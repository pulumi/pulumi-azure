# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'AppConnectionAuthentication',
    'AppConnectionSecretStore',
    'AppServiceAuthSettings',
    'AppServiceAuthSettingsActiveDirectory',
    'AppServiceAuthSettingsFacebook',
    'AppServiceAuthSettingsGoogle',
    'AppServiceAuthSettingsMicrosoft',
    'AppServiceAuthSettingsTwitter',
    'AppServiceBackup',
    'AppServiceBackupSchedule',
    'AppServiceConnectionString',
    'AppServiceIdentity',
    'AppServiceLogs',
    'AppServiceLogsApplicationLogs',
    'AppServiceLogsApplicationLogsAzureBlobStorage',
    'AppServiceLogsHttpLogs',
    'AppServiceLogsHttpLogsAzureBlobStorage',
    'AppServiceLogsHttpLogsFileSystem',
    'AppServiceSiteConfig',
    'AppServiceSiteConfigCors',
    'AppServiceSiteConfigIpRestriction',
    'AppServiceSiteConfigIpRestrictionHeaders',
    'AppServiceSiteConfigScmIpRestriction',
    'AppServiceSiteConfigScmIpRestrictionHeaders',
    'AppServiceSiteCredential',
    'AppServiceSourceControl',
    'AppServiceStorageAccount',
    'CertificateOrderCertificate',
    'ConnectionAuthentication',
    'ConnectionSecretStore',
    'EnvironmentClusterSetting',
    'EnvironmentV3ClusterSetting',
    'EnvironmentV3InboundNetworkDependency',
    'FunctionAppAuthSettings',
    'FunctionAppAuthSettingsActiveDirectory',
    'FunctionAppAuthSettingsFacebook',
    'FunctionAppAuthSettingsGoogle',
    'FunctionAppAuthSettingsMicrosoft',
    'FunctionAppAuthSettingsTwitter',
    'FunctionAppConnectionString',
    'FunctionAppFunctionFile',
    'FunctionAppIdentity',
    'FunctionAppSiteConfig',
    'FunctionAppSiteConfigCors',
    'FunctionAppSiteConfigIpRestriction',
    'FunctionAppSiteConfigIpRestrictionHeaders',
    'FunctionAppSiteConfigScmIpRestriction',
    'FunctionAppSiteConfigScmIpRestrictionHeaders',
    'FunctionAppSiteCredential',
    'FunctionAppSlotAuthSettings',
    'FunctionAppSlotAuthSettingsActiveDirectory',
    'FunctionAppSlotAuthSettingsFacebook',
    'FunctionAppSlotAuthSettingsGoogle',
    'FunctionAppSlotAuthSettingsMicrosoft',
    'FunctionAppSlotAuthSettingsTwitter',
    'FunctionAppSlotConnectionString',
    'FunctionAppSlotIdentity',
    'FunctionAppSlotSiteConfig',
    'FunctionAppSlotSiteConfigCors',
    'FunctionAppSlotSiteConfigIpRestriction',
    'FunctionAppSlotSiteConfigIpRestrictionHeaders',
    'FunctionAppSlotSiteConfigScmIpRestriction',
    'FunctionAppSlotSiteConfigScmIpRestrictionHeaders',
    'FunctionAppSlotSiteCredential',
    'FunctionAppSourceControl',
    'LinuxFunctionAppAuthSettings',
    'LinuxFunctionAppAuthSettingsActiveDirectory',
    'LinuxFunctionAppAuthSettingsFacebook',
    'LinuxFunctionAppAuthSettingsGithub',
    'LinuxFunctionAppAuthSettingsGoogle',
    'LinuxFunctionAppAuthSettingsMicrosoft',
    'LinuxFunctionAppAuthSettingsTwitter',
    'LinuxFunctionAppAuthSettingsV2',
    'LinuxFunctionAppAuthSettingsV2ActiveDirectoryV2',
    'LinuxFunctionAppAuthSettingsV2AppleV2',
    'LinuxFunctionAppAuthSettingsV2AzureStaticWebAppV2',
    'LinuxFunctionAppAuthSettingsV2CustomOidcV2',
    'LinuxFunctionAppAuthSettingsV2FacebookV2',
    'LinuxFunctionAppAuthSettingsV2GithubV2',
    'LinuxFunctionAppAuthSettingsV2GoogleV2',
    'LinuxFunctionAppAuthSettingsV2Login',
    'LinuxFunctionAppAuthSettingsV2MicrosoftV2',
    'LinuxFunctionAppAuthSettingsV2TwitterV2',
    'LinuxFunctionAppBackup',
    'LinuxFunctionAppBackupSchedule',
    'LinuxFunctionAppConnectionString',
    'LinuxFunctionAppIdentity',
    'LinuxFunctionAppSiteConfig',
    'LinuxFunctionAppSiteConfigAppServiceLogs',
    'LinuxFunctionAppSiteConfigApplicationStack',
    'LinuxFunctionAppSiteConfigApplicationStackDocker',
    'LinuxFunctionAppSiteConfigCors',
    'LinuxFunctionAppSiteConfigIpRestriction',
    'LinuxFunctionAppSiteConfigIpRestrictionHeaders',
    'LinuxFunctionAppSiteConfigScmIpRestriction',
    'LinuxFunctionAppSiteConfigScmIpRestrictionHeaders',
    'LinuxFunctionAppSiteCredential',
    'LinuxFunctionAppSlotAuthSettings',
    'LinuxFunctionAppSlotAuthSettingsActiveDirectory',
    'LinuxFunctionAppSlotAuthSettingsFacebook',
    'LinuxFunctionAppSlotAuthSettingsGithub',
    'LinuxFunctionAppSlotAuthSettingsGoogle',
    'LinuxFunctionAppSlotAuthSettingsMicrosoft',
    'LinuxFunctionAppSlotAuthSettingsTwitter',
    'LinuxFunctionAppSlotAuthSettingsV2',
    'LinuxFunctionAppSlotAuthSettingsV2ActiveDirectoryV2',
    'LinuxFunctionAppSlotAuthSettingsV2AppleV2',
    'LinuxFunctionAppSlotAuthSettingsV2AzureStaticWebAppV2',
    'LinuxFunctionAppSlotAuthSettingsV2CustomOidcV2',
    'LinuxFunctionAppSlotAuthSettingsV2FacebookV2',
    'LinuxFunctionAppSlotAuthSettingsV2GithubV2',
    'LinuxFunctionAppSlotAuthSettingsV2GoogleV2',
    'LinuxFunctionAppSlotAuthSettingsV2Login',
    'LinuxFunctionAppSlotAuthSettingsV2MicrosoftV2',
    'LinuxFunctionAppSlotAuthSettingsV2TwitterV2',
    'LinuxFunctionAppSlotBackup',
    'LinuxFunctionAppSlotBackupSchedule',
    'LinuxFunctionAppSlotConnectionString',
    'LinuxFunctionAppSlotIdentity',
    'LinuxFunctionAppSlotSiteConfig',
    'LinuxFunctionAppSlotSiteConfigAppServiceLogs',
    'LinuxFunctionAppSlotSiteConfigApplicationStack',
    'LinuxFunctionAppSlotSiteConfigApplicationStackDocker',
    'LinuxFunctionAppSlotSiteConfigCors',
    'LinuxFunctionAppSlotSiteConfigIpRestriction',
    'LinuxFunctionAppSlotSiteConfigIpRestrictionHeaders',
    'LinuxFunctionAppSlotSiteConfigScmIpRestriction',
    'LinuxFunctionAppSlotSiteConfigScmIpRestrictionHeaders',
    'LinuxFunctionAppSlotSiteCredential',
    'LinuxFunctionAppSlotStorageAccount',
    'LinuxFunctionAppStickySettings',
    'LinuxFunctionAppStorageAccount',
    'LinuxWebAppAuthSettings',
    'LinuxWebAppAuthSettingsActiveDirectory',
    'LinuxWebAppAuthSettingsFacebook',
    'LinuxWebAppAuthSettingsGithub',
    'LinuxWebAppAuthSettingsGoogle',
    'LinuxWebAppAuthSettingsMicrosoft',
    'LinuxWebAppAuthSettingsTwitter',
    'LinuxWebAppAuthSettingsV2',
    'LinuxWebAppAuthSettingsV2ActiveDirectoryV2',
    'LinuxWebAppAuthSettingsV2AppleV2',
    'LinuxWebAppAuthSettingsV2AzureStaticWebAppV2',
    'LinuxWebAppAuthSettingsV2CustomOidcV2',
    'LinuxWebAppAuthSettingsV2FacebookV2',
    'LinuxWebAppAuthSettingsV2GithubV2',
    'LinuxWebAppAuthSettingsV2GoogleV2',
    'LinuxWebAppAuthSettingsV2Login',
    'LinuxWebAppAuthSettingsV2MicrosoftV2',
    'LinuxWebAppAuthSettingsV2TwitterV2',
    'LinuxWebAppBackup',
    'LinuxWebAppBackupSchedule',
    'LinuxWebAppConnectionString',
    'LinuxWebAppIdentity',
    'LinuxWebAppLogs',
    'LinuxWebAppLogsApplicationLogs',
    'LinuxWebAppLogsApplicationLogsAzureBlobStorage',
    'LinuxWebAppLogsHttpLogs',
    'LinuxWebAppLogsHttpLogsAzureBlobStorage',
    'LinuxWebAppLogsHttpLogsFileSystem',
    'LinuxWebAppSiteConfig',
    'LinuxWebAppSiteConfigApplicationStack',
    'LinuxWebAppSiteConfigAutoHealSetting',
    'LinuxWebAppSiteConfigAutoHealSettingAction',
    'LinuxWebAppSiteConfigAutoHealSettingTrigger',
    'LinuxWebAppSiteConfigAutoHealSettingTriggerRequests',
    'LinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequest',
    'LinuxWebAppSiteConfigAutoHealSettingTriggerStatusCode',
    'LinuxWebAppSiteConfigCors',
    'LinuxWebAppSiteConfigIpRestriction',
    'LinuxWebAppSiteConfigIpRestrictionHeaders',
    'LinuxWebAppSiteConfigScmIpRestriction',
    'LinuxWebAppSiteConfigScmIpRestrictionHeaders',
    'LinuxWebAppSiteCredential',
    'LinuxWebAppSlotAuthSettings',
    'LinuxWebAppSlotAuthSettingsActiveDirectory',
    'LinuxWebAppSlotAuthSettingsFacebook',
    'LinuxWebAppSlotAuthSettingsGithub',
    'LinuxWebAppSlotAuthSettingsGoogle',
    'LinuxWebAppSlotAuthSettingsMicrosoft',
    'LinuxWebAppSlotAuthSettingsTwitter',
    'LinuxWebAppSlotAuthSettingsV2',
    'LinuxWebAppSlotAuthSettingsV2ActiveDirectoryV2',
    'LinuxWebAppSlotAuthSettingsV2AppleV2',
    'LinuxWebAppSlotAuthSettingsV2AzureStaticWebAppV2',
    'LinuxWebAppSlotAuthSettingsV2CustomOidcV2',
    'LinuxWebAppSlotAuthSettingsV2FacebookV2',
    'LinuxWebAppSlotAuthSettingsV2GithubV2',
    'LinuxWebAppSlotAuthSettingsV2GoogleV2',
    'LinuxWebAppSlotAuthSettingsV2Login',
    'LinuxWebAppSlotAuthSettingsV2MicrosoftV2',
    'LinuxWebAppSlotAuthSettingsV2TwitterV2',
    'LinuxWebAppSlotBackup',
    'LinuxWebAppSlotBackupSchedule',
    'LinuxWebAppSlotConnectionString',
    'LinuxWebAppSlotIdentity',
    'LinuxWebAppSlotLogs',
    'LinuxWebAppSlotLogsApplicationLogs',
    'LinuxWebAppSlotLogsApplicationLogsAzureBlobStorage',
    'LinuxWebAppSlotLogsHttpLogs',
    'LinuxWebAppSlotLogsHttpLogsAzureBlobStorage',
    'LinuxWebAppSlotLogsHttpLogsFileSystem',
    'LinuxWebAppSlotSiteConfig',
    'LinuxWebAppSlotSiteConfigApplicationStack',
    'LinuxWebAppSlotSiteConfigAutoHealSetting',
    'LinuxWebAppSlotSiteConfigAutoHealSettingAction',
    'LinuxWebAppSlotSiteConfigAutoHealSettingTrigger',
    'LinuxWebAppSlotSiteConfigAutoHealSettingTriggerRequests',
    'LinuxWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequest',
    'LinuxWebAppSlotSiteConfigAutoHealSettingTriggerStatusCode',
    'LinuxWebAppSlotSiteConfigCors',
    'LinuxWebAppSlotSiteConfigIpRestriction',
    'LinuxWebAppSlotSiteConfigIpRestrictionHeaders',
    'LinuxWebAppSlotSiteConfigScmIpRestriction',
    'LinuxWebAppSlotSiteConfigScmIpRestrictionHeaders',
    'LinuxWebAppSlotSiteCredential',
    'LinuxWebAppSlotStorageAccount',
    'LinuxWebAppStickySettings',
    'LinuxWebAppStorageAccount',
    'PlanSku',
    'SlotAuthSettings',
    'SlotAuthSettingsActiveDirectory',
    'SlotAuthSettingsFacebook',
    'SlotAuthSettingsGoogle',
    'SlotAuthSettingsMicrosoft',
    'SlotAuthSettingsTwitter',
    'SlotConnectionString',
    'SlotIdentity',
    'SlotLogs',
    'SlotLogsApplicationLogs',
    'SlotLogsApplicationLogsAzureBlobStorage',
    'SlotLogsHttpLogs',
    'SlotLogsHttpLogsAzureBlobStorage',
    'SlotLogsHttpLogsFileSystem',
    'SlotSiteConfig',
    'SlotSiteConfigCors',
    'SlotSiteConfigIpRestriction',
    'SlotSiteConfigIpRestrictionHeaders',
    'SlotSiteConfigScmIpRestriction',
    'SlotSiteConfigScmIpRestrictionHeaders',
    'SlotSiteCredential',
    'SlotStorageAccount',
    'SourceControlGithubActionConfiguration',
    'SourceControlGithubActionConfigurationCodeConfiguration',
    'SourceControlGithubActionConfigurationContainerConfiguration',
    'SourceControlSlotGithubActionConfiguration',
    'SourceControlSlotGithubActionConfigurationCodeConfiguration',
    'SourceControlSlotGithubActionConfigurationContainerConfiguration',
    'StaticSiteIdentity',
    'WindowsFunctionAppAuthSettings',
    'WindowsFunctionAppAuthSettingsActiveDirectory',
    'WindowsFunctionAppAuthSettingsFacebook',
    'WindowsFunctionAppAuthSettingsGithub',
    'WindowsFunctionAppAuthSettingsGoogle',
    'WindowsFunctionAppAuthSettingsMicrosoft',
    'WindowsFunctionAppAuthSettingsTwitter',
    'WindowsFunctionAppAuthSettingsV2',
    'WindowsFunctionAppAuthSettingsV2ActiveDirectoryV2',
    'WindowsFunctionAppAuthSettingsV2AppleV2',
    'WindowsFunctionAppAuthSettingsV2AzureStaticWebAppV2',
    'WindowsFunctionAppAuthSettingsV2CustomOidcV2',
    'WindowsFunctionAppAuthSettingsV2FacebookV2',
    'WindowsFunctionAppAuthSettingsV2GithubV2',
    'WindowsFunctionAppAuthSettingsV2GoogleV2',
    'WindowsFunctionAppAuthSettingsV2Login',
    'WindowsFunctionAppAuthSettingsV2MicrosoftV2',
    'WindowsFunctionAppAuthSettingsV2TwitterV2',
    'WindowsFunctionAppBackup',
    'WindowsFunctionAppBackupSchedule',
    'WindowsFunctionAppConnectionString',
    'WindowsFunctionAppIdentity',
    'WindowsFunctionAppSiteConfig',
    'WindowsFunctionAppSiteConfigAppServiceLogs',
    'WindowsFunctionAppSiteConfigApplicationStack',
    'WindowsFunctionAppSiteConfigCors',
    'WindowsFunctionAppSiteConfigIpRestriction',
    'WindowsFunctionAppSiteConfigIpRestrictionHeaders',
    'WindowsFunctionAppSiteConfigScmIpRestriction',
    'WindowsFunctionAppSiteConfigScmIpRestrictionHeaders',
    'WindowsFunctionAppSiteCredential',
    'WindowsFunctionAppSlotAuthSettings',
    'WindowsFunctionAppSlotAuthSettingsActiveDirectory',
    'WindowsFunctionAppSlotAuthSettingsFacebook',
    'WindowsFunctionAppSlotAuthSettingsGithub',
    'WindowsFunctionAppSlotAuthSettingsGoogle',
    'WindowsFunctionAppSlotAuthSettingsMicrosoft',
    'WindowsFunctionAppSlotAuthSettingsTwitter',
    'WindowsFunctionAppSlotAuthSettingsV2',
    'WindowsFunctionAppSlotAuthSettingsV2ActiveDirectoryV2',
    'WindowsFunctionAppSlotAuthSettingsV2AppleV2',
    'WindowsFunctionAppSlotAuthSettingsV2AzureStaticWebAppV2',
    'WindowsFunctionAppSlotAuthSettingsV2CustomOidcV2',
    'WindowsFunctionAppSlotAuthSettingsV2FacebookV2',
    'WindowsFunctionAppSlotAuthSettingsV2GithubV2',
    'WindowsFunctionAppSlotAuthSettingsV2GoogleV2',
    'WindowsFunctionAppSlotAuthSettingsV2Login',
    'WindowsFunctionAppSlotAuthSettingsV2MicrosoftV2',
    'WindowsFunctionAppSlotAuthSettingsV2TwitterV2',
    'WindowsFunctionAppSlotBackup',
    'WindowsFunctionAppSlotBackupSchedule',
    'WindowsFunctionAppSlotConnectionString',
    'WindowsFunctionAppSlotIdentity',
    'WindowsFunctionAppSlotSiteConfig',
    'WindowsFunctionAppSlotSiteConfigAppServiceLogs',
    'WindowsFunctionAppSlotSiteConfigApplicationStack',
    'WindowsFunctionAppSlotSiteConfigCors',
    'WindowsFunctionAppSlotSiteConfigIpRestriction',
    'WindowsFunctionAppSlotSiteConfigIpRestrictionHeaders',
    'WindowsFunctionAppSlotSiteConfigScmIpRestriction',
    'WindowsFunctionAppSlotSiteConfigScmIpRestrictionHeaders',
    'WindowsFunctionAppSlotSiteCredential',
    'WindowsFunctionAppSlotStorageAccount',
    'WindowsFunctionAppStickySettings',
    'WindowsFunctionAppStorageAccount',
    'WindowsWebAppAuthSettings',
    'WindowsWebAppAuthSettingsActiveDirectory',
    'WindowsWebAppAuthSettingsFacebook',
    'WindowsWebAppAuthSettingsGithub',
    'WindowsWebAppAuthSettingsGoogle',
    'WindowsWebAppAuthSettingsMicrosoft',
    'WindowsWebAppAuthSettingsTwitter',
    'WindowsWebAppAuthSettingsV2',
    'WindowsWebAppAuthSettingsV2ActiveDirectoryV2',
    'WindowsWebAppAuthSettingsV2AppleV2',
    'WindowsWebAppAuthSettingsV2AzureStaticWebAppV2',
    'WindowsWebAppAuthSettingsV2CustomOidcV2',
    'WindowsWebAppAuthSettingsV2FacebookV2',
    'WindowsWebAppAuthSettingsV2GithubV2',
    'WindowsWebAppAuthSettingsV2GoogleV2',
    'WindowsWebAppAuthSettingsV2Login',
    'WindowsWebAppAuthSettingsV2MicrosoftV2',
    'WindowsWebAppAuthSettingsV2TwitterV2',
    'WindowsWebAppBackup',
    'WindowsWebAppBackupSchedule',
    'WindowsWebAppConnectionString',
    'WindowsWebAppIdentity',
    'WindowsWebAppLogs',
    'WindowsWebAppLogsApplicationLogs',
    'WindowsWebAppLogsApplicationLogsAzureBlobStorage',
    'WindowsWebAppLogsHttpLogs',
    'WindowsWebAppLogsHttpLogsAzureBlobStorage',
    'WindowsWebAppLogsHttpLogsFileSystem',
    'WindowsWebAppSiteConfig',
    'WindowsWebAppSiteConfigApplicationStack',
    'WindowsWebAppSiteConfigAutoHealSetting',
    'WindowsWebAppSiteConfigAutoHealSettingAction',
    'WindowsWebAppSiteConfigAutoHealSettingActionCustomAction',
    'WindowsWebAppSiteConfigAutoHealSettingTrigger',
    'WindowsWebAppSiteConfigAutoHealSettingTriggerRequests',
    'WindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequest',
    'WindowsWebAppSiteConfigAutoHealSettingTriggerStatusCode',
    'WindowsWebAppSiteConfigCors',
    'WindowsWebAppSiteConfigIpRestriction',
    'WindowsWebAppSiteConfigIpRestrictionHeaders',
    'WindowsWebAppSiteConfigScmIpRestriction',
    'WindowsWebAppSiteConfigScmIpRestrictionHeaders',
    'WindowsWebAppSiteConfigVirtualApplication',
    'WindowsWebAppSiteConfigVirtualApplicationVirtualDirectory',
    'WindowsWebAppSiteCredential',
    'WindowsWebAppSlotAuthSettings',
    'WindowsWebAppSlotAuthSettingsActiveDirectory',
    'WindowsWebAppSlotAuthSettingsFacebook',
    'WindowsWebAppSlotAuthSettingsGithub',
    'WindowsWebAppSlotAuthSettingsGoogle',
    'WindowsWebAppSlotAuthSettingsMicrosoft',
    'WindowsWebAppSlotAuthSettingsTwitter',
    'WindowsWebAppSlotAuthSettingsV2',
    'WindowsWebAppSlotAuthSettingsV2ActiveDirectoryV2',
    'WindowsWebAppSlotAuthSettingsV2AppleV2',
    'WindowsWebAppSlotAuthSettingsV2AzureStaticWebAppV2',
    'WindowsWebAppSlotAuthSettingsV2CustomOidcV2',
    'WindowsWebAppSlotAuthSettingsV2FacebookV2',
    'WindowsWebAppSlotAuthSettingsV2GithubV2',
    'WindowsWebAppSlotAuthSettingsV2GoogleV2',
    'WindowsWebAppSlotAuthSettingsV2Login',
    'WindowsWebAppSlotAuthSettingsV2MicrosoftV2',
    'WindowsWebAppSlotAuthSettingsV2TwitterV2',
    'WindowsWebAppSlotBackup',
    'WindowsWebAppSlotBackupSchedule',
    'WindowsWebAppSlotConnectionString',
    'WindowsWebAppSlotIdentity',
    'WindowsWebAppSlotLogs',
    'WindowsWebAppSlotLogsApplicationLogs',
    'WindowsWebAppSlotLogsApplicationLogsAzureBlobStorage',
    'WindowsWebAppSlotLogsHttpLogs',
    'WindowsWebAppSlotLogsHttpLogsAzureBlobStorage',
    'WindowsWebAppSlotLogsHttpLogsFileSystem',
    'WindowsWebAppSlotSiteConfig',
    'WindowsWebAppSlotSiteConfigApplicationStack',
    'WindowsWebAppSlotSiteConfigAutoHealSetting',
    'WindowsWebAppSlotSiteConfigAutoHealSettingAction',
    'WindowsWebAppSlotSiteConfigAutoHealSettingActionCustomAction',
    'WindowsWebAppSlotSiteConfigAutoHealSettingTrigger',
    'WindowsWebAppSlotSiteConfigAutoHealSettingTriggerRequests',
    'WindowsWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequest',
    'WindowsWebAppSlotSiteConfigAutoHealSettingTriggerStatusCode',
    'WindowsWebAppSlotSiteConfigCors',
    'WindowsWebAppSlotSiteConfigIpRestriction',
    'WindowsWebAppSlotSiteConfigIpRestrictionHeaders',
    'WindowsWebAppSlotSiteConfigScmIpRestriction',
    'WindowsWebAppSlotSiteConfigScmIpRestrictionHeaders',
    'WindowsWebAppSlotSiteConfigVirtualApplication',
    'WindowsWebAppSlotSiteConfigVirtualApplicationVirtualDirectory',
    'WindowsWebAppSlotSiteCredential',
    'WindowsWebAppSlotStorageAccount',
    'WindowsWebAppStickySettings',
    'WindowsWebAppStorageAccount',
    'GetAppServiceConnectionStringResult',
    'GetAppServiceEnvironmentClusterSettingResult',
    'GetAppServicePlanSkuResult',
    'GetAppServiceSiteConfigResult',
    'GetAppServiceSiteConfigCorResult',
    'GetAppServiceSiteConfigIpRestrictionResult',
    'GetAppServiceSiteConfigIpRestrictionHeadersResult',
    'GetAppServiceSiteConfigScmIpRestrictionResult',
    'GetAppServiceSiteConfigScmIpRestrictionHeadersResult',
    'GetAppServiceSiteCredentialResult',
    'GetAppServiceSourceControlResult',
    'GetCertificateOrderCertificateResult',
    'GetEnvironmentV3ClusterSettingResult',
    'GetEnvironmentV3InboundNetworkDependencyResult',
    'GetFunctionAppConnectionStringResult',
    'GetFunctionAppIdentityResult',
    'GetFunctionAppSiteConfigResult',
    'GetFunctionAppSiteConfigCorsResult',
    'GetFunctionAppSiteConfigIpRestrictionResult',
    'GetFunctionAppSiteConfigIpRestrictionHeadersResult',
    'GetFunctionAppSiteConfigScmIpRestrictionResult',
    'GetFunctionAppSiteConfigScmIpRestrictionHeadersResult',
    'GetFunctionAppSiteCredentialResult',
    'GetFunctionAppSourceControlResult',
    'GetLinuxFunctionAppAuthSettingResult',
    'GetLinuxFunctionAppAuthSettingActiveDirectoryResult',
    'GetLinuxFunctionAppAuthSettingFacebookResult',
    'GetLinuxFunctionAppAuthSettingGithubResult',
    'GetLinuxFunctionAppAuthSettingGoogleResult',
    'GetLinuxFunctionAppAuthSettingMicrosoftResult',
    'GetLinuxFunctionAppAuthSettingTwitterResult',
    'GetLinuxFunctionAppAuthSettingsV2Result',
    'GetLinuxFunctionAppAuthSettingsV2ActiveDirectoryV2Result',
    'GetLinuxFunctionAppAuthSettingsV2AppleV2Result',
    'GetLinuxFunctionAppAuthSettingsV2AzureStaticWebAppV2Result',
    'GetLinuxFunctionAppAuthSettingsV2CustomOidcV2Result',
    'GetLinuxFunctionAppAuthSettingsV2FacebookV2Result',
    'GetLinuxFunctionAppAuthSettingsV2GithubV2Result',
    'GetLinuxFunctionAppAuthSettingsV2GoogleV2Result',
    'GetLinuxFunctionAppAuthSettingsV2LoginResult',
    'GetLinuxFunctionAppAuthSettingsV2MicrosoftV2Result',
    'GetLinuxFunctionAppAuthSettingsV2TwitterV2Result',
    'GetLinuxFunctionAppBackupResult',
    'GetLinuxFunctionAppBackupScheduleResult',
    'GetLinuxFunctionAppConnectionStringResult',
    'GetLinuxFunctionAppIdentityResult',
    'GetLinuxFunctionAppSiteConfigResult',
    'GetLinuxFunctionAppSiteConfigAppServiceLogResult',
    'GetLinuxFunctionAppSiteConfigApplicationStackResult',
    'GetLinuxFunctionAppSiteConfigApplicationStackDockerResult',
    'GetLinuxFunctionAppSiteConfigCorResult',
    'GetLinuxFunctionAppSiteConfigIpRestrictionResult',
    'GetLinuxFunctionAppSiteConfigIpRestrictionHeaderResult',
    'GetLinuxFunctionAppSiteConfigScmIpRestrictionResult',
    'GetLinuxFunctionAppSiteConfigScmIpRestrictionHeaderResult',
    'GetLinuxFunctionAppSiteCredentialResult',
    'GetLinuxFunctionAppStickySettingResult',
    'GetLinuxWebAppAuthSettingResult',
    'GetLinuxWebAppAuthSettingActiveDirectoryResult',
    'GetLinuxWebAppAuthSettingFacebookResult',
    'GetLinuxWebAppAuthSettingGithubResult',
    'GetLinuxWebAppAuthSettingGoogleResult',
    'GetLinuxWebAppAuthSettingMicrosoftResult',
    'GetLinuxWebAppAuthSettingTwitterResult',
    'GetLinuxWebAppAuthSettingsV2Result',
    'GetLinuxWebAppAuthSettingsV2ActiveDirectoryV2Result',
    'GetLinuxWebAppAuthSettingsV2AppleV2Result',
    'GetLinuxWebAppAuthSettingsV2AzureStaticWebAppV2Result',
    'GetLinuxWebAppAuthSettingsV2CustomOidcV2Result',
    'GetLinuxWebAppAuthSettingsV2FacebookV2Result',
    'GetLinuxWebAppAuthSettingsV2GithubV2Result',
    'GetLinuxWebAppAuthSettingsV2GoogleV2Result',
    'GetLinuxWebAppAuthSettingsV2LoginResult',
    'GetLinuxWebAppAuthSettingsV2MicrosoftV2Result',
    'GetLinuxWebAppAuthSettingsV2TwitterV2Result',
    'GetLinuxWebAppBackupResult',
    'GetLinuxWebAppBackupScheduleResult',
    'GetLinuxWebAppConnectionStringResult',
    'GetLinuxWebAppIdentityResult',
    'GetLinuxWebAppLogResult',
    'GetLinuxWebAppLogApplicationLogResult',
    'GetLinuxWebAppLogApplicationLogAzureBlobStorageResult',
    'GetLinuxWebAppLogHttpLogResult',
    'GetLinuxWebAppLogHttpLogAzureBlobStorageResult',
    'GetLinuxWebAppLogHttpLogFileSystemResult',
    'GetLinuxWebAppSiteConfigResult',
    'GetLinuxWebAppSiteConfigApplicationStackResult',
    'GetLinuxWebAppSiteConfigAutoHealSettingResult',
    'GetLinuxWebAppSiteConfigAutoHealSettingActionResult',
    'GetLinuxWebAppSiteConfigAutoHealSettingTriggerResult',
    'GetLinuxWebAppSiteConfigAutoHealSettingTriggerRequestResult',
    'GetLinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequestResult',
    'GetLinuxWebAppSiteConfigAutoHealSettingTriggerStatusCodeResult',
    'GetLinuxWebAppSiteConfigCorResult',
    'GetLinuxWebAppSiteConfigIpRestrictionResult',
    'GetLinuxWebAppSiteConfigIpRestrictionHeaderResult',
    'GetLinuxWebAppSiteConfigScmIpRestrictionResult',
    'GetLinuxWebAppSiteConfigScmIpRestrictionHeaderResult',
    'GetLinuxWebAppSiteCredentialResult',
    'GetLinuxWebAppStickySettingResult',
    'GetLinuxWebAppStorageAccountResult',
    'GetWindowsFunctionAppAuthSettingResult',
    'GetWindowsFunctionAppAuthSettingActiveDirectoryResult',
    'GetWindowsFunctionAppAuthSettingFacebookResult',
    'GetWindowsFunctionAppAuthSettingGithubResult',
    'GetWindowsFunctionAppAuthSettingGoogleResult',
    'GetWindowsFunctionAppAuthSettingMicrosoftResult',
    'GetWindowsFunctionAppAuthSettingTwitterResult',
    'GetWindowsFunctionAppAuthSettingsV2Result',
    'GetWindowsFunctionAppAuthSettingsV2ActiveDirectoryV2Result',
    'GetWindowsFunctionAppAuthSettingsV2AppleV2Result',
    'GetWindowsFunctionAppAuthSettingsV2AzureStaticWebAppV2Result',
    'GetWindowsFunctionAppAuthSettingsV2CustomOidcV2Result',
    'GetWindowsFunctionAppAuthSettingsV2FacebookV2Result',
    'GetWindowsFunctionAppAuthSettingsV2GithubV2Result',
    'GetWindowsFunctionAppAuthSettingsV2GoogleV2Result',
    'GetWindowsFunctionAppAuthSettingsV2LoginResult',
    'GetWindowsFunctionAppAuthSettingsV2MicrosoftV2Result',
    'GetWindowsFunctionAppAuthSettingsV2TwitterV2Result',
    'GetWindowsFunctionAppBackupResult',
    'GetWindowsFunctionAppBackupScheduleResult',
    'GetWindowsFunctionAppConnectionStringResult',
    'GetWindowsFunctionAppIdentityResult',
    'GetWindowsFunctionAppSiteConfigResult',
    'GetWindowsFunctionAppSiteConfigAppServiceLogResult',
    'GetWindowsFunctionAppSiteConfigApplicationStackResult',
    'GetWindowsFunctionAppSiteConfigCorResult',
    'GetWindowsFunctionAppSiteConfigIpRestrictionResult',
    'GetWindowsFunctionAppSiteConfigIpRestrictionHeaderResult',
    'GetWindowsFunctionAppSiteConfigScmIpRestrictionResult',
    'GetWindowsFunctionAppSiteConfigScmIpRestrictionHeaderResult',
    'GetWindowsFunctionAppSiteCredentialResult',
    'GetWindowsFunctionAppStickySettingResult',
    'GetWindowsWebAppAuthSettingResult',
    'GetWindowsWebAppAuthSettingActiveDirectoryResult',
    'GetWindowsWebAppAuthSettingFacebookResult',
    'GetWindowsWebAppAuthSettingGithubResult',
    'GetWindowsWebAppAuthSettingGoogleResult',
    'GetWindowsWebAppAuthSettingMicrosoftResult',
    'GetWindowsWebAppAuthSettingTwitterResult',
    'GetWindowsWebAppAuthSettingsV2Result',
    'GetWindowsWebAppAuthSettingsV2ActiveDirectoryV2Result',
    'GetWindowsWebAppAuthSettingsV2AppleV2Result',
    'GetWindowsWebAppAuthSettingsV2AzureStaticWebAppV2Result',
    'GetWindowsWebAppAuthSettingsV2CustomOidcV2Result',
    'GetWindowsWebAppAuthSettingsV2FacebookV2Result',
    'GetWindowsWebAppAuthSettingsV2GithubV2Result',
    'GetWindowsWebAppAuthSettingsV2GoogleV2Result',
    'GetWindowsWebAppAuthSettingsV2LoginResult',
    'GetWindowsWebAppAuthSettingsV2MicrosoftV2Result',
    'GetWindowsWebAppAuthSettingsV2TwitterV2Result',
    'GetWindowsWebAppBackupResult',
    'GetWindowsWebAppBackupScheduleResult',
    'GetWindowsWebAppConnectionStringResult',
    'GetWindowsWebAppIdentityResult',
    'GetWindowsWebAppLogResult',
    'GetWindowsWebAppLogApplicationLogResult',
    'GetWindowsWebAppLogApplicationLogAzureBlobStorageResult',
    'GetWindowsWebAppLogHttpLogResult',
    'GetWindowsWebAppLogHttpLogAzureBlobStorageResult',
    'GetWindowsWebAppLogHttpLogFileSystemResult',
    'GetWindowsWebAppSiteConfigResult',
    'GetWindowsWebAppSiteConfigApplicationStackResult',
    'GetWindowsWebAppSiteConfigAutoHealSettingResult',
    'GetWindowsWebAppSiteConfigAutoHealSettingActionResult',
    'GetWindowsWebAppSiteConfigAutoHealSettingActionCustomActionResult',
    'GetWindowsWebAppSiteConfigAutoHealSettingTriggerResult',
    'GetWindowsWebAppSiteConfigAutoHealSettingTriggerRequestResult',
    'GetWindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequestResult',
    'GetWindowsWebAppSiteConfigAutoHealSettingTriggerStatusCodeResult',
    'GetWindowsWebAppSiteConfigCorResult',
    'GetWindowsWebAppSiteConfigIpRestrictionResult',
    'GetWindowsWebAppSiteConfigIpRestrictionHeaderResult',
    'GetWindowsWebAppSiteConfigScmIpRestrictionResult',
    'GetWindowsWebAppSiteConfigScmIpRestrictionHeaderResult',
    'GetWindowsWebAppSiteConfigVirtualApplicationResult',
    'GetWindowsWebAppSiteConfigVirtualApplicationVirtualDirectoryResult',
    'GetWindowsWebAppSiteCredentialResult',
    'GetWindowsWebAppStickySettingResult',
    'GetWindowsWebAppStorageAccountResult',
]

@pulumi.output_type
class AppConnectionAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "subscriptionId":
            suggest = "subscription_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppConnectionAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppConnectionAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppConnectionAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 certificate: Optional[str] = None,
                 client_id: Optional[str] = None,
                 name: Optional[str] = None,
                 principal_id: Optional[str] = None,
                 secret: Optional[str] = None,
                 subscription_id: Optional[str] = None):
        """
        :param str type: The authentication type. Possible values are `systemAssignedIdentity`, `userAssignedIdentity`, `servicePrincipalSecret`, `servicePrincipalCertificate`, `secret`. Changing this forces a new resource to be created.
        :param str certificate: Service principal certificate for `servicePrincipal` auth. Should be specified when `type` is set to `servicePrincipalCertificate`.
        :param str client_id: Client ID for `userAssignedIdentity` or `servicePrincipal` auth. Should be specified when `type` is set to `servicePrincipalSecret` or `servicePrincipalCertificate`. When `type` is set to `userAssignedIdentity`, `client_id` and `subscription_id` should be either both specified or both not specified.
        :param str name: Username or account name for secret auth. `name` and `secret` should be either both specified or both not specified when `type` is set to `secret`.
        :param str principal_id: Principal ID for `servicePrincipal` auth. Should be specified when `type` is set to `servicePrincipalSecret` or `servicePrincipalCertificate`.
        :param str secret: Password or account key for secret auth. `secret` and `name` should be either both specified or both not specified when `type` is set to `secret`.
        :param str subscription_id: Subscription ID for `userAssignedIdentity`. `subscription_id` and `client_id` should be either both specified or both not specified.
        """
        pulumi.set(__self__, "type", type)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The authentication type. Possible values are `systemAssignedIdentity`, `userAssignedIdentity`, `servicePrincipalSecret`, `servicePrincipalCertificate`, `secret`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[str]:
        """
        Service principal certificate for `servicePrincipal` auth. Should be specified when `type` is set to `servicePrincipalCertificate`.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        Client ID for `userAssignedIdentity` or `servicePrincipal` auth. Should be specified when `type` is set to `servicePrincipalSecret` or `servicePrincipalCertificate`. When `type` is set to `userAssignedIdentity`, `client_id` and `subscription_id` should be either both specified or both not specified.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Username or account name for secret auth. `name` and `secret` should be either both specified or both not specified when `type` is set to `secret`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        """
        Principal ID for `servicePrincipal` auth. Should be specified when `type` is set to `servicePrincipalSecret` or `servicePrincipalCertificate`.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter
    def secret(self) -> Optional[str]:
        """
        Password or account key for secret auth. `secret` and `name` should be either both specified or both not specified when `type` is set to `secret`.
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[str]:
        """
        Subscription ID for `userAssignedIdentity`. `subscription_id` and `client_id` should be either both specified or both not specified.
        """
        return pulumi.get(self, "subscription_id")


@pulumi.output_type
class AppConnectionSecretStore(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVaultId":
            suggest = "key_vault_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppConnectionSecretStore. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppConnectionSecretStore.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppConnectionSecretStore.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_vault_id: str):
        """
        :param str key_vault_id: The key vault id to store secret.
        """
        pulumi.set(__self__, "key_vault_id", key_vault_id)

    @property
    @pulumi.getter(name="keyVaultId")
    def key_vault_id(self) -> str:
        """
        The key vault id to store secret.
        """
        return pulumi.get(self, "key_vault_id")


@pulumi.output_type
class AppServiceAuthSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeDirectory":
            suggest = "active_directory"
        elif key == "additionalLoginParams":
            suggest = "additional_login_params"
        elif key == "allowedExternalRedirectUrls":
            suggest = "allowed_external_redirect_urls"
        elif key == "defaultProvider":
            suggest = "default_provider"
        elif key == "runtimeVersion":
            suggest = "runtime_version"
        elif key == "tokenRefreshExtensionHours":
            suggest = "token_refresh_extension_hours"
        elif key == "tokenStoreEnabled":
            suggest = "token_store_enabled"
        elif key == "unauthenticatedClientAction":
            suggest = "unauthenticated_client_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceAuthSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceAuthSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceAuthSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 active_directory: Optional['outputs.AppServiceAuthSettingsActiveDirectory'] = None,
                 additional_login_params: Optional[Mapping[str, str]] = None,
                 allowed_external_redirect_urls: Optional[Sequence[str]] = None,
                 default_provider: Optional[str] = None,
                 facebook: Optional['outputs.AppServiceAuthSettingsFacebook'] = None,
                 google: Optional['outputs.AppServiceAuthSettingsGoogle'] = None,
                 issuer: Optional[str] = None,
                 microsoft: Optional['outputs.AppServiceAuthSettingsMicrosoft'] = None,
                 runtime_version: Optional[str] = None,
                 token_refresh_extension_hours: Optional[float] = None,
                 token_store_enabled: Optional[bool] = None,
                 twitter: Optional['outputs.AppServiceAuthSettingsTwitter'] = None,
                 unauthenticated_client_action: Optional[str] = None):
        """
        :param bool enabled: Is Authentication enabled?
        :param 'AppServiceAuthSettingsActiveDirectoryArgs' active_directory: A `active_directory` block as defined below.
        :param Mapping[str, str] additional_login_params: Login parameters to send to the OpenID Connect authorization endpoint when a user logs in. Each parameter must be in the form "key=value".
        :param Sequence[str] allowed_external_redirect_urls: External URLs that can be redirected to as part of logging in or logging out of the app.
        :param str default_provider: The default provider to use when multiple providers have been set up. Possible values are `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount` and `Twitter`.
               
               > **NOTE:** When using multiple providers, the default provider must be set for settings like `unauthenticated_client_action` to work.
        :param 'AppServiceAuthSettingsFacebookArgs' facebook: A `facebook` block as defined below.
        :param 'AppServiceAuthSettingsGoogleArgs' google: A `google` block as defined below.
        :param str issuer: Issuer URI. When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        :param 'AppServiceAuthSettingsMicrosoftArgs' microsoft: A `microsoft` block as defined below.
        :param str runtime_version: The runtime version of the Authentication/Authorization module.
        :param float token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72`.
        :param bool token_store_enabled: If enabled the module will durably store platform-specific security tokens that are obtained during login flows. Defaults to `false`.
        :param 'AppServiceAuthSettingsTwitterArgs' twitter: A `twitter` block as defined below.
        :param str unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app. Possible values are `AllowAnonymous` and `RedirectToLoginPage`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if active_directory is not None:
            pulumi.set(__self__, "active_directory", active_directory)
        if additional_login_params is not None:
            pulumi.set(__self__, "additional_login_params", additional_login_params)
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if facebook is not None:
            pulumi.set(__self__, "facebook", facebook)
        if google is not None:
            pulumi.set(__self__, "google", google)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if microsoft is not None:
            pulumi.set(__self__, "microsoft", microsoft)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if token_refresh_extension_hours is not None:
            pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if twitter is not None:
            pulumi.set(__self__, "twitter", twitter)
        if unauthenticated_client_action is not None:
            pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is Authentication enabled?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="activeDirectory")
    def active_directory(self) -> Optional['outputs.AppServiceAuthSettingsActiveDirectory']:
        """
        A `active_directory` block as defined below.
        """
        return pulumi.get(self, "active_directory")

    @property
    @pulumi.getter(name="additionalLoginParams")
    def additional_login_params(self) -> Optional[Mapping[str, str]]:
        """
        Login parameters to send to the OpenID Connect authorization endpoint when a user logs in. Each parameter must be in the form "key=value".
        """
        return pulumi.get(self, "additional_login_params")

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[Sequence[str]]:
        """
        External URLs that can be redirected to as part of logging in or logging out of the app.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[str]:
        """
        The default provider to use when multiple providers have been set up. Possible values are `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount` and `Twitter`.

        > **NOTE:** When using multiple providers, the default provider must be set for settings like `unauthenticated_client_action` to work.
        """
        return pulumi.get(self, "default_provider")

    @property
    @pulumi.getter
    def facebook(self) -> Optional['outputs.AppServiceAuthSettingsFacebook']:
        """
        A `facebook` block as defined below.
        """
        return pulumi.get(self, "facebook")

    @property
    @pulumi.getter
    def google(self) -> Optional['outputs.AppServiceAuthSettingsGoogle']:
        """
        A `google` block as defined below.
        """
        return pulumi.get(self, "google")

    @property
    @pulumi.getter
    def issuer(self) -> Optional[str]:
        """
        Issuer URI. When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def microsoft(self) -> Optional['outputs.AppServiceAuthSettingsMicrosoft']:
        """
        A `microsoft` block as defined below.
        """
        return pulumi.get(self, "microsoft")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[str]:
        """
        The runtime version of the Authentication/Authorization module.
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> Optional[float]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72`.
        """
        return pulumi.get(self, "token_refresh_extension_hours")

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[bool]:
        """
        If enabled the module will durably store platform-specific security tokens that are obtained during login flows. Defaults to `false`.
        """
        return pulumi.get(self, "token_store_enabled")

    @property
    @pulumi.getter
    def twitter(self) -> Optional['outputs.AppServiceAuthSettingsTwitter']:
        """
        A `twitter` block as defined below.
        """
        return pulumi.get(self, "twitter")

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> Optional[str]:
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values are `AllowAnonymous` and `RedirectToLoginPage`.
        """
        return pulumi.get(self, "unauthenticated_client_action")


@pulumi.output_type
class AppServiceAuthSettingsActiveDirectory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "clientSecret":
            suggest = "client_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceAuthSettingsActiveDirectory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceAuthSettingsActiveDirectory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceAuthSettingsActiveDirectory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 client_secret: Optional[str] = None):
        """
        :param str client_id: The Client ID of this relying party application. Enables OpenIDConnection authentication with Azure Active Directory.
        :param Sequence[str] allowed_audiences: Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
        :param str client_secret: The Client Secret of this relying party application. If no secret is provided, implicit flow will be used.
        """
        pulumi.set(__self__, "client_id", client_id)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The Client ID of this relying party application. Enables OpenIDConnection authentication with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret of this relying party application. If no secret is provided, implicit flow will be used.
        """
        return pulumi.get(self, "client_secret")


@pulumi.output_type
class AppServiceAuthSettingsFacebook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "appSecret":
            suggest = "app_secret"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceAuthSettingsFacebook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceAuthSettingsFacebook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceAuthSettingsFacebook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: str,
                 app_secret: str,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str app_id: The App ID of the Facebook app used for login
        :param str app_secret: The App Secret of the Facebook app used for Facebook login.
        :param Sequence[str] oauth_scopes: The OAuth 2.0 scopes that will be requested as part of Facebook login authentication. <https://developers.facebook.com/docs/facebook-login>
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "app_secret", app_secret)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        The App ID of the Facebook app used for login
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appSecret")
    def app_secret(self) -> str:
        """
        The App Secret of the Facebook app used for Facebook login.
        """
        return pulumi.get(self, "app_secret")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        The OAuth 2.0 scopes that will be requested as part of Facebook login authentication. <https://developers.facebook.com/docs/facebook-login>
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class AppServiceAuthSettingsGoogle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceAuthSettingsGoogle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceAuthSettingsGoogle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceAuthSettingsGoogle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OpenID Connect Client ID for the Google web application.
        :param str client_secret: The client secret associated with the Google web application.
        :param Sequence[str] oauth_scopes: The OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. <https://developers.google.com/identity/sign-in/web/>
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OpenID Connect Client ID for the Google web application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The client secret associated with the Google web application.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        The OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. <https://developers.google.com/identity/sign-in/web/>
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class AppServiceAuthSettingsMicrosoft(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceAuthSettingsMicrosoft. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceAuthSettingsMicrosoft.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceAuthSettingsMicrosoft.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret: The OAuth 2.0 client secret that was created for the app used for authentication.
        :param Sequence[str] oauth_scopes: The OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. <https://msdn.microsoft.com/en-us/library/dn631845.aspx>
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        The OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. <https://msdn.microsoft.com/en-us/library/dn631845.aspx>
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class AppServiceAuthSettingsTwitter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerKey":
            suggest = "consumer_key"
        elif key == "consumerSecret":
            suggest = "consumer_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceAuthSettingsTwitter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceAuthSettingsTwitter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceAuthSettingsTwitter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_key: str,
                 consumer_secret: str):
        """
        :param str consumer_key: The consumer key of the Twitter app used for login
        :param str consumer_secret: The consumer secret of the Twitter app used for login.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        pulumi.set(__self__, "consumer_secret", consumer_secret)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> str:
        """
        The consumer key of the Twitter app used for login
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> str:
        """
        The consumer secret of the Twitter app used for login.
        """
        return pulumi.get(self, "consumer_secret")


@pulumi.output_type
class AppServiceBackup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageAccountUrl":
            suggest = "storage_account_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceBackup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceBackup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceBackup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 schedule: 'outputs.AppServiceBackupSchedule',
                 storage_account_url: str,
                 enabled: Optional[bool] = None):
        """
        :param str name: Specifies the name for this Backup.
        :param 'AppServiceBackupScheduleArgs' schedule: A `schedule` block as defined below.
        :param str storage_account_url: The SAS URL to a Storage Container where Backups should be saved.
        :param bool enabled: Is this Backup enabled? Defaults to `true`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "storage_account_url", storage_account_url)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name for this Backup.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def schedule(self) -> 'outputs.AppServiceBackupSchedule':
        """
        A `schedule` block as defined below.
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter(name="storageAccountUrl")
    def storage_account_url(self) -> str:
        """
        The SAS URL to a Storage Container where Backups should be saved.
        """
        return pulumi.get(self, "storage_account_url")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Is this Backup enabled? Defaults to `true`.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class AppServiceBackupSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "frequencyUnit":
            suggest = "frequency_unit"
        elif key == "keepAtLeastOneBackup":
            suggest = "keep_at_least_one_backup"
        elif key == "retentionPeriodInDays":
            suggest = "retention_period_in_days"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceBackupSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceBackupSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceBackupSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_unit: str,
                 keep_at_least_one_backup: Optional[bool] = None,
                 retention_period_in_days: Optional[int] = None,
                 start_time: Optional[str] = None):
        """
        :param int frequency_interval: Sets how often the backup should be executed.
        :param str frequency_unit: Sets the unit of time for how often the backup should be executed. Possible values are `Day` or `Hour`.
        :param bool keep_at_least_one_backup: Should at least one backup always be kept in the Storage Account by the Retention Policy, regardless of how old it is?
        :param int retention_period_in_days: Specifies the number of days after which Backups should be deleted. Defaults to `30`.
        :param str start_time: Sets when the schedule should start working.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_unit", frequency_unit)
        if keep_at_least_one_backup is not None:
            pulumi.set(__self__, "keep_at_least_one_backup", keep_at_least_one_backup)
        if retention_period_in_days is not None:
            pulumi.set(__self__, "retention_period_in_days", retention_period_in_days)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Sets how often the backup should be executed.
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyUnit")
    def frequency_unit(self) -> str:
        """
        Sets the unit of time for how often the backup should be executed. Possible values are `Day` or `Hour`.
        """
        return pulumi.get(self, "frequency_unit")

    @property
    @pulumi.getter(name="keepAtLeastOneBackup")
    def keep_at_least_one_backup(self) -> Optional[bool]:
        """
        Should at least one backup always be kept in the Storage Account by the Retention Policy, regardless of how old it is?
        """
        return pulumi.get(self, "keep_at_least_one_backup")

    @property
    @pulumi.getter(name="retentionPeriodInDays")
    def retention_period_in_days(self) -> Optional[int]:
        """
        Specifies the number of days after which Backups should be deleted. Defaults to `30`.
        """
        return pulumi.get(self, "retention_period_in_days")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        """
        Sets when the schedule should start working.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class AppServiceConnectionString(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: The name of the Connection String.
        :param str type: The type of the Connection String. Possible values are `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure` and `SQLServer`.
        :param str value: The value for the Connection String.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Connection String.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the Connection String. Possible values are `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure` and `SQLServer`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the Connection String.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AppServiceIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 identity_ids: Optional[Sequence[str]] = None,
                 principal_id: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str type: Specifies the identity type of the App Service. Possible values are `SystemAssigned` (where Azure will generate a Service Principal for you), `UserAssigned` where you can specify the Service Principal IDs in the `identity_ids` field, and `SystemAssigned, UserAssigned` which assigns both a system managed identity as well as the specified user assigned identities.
               
               > **NOTE:** When `type` is set to `SystemAssigned`, The assigned `principal_id` and `tenant_id` can be retrieved after the App Service has been created. More details are available below.
        :param Sequence[str] identity_ids: Specifies a list of user managed identity ids to be assigned. Required if `type` is `UserAssigned`.
        :param str principal_id: The Principal ID for the Service Principal associated with the Managed Service Identity of this App Service.
        :param str tenant_id: The Tenant ID for the Service Principal associated with the Managed Service Identity of this App Service.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the identity type of the App Service. Possible values are `SystemAssigned` (where Azure will generate a Service Principal for you), `UserAssigned` where you can specify the Service Principal IDs in the `identity_ids` field, and `SystemAssigned, UserAssigned` which assigns both a system managed identity as well as the specified user assigned identities.

        > **NOTE:** When `type` is set to `SystemAssigned`, The assigned `principal_id` and `tenant_id` can be retrieved after the App Service has been created. More details are available below.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of user managed identity ids to be assigned. Required if `type` is `UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        """
        The Principal ID for the Service Principal associated with the Managed Service Identity of this App Service.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The Tenant ID for the Service Principal associated with the Managed Service Identity of this App Service.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class AppServiceLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationLogs":
            suggest = "application_logs"
        elif key == "detailedErrorMessagesEnabled":
            suggest = "detailed_error_messages_enabled"
        elif key == "failedRequestTracingEnabled":
            suggest = "failed_request_tracing_enabled"
        elif key == "httpLogs":
            suggest = "http_logs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_logs: Optional['outputs.AppServiceLogsApplicationLogs'] = None,
                 detailed_error_messages_enabled: Optional[bool] = None,
                 failed_request_tracing_enabled: Optional[bool] = None,
                 http_logs: Optional['outputs.AppServiceLogsHttpLogs'] = None):
        """
        :param 'AppServiceLogsApplicationLogsArgs' application_logs: An `application_logs` block as defined below.
        :param bool detailed_error_messages_enabled: Should `Detailed error messages` be enabled on this App Service? Defaults to `false`.
        :param bool failed_request_tracing_enabled: Should `Failed request tracing` be enabled on this App Service? Defaults to `false`.
        :param 'AppServiceLogsHttpLogsArgs' http_logs: An `http_logs` block as defined below.
        """
        if application_logs is not None:
            pulumi.set(__self__, "application_logs", application_logs)
        if detailed_error_messages_enabled is not None:
            pulumi.set(__self__, "detailed_error_messages_enabled", detailed_error_messages_enabled)
        if failed_request_tracing_enabled is not None:
            pulumi.set(__self__, "failed_request_tracing_enabled", failed_request_tracing_enabled)
        if http_logs is not None:
            pulumi.set(__self__, "http_logs", http_logs)

    @property
    @pulumi.getter(name="applicationLogs")
    def application_logs(self) -> Optional['outputs.AppServiceLogsApplicationLogs']:
        """
        An `application_logs` block as defined below.
        """
        return pulumi.get(self, "application_logs")

    @property
    @pulumi.getter(name="detailedErrorMessagesEnabled")
    def detailed_error_messages_enabled(self) -> Optional[bool]:
        """
        Should `Detailed error messages` be enabled on this App Service? Defaults to `false`.
        """
        return pulumi.get(self, "detailed_error_messages_enabled")

    @property
    @pulumi.getter(name="failedRequestTracingEnabled")
    def failed_request_tracing_enabled(self) -> Optional[bool]:
        """
        Should `Failed request tracing` be enabled on this App Service? Defaults to `false`.
        """
        return pulumi.get(self, "failed_request_tracing_enabled")

    @property
    @pulumi.getter(name="httpLogs")
    def http_logs(self) -> Optional['outputs.AppServiceLogsHttpLogs']:
        """
        An `http_logs` block as defined below.
        """
        return pulumi.get(self, "http_logs")


@pulumi.output_type
class AppServiceLogsApplicationLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureBlobStorage":
            suggest = "azure_blob_storage"
        elif key == "fileSystemLevel":
            suggest = "file_system_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceLogsApplicationLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceLogsApplicationLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceLogsApplicationLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_blob_storage: Optional['outputs.AppServiceLogsApplicationLogsAzureBlobStorage'] = None,
                 file_system_level: Optional[str] = None):
        """
        :param 'AppServiceLogsApplicationLogsAzureBlobStorageArgs' azure_blob_storage: An `azure_blob_storage` block as defined below.
        :param str file_system_level: Log level for filesystem based logging. Supported values are `Error`, `Information`, `Verbose`, `Warning` and `Off`. Defaults to `Off`.
        """
        if azure_blob_storage is not None:
            pulumi.set(__self__, "azure_blob_storage", azure_blob_storage)
        if file_system_level is not None:
            pulumi.set(__self__, "file_system_level", file_system_level)

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional['outputs.AppServiceLogsApplicationLogsAzureBlobStorage']:
        """
        An `azure_blob_storage` block as defined below.
        """
        return pulumi.get(self, "azure_blob_storage")

    @property
    @pulumi.getter(name="fileSystemLevel")
    def file_system_level(self) -> Optional[str]:
        """
        Log level for filesystem based logging. Supported values are `Error`, `Information`, `Verbose`, `Warning` and `Off`. Defaults to `Off`.
        """
        return pulumi.get(self, "file_system_level")


@pulumi.output_type
class AppServiceLogsApplicationLogsAzureBlobStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retentionInDays":
            suggest = "retention_in_days"
        elif key == "sasUrl":
            suggest = "sas_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceLogsApplicationLogsAzureBlobStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceLogsApplicationLogsAzureBlobStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceLogsApplicationLogsAzureBlobStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 level: str,
                 retention_in_days: int,
                 sas_url: str):
        """
        :param str level: The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        :param int retention_in_days: The number of days to retain logs for.
        :param str sas_url: The URL to the storage container with a shared access signature token appended.
        """
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "sas_url", sas_url)

    @property
    @pulumi.getter
    def level(self) -> str:
        """
        The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        """
        return pulumi.get(self, "level")

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> int:
        """
        The number of days to retain logs for.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> str:
        """
        The URL to the storage container with a shared access signature token appended.
        """
        return pulumi.get(self, "sas_url")


@pulumi.output_type
class AppServiceLogsHttpLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureBlobStorage":
            suggest = "azure_blob_storage"
        elif key == "fileSystem":
            suggest = "file_system"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceLogsHttpLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceLogsHttpLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceLogsHttpLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_blob_storage: Optional['outputs.AppServiceLogsHttpLogsAzureBlobStorage'] = None,
                 file_system: Optional['outputs.AppServiceLogsHttpLogsFileSystem'] = None):
        """
        :param 'AppServiceLogsHttpLogsAzureBlobStorageArgs' azure_blob_storage: An `azure_blob_storage` block as defined below.
        :param 'AppServiceLogsHttpLogsFileSystemArgs' file_system: A `file_system` block as defined below.
        """
        if azure_blob_storage is not None:
            pulumi.set(__self__, "azure_blob_storage", azure_blob_storage)
        if file_system is not None:
            pulumi.set(__self__, "file_system", file_system)

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional['outputs.AppServiceLogsHttpLogsAzureBlobStorage']:
        """
        An `azure_blob_storage` block as defined below.
        """
        return pulumi.get(self, "azure_blob_storage")

    @property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional['outputs.AppServiceLogsHttpLogsFileSystem']:
        """
        A `file_system` block as defined below.
        """
        return pulumi.get(self, "file_system")


@pulumi.output_type
class AppServiceLogsHttpLogsAzureBlobStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retentionInDays":
            suggest = "retention_in_days"
        elif key == "sasUrl":
            suggest = "sas_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceLogsHttpLogsAzureBlobStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceLogsHttpLogsAzureBlobStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceLogsHttpLogsAzureBlobStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 retention_in_days: int,
                 sas_url: str):
        """
        :param int retention_in_days: The number of days to retain logs for.
        :param str sas_url: The URL to the storage container with a shared access signature token appended.
        """
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "sas_url", sas_url)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> int:
        """
        The number of days to retain logs for.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> str:
        """
        The URL to the storage container with a shared access signature token appended.
        """
        return pulumi.get(self, "sas_url")


@pulumi.output_type
class AppServiceLogsHttpLogsFileSystem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retentionInDays":
            suggest = "retention_in_days"
        elif key == "retentionInMb":
            suggest = "retention_in_mb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceLogsHttpLogsFileSystem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceLogsHttpLogsFileSystem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceLogsHttpLogsFileSystem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 retention_in_days: int,
                 retention_in_mb: int):
        """
        :param int retention_in_days: The number of days to retain logs for.
        :param int retention_in_mb: The maximum size in megabytes that HTTP log files can use before being removed.
        """
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "retention_in_mb", retention_in_mb)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> int:
        """
        The number of days to retain logs for.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="retentionInMb")
    def retention_in_mb(self) -> int:
        """
        The maximum size in megabytes that HTTP log files can use before being removed.
        """
        return pulumi.get(self, "retention_in_mb")


@pulumi.output_type
class AppServiceSiteConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acrUseManagedIdentityCredentials":
            suggest = "acr_use_managed_identity_credentials"
        elif key == "acrUserManagedIdentityClientId":
            suggest = "acr_user_managed_identity_client_id"
        elif key == "alwaysOn":
            suggest = "always_on"
        elif key == "appCommandLine":
            suggest = "app_command_line"
        elif key == "autoSwapSlotName":
            suggest = "auto_swap_slot_name"
        elif key == "defaultDocuments":
            suggest = "default_documents"
        elif key == "dotnetFrameworkVersion":
            suggest = "dotnet_framework_version"
        elif key == "ftpsState":
            suggest = "ftps_state"
        elif key == "healthCheckPath":
            suggest = "health_check_path"
        elif key == "http2Enabled":
            suggest = "http2_enabled"
        elif key == "ipRestrictions":
            suggest = "ip_restrictions"
        elif key == "javaContainer":
            suggest = "java_container"
        elif key == "javaContainerVersion":
            suggest = "java_container_version"
        elif key == "javaVersion":
            suggest = "java_version"
        elif key == "linuxFxVersion":
            suggest = "linux_fx_version"
        elif key == "localMysqlEnabled":
            suggest = "local_mysql_enabled"
        elif key == "managedPipelineMode":
            suggest = "managed_pipeline_mode"
        elif key == "minTlsVersion":
            suggest = "min_tls_version"
        elif key == "numberOfWorkers":
            suggest = "number_of_workers"
        elif key == "phpVersion":
            suggest = "php_version"
        elif key == "pythonVersion":
            suggest = "python_version"
        elif key == "remoteDebuggingEnabled":
            suggest = "remote_debugging_enabled"
        elif key == "remoteDebuggingVersion":
            suggest = "remote_debugging_version"
        elif key == "scmIpRestrictions":
            suggest = "scm_ip_restrictions"
        elif key == "scmType":
            suggest = "scm_type"
        elif key == "scmUseMainIpRestriction":
            suggest = "scm_use_main_ip_restriction"
        elif key == "use32BitWorkerProcess":
            suggest = "use32_bit_worker_process"
        elif key == "vnetRouteAllEnabled":
            suggest = "vnet_route_all_enabled"
        elif key == "websocketsEnabled":
            suggest = "websockets_enabled"
        elif key == "windowsFxVersion":
            suggest = "windows_fx_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceSiteConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceSiteConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceSiteConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acr_use_managed_identity_credentials: Optional[bool] = None,
                 acr_user_managed_identity_client_id: Optional[str] = None,
                 always_on: Optional[bool] = None,
                 app_command_line: Optional[str] = None,
                 auto_swap_slot_name: Optional[str] = None,
                 cors: Optional['outputs.AppServiceSiteConfigCors'] = None,
                 default_documents: Optional[Sequence[str]] = None,
                 dotnet_framework_version: Optional[str] = None,
                 ftps_state: Optional[str] = None,
                 health_check_path: Optional[str] = None,
                 http2_enabled: Optional[bool] = None,
                 ip_restrictions: Optional[Sequence['outputs.AppServiceSiteConfigIpRestriction']] = None,
                 java_container: Optional[str] = None,
                 java_container_version: Optional[str] = None,
                 java_version: Optional[str] = None,
                 linux_fx_version: Optional[str] = None,
                 local_mysql_enabled: Optional[bool] = None,
                 managed_pipeline_mode: Optional[str] = None,
                 min_tls_version: Optional[str] = None,
                 number_of_workers: Optional[int] = None,
                 php_version: Optional[str] = None,
                 python_version: Optional[str] = None,
                 remote_debugging_enabled: Optional[bool] = None,
                 remote_debugging_version: Optional[str] = None,
                 scm_ip_restrictions: Optional[Sequence['outputs.AppServiceSiteConfigScmIpRestriction']] = None,
                 scm_type: Optional[str] = None,
                 scm_use_main_ip_restriction: Optional[bool] = None,
                 use32_bit_worker_process: Optional[bool] = None,
                 vnet_route_all_enabled: Optional[bool] = None,
                 websockets_enabled: Optional[bool] = None,
                 windows_fx_version: Optional[str] = None):
        """
        :param bool acr_use_managed_identity_credentials: Are Managed Identity Credentials used for Azure Container Registry pull
        :param str acr_user_managed_identity_client_id: If using User Managed Identity, the User Managed Identity Client Id
               
               > **NOTE:** When using User Managed Identity with Azure Container Registry the Identity will need to have the [ACRPull role assigned](https://docs.microsoft.com/azure/container-registry/container-registry-authentication-managed-identity#example-1-access-with-a-user-assigned-identity)
        :param bool always_on: Should the app be loaded at all times? Defaults to `false`.
               
               > **NOTE:** when using an App Service Plan in the `Free` or `Shared` Tiers `always_on` must be set to `false`.
        :param str app_command_line: App command line to launch, e.g. `/sbin/myserver -b 0.0.0.0`.
        :param str auto_swap_slot_name: The name of the slot to automatically swap to during deployment
        :param 'AppServiceSiteConfigCorsArgs' cors: A `cors` block as defined below.
        :param Sequence[str] default_documents: The ordering of default documents to load, if an address isn't specified.
        :param str dotnet_framework_version: The version of the .NET framework's CLR used in this App Service. Possible values are `v2.0` (which will use the latest version of the .NET framework for the .NET CLR v2 - currently `.net 3.5`), `v4.0` (which corresponds to the latest version of the .NET CLR v4 - which at the time of writing is `.net 4.7.1`), `v5.0` and `v6.0`. [For more information on which .NET CLR version to use based on the .NET framework you're targeting - please see this table](https://en.wikipedia.org/wiki/.NET_Framework_version_history#Overview). Defaults to `v4.0`.
        :param str ftps_state: State of FTP / FTPS service for this App Service. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`.
        :param str health_check_path: The health check path to be pinged by App Service. [For more information - please see App Service health check announcement](https://azure.github.io/AppService/2020/08/24/healthcheck-on-app-service.html).
        :param bool http2_enabled: Is HTTP2 Enabled on this App Service? Defaults to `false`.
        :param Sequence['AppServiceSiteConfigIpRestrictionArgs'] ip_restrictions: A list of objects representing ip restrictions as defined below.
               
               > **NOTE** User has to explicitly set `ip_restriction` to empty slice (`[]`) to remove it.
        :param str java_container: The Java Container to use. If specified `java_version` and `java_container_version` must also be specified. Possible values are `JAVA`, `JETTY`, and `TOMCAT`.
        :param str java_container_version: The version of the Java Container to use. If specified `java_version` and `java_container` must also be specified.
        :param str java_version: The version of Java to use. If specified `java_container` and `java_container_version` must also be specified. Possible values are `1.7`, `1.8` and `11` and their specific versions - except for Java 11 (e.g. `1.7.0_80`, `1.8.0_181`, `11`)
        :param str linux_fx_version: Linux App Framework and version for the App Service. Possible options are a Docker container (`DOCKER|<user/image:tag>`), a base-64 encoded Docker Compose file (`COMPOSE|${filebase64("compose.yml")}`) or a base-64 encoded Kubernetes Manifest (`KUBE|${filebase64("kubernetes.yml")}`).
               
               > **NOTE:** To set this property the App Service Plan to which the App belongs must be configured with `kind = "Linux"`, and `reserved = true` or the API will reject any value supplied.
        :param bool local_mysql_enabled: Is "MySQL In App" Enabled? This runs a local MySQL instance with your app and shares resources from the App Service plan.
               
               > **NOTE:** MySQL In App is not intended for production environments and will not scale beyond a single instance. Instead you may wish to use Azure Database for MySQL.
        :param str managed_pipeline_mode: The Managed Pipeline Mode. Possible values are `Integrated` and `Classic`. Defaults to `Integrated`.
        :param str min_tls_version: The minimum supported TLS version for the app service. Possible values are `1.0`, `1.1`, and `1.2`. Defaults to `1.2` for new app services.
        :param int number_of_workers: The scaled number of workers (for per site scaling) of this App Service. Requires that `per_site_scaling` is enabled on the `appservice.Plan`. [For more information - please see Microsoft documentation on high-density hosting](https://docs.microsoft.com/azure/app-service/manage-scale-per-app).
        :param str php_version: The version of PHP to use in this App Service. Possible values are `5.5`, `5.6`, `7.0`, `7.1`, `7.2`, `7.3` and `7.4`.
        :param str python_version: The version of Python to use in this App Service. Possible values are `2.7` and `3.4`.
        :param bool remote_debugging_enabled: Is Remote Debugging Enabled? Defaults to `false`.
        :param str remote_debugging_version: Which version of Visual Studio should the Remote Debugger be compatible with? Possible values are `VS2017` and `VS2019`.
        :param Sequence['AppServiceSiteConfigScmIpRestrictionArgs'] scm_ip_restrictions: A [List of objects](https://www.terraform.io/docs/configuration/attr-as-blocks.html) representing IP restrictions as defined below.
               
               > **NOTE** User has to explicitly set `scm_ip_restriction` to empty slice (`[]`) to remove it.
        :param str scm_type: The type of Source Control enabled for this App Service. Defaults to `None`. Possible values are: `BitbucketGit`, `BitbucketHg`, `CodePlexGit`, `CodePlexHg`, `Dropbox`, `ExternalGit`, `ExternalHg`, `GitHub`, `LocalGit`, `None`, `OneDrive`, `Tfs`, `VSO`, and `VSTSRM`
        :param bool scm_use_main_ip_restriction: IP security restrictions for scm to use main. Defaults to `false`. 
               
               > **NOTE** Any `scm_ip_restriction` blocks configured are ignored by the service when `scm_use_main_ip_restriction` is set to `true`. Any scm restrictions will become active if this is subsequently set to `false` or removed.
        :param bool use32_bit_worker_process: Should the App Service run in 32 bit mode, rather than 64 bit mode?
               
               > **NOTE:** when using an App Service Plan in the `Free` or `Shared` Tiers `use_32_bit_worker_process` must be set to `true`.
        :param bool websockets_enabled: Should WebSockets be enabled?
        :param str windows_fx_version: The Windows Docker container image (`DOCKER|<user/image:tag>`)
        """
        if acr_use_managed_identity_credentials is not None:
            pulumi.set(__self__, "acr_use_managed_identity_credentials", acr_use_managed_identity_credentials)
        if acr_user_managed_identity_client_id is not None:
            pulumi.set(__self__, "acr_user_managed_identity_client_id", acr_user_managed_identity_client_id)
        if always_on is not None:
            pulumi.set(__self__, "always_on", always_on)
        if app_command_line is not None:
            pulumi.set(__self__, "app_command_line", app_command_line)
        if auto_swap_slot_name is not None:
            pulumi.set(__self__, "auto_swap_slot_name", auto_swap_slot_name)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if default_documents is not None:
            pulumi.set(__self__, "default_documents", default_documents)
        if dotnet_framework_version is not None:
            pulumi.set(__self__, "dotnet_framework_version", dotnet_framework_version)
        if ftps_state is not None:
            pulumi.set(__self__, "ftps_state", ftps_state)
        if health_check_path is not None:
            pulumi.set(__self__, "health_check_path", health_check_path)
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if ip_restrictions is not None:
            pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        if java_container is not None:
            pulumi.set(__self__, "java_container", java_container)
        if java_container_version is not None:
            pulumi.set(__self__, "java_container_version", java_container_version)
        if java_version is not None:
            pulumi.set(__self__, "java_version", java_version)
        if linux_fx_version is not None:
            pulumi.set(__self__, "linux_fx_version", linux_fx_version)
        if local_mysql_enabled is not None:
            pulumi.set(__self__, "local_mysql_enabled", local_mysql_enabled)
        if managed_pipeline_mode is not None:
            pulumi.set(__self__, "managed_pipeline_mode", managed_pipeline_mode)
        if min_tls_version is not None:
            pulumi.set(__self__, "min_tls_version", min_tls_version)
        if number_of_workers is not None:
            pulumi.set(__self__, "number_of_workers", number_of_workers)
        if php_version is not None:
            pulumi.set(__self__, "php_version", php_version)
        if python_version is not None:
            pulumi.set(__self__, "python_version", python_version)
        if remote_debugging_enabled is not None:
            pulumi.set(__self__, "remote_debugging_enabled", remote_debugging_enabled)
        if remote_debugging_version is not None:
            pulumi.set(__self__, "remote_debugging_version", remote_debugging_version)
        if scm_ip_restrictions is not None:
            pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        if scm_type is not None:
            pulumi.set(__self__, "scm_type", scm_type)
        if scm_use_main_ip_restriction is not None:
            pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        if use32_bit_worker_process is not None:
            pulumi.set(__self__, "use32_bit_worker_process", use32_bit_worker_process)
        if vnet_route_all_enabled is not None:
            pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        if websockets_enabled is not None:
            pulumi.set(__self__, "websockets_enabled", websockets_enabled)
        if windows_fx_version is not None:
            pulumi.set(__self__, "windows_fx_version", windows_fx_version)

    @property
    @pulumi.getter(name="acrUseManagedIdentityCredentials")
    def acr_use_managed_identity_credentials(self) -> Optional[bool]:
        """
        Are Managed Identity Credentials used for Azure Container Registry pull
        """
        return pulumi.get(self, "acr_use_managed_identity_credentials")

    @property
    @pulumi.getter(name="acrUserManagedIdentityClientId")
    def acr_user_managed_identity_client_id(self) -> Optional[str]:
        """
        If using User Managed Identity, the User Managed Identity Client Id

        > **NOTE:** When using User Managed Identity with Azure Container Registry the Identity will need to have the [ACRPull role assigned](https://docs.microsoft.com/azure/container-registry/container-registry-authentication-managed-identity#example-1-access-with-a-user-assigned-identity)
        """
        return pulumi.get(self, "acr_user_managed_identity_client_id")

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> Optional[bool]:
        """
        Should the app be loaded at all times? Defaults to `false`.

        > **NOTE:** when using an App Service Plan in the `Free` or `Shared` Tiers `always_on` must be set to `false`.
        """
        return pulumi.get(self, "always_on")

    @property
    @pulumi.getter(name="appCommandLine")
    def app_command_line(self) -> Optional[str]:
        """
        App command line to launch, e.g. `/sbin/myserver -b 0.0.0.0`.
        """
        return pulumi.get(self, "app_command_line")

    @property
    @pulumi.getter(name="autoSwapSlotName")
    def auto_swap_slot_name(self) -> Optional[str]:
        """
        The name of the slot to automatically swap to during deployment
        """
        return pulumi.get(self, "auto_swap_slot_name")

    @property
    @pulumi.getter
    def cors(self) -> Optional['outputs.AppServiceSiteConfigCors']:
        """
        A `cors` block as defined below.
        """
        return pulumi.get(self, "cors")

    @property
    @pulumi.getter(name="defaultDocuments")
    def default_documents(self) -> Optional[Sequence[str]]:
        """
        The ordering of default documents to load, if an address isn't specified.
        """
        return pulumi.get(self, "default_documents")

    @property
    @pulumi.getter(name="dotnetFrameworkVersion")
    def dotnet_framework_version(self) -> Optional[str]:
        """
        The version of the .NET framework's CLR used in this App Service. Possible values are `v2.0` (which will use the latest version of the .NET framework for the .NET CLR v2 - currently `.net 3.5`), `v4.0` (which corresponds to the latest version of the .NET CLR v4 - which at the time of writing is `.net 4.7.1`), `v5.0` and `v6.0`. [For more information on which .NET CLR version to use based on the .NET framework you're targeting - please see this table](https://en.wikipedia.org/wiki/.NET_Framework_version_history#Overview). Defaults to `v4.0`.
        """
        return pulumi.get(self, "dotnet_framework_version")

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> Optional[str]:
        """
        State of FTP / FTPS service for this App Service. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`.
        """
        return pulumi.get(self, "ftps_state")

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> Optional[str]:
        """
        The health check path to be pinged by App Service. [For more information - please see App Service health check announcement](https://azure.github.io/AppService/2020/08/24/healthcheck-on-app-service.html).
        """
        return pulumi.get(self, "health_check_path")

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[bool]:
        """
        Is HTTP2 Enabled on this App Service? Defaults to `false`.
        """
        return pulumi.get(self, "http2_enabled")

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Optional[Sequence['outputs.AppServiceSiteConfigIpRestriction']]:
        """
        A list of objects representing ip restrictions as defined below.

        > **NOTE** User has to explicitly set `ip_restriction` to empty slice (`[]`) to remove it.
        """
        return pulumi.get(self, "ip_restrictions")

    @property
    @pulumi.getter(name="javaContainer")
    def java_container(self) -> Optional[str]:
        """
        The Java Container to use. If specified `java_version` and `java_container_version` must also be specified. Possible values are `JAVA`, `JETTY`, and `TOMCAT`.
        """
        return pulumi.get(self, "java_container")

    @property
    @pulumi.getter(name="javaContainerVersion")
    def java_container_version(self) -> Optional[str]:
        """
        The version of the Java Container to use. If specified `java_version` and `java_container` must also be specified.
        """
        return pulumi.get(self, "java_container_version")

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> Optional[str]:
        """
        The version of Java to use. If specified `java_container` and `java_container_version` must also be specified. Possible values are `1.7`, `1.8` and `11` and their specific versions - except for Java 11 (e.g. `1.7.0_80`, `1.8.0_181`, `11`)
        """
        return pulumi.get(self, "java_version")

    @property
    @pulumi.getter(name="linuxFxVersion")
    def linux_fx_version(self) -> Optional[str]:
        """
        Linux App Framework and version for the App Service. Possible options are a Docker container (`DOCKER|<user/image:tag>`), a base-64 encoded Docker Compose file (`COMPOSE|${filebase64("compose.yml")}`) or a base-64 encoded Kubernetes Manifest (`KUBE|${filebase64("kubernetes.yml")}`).

        > **NOTE:** To set this property the App Service Plan to which the App belongs must be configured with `kind = "Linux"`, and `reserved = true` or the API will reject any value supplied.
        """
        return pulumi.get(self, "linux_fx_version")

    @property
    @pulumi.getter(name="localMysqlEnabled")
    def local_mysql_enabled(self) -> Optional[bool]:
        """
        Is "MySQL In App" Enabled? This runs a local MySQL instance with your app and shares resources from the App Service plan.

        > **NOTE:** MySQL In App is not intended for production environments and will not scale beyond a single instance. Instead you may wish to use Azure Database for MySQL.
        """
        return pulumi.get(self, "local_mysql_enabled")

    @property
    @pulumi.getter(name="managedPipelineMode")
    def managed_pipeline_mode(self) -> Optional[str]:
        """
        The Managed Pipeline Mode. Possible values are `Integrated` and `Classic`. Defaults to `Integrated`.
        """
        return pulumi.get(self, "managed_pipeline_mode")

    @property
    @pulumi.getter(name="minTlsVersion")
    def min_tls_version(self) -> Optional[str]:
        """
        The minimum supported TLS version for the app service. Possible values are `1.0`, `1.1`, and `1.2`. Defaults to `1.2` for new app services.
        """
        return pulumi.get(self, "min_tls_version")

    @property
    @pulumi.getter(name="numberOfWorkers")
    def number_of_workers(self) -> Optional[int]:
        """
        The scaled number of workers (for per site scaling) of this App Service. Requires that `per_site_scaling` is enabled on the `appservice.Plan`. [For more information - please see Microsoft documentation on high-density hosting](https://docs.microsoft.com/azure/app-service/manage-scale-per-app).
        """
        return pulumi.get(self, "number_of_workers")

    @property
    @pulumi.getter(name="phpVersion")
    def php_version(self) -> Optional[str]:
        """
        The version of PHP to use in this App Service. Possible values are `5.5`, `5.6`, `7.0`, `7.1`, `7.2`, `7.3` and `7.4`.
        """
        return pulumi.get(self, "php_version")

    @property
    @pulumi.getter(name="pythonVersion")
    def python_version(self) -> Optional[str]:
        """
        The version of Python to use in this App Service. Possible values are `2.7` and `3.4`.
        """
        return pulumi.get(self, "python_version")

    @property
    @pulumi.getter(name="remoteDebuggingEnabled")
    def remote_debugging_enabled(self) -> Optional[bool]:
        """
        Is Remote Debugging Enabled? Defaults to `false`.
        """
        return pulumi.get(self, "remote_debugging_enabled")

    @property
    @pulumi.getter(name="remoteDebuggingVersion")
    def remote_debugging_version(self) -> Optional[str]:
        """
        Which version of Visual Studio should the Remote Debugger be compatible with? Possible values are `VS2017` and `VS2019`.
        """
        return pulumi.get(self, "remote_debugging_version")

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Optional[Sequence['outputs.AppServiceSiteConfigScmIpRestriction']]:
        """
        A [List of objects](https://www.terraform.io/docs/configuration/attr-as-blocks.html) representing IP restrictions as defined below.

        > **NOTE** User has to explicitly set `scm_ip_restriction` to empty slice (`[]`) to remove it.
        """
        return pulumi.get(self, "scm_ip_restrictions")

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> Optional[str]:
        """
        The type of Source Control enabled for this App Service. Defaults to `None`. Possible values are: `BitbucketGit`, `BitbucketHg`, `CodePlexGit`, `CodePlexHg`, `Dropbox`, `ExternalGit`, `ExternalHg`, `GitHub`, `LocalGit`, `None`, `OneDrive`, `Tfs`, `VSO`, and `VSTSRM`
        """
        return pulumi.get(self, "scm_type")

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> Optional[bool]:
        """
        IP security restrictions for scm to use main. Defaults to `false`. 

        > **NOTE** Any `scm_ip_restriction` blocks configured are ignored by the service when `scm_use_main_ip_restriction` is set to `true`. Any scm restrictions will become active if this is subsequently set to `false` or removed.
        """
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @property
    @pulumi.getter(name="use32BitWorkerProcess")
    def use32_bit_worker_process(self) -> Optional[bool]:
        """
        Should the App Service run in 32 bit mode, rather than 64 bit mode?

        > **NOTE:** when using an App Service Plan in the `Free` or `Shared` Tiers `use_32_bit_worker_process` must be set to `true`.
        """
        return pulumi.get(self, "use32_bit_worker_process")

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "vnet_route_all_enabled")

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> Optional[bool]:
        """
        Should WebSockets be enabled?
        """
        return pulumi.get(self, "websockets_enabled")

    @property
    @pulumi.getter(name="windowsFxVersion")
    def windows_fx_version(self) -> Optional[str]:
        """
        The Windows Docker container image (`DOCKER|<user/image:tag>`)
        """
        return pulumi.get(self, "windows_fx_version")


@pulumi.output_type
class AppServiceSiteConfigCors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedOrigins":
            suggest = "allowed_origins"
        elif key == "supportCredentials":
            suggest = "support_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceSiteConfigCors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceSiteConfigCors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceSiteConfigCors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_origins: Sequence[str],
                 support_credentials: Optional[bool] = None):
        """
        :param Sequence[str] allowed_origins: A list of origins which should be able to make cross-origin calls. `*` can be used to allow all calls.
        :param bool support_credentials: Are credentials supported?
        """
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        if support_credentials is not None:
            pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Sequence[str]:
        """
        A list of origins which should be able to make cross-origin calls. `*` can be used to allow all calls.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> Optional[bool]:
        """
        Are credentials supported?
        """
        return pulumi.get(self, "support_credentials")


@pulumi.output_type
class AppServiceSiteConfigIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceSiteConfigIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceSiteConfigIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceSiteConfigIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.AppServiceSiteConfigIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: Does this restriction `Allow` or `Deny` access for this IP range. Defaults to `Allow`.
        :param 'AppServiceSiteConfigIpRestrictionHeadersArgs' headers: The headers for this specific `ip_restriction` as defined below.
        :param str ip_address: The IP Address used for this IP Restriction in CIDR notation.
        :param str name: The name for this IP Restriction.
        :param int priority: The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
               
               > **NOTE:** One of either `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        Does this restriction `Allow` or `Deny` access for this IP range. Defaults to `Allow`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.AppServiceSiteConfigIpRestrictionHeaders']:
        """
        The headers for this specific `ip_restriction` as defined below.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The IP Address used for this IP Restriction in CIDR notation.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name for this IP Restriction.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One of either `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class AppServiceSiteConfigIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceSiteConfigIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        :param str x_fd_health_probe: A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        :param Sequence[str] x_forwarded_fors: A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        :param Sequence[str] x_forwarded_hosts: A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class AppServiceSiteConfigScmIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceSiteConfigScmIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceSiteConfigScmIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceSiteConfigScmIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.AppServiceSiteConfigScmIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: Allow or Deny access for this IP range. Defaults to `Allow`.
        :param 'AppServiceSiteConfigScmIpRestrictionHeadersArgs' headers: The headers for this specific `scm_ip_restriction` as defined below.
        :param str ip_address: The IP Address used for this IP Restriction in CIDR notation.
        :param str name: The name for this IP Restriction.
        :param int priority: The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
               
               > **NOTE:** One of either `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        Allow or Deny access for this IP range. Defaults to `Allow`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.AppServiceSiteConfigScmIpRestrictionHeaders']:
        """
        The headers for this specific `scm_ip_restriction` as defined below.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The IP Address used for this IP Restriction in CIDR notation.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name for this IP Restriction.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One of either `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class AppServiceSiteConfigScmIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceSiteConfigScmIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        :param str x_fd_health_probe: A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        :param Sequence[str] x_forwarded_fors: A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        :param Sequence[str] x_forwarded_hosts: A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class AppServiceSiteCredential(dict):
    def __init__(__self__, *,
                 password: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str password: The password associated with the username, which can be used to publish to this App Service.
        :param str username: The username which can be used to publish to this App Service
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password associated with the username, which can be used to publish to this App Service.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username which can be used to publish to this App Service
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class AppServiceSourceControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "manualIntegration":
            suggest = "manual_integration"
        elif key == "repoUrl":
            suggest = "repo_url"
        elif key == "rollbackEnabled":
            suggest = "rollback_enabled"
        elif key == "useMercurial":
            suggest = "use_mercurial"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceSourceControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceSourceControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceSourceControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch: Optional[str] = None,
                 manual_integration: Optional[bool] = None,
                 repo_url: Optional[str] = None,
                 rollback_enabled: Optional[bool] = None,
                 use_mercurial: Optional[bool] = None):
        """
        :param str branch: The branch of the remote repository to use. Defaults to 'master'.
        :param bool manual_integration: Limits to manual integration. Defaults to `false` if not specified.
        :param str repo_url: The URL of the source code repository.
        :param bool rollback_enabled: Enable roll-back for the repository. Defaults to `false` if not specified.
        :param bool use_mercurial: Use Mercurial if `true`, otherwise uses Git.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if manual_integration is not None:
            pulumi.set(__self__, "manual_integration", manual_integration)
        if repo_url is not None:
            pulumi.set(__self__, "repo_url", repo_url)
        if rollback_enabled is not None:
            pulumi.set(__self__, "rollback_enabled", rollback_enabled)
        if use_mercurial is not None:
            pulumi.set(__self__, "use_mercurial", use_mercurial)

    @property
    @pulumi.getter
    def branch(self) -> Optional[str]:
        """
        The branch of the remote repository to use. Defaults to 'master'.
        """
        return pulumi.get(self, "branch")

    @property
    @pulumi.getter(name="manualIntegration")
    def manual_integration(self) -> Optional[bool]:
        """
        Limits to manual integration. Defaults to `false` if not specified.
        """
        return pulumi.get(self, "manual_integration")

    @property
    @pulumi.getter(name="repoUrl")
    def repo_url(self) -> Optional[str]:
        """
        The URL of the source code repository.
        """
        return pulumi.get(self, "repo_url")

    @property
    @pulumi.getter(name="rollbackEnabled")
    def rollback_enabled(self) -> Optional[bool]:
        """
        Enable roll-back for the repository. Defaults to `false` if not specified.
        """
        return pulumi.get(self, "rollback_enabled")

    @property
    @pulumi.getter(name="useMercurial")
    def use_mercurial(self) -> Optional[bool]:
        """
        Use Mercurial if `true`, otherwise uses Git.
        """
        return pulumi.get(self, "use_mercurial")


@pulumi.output_type
class AppServiceStorageAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "accountName":
            suggest = "account_name"
        elif key == "shareName":
            suggest = "share_name"
        elif key == "mountPath":
            suggest = "mount_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceStorageAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceStorageAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceStorageAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: str,
                 account_name: str,
                 name: str,
                 share_name: str,
                 type: str,
                 mount_path: Optional[str] = None):
        """
        :param str access_key: The access key for the storage account.
        :param str account_name: The name of the storage account.
        :param str name: The name of the storage account identifier.
        :param str share_name: The name of the file share (container name, for Blob storage).
        :param str type: The type of storage. Possible values are `AzureBlob` and `AzureFiles`.
        :param str mount_path: The path to mount the storage within the site's runtime environment.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "share_name", share_name)
        pulumi.set(__self__, "type", type)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> str:
        """
        The access key for the storage account.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> str:
        """
        The name of the storage account.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the storage account identifier.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> str:
        """
        The name of the file share (container name, for Blob storage).
        """
        return pulumi.get(self, "share_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of storage. Possible values are `AzureBlob` and `AzureFiles`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[str]:
        """
        The path to mount the storage within the site's runtime environment.
        """
        return pulumi.get(self, "mount_path")


@pulumi.output_type
class CertificateOrderCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateName":
            suggest = "certificate_name"
        elif key == "keyVaultId":
            suggest = "key_vault_id"
        elif key == "keyVaultSecretName":
            suggest = "key_vault_secret_name"
        elif key == "provisioningState":
            suggest = "provisioning_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CertificateOrderCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CertificateOrderCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CertificateOrderCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_name: Optional[str] = None,
                 key_vault_id: Optional[str] = None,
                 key_vault_secret_name: Optional[str] = None,
                 provisioning_state: Optional[str] = None):
        """
        :param str certificate_name: The name of the App Service Certificate.
        :param str key_vault_id: Key Vault resource Id.
        :param str key_vault_secret_name: Key Vault secret name.
        :param str provisioning_state: Status of the Key Vault secret.
        """
        if certificate_name is not None:
            pulumi.set(__self__, "certificate_name", certificate_name)
        if key_vault_id is not None:
            pulumi.set(__self__, "key_vault_id", key_vault_id)
        if key_vault_secret_name is not None:
            pulumi.set(__self__, "key_vault_secret_name", key_vault_secret_name)
        if provisioning_state is not None:
            pulumi.set(__self__, "provisioning_state", provisioning_state)

    @property
    @pulumi.getter(name="certificateName")
    def certificate_name(self) -> Optional[str]:
        """
        The name of the App Service Certificate.
        """
        return pulumi.get(self, "certificate_name")

    @property
    @pulumi.getter(name="keyVaultId")
    def key_vault_id(self) -> Optional[str]:
        """
        Key Vault resource Id.
        """
        return pulumi.get(self, "key_vault_id")

    @property
    @pulumi.getter(name="keyVaultSecretName")
    def key_vault_secret_name(self) -> Optional[str]:
        """
        Key Vault secret name.
        """
        return pulumi.get(self, "key_vault_secret_name")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> Optional[str]:
        """
        Status of the Key Vault secret.
        """
        return pulumi.get(self, "provisioning_state")


@pulumi.output_type
class ConnectionAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "subscriptionId":
            suggest = "subscription_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 certificate: Optional[str] = None,
                 client_id: Optional[str] = None,
                 name: Optional[str] = None,
                 principal_id: Optional[str] = None,
                 secret: Optional[str] = None,
                 subscription_id: Optional[str] = None):
        """
        :param str type: The authentication type. Possible values are `systemAssignedIdentity`, `userAssignedIdentity`, `servicePrincipalSecret`, `servicePrincipalCertificate`, `secret`. Changing this forces a new resource to be created.
        :param str certificate: Service principal certificate for `servicePrincipal` auth. Should be specified when `type` is set to `servicePrincipalCertificate`.
        :param str client_id: Client ID for `userAssignedIdentity` or `servicePrincipal` auth. Should be specified when `type` is set to `servicePrincipalSecret` or `servicePrincipalCertificate`. When `type` is set to `userAssignedIdentity`, `client_id` and `subscription_id` should be either both specified or both not specified.
        :param str name: Username or account name for secret auth. `name` and `secret` should be either both specified or both not specified when `type` is set to `secret`.
        :param str principal_id: Principal ID for `servicePrincipal` auth. Should be specified when `type` is set to `servicePrincipalSecret` or `servicePrincipalCertificate`.
        :param str secret: Password or account key for secret auth. `secret` and `name` should be either both specified or both not specified when `type` is set to `secret`.
        :param str subscription_id: Subscription ID for `userAssignedIdentity`. `subscription_id` and `client_id` should be either both specified or both not specified.
        """
        pulumi.set(__self__, "type", type)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The authentication type. Possible values are `systemAssignedIdentity`, `userAssignedIdentity`, `servicePrincipalSecret`, `servicePrincipalCertificate`, `secret`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[str]:
        """
        Service principal certificate for `servicePrincipal` auth. Should be specified when `type` is set to `servicePrincipalCertificate`.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        Client ID for `userAssignedIdentity` or `servicePrincipal` auth. Should be specified when `type` is set to `servicePrincipalSecret` or `servicePrincipalCertificate`. When `type` is set to `userAssignedIdentity`, `client_id` and `subscription_id` should be either both specified or both not specified.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Username or account name for secret auth. `name` and `secret` should be either both specified or both not specified when `type` is set to `secret`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        """
        Principal ID for `servicePrincipal` auth. Should be specified when `type` is set to `servicePrincipalSecret` or `servicePrincipalCertificate`.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter
    def secret(self) -> Optional[str]:
        """
        Password or account key for secret auth. `secret` and `name` should be either both specified or both not specified when `type` is set to `secret`.
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[str]:
        """
        Subscription ID for `userAssignedIdentity`. `subscription_id` and `client_id` should be either both specified or both not specified.
        """
        return pulumi.get(self, "subscription_id")


@pulumi.output_type
class ConnectionSecretStore(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVaultId":
            suggest = "key_vault_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionSecretStore. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionSecretStore.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionSecretStore.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_vault_id: str):
        """
        :param str key_vault_id: The key vault id to store secret.
        """
        pulumi.set(__self__, "key_vault_id", key_vault_id)

    @property
    @pulumi.getter(name="keyVaultId")
    def key_vault_id(self) -> str:
        """
        The key vault id to store secret.
        """
        return pulumi.get(self, "key_vault_id")


@pulumi.output_type
class EnvironmentClusterSetting(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: The name of the Cluster Setting.
        :param str value: The value for the Cluster Setting.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Cluster Setting.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the Cluster Setting.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EnvironmentV3ClusterSetting(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: The name of the Cluster Setting.
        :param str value: The value for the Cluster Setting.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Cluster Setting.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the Cluster Setting.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EnvironmentV3InboundNetworkDependency(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddresses":
            suggest = "ip_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EnvironmentV3InboundNetworkDependency. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EnvironmentV3InboundNetworkDependency.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EnvironmentV3InboundNetworkDependency.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[str] = None,
                 ip_addresses: Optional[Sequence[str]] = None,
                 ports: Optional[Sequence[str]] = None):
        """
        :param str description: A short description of the purpose of the network traffic.
        :param Sequence[str] ip_addresses: A list of IP addresses that network traffic will originate from in CIDR notation.
        :param Sequence[str] ports: The ports that network traffic will arrive to the App Service Environment V3 on.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A short description of the purpose of the network traffic.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[Sequence[str]]:
        """
        A list of IP addresses that network traffic will originate from in CIDR notation.
        """
        return pulumi.get(self, "ip_addresses")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[str]]:
        """
        The ports that network traffic will arrive to the App Service Environment V3 on.
        """
        return pulumi.get(self, "ports")


@pulumi.output_type
class FunctionAppAuthSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeDirectory":
            suggest = "active_directory"
        elif key == "additionalLoginParams":
            suggest = "additional_login_params"
        elif key == "allowedExternalRedirectUrls":
            suggest = "allowed_external_redirect_urls"
        elif key == "defaultProvider":
            suggest = "default_provider"
        elif key == "runtimeVersion":
            suggest = "runtime_version"
        elif key == "tokenRefreshExtensionHours":
            suggest = "token_refresh_extension_hours"
        elif key == "tokenStoreEnabled":
            suggest = "token_store_enabled"
        elif key == "unauthenticatedClientAction":
            suggest = "unauthenticated_client_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppAuthSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppAuthSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppAuthSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 active_directory: Optional['outputs.FunctionAppAuthSettingsActiveDirectory'] = None,
                 additional_login_params: Optional[Mapping[str, str]] = None,
                 allowed_external_redirect_urls: Optional[Sequence[str]] = None,
                 default_provider: Optional[str] = None,
                 facebook: Optional['outputs.FunctionAppAuthSettingsFacebook'] = None,
                 google: Optional['outputs.FunctionAppAuthSettingsGoogle'] = None,
                 issuer: Optional[str] = None,
                 microsoft: Optional['outputs.FunctionAppAuthSettingsMicrosoft'] = None,
                 runtime_version: Optional[str] = None,
                 token_refresh_extension_hours: Optional[float] = None,
                 token_store_enabled: Optional[bool] = None,
                 twitter: Optional['outputs.FunctionAppAuthSettingsTwitter'] = None,
                 unauthenticated_client_action: Optional[str] = None):
        """
        :param bool enabled: Is Authentication enabled?
        :param 'FunctionAppAuthSettingsActiveDirectoryArgs' active_directory: A `active_directory` block as defined below.
        :param Mapping[str, str] additional_login_params: Login parameters to send to the OpenID Connect authorization endpoint when a user logs in. Each parameter must be in the form "key=value".
        :param Sequence[str] allowed_external_redirect_urls: External URLs that can be redirected to as part of logging in or logging out of the app.
        :param str default_provider: The default provider to use when multiple providers have been set up. Possible values are `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount` and `Twitter`.
               
               > **NOTE:** When using multiple providers, the default provider must be set for settings like `unauthenticated_client_action` to work.
        :param 'FunctionAppAuthSettingsFacebookArgs' facebook: A `facebook` block as defined below.
        :param 'FunctionAppAuthSettingsGoogleArgs' google: A `google` block as defined below.
        :param str issuer: Issuer URI. When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        :param 'FunctionAppAuthSettingsMicrosoftArgs' microsoft: A `microsoft` block as defined below.
        :param str runtime_version: The runtime version of the Authentication/Authorization module.
        :param float token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72`.
        :param bool token_store_enabled: If enabled the module will durably store platform-specific security tokens that are obtained during login flows. Defaults to `false`.
        :param 'FunctionAppAuthSettingsTwitterArgs' twitter: A `twitter` block as defined below.
        :param str unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app. Possible values are `AllowAnonymous` and `RedirectToLoginPage`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if active_directory is not None:
            pulumi.set(__self__, "active_directory", active_directory)
        if additional_login_params is not None:
            pulumi.set(__self__, "additional_login_params", additional_login_params)
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if facebook is not None:
            pulumi.set(__self__, "facebook", facebook)
        if google is not None:
            pulumi.set(__self__, "google", google)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if microsoft is not None:
            pulumi.set(__self__, "microsoft", microsoft)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if token_refresh_extension_hours is not None:
            pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if twitter is not None:
            pulumi.set(__self__, "twitter", twitter)
        if unauthenticated_client_action is not None:
            pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is Authentication enabled?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="activeDirectory")
    def active_directory(self) -> Optional['outputs.FunctionAppAuthSettingsActiveDirectory']:
        """
        A `active_directory` block as defined below.
        """
        return pulumi.get(self, "active_directory")

    @property
    @pulumi.getter(name="additionalLoginParams")
    def additional_login_params(self) -> Optional[Mapping[str, str]]:
        """
        Login parameters to send to the OpenID Connect authorization endpoint when a user logs in. Each parameter must be in the form "key=value".
        """
        return pulumi.get(self, "additional_login_params")

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[Sequence[str]]:
        """
        External URLs that can be redirected to as part of logging in or logging out of the app.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[str]:
        """
        The default provider to use when multiple providers have been set up. Possible values are `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount` and `Twitter`.

        > **NOTE:** When using multiple providers, the default provider must be set for settings like `unauthenticated_client_action` to work.
        """
        return pulumi.get(self, "default_provider")

    @property
    @pulumi.getter
    def facebook(self) -> Optional['outputs.FunctionAppAuthSettingsFacebook']:
        """
        A `facebook` block as defined below.
        """
        return pulumi.get(self, "facebook")

    @property
    @pulumi.getter
    def google(self) -> Optional['outputs.FunctionAppAuthSettingsGoogle']:
        """
        A `google` block as defined below.
        """
        return pulumi.get(self, "google")

    @property
    @pulumi.getter
    def issuer(self) -> Optional[str]:
        """
        Issuer URI. When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def microsoft(self) -> Optional['outputs.FunctionAppAuthSettingsMicrosoft']:
        """
        A `microsoft` block as defined below.
        """
        return pulumi.get(self, "microsoft")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[str]:
        """
        The runtime version of the Authentication/Authorization module.
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> Optional[float]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72`.
        """
        return pulumi.get(self, "token_refresh_extension_hours")

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[bool]:
        """
        If enabled the module will durably store platform-specific security tokens that are obtained during login flows. Defaults to `false`.
        """
        return pulumi.get(self, "token_store_enabled")

    @property
    @pulumi.getter
    def twitter(self) -> Optional['outputs.FunctionAppAuthSettingsTwitter']:
        """
        A `twitter` block as defined below.
        """
        return pulumi.get(self, "twitter")

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> Optional[str]:
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values are `AllowAnonymous` and `RedirectToLoginPage`.
        """
        return pulumi.get(self, "unauthenticated_client_action")


@pulumi.output_type
class FunctionAppAuthSettingsActiveDirectory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "clientSecret":
            suggest = "client_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppAuthSettingsActiveDirectory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppAuthSettingsActiveDirectory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppAuthSettingsActiveDirectory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 client_secret: Optional[str] = None):
        """
        :param str client_id: The Client ID of this relying party application. Enables OpenIDConnection authentication with Azure Active Directory.
        :param Sequence[str] allowed_audiences: Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
        :param str client_secret: The Client Secret of this relying party application. If no secret is provided, implicit flow will be used.
        """
        pulumi.set(__self__, "client_id", client_id)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The Client ID of this relying party application. Enables OpenIDConnection authentication with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret of this relying party application. If no secret is provided, implicit flow will be used.
        """
        return pulumi.get(self, "client_secret")


@pulumi.output_type
class FunctionAppAuthSettingsFacebook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "appSecret":
            suggest = "app_secret"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppAuthSettingsFacebook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppAuthSettingsFacebook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppAuthSettingsFacebook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: str,
                 app_secret: str,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str app_id: The App ID of the Facebook app used for login
        :param str app_secret: The App Secret of the Facebook app used for Facebook login.
        :param Sequence[str] oauth_scopes: The OAuth 2.0 scopes that will be requested as part of Facebook login authentication. <https://developers.facebook.com/docs/facebook-login>
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "app_secret", app_secret)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        The App ID of the Facebook app used for login
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appSecret")
    def app_secret(self) -> str:
        """
        The App Secret of the Facebook app used for Facebook login.
        """
        return pulumi.get(self, "app_secret")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        The OAuth 2.0 scopes that will be requested as part of Facebook login authentication. <https://developers.facebook.com/docs/facebook-login>
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class FunctionAppAuthSettingsGoogle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppAuthSettingsGoogle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppAuthSettingsGoogle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppAuthSettingsGoogle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OpenID Connect Client ID for the Google web application.
        :param str client_secret: The client secret associated with the Google web application.
        :param Sequence[str] oauth_scopes: The OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. <https://developers.google.com/identity/sign-in/web/>
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OpenID Connect Client ID for the Google web application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The client secret associated with the Google web application.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        The OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. <https://developers.google.com/identity/sign-in/web/>
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class FunctionAppAuthSettingsMicrosoft(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppAuthSettingsMicrosoft. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppAuthSettingsMicrosoft.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppAuthSettingsMicrosoft.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret: The OAuth 2.0 client secret that was created for the app used for authentication.
        :param Sequence[str] oauth_scopes: The OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. <https://msdn.microsoft.com/en-us/library/dn631845.aspx>
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        The OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. <https://msdn.microsoft.com/en-us/library/dn631845.aspx>
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class FunctionAppAuthSettingsTwitter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerKey":
            suggest = "consumer_key"
        elif key == "consumerSecret":
            suggest = "consumer_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppAuthSettingsTwitter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppAuthSettingsTwitter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppAuthSettingsTwitter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_key: str,
                 consumer_secret: str):
        """
        :param str consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param str consumer_secret: The OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        pulumi.set(__self__, "consumer_secret", consumer_secret)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> str:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> str:
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_secret")


@pulumi.output_type
class FunctionAppConnectionString(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: The name of the Connection String.
        :param str type: The type of the Connection String. Possible values are `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure` and `SQLServer`.
        :param str value: The value for the Connection String.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Connection String.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the Connection String. Possible values are `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure` and `SQLServer`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the Connection String.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class FunctionAppFunctionFile(dict):
    def __init__(__self__, *,
                 content: str,
                 name: str):
        """
        :param str content: The content of the file. Changing this forces a new resource to be created.
        :param str name: The filename of the file to be uploaded. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def content(self) -> str:
        """
        The content of the file. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The filename of the file to be uploaded. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class FunctionAppIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 identity_ids: Optional[Sequence[str]] = None,
                 principal_id: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str type: Specifies the identity type of the Function App. Possible values are `SystemAssigned` (where Azure will generate a Service Principal for you), `UserAssigned` where you can specify the Service Principal IDs in the `identity_ids` field, and `SystemAssigned, UserAssigned` which assigns both a system managed identity as well as the specified user assigned identities.
               
               > **NOTE:** When `type` is set to `SystemAssigned`, The assigned `principal_id` and `tenant_id` can be retrieved after the Function App has been created. More details are available below.
        :param Sequence[str] identity_ids: Specifies a list of user managed identity ids to be assigned. Required if `type` is `UserAssigned`.
        :param str principal_id: The Principal ID for the Service Principal associated with the Managed Service Identity of this App Service.
        :param str tenant_id: The Tenant ID for the Service Principal associated with the Managed Service Identity of this App Service.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the identity type of the Function App. Possible values are `SystemAssigned` (where Azure will generate a Service Principal for you), `UserAssigned` where you can specify the Service Principal IDs in the `identity_ids` field, and `SystemAssigned, UserAssigned` which assigns both a system managed identity as well as the specified user assigned identities.

        > **NOTE:** When `type` is set to `SystemAssigned`, The assigned `principal_id` and `tenant_id` can be retrieved after the Function App has been created. More details are available below.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of user managed identity ids to be assigned. Required if `type` is `UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        """
        The Principal ID for the Service Principal associated with the Managed Service Identity of this App Service.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The Tenant ID for the Service Principal associated with the Managed Service Identity of this App Service.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class FunctionAppSiteConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alwaysOn":
            suggest = "always_on"
        elif key == "appScaleLimit":
            suggest = "app_scale_limit"
        elif key == "autoSwapSlotName":
            suggest = "auto_swap_slot_name"
        elif key == "dotnetFrameworkVersion":
            suggest = "dotnet_framework_version"
        elif key == "elasticInstanceMinimum":
            suggest = "elastic_instance_minimum"
        elif key == "ftpsState":
            suggest = "ftps_state"
        elif key == "healthCheckPath":
            suggest = "health_check_path"
        elif key == "http2Enabled":
            suggest = "http2_enabled"
        elif key == "ipRestrictions":
            suggest = "ip_restrictions"
        elif key == "javaVersion":
            suggest = "java_version"
        elif key == "linuxFxVersion":
            suggest = "linux_fx_version"
        elif key == "minTlsVersion":
            suggest = "min_tls_version"
        elif key == "preWarmedInstanceCount":
            suggest = "pre_warmed_instance_count"
        elif key == "runtimeScaleMonitoringEnabled":
            suggest = "runtime_scale_monitoring_enabled"
        elif key == "scmIpRestrictions":
            suggest = "scm_ip_restrictions"
        elif key == "scmType":
            suggest = "scm_type"
        elif key == "scmUseMainIpRestriction":
            suggest = "scm_use_main_ip_restriction"
        elif key == "use32BitWorkerProcess":
            suggest = "use32_bit_worker_process"
        elif key == "vnetRouteAllEnabled":
            suggest = "vnet_route_all_enabled"
        elif key == "websocketsEnabled":
            suggest = "websockets_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppSiteConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppSiteConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppSiteConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 always_on: Optional[bool] = None,
                 app_scale_limit: Optional[int] = None,
                 auto_swap_slot_name: Optional[str] = None,
                 cors: Optional['outputs.FunctionAppSiteConfigCors'] = None,
                 dotnet_framework_version: Optional[str] = None,
                 elastic_instance_minimum: Optional[int] = None,
                 ftps_state: Optional[str] = None,
                 health_check_path: Optional[str] = None,
                 http2_enabled: Optional[bool] = None,
                 ip_restrictions: Optional[Sequence['outputs.FunctionAppSiteConfigIpRestriction']] = None,
                 java_version: Optional[str] = None,
                 linux_fx_version: Optional[str] = None,
                 min_tls_version: Optional[str] = None,
                 pre_warmed_instance_count: Optional[int] = None,
                 runtime_scale_monitoring_enabled: Optional[bool] = None,
                 scm_ip_restrictions: Optional[Sequence['outputs.FunctionAppSiteConfigScmIpRestriction']] = None,
                 scm_type: Optional[str] = None,
                 scm_use_main_ip_restriction: Optional[bool] = None,
                 use32_bit_worker_process: Optional[bool] = None,
                 vnet_route_all_enabled: Optional[bool] = None,
                 websockets_enabled: Optional[bool] = None):
        """
        :param bool always_on: Should the Function App be loaded at all times? Defaults to `false`.
        :param int app_scale_limit: The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
        :param str auto_swap_slot_name: The name of the slot to automatically swap to during deployment
               
               > **NOTE:** This attribute is only used for slots.
        :param 'FunctionAppSiteConfigCorsArgs' cors: A `cors` block as defined below.
        :param str dotnet_framework_version: The version of the .NET framework's CLR used in this function app. Possible values are `v4.0` (including .NET Core 2.1 and 3.1), `v5.0` and `v6.0`. [For more information on which .NET Framework version to use based on the runtime version you're targeting - please see this table](https://docs.microsoft.com/azure/azure-functions/functions-dotnet-class-library#supported-versions). Defaults to `v4.0`.
        :param int elastic_instance_minimum: The number of minimum instances for this function app. Only affects apps on the Premium plan.
        :param str ftps_state: State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`. Defaults to `AllAllowed`.
        :param str health_check_path: Path which will be checked for this function app health.
        :param bool http2_enabled: Specifies whether or not the HTTP2 protocol should be enabled. Defaults to `false`.
        :param Sequence['FunctionAppSiteConfigIpRestrictionArgs'] ip_restrictions: A [List of objects](https://www.terraform.io/docs/configuration/attr-as-blocks.html) representing IP restrictions as defined below.
               
               > **NOTE** User has to explicitly set `ip_restriction` to empty slice (`[]`) to remove it.
        :param str java_version: Java version hosted by the function app in Azure. Possible values are `1.8`, `11` & `17` (In-Preview).
        :param str linux_fx_version: Linux App Framework and version for the AppService, e.g. `DOCKER|(golang:latest)`.
        :param str min_tls_version: The minimum supported TLS version for the function app. Possible values are `1.0`, `1.1`, and `1.2`. Defaults to `1.2` for new function apps.
        :param int pre_warmed_instance_count: The number of pre-warmed instances for this function app. Only affects apps on the Premium plan.
        :param bool runtime_scale_monitoring_enabled: Should Runtime Scale Monitoring be enabled?. Only applicable to apps on the Premium plan. Defaults to `false`.
        :param Sequence['FunctionAppSiteConfigScmIpRestrictionArgs'] scm_ip_restrictions: A [List of objects](https://www.terraform.io/docs/configuration/attr-as-blocks.html) representing IP restrictions as defined below.
               
               > **NOTE** User has to explicitly set `scm_ip_restriction` to empty slice (`[]`) to remove it.
        :param str scm_type: The type of Source Control used by the Function App. Valid values include: `BitBucketGit`, `BitBucketHg`, `CodePlexGit`, `CodePlexHg`, `Dropbox`, `ExternalGit`, `ExternalHg`, `GitHub`, `LocalGit`, `None` (default), `OneDrive`, `Tfs`, `VSO`, and `VSTSRM`.
               
               > **NOTE:** This setting is incompatible with the `source_control` block which updates this value based on the setting provided.
        :param bool scm_use_main_ip_restriction: IP security restrictions for scm to use main. Defaults to `false`. 
               
               > **NOTE** Any `scm_ip_restriction` blocks configured are ignored by the service when `scm_use_main_ip_restriction` is set to `true`. Any scm restrictions will become active if this is subsequently set to `false` or removed.
        :param bool use32_bit_worker_process: Should the Function App run in 32 bit mode, rather than 64 bit mode? Defaults to `true`.
               
               > **Note:** when using an App Service Plan in the `Free` or `Shared` Tiers `use_32_bit_worker_process` must be set to `true`.
        :param bool websockets_enabled: Should WebSockets be enabled?
        """
        if always_on is not None:
            pulumi.set(__self__, "always_on", always_on)
        if app_scale_limit is not None:
            pulumi.set(__self__, "app_scale_limit", app_scale_limit)
        if auto_swap_slot_name is not None:
            pulumi.set(__self__, "auto_swap_slot_name", auto_swap_slot_name)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if dotnet_framework_version is not None:
            pulumi.set(__self__, "dotnet_framework_version", dotnet_framework_version)
        if elastic_instance_minimum is not None:
            pulumi.set(__self__, "elastic_instance_minimum", elastic_instance_minimum)
        if ftps_state is not None:
            pulumi.set(__self__, "ftps_state", ftps_state)
        if health_check_path is not None:
            pulumi.set(__self__, "health_check_path", health_check_path)
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if ip_restrictions is not None:
            pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        if java_version is not None:
            pulumi.set(__self__, "java_version", java_version)
        if linux_fx_version is not None:
            pulumi.set(__self__, "linux_fx_version", linux_fx_version)
        if min_tls_version is not None:
            pulumi.set(__self__, "min_tls_version", min_tls_version)
        if pre_warmed_instance_count is not None:
            pulumi.set(__self__, "pre_warmed_instance_count", pre_warmed_instance_count)
        if runtime_scale_monitoring_enabled is not None:
            pulumi.set(__self__, "runtime_scale_monitoring_enabled", runtime_scale_monitoring_enabled)
        if scm_ip_restrictions is not None:
            pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        if scm_type is not None:
            pulumi.set(__self__, "scm_type", scm_type)
        if scm_use_main_ip_restriction is not None:
            pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        if use32_bit_worker_process is not None:
            pulumi.set(__self__, "use32_bit_worker_process", use32_bit_worker_process)
        if vnet_route_all_enabled is not None:
            pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        if websockets_enabled is not None:
            pulumi.set(__self__, "websockets_enabled", websockets_enabled)

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> Optional[bool]:
        """
        Should the Function App be loaded at all times? Defaults to `false`.
        """
        return pulumi.get(self, "always_on")

    @property
    @pulumi.getter(name="appScaleLimit")
    def app_scale_limit(self) -> Optional[int]:
        """
        The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
        """
        return pulumi.get(self, "app_scale_limit")

    @property
    @pulumi.getter(name="autoSwapSlotName")
    def auto_swap_slot_name(self) -> Optional[str]:
        """
        The name of the slot to automatically swap to during deployment

        > **NOTE:** This attribute is only used for slots.
        """
        return pulumi.get(self, "auto_swap_slot_name")

    @property
    @pulumi.getter
    def cors(self) -> Optional['outputs.FunctionAppSiteConfigCors']:
        """
        A `cors` block as defined below.
        """
        return pulumi.get(self, "cors")

    @property
    @pulumi.getter(name="dotnetFrameworkVersion")
    def dotnet_framework_version(self) -> Optional[str]:
        """
        The version of the .NET framework's CLR used in this function app. Possible values are `v4.0` (including .NET Core 2.1 and 3.1), `v5.0` and `v6.0`. [For more information on which .NET Framework version to use based on the runtime version you're targeting - please see this table](https://docs.microsoft.com/azure/azure-functions/functions-dotnet-class-library#supported-versions). Defaults to `v4.0`.
        """
        return pulumi.get(self, "dotnet_framework_version")

    @property
    @pulumi.getter(name="elasticInstanceMinimum")
    def elastic_instance_minimum(self) -> Optional[int]:
        """
        The number of minimum instances for this function app. Only affects apps on the Premium plan.
        """
        return pulumi.get(self, "elastic_instance_minimum")

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> Optional[str]:
        """
        State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`. Defaults to `AllAllowed`.
        """
        return pulumi.get(self, "ftps_state")

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> Optional[str]:
        """
        Path which will be checked for this function app health.
        """
        return pulumi.get(self, "health_check_path")

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[bool]:
        """
        Specifies whether or not the HTTP2 protocol should be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "http2_enabled")

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Optional[Sequence['outputs.FunctionAppSiteConfigIpRestriction']]:
        """
        A [List of objects](https://www.terraform.io/docs/configuration/attr-as-blocks.html) representing IP restrictions as defined below.

        > **NOTE** User has to explicitly set `ip_restriction` to empty slice (`[]`) to remove it.
        """
        return pulumi.get(self, "ip_restrictions")

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> Optional[str]:
        """
        Java version hosted by the function app in Azure. Possible values are `1.8`, `11` & `17` (In-Preview).
        """
        return pulumi.get(self, "java_version")

    @property
    @pulumi.getter(name="linuxFxVersion")
    def linux_fx_version(self) -> Optional[str]:
        """
        Linux App Framework and version for the AppService, e.g. `DOCKER|(golang:latest)`.
        """
        return pulumi.get(self, "linux_fx_version")

    @property
    @pulumi.getter(name="minTlsVersion")
    def min_tls_version(self) -> Optional[str]:
        """
        The minimum supported TLS version for the function app. Possible values are `1.0`, `1.1`, and `1.2`. Defaults to `1.2` for new function apps.
        """
        return pulumi.get(self, "min_tls_version")

    @property
    @pulumi.getter(name="preWarmedInstanceCount")
    def pre_warmed_instance_count(self) -> Optional[int]:
        """
        The number of pre-warmed instances for this function app. Only affects apps on the Premium plan.
        """
        return pulumi.get(self, "pre_warmed_instance_count")

    @property
    @pulumi.getter(name="runtimeScaleMonitoringEnabled")
    def runtime_scale_monitoring_enabled(self) -> Optional[bool]:
        """
        Should Runtime Scale Monitoring be enabled?. Only applicable to apps on the Premium plan. Defaults to `false`.
        """
        return pulumi.get(self, "runtime_scale_monitoring_enabled")

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Optional[Sequence['outputs.FunctionAppSiteConfigScmIpRestriction']]:
        """
        A [List of objects](https://www.terraform.io/docs/configuration/attr-as-blocks.html) representing IP restrictions as defined below.

        > **NOTE** User has to explicitly set `scm_ip_restriction` to empty slice (`[]`) to remove it.
        """
        return pulumi.get(self, "scm_ip_restrictions")

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> Optional[str]:
        """
        The type of Source Control used by the Function App. Valid values include: `BitBucketGit`, `BitBucketHg`, `CodePlexGit`, `CodePlexHg`, `Dropbox`, `ExternalGit`, `ExternalHg`, `GitHub`, `LocalGit`, `None` (default), `OneDrive`, `Tfs`, `VSO`, and `VSTSRM`.

        > **NOTE:** This setting is incompatible with the `source_control` block which updates this value based on the setting provided.
        """
        return pulumi.get(self, "scm_type")

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> Optional[bool]:
        """
        IP security restrictions for scm to use main. Defaults to `false`. 

        > **NOTE** Any `scm_ip_restriction` blocks configured are ignored by the service when `scm_use_main_ip_restriction` is set to `true`. Any scm restrictions will become active if this is subsequently set to `false` or removed.
        """
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @property
    @pulumi.getter(name="use32BitWorkerProcess")
    def use32_bit_worker_process(self) -> Optional[bool]:
        """
        Should the Function App run in 32 bit mode, rather than 64 bit mode? Defaults to `true`.

        > **Note:** when using an App Service Plan in the `Free` or `Shared` Tiers `use_32_bit_worker_process` must be set to `true`.
        """
        return pulumi.get(self, "use32_bit_worker_process")

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "vnet_route_all_enabled")

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> Optional[bool]:
        """
        Should WebSockets be enabled?
        """
        return pulumi.get(self, "websockets_enabled")


@pulumi.output_type
class FunctionAppSiteConfigCors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedOrigins":
            suggest = "allowed_origins"
        elif key == "supportCredentials":
            suggest = "support_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppSiteConfigCors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppSiteConfigCors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppSiteConfigCors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_origins: Sequence[str],
                 support_credentials: Optional[bool] = None):
        """
        :param Sequence[str] allowed_origins: A list of origins which should be able to make cross-origin calls. `*` can be used to allow all calls.
        :param bool support_credentials: Are credentials supported?
        """
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        if support_credentials is not None:
            pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Sequence[str]:
        """
        A list of origins which should be able to make cross-origin calls. `*` can be used to allow all calls.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> Optional[bool]:
        """
        Are credentials supported?
        """
        return pulumi.get(self, "support_credentials")


@pulumi.output_type
class FunctionAppSiteConfigIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppSiteConfigIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppSiteConfigIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppSiteConfigIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.FunctionAppSiteConfigIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: Does this restriction `Allow` or `Deny` access for this IP range. Defaults to `Allow`.
        :param 'FunctionAppSiteConfigIpRestrictionHeadersArgs' headers: The headers for this specific `ip_restriction` as defined below.
        :param str ip_address: The IP Address used for this IP Restriction in CIDR notation.
        :param str name: The name for this IP Restriction.
        :param int priority: The priority for this IP Restriction. Restrictions are enforced in priority order. By default, the priority is set to 65000 if not specified.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
               
               > **NOTE:** One of either `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        Does this restriction `Allow` or `Deny` access for this IP range. Defaults to `Allow`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.FunctionAppSiteConfigIpRestrictionHeaders']:
        """
        The headers for this specific `ip_restriction` as defined below.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The IP Address used for this IP Restriction in CIDR notation.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name for this IP Restriction.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority for this IP Restriction. Restrictions are enforced in priority order. By default, the priority is set to 65000 if not specified.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One of either `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class FunctionAppSiteConfigIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppSiteConfigIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        :param str x_fd_health_probe: A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        :param Sequence[str] x_forwarded_fors: A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        :param Sequence[str] x_forwarded_hosts: A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class FunctionAppSiteConfigScmIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppSiteConfigScmIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppSiteConfigScmIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppSiteConfigScmIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.FunctionAppSiteConfigScmIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: Allow or Deny access for this IP range. Defaults to `Allow`.
        :param 'FunctionAppSiteConfigScmIpRestrictionHeadersArgs' headers: The headers for this specific `scm_ip_restriction` as defined below.
        :param str ip_address: The IP Address used for this IP Restriction in CIDR notation.
        :param str name: The name for this IP Restriction.
        :param int priority: The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
               
               > **NOTE:** One of either `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        Allow or Deny access for this IP range. Defaults to `Allow`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.FunctionAppSiteConfigScmIpRestrictionHeaders']:
        """
        The headers for this specific `scm_ip_restriction` as defined below.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The IP Address used for this IP Restriction in CIDR notation.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name for this IP Restriction.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One of either `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class FunctionAppSiteConfigScmIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppSiteConfigScmIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        :param str x_fd_health_probe: A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        :param Sequence[str] x_forwarded_fors: A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        :param Sequence[str] x_forwarded_hosts: A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class FunctionAppSiteCredential(dict):
    def __init__(__self__, *,
                 password: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str password: The password associated with the username, which can be used to publish to this App Service.
        :param str username: The username which can be used to publish to this App Service
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password associated with the username, which can be used to publish to this App Service.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username which can be used to publish to this App Service
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class FunctionAppSlotAuthSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeDirectory":
            suggest = "active_directory"
        elif key == "additionalLoginParams":
            suggest = "additional_login_params"
        elif key == "allowedExternalRedirectUrls":
            suggest = "allowed_external_redirect_urls"
        elif key == "defaultProvider":
            suggest = "default_provider"
        elif key == "runtimeVersion":
            suggest = "runtime_version"
        elif key == "tokenRefreshExtensionHours":
            suggest = "token_refresh_extension_hours"
        elif key == "tokenStoreEnabled":
            suggest = "token_store_enabled"
        elif key == "unauthenticatedClientAction":
            suggest = "unauthenticated_client_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppSlotAuthSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppSlotAuthSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppSlotAuthSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 active_directory: Optional['outputs.FunctionAppSlotAuthSettingsActiveDirectory'] = None,
                 additional_login_params: Optional[Mapping[str, str]] = None,
                 allowed_external_redirect_urls: Optional[Sequence[str]] = None,
                 default_provider: Optional[str] = None,
                 facebook: Optional['outputs.FunctionAppSlotAuthSettingsFacebook'] = None,
                 google: Optional['outputs.FunctionAppSlotAuthSettingsGoogle'] = None,
                 issuer: Optional[str] = None,
                 microsoft: Optional['outputs.FunctionAppSlotAuthSettingsMicrosoft'] = None,
                 runtime_version: Optional[str] = None,
                 token_refresh_extension_hours: Optional[float] = None,
                 token_store_enabled: Optional[bool] = None,
                 twitter: Optional['outputs.FunctionAppSlotAuthSettingsTwitter'] = None,
                 unauthenticated_client_action: Optional[str] = None):
        """
        :param bool enabled: Is Authentication enabled?
        :param 'FunctionAppSlotAuthSettingsActiveDirectoryArgs' active_directory: An `active_directory` block as defined below.
        :param Mapping[str, str] additional_login_params: login parameters to send to the OpenID Connect authorization endpoint when a user logs in. Each parameter must be in the form "key=value".
        :param Sequence[str] allowed_external_redirect_urls: External URLs that can be redirected to as part of logging in or logging out of the app.
        :param str default_provider: The default provider to use when multiple providers have been set up. Possible values are `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount` and `Twitter`.
               
               > **NOTE:** When using multiple providers, the default provider must be set for settings like `unauthenticated_client_action` to work.
        :param 'FunctionAppSlotAuthSettingsFacebookArgs' facebook: A `facebook` block as defined below.
        :param 'FunctionAppSlotAuthSettingsGoogleArgs' google: A `google` block as defined below.
        :param str issuer: Issuer URI. When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        :param 'FunctionAppSlotAuthSettingsMicrosoftArgs' microsoft: A `microsoft` block as defined below.
        :param str runtime_version: The runtime version of the Authentication/Authorization module.
        :param float token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72`.
        :param bool token_store_enabled: If enabled the module will durably store platform-specific security tokens that are obtained during login flows. Defaults to `false`.
        :param 'FunctionAppSlotAuthSettingsTwitterArgs' twitter: A `twitter` block as defined below.
        :param str unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app. Possible values are `AllowAnonymous` and `RedirectToLoginPage`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if active_directory is not None:
            pulumi.set(__self__, "active_directory", active_directory)
        if additional_login_params is not None:
            pulumi.set(__self__, "additional_login_params", additional_login_params)
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if facebook is not None:
            pulumi.set(__self__, "facebook", facebook)
        if google is not None:
            pulumi.set(__self__, "google", google)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if microsoft is not None:
            pulumi.set(__self__, "microsoft", microsoft)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if token_refresh_extension_hours is not None:
            pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if twitter is not None:
            pulumi.set(__self__, "twitter", twitter)
        if unauthenticated_client_action is not None:
            pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is Authentication enabled?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="activeDirectory")
    def active_directory(self) -> Optional['outputs.FunctionAppSlotAuthSettingsActiveDirectory']:
        """
        An `active_directory` block as defined below.
        """
        return pulumi.get(self, "active_directory")

    @property
    @pulumi.getter(name="additionalLoginParams")
    def additional_login_params(self) -> Optional[Mapping[str, str]]:
        """
        login parameters to send to the OpenID Connect authorization endpoint when a user logs in. Each parameter must be in the form "key=value".
        """
        return pulumi.get(self, "additional_login_params")

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[Sequence[str]]:
        """
        External URLs that can be redirected to as part of logging in or logging out of the app.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[str]:
        """
        The default provider to use when multiple providers have been set up. Possible values are `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount` and `Twitter`.

        > **NOTE:** When using multiple providers, the default provider must be set for settings like `unauthenticated_client_action` to work.
        """
        return pulumi.get(self, "default_provider")

    @property
    @pulumi.getter
    def facebook(self) -> Optional['outputs.FunctionAppSlotAuthSettingsFacebook']:
        """
        A `facebook` block as defined below.
        """
        return pulumi.get(self, "facebook")

    @property
    @pulumi.getter
    def google(self) -> Optional['outputs.FunctionAppSlotAuthSettingsGoogle']:
        """
        A `google` block as defined below.
        """
        return pulumi.get(self, "google")

    @property
    @pulumi.getter
    def issuer(self) -> Optional[str]:
        """
        Issuer URI. When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def microsoft(self) -> Optional['outputs.FunctionAppSlotAuthSettingsMicrosoft']:
        """
        A `microsoft` block as defined below.
        """
        return pulumi.get(self, "microsoft")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[str]:
        """
        The runtime version of the Authentication/Authorization module.
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> Optional[float]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72`.
        """
        return pulumi.get(self, "token_refresh_extension_hours")

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[bool]:
        """
        If enabled the module will durably store platform-specific security tokens that are obtained during login flows. Defaults to `false`.
        """
        return pulumi.get(self, "token_store_enabled")

    @property
    @pulumi.getter
    def twitter(self) -> Optional['outputs.FunctionAppSlotAuthSettingsTwitter']:
        """
        A `twitter` block as defined below.
        """
        return pulumi.get(self, "twitter")

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> Optional[str]:
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values are `AllowAnonymous` and `RedirectToLoginPage`.
        """
        return pulumi.get(self, "unauthenticated_client_action")


@pulumi.output_type
class FunctionAppSlotAuthSettingsActiveDirectory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "clientSecret":
            suggest = "client_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppSlotAuthSettingsActiveDirectory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppSlotAuthSettingsActiveDirectory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppSlotAuthSettingsActiveDirectory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 client_secret: Optional[str] = None):
        """
        :param str client_id: The Client ID of this relying party application. Enables OpenIDConnection authentication with Azure Active Directory.
        :param Sequence[str] allowed_audiences: Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
        :param str client_secret: The Client Secret of this relying party application. If no secret is provided, implicit flow will be used.
        """
        pulumi.set(__self__, "client_id", client_id)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The Client ID of this relying party application. Enables OpenIDConnection authentication with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret of this relying party application. If no secret is provided, implicit flow will be used.
        """
        return pulumi.get(self, "client_secret")


@pulumi.output_type
class FunctionAppSlotAuthSettingsFacebook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "appSecret":
            suggest = "app_secret"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppSlotAuthSettingsFacebook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppSlotAuthSettingsFacebook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppSlotAuthSettingsFacebook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: str,
                 app_secret: str,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str app_id: The App ID of the Facebook app used for login
        :param str app_secret: The App Secret of the Facebook app used for Facebook login.
        :param Sequence[str] oauth_scopes: The OAuth 2.0 scopes that will be requested as part of Facebook login authentication. <https://developers.facebook.com/docs/facebook-login>
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "app_secret", app_secret)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        The App ID of the Facebook app used for login
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appSecret")
    def app_secret(self) -> str:
        """
        The App Secret of the Facebook app used for Facebook login.
        """
        return pulumi.get(self, "app_secret")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        The OAuth 2.0 scopes that will be requested as part of Facebook login authentication. <https://developers.facebook.com/docs/facebook-login>
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class FunctionAppSlotAuthSettingsGoogle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppSlotAuthSettingsGoogle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppSlotAuthSettingsGoogle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppSlotAuthSettingsGoogle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OpenID Connect Client ID for the Google web application.
        :param str client_secret: The client secret associated with the Google web application.
        :param Sequence[str] oauth_scopes: The OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. <https://developers.google.com/identity/sign-in/web/>
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OpenID Connect Client ID for the Google web application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The client secret associated with the Google web application.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        The OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. <https://developers.google.com/identity/sign-in/web/>
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class FunctionAppSlotAuthSettingsMicrosoft(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppSlotAuthSettingsMicrosoft. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppSlotAuthSettingsMicrosoft.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppSlotAuthSettingsMicrosoft.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret: The OAuth 2.0 client secret that was created for the app used for authentication.
        :param Sequence[str] oauth_scopes: The OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. <https://msdn.microsoft.com/en-us/library/dn631845.aspx>
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        The OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. <https://msdn.microsoft.com/en-us/library/dn631845.aspx>
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class FunctionAppSlotAuthSettingsTwitter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerKey":
            suggest = "consumer_key"
        elif key == "consumerSecret":
            suggest = "consumer_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppSlotAuthSettingsTwitter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppSlotAuthSettingsTwitter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppSlotAuthSettingsTwitter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_key: str,
                 consumer_secret: str):
        """
        :param str consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param str consumer_secret: The OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        pulumi.set(__self__, "consumer_secret", consumer_secret)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> str:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> str:
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_secret")


@pulumi.output_type
class FunctionAppSlotConnectionString(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: The name of the Connection String.
        :param str type: The type of the Connection String. Possible values are `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure` and `SQLServer`.
        :param str value: The value for the Connection String.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Connection String.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the Connection String. Possible values are `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure` and `SQLServer`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the Connection String.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class FunctionAppSlotIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppSlotIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppSlotIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppSlotIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 identity_ids: Optional[Sequence[str]] = None,
                 principal_id: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str type: Specifies the identity type of the Function App. Possible values are `SystemAssigned` (where Azure will generate a Service Principal for you), `UserAssigned` where you can specify the Service Principal IDs in the `identity_ids` field, and `SystemAssigned, UserAssigned` which assigns both a system managed identity as well as the specified user assigned identities.
               
               > **NOTE:** When `type` is set to `SystemAssigned`, The assigned `principal_id` and `tenant_id` can be retrieved after the Function App has been created. More details are available below.
        :param Sequence[str] identity_ids: Specifies a list of user managed identity ids to be assigned. Required if `type` is `UserAssigned`.
        :param str principal_id: The Principal ID for the Service Principal associated with the Managed Service Identity of this App Service.
        :param str tenant_id: The Tenant ID for the Service Principal associated with the Managed Service Identity of this App Service.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the identity type of the Function App. Possible values are `SystemAssigned` (where Azure will generate a Service Principal for you), `UserAssigned` where you can specify the Service Principal IDs in the `identity_ids` field, and `SystemAssigned, UserAssigned` which assigns both a system managed identity as well as the specified user assigned identities.

        > **NOTE:** When `type` is set to `SystemAssigned`, The assigned `principal_id` and `tenant_id` can be retrieved after the Function App has been created. More details are available below.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of user managed identity ids to be assigned. Required if `type` is `UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        """
        The Principal ID for the Service Principal associated with the Managed Service Identity of this App Service.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The Tenant ID for the Service Principal associated with the Managed Service Identity of this App Service.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class FunctionAppSlotSiteConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alwaysOn":
            suggest = "always_on"
        elif key == "appScaleLimit":
            suggest = "app_scale_limit"
        elif key == "autoSwapSlotName":
            suggest = "auto_swap_slot_name"
        elif key == "dotnetFrameworkVersion":
            suggest = "dotnet_framework_version"
        elif key == "elasticInstanceMinimum":
            suggest = "elastic_instance_minimum"
        elif key == "ftpsState":
            suggest = "ftps_state"
        elif key == "healthCheckPath":
            suggest = "health_check_path"
        elif key == "http2Enabled":
            suggest = "http2_enabled"
        elif key == "ipRestrictions":
            suggest = "ip_restrictions"
        elif key == "javaVersion":
            suggest = "java_version"
        elif key == "linuxFxVersion":
            suggest = "linux_fx_version"
        elif key == "minTlsVersion":
            suggest = "min_tls_version"
        elif key == "preWarmedInstanceCount":
            suggest = "pre_warmed_instance_count"
        elif key == "runtimeScaleMonitoringEnabled":
            suggest = "runtime_scale_monitoring_enabled"
        elif key == "scmIpRestrictions":
            suggest = "scm_ip_restrictions"
        elif key == "scmType":
            suggest = "scm_type"
        elif key == "scmUseMainIpRestriction":
            suggest = "scm_use_main_ip_restriction"
        elif key == "use32BitWorkerProcess":
            suggest = "use32_bit_worker_process"
        elif key == "vnetRouteAllEnabled":
            suggest = "vnet_route_all_enabled"
        elif key == "websocketsEnabled":
            suggest = "websockets_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppSlotSiteConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppSlotSiteConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppSlotSiteConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 always_on: Optional[bool] = None,
                 app_scale_limit: Optional[int] = None,
                 auto_swap_slot_name: Optional[str] = None,
                 cors: Optional['outputs.FunctionAppSlotSiteConfigCors'] = None,
                 dotnet_framework_version: Optional[str] = None,
                 elastic_instance_minimum: Optional[int] = None,
                 ftps_state: Optional[str] = None,
                 health_check_path: Optional[str] = None,
                 http2_enabled: Optional[bool] = None,
                 ip_restrictions: Optional[Sequence['outputs.FunctionAppSlotSiteConfigIpRestriction']] = None,
                 java_version: Optional[str] = None,
                 linux_fx_version: Optional[str] = None,
                 min_tls_version: Optional[str] = None,
                 pre_warmed_instance_count: Optional[int] = None,
                 runtime_scale_monitoring_enabled: Optional[bool] = None,
                 scm_ip_restrictions: Optional[Sequence['outputs.FunctionAppSlotSiteConfigScmIpRestriction']] = None,
                 scm_type: Optional[str] = None,
                 scm_use_main_ip_restriction: Optional[bool] = None,
                 use32_bit_worker_process: Optional[bool] = None,
                 vnet_route_all_enabled: Optional[bool] = None,
                 websockets_enabled: Optional[bool] = None):
        """
        :param bool always_on: Should the Function App be loaded at all times? Defaults to `false`.
        :param int app_scale_limit: The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
        :param str auto_swap_slot_name: The name of the slot to automatically swap to during deployment
        :param 'FunctionAppSlotSiteConfigCorsArgs' cors: A `cors` block as defined below.
        :param str dotnet_framework_version: The version of the .NET framework's CLR used in this function app. Possible values are `v4.0` (including .NET Core 2.1 and 3.1), `v5.0` and `v6.0`. [For more information on which .NET Framework version to use based on the runtime version you're targeting - please see this table](https://docs.microsoft.com/azure/azure-functions/functions-dotnet-class-library#supported-versions). Defaults to `v4.0`.
        :param int elastic_instance_minimum: The number of minimum instances for this function app. Only applicable to apps on the Premium plan.
        :param str ftps_state: State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`.
        :param str health_check_path: Path which will be checked for this function app health.
        :param bool http2_enabled: Specifies whether or not the HTTP2 protocol should be enabled. Defaults to `false`.
        :param Sequence['FunctionAppSlotSiteConfigIpRestrictionArgs'] ip_restrictions: A [List of objects](https://www.terraform.io/docs/configuration/attr-as-blocks.html) representing IP restrictions as defined below.
        :param str java_version: Java version hosted by the function app in Azure. Possible values are `1.8`, `11` & `17` (In-Preview).
        :param str linux_fx_version: Linux App Framework and version for the AppService, e.g. `DOCKER|(golang:latest)`.
        :param str min_tls_version: The minimum supported TLS version for the function app. Possible values are `1.0`, `1.1`, and `1.2`. Defaults to `1.2` for new function apps.
        :param int pre_warmed_instance_count: The number of pre-warmed instances for this function app. Only affects apps on the Premium plan.
        :param bool runtime_scale_monitoring_enabled: Should Runtime Scale Monitoring be enabled?. Only applicable to apps on the Premium plan. Defaults to `false`.
        :param Sequence['FunctionAppSlotSiteConfigScmIpRestrictionArgs'] scm_ip_restrictions: A [List of objects](https://www.terraform.io/docs/configuration/attr-as-blocks.html) representing IP restrictions as defined below.
               
               > **NOTE** User has to explicitly set `scm_ip_restriction` to empty slice (`[]`) to remove it.
        :param str scm_type: The type of Source Control used by this function App. Valid values include: `BitBucketGit`, `BitBucketHg`, `CodePlexGit`, `CodePlexHg`, `Dropbox`, `ExternalGit`, `ExternalHg`, `GitHub`, `LocalGit`, `None` (default), `OneDrive`, `Tfs`, `VSO`, and `VSTSRM`.
               
               > **NOTE:** This setting is incompatible with the `source_control` block which updates this value based on the setting provided.
        :param bool scm_use_main_ip_restriction: IP security restrictions for scm to use main. Defaults to `false`.
               
               > **NOTE** Any `scm_ip_restriction` blocks configured are ignored by the service when `scm_use_main_ip_restriction` is set to `true`. Any scm restrictions will become active if this is subsequently set to `false` or removed.
        :param bool use32_bit_worker_process: Should the Function App run in 32 bit mode, rather than 64 bit mode? Defaults to `true`.
               
               > **Note:** when using an App Service Plan in the `Free` or `Shared` Tiers `use_32_bit_worker_process` must be set to `true`.
        :param bool websockets_enabled: Should WebSockets be enabled?
        """
        if always_on is not None:
            pulumi.set(__self__, "always_on", always_on)
        if app_scale_limit is not None:
            pulumi.set(__self__, "app_scale_limit", app_scale_limit)
        if auto_swap_slot_name is not None:
            pulumi.set(__self__, "auto_swap_slot_name", auto_swap_slot_name)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if dotnet_framework_version is not None:
            pulumi.set(__self__, "dotnet_framework_version", dotnet_framework_version)
        if elastic_instance_minimum is not None:
            pulumi.set(__self__, "elastic_instance_minimum", elastic_instance_minimum)
        if ftps_state is not None:
            pulumi.set(__self__, "ftps_state", ftps_state)
        if health_check_path is not None:
            pulumi.set(__self__, "health_check_path", health_check_path)
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if ip_restrictions is not None:
            pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        if java_version is not None:
            pulumi.set(__self__, "java_version", java_version)
        if linux_fx_version is not None:
            pulumi.set(__self__, "linux_fx_version", linux_fx_version)
        if min_tls_version is not None:
            pulumi.set(__self__, "min_tls_version", min_tls_version)
        if pre_warmed_instance_count is not None:
            pulumi.set(__self__, "pre_warmed_instance_count", pre_warmed_instance_count)
        if runtime_scale_monitoring_enabled is not None:
            pulumi.set(__self__, "runtime_scale_monitoring_enabled", runtime_scale_monitoring_enabled)
        if scm_ip_restrictions is not None:
            pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        if scm_type is not None:
            pulumi.set(__self__, "scm_type", scm_type)
        if scm_use_main_ip_restriction is not None:
            pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        if use32_bit_worker_process is not None:
            pulumi.set(__self__, "use32_bit_worker_process", use32_bit_worker_process)
        if vnet_route_all_enabled is not None:
            pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        if websockets_enabled is not None:
            pulumi.set(__self__, "websockets_enabled", websockets_enabled)

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> Optional[bool]:
        """
        Should the Function App be loaded at all times? Defaults to `false`.
        """
        return pulumi.get(self, "always_on")

    @property
    @pulumi.getter(name="appScaleLimit")
    def app_scale_limit(self) -> Optional[int]:
        """
        The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
        """
        return pulumi.get(self, "app_scale_limit")

    @property
    @pulumi.getter(name="autoSwapSlotName")
    def auto_swap_slot_name(self) -> Optional[str]:
        """
        The name of the slot to automatically swap to during deployment
        """
        return pulumi.get(self, "auto_swap_slot_name")

    @property
    @pulumi.getter
    def cors(self) -> Optional['outputs.FunctionAppSlotSiteConfigCors']:
        """
        A `cors` block as defined below.
        """
        return pulumi.get(self, "cors")

    @property
    @pulumi.getter(name="dotnetFrameworkVersion")
    def dotnet_framework_version(self) -> Optional[str]:
        """
        The version of the .NET framework's CLR used in this function app. Possible values are `v4.0` (including .NET Core 2.1 and 3.1), `v5.0` and `v6.0`. [For more information on which .NET Framework version to use based on the runtime version you're targeting - please see this table](https://docs.microsoft.com/azure/azure-functions/functions-dotnet-class-library#supported-versions). Defaults to `v4.0`.
        """
        return pulumi.get(self, "dotnet_framework_version")

    @property
    @pulumi.getter(name="elasticInstanceMinimum")
    def elastic_instance_minimum(self) -> Optional[int]:
        """
        The number of minimum instances for this function app. Only applicable to apps on the Premium plan.
        """
        return pulumi.get(self, "elastic_instance_minimum")

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> Optional[str]:
        """
        State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`.
        """
        return pulumi.get(self, "ftps_state")

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> Optional[str]:
        """
        Path which will be checked for this function app health.
        """
        return pulumi.get(self, "health_check_path")

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[bool]:
        """
        Specifies whether or not the HTTP2 protocol should be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "http2_enabled")

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Optional[Sequence['outputs.FunctionAppSlotSiteConfigIpRestriction']]:
        """
        A [List of objects](https://www.terraform.io/docs/configuration/attr-as-blocks.html) representing IP restrictions as defined below.
        """
        return pulumi.get(self, "ip_restrictions")

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> Optional[str]:
        """
        Java version hosted by the function app in Azure. Possible values are `1.8`, `11` & `17` (In-Preview).
        """
        return pulumi.get(self, "java_version")

    @property
    @pulumi.getter(name="linuxFxVersion")
    def linux_fx_version(self) -> Optional[str]:
        """
        Linux App Framework and version for the AppService, e.g. `DOCKER|(golang:latest)`.
        """
        return pulumi.get(self, "linux_fx_version")

    @property
    @pulumi.getter(name="minTlsVersion")
    def min_tls_version(self) -> Optional[str]:
        """
        The minimum supported TLS version for the function app. Possible values are `1.0`, `1.1`, and `1.2`. Defaults to `1.2` for new function apps.
        """
        return pulumi.get(self, "min_tls_version")

    @property
    @pulumi.getter(name="preWarmedInstanceCount")
    def pre_warmed_instance_count(self) -> Optional[int]:
        """
        The number of pre-warmed instances for this function app. Only affects apps on the Premium plan.
        """
        return pulumi.get(self, "pre_warmed_instance_count")

    @property
    @pulumi.getter(name="runtimeScaleMonitoringEnabled")
    def runtime_scale_monitoring_enabled(self) -> Optional[bool]:
        """
        Should Runtime Scale Monitoring be enabled?. Only applicable to apps on the Premium plan. Defaults to `false`.
        """
        return pulumi.get(self, "runtime_scale_monitoring_enabled")

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Optional[Sequence['outputs.FunctionAppSlotSiteConfigScmIpRestriction']]:
        """
        A [List of objects](https://www.terraform.io/docs/configuration/attr-as-blocks.html) representing IP restrictions as defined below.

        > **NOTE** User has to explicitly set `scm_ip_restriction` to empty slice (`[]`) to remove it.
        """
        return pulumi.get(self, "scm_ip_restrictions")

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> Optional[str]:
        """
        The type of Source Control used by this function App. Valid values include: `BitBucketGit`, `BitBucketHg`, `CodePlexGit`, `CodePlexHg`, `Dropbox`, `ExternalGit`, `ExternalHg`, `GitHub`, `LocalGit`, `None` (default), `OneDrive`, `Tfs`, `VSO`, and `VSTSRM`.

        > **NOTE:** This setting is incompatible with the `source_control` block which updates this value based on the setting provided.
        """
        return pulumi.get(self, "scm_type")

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> Optional[bool]:
        """
        IP security restrictions for scm to use main. Defaults to `false`.

        > **NOTE** Any `scm_ip_restriction` blocks configured are ignored by the service when `scm_use_main_ip_restriction` is set to `true`. Any scm restrictions will become active if this is subsequently set to `false` or removed.
        """
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @property
    @pulumi.getter(name="use32BitWorkerProcess")
    def use32_bit_worker_process(self) -> Optional[bool]:
        """
        Should the Function App run in 32 bit mode, rather than 64 bit mode? Defaults to `true`.

        > **Note:** when using an App Service Plan in the `Free` or `Shared` Tiers `use_32_bit_worker_process` must be set to `true`.
        """
        return pulumi.get(self, "use32_bit_worker_process")

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "vnet_route_all_enabled")

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> Optional[bool]:
        """
        Should WebSockets be enabled?
        """
        return pulumi.get(self, "websockets_enabled")


@pulumi.output_type
class FunctionAppSlotSiteConfigCors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedOrigins":
            suggest = "allowed_origins"
        elif key == "supportCredentials":
            suggest = "support_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppSlotSiteConfigCors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppSlotSiteConfigCors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppSlotSiteConfigCors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_origins: Sequence[str],
                 support_credentials: Optional[bool] = None):
        """
        :param Sequence[str] allowed_origins: A list of origins which should be able to make cross-origin calls. `*` can be used to allow all calls.
        :param bool support_credentials: Are credentials supported?
        """
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        if support_credentials is not None:
            pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Sequence[str]:
        """
        A list of origins which should be able to make cross-origin calls. `*` can be used to allow all calls.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> Optional[bool]:
        """
        Are credentials supported?
        """
        return pulumi.get(self, "support_credentials")


@pulumi.output_type
class FunctionAppSlotSiteConfigIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppSlotSiteConfigIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppSlotSiteConfigIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppSlotSiteConfigIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.FunctionAppSlotSiteConfigIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: Does this restriction `Allow` or `Deny` access for this IP range. Defaults to `Allow`.
        :param 'FunctionAppSlotSiteConfigIpRestrictionHeadersArgs' headers: The headers for this specific `ip_restriction` as defined below.
        :param str ip_address: The IP Address used for this IP Restriction in CIDR notation.
        :param str name: The name for this IP Restriction.
        :param int priority: The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
               
               > **NOTE:** One of either `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        Does this restriction `Allow` or `Deny` access for this IP range. Defaults to `Allow`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.FunctionAppSlotSiteConfigIpRestrictionHeaders']:
        """
        The headers for this specific `ip_restriction` as defined below.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The IP Address used for this IP Restriction in CIDR notation.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name for this IP Restriction.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One of either `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class FunctionAppSlotSiteConfigIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppSlotSiteConfigIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppSlotSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppSlotSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        :param str x_fd_health_probe: A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        :param Sequence[str] x_forwarded_fors: A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        :param Sequence[str] x_forwarded_hosts: A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class FunctionAppSlotSiteConfigScmIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppSlotSiteConfigScmIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppSlotSiteConfigScmIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppSlotSiteConfigScmIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.FunctionAppSlotSiteConfigScmIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: Allow or Deny access for this IP range. Defaults to `Allow`.
        :param 'FunctionAppSlotSiteConfigScmIpRestrictionHeadersArgs' headers: The headers for this specific `scm_ip_restriction` as defined below.
        :param str ip_address: The IP Address used for this IP Restriction in CIDR notation.
        :param str name: The name for this IP Restriction.
        :param int priority: The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
               
               > **NOTE:** One of either `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        Allow or Deny access for this IP range. Defaults to `Allow`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.FunctionAppSlotSiteConfigScmIpRestrictionHeaders']:
        """
        The headers for this specific `scm_ip_restriction` as defined below.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The IP Address used for this IP Restriction in CIDR notation.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name for this IP Restriction.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One of either `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class FunctionAppSlotSiteConfigScmIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppSlotSiteConfigScmIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppSlotSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppSlotSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        :param str x_fd_health_probe: A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        :param Sequence[str] x_forwarded_fors: A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        :param Sequence[str] x_forwarded_hosts: A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class FunctionAppSlotSiteCredential(dict):
    def __init__(__self__, *,
                 password: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str password: The password associated with the username, which can be used to publish to this App Service.
        :param str username: The username which can be used to publish to this App Service
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password associated with the username, which can be used to publish to this App Service.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username which can be used to publish to this App Service
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class FunctionAppSourceControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "manualIntegration":
            suggest = "manual_integration"
        elif key == "repoUrl":
            suggest = "repo_url"
        elif key == "rollbackEnabled":
            suggest = "rollback_enabled"
        elif key == "useMercurial":
            suggest = "use_mercurial"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppSourceControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppSourceControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppSourceControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch: Optional[str] = None,
                 manual_integration: Optional[bool] = None,
                 repo_url: Optional[str] = None,
                 rollback_enabled: Optional[bool] = None,
                 use_mercurial: Optional[bool] = None):
        """
        :param str branch: The branch of the remote repository to use. Defaults to 'master'.
        :param bool manual_integration: Limits to manual integration. Defaults to `false` if not specified.
        :param str repo_url: The URL of the source code repository.
        :param bool rollback_enabled: Enable roll-back for the repository. Defaults to `false` if not specified.
        :param bool use_mercurial: Use Mercurial if `true`, otherwise uses Git.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if manual_integration is not None:
            pulumi.set(__self__, "manual_integration", manual_integration)
        if repo_url is not None:
            pulumi.set(__self__, "repo_url", repo_url)
        if rollback_enabled is not None:
            pulumi.set(__self__, "rollback_enabled", rollback_enabled)
        if use_mercurial is not None:
            pulumi.set(__self__, "use_mercurial", use_mercurial)

    @property
    @pulumi.getter
    def branch(self) -> Optional[str]:
        """
        The branch of the remote repository to use. Defaults to 'master'.
        """
        return pulumi.get(self, "branch")

    @property
    @pulumi.getter(name="manualIntegration")
    def manual_integration(self) -> Optional[bool]:
        """
        Limits to manual integration. Defaults to `false` if not specified.
        """
        return pulumi.get(self, "manual_integration")

    @property
    @pulumi.getter(name="repoUrl")
    def repo_url(self) -> Optional[str]:
        """
        The URL of the source code repository.
        """
        return pulumi.get(self, "repo_url")

    @property
    @pulumi.getter(name="rollbackEnabled")
    def rollback_enabled(self) -> Optional[bool]:
        """
        Enable roll-back for the repository. Defaults to `false` if not specified.
        """
        return pulumi.get(self, "rollback_enabled")

    @property
    @pulumi.getter(name="useMercurial")
    def use_mercurial(self) -> Optional[bool]:
        """
        Use Mercurial if `true`, otherwise uses Git.
        """
        return pulumi.get(self, "use_mercurial")


@pulumi.output_type
class LinuxFunctionAppAuthSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeDirectory":
            suggest = "active_directory"
        elif key == "additionalLoginParameters":
            suggest = "additional_login_parameters"
        elif key == "allowedExternalRedirectUrls":
            suggest = "allowed_external_redirect_urls"
        elif key == "defaultProvider":
            suggest = "default_provider"
        elif key == "runtimeVersion":
            suggest = "runtime_version"
        elif key == "tokenRefreshExtensionHours":
            suggest = "token_refresh_extension_hours"
        elif key == "tokenStoreEnabled":
            suggest = "token_store_enabled"
        elif key == "unauthenticatedClientAction":
            suggest = "unauthenticated_client_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppAuthSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppAuthSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppAuthSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 active_directory: Optional['outputs.LinuxFunctionAppAuthSettingsActiveDirectory'] = None,
                 additional_login_parameters: Optional[Mapping[str, str]] = None,
                 allowed_external_redirect_urls: Optional[Sequence[str]] = None,
                 default_provider: Optional[str] = None,
                 facebook: Optional['outputs.LinuxFunctionAppAuthSettingsFacebook'] = None,
                 github: Optional['outputs.LinuxFunctionAppAuthSettingsGithub'] = None,
                 google: Optional['outputs.LinuxFunctionAppAuthSettingsGoogle'] = None,
                 issuer: Optional[str] = None,
                 microsoft: Optional['outputs.LinuxFunctionAppAuthSettingsMicrosoft'] = None,
                 runtime_version: Optional[str] = None,
                 token_refresh_extension_hours: Optional[float] = None,
                 token_store_enabled: Optional[bool] = None,
                 twitter: Optional['outputs.LinuxFunctionAppAuthSettingsTwitter'] = None,
                 unauthenticated_client_action: Optional[str] = None):
        """
        :param bool enabled: Should the Authentication / Authorization feature be enabled for the Linux Web App?
        :param 'LinuxFunctionAppAuthSettingsActiveDirectoryArgs' active_directory: An `active_directory` block as defined above.
        :param Mapping[str, str] additional_login_parameters: Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        :param Sequence[str] allowed_external_redirect_urls: Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Linux Web App.
        :param str default_provider: The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.
               
               > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        :param 'LinuxFunctionAppAuthSettingsFacebookArgs' facebook: A `facebook` block as defined below.
        :param 'LinuxFunctionAppAuthSettingsGithubArgs' github: A `github` block as defined below.
        :param 'LinuxFunctionAppAuthSettingsGoogleArgs' google: A `google` block as defined below.
        :param str issuer: The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Linux Web App.
               
               > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        :param 'LinuxFunctionAppAuthSettingsMicrosoftArgs' microsoft: A `microsoft` block as defined below.
        :param str runtime_version: The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        :param float token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        :param bool token_store_enabled: Should the Linux Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        :param 'LinuxFunctionAppAuthSettingsTwitterArgs' twitter: A `twitter` block as defined below.
        :param str unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if active_directory is not None:
            pulumi.set(__self__, "active_directory", active_directory)
        if additional_login_parameters is not None:
            pulumi.set(__self__, "additional_login_parameters", additional_login_parameters)
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if facebook is not None:
            pulumi.set(__self__, "facebook", facebook)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if google is not None:
            pulumi.set(__self__, "google", google)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if microsoft is not None:
            pulumi.set(__self__, "microsoft", microsoft)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if token_refresh_extension_hours is not None:
            pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if twitter is not None:
            pulumi.set(__self__, "twitter", twitter)
        if unauthenticated_client_action is not None:
            pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Should the Authentication / Authorization feature be enabled for the Linux Web App?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="activeDirectory")
    def active_directory(self) -> Optional['outputs.LinuxFunctionAppAuthSettingsActiveDirectory']:
        """
        An `active_directory` block as defined above.
        """
        return pulumi.get(self, "active_directory")

    @property
    @pulumi.getter(name="additionalLoginParameters")
    def additional_login_parameters(self) -> Optional[Mapping[str, str]]:
        """
        Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        """
        return pulumi.get(self, "additional_login_parameters")

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Linux Web App.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[str]:
        """
        The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.

        > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        """
        return pulumi.get(self, "default_provider")

    @property
    @pulumi.getter
    def facebook(self) -> Optional['outputs.LinuxFunctionAppAuthSettingsFacebook']:
        """
        A `facebook` block as defined below.
        """
        return pulumi.get(self, "facebook")

    @property
    @pulumi.getter
    def github(self) -> Optional['outputs.LinuxFunctionAppAuthSettingsGithub']:
        """
        A `github` block as defined below.
        """
        return pulumi.get(self, "github")

    @property
    @pulumi.getter
    def google(self) -> Optional['outputs.LinuxFunctionAppAuthSettingsGoogle']:
        """
        A `google` block as defined below.
        """
        return pulumi.get(self, "google")

    @property
    @pulumi.getter
    def issuer(self) -> Optional[str]:
        """
        The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Linux Web App.

        > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def microsoft(self) -> Optional['outputs.LinuxFunctionAppAuthSettingsMicrosoft']:
        """
        A `microsoft` block as defined below.
        """
        return pulumi.get(self, "microsoft")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[str]:
        """
        The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> Optional[float]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        return pulumi.get(self, "token_refresh_extension_hours")

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[bool]:
        """
        Should the Linux Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        """
        return pulumi.get(self, "token_store_enabled")

    @property
    @pulumi.getter
    def twitter(self) -> Optional['outputs.LinuxFunctionAppAuthSettingsTwitter']:
        """
        A `twitter` block as defined below.
        """
        return pulumi.get(self, "twitter")

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> Optional[str]:
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        return pulumi.get(self, "unauthenticated_client_action")


@pulumi.output_type
class LinuxFunctionAppAuthSettingsActiveDirectory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppAuthSettingsActiveDirectory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppAuthSettingsActiveDirectory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppAuthSettingsActiveDirectory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param Sequence[str] allowed_audiences: Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
               
               > **Note:** The `client_id` value is always considered an allowed audience.
        :param str client_secret: The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        pulumi.set(__self__, "client_id", client_id)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **Note:** The `client_id` value is always considered an allowed audience.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")


@pulumi.output_type
class LinuxFunctionAppAuthSettingsFacebook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "appSecret":
            suggest = "app_secret"
        elif key == "appSecretSettingName":
            suggest = "app_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppAuthSettingsFacebook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppAuthSettingsFacebook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppAuthSettingsFacebook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: str,
                 app_secret: Optional[str] = None,
                 app_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str app_id: The App ID of the Facebook app used for login.
        :param str app_secret: The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        :param str app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        if app_secret is not None:
            pulumi.set(__self__, "app_secret", app_secret)
        if app_secret_setting_name is not None:
            pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appSecret")
    def app_secret(self) -> Optional[str]:
        """
        The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        """
        return pulumi.get(self, "app_secret")

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class LinuxFunctionAppAuthSettingsGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppAuthSettingsGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppAuthSettingsGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppAuthSettingsGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the GitHub app used for login.
        :param str client_secret: The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the GitHub app used for login.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class LinuxFunctionAppAuthSettingsGoogle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppAuthSettingsGoogle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppAuthSettingsGoogle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppAuthSettingsGoogle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OpenID Connect Client ID for the Google web application.
        :param str client_secret: The client secret associated with the Google web application. Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OpenID Connect Client ID for the Google web application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The client secret associated with the Google web application. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class LinuxFunctionAppAuthSettingsMicrosoft(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppAuthSettingsMicrosoft. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppAuthSettingsMicrosoft.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppAuthSettingsMicrosoft.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret: The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, `wl.basic` is used as the default scope.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, `wl.basic` is used as the default scope.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class LinuxFunctionAppAuthSettingsTwitter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerKey":
            suggest = "consumer_key"
        elif key == "consumerSecret":
            suggest = "consumer_secret"
        elif key == "consumerSecretSettingName":
            suggest = "consumer_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppAuthSettingsTwitter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppAuthSettingsTwitter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppAuthSettingsTwitter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_key: str,
                 consumer_secret: Optional[str] = None,
                 consumer_secret_setting_name: Optional[str] = None):
        """
        :param str consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param str consumer_secret: The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        :param str consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        if consumer_secret is not None:
            pulumi.set(__self__, "consumer_secret", consumer_secret)
        if consumer_secret_setting_name is not None:
            pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> str:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> Optional[str]:
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        """
        return pulumi.get(self, "consumer_secret")

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        return pulumi.get(self, "consumer_secret_setting_name")


@pulumi.output_type
class LinuxFunctionAppAuthSettingsV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeDirectoryV2":
            suggest = "active_directory_v2"
        elif key == "appleV2":
            suggest = "apple_v2"
        elif key == "authEnabled":
            suggest = "auth_enabled"
        elif key == "azureStaticWebAppV2":
            suggest = "azure_static_web_app_v2"
        elif key == "configFilePath":
            suggest = "config_file_path"
        elif key == "customOidcV2s":
            suggest = "custom_oidc_v2s"
        elif key == "defaultProvider":
            suggest = "default_provider"
        elif key == "excludedPaths":
            suggest = "excluded_paths"
        elif key == "facebookV2":
            suggest = "facebook_v2"
        elif key == "forwardProxyConvention":
            suggest = "forward_proxy_convention"
        elif key == "forwardProxyCustomHostHeaderName":
            suggest = "forward_proxy_custom_host_header_name"
        elif key == "forwardProxyCustomSchemeHeaderName":
            suggest = "forward_proxy_custom_scheme_header_name"
        elif key == "githubV2":
            suggest = "github_v2"
        elif key == "googleV2":
            suggest = "google_v2"
        elif key == "httpRouteApiPrefix":
            suggest = "http_route_api_prefix"
        elif key == "microsoftV2":
            suggest = "microsoft_v2"
        elif key == "requireAuthentication":
            suggest = "require_authentication"
        elif key == "requireHttps":
            suggest = "require_https"
        elif key == "runtimeVersion":
            suggest = "runtime_version"
        elif key == "twitterV2":
            suggest = "twitter_v2"
        elif key == "unauthenticatedAction":
            suggest = "unauthenticated_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppAuthSettingsV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppAuthSettingsV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppAuthSettingsV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 login: 'outputs.LinuxFunctionAppAuthSettingsV2Login',
                 active_directory_v2: Optional['outputs.LinuxFunctionAppAuthSettingsV2ActiveDirectoryV2'] = None,
                 apple_v2: Optional['outputs.LinuxFunctionAppAuthSettingsV2AppleV2'] = None,
                 auth_enabled: Optional[bool] = None,
                 azure_static_web_app_v2: Optional['outputs.LinuxFunctionAppAuthSettingsV2AzureStaticWebAppV2'] = None,
                 config_file_path: Optional[str] = None,
                 custom_oidc_v2s: Optional[Sequence['outputs.LinuxFunctionAppAuthSettingsV2CustomOidcV2']] = None,
                 default_provider: Optional[str] = None,
                 excluded_paths: Optional[Sequence[str]] = None,
                 facebook_v2: Optional['outputs.LinuxFunctionAppAuthSettingsV2FacebookV2'] = None,
                 forward_proxy_convention: Optional[str] = None,
                 forward_proxy_custom_host_header_name: Optional[str] = None,
                 forward_proxy_custom_scheme_header_name: Optional[str] = None,
                 github_v2: Optional['outputs.LinuxFunctionAppAuthSettingsV2GithubV2'] = None,
                 google_v2: Optional['outputs.LinuxFunctionAppAuthSettingsV2GoogleV2'] = None,
                 http_route_api_prefix: Optional[str] = None,
                 microsoft_v2: Optional['outputs.LinuxFunctionAppAuthSettingsV2MicrosoftV2'] = None,
                 require_authentication: Optional[bool] = None,
                 require_https: Optional[bool] = None,
                 runtime_version: Optional[str] = None,
                 twitter_v2: Optional['outputs.LinuxFunctionAppAuthSettingsV2TwitterV2'] = None,
                 unauthenticated_action: Optional[str] = None):
        """
        :param 'LinuxFunctionAppAuthSettingsV2LoginArgs' login: A `login` block as defined below.
        :param 'LinuxFunctionAppAuthSettingsV2ActiveDirectoryV2Args' active_directory_v2: An `active_directory_v2` block as defined below.
        :param 'LinuxFunctionAppAuthSettingsV2AppleV2Args' apple_v2: An `apple_v2` block as defined below.
        :param bool auth_enabled: Should the AuthV2 Settings be enabled. Defaults to `false`.
        :param 'LinuxFunctionAppAuthSettingsV2AzureStaticWebAppV2Args' azure_static_web_app_v2: An `azure_static_web_app_v2` block as defined below.
        :param str config_file_path: The path to the App Auth settings.
               
               * > **Note:** Relative Paths are evaluated from the Site Root directory.
        :param Sequence['LinuxFunctionAppAuthSettingsV2CustomOidcV2Args'] custom_oidc_v2s: Zero or more `custom_oidc_v2` blocks as defined below.
        :param str default_provider: The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.
               
               > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        :param Sequence[str] excluded_paths: The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.
               
               > **NOTE:** This list should be used instead of setting `WEBSITE_WARMUP_PATH` in `app_settings` as it takes priority.
        :param 'LinuxFunctionAppAuthSettingsV2FacebookV2Args' facebook_v2: A `facebook_v2` block as defined below.
        :param str forward_proxy_convention: The convention used to determine the url of the request made. Possible values include `NoProxy`, `Standard`, `Custom`. Defaults to `NoProxy`.
        :param str forward_proxy_custom_host_header_name: The name of the custom header containing the host of the request.
        :param str forward_proxy_custom_scheme_header_name: The name of the custom header containing the scheme of the request.
        :param 'LinuxFunctionAppAuthSettingsV2GithubV2Args' github_v2: A `github_v2` block as defined below.
        :param 'LinuxFunctionAppAuthSettingsV2GoogleV2Args' google_v2: A `google_v2` block as defined below.
        :param str http_route_api_prefix: The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
        :param 'LinuxFunctionAppAuthSettingsV2MicrosoftV2Args' microsoft_v2: A `microsoft_v2` block as defined below.
        :param bool require_authentication: Should the authentication flow be used for all requests.
        :param bool require_https: Should HTTPS be required on connections? Defaults to `true`.
        :param str runtime_version: The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        :param 'LinuxFunctionAppAuthSettingsV2TwitterV2Args' twitter_v2: A `twitter_v2` block as defined below.
        :param str unauthenticated_action: The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
        """
        pulumi.set(__self__, "login", login)
        if active_directory_v2 is not None:
            pulumi.set(__self__, "active_directory_v2", active_directory_v2)
        if apple_v2 is not None:
            pulumi.set(__self__, "apple_v2", apple_v2)
        if auth_enabled is not None:
            pulumi.set(__self__, "auth_enabled", auth_enabled)
        if azure_static_web_app_v2 is not None:
            pulumi.set(__self__, "azure_static_web_app_v2", azure_static_web_app_v2)
        if config_file_path is not None:
            pulumi.set(__self__, "config_file_path", config_file_path)
        if custom_oidc_v2s is not None:
            pulumi.set(__self__, "custom_oidc_v2s", custom_oidc_v2s)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if excluded_paths is not None:
            pulumi.set(__self__, "excluded_paths", excluded_paths)
        if facebook_v2 is not None:
            pulumi.set(__self__, "facebook_v2", facebook_v2)
        if forward_proxy_convention is not None:
            pulumi.set(__self__, "forward_proxy_convention", forward_proxy_convention)
        if forward_proxy_custom_host_header_name is not None:
            pulumi.set(__self__, "forward_proxy_custom_host_header_name", forward_proxy_custom_host_header_name)
        if forward_proxy_custom_scheme_header_name is not None:
            pulumi.set(__self__, "forward_proxy_custom_scheme_header_name", forward_proxy_custom_scheme_header_name)
        if github_v2 is not None:
            pulumi.set(__self__, "github_v2", github_v2)
        if google_v2 is not None:
            pulumi.set(__self__, "google_v2", google_v2)
        if http_route_api_prefix is not None:
            pulumi.set(__self__, "http_route_api_prefix", http_route_api_prefix)
        if microsoft_v2 is not None:
            pulumi.set(__self__, "microsoft_v2", microsoft_v2)
        if require_authentication is not None:
            pulumi.set(__self__, "require_authentication", require_authentication)
        if require_https is not None:
            pulumi.set(__self__, "require_https", require_https)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if twitter_v2 is not None:
            pulumi.set(__self__, "twitter_v2", twitter_v2)
        if unauthenticated_action is not None:
            pulumi.set(__self__, "unauthenticated_action", unauthenticated_action)

    @property
    @pulumi.getter
    def login(self) -> 'outputs.LinuxFunctionAppAuthSettingsV2Login':
        """
        A `login` block as defined below.
        """
        return pulumi.get(self, "login")

    @property
    @pulumi.getter(name="activeDirectoryV2")
    def active_directory_v2(self) -> Optional['outputs.LinuxFunctionAppAuthSettingsV2ActiveDirectoryV2']:
        """
        An `active_directory_v2` block as defined below.
        """
        return pulumi.get(self, "active_directory_v2")

    @property
    @pulumi.getter(name="appleV2")
    def apple_v2(self) -> Optional['outputs.LinuxFunctionAppAuthSettingsV2AppleV2']:
        """
        An `apple_v2` block as defined below.
        """
        return pulumi.get(self, "apple_v2")

    @property
    @pulumi.getter(name="authEnabled")
    def auth_enabled(self) -> Optional[bool]:
        """
        Should the AuthV2 Settings be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "auth_enabled")

    @property
    @pulumi.getter(name="azureStaticWebAppV2")
    def azure_static_web_app_v2(self) -> Optional['outputs.LinuxFunctionAppAuthSettingsV2AzureStaticWebAppV2']:
        """
        An `azure_static_web_app_v2` block as defined below.
        """
        return pulumi.get(self, "azure_static_web_app_v2")

    @property
    @pulumi.getter(name="configFilePath")
    def config_file_path(self) -> Optional[str]:
        """
        The path to the App Auth settings.

        * > **Note:** Relative Paths are evaluated from the Site Root directory.
        """
        return pulumi.get(self, "config_file_path")

    @property
    @pulumi.getter(name="customOidcV2s")
    def custom_oidc_v2s(self) -> Optional[Sequence['outputs.LinuxFunctionAppAuthSettingsV2CustomOidcV2']]:
        """
        Zero or more `custom_oidc_v2` blocks as defined below.
        """
        return pulumi.get(self, "custom_oidc_v2s")

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[str]:
        """
        The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.

        > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        """
        return pulumi.get(self, "default_provider")

    @property
    @pulumi.getter(name="excludedPaths")
    def excluded_paths(self) -> Optional[Sequence[str]]:
        """
        The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.

        > **NOTE:** This list should be used instead of setting `WEBSITE_WARMUP_PATH` in `app_settings` as it takes priority.
        """
        return pulumi.get(self, "excluded_paths")

    @property
    @pulumi.getter(name="facebookV2")
    def facebook_v2(self) -> Optional['outputs.LinuxFunctionAppAuthSettingsV2FacebookV2']:
        """
        A `facebook_v2` block as defined below.
        """
        return pulumi.get(self, "facebook_v2")

    @property
    @pulumi.getter(name="forwardProxyConvention")
    def forward_proxy_convention(self) -> Optional[str]:
        """
        The convention used to determine the url of the request made. Possible values include `NoProxy`, `Standard`, `Custom`. Defaults to `NoProxy`.
        """
        return pulumi.get(self, "forward_proxy_convention")

    @property
    @pulumi.getter(name="forwardProxyCustomHostHeaderName")
    def forward_proxy_custom_host_header_name(self) -> Optional[str]:
        """
        The name of the custom header containing the host of the request.
        """
        return pulumi.get(self, "forward_proxy_custom_host_header_name")

    @property
    @pulumi.getter(name="forwardProxyCustomSchemeHeaderName")
    def forward_proxy_custom_scheme_header_name(self) -> Optional[str]:
        """
        The name of the custom header containing the scheme of the request.
        """
        return pulumi.get(self, "forward_proxy_custom_scheme_header_name")

    @property
    @pulumi.getter(name="githubV2")
    def github_v2(self) -> Optional['outputs.LinuxFunctionAppAuthSettingsV2GithubV2']:
        """
        A `github_v2` block as defined below.
        """
        return pulumi.get(self, "github_v2")

    @property
    @pulumi.getter(name="googleV2")
    def google_v2(self) -> Optional['outputs.LinuxFunctionAppAuthSettingsV2GoogleV2']:
        """
        A `google_v2` block as defined below.
        """
        return pulumi.get(self, "google_v2")

    @property
    @pulumi.getter(name="httpRouteApiPrefix")
    def http_route_api_prefix(self) -> Optional[str]:
        """
        The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
        """
        return pulumi.get(self, "http_route_api_prefix")

    @property
    @pulumi.getter(name="microsoftV2")
    def microsoft_v2(self) -> Optional['outputs.LinuxFunctionAppAuthSettingsV2MicrosoftV2']:
        """
        A `microsoft_v2` block as defined below.
        """
        return pulumi.get(self, "microsoft_v2")

    @property
    @pulumi.getter(name="requireAuthentication")
    def require_authentication(self) -> Optional[bool]:
        """
        Should the authentication flow be used for all requests.
        """
        return pulumi.get(self, "require_authentication")

    @property
    @pulumi.getter(name="requireHttps")
    def require_https(self) -> Optional[bool]:
        """
        Should HTTPS be required on connections? Defaults to `true`.
        """
        return pulumi.get(self, "require_https")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[str]:
        """
        The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter(name="twitterV2")
    def twitter_v2(self) -> Optional['outputs.LinuxFunctionAppAuthSettingsV2TwitterV2']:
        """
        A `twitter_v2` block as defined below.
        """
        return pulumi.get(self, "twitter_v2")

    @property
    @pulumi.getter(name="unauthenticatedAction")
    def unauthenticated_action(self) -> Optional[str]:
        """
        The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
        """
        return pulumi.get(self, "unauthenticated_action")


@pulumi.output_type
class LinuxFunctionAppAuthSettingsV2ActiveDirectoryV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "tenantAuthEndpoint":
            suggest = "tenant_auth_endpoint"
        elif key == "allowedApplications":
            suggest = "allowed_applications"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "allowedGroups":
            suggest = "allowed_groups"
        elif key == "allowedIdentities":
            suggest = "allowed_identities"
        elif key == "clientSecretCertificateThumbprint":
            suggest = "client_secret_certificate_thumbprint"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "jwtAllowedClientApplications":
            suggest = "jwt_allowed_client_applications"
        elif key == "jwtAllowedGroups":
            suggest = "jwt_allowed_groups"
        elif key == "loginParameters":
            suggest = "login_parameters"
        elif key == "wwwAuthenticationDisabled":
            suggest = "www_authentication_disabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppAuthSettingsV2ActiveDirectoryV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppAuthSettingsV2ActiveDirectoryV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppAuthSettingsV2ActiveDirectoryV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 tenant_auth_endpoint: str,
                 allowed_applications: Optional[Sequence[str]] = None,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 allowed_groups: Optional[Sequence[str]] = None,
                 allowed_identities: Optional[Sequence[str]] = None,
                 client_secret_certificate_thumbprint: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 jwt_allowed_client_applications: Optional[Sequence[str]] = None,
                 jwt_allowed_groups: Optional[Sequence[str]] = None,
                 login_parameters: Optional[Mapping[str, str]] = None,
                 www_authentication_disabled: Optional[bool] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str tenant_auth_endpoint: The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`
        :param Sequence[str] allowed_applications: The list of allowed Applications for the Default Authorisation Policy.
        :param Sequence[str] allowed_audiences: Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
               
               > **Note:** The `client_id` value is always considered an allowed audience.
        :param Sequence[str] allowed_groups: The list of allowed Group Names for the Default Authorisation Policy.
        :param Sequence[str] allowed_identities: The list of allowed Identities for the Default Authorisation Policy.
        :param str client_secret_certificate_thumbprint: The thumbprint of the certificate used for signing purposes.
               
               > **NOTE:** One of `client_secret_setting_name` or `client_secret_certificate_thumbprint` must be specified.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param Sequence[str] jwt_allowed_client_applications: A list of Allowed Client Applications in the JWT Claim.
        :param Sequence[str] jwt_allowed_groups: A list of Allowed Groups in the JWT Claim.
        :param Mapping[str, str] login_parameters: A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
        :param bool www_authentication_disabled: Should the www-authenticate provider should be omitted from the request? Defaults to `false`
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "tenant_auth_endpoint", tenant_auth_endpoint)
        if allowed_applications is not None:
            pulumi.set(__self__, "allowed_applications", allowed_applications)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if allowed_groups is not None:
            pulumi.set(__self__, "allowed_groups", allowed_groups)
        if allowed_identities is not None:
            pulumi.set(__self__, "allowed_identities", allowed_identities)
        if client_secret_certificate_thumbprint is not None:
            pulumi.set(__self__, "client_secret_certificate_thumbprint", client_secret_certificate_thumbprint)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if jwt_allowed_client_applications is not None:
            pulumi.set(__self__, "jwt_allowed_client_applications", jwt_allowed_client_applications)
        if jwt_allowed_groups is not None:
            pulumi.set(__self__, "jwt_allowed_groups", jwt_allowed_groups)
        if login_parameters is not None:
            pulumi.set(__self__, "login_parameters", login_parameters)
        if www_authentication_disabled is not None:
            pulumi.set(__self__, "www_authentication_disabled", www_authentication_disabled)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="tenantAuthEndpoint")
    def tenant_auth_endpoint(self) -> str:
        """
        The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`
        """
        return pulumi.get(self, "tenant_auth_endpoint")

    @property
    @pulumi.getter(name="allowedApplications")
    def allowed_applications(self) -> Optional[Sequence[str]]:
        """
        The list of allowed Applications for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_applications")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **Note:** The `client_id` value is always considered an allowed audience.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="allowedGroups")
    def allowed_groups(self) -> Optional[Sequence[str]]:
        """
        The list of allowed Group Names for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_groups")

    @property
    @pulumi.getter(name="allowedIdentities")
    def allowed_identities(self) -> Optional[Sequence[str]]:
        """
        The list of allowed Identities for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_identities")

    @property
    @pulumi.getter(name="clientSecretCertificateThumbprint")
    def client_secret_certificate_thumbprint(self) -> Optional[str]:
        """
        The thumbprint of the certificate used for signing purposes.

        > **NOTE:** One of `client_secret_setting_name` or `client_secret_certificate_thumbprint` must be specified.
        """
        return pulumi.get(self, "client_secret_certificate_thumbprint")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="jwtAllowedClientApplications")
    def jwt_allowed_client_applications(self) -> Optional[Sequence[str]]:
        """
        A list of Allowed Client Applications in the JWT Claim.
        """
        return pulumi.get(self, "jwt_allowed_client_applications")

    @property
    @pulumi.getter(name="jwtAllowedGroups")
    def jwt_allowed_groups(self) -> Optional[Sequence[str]]:
        """
        A list of Allowed Groups in the JWT Claim.
        """
        return pulumi.get(self, "jwt_allowed_groups")

    @property
    @pulumi.getter(name="loginParameters")
    def login_parameters(self) -> Optional[Mapping[str, str]]:
        """
        A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
        """
        return pulumi.get(self, "login_parameters")

    @property
    @pulumi.getter(name="wwwAuthenticationDisabled")
    def www_authentication_disabled(self) -> Optional[bool]:
        """
        Should the www-authenticate provider should be omitted from the request? Defaults to `false`
        """
        return pulumi.get(self, "www_authentication_disabled")


@pulumi.output_type
class LinuxFunctionAppAuthSettingsV2AppleV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "loginScopes":
            suggest = "login_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppAuthSettingsV2AppleV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppAuthSettingsV2AppleV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppAuthSettingsV2AppleV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret_setting_name: str,
                 login_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param Sequence[str] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[Sequence[str]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class LinuxFunctionAppAuthSettingsV2AzureStaticWebAppV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppAuthSettingsV2AzureStaticWebAppV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppAuthSettingsV2AzureStaticWebAppV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppAuthSettingsV2AzureStaticWebAppV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        """
        pulumi.set(__self__, "client_id", client_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")


@pulumi.output_type
class LinuxFunctionAppAuthSettingsV2CustomOidcV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "openidConfigurationEndpoint":
            suggest = "openid_configuration_endpoint"
        elif key == "authorisationEndpoint":
            suggest = "authorisation_endpoint"
        elif key == "certificationUri":
            suggest = "certification_uri"
        elif key == "clientCredentialMethod":
            suggest = "client_credential_method"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "issuerEndpoint":
            suggest = "issuer_endpoint"
        elif key == "nameClaimType":
            suggest = "name_claim_type"
        elif key == "tokenEndpoint":
            suggest = "token_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppAuthSettingsV2CustomOidcV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppAuthSettingsV2CustomOidcV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppAuthSettingsV2CustomOidcV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 name: str,
                 openid_configuration_endpoint: str,
                 authorisation_endpoint: Optional[str] = None,
                 certification_uri: Optional[str] = None,
                 client_credential_method: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 issuer_endpoint: Optional[str] = None,
                 name_claim_type: Optional[str] = None,
                 scopes: Optional[Sequence[str]] = None,
                 token_endpoint: Optional[str] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str name: The name which should be used for this Linux Function App. Changing this forces a new Linux Function App to be created. Limit the function name to 32 characters to avoid naming collisions. For more information about [Function App naming rule](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/resource-name-rules#microsoftweb) and [Host ID Collisions](https://github.com/Azure/azure-functions-host/wiki/Host-IDs#host-id-collisions)
        :param str openid_configuration_endpoint: The app setting name that contains the `client_secret` value used for the Custom OIDC Login.
        :param str authorisation_endpoint: The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        :param str certification_uri: The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        :param str client_credential_method: The Client Credential Method used.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param str issuer_endpoint: The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        :param str name_claim_type: The name of the claim that contains the users name.
        :param Sequence[str] scopes: The list of the scopes that should be requested while authenticating.
        :param str token_endpoint: The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "openid_configuration_endpoint", openid_configuration_endpoint)
        if authorisation_endpoint is not None:
            pulumi.set(__self__, "authorisation_endpoint", authorisation_endpoint)
        if certification_uri is not None:
            pulumi.set(__self__, "certification_uri", certification_uri)
        if client_credential_method is not None:
            pulumi.set(__self__, "client_credential_method", client_credential_method)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if issuer_endpoint is not None:
            pulumi.set(__self__, "issuer_endpoint", issuer_endpoint)
        if name_claim_type is not None:
            pulumi.set(__self__, "name_claim_type", name_claim_type)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Linux Function App. Changing this forces a new Linux Function App to be created. Limit the function name to 32 characters to avoid naming collisions. For more information about [Function App naming rule](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/resource-name-rules#microsoftweb) and [Host ID Collisions](https://github.com/Azure/azure-functions-host/wiki/Host-IDs#host-id-collisions)
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="openidConfigurationEndpoint")
    def openid_configuration_endpoint(self) -> str:
        """
        The app setting name that contains the `client_secret` value used for the Custom OIDC Login.
        """
        return pulumi.get(self, "openid_configuration_endpoint")

    @property
    @pulumi.getter(name="authorisationEndpoint")
    def authorisation_endpoint(self) -> Optional[str]:
        """
        The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "authorisation_endpoint")

    @property
    @pulumi.getter(name="certificationUri")
    def certification_uri(self) -> Optional[str]:
        """
        The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "certification_uri")

    @property
    @pulumi.getter(name="clientCredentialMethod")
    def client_credential_method(self) -> Optional[str]:
        """
        The Client Credential Method used.
        """
        return pulumi.get(self, "client_credential_method")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="issuerEndpoint")
    def issuer_endpoint(self) -> Optional[str]:
        """
        The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "issuer_endpoint")

    @property
    @pulumi.getter(name="nameClaimType")
    def name_claim_type(self) -> Optional[str]:
        """
        The name of the claim that contains the users name.
        """
        return pulumi.get(self, "name_claim_type")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[str]]:
        """
        The list of the scopes that should be requested while authenticating.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[str]:
        """
        The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "token_endpoint")


@pulumi.output_type
class LinuxFunctionAppAuthSettingsV2FacebookV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "appSecretSettingName":
            suggest = "app_secret_setting_name"
        elif key == "graphApiVersion":
            suggest = "graph_api_version"
        elif key == "loginScopes":
            suggest = "login_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppAuthSettingsV2FacebookV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppAuthSettingsV2FacebookV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppAuthSettingsV2FacebookV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: str,
                 app_secret_setting_name: str,
                 graph_api_version: Optional[str] = None,
                 login_scopes: Optional[Sequence[str]] = None):
        """
        :param str app_id: The App ID of the Facebook app used for login.
        :param str app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook Login.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param str graph_api_version: The version of the Facebook API to be used while logging in.
        :param Sequence[str] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        if graph_api_version is not None:
            pulumi.set(__self__, "graph_api_version", graph_api_version)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> str:
        """
        The app setting name that contains the `app_secret` value used for Facebook Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @property
    @pulumi.getter(name="graphApiVersion")
    def graph_api_version(self) -> Optional[str]:
        """
        The version of the Facebook API to be used while logging in.
        """
        return pulumi.get(self, "graph_api_version")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[Sequence[str]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class LinuxFunctionAppAuthSettingsV2GithubV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "loginScopes":
            suggest = "login_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppAuthSettingsV2GithubV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppAuthSettingsV2GithubV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppAuthSettingsV2GithubV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret_setting_name: str,
                 login_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param Sequence[str] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[Sequence[str]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class LinuxFunctionAppAuthSettingsV2GoogleV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "loginScopes":
            suggest = "login_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppAuthSettingsV2GoogleV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppAuthSettingsV2GoogleV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppAuthSettingsV2GoogleV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret_setting_name: str,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 login_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param Sequence[str] allowed_audiences: Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
               
               > **Note:** The `client_id` value is always considered an allowed audience.
        :param Sequence[str] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **Note:** The `client_id` value is always considered an allowed audience.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[Sequence[str]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class LinuxFunctionAppAuthSettingsV2Login(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedExternalRedirectUrls":
            suggest = "allowed_external_redirect_urls"
        elif key == "cookieExpirationConvention":
            suggest = "cookie_expiration_convention"
        elif key == "cookieExpirationTime":
            suggest = "cookie_expiration_time"
        elif key == "logoutEndpoint":
            suggest = "logout_endpoint"
        elif key == "nonceExpirationTime":
            suggest = "nonce_expiration_time"
        elif key == "preserveUrlFragmentsForLogins":
            suggest = "preserve_url_fragments_for_logins"
        elif key == "tokenRefreshExtensionTime":
            suggest = "token_refresh_extension_time"
        elif key == "tokenStoreEnabled":
            suggest = "token_store_enabled"
        elif key == "tokenStorePath":
            suggest = "token_store_path"
        elif key == "tokenStoreSasSettingName":
            suggest = "token_store_sas_setting_name"
        elif key == "validateNonce":
            suggest = "validate_nonce"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppAuthSettingsV2Login. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppAuthSettingsV2Login.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppAuthSettingsV2Login.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_external_redirect_urls: Optional[Sequence[str]] = None,
                 cookie_expiration_convention: Optional[str] = None,
                 cookie_expiration_time: Optional[str] = None,
                 logout_endpoint: Optional[str] = None,
                 nonce_expiration_time: Optional[str] = None,
                 preserve_url_fragments_for_logins: Optional[bool] = None,
                 token_refresh_extension_time: Optional[float] = None,
                 token_store_enabled: Optional[bool] = None,
                 token_store_path: Optional[str] = None,
                 token_store_sas_setting_name: Optional[str] = None,
                 validate_nonce: Optional[bool] = None):
        """
        :param Sequence[str] allowed_external_redirect_urls: External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends.
               
               > **Note:** URLs within the current domain are always implicitly allowed.
        :param str cookie_expiration_convention: The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
        :param str cookie_expiration_time: The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
        :param str logout_endpoint: The endpoint to which logout requests should be made.
        :param str nonce_expiration_time: The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
        :param bool preserve_url_fragments_for_logins: Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
        :param float token_refresh_extension_time: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        :param bool token_store_enabled: Should the Token Store configuration Enabled. Defaults to `false`
        :param str token_store_path: The directory path in the App Filesystem in which the tokens will be stored.
        :param str token_store_sas_setting_name: The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        :param bool validate_nonce: Should the nonce be validated while completing the login flow. Defaults to `true`.
        """
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if cookie_expiration_convention is not None:
            pulumi.set(__self__, "cookie_expiration_convention", cookie_expiration_convention)
        if cookie_expiration_time is not None:
            pulumi.set(__self__, "cookie_expiration_time", cookie_expiration_time)
        if logout_endpoint is not None:
            pulumi.set(__self__, "logout_endpoint", logout_endpoint)
        if nonce_expiration_time is not None:
            pulumi.set(__self__, "nonce_expiration_time", nonce_expiration_time)
        if preserve_url_fragments_for_logins is not None:
            pulumi.set(__self__, "preserve_url_fragments_for_logins", preserve_url_fragments_for_logins)
        if token_refresh_extension_time is not None:
            pulumi.set(__self__, "token_refresh_extension_time", token_refresh_extension_time)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if token_store_path is not None:
            pulumi.set(__self__, "token_store_path", token_store_path)
        if token_store_sas_setting_name is not None:
            pulumi.set(__self__, "token_store_sas_setting_name", token_store_sas_setting_name)
        if validate_nonce is not None:
            pulumi.set(__self__, "validate_nonce", validate_nonce)

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[Sequence[str]]:
        """
        External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends.

        > **Note:** URLs within the current domain are always implicitly allowed.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @property
    @pulumi.getter(name="cookieExpirationConvention")
    def cookie_expiration_convention(self) -> Optional[str]:
        """
        The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
        """
        return pulumi.get(self, "cookie_expiration_convention")

    @property
    @pulumi.getter(name="cookieExpirationTime")
    def cookie_expiration_time(self) -> Optional[str]:
        """
        The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
        """
        return pulumi.get(self, "cookie_expiration_time")

    @property
    @pulumi.getter(name="logoutEndpoint")
    def logout_endpoint(self) -> Optional[str]:
        """
        The endpoint to which logout requests should be made.
        """
        return pulumi.get(self, "logout_endpoint")

    @property
    @pulumi.getter(name="nonceExpirationTime")
    def nonce_expiration_time(self) -> Optional[str]:
        """
        The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
        """
        return pulumi.get(self, "nonce_expiration_time")

    @property
    @pulumi.getter(name="preserveUrlFragmentsForLogins")
    def preserve_url_fragments_for_logins(self) -> Optional[bool]:
        """
        Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
        """
        return pulumi.get(self, "preserve_url_fragments_for_logins")

    @property
    @pulumi.getter(name="tokenRefreshExtensionTime")
    def token_refresh_extension_time(self) -> Optional[float]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        return pulumi.get(self, "token_refresh_extension_time")

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[bool]:
        """
        Should the Token Store configuration Enabled. Defaults to `false`
        """
        return pulumi.get(self, "token_store_enabled")

    @property
    @pulumi.getter(name="tokenStorePath")
    def token_store_path(self) -> Optional[str]:
        """
        The directory path in the App Filesystem in which the tokens will be stored.
        """
        return pulumi.get(self, "token_store_path")

    @property
    @pulumi.getter(name="tokenStoreSasSettingName")
    def token_store_sas_setting_name(self) -> Optional[str]:
        """
        The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        """
        return pulumi.get(self, "token_store_sas_setting_name")

    @property
    @pulumi.getter(name="validateNonce")
    def validate_nonce(self) -> Optional[bool]:
        """
        Should the nonce be validated while completing the login flow. Defaults to `true`.
        """
        return pulumi.get(self, "validate_nonce")


@pulumi.output_type
class LinuxFunctionAppAuthSettingsV2MicrosoftV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "loginScopes":
            suggest = "login_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppAuthSettingsV2MicrosoftV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppAuthSettingsV2MicrosoftV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppAuthSettingsV2MicrosoftV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret_setting_name: str,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 login_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param Sequence[str] allowed_audiences: Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
               
               > **Note:** The `client_id` value is always considered an allowed audience.
        :param Sequence[str] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **Note:** The `client_id` value is always considered an allowed audience.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[Sequence[str]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class LinuxFunctionAppAuthSettingsV2TwitterV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerKey":
            suggest = "consumer_key"
        elif key == "consumerSecretSettingName":
            suggest = "consumer_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppAuthSettingsV2TwitterV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppAuthSettingsV2TwitterV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppAuthSettingsV2TwitterV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_key: str,
                 consumer_secret_setting_name: str):
        """
        :param str consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param str consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> str:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> str:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "consumer_secret_setting_name")


@pulumi.output_type
class LinuxFunctionAppBackup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageAccountUrl":
            suggest = "storage_account_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppBackup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppBackup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppBackup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 schedule: 'outputs.LinuxFunctionAppBackupSchedule',
                 storage_account_url: str,
                 enabled: Optional[bool] = None):
        """
        :param str name: The name which should be used for this Backup.
        :param 'LinuxFunctionAppBackupScheduleArgs' schedule: A `schedule` block as defined below.
        :param str storage_account_url: The SAS URL to the container.
        :param bool enabled: Should this backup job be enabled? Defaults to `true`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "storage_account_url", storage_account_url)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Backup.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def schedule(self) -> 'outputs.LinuxFunctionAppBackupSchedule':
        """
        A `schedule` block as defined below.
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter(name="storageAccountUrl")
    def storage_account_url(self) -> str:
        """
        The SAS URL to the container.
        """
        return pulumi.get(self, "storage_account_url")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Should this backup job be enabled? Defaults to `true`.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class LinuxFunctionAppBackupSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "frequencyUnit":
            suggest = "frequency_unit"
        elif key == "keepAtLeastOneBackup":
            suggest = "keep_at_least_one_backup"
        elif key == "lastExecutionTime":
            suggest = "last_execution_time"
        elif key == "retentionPeriodDays":
            suggest = "retention_period_days"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppBackupSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppBackupSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppBackupSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_unit: str,
                 keep_at_least_one_backup: Optional[bool] = None,
                 last_execution_time: Optional[str] = None,
                 retention_period_days: Optional[int] = None,
                 start_time: Optional[str] = None):
        """
        :param int frequency_interval: How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).
               
               > **NOTE:** Not all intervals are supported on all Linux Function App SKUs. Please refer to the official documentation for appropriate values.
        :param str frequency_unit: The unit of time for how often the backup should take place. Possible values include: `Day` and `Hour`.
        :param bool keep_at_least_one_backup: Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
        :param int retention_period_days: After how many days backups should be deleted. Defaults to `30`.
        :param str start_time: When the schedule should start working in RFC-3339 format.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_unit", frequency_unit)
        if keep_at_least_one_backup is not None:
            pulumi.set(__self__, "keep_at_least_one_backup", keep_at_least_one_backup)
        if last_execution_time is not None:
            pulumi.set(__self__, "last_execution_time", last_execution_time)
        if retention_period_days is not None:
            pulumi.set(__self__, "retention_period_days", retention_period_days)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).

        > **NOTE:** Not all intervals are supported on all Linux Function App SKUs. Please refer to the official documentation for appropriate values.
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyUnit")
    def frequency_unit(self) -> str:
        """
        The unit of time for how often the backup should take place. Possible values include: `Day` and `Hour`.
        """
        return pulumi.get(self, "frequency_unit")

    @property
    @pulumi.getter(name="keepAtLeastOneBackup")
    def keep_at_least_one_backup(self) -> Optional[bool]:
        """
        Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
        """
        return pulumi.get(self, "keep_at_least_one_backup")

    @property
    @pulumi.getter(name="lastExecutionTime")
    def last_execution_time(self) -> Optional[str]:
        return pulumi.get(self, "last_execution_time")

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> Optional[int]:
        """
        After how many days backups should be deleted. Defaults to `30`.
        """
        return pulumi.get(self, "retention_period_days")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        """
        When the schedule should start working in RFC-3339 format.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class LinuxFunctionAppConnectionString(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: The name which should be used for this Connection.
        :param str type: Type of database. Possible values include: `MySQL`, `SQLServer`, `SQLAzure`, `Custom`, `NotificationHub`, `ServiceBus`, `EventHub`, `APIHub`, `DocDb`, `RedisCache`, and `PostgreSQL`.
        :param str value: The connection string value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Connection.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of database. Possible values include: `MySQL`, `SQLServer`, `SQLAzure`, `Custom`, `NotificationHub`, `ServiceBus`, `EventHub`, `APIHub`, `DocDb`, `RedisCache`, and `PostgreSQL`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The connection string value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class LinuxFunctionAppIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 identity_ids: Optional[Sequence[str]] = None,
                 principal_id: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str type: Specifies the type of Managed Service Identity that should be configured on this Linux Function App. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        :param Sequence[str] identity_ids: A list of User Assigned Managed Identity IDs to be assigned to this Linux Function App.
               
               > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        :param str principal_id: The Principal ID associated with this Managed Service Identity.
        :param str tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the type of Managed Service Identity that should be configured on this Linux Function App. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[str]]:
        """
        A list of User Assigned Managed Identity IDs to be assigned to this Linux Function App.

        > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class LinuxFunctionAppSiteConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alwaysOn":
            suggest = "always_on"
        elif key == "apiDefinitionUrl":
            suggest = "api_definition_url"
        elif key == "apiManagementApiId":
            suggest = "api_management_api_id"
        elif key == "appCommandLine":
            suggest = "app_command_line"
        elif key == "appScaleLimit":
            suggest = "app_scale_limit"
        elif key == "appServiceLogs":
            suggest = "app_service_logs"
        elif key == "applicationInsightsConnectionString":
            suggest = "application_insights_connection_string"
        elif key == "applicationInsightsKey":
            suggest = "application_insights_key"
        elif key == "applicationStack":
            suggest = "application_stack"
        elif key == "containerRegistryManagedIdentityClientId":
            suggest = "container_registry_managed_identity_client_id"
        elif key == "containerRegistryUseManagedIdentity":
            suggest = "container_registry_use_managed_identity"
        elif key == "defaultDocuments":
            suggest = "default_documents"
        elif key == "detailedErrorLoggingEnabled":
            suggest = "detailed_error_logging_enabled"
        elif key == "elasticInstanceMinimum":
            suggest = "elastic_instance_minimum"
        elif key == "ftpsState":
            suggest = "ftps_state"
        elif key == "healthCheckEvictionTimeInMin":
            suggest = "health_check_eviction_time_in_min"
        elif key == "healthCheckPath":
            suggest = "health_check_path"
        elif key == "http2Enabled":
            suggest = "http2_enabled"
        elif key == "ipRestrictions":
            suggest = "ip_restrictions"
        elif key == "linuxFxVersion":
            suggest = "linux_fx_version"
        elif key == "loadBalancingMode":
            suggest = "load_balancing_mode"
        elif key == "managedPipelineMode":
            suggest = "managed_pipeline_mode"
        elif key == "minimumTlsVersion":
            suggest = "minimum_tls_version"
        elif key == "preWarmedInstanceCount":
            suggest = "pre_warmed_instance_count"
        elif key == "remoteDebuggingEnabled":
            suggest = "remote_debugging_enabled"
        elif key == "remoteDebuggingVersion":
            suggest = "remote_debugging_version"
        elif key == "runtimeScaleMonitoringEnabled":
            suggest = "runtime_scale_monitoring_enabled"
        elif key == "scmIpRestrictions":
            suggest = "scm_ip_restrictions"
        elif key == "scmMinimumTlsVersion":
            suggest = "scm_minimum_tls_version"
        elif key == "scmType":
            suggest = "scm_type"
        elif key == "scmUseMainIpRestriction":
            suggest = "scm_use_main_ip_restriction"
        elif key == "use32BitWorker":
            suggest = "use32_bit_worker"
        elif key == "vnetRouteAllEnabled":
            suggest = "vnet_route_all_enabled"
        elif key == "websocketsEnabled":
            suggest = "websockets_enabled"
        elif key == "workerCount":
            suggest = "worker_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSiteConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSiteConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSiteConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 always_on: Optional[bool] = None,
                 api_definition_url: Optional[str] = None,
                 api_management_api_id: Optional[str] = None,
                 app_command_line: Optional[str] = None,
                 app_scale_limit: Optional[int] = None,
                 app_service_logs: Optional['outputs.LinuxFunctionAppSiteConfigAppServiceLogs'] = None,
                 application_insights_connection_string: Optional[str] = None,
                 application_insights_key: Optional[str] = None,
                 application_stack: Optional['outputs.LinuxFunctionAppSiteConfigApplicationStack'] = None,
                 container_registry_managed_identity_client_id: Optional[str] = None,
                 container_registry_use_managed_identity: Optional[bool] = None,
                 cors: Optional['outputs.LinuxFunctionAppSiteConfigCors'] = None,
                 default_documents: Optional[Sequence[str]] = None,
                 detailed_error_logging_enabled: Optional[bool] = None,
                 elastic_instance_minimum: Optional[int] = None,
                 ftps_state: Optional[str] = None,
                 health_check_eviction_time_in_min: Optional[int] = None,
                 health_check_path: Optional[str] = None,
                 http2_enabled: Optional[bool] = None,
                 ip_restrictions: Optional[Sequence['outputs.LinuxFunctionAppSiteConfigIpRestriction']] = None,
                 linux_fx_version: Optional[str] = None,
                 load_balancing_mode: Optional[str] = None,
                 managed_pipeline_mode: Optional[str] = None,
                 minimum_tls_version: Optional[str] = None,
                 pre_warmed_instance_count: Optional[int] = None,
                 remote_debugging_enabled: Optional[bool] = None,
                 remote_debugging_version: Optional[str] = None,
                 runtime_scale_monitoring_enabled: Optional[bool] = None,
                 scm_ip_restrictions: Optional[Sequence['outputs.LinuxFunctionAppSiteConfigScmIpRestriction']] = None,
                 scm_minimum_tls_version: Optional[str] = None,
                 scm_type: Optional[str] = None,
                 scm_use_main_ip_restriction: Optional[bool] = None,
                 use32_bit_worker: Optional[bool] = None,
                 vnet_route_all_enabled: Optional[bool] = None,
                 websockets_enabled: Optional[bool] = None,
                 worker_count: Optional[int] = None):
        """
        :param bool always_on: If this Linux Web App is Always On enabled. Defaults to `false`.
               
               > **NOTE:** when running in a Consumption or Premium Plan, `always_on` feature should be turned off. Please turn it off before upgrading the service plan from standard to premium.
        :param str api_definition_url: The URL of the API definition that describes this Linux Function App.
        :param str api_management_api_id: The ID of the API Management API for this Linux Function App.
        :param str app_command_line: The App command line to launch.
        :param int app_scale_limit: The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
        :param 'LinuxFunctionAppSiteConfigAppServiceLogsArgs' app_service_logs: An `app_service_logs` block as defined above.
        :param str application_insights_connection_string: The Connection String for linking the Linux Function App to Application Insights.
        :param str application_insights_key: The Instrumentation Key for connecting the Linux Function App to Application Insights.
        :param 'LinuxFunctionAppSiteConfigApplicationStackArgs' application_stack: An `application_stack` block as defined above.
               
               > **Note:** If this is set, there must not be an application setting `FUNCTIONS_WORKER_RUNTIME`.
        :param str container_registry_managed_identity_client_id: The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
        :param bool container_registry_use_managed_identity: Should connections for Azure Container Registry use Managed Identity.
        :param 'LinuxFunctionAppSiteConfigCorsArgs' cors: A `cors` block as defined above.
        :param Sequence[str] default_documents: Specifies a list of Default Documents for the Linux Web App.
        :param int elastic_instance_minimum: The number of minimum instances for this Linux Function App. Only affects apps on Elastic Premium plans.
        :param str ftps_state: State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`. Defaults to `Disabled`.
        :param int health_check_eviction_time_in_min: The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        :param str health_check_path: The path to be checked for this function app health.
        :param bool http2_enabled: Specifies if the HTTP2 protocol should be enabled. Defaults to `false`.
        :param Sequence['LinuxFunctionAppSiteConfigIpRestrictionArgs'] ip_restrictions: One or more `ip_restriction` blocks as defined above.
        :param str load_balancing_mode: The Site load balancing mode. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        :param str managed_pipeline_mode: Managed pipeline mode. Possible values include: `Integrated`, `Classic`. Defaults to `Integrated`.
        :param str minimum_tls_version: The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        :param int pre_warmed_instance_count: The number of pre-warmed instances for this function app. Only affects apps on an Elastic Premium plan.
        :param bool remote_debugging_enabled: Should Remote Debugging be enabled. Defaults to `false`.
        :param str remote_debugging_version: The Remote Debugging Version. Possible values include `VS2017`, `VS2019`, and `VS2022`.
        :param bool runtime_scale_monitoring_enabled: Should Scale Monitoring of the Functions Runtime be enabled?
               
               > **NOTE:** Functions runtime scale monitoring can only be enabled for Elastic Premium Function Apps or Workflow Standard Logic Apps and requires a minimum prewarmed instance count of 1.
        :param Sequence['LinuxFunctionAppSiteConfigScmIpRestrictionArgs'] scm_ip_restrictions: One or more `scm_ip_restriction` blocks as defined above.
        :param str scm_minimum_tls_version: Configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        :param bool scm_use_main_ip_restriction: Should the Linux Function App `ip_restriction` configuration be used for the SCM also.
        :param bool use32_bit_worker: Should the Linux Web App use a 32-bit worker process. Defaults to `true`.
        :param bool vnet_route_all_enabled: Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        :param bool websockets_enabled: Should Web Sockets be enabled. Defaults to `false`.
        :param int worker_count: The number of Workers for this Linux Function App.
        """
        if always_on is not None:
            pulumi.set(__self__, "always_on", always_on)
        if api_definition_url is not None:
            pulumi.set(__self__, "api_definition_url", api_definition_url)
        if api_management_api_id is not None:
            pulumi.set(__self__, "api_management_api_id", api_management_api_id)
        if app_command_line is not None:
            pulumi.set(__self__, "app_command_line", app_command_line)
        if app_scale_limit is not None:
            pulumi.set(__self__, "app_scale_limit", app_scale_limit)
        if app_service_logs is not None:
            pulumi.set(__self__, "app_service_logs", app_service_logs)
        if application_insights_connection_string is not None:
            pulumi.set(__self__, "application_insights_connection_string", application_insights_connection_string)
        if application_insights_key is not None:
            pulumi.set(__self__, "application_insights_key", application_insights_key)
        if application_stack is not None:
            pulumi.set(__self__, "application_stack", application_stack)
        if container_registry_managed_identity_client_id is not None:
            pulumi.set(__self__, "container_registry_managed_identity_client_id", container_registry_managed_identity_client_id)
        if container_registry_use_managed_identity is not None:
            pulumi.set(__self__, "container_registry_use_managed_identity", container_registry_use_managed_identity)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if default_documents is not None:
            pulumi.set(__self__, "default_documents", default_documents)
        if detailed_error_logging_enabled is not None:
            pulumi.set(__self__, "detailed_error_logging_enabled", detailed_error_logging_enabled)
        if elastic_instance_minimum is not None:
            pulumi.set(__self__, "elastic_instance_minimum", elastic_instance_minimum)
        if ftps_state is not None:
            pulumi.set(__self__, "ftps_state", ftps_state)
        if health_check_eviction_time_in_min is not None:
            pulumi.set(__self__, "health_check_eviction_time_in_min", health_check_eviction_time_in_min)
        if health_check_path is not None:
            pulumi.set(__self__, "health_check_path", health_check_path)
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if ip_restrictions is not None:
            pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        if linux_fx_version is not None:
            pulumi.set(__self__, "linux_fx_version", linux_fx_version)
        if load_balancing_mode is not None:
            pulumi.set(__self__, "load_balancing_mode", load_balancing_mode)
        if managed_pipeline_mode is not None:
            pulumi.set(__self__, "managed_pipeline_mode", managed_pipeline_mode)
        if minimum_tls_version is not None:
            pulumi.set(__self__, "minimum_tls_version", minimum_tls_version)
        if pre_warmed_instance_count is not None:
            pulumi.set(__self__, "pre_warmed_instance_count", pre_warmed_instance_count)
        if remote_debugging_enabled is not None:
            pulumi.set(__self__, "remote_debugging_enabled", remote_debugging_enabled)
        if remote_debugging_version is not None:
            pulumi.set(__self__, "remote_debugging_version", remote_debugging_version)
        if runtime_scale_monitoring_enabled is not None:
            pulumi.set(__self__, "runtime_scale_monitoring_enabled", runtime_scale_monitoring_enabled)
        if scm_ip_restrictions is not None:
            pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        if scm_minimum_tls_version is not None:
            pulumi.set(__self__, "scm_minimum_tls_version", scm_minimum_tls_version)
        if scm_type is not None:
            pulumi.set(__self__, "scm_type", scm_type)
        if scm_use_main_ip_restriction is not None:
            pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        if use32_bit_worker is not None:
            pulumi.set(__self__, "use32_bit_worker", use32_bit_worker)
        if vnet_route_all_enabled is not None:
            pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        if websockets_enabled is not None:
            pulumi.set(__self__, "websockets_enabled", websockets_enabled)
        if worker_count is not None:
            pulumi.set(__self__, "worker_count", worker_count)

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> Optional[bool]:
        """
        If this Linux Web App is Always On enabled. Defaults to `false`.

        > **NOTE:** when running in a Consumption or Premium Plan, `always_on` feature should be turned off. Please turn it off before upgrading the service plan from standard to premium.
        """
        return pulumi.get(self, "always_on")

    @property
    @pulumi.getter(name="apiDefinitionUrl")
    def api_definition_url(self) -> Optional[str]:
        """
        The URL of the API definition that describes this Linux Function App.
        """
        return pulumi.get(self, "api_definition_url")

    @property
    @pulumi.getter(name="apiManagementApiId")
    def api_management_api_id(self) -> Optional[str]:
        """
        The ID of the API Management API for this Linux Function App.
        """
        return pulumi.get(self, "api_management_api_id")

    @property
    @pulumi.getter(name="appCommandLine")
    def app_command_line(self) -> Optional[str]:
        """
        The App command line to launch.
        """
        return pulumi.get(self, "app_command_line")

    @property
    @pulumi.getter(name="appScaleLimit")
    def app_scale_limit(self) -> Optional[int]:
        """
        The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
        """
        return pulumi.get(self, "app_scale_limit")

    @property
    @pulumi.getter(name="appServiceLogs")
    def app_service_logs(self) -> Optional['outputs.LinuxFunctionAppSiteConfigAppServiceLogs']:
        """
        An `app_service_logs` block as defined above.
        """
        return pulumi.get(self, "app_service_logs")

    @property
    @pulumi.getter(name="applicationInsightsConnectionString")
    def application_insights_connection_string(self) -> Optional[str]:
        """
        The Connection String for linking the Linux Function App to Application Insights.
        """
        return pulumi.get(self, "application_insights_connection_string")

    @property
    @pulumi.getter(name="applicationInsightsKey")
    def application_insights_key(self) -> Optional[str]:
        """
        The Instrumentation Key for connecting the Linux Function App to Application Insights.
        """
        return pulumi.get(self, "application_insights_key")

    @property
    @pulumi.getter(name="applicationStack")
    def application_stack(self) -> Optional['outputs.LinuxFunctionAppSiteConfigApplicationStack']:
        """
        An `application_stack` block as defined above.

        > **Note:** If this is set, there must not be an application setting `FUNCTIONS_WORKER_RUNTIME`.
        """
        return pulumi.get(self, "application_stack")

    @property
    @pulumi.getter(name="containerRegistryManagedIdentityClientId")
    def container_registry_managed_identity_client_id(self) -> Optional[str]:
        """
        The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
        """
        return pulumi.get(self, "container_registry_managed_identity_client_id")

    @property
    @pulumi.getter(name="containerRegistryUseManagedIdentity")
    def container_registry_use_managed_identity(self) -> Optional[bool]:
        """
        Should connections for Azure Container Registry use Managed Identity.
        """
        return pulumi.get(self, "container_registry_use_managed_identity")

    @property
    @pulumi.getter
    def cors(self) -> Optional['outputs.LinuxFunctionAppSiteConfigCors']:
        """
        A `cors` block as defined above.
        """
        return pulumi.get(self, "cors")

    @property
    @pulumi.getter(name="defaultDocuments")
    def default_documents(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Default Documents for the Linux Web App.
        """
        return pulumi.get(self, "default_documents")

    @property
    @pulumi.getter(name="detailedErrorLoggingEnabled")
    def detailed_error_logging_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "detailed_error_logging_enabled")

    @property
    @pulumi.getter(name="elasticInstanceMinimum")
    def elastic_instance_minimum(self) -> Optional[int]:
        """
        The number of minimum instances for this Linux Function App. Only affects apps on Elastic Premium plans.
        """
        return pulumi.get(self, "elastic_instance_minimum")

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> Optional[str]:
        """
        State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`. Defaults to `Disabled`.
        """
        return pulumi.get(self, "ftps_state")

    @property
    @pulumi.getter(name="healthCheckEvictionTimeInMin")
    def health_check_eviction_time_in_min(self) -> Optional[int]:
        """
        The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        """
        return pulumi.get(self, "health_check_eviction_time_in_min")

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> Optional[str]:
        """
        The path to be checked for this function app health.
        """
        return pulumi.get(self, "health_check_path")

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[bool]:
        """
        Specifies if the HTTP2 protocol should be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "http2_enabled")

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Optional[Sequence['outputs.LinuxFunctionAppSiteConfigIpRestriction']]:
        """
        One or more `ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "ip_restrictions")

    @property
    @pulumi.getter(name="linuxFxVersion")
    def linux_fx_version(self) -> Optional[str]:
        return pulumi.get(self, "linux_fx_version")

    @property
    @pulumi.getter(name="loadBalancingMode")
    def load_balancing_mode(self) -> Optional[str]:
        """
        The Site load balancing mode. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        """
        return pulumi.get(self, "load_balancing_mode")

    @property
    @pulumi.getter(name="managedPipelineMode")
    def managed_pipeline_mode(self) -> Optional[str]:
        """
        Managed pipeline mode. Possible values include: `Integrated`, `Classic`. Defaults to `Integrated`.
        """
        return pulumi.get(self, "managed_pipeline_mode")

    @property
    @pulumi.getter(name="minimumTlsVersion")
    def minimum_tls_version(self) -> Optional[str]:
        """
        The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        """
        return pulumi.get(self, "minimum_tls_version")

    @property
    @pulumi.getter(name="preWarmedInstanceCount")
    def pre_warmed_instance_count(self) -> Optional[int]:
        """
        The number of pre-warmed instances for this function app. Only affects apps on an Elastic Premium plan.
        """
        return pulumi.get(self, "pre_warmed_instance_count")

    @property
    @pulumi.getter(name="remoteDebuggingEnabled")
    def remote_debugging_enabled(self) -> Optional[bool]:
        """
        Should Remote Debugging be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "remote_debugging_enabled")

    @property
    @pulumi.getter(name="remoteDebuggingVersion")
    def remote_debugging_version(self) -> Optional[str]:
        """
        The Remote Debugging Version. Possible values include `VS2017`, `VS2019`, and `VS2022`.
        """
        return pulumi.get(self, "remote_debugging_version")

    @property
    @pulumi.getter(name="runtimeScaleMonitoringEnabled")
    def runtime_scale_monitoring_enabled(self) -> Optional[bool]:
        """
        Should Scale Monitoring of the Functions Runtime be enabled?

        > **NOTE:** Functions runtime scale monitoring can only be enabled for Elastic Premium Function Apps or Workflow Standard Logic Apps and requires a minimum prewarmed instance count of 1.
        """
        return pulumi.get(self, "runtime_scale_monitoring_enabled")

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Optional[Sequence['outputs.LinuxFunctionAppSiteConfigScmIpRestriction']]:
        """
        One or more `scm_ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "scm_ip_restrictions")

    @property
    @pulumi.getter(name="scmMinimumTlsVersion")
    def scm_minimum_tls_version(self) -> Optional[str]:
        """
        Configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        """
        return pulumi.get(self, "scm_minimum_tls_version")

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> Optional[str]:
        return pulumi.get(self, "scm_type")

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> Optional[bool]:
        """
        Should the Linux Function App `ip_restriction` configuration be used for the SCM also.
        """
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @property
    @pulumi.getter(name="use32BitWorker")
    def use32_bit_worker(self) -> Optional[bool]:
        """
        Should the Linux Web App use a 32-bit worker process. Defaults to `true`.
        """
        return pulumi.get(self, "use32_bit_worker")

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> Optional[bool]:
        """
        Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        """
        return pulumi.get(self, "vnet_route_all_enabled")

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> Optional[bool]:
        """
        Should Web Sockets be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "websockets_enabled")

    @property
    @pulumi.getter(name="workerCount")
    def worker_count(self) -> Optional[int]:
        """
        The number of Workers for this Linux Function App.
        """
        return pulumi.get(self, "worker_count")


@pulumi.output_type
class LinuxFunctionAppSiteConfigAppServiceLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskQuotaMb":
            suggest = "disk_quota_mb"
        elif key == "retentionPeriodDays":
            suggest = "retention_period_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSiteConfigAppServiceLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSiteConfigAppServiceLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSiteConfigAppServiceLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_quota_mb: Optional[int] = None,
                 retention_period_days: Optional[int] = None):
        """
        :param int disk_quota_mb: The amount of disk space to use for logs. Valid values are between `25` and `100`. Defaults to `35`.
        :param int retention_period_days: The retention period for logs in days. Valid values are between `0` and `99999`.(never delete).
               
               > **NOTE:** This block is not supported on Consumption plans.
        """
        if disk_quota_mb is not None:
            pulumi.set(__self__, "disk_quota_mb", disk_quota_mb)
        if retention_period_days is not None:
            pulumi.set(__self__, "retention_period_days", retention_period_days)

    @property
    @pulumi.getter(name="diskQuotaMb")
    def disk_quota_mb(self) -> Optional[int]:
        """
        The amount of disk space to use for logs. Valid values are between `25` and `100`. Defaults to `35`.
        """
        return pulumi.get(self, "disk_quota_mb")

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> Optional[int]:
        """
        The retention period for logs in days. Valid values are between `0` and `99999`.(never delete).

        > **NOTE:** This block is not supported on Consumption plans.
        """
        return pulumi.get(self, "retention_period_days")


@pulumi.output_type
class LinuxFunctionAppSiteConfigApplicationStack(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dotnetVersion":
            suggest = "dotnet_version"
        elif key == "javaVersion":
            suggest = "java_version"
        elif key == "nodeVersion":
            suggest = "node_version"
        elif key == "powershellCoreVersion":
            suggest = "powershell_core_version"
        elif key == "pythonVersion":
            suggest = "python_version"
        elif key == "useCustomRuntime":
            suggest = "use_custom_runtime"
        elif key == "useDotnetIsolatedRuntime":
            suggest = "use_dotnet_isolated_runtime"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSiteConfigApplicationStack. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSiteConfigApplicationStack.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSiteConfigApplicationStack.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dockers: Optional[Sequence['outputs.LinuxFunctionAppSiteConfigApplicationStackDocker']] = None,
                 dotnet_version: Optional[str] = None,
                 java_version: Optional[str] = None,
                 node_version: Optional[str] = None,
                 powershell_core_version: Optional[str] = None,
                 python_version: Optional[str] = None,
                 use_custom_runtime: Optional[bool] = None,
                 use_dotnet_isolated_runtime: Optional[bool] = None):
        """
        :param Sequence['LinuxFunctionAppSiteConfigApplicationStackDockerArgs'] dockers: One or more `docker` blocks as defined below.
        :param str dotnet_version: The version of .NET to use. Possible values include `3.1`, `6.0` and `7.0`.
        :param str java_version: The Version of Java to use. Supported versions include `8`, `11` & `17`.
        :param str node_version: The version of Node to run. Possible values include `12`, `14`, `16` and `18`.
        :param str powershell_core_version: The version of PowerShell Core to run. Possible values are `7`, and `7.2`.
        :param str python_version: The version of Python to run. Possible values are `3.11`, `3.10`, `3.9`, `3.8` and `3.7`.
        :param bool use_custom_runtime: Should the Linux Function App use a custom runtime?
        :param bool use_dotnet_isolated_runtime: Should the DotNet process use an isolated runtime. Defaults to `false`.
        """
        if dockers is not None:
            pulumi.set(__self__, "dockers", dockers)
        if dotnet_version is not None:
            pulumi.set(__self__, "dotnet_version", dotnet_version)
        if java_version is not None:
            pulumi.set(__self__, "java_version", java_version)
        if node_version is not None:
            pulumi.set(__self__, "node_version", node_version)
        if powershell_core_version is not None:
            pulumi.set(__self__, "powershell_core_version", powershell_core_version)
        if python_version is not None:
            pulumi.set(__self__, "python_version", python_version)
        if use_custom_runtime is not None:
            pulumi.set(__self__, "use_custom_runtime", use_custom_runtime)
        if use_dotnet_isolated_runtime is not None:
            pulumi.set(__self__, "use_dotnet_isolated_runtime", use_dotnet_isolated_runtime)

    @property
    @pulumi.getter
    def dockers(self) -> Optional[Sequence['outputs.LinuxFunctionAppSiteConfigApplicationStackDocker']]:
        """
        One or more `docker` blocks as defined below.
        """
        return pulumi.get(self, "dockers")

    @property
    @pulumi.getter(name="dotnetVersion")
    def dotnet_version(self) -> Optional[str]:
        """
        The version of .NET to use. Possible values include `3.1`, `6.0` and `7.0`.
        """
        return pulumi.get(self, "dotnet_version")

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> Optional[str]:
        """
        The Version of Java to use. Supported versions include `8`, `11` & `17`.
        """
        return pulumi.get(self, "java_version")

    @property
    @pulumi.getter(name="nodeVersion")
    def node_version(self) -> Optional[str]:
        """
        The version of Node to run. Possible values include `12`, `14`, `16` and `18`.
        """
        return pulumi.get(self, "node_version")

    @property
    @pulumi.getter(name="powershellCoreVersion")
    def powershell_core_version(self) -> Optional[str]:
        """
        The version of PowerShell Core to run. Possible values are `7`, and `7.2`.
        """
        return pulumi.get(self, "powershell_core_version")

    @property
    @pulumi.getter(name="pythonVersion")
    def python_version(self) -> Optional[str]:
        """
        The version of Python to run. Possible values are `3.11`, `3.10`, `3.9`, `3.8` and `3.7`.
        """
        return pulumi.get(self, "python_version")

    @property
    @pulumi.getter(name="useCustomRuntime")
    def use_custom_runtime(self) -> Optional[bool]:
        """
        Should the Linux Function App use a custom runtime?
        """
        return pulumi.get(self, "use_custom_runtime")

    @property
    @pulumi.getter(name="useDotnetIsolatedRuntime")
    def use_dotnet_isolated_runtime(self) -> Optional[bool]:
        """
        Should the DotNet process use an isolated runtime. Defaults to `false`.
        """
        return pulumi.get(self, "use_dotnet_isolated_runtime")


@pulumi.output_type
class LinuxFunctionAppSiteConfigApplicationStackDocker(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageName":
            suggest = "image_name"
        elif key == "imageTag":
            suggest = "image_tag"
        elif key == "registryUrl":
            suggest = "registry_url"
        elif key == "registryPassword":
            suggest = "registry_password"
        elif key == "registryUsername":
            suggest = "registry_username"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSiteConfigApplicationStackDocker. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSiteConfigApplicationStackDocker.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSiteConfigApplicationStackDocker.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_name: str,
                 image_tag: str,
                 registry_url: str,
                 registry_password: Optional[str] = None,
                 registry_username: Optional[str] = None):
        """
        :param str image_name: The name of the Docker image to use.
        :param str image_tag: The image tag of the image to use.
        :param str registry_url: The URL of the docker registry.
        :param str registry_password: The password for the account to use to connect to the registry.
               
               > **NOTE:** This value is required if `container_registry_use_managed_identity` is not set to `true`.
        :param str registry_username: The username to use for connections to the registry.
               
               > **NOTE:** This value is required if `container_registry_use_managed_identity` is not set to `true`.
        """
        pulumi.set(__self__, "image_name", image_name)
        pulumi.set(__self__, "image_tag", image_tag)
        pulumi.set(__self__, "registry_url", registry_url)
        if registry_password is not None:
            pulumi.set(__self__, "registry_password", registry_password)
        if registry_username is not None:
            pulumi.set(__self__, "registry_username", registry_username)

    @property
    @pulumi.getter(name="imageName")
    def image_name(self) -> str:
        """
        The name of the Docker image to use.
        """
        return pulumi.get(self, "image_name")

    @property
    @pulumi.getter(name="imageTag")
    def image_tag(self) -> str:
        """
        The image tag of the image to use.
        """
        return pulumi.get(self, "image_tag")

    @property
    @pulumi.getter(name="registryUrl")
    def registry_url(self) -> str:
        """
        The URL of the docker registry.
        """
        return pulumi.get(self, "registry_url")

    @property
    @pulumi.getter(name="registryPassword")
    def registry_password(self) -> Optional[str]:
        """
        The password for the account to use to connect to the registry.

        > **NOTE:** This value is required if `container_registry_use_managed_identity` is not set to `true`.
        """
        return pulumi.get(self, "registry_password")

    @property
    @pulumi.getter(name="registryUsername")
    def registry_username(self) -> Optional[str]:
        """
        The username to use for connections to the registry.

        > **NOTE:** This value is required if `container_registry_use_managed_identity` is not set to `true`.
        """
        return pulumi.get(self, "registry_username")


@pulumi.output_type
class LinuxFunctionAppSiteConfigCors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedOrigins":
            suggest = "allowed_origins"
        elif key == "supportCredentials":
            suggest = "support_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSiteConfigCors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSiteConfigCors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSiteConfigCors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_origins: Optional[Sequence[str]] = None,
                 support_credentials: Optional[bool] = None):
        """
        :param Sequence[str] allowed_origins: Specifies a list of origins that should be allowed to make cross-origin calls.
        :param bool support_credentials: Are credentials allowed in CORS requests? Defaults to `false`.
        """
        if allowed_origins is not None:
            pulumi.set(__self__, "allowed_origins", allowed_origins)
        if support_credentials is not None:
            pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of origins that should be allowed to make cross-origin calls.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> Optional[bool]:
        """
        Are credentials allowed in CORS requests? Defaults to `false`.
        """
        return pulumi.get(self, "support_credentials")


@pulumi.output_type
class LinuxFunctionAppSiteConfigIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSiteConfigIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSiteConfigIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSiteConfigIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.LinuxFunctionAppSiteConfigIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: The action to take. Possible values are `Allow` or `Deny`.
        :param 'LinuxFunctionAppSiteConfigIpRestrictionHeadersArgs' headers: A `headers` block as defined above.
        :param str ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param str name: The name which should be used for this `ip_restriction`.
        :param int priority: The priority value of this `ip_restriction`. Defaults to `65000`.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
               
               > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        The action to take. Possible values are `Allow` or `Deny`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.LinuxFunctionAppSiteConfigIpRestrictionHeaders']:
        """
        A `headers` block as defined above.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class LinuxFunctionAppSiteConfigIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSiteConfigIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param str x_fd_health_probe: Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        :param Sequence[str] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param Sequence[str] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class LinuxFunctionAppSiteConfigScmIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSiteConfigScmIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSiteConfigScmIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSiteConfigScmIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.LinuxFunctionAppSiteConfigScmIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: The action to take. Possible values are `Allow` or `Deny`.
        :param 'LinuxFunctionAppSiteConfigScmIpRestrictionHeadersArgs' headers: A `headers` block as defined above.
        :param str ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param str name: The name which should be used for this `ip_restriction`.
        :param int priority: The priority value of this `ip_restriction`. Defaults to `65000`.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
               
               > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        The action to take. Possible values are `Allow` or `Deny`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.LinuxFunctionAppSiteConfigScmIpRestrictionHeaders']:
        """
        A `headers` block as defined above.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class LinuxFunctionAppSiteConfigScmIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSiteConfigScmIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param str x_fd_health_probe: Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        :param Sequence[str] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param Sequence[str] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class LinuxFunctionAppSiteCredential(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 password: Optional[str] = None):
        """
        :param str name: The name which should be used for this Linux Function App. Changing this forces a new Linux Function App to be created. Limit the function name to 32 characters to avoid naming collisions. For more information about [Function App naming rule](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/resource-name-rules#microsoftweb) and [Host ID Collisions](https://github.com/Azure/azure-functions-host/wiki/Host-IDs#host-id-collisions)
        :param str password: The Site Credentials Password used for publishing.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name which should be used for this Linux Function App. Changing this forces a new Linux Function App to be created. Limit the function name to 32 characters to avoid naming collisions. For more information about [Function App naming rule](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/resource-name-rules#microsoftweb) and [Host ID Collisions](https://github.com/Azure/azure-functions-host/wiki/Host-IDs#host-id-collisions)
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The Site Credentials Password used for publishing.
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class LinuxFunctionAppSlotAuthSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeDirectory":
            suggest = "active_directory"
        elif key == "additionalLoginParameters":
            suggest = "additional_login_parameters"
        elif key == "allowedExternalRedirectUrls":
            suggest = "allowed_external_redirect_urls"
        elif key == "defaultProvider":
            suggest = "default_provider"
        elif key == "runtimeVersion":
            suggest = "runtime_version"
        elif key == "tokenRefreshExtensionHours":
            suggest = "token_refresh_extension_hours"
        elif key == "tokenStoreEnabled":
            suggest = "token_store_enabled"
        elif key == "unauthenticatedClientAction":
            suggest = "unauthenticated_client_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotAuthSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotAuthSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotAuthSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 active_directory: Optional['outputs.LinuxFunctionAppSlotAuthSettingsActiveDirectory'] = None,
                 additional_login_parameters: Optional[Mapping[str, str]] = None,
                 allowed_external_redirect_urls: Optional[Sequence[str]] = None,
                 default_provider: Optional[str] = None,
                 facebook: Optional['outputs.LinuxFunctionAppSlotAuthSettingsFacebook'] = None,
                 github: Optional['outputs.LinuxFunctionAppSlotAuthSettingsGithub'] = None,
                 google: Optional['outputs.LinuxFunctionAppSlotAuthSettingsGoogle'] = None,
                 issuer: Optional[str] = None,
                 microsoft: Optional['outputs.LinuxFunctionAppSlotAuthSettingsMicrosoft'] = None,
                 runtime_version: Optional[str] = None,
                 token_refresh_extension_hours: Optional[float] = None,
                 token_store_enabled: Optional[bool] = None,
                 twitter: Optional['outputs.LinuxFunctionAppSlotAuthSettingsTwitter'] = None,
                 unauthenticated_client_action: Optional[str] = None):
        """
        :param bool enabled: Should the Authentication / Authorization feature be enabled?
        :param 'LinuxFunctionAppSlotAuthSettingsActiveDirectoryArgs' active_directory: an `active_directory` block as detailed below.
        :param Mapping[str, str] additional_login_parameters: Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        :param Sequence[str] allowed_external_redirect_urls: an `allowed_external_redirect_urls` block as detailed below.
        :param str default_provider: The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.
               
               > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        :param 'LinuxFunctionAppSlotAuthSettingsFacebookArgs' facebook: a `facebook` block as detailed below.
        :param 'LinuxFunctionAppSlotAuthSettingsGithubArgs' github: a `github` block as detailed below.
        :param 'LinuxFunctionAppSlotAuthSettingsGoogleArgs' google: a `google` block as detailed below.
        :param str issuer: The OpenID Connect Issuer URI that represents the entity which issues access tokens.
               
               > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        :param 'LinuxFunctionAppSlotAuthSettingsMicrosoftArgs' microsoft: a `microsoft` block as detailed below.
        :param str runtime_version: The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        :param float token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        :param bool token_store_enabled: Should the Linux Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        :param 'LinuxFunctionAppSlotAuthSettingsTwitterArgs' twitter: a `twitter` block as detailed below.
        :param str unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if active_directory is not None:
            pulumi.set(__self__, "active_directory", active_directory)
        if additional_login_parameters is not None:
            pulumi.set(__self__, "additional_login_parameters", additional_login_parameters)
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if facebook is not None:
            pulumi.set(__self__, "facebook", facebook)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if google is not None:
            pulumi.set(__self__, "google", google)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if microsoft is not None:
            pulumi.set(__self__, "microsoft", microsoft)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if token_refresh_extension_hours is not None:
            pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if twitter is not None:
            pulumi.set(__self__, "twitter", twitter)
        if unauthenticated_client_action is not None:
            pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Should the Authentication / Authorization feature be enabled?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="activeDirectory")
    def active_directory(self) -> Optional['outputs.LinuxFunctionAppSlotAuthSettingsActiveDirectory']:
        """
        an `active_directory` block as detailed below.
        """
        return pulumi.get(self, "active_directory")

    @property
    @pulumi.getter(name="additionalLoginParameters")
    def additional_login_parameters(self) -> Optional[Mapping[str, str]]:
        """
        Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        """
        return pulumi.get(self, "additional_login_parameters")

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[Sequence[str]]:
        """
        an `allowed_external_redirect_urls` block as detailed below.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[str]:
        """
        The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.

        > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        """
        return pulumi.get(self, "default_provider")

    @property
    @pulumi.getter
    def facebook(self) -> Optional['outputs.LinuxFunctionAppSlotAuthSettingsFacebook']:
        """
        a `facebook` block as detailed below.
        """
        return pulumi.get(self, "facebook")

    @property
    @pulumi.getter
    def github(self) -> Optional['outputs.LinuxFunctionAppSlotAuthSettingsGithub']:
        """
        a `github` block as detailed below.
        """
        return pulumi.get(self, "github")

    @property
    @pulumi.getter
    def google(self) -> Optional['outputs.LinuxFunctionAppSlotAuthSettingsGoogle']:
        """
        a `google` block as detailed below.
        """
        return pulumi.get(self, "google")

    @property
    @pulumi.getter
    def issuer(self) -> Optional[str]:
        """
        The OpenID Connect Issuer URI that represents the entity which issues access tokens.

        > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def microsoft(self) -> Optional['outputs.LinuxFunctionAppSlotAuthSettingsMicrosoft']:
        """
        a `microsoft` block as detailed below.
        """
        return pulumi.get(self, "microsoft")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[str]:
        """
        The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> Optional[float]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        return pulumi.get(self, "token_refresh_extension_hours")

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[bool]:
        """
        Should the Linux Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        """
        return pulumi.get(self, "token_store_enabled")

    @property
    @pulumi.getter
    def twitter(self) -> Optional['outputs.LinuxFunctionAppSlotAuthSettingsTwitter']:
        """
        a `twitter` block as detailed below.
        """
        return pulumi.get(self, "twitter")

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> Optional[str]:
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        return pulumi.get(self, "unauthenticated_client_action")


@pulumi.output_type
class LinuxFunctionAppSlotAuthSettingsActiveDirectory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotAuthSettingsActiveDirectory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotAuthSettingsActiveDirectory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotAuthSettingsActiveDirectory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param Sequence[str] allowed_audiences: an `allowed_audiences` block as detailed below.
               
               > **Note:** The `client_id` value is always considered an allowed audience.
        :param str client_secret: The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        pulumi.set(__self__, "client_id", client_id)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        an `allowed_audiences` block as detailed below.

        > **Note:** The `client_id` value is always considered an allowed audience.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")


@pulumi.output_type
class LinuxFunctionAppSlotAuthSettingsFacebook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "appSecret":
            suggest = "app_secret"
        elif key == "appSecretSettingName":
            suggest = "app_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotAuthSettingsFacebook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotAuthSettingsFacebook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotAuthSettingsFacebook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: str,
                 app_secret: Optional[str] = None,
                 app_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str app_id: The App ID of the Facebook app used for login.
        :param str app_secret: The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        :param str app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        if app_secret is not None:
            pulumi.set(__self__, "app_secret", app_secret)
        if app_secret_setting_name is not None:
            pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appSecret")
    def app_secret(self) -> Optional[str]:
        """
        The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        """
        return pulumi.get(self, "app_secret")

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class LinuxFunctionAppSlotAuthSettingsGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotAuthSettingsGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotAuthSettingsGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotAuthSettingsGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the GitHub app used for login.
        :param str client_secret: The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the GitHub app used for login.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class LinuxFunctionAppSlotAuthSettingsGoogle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotAuthSettingsGoogle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotAuthSettingsGoogle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotAuthSettingsGoogle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OpenID Connect Client ID for the Google web application.
        :param str client_secret: The client secret associated with the Google web application. Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OpenID Connect Client ID for the Google web application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The client secret associated with the Google web application. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class LinuxFunctionAppSlotAuthSettingsMicrosoft(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotAuthSettingsMicrosoft. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotAuthSettingsMicrosoft.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotAuthSettingsMicrosoft.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret: The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, `wl.basic` is used as the default scope.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, `wl.basic` is used as the default scope.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class LinuxFunctionAppSlotAuthSettingsTwitter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerKey":
            suggest = "consumer_key"
        elif key == "consumerSecret":
            suggest = "consumer_secret"
        elif key == "consumerSecretSettingName":
            suggest = "consumer_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotAuthSettingsTwitter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotAuthSettingsTwitter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotAuthSettingsTwitter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_key: str,
                 consumer_secret: Optional[str] = None,
                 consumer_secret_setting_name: Optional[str] = None):
        """
        :param str consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param str consumer_secret: The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        :param str consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        if consumer_secret is not None:
            pulumi.set(__self__, "consumer_secret", consumer_secret)
        if consumer_secret_setting_name is not None:
            pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> str:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> Optional[str]:
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        """
        return pulumi.get(self, "consumer_secret")

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        return pulumi.get(self, "consumer_secret_setting_name")


@pulumi.output_type
class LinuxFunctionAppSlotAuthSettingsV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeDirectoryV2":
            suggest = "active_directory_v2"
        elif key == "appleV2":
            suggest = "apple_v2"
        elif key == "authEnabled":
            suggest = "auth_enabled"
        elif key == "azureStaticWebAppV2":
            suggest = "azure_static_web_app_v2"
        elif key == "configFilePath":
            suggest = "config_file_path"
        elif key == "customOidcV2s":
            suggest = "custom_oidc_v2s"
        elif key == "defaultProvider":
            suggest = "default_provider"
        elif key == "excludedPaths":
            suggest = "excluded_paths"
        elif key == "facebookV2":
            suggest = "facebook_v2"
        elif key == "forwardProxyConvention":
            suggest = "forward_proxy_convention"
        elif key == "forwardProxyCustomHostHeaderName":
            suggest = "forward_proxy_custom_host_header_name"
        elif key == "forwardProxyCustomSchemeHeaderName":
            suggest = "forward_proxy_custom_scheme_header_name"
        elif key == "githubV2":
            suggest = "github_v2"
        elif key == "googleV2":
            suggest = "google_v2"
        elif key == "httpRouteApiPrefix":
            suggest = "http_route_api_prefix"
        elif key == "microsoftV2":
            suggest = "microsoft_v2"
        elif key == "requireAuthentication":
            suggest = "require_authentication"
        elif key == "requireHttps":
            suggest = "require_https"
        elif key == "runtimeVersion":
            suggest = "runtime_version"
        elif key == "twitterV2":
            suggest = "twitter_v2"
        elif key == "unauthenticatedAction":
            suggest = "unauthenticated_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotAuthSettingsV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotAuthSettingsV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotAuthSettingsV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 login: 'outputs.LinuxFunctionAppSlotAuthSettingsV2Login',
                 active_directory_v2: Optional['outputs.LinuxFunctionAppSlotAuthSettingsV2ActiveDirectoryV2'] = None,
                 apple_v2: Optional['outputs.LinuxFunctionAppSlotAuthSettingsV2AppleV2'] = None,
                 auth_enabled: Optional[bool] = None,
                 azure_static_web_app_v2: Optional['outputs.LinuxFunctionAppSlotAuthSettingsV2AzureStaticWebAppV2'] = None,
                 config_file_path: Optional[str] = None,
                 custom_oidc_v2s: Optional[Sequence['outputs.LinuxFunctionAppSlotAuthSettingsV2CustomOidcV2']] = None,
                 default_provider: Optional[str] = None,
                 excluded_paths: Optional[Sequence[str]] = None,
                 facebook_v2: Optional['outputs.LinuxFunctionAppSlotAuthSettingsV2FacebookV2'] = None,
                 forward_proxy_convention: Optional[str] = None,
                 forward_proxy_custom_host_header_name: Optional[str] = None,
                 forward_proxy_custom_scheme_header_name: Optional[str] = None,
                 github_v2: Optional['outputs.LinuxFunctionAppSlotAuthSettingsV2GithubV2'] = None,
                 google_v2: Optional['outputs.LinuxFunctionAppSlotAuthSettingsV2GoogleV2'] = None,
                 http_route_api_prefix: Optional[str] = None,
                 microsoft_v2: Optional['outputs.LinuxFunctionAppSlotAuthSettingsV2MicrosoftV2'] = None,
                 require_authentication: Optional[bool] = None,
                 require_https: Optional[bool] = None,
                 runtime_version: Optional[str] = None,
                 twitter_v2: Optional['outputs.LinuxFunctionAppSlotAuthSettingsV2TwitterV2'] = None,
                 unauthenticated_action: Optional[str] = None):
        """
        :param 'LinuxFunctionAppSlotAuthSettingsV2LoginArgs' login: A `login` block as defined below.
        :param 'LinuxFunctionAppSlotAuthSettingsV2ActiveDirectoryV2Args' active_directory_v2: An `active_directory_v2` block as defined below.
        :param 'LinuxFunctionAppSlotAuthSettingsV2AppleV2Args' apple_v2: An `apple_v2` block as defined below.
        :param bool auth_enabled: Should the AuthV2 Settings be enabled. Defaults to `false`.
        :param 'LinuxFunctionAppSlotAuthSettingsV2AzureStaticWebAppV2Args' azure_static_web_app_v2: An `azure_static_web_app_v2` block as defined below.
        :param str config_file_path: The path to the App Auth settings.
               
               * > **Note:** Relative Paths are evaluated from the Site Root directory.
        :param Sequence['LinuxFunctionAppSlotAuthSettingsV2CustomOidcV2Args'] custom_oidc_v2s: Zero or more `custom_oidc_v2` blocks as defined below.
        :param str default_provider: The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.
               
               > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        :param Sequence[str] excluded_paths: The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.
               
               > **NOTE:** This list should be used instead of setting `WEBSITE_WARMUP_PATH` in `app_settings` as it takes priority.
        :param 'LinuxFunctionAppSlotAuthSettingsV2FacebookV2Args' facebook_v2: A `facebook_v2` block as defined below.
        :param str forward_proxy_convention: The convention used to determine the url of the request made. Possible values include `NoProxy`, `Standard`, `Custom`. Defaults to `NoProxy`.
        :param str forward_proxy_custom_host_header_name: The name of the custom header containing the host of the request.
        :param str forward_proxy_custom_scheme_header_name: The name of the custom header containing the scheme of the request.
        :param 'LinuxFunctionAppSlotAuthSettingsV2GithubV2Args' github_v2: A `github_v2` block as defined below.
        :param 'LinuxFunctionAppSlotAuthSettingsV2GoogleV2Args' google_v2: A `google_v2` block as defined below.
        :param str http_route_api_prefix: The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
        :param 'LinuxFunctionAppSlotAuthSettingsV2MicrosoftV2Args' microsoft_v2: A `microsoft_v2` block as defined below.
        :param bool require_authentication: Should the authentication flow be used for all requests.
        :param bool require_https: Should HTTPS be required on connections? Defaults to `true`.
        :param str runtime_version: The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        :param 'LinuxFunctionAppSlotAuthSettingsV2TwitterV2Args' twitter_v2: A `twitter_v2` block as defined below.
        :param str unauthenticated_action: The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
        """
        pulumi.set(__self__, "login", login)
        if active_directory_v2 is not None:
            pulumi.set(__self__, "active_directory_v2", active_directory_v2)
        if apple_v2 is not None:
            pulumi.set(__self__, "apple_v2", apple_v2)
        if auth_enabled is not None:
            pulumi.set(__self__, "auth_enabled", auth_enabled)
        if azure_static_web_app_v2 is not None:
            pulumi.set(__self__, "azure_static_web_app_v2", azure_static_web_app_v2)
        if config_file_path is not None:
            pulumi.set(__self__, "config_file_path", config_file_path)
        if custom_oidc_v2s is not None:
            pulumi.set(__self__, "custom_oidc_v2s", custom_oidc_v2s)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if excluded_paths is not None:
            pulumi.set(__self__, "excluded_paths", excluded_paths)
        if facebook_v2 is not None:
            pulumi.set(__self__, "facebook_v2", facebook_v2)
        if forward_proxy_convention is not None:
            pulumi.set(__self__, "forward_proxy_convention", forward_proxy_convention)
        if forward_proxy_custom_host_header_name is not None:
            pulumi.set(__self__, "forward_proxy_custom_host_header_name", forward_proxy_custom_host_header_name)
        if forward_proxy_custom_scheme_header_name is not None:
            pulumi.set(__self__, "forward_proxy_custom_scheme_header_name", forward_proxy_custom_scheme_header_name)
        if github_v2 is not None:
            pulumi.set(__self__, "github_v2", github_v2)
        if google_v2 is not None:
            pulumi.set(__self__, "google_v2", google_v2)
        if http_route_api_prefix is not None:
            pulumi.set(__self__, "http_route_api_prefix", http_route_api_prefix)
        if microsoft_v2 is not None:
            pulumi.set(__self__, "microsoft_v2", microsoft_v2)
        if require_authentication is not None:
            pulumi.set(__self__, "require_authentication", require_authentication)
        if require_https is not None:
            pulumi.set(__self__, "require_https", require_https)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if twitter_v2 is not None:
            pulumi.set(__self__, "twitter_v2", twitter_v2)
        if unauthenticated_action is not None:
            pulumi.set(__self__, "unauthenticated_action", unauthenticated_action)

    @property
    @pulumi.getter
    def login(self) -> 'outputs.LinuxFunctionAppSlotAuthSettingsV2Login':
        """
        A `login` block as defined below.
        """
        return pulumi.get(self, "login")

    @property
    @pulumi.getter(name="activeDirectoryV2")
    def active_directory_v2(self) -> Optional['outputs.LinuxFunctionAppSlotAuthSettingsV2ActiveDirectoryV2']:
        """
        An `active_directory_v2` block as defined below.
        """
        return pulumi.get(self, "active_directory_v2")

    @property
    @pulumi.getter(name="appleV2")
    def apple_v2(self) -> Optional['outputs.LinuxFunctionAppSlotAuthSettingsV2AppleV2']:
        """
        An `apple_v2` block as defined below.
        """
        return pulumi.get(self, "apple_v2")

    @property
    @pulumi.getter(name="authEnabled")
    def auth_enabled(self) -> Optional[bool]:
        """
        Should the AuthV2 Settings be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "auth_enabled")

    @property
    @pulumi.getter(name="azureStaticWebAppV2")
    def azure_static_web_app_v2(self) -> Optional['outputs.LinuxFunctionAppSlotAuthSettingsV2AzureStaticWebAppV2']:
        """
        An `azure_static_web_app_v2` block as defined below.
        """
        return pulumi.get(self, "azure_static_web_app_v2")

    @property
    @pulumi.getter(name="configFilePath")
    def config_file_path(self) -> Optional[str]:
        """
        The path to the App Auth settings.

        * > **Note:** Relative Paths are evaluated from the Site Root directory.
        """
        return pulumi.get(self, "config_file_path")

    @property
    @pulumi.getter(name="customOidcV2s")
    def custom_oidc_v2s(self) -> Optional[Sequence['outputs.LinuxFunctionAppSlotAuthSettingsV2CustomOidcV2']]:
        """
        Zero or more `custom_oidc_v2` blocks as defined below.
        """
        return pulumi.get(self, "custom_oidc_v2s")

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[str]:
        """
        The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.

        > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        """
        return pulumi.get(self, "default_provider")

    @property
    @pulumi.getter(name="excludedPaths")
    def excluded_paths(self) -> Optional[Sequence[str]]:
        """
        The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.

        > **NOTE:** This list should be used instead of setting `WEBSITE_WARMUP_PATH` in `app_settings` as it takes priority.
        """
        return pulumi.get(self, "excluded_paths")

    @property
    @pulumi.getter(name="facebookV2")
    def facebook_v2(self) -> Optional['outputs.LinuxFunctionAppSlotAuthSettingsV2FacebookV2']:
        """
        A `facebook_v2` block as defined below.
        """
        return pulumi.get(self, "facebook_v2")

    @property
    @pulumi.getter(name="forwardProxyConvention")
    def forward_proxy_convention(self) -> Optional[str]:
        """
        The convention used to determine the url of the request made. Possible values include `NoProxy`, `Standard`, `Custom`. Defaults to `NoProxy`.
        """
        return pulumi.get(self, "forward_proxy_convention")

    @property
    @pulumi.getter(name="forwardProxyCustomHostHeaderName")
    def forward_proxy_custom_host_header_name(self) -> Optional[str]:
        """
        The name of the custom header containing the host of the request.
        """
        return pulumi.get(self, "forward_proxy_custom_host_header_name")

    @property
    @pulumi.getter(name="forwardProxyCustomSchemeHeaderName")
    def forward_proxy_custom_scheme_header_name(self) -> Optional[str]:
        """
        The name of the custom header containing the scheme of the request.
        """
        return pulumi.get(self, "forward_proxy_custom_scheme_header_name")

    @property
    @pulumi.getter(name="githubV2")
    def github_v2(self) -> Optional['outputs.LinuxFunctionAppSlotAuthSettingsV2GithubV2']:
        """
        A `github_v2` block as defined below.
        """
        return pulumi.get(self, "github_v2")

    @property
    @pulumi.getter(name="googleV2")
    def google_v2(self) -> Optional['outputs.LinuxFunctionAppSlotAuthSettingsV2GoogleV2']:
        """
        A `google_v2` block as defined below.
        """
        return pulumi.get(self, "google_v2")

    @property
    @pulumi.getter(name="httpRouteApiPrefix")
    def http_route_api_prefix(self) -> Optional[str]:
        """
        The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
        """
        return pulumi.get(self, "http_route_api_prefix")

    @property
    @pulumi.getter(name="microsoftV2")
    def microsoft_v2(self) -> Optional['outputs.LinuxFunctionAppSlotAuthSettingsV2MicrosoftV2']:
        """
        A `microsoft_v2` block as defined below.
        """
        return pulumi.get(self, "microsoft_v2")

    @property
    @pulumi.getter(name="requireAuthentication")
    def require_authentication(self) -> Optional[bool]:
        """
        Should the authentication flow be used for all requests.
        """
        return pulumi.get(self, "require_authentication")

    @property
    @pulumi.getter(name="requireHttps")
    def require_https(self) -> Optional[bool]:
        """
        Should HTTPS be required on connections? Defaults to `true`.
        """
        return pulumi.get(self, "require_https")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[str]:
        """
        The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter(name="twitterV2")
    def twitter_v2(self) -> Optional['outputs.LinuxFunctionAppSlotAuthSettingsV2TwitterV2']:
        """
        A `twitter_v2` block as defined below.
        """
        return pulumi.get(self, "twitter_v2")

    @property
    @pulumi.getter(name="unauthenticatedAction")
    def unauthenticated_action(self) -> Optional[str]:
        """
        The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
        """
        return pulumi.get(self, "unauthenticated_action")


@pulumi.output_type
class LinuxFunctionAppSlotAuthSettingsV2ActiveDirectoryV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "tenantAuthEndpoint":
            suggest = "tenant_auth_endpoint"
        elif key == "allowedApplications":
            suggest = "allowed_applications"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "allowedGroups":
            suggest = "allowed_groups"
        elif key == "allowedIdentities":
            suggest = "allowed_identities"
        elif key == "clientSecretCertificateThumbprint":
            suggest = "client_secret_certificate_thumbprint"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "jwtAllowedClientApplications":
            suggest = "jwt_allowed_client_applications"
        elif key == "jwtAllowedGroups":
            suggest = "jwt_allowed_groups"
        elif key == "loginParameters":
            suggest = "login_parameters"
        elif key == "wwwAuthenticationDisabled":
            suggest = "www_authentication_disabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotAuthSettingsV2ActiveDirectoryV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotAuthSettingsV2ActiveDirectoryV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotAuthSettingsV2ActiveDirectoryV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 tenant_auth_endpoint: str,
                 allowed_applications: Optional[Sequence[str]] = None,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 allowed_groups: Optional[Sequence[str]] = None,
                 allowed_identities: Optional[Sequence[str]] = None,
                 client_secret_certificate_thumbprint: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 jwt_allowed_client_applications: Optional[Sequence[str]] = None,
                 jwt_allowed_groups: Optional[Sequence[str]] = None,
                 login_parameters: Optional[Mapping[str, str]] = None,
                 www_authentication_disabled: Optional[bool] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str tenant_auth_endpoint: The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`
        :param Sequence[str] allowed_applications: The list of allowed Applications for the Default Authorisation Policy.
        :param Sequence[str] allowed_audiences: an `allowed_audiences` block as detailed below.
               
               > **Note:** The `client_id` value is always considered an allowed audience.
        :param Sequence[str] allowed_groups: The list of allowed Group Names for the Default Authorisation Policy.
        :param Sequence[str] allowed_identities: The list of allowed Identities for the Default Authorisation Policy.
        :param str client_secret_certificate_thumbprint: The thumbprint of the certificate used for signing purposes.
               
               > **NOTE:** One of `client_secret_setting_name` or `client_secret_certificate_thumbprint` must be specified.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param Sequence[str] jwt_allowed_client_applications: A list of Allowed Client Applications in the JWT Claim.
        :param Sequence[str] jwt_allowed_groups: A list of Allowed Groups in the JWT Claim.
        :param Mapping[str, str] login_parameters: A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
        :param bool www_authentication_disabled: Should the www-authenticate provider should be omitted from the request? Defaults to `false`
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "tenant_auth_endpoint", tenant_auth_endpoint)
        if allowed_applications is not None:
            pulumi.set(__self__, "allowed_applications", allowed_applications)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if allowed_groups is not None:
            pulumi.set(__self__, "allowed_groups", allowed_groups)
        if allowed_identities is not None:
            pulumi.set(__self__, "allowed_identities", allowed_identities)
        if client_secret_certificate_thumbprint is not None:
            pulumi.set(__self__, "client_secret_certificate_thumbprint", client_secret_certificate_thumbprint)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if jwt_allowed_client_applications is not None:
            pulumi.set(__self__, "jwt_allowed_client_applications", jwt_allowed_client_applications)
        if jwt_allowed_groups is not None:
            pulumi.set(__self__, "jwt_allowed_groups", jwt_allowed_groups)
        if login_parameters is not None:
            pulumi.set(__self__, "login_parameters", login_parameters)
        if www_authentication_disabled is not None:
            pulumi.set(__self__, "www_authentication_disabled", www_authentication_disabled)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="tenantAuthEndpoint")
    def tenant_auth_endpoint(self) -> str:
        """
        The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`
        """
        return pulumi.get(self, "tenant_auth_endpoint")

    @property
    @pulumi.getter(name="allowedApplications")
    def allowed_applications(self) -> Optional[Sequence[str]]:
        """
        The list of allowed Applications for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_applications")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        an `allowed_audiences` block as detailed below.

        > **Note:** The `client_id` value is always considered an allowed audience.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="allowedGroups")
    def allowed_groups(self) -> Optional[Sequence[str]]:
        """
        The list of allowed Group Names for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_groups")

    @property
    @pulumi.getter(name="allowedIdentities")
    def allowed_identities(self) -> Optional[Sequence[str]]:
        """
        The list of allowed Identities for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_identities")

    @property
    @pulumi.getter(name="clientSecretCertificateThumbprint")
    def client_secret_certificate_thumbprint(self) -> Optional[str]:
        """
        The thumbprint of the certificate used for signing purposes.

        > **NOTE:** One of `client_secret_setting_name` or `client_secret_certificate_thumbprint` must be specified.
        """
        return pulumi.get(self, "client_secret_certificate_thumbprint")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="jwtAllowedClientApplications")
    def jwt_allowed_client_applications(self) -> Optional[Sequence[str]]:
        """
        A list of Allowed Client Applications in the JWT Claim.
        """
        return pulumi.get(self, "jwt_allowed_client_applications")

    @property
    @pulumi.getter(name="jwtAllowedGroups")
    def jwt_allowed_groups(self) -> Optional[Sequence[str]]:
        """
        A list of Allowed Groups in the JWT Claim.
        """
        return pulumi.get(self, "jwt_allowed_groups")

    @property
    @pulumi.getter(name="loginParameters")
    def login_parameters(self) -> Optional[Mapping[str, str]]:
        """
        A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
        """
        return pulumi.get(self, "login_parameters")

    @property
    @pulumi.getter(name="wwwAuthenticationDisabled")
    def www_authentication_disabled(self) -> Optional[bool]:
        """
        Should the www-authenticate provider should be omitted from the request? Defaults to `false`
        """
        return pulumi.get(self, "www_authentication_disabled")


@pulumi.output_type
class LinuxFunctionAppSlotAuthSettingsV2AppleV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "loginScopes":
            suggest = "login_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotAuthSettingsV2AppleV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotAuthSettingsV2AppleV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotAuthSettingsV2AppleV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret_setting_name: str,
                 login_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param Sequence[str] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[Sequence[str]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class LinuxFunctionAppSlotAuthSettingsV2AzureStaticWebAppV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotAuthSettingsV2AzureStaticWebAppV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotAuthSettingsV2AzureStaticWebAppV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotAuthSettingsV2AzureStaticWebAppV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        """
        pulumi.set(__self__, "client_id", client_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")


@pulumi.output_type
class LinuxFunctionAppSlotAuthSettingsV2CustomOidcV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "openidConfigurationEndpoint":
            suggest = "openid_configuration_endpoint"
        elif key == "authorisationEndpoint":
            suggest = "authorisation_endpoint"
        elif key == "certificationUri":
            suggest = "certification_uri"
        elif key == "clientCredentialMethod":
            suggest = "client_credential_method"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "issuerEndpoint":
            suggest = "issuer_endpoint"
        elif key == "nameClaimType":
            suggest = "name_claim_type"
        elif key == "tokenEndpoint":
            suggest = "token_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotAuthSettingsV2CustomOidcV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotAuthSettingsV2CustomOidcV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotAuthSettingsV2CustomOidcV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 name: str,
                 openid_configuration_endpoint: str,
                 authorisation_endpoint: Optional[str] = None,
                 certification_uri: Optional[str] = None,
                 client_credential_method: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 issuer_endpoint: Optional[str] = None,
                 name_claim_type: Optional[str] = None,
                 scopes: Optional[Sequence[str]] = None,
                 token_endpoint: Optional[str] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str name: Specifies the name of the Function App Slot. Changing this forces a new resource to be created.
        :param str openid_configuration_endpoint: The app setting name that contains the `client_secret` value used for the Custom OIDC Login.
        :param str authorisation_endpoint: The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        :param str certification_uri: The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        :param str client_credential_method: The Client Credential Method used.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param str issuer_endpoint: The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        :param str name_claim_type: The name of the claim that contains the users name.
        :param Sequence[str] scopes: The list of the scopes that should be requested while authenticating.
        :param str token_endpoint: The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "openid_configuration_endpoint", openid_configuration_endpoint)
        if authorisation_endpoint is not None:
            pulumi.set(__self__, "authorisation_endpoint", authorisation_endpoint)
        if certification_uri is not None:
            pulumi.set(__self__, "certification_uri", certification_uri)
        if client_credential_method is not None:
            pulumi.set(__self__, "client_credential_method", client_credential_method)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if issuer_endpoint is not None:
            pulumi.set(__self__, "issuer_endpoint", issuer_endpoint)
        if name_claim_type is not None:
            pulumi.set(__self__, "name_claim_type", name_claim_type)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Function App Slot. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="openidConfigurationEndpoint")
    def openid_configuration_endpoint(self) -> str:
        """
        The app setting name that contains the `client_secret` value used for the Custom OIDC Login.
        """
        return pulumi.get(self, "openid_configuration_endpoint")

    @property
    @pulumi.getter(name="authorisationEndpoint")
    def authorisation_endpoint(self) -> Optional[str]:
        """
        The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "authorisation_endpoint")

    @property
    @pulumi.getter(name="certificationUri")
    def certification_uri(self) -> Optional[str]:
        """
        The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "certification_uri")

    @property
    @pulumi.getter(name="clientCredentialMethod")
    def client_credential_method(self) -> Optional[str]:
        """
        The Client Credential Method used.
        """
        return pulumi.get(self, "client_credential_method")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="issuerEndpoint")
    def issuer_endpoint(self) -> Optional[str]:
        """
        The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "issuer_endpoint")

    @property
    @pulumi.getter(name="nameClaimType")
    def name_claim_type(self) -> Optional[str]:
        """
        The name of the claim that contains the users name.
        """
        return pulumi.get(self, "name_claim_type")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[str]]:
        """
        The list of the scopes that should be requested while authenticating.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[str]:
        """
        The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "token_endpoint")


@pulumi.output_type
class LinuxFunctionAppSlotAuthSettingsV2FacebookV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "appSecretSettingName":
            suggest = "app_secret_setting_name"
        elif key == "graphApiVersion":
            suggest = "graph_api_version"
        elif key == "loginScopes":
            suggest = "login_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotAuthSettingsV2FacebookV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotAuthSettingsV2FacebookV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotAuthSettingsV2FacebookV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: str,
                 app_secret_setting_name: str,
                 graph_api_version: Optional[str] = None,
                 login_scopes: Optional[Sequence[str]] = None):
        """
        :param str app_id: The App ID of the Facebook app used for login.
        :param str app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook Login.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param str graph_api_version: The version of the Facebook API to be used while logging in.
        :param Sequence[str] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        if graph_api_version is not None:
            pulumi.set(__self__, "graph_api_version", graph_api_version)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> str:
        """
        The app setting name that contains the `app_secret` value used for Facebook Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @property
    @pulumi.getter(name="graphApiVersion")
    def graph_api_version(self) -> Optional[str]:
        """
        The version of the Facebook API to be used while logging in.
        """
        return pulumi.get(self, "graph_api_version")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[Sequence[str]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class LinuxFunctionAppSlotAuthSettingsV2GithubV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "loginScopes":
            suggest = "login_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotAuthSettingsV2GithubV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotAuthSettingsV2GithubV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotAuthSettingsV2GithubV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret_setting_name: str,
                 login_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param Sequence[str] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[Sequence[str]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class LinuxFunctionAppSlotAuthSettingsV2GoogleV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "loginScopes":
            suggest = "login_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotAuthSettingsV2GoogleV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotAuthSettingsV2GoogleV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotAuthSettingsV2GoogleV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret_setting_name: str,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 login_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param Sequence[str] allowed_audiences: an `allowed_audiences` block as detailed below.
               
               > **Note:** The `client_id` value is always considered an allowed audience.
        :param Sequence[str] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        an `allowed_audiences` block as detailed below.

        > **Note:** The `client_id` value is always considered an allowed audience.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[Sequence[str]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class LinuxFunctionAppSlotAuthSettingsV2Login(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedExternalRedirectUrls":
            suggest = "allowed_external_redirect_urls"
        elif key == "cookieExpirationConvention":
            suggest = "cookie_expiration_convention"
        elif key == "cookieExpirationTime":
            suggest = "cookie_expiration_time"
        elif key == "logoutEndpoint":
            suggest = "logout_endpoint"
        elif key == "nonceExpirationTime":
            suggest = "nonce_expiration_time"
        elif key == "preserveUrlFragmentsForLogins":
            suggest = "preserve_url_fragments_for_logins"
        elif key == "tokenRefreshExtensionTime":
            suggest = "token_refresh_extension_time"
        elif key == "tokenStoreEnabled":
            suggest = "token_store_enabled"
        elif key == "tokenStorePath":
            suggest = "token_store_path"
        elif key == "tokenStoreSasSettingName":
            suggest = "token_store_sas_setting_name"
        elif key == "validateNonce":
            suggest = "validate_nonce"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotAuthSettingsV2Login. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotAuthSettingsV2Login.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotAuthSettingsV2Login.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_external_redirect_urls: Optional[Sequence[str]] = None,
                 cookie_expiration_convention: Optional[str] = None,
                 cookie_expiration_time: Optional[str] = None,
                 logout_endpoint: Optional[str] = None,
                 nonce_expiration_time: Optional[str] = None,
                 preserve_url_fragments_for_logins: Optional[bool] = None,
                 token_refresh_extension_time: Optional[float] = None,
                 token_store_enabled: Optional[bool] = None,
                 token_store_path: Optional[str] = None,
                 token_store_sas_setting_name: Optional[str] = None,
                 validate_nonce: Optional[bool] = None):
        """
        :param Sequence[str] allowed_external_redirect_urls: External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends.
               
               > **Note:** URLs within the current domain are always implicitly allowed.
        :param str cookie_expiration_convention: The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
        :param str cookie_expiration_time: The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
        :param str logout_endpoint: The endpoint to which logout requests should be made.
        :param str nonce_expiration_time: The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
        :param bool preserve_url_fragments_for_logins: Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
        :param float token_refresh_extension_time: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        :param bool token_store_enabled: Should the Token Store configuration Enabled. Defaults to `false`
        :param str token_store_path: The directory path in the App Filesystem in which the tokens will be stored.
        :param str token_store_sas_setting_name: The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        :param bool validate_nonce: Should the nonce be validated while completing the login flow. Defaults to `true`.
        """
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if cookie_expiration_convention is not None:
            pulumi.set(__self__, "cookie_expiration_convention", cookie_expiration_convention)
        if cookie_expiration_time is not None:
            pulumi.set(__self__, "cookie_expiration_time", cookie_expiration_time)
        if logout_endpoint is not None:
            pulumi.set(__self__, "logout_endpoint", logout_endpoint)
        if nonce_expiration_time is not None:
            pulumi.set(__self__, "nonce_expiration_time", nonce_expiration_time)
        if preserve_url_fragments_for_logins is not None:
            pulumi.set(__self__, "preserve_url_fragments_for_logins", preserve_url_fragments_for_logins)
        if token_refresh_extension_time is not None:
            pulumi.set(__self__, "token_refresh_extension_time", token_refresh_extension_time)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if token_store_path is not None:
            pulumi.set(__self__, "token_store_path", token_store_path)
        if token_store_sas_setting_name is not None:
            pulumi.set(__self__, "token_store_sas_setting_name", token_store_sas_setting_name)
        if validate_nonce is not None:
            pulumi.set(__self__, "validate_nonce", validate_nonce)

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[Sequence[str]]:
        """
        External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends.

        > **Note:** URLs within the current domain are always implicitly allowed.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @property
    @pulumi.getter(name="cookieExpirationConvention")
    def cookie_expiration_convention(self) -> Optional[str]:
        """
        The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
        """
        return pulumi.get(self, "cookie_expiration_convention")

    @property
    @pulumi.getter(name="cookieExpirationTime")
    def cookie_expiration_time(self) -> Optional[str]:
        """
        The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
        """
        return pulumi.get(self, "cookie_expiration_time")

    @property
    @pulumi.getter(name="logoutEndpoint")
    def logout_endpoint(self) -> Optional[str]:
        """
        The endpoint to which logout requests should be made.
        """
        return pulumi.get(self, "logout_endpoint")

    @property
    @pulumi.getter(name="nonceExpirationTime")
    def nonce_expiration_time(self) -> Optional[str]:
        """
        The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
        """
        return pulumi.get(self, "nonce_expiration_time")

    @property
    @pulumi.getter(name="preserveUrlFragmentsForLogins")
    def preserve_url_fragments_for_logins(self) -> Optional[bool]:
        """
        Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
        """
        return pulumi.get(self, "preserve_url_fragments_for_logins")

    @property
    @pulumi.getter(name="tokenRefreshExtensionTime")
    def token_refresh_extension_time(self) -> Optional[float]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        return pulumi.get(self, "token_refresh_extension_time")

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[bool]:
        """
        Should the Token Store configuration Enabled. Defaults to `false`
        """
        return pulumi.get(self, "token_store_enabled")

    @property
    @pulumi.getter(name="tokenStorePath")
    def token_store_path(self) -> Optional[str]:
        """
        The directory path in the App Filesystem in which the tokens will be stored.
        """
        return pulumi.get(self, "token_store_path")

    @property
    @pulumi.getter(name="tokenStoreSasSettingName")
    def token_store_sas_setting_name(self) -> Optional[str]:
        """
        The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        """
        return pulumi.get(self, "token_store_sas_setting_name")

    @property
    @pulumi.getter(name="validateNonce")
    def validate_nonce(self) -> Optional[bool]:
        """
        Should the nonce be validated while completing the login flow. Defaults to `true`.
        """
        return pulumi.get(self, "validate_nonce")


@pulumi.output_type
class LinuxFunctionAppSlotAuthSettingsV2MicrosoftV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "loginScopes":
            suggest = "login_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotAuthSettingsV2MicrosoftV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotAuthSettingsV2MicrosoftV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotAuthSettingsV2MicrosoftV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret_setting_name: str,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 login_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param Sequence[str] allowed_audiences: an `allowed_audiences` block as detailed below.
               
               > **Note:** The `client_id` value is always considered an allowed audience.
        :param Sequence[str] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        an `allowed_audiences` block as detailed below.

        > **Note:** The `client_id` value is always considered an allowed audience.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[Sequence[str]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class LinuxFunctionAppSlotAuthSettingsV2TwitterV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerKey":
            suggest = "consumer_key"
        elif key == "consumerSecretSettingName":
            suggest = "consumer_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotAuthSettingsV2TwitterV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotAuthSettingsV2TwitterV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotAuthSettingsV2TwitterV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_key: str,
                 consumer_secret_setting_name: str):
        """
        :param str consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param str consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> str:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> str:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "consumer_secret_setting_name")


@pulumi.output_type
class LinuxFunctionAppSlotBackup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageAccountUrl":
            suggest = "storage_account_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotBackup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotBackup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotBackup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 schedule: 'outputs.LinuxFunctionAppSlotBackupSchedule',
                 storage_account_url: str,
                 enabled: Optional[bool] = None):
        """
        :param str name: The name which should be used for this Backup.
        :param 'LinuxFunctionAppSlotBackupScheduleArgs' schedule: a `schedule` block as detailed below.
        :param str storage_account_url: The SAS URL to the container.
        :param bool enabled: Should this backup job be enabled? Defaults to `true`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "storage_account_url", storage_account_url)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Backup.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def schedule(self) -> 'outputs.LinuxFunctionAppSlotBackupSchedule':
        """
        a `schedule` block as detailed below.
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter(name="storageAccountUrl")
    def storage_account_url(self) -> str:
        """
        The SAS URL to the container.
        """
        return pulumi.get(self, "storage_account_url")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Should this backup job be enabled? Defaults to `true`.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class LinuxFunctionAppSlotBackupSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "frequencyUnit":
            suggest = "frequency_unit"
        elif key == "keepAtLeastOneBackup":
            suggest = "keep_at_least_one_backup"
        elif key == "lastExecutionTime":
            suggest = "last_execution_time"
        elif key == "retentionPeriodDays":
            suggest = "retention_period_days"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotBackupSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotBackupSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotBackupSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_unit: str,
                 keep_at_least_one_backup: Optional[bool] = None,
                 last_execution_time: Optional[str] = None,
                 retention_period_days: Optional[int] = None,
                 start_time: Optional[str] = None):
        """
        :param int frequency_interval: How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).
               
               > **NOTE:** Not all intervals are supported on all Linux Function App SKUs. Please refer to the official documentation for appropriate values.
        :param str frequency_unit: The unit of time for how often the backup should take place. Possible values include: `Day` and `Hour`.
        :param bool keep_at_least_one_backup: Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
        :param str last_execution_time: The time the backup was last attempted.
        :param int retention_period_days: After how many days backups should be deleted. Defaults to `30`.
        :param str start_time: When the schedule should start working in RFC-3339 format.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_unit", frequency_unit)
        if keep_at_least_one_backup is not None:
            pulumi.set(__self__, "keep_at_least_one_backup", keep_at_least_one_backup)
        if last_execution_time is not None:
            pulumi.set(__self__, "last_execution_time", last_execution_time)
        if retention_period_days is not None:
            pulumi.set(__self__, "retention_period_days", retention_period_days)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).

        > **NOTE:** Not all intervals are supported on all Linux Function App SKUs. Please refer to the official documentation for appropriate values.
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyUnit")
    def frequency_unit(self) -> str:
        """
        The unit of time for how often the backup should take place. Possible values include: `Day` and `Hour`.
        """
        return pulumi.get(self, "frequency_unit")

    @property
    @pulumi.getter(name="keepAtLeastOneBackup")
    def keep_at_least_one_backup(self) -> Optional[bool]:
        """
        Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
        """
        return pulumi.get(self, "keep_at_least_one_backup")

    @property
    @pulumi.getter(name="lastExecutionTime")
    def last_execution_time(self) -> Optional[str]:
        """
        The time the backup was last attempted.
        """
        return pulumi.get(self, "last_execution_time")

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> Optional[int]:
        """
        After how many days backups should be deleted. Defaults to `30`.
        """
        return pulumi.get(self, "retention_period_days")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        """
        When the schedule should start working in RFC-3339 format.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class LinuxFunctionAppSlotConnectionString(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: The name which should be used for this Connection.
        :param str type: Type of database. Possible values include: `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
        :param str value: The connection string value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Connection.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of database. Possible values include: `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The connection string value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class LinuxFunctionAppSlotIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 identity_ids: Optional[Sequence[str]] = None,
                 principal_id: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str type: Specifies the type of Managed Service Identity that should be configured on this Linux Function App Slot. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        :param Sequence[str] identity_ids: A list of User Assigned Managed Identity IDs to be assigned to this Linux Function App Slot.
               
               > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        :param str principal_id: The Principal ID associated with this Managed Service Identity.
        :param str tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the type of Managed Service Identity that should be configured on this Linux Function App Slot. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[str]]:
        """
        A list of User Assigned Managed Identity IDs to be assigned to this Linux Function App Slot.

        > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class LinuxFunctionAppSlotSiteConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alwaysOn":
            suggest = "always_on"
        elif key == "apiDefinitionUrl":
            suggest = "api_definition_url"
        elif key == "apiManagementApiId":
            suggest = "api_management_api_id"
        elif key == "appCommandLine":
            suggest = "app_command_line"
        elif key == "appScaleLimit":
            suggest = "app_scale_limit"
        elif key == "appServiceLogs":
            suggest = "app_service_logs"
        elif key == "applicationInsightsConnectionString":
            suggest = "application_insights_connection_string"
        elif key == "applicationInsightsKey":
            suggest = "application_insights_key"
        elif key == "applicationStack":
            suggest = "application_stack"
        elif key == "autoSwapSlotName":
            suggest = "auto_swap_slot_name"
        elif key == "containerRegistryManagedIdentityClientId":
            suggest = "container_registry_managed_identity_client_id"
        elif key == "containerRegistryUseManagedIdentity":
            suggest = "container_registry_use_managed_identity"
        elif key == "defaultDocuments":
            suggest = "default_documents"
        elif key == "detailedErrorLoggingEnabled":
            suggest = "detailed_error_logging_enabled"
        elif key == "elasticInstanceMinimum":
            suggest = "elastic_instance_minimum"
        elif key == "ftpsState":
            suggest = "ftps_state"
        elif key == "healthCheckEvictionTimeInMin":
            suggest = "health_check_eviction_time_in_min"
        elif key == "healthCheckPath":
            suggest = "health_check_path"
        elif key == "http2Enabled":
            suggest = "http2_enabled"
        elif key == "ipRestrictions":
            suggest = "ip_restrictions"
        elif key == "linuxFxVersion":
            suggest = "linux_fx_version"
        elif key == "loadBalancingMode":
            suggest = "load_balancing_mode"
        elif key == "managedPipelineMode":
            suggest = "managed_pipeline_mode"
        elif key == "minimumTlsVersion":
            suggest = "minimum_tls_version"
        elif key == "preWarmedInstanceCount":
            suggest = "pre_warmed_instance_count"
        elif key == "remoteDebuggingEnabled":
            suggest = "remote_debugging_enabled"
        elif key == "remoteDebuggingVersion":
            suggest = "remote_debugging_version"
        elif key == "runtimeScaleMonitoringEnabled":
            suggest = "runtime_scale_monitoring_enabled"
        elif key == "scmIpRestrictions":
            suggest = "scm_ip_restrictions"
        elif key == "scmMinimumTlsVersion":
            suggest = "scm_minimum_tls_version"
        elif key == "scmType":
            suggest = "scm_type"
        elif key == "scmUseMainIpRestriction":
            suggest = "scm_use_main_ip_restriction"
        elif key == "use32BitWorker":
            suggest = "use32_bit_worker"
        elif key == "vnetRouteAllEnabled":
            suggest = "vnet_route_all_enabled"
        elif key == "websocketsEnabled":
            suggest = "websockets_enabled"
        elif key == "workerCount":
            suggest = "worker_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotSiteConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotSiteConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotSiteConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 always_on: Optional[bool] = None,
                 api_definition_url: Optional[str] = None,
                 api_management_api_id: Optional[str] = None,
                 app_command_line: Optional[str] = None,
                 app_scale_limit: Optional[int] = None,
                 app_service_logs: Optional['outputs.LinuxFunctionAppSlotSiteConfigAppServiceLogs'] = None,
                 application_insights_connection_string: Optional[str] = None,
                 application_insights_key: Optional[str] = None,
                 application_stack: Optional['outputs.LinuxFunctionAppSlotSiteConfigApplicationStack'] = None,
                 auto_swap_slot_name: Optional[str] = None,
                 container_registry_managed_identity_client_id: Optional[str] = None,
                 container_registry_use_managed_identity: Optional[bool] = None,
                 cors: Optional['outputs.LinuxFunctionAppSlotSiteConfigCors'] = None,
                 default_documents: Optional[Sequence[str]] = None,
                 detailed_error_logging_enabled: Optional[bool] = None,
                 elastic_instance_minimum: Optional[int] = None,
                 ftps_state: Optional[str] = None,
                 health_check_eviction_time_in_min: Optional[int] = None,
                 health_check_path: Optional[str] = None,
                 http2_enabled: Optional[bool] = None,
                 ip_restrictions: Optional[Sequence['outputs.LinuxFunctionAppSlotSiteConfigIpRestriction']] = None,
                 linux_fx_version: Optional[str] = None,
                 load_balancing_mode: Optional[str] = None,
                 managed_pipeline_mode: Optional[str] = None,
                 minimum_tls_version: Optional[str] = None,
                 pre_warmed_instance_count: Optional[int] = None,
                 remote_debugging_enabled: Optional[bool] = None,
                 remote_debugging_version: Optional[str] = None,
                 runtime_scale_monitoring_enabled: Optional[bool] = None,
                 scm_ip_restrictions: Optional[Sequence['outputs.LinuxFunctionAppSlotSiteConfigScmIpRestriction']] = None,
                 scm_minimum_tls_version: Optional[str] = None,
                 scm_type: Optional[str] = None,
                 scm_use_main_ip_restriction: Optional[bool] = None,
                 use32_bit_worker: Optional[bool] = None,
                 vnet_route_all_enabled: Optional[bool] = None,
                 websockets_enabled: Optional[bool] = None,
                 worker_count: Optional[int] = None):
        """
        :param bool always_on: If this Linux Web App is Always On enabled. Defaults to `false`.
        :param str api_definition_url: The URL of the API definition that describes this Linux Function App.
        :param str api_management_api_id: The ID of the API Management API for this Linux Function App.
        :param str app_command_line: The program and any arguments used to launch this app via the command line. (Example `node myapp.js`).
        :param int app_scale_limit: The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
        :param 'LinuxFunctionAppSlotSiteConfigAppServiceLogsArgs' app_service_logs: an `app_service_logs` block as detailed below.
        :param str application_insights_connection_string: The Connection String for linking the Linux Function App to Application Insights.
        :param str application_insights_key: The Instrumentation Key for connecting the Linux Function App to Application Insights.
        :param 'LinuxFunctionAppSlotSiteConfigApplicationStackArgs' application_stack: an `application_stack` block as detailed below.
        :param str auto_swap_slot_name: The name of the slot to automatically swap with when this slot is successfully deployed.
        :param str container_registry_managed_identity_client_id: The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
        :param bool container_registry_use_managed_identity: Should connections for Azure Container Registry use Managed Identity.
        :param 'LinuxFunctionAppSlotSiteConfigCorsArgs' cors: a `cors` block as detailed below.
        :param Sequence[str] default_documents: a `default_documents` block as detailed below.
        :param bool detailed_error_logging_enabled: Is detailed error logging enabled
        :param int elastic_instance_minimum: The number of minimum instances for this Linux Function App. Only affects apps on Elastic Premium plans.
        :param str ftps_state: State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`. Defaults to `Disabled`.
        :param int health_check_eviction_time_in_min: The amount of time in minutes that a node is unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Defaults to `10`. Only valid in conjunction with `health_check_path`
        :param str health_check_path: The path to be checked for this function app health.
        :param bool http2_enabled: Specifies if the HTTP2 protocol should be enabled. Defaults to `false`.
        :param Sequence['LinuxFunctionAppSlotSiteConfigIpRestrictionArgs'] ip_restrictions: an `ip_restriction` block as detailed below.
        :param str linux_fx_version: The Linux FX Version
        :param str load_balancing_mode: The Site load balancing mode. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        :param str managed_pipeline_mode: The Managed Pipeline mode. Possible values include: `Integrated`, `Classic`. Defaults to `Integrated`.
        :param str minimum_tls_version: The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        :param int pre_warmed_instance_count: The number of pre-warmed instances for this function app. Only affects apps on an Elastic Premium plan.
        :param bool remote_debugging_enabled: Should Remote Debugging be enabled. Defaults to `false`.
        :param str remote_debugging_version: The Remote Debugging Version. Possible values include `VS2017`, `VS2019`, and `VS2022`
        :param bool runtime_scale_monitoring_enabled: Should Functions Runtime Scale Monitoring be enabled.
               
               > **NOTE:** Functions runtime scale monitoring can only be enabled for Elastic Premium Function Apps or Workflow Standard Logic Apps and requires a minimum prewarmed instance count of 1.
        :param Sequence['LinuxFunctionAppSlotSiteConfigScmIpRestrictionArgs'] scm_ip_restrictions: a `scm_ip_restriction` block as detailed below.
        :param str scm_minimum_tls_version: Configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        :param str scm_type: The SCM Type in use by the Linux Function App.
        :param bool scm_use_main_ip_restriction: Should the Linux Function App `ip_restriction` configuration be used for the SCM also.
        :param bool use32_bit_worker: Should the Linux Web App use a 32-bit worker.
        :param bool vnet_route_all_enabled: Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        :param bool websockets_enabled: Should Web Sockets be enabled. Defaults to `false`.
        :param int worker_count: The number of Workers for this Linux Function App.
        """
        if always_on is not None:
            pulumi.set(__self__, "always_on", always_on)
        if api_definition_url is not None:
            pulumi.set(__self__, "api_definition_url", api_definition_url)
        if api_management_api_id is not None:
            pulumi.set(__self__, "api_management_api_id", api_management_api_id)
        if app_command_line is not None:
            pulumi.set(__self__, "app_command_line", app_command_line)
        if app_scale_limit is not None:
            pulumi.set(__self__, "app_scale_limit", app_scale_limit)
        if app_service_logs is not None:
            pulumi.set(__self__, "app_service_logs", app_service_logs)
        if application_insights_connection_string is not None:
            pulumi.set(__self__, "application_insights_connection_string", application_insights_connection_string)
        if application_insights_key is not None:
            pulumi.set(__self__, "application_insights_key", application_insights_key)
        if application_stack is not None:
            pulumi.set(__self__, "application_stack", application_stack)
        if auto_swap_slot_name is not None:
            pulumi.set(__self__, "auto_swap_slot_name", auto_swap_slot_name)
        if container_registry_managed_identity_client_id is not None:
            pulumi.set(__self__, "container_registry_managed_identity_client_id", container_registry_managed_identity_client_id)
        if container_registry_use_managed_identity is not None:
            pulumi.set(__self__, "container_registry_use_managed_identity", container_registry_use_managed_identity)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if default_documents is not None:
            pulumi.set(__self__, "default_documents", default_documents)
        if detailed_error_logging_enabled is not None:
            pulumi.set(__self__, "detailed_error_logging_enabled", detailed_error_logging_enabled)
        if elastic_instance_minimum is not None:
            pulumi.set(__self__, "elastic_instance_minimum", elastic_instance_minimum)
        if ftps_state is not None:
            pulumi.set(__self__, "ftps_state", ftps_state)
        if health_check_eviction_time_in_min is not None:
            pulumi.set(__self__, "health_check_eviction_time_in_min", health_check_eviction_time_in_min)
        if health_check_path is not None:
            pulumi.set(__self__, "health_check_path", health_check_path)
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if ip_restrictions is not None:
            pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        if linux_fx_version is not None:
            pulumi.set(__self__, "linux_fx_version", linux_fx_version)
        if load_balancing_mode is not None:
            pulumi.set(__self__, "load_balancing_mode", load_balancing_mode)
        if managed_pipeline_mode is not None:
            pulumi.set(__self__, "managed_pipeline_mode", managed_pipeline_mode)
        if minimum_tls_version is not None:
            pulumi.set(__self__, "minimum_tls_version", minimum_tls_version)
        if pre_warmed_instance_count is not None:
            pulumi.set(__self__, "pre_warmed_instance_count", pre_warmed_instance_count)
        if remote_debugging_enabled is not None:
            pulumi.set(__self__, "remote_debugging_enabled", remote_debugging_enabled)
        if remote_debugging_version is not None:
            pulumi.set(__self__, "remote_debugging_version", remote_debugging_version)
        if runtime_scale_monitoring_enabled is not None:
            pulumi.set(__self__, "runtime_scale_monitoring_enabled", runtime_scale_monitoring_enabled)
        if scm_ip_restrictions is not None:
            pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        if scm_minimum_tls_version is not None:
            pulumi.set(__self__, "scm_minimum_tls_version", scm_minimum_tls_version)
        if scm_type is not None:
            pulumi.set(__self__, "scm_type", scm_type)
        if scm_use_main_ip_restriction is not None:
            pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        if use32_bit_worker is not None:
            pulumi.set(__self__, "use32_bit_worker", use32_bit_worker)
        if vnet_route_all_enabled is not None:
            pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        if websockets_enabled is not None:
            pulumi.set(__self__, "websockets_enabled", websockets_enabled)
        if worker_count is not None:
            pulumi.set(__self__, "worker_count", worker_count)

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> Optional[bool]:
        """
        If this Linux Web App is Always On enabled. Defaults to `false`.
        """
        return pulumi.get(self, "always_on")

    @property
    @pulumi.getter(name="apiDefinitionUrl")
    def api_definition_url(self) -> Optional[str]:
        """
        The URL of the API definition that describes this Linux Function App.
        """
        return pulumi.get(self, "api_definition_url")

    @property
    @pulumi.getter(name="apiManagementApiId")
    def api_management_api_id(self) -> Optional[str]:
        """
        The ID of the API Management API for this Linux Function App.
        """
        return pulumi.get(self, "api_management_api_id")

    @property
    @pulumi.getter(name="appCommandLine")
    def app_command_line(self) -> Optional[str]:
        """
        The program and any arguments used to launch this app via the command line. (Example `node myapp.js`).
        """
        return pulumi.get(self, "app_command_line")

    @property
    @pulumi.getter(name="appScaleLimit")
    def app_scale_limit(self) -> Optional[int]:
        """
        The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
        """
        return pulumi.get(self, "app_scale_limit")

    @property
    @pulumi.getter(name="appServiceLogs")
    def app_service_logs(self) -> Optional['outputs.LinuxFunctionAppSlotSiteConfigAppServiceLogs']:
        """
        an `app_service_logs` block as detailed below.
        """
        return pulumi.get(self, "app_service_logs")

    @property
    @pulumi.getter(name="applicationInsightsConnectionString")
    def application_insights_connection_string(self) -> Optional[str]:
        """
        The Connection String for linking the Linux Function App to Application Insights.
        """
        return pulumi.get(self, "application_insights_connection_string")

    @property
    @pulumi.getter(name="applicationInsightsKey")
    def application_insights_key(self) -> Optional[str]:
        """
        The Instrumentation Key for connecting the Linux Function App to Application Insights.
        """
        return pulumi.get(self, "application_insights_key")

    @property
    @pulumi.getter(name="applicationStack")
    def application_stack(self) -> Optional['outputs.LinuxFunctionAppSlotSiteConfigApplicationStack']:
        """
        an `application_stack` block as detailed below.
        """
        return pulumi.get(self, "application_stack")

    @property
    @pulumi.getter(name="autoSwapSlotName")
    def auto_swap_slot_name(self) -> Optional[str]:
        """
        The name of the slot to automatically swap with when this slot is successfully deployed.
        """
        return pulumi.get(self, "auto_swap_slot_name")

    @property
    @pulumi.getter(name="containerRegistryManagedIdentityClientId")
    def container_registry_managed_identity_client_id(self) -> Optional[str]:
        """
        The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
        """
        return pulumi.get(self, "container_registry_managed_identity_client_id")

    @property
    @pulumi.getter(name="containerRegistryUseManagedIdentity")
    def container_registry_use_managed_identity(self) -> Optional[bool]:
        """
        Should connections for Azure Container Registry use Managed Identity.
        """
        return pulumi.get(self, "container_registry_use_managed_identity")

    @property
    @pulumi.getter
    def cors(self) -> Optional['outputs.LinuxFunctionAppSlotSiteConfigCors']:
        """
        a `cors` block as detailed below.
        """
        return pulumi.get(self, "cors")

    @property
    @pulumi.getter(name="defaultDocuments")
    def default_documents(self) -> Optional[Sequence[str]]:
        """
        a `default_documents` block as detailed below.
        """
        return pulumi.get(self, "default_documents")

    @property
    @pulumi.getter(name="detailedErrorLoggingEnabled")
    def detailed_error_logging_enabled(self) -> Optional[bool]:
        """
        Is detailed error logging enabled
        """
        return pulumi.get(self, "detailed_error_logging_enabled")

    @property
    @pulumi.getter(name="elasticInstanceMinimum")
    def elastic_instance_minimum(self) -> Optional[int]:
        """
        The number of minimum instances for this Linux Function App. Only affects apps on Elastic Premium plans.
        """
        return pulumi.get(self, "elastic_instance_minimum")

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> Optional[str]:
        """
        State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`. Defaults to `Disabled`.
        """
        return pulumi.get(self, "ftps_state")

    @property
    @pulumi.getter(name="healthCheckEvictionTimeInMin")
    def health_check_eviction_time_in_min(self) -> Optional[int]:
        """
        The amount of time in minutes that a node is unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Defaults to `10`. Only valid in conjunction with `health_check_path`
        """
        return pulumi.get(self, "health_check_eviction_time_in_min")

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> Optional[str]:
        """
        The path to be checked for this function app health.
        """
        return pulumi.get(self, "health_check_path")

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[bool]:
        """
        Specifies if the HTTP2 protocol should be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "http2_enabled")

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Optional[Sequence['outputs.LinuxFunctionAppSlotSiteConfigIpRestriction']]:
        """
        an `ip_restriction` block as detailed below.
        """
        return pulumi.get(self, "ip_restrictions")

    @property
    @pulumi.getter(name="linuxFxVersion")
    def linux_fx_version(self) -> Optional[str]:
        """
        The Linux FX Version
        """
        return pulumi.get(self, "linux_fx_version")

    @property
    @pulumi.getter(name="loadBalancingMode")
    def load_balancing_mode(self) -> Optional[str]:
        """
        The Site load balancing mode. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        """
        return pulumi.get(self, "load_balancing_mode")

    @property
    @pulumi.getter(name="managedPipelineMode")
    def managed_pipeline_mode(self) -> Optional[str]:
        """
        The Managed Pipeline mode. Possible values include: `Integrated`, `Classic`. Defaults to `Integrated`.
        """
        return pulumi.get(self, "managed_pipeline_mode")

    @property
    @pulumi.getter(name="minimumTlsVersion")
    def minimum_tls_version(self) -> Optional[str]:
        """
        The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        """
        return pulumi.get(self, "minimum_tls_version")

    @property
    @pulumi.getter(name="preWarmedInstanceCount")
    def pre_warmed_instance_count(self) -> Optional[int]:
        """
        The number of pre-warmed instances for this function app. Only affects apps on an Elastic Premium plan.
        """
        return pulumi.get(self, "pre_warmed_instance_count")

    @property
    @pulumi.getter(name="remoteDebuggingEnabled")
    def remote_debugging_enabled(self) -> Optional[bool]:
        """
        Should Remote Debugging be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "remote_debugging_enabled")

    @property
    @pulumi.getter(name="remoteDebuggingVersion")
    def remote_debugging_version(self) -> Optional[str]:
        """
        The Remote Debugging Version. Possible values include `VS2017`, `VS2019`, and `VS2022`
        """
        return pulumi.get(self, "remote_debugging_version")

    @property
    @pulumi.getter(name="runtimeScaleMonitoringEnabled")
    def runtime_scale_monitoring_enabled(self) -> Optional[bool]:
        """
        Should Functions Runtime Scale Monitoring be enabled.

        > **NOTE:** Functions runtime scale monitoring can only be enabled for Elastic Premium Function Apps or Workflow Standard Logic Apps and requires a minimum prewarmed instance count of 1.
        """
        return pulumi.get(self, "runtime_scale_monitoring_enabled")

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Optional[Sequence['outputs.LinuxFunctionAppSlotSiteConfigScmIpRestriction']]:
        """
        a `scm_ip_restriction` block as detailed below.
        """
        return pulumi.get(self, "scm_ip_restrictions")

    @property
    @pulumi.getter(name="scmMinimumTlsVersion")
    def scm_minimum_tls_version(self) -> Optional[str]:
        """
        Configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        """
        return pulumi.get(self, "scm_minimum_tls_version")

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> Optional[str]:
        """
        The SCM Type in use by the Linux Function App.
        """
        return pulumi.get(self, "scm_type")

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> Optional[bool]:
        """
        Should the Linux Function App `ip_restriction` configuration be used for the SCM also.
        """
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @property
    @pulumi.getter(name="use32BitWorker")
    def use32_bit_worker(self) -> Optional[bool]:
        """
        Should the Linux Web App use a 32-bit worker.
        """
        return pulumi.get(self, "use32_bit_worker")

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> Optional[bool]:
        """
        Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        """
        return pulumi.get(self, "vnet_route_all_enabled")

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> Optional[bool]:
        """
        Should Web Sockets be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "websockets_enabled")

    @property
    @pulumi.getter(name="workerCount")
    def worker_count(self) -> Optional[int]:
        """
        The number of Workers for this Linux Function App.
        """
        return pulumi.get(self, "worker_count")


@pulumi.output_type
class LinuxFunctionAppSlotSiteConfigAppServiceLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskQuotaMb":
            suggest = "disk_quota_mb"
        elif key == "retentionPeriodDays":
            suggest = "retention_period_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotSiteConfigAppServiceLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotSiteConfigAppServiceLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotSiteConfigAppServiceLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_quota_mb: Optional[int] = None,
                 retention_period_days: Optional[int] = None):
        """
        :param int disk_quota_mb: The amount of disk space to use for logs. Valid values are between `25` and `100`. Defaults to `35`.
        :param int retention_period_days: The retention period for logs in days. Valid values are between `0` and `99999`.(never delete).
               
               > **NOTE:** This block is not supported on Consumption plans.
        """
        if disk_quota_mb is not None:
            pulumi.set(__self__, "disk_quota_mb", disk_quota_mb)
        if retention_period_days is not None:
            pulumi.set(__self__, "retention_period_days", retention_period_days)

    @property
    @pulumi.getter(name="diskQuotaMb")
    def disk_quota_mb(self) -> Optional[int]:
        """
        The amount of disk space to use for logs. Valid values are between `25` and `100`. Defaults to `35`.
        """
        return pulumi.get(self, "disk_quota_mb")

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> Optional[int]:
        """
        The retention period for logs in days. Valid values are between `0` and `99999`.(never delete).

        > **NOTE:** This block is not supported on Consumption plans.
        """
        return pulumi.get(self, "retention_period_days")


@pulumi.output_type
class LinuxFunctionAppSlotSiteConfigApplicationStack(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dotnetVersion":
            suggest = "dotnet_version"
        elif key == "javaVersion":
            suggest = "java_version"
        elif key == "nodeVersion":
            suggest = "node_version"
        elif key == "powershellCoreVersion":
            suggest = "powershell_core_version"
        elif key == "pythonVersion":
            suggest = "python_version"
        elif key == "useCustomRuntime":
            suggest = "use_custom_runtime"
        elif key == "useDotnetIsolatedRuntime":
            suggest = "use_dotnet_isolated_runtime"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotSiteConfigApplicationStack. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotSiteConfigApplicationStack.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotSiteConfigApplicationStack.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dockers: Optional[Sequence['outputs.LinuxFunctionAppSlotSiteConfigApplicationStackDocker']] = None,
                 dotnet_version: Optional[str] = None,
                 java_version: Optional[str] = None,
                 node_version: Optional[str] = None,
                 powershell_core_version: Optional[str] = None,
                 python_version: Optional[str] = None,
                 use_custom_runtime: Optional[bool] = None,
                 use_dotnet_isolated_runtime: Optional[bool] = None):
        """
        :param Sequence['LinuxFunctionAppSlotSiteConfigApplicationStackDockerArgs'] dockers: a `docker` block as detailed below.
        :param str dotnet_version: The version of .Net. Possible values are `3.1`, `6.0` and `7.0`.
        :param str java_version: The version of Java to use. Possible values are `8`, `11` & `17` (In-Preview).
        :param str node_version: The version of Node to use. Possible values include `12`, `14`, `16` and `18`
        :param str powershell_core_version: The version of PowerShell Core to use. Possibles values are `7` , and `7.2`.
        :param str python_version: The version of Python to use. Possible values are `3.11`, `3.10`, `3.9`, `3.8` and `3.7`.
        :param bool use_custom_runtime: Should the Linux Function App use a custom runtime?
        :param bool use_dotnet_isolated_runtime: Should the DotNet process use an isolated runtime. Defaults to `false`.
        """
        if dockers is not None:
            pulumi.set(__self__, "dockers", dockers)
        if dotnet_version is not None:
            pulumi.set(__self__, "dotnet_version", dotnet_version)
        if java_version is not None:
            pulumi.set(__self__, "java_version", java_version)
        if node_version is not None:
            pulumi.set(__self__, "node_version", node_version)
        if powershell_core_version is not None:
            pulumi.set(__self__, "powershell_core_version", powershell_core_version)
        if python_version is not None:
            pulumi.set(__self__, "python_version", python_version)
        if use_custom_runtime is not None:
            pulumi.set(__self__, "use_custom_runtime", use_custom_runtime)
        if use_dotnet_isolated_runtime is not None:
            pulumi.set(__self__, "use_dotnet_isolated_runtime", use_dotnet_isolated_runtime)

    @property
    @pulumi.getter
    def dockers(self) -> Optional[Sequence['outputs.LinuxFunctionAppSlotSiteConfigApplicationStackDocker']]:
        """
        a `docker` block as detailed below.
        """
        return pulumi.get(self, "dockers")

    @property
    @pulumi.getter(name="dotnetVersion")
    def dotnet_version(self) -> Optional[str]:
        """
        The version of .Net. Possible values are `3.1`, `6.0` and `7.0`.
        """
        return pulumi.get(self, "dotnet_version")

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> Optional[str]:
        """
        The version of Java to use. Possible values are `8`, `11` & `17` (In-Preview).
        """
        return pulumi.get(self, "java_version")

    @property
    @pulumi.getter(name="nodeVersion")
    def node_version(self) -> Optional[str]:
        """
        The version of Node to use. Possible values include `12`, `14`, `16` and `18`
        """
        return pulumi.get(self, "node_version")

    @property
    @pulumi.getter(name="powershellCoreVersion")
    def powershell_core_version(self) -> Optional[str]:
        """
        The version of PowerShell Core to use. Possibles values are `7` , and `7.2`.
        """
        return pulumi.get(self, "powershell_core_version")

    @property
    @pulumi.getter(name="pythonVersion")
    def python_version(self) -> Optional[str]:
        """
        The version of Python to use. Possible values are `3.11`, `3.10`, `3.9`, `3.8` and `3.7`.
        """
        return pulumi.get(self, "python_version")

    @property
    @pulumi.getter(name="useCustomRuntime")
    def use_custom_runtime(self) -> Optional[bool]:
        """
        Should the Linux Function App use a custom runtime?
        """
        return pulumi.get(self, "use_custom_runtime")

    @property
    @pulumi.getter(name="useDotnetIsolatedRuntime")
    def use_dotnet_isolated_runtime(self) -> Optional[bool]:
        """
        Should the DotNet process use an isolated runtime. Defaults to `false`.
        """
        return pulumi.get(self, "use_dotnet_isolated_runtime")


@pulumi.output_type
class LinuxFunctionAppSlotSiteConfigApplicationStackDocker(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageName":
            suggest = "image_name"
        elif key == "imageTag":
            suggest = "image_tag"
        elif key == "registryUrl":
            suggest = "registry_url"
        elif key == "registryPassword":
            suggest = "registry_password"
        elif key == "registryUsername":
            suggest = "registry_username"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotSiteConfigApplicationStackDocker. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotSiteConfigApplicationStackDocker.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotSiteConfigApplicationStackDocker.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_name: str,
                 image_tag: str,
                 registry_url: str,
                 registry_password: Optional[str] = None,
                 registry_username: Optional[str] = None):
        """
        :param str image_name: The name of the Docker image to use.
        :param str image_tag: The image tag of the image to use.
        :param str registry_url: The URL of the docker registry.
        :param str registry_password: The password for the account to use to connect to the registry.
               
               > **NOTE:** This value is required if `container_registry_use_managed_identity` is not set to `true`.
        :param str registry_username: The username to use for connections to the registry.
               
               > **NOTE:** This value is required if `container_registry_use_managed_identity` is not set to `true`.
        """
        pulumi.set(__self__, "image_name", image_name)
        pulumi.set(__self__, "image_tag", image_tag)
        pulumi.set(__self__, "registry_url", registry_url)
        if registry_password is not None:
            pulumi.set(__self__, "registry_password", registry_password)
        if registry_username is not None:
            pulumi.set(__self__, "registry_username", registry_username)

    @property
    @pulumi.getter(name="imageName")
    def image_name(self) -> str:
        """
        The name of the Docker image to use.
        """
        return pulumi.get(self, "image_name")

    @property
    @pulumi.getter(name="imageTag")
    def image_tag(self) -> str:
        """
        The image tag of the image to use.
        """
        return pulumi.get(self, "image_tag")

    @property
    @pulumi.getter(name="registryUrl")
    def registry_url(self) -> str:
        """
        The URL of the docker registry.
        """
        return pulumi.get(self, "registry_url")

    @property
    @pulumi.getter(name="registryPassword")
    def registry_password(self) -> Optional[str]:
        """
        The password for the account to use to connect to the registry.

        > **NOTE:** This value is required if `container_registry_use_managed_identity` is not set to `true`.
        """
        return pulumi.get(self, "registry_password")

    @property
    @pulumi.getter(name="registryUsername")
    def registry_username(self) -> Optional[str]:
        """
        The username to use for connections to the registry.

        > **NOTE:** This value is required if `container_registry_use_managed_identity` is not set to `true`.
        """
        return pulumi.get(self, "registry_username")


@pulumi.output_type
class LinuxFunctionAppSlotSiteConfigCors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedOrigins":
            suggest = "allowed_origins"
        elif key == "supportCredentials":
            suggest = "support_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotSiteConfigCors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotSiteConfigCors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotSiteConfigCors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_origins: Optional[Sequence[str]] = None,
                 support_credentials: Optional[bool] = None):
        """
        :param Sequence[str] allowed_origins: an `allowed_origins` block as detailed below.
        :param bool support_credentials: Are credentials allowed in CORS requests? Defaults to `false`.
        """
        if allowed_origins is not None:
            pulumi.set(__self__, "allowed_origins", allowed_origins)
        if support_credentials is not None:
            pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Optional[Sequence[str]]:
        """
        an `allowed_origins` block as detailed below.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> Optional[bool]:
        """
        Are credentials allowed in CORS requests? Defaults to `false`.
        """
        return pulumi.get(self, "support_credentials")


@pulumi.output_type
class LinuxFunctionAppSlotSiteConfigIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotSiteConfigIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotSiteConfigIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotSiteConfigIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.LinuxFunctionAppSlotSiteConfigIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: The action to take. Possible values are `Allow` or `Deny`.
        :param 'LinuxFunctionAppSlotSiteConfigIpRestrictionHeadersArgs' headers: a `headers` block as detailed below.
        :param str ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param str name: The name which should be used for this `ip_restriction`.
        :param int priority: The priority value of this `ip_restriction`. Defaults to `65000`.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
               
               > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        The action to take. Possible values are `Allow` or `Deny`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.LinuxFunctionAppSlotSiteConfigIpRestrictionHeaders']:
        """
        a `headers` block as detailed below.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class LinuxFunctionAppSlotSiteConfigIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotSiteConfigIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param str x_fd_health_probe: Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        :param Sequence[str] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param Sequence[str] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class LinuxFunctionAppSlotSiteConfigScmIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotSiteConfigScmIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotSiteConfigScmIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotSiteConfigScmIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.LinuxFunctionAppSlotSiteConfigScmIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: The action to take. Possible values are `Allow` or `Deny`.
        :param 'LinuxFunctionAppSlotSiteConfigScmIpRestrictionHeadersArgs' headers: a `headers` block as detailed below.
        :param str ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param str name: The name which should be used for this `ip_restriction`.
        :param int priority: The priority value of this `ip_restriction`. Defaults to `65000`.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.ENDEXPERIMENT
               
               > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        The action to take. Possible values are `Allow` or `Deny`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.LinuxFunctionAppSlotSiteConfigScmIpRestrictionHeaders']:
        """
        a `headers` block as detailed below.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.ENDEXPERIMENT

        > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class LinuxFunctionAppSlotSiteConfigScmIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotSiteConfigScmIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param str x_fd_health_probe: Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        :param Sequence[str] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param Sequence[str] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class LinuxFunctionAppSlotSiteCredential(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 password: Optional[str] = None):
        """
        :param str name: The Site Credentials Username used for publishing.
        :param str password: The Site Credentials Password used for publishing.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The Site Credentials Username used for publishing.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The Site Credentials Password used for publishing.
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class LinuxFunctionAppSlotStorageAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "accountName":
            suggest = "account_name"
        elif key == "shareName":
            suggest = "share_name"
        elif key == "mountPath":
            suggest = "mount_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotStorageAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotStorageAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotStorageAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: str,
                 account_name: str,
                 name: str,
                 share_name: str,
                 type: str,
                 mount_path: Optional[str] = None):
        """
        :param str access_key: The Access key for the storage account.
        :param str account_name: The Name of the Storage Account.
        :param str name: The name which should be used for this Storage Account.
        :param str share_name: The Name of the File Share or Container Name for Blob storage.
        :param str type: The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`.
        :param str mount_path: The path at which to mount the storage share.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "share_name", share_name)
        pulumi.set(__self__, "type", type)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> str:
        """
        The Access key for the storage account.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> str:
        """
        The Name of the Storage Account.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Storage Account.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> str:
        """
        The Name of the File Share or Container Name for Blob storage.
        """
        return pulumi.get(self, "share_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[str]:
        """
        The path at which to mount the storage share.
        """
        return pulumi.get(self, "mount_path")


@pulumi.output_type
class LinuxFunctionAppStickySettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appSettingNames":
            suggest = "app_setting_names"
        elif key == "connectionStringNames":
            suggest = "connection_string_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppStickySettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppStickySettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppStickySettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_setting_names: Optional[Sequence[str]] = None,
                 connection_string_names: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] app_setting_names: A list of `app_setting` names that the Linux Function App will not swap between Slots when a swap operation is triggered.
        :param Sequence[str] connection_string_names: A list of `connection_string` names that the Linux Function App will not swap between Slots when a swap operation is triggered.
        """
        if app_setting_names is not None:
            pulumi.set(__self__, "app_setting_names", app_setting_names)
        if connection_string_names is not None:
            pulumi.set(__self__, "connection_string_names", connection_string_names)

    @property
    @pulumi.getter(name="appSettingNames")
    def app_setting_names(self) -> Optional[Sequence[str]]:
        """
        A list of `app_setting` names that the Linux Function App will not swap between Slots when a swap operation is triggered.
        """
        return pulumi.get(self, "app_setting_names")

    @property
    @pulumi.getter(name="connectionStringNames")
    def connection_string_names(self) -> Optional[Sequence[str]]:
        """
        A list of `connection_string` names that the Linux Function App will not swap between Slots when a swap operation is triggered.
        """
        return pulumi.get(self, "connection_string_names")


@pulumi.output_type
class LinuxFunctionAppStorageAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "accountName":
            suggest = "account_name"
        elif key == "shareName":
            suggest = "share_name"
        elif key == "mountPath":
            suggest = "mount_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppStorageAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppStorageAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppStorageAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: str,
                 account_name: str,
                 name: str,
                 share_name: str,
                 type: str,
                 mount_path: Optional[str] = None):
        """
        :param str access_key: The Access key for the storage account.
        :param str account_name: The Name of the Storage Account.
        :param str name: The name which should be used for this Storage Account.
        :param str share_name: The Name of the File Share or Container Name for Blob storage.
        :param str type: The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`.
        :param str mount_path: The path at which to mount the storage share.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "share_name", share_name)
        pulumi.set(__self__, "type", type)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> str:
        """
        The Access key for the storage account.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> str:
        """
        The Name of the Storage Account.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Storage Account.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> str:
        """
        The Name of the File Share or Container Name for Blob storage.
        """
        return pulumi.get(self, "share_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[str]:
        """
        The path at which to mount the storage share.
        """
        return pulumi.get(self, "mount_path")


@pulumi.output_type
class LinuxWebAppAuthSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeDirectory":
            suggest = "active_directory"
        elif key == "additionalLoginParameters":
            suggest = "additional_login_parameters"
        elif key == "allowedExternalRedirectUrls":
            suggest = "allowed_external_redirect_urls"
        elif key == "defaultProvider":
            suggest = "default_provider"
        elif key == "runtimeVersion":
            suggest = "runtime_version"
        elif key == "tokenRefreshExtensionHours":
            suggest = "token_refresh_extension_hours"
        elif key == "tokenStoreEnabled":
            suggest = "token_store_enabled"
        elif key == "unauthenticatedClientAction":
            suggest = "unauthenticated_client_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppAuthSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppAuthSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppAuthSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 active_directory: Optional['outputs.LinuxWebAppAuthSettingsActiveDirectory'] = None,
                 additional_login_parameters: Optional[Mapping[str, str]] = None,
                 allowed_external_redirect_urls: Optional[Sequence[str]] = None,
                 default_provider: Optional[str] = None,
                 facebook: Optional['outputs.LinuxWebAppAuthSettingsFacebook'] = None,
                 github: Optional['outputs.LinuxWebAppAuthSettingsGithub'] = None,
                 google: Optional['outputs.LinuxWebAppAuthSettingsGoogle'] = None,
                 issuer: Optional[str] = None,
                 microsoft: Optional['outputs.LinuxWebAppAuthSettingsMicrosoft'] = None,
                 runtime_version: Optional[str] = None,
                 token_refresh_extension_hours: Optional[float] = None,
                 token_store_enabled: Optional[bool] = None,
                 twitter: Optional['outputs.LinuxWebAppAuthSettingsTwitter'] = None,
                 unauthenticated_client_action: Optional[str] = None):
        """
        :param bool enabled: Should the Authentication / Authorization feature be enabled for the Linux Web App?
        :param 'LinuxWebAppAuthSettingsActiveDirectoryArgs' active_directory: An `active_directory` block as defined above.
        :param Mapping[str, str] additional_login_parameters: Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        :param Sequence[str] allowed_external_redirect_urls: Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Linux Web App.
        :param str default_provider: The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.
               
               > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        :param 'LinuxWebAppAuthSettingsFacebookArgs' facebook: A `facebook` block as defined below.
        :param 'LinuxWebAppAuthSettingsGithubArgs' github: A `github` block as defined below.
        :param 'LinuxWebAppAuthSettingsGoogleArgs' google: A `google` block as defined below.
        :param str issuer: The OpenID Connect Issuer URI that represents the entity that issues access tokens for this Linux Web App.
               
               > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        :param 'LinuxWebAppAuthSettingsMicrosoftArgs' microsoft: A `microsoft` block as defined below.
        :param str runtime_version: The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        :param float token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        :param bool token_store_enabled: Should the Linux Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        :param 'LinuxWebAppAuthSettingsTwitterArgs' twitter: A `twitter` block as defined below.
        :param str unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if active_directory is not None:
            pulumi.set(__self__, "active_directory", active_directory)
        if additional_login_parameters is not None:
            pulumi.set(__self__, "additional_login_parameters", additional_login_parameters)
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if facebook is not None:
            pulumi.set(__self__, "facebook", facebook)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if google is not None:
            pulumi.set(__self__, "google", google)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if microsoft is not None:
            pulumi.set(__self__, "microsoft", microsoft)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if token_refresh_extension_hours is not None:
            pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if twitter is not None:
            pulumi.set(__self__, "twitter", twitter)
        if unauthenticated_client_action is not None:
            pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Should the Authentication / Authorization feature be enabled for the Linux Web App?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="activeDirectory")
    def active_directory(self) -> Optional['outputs.LinuxWebAppAuthSettingsActiveDirectory']:
        """
        An `active_directory` block as defined above.
        """
        return pulumi.get(self, "active_directory")

    @property
    @pulumi.getter(name="additionalLoginParameters")
    def additional_login_parameters(self) -> Optional[Mapping[str, str]]:
        """
        Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        """
        return pulumi.get(self, "additional_login_parameters")

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Linux Web App.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[str]:
        """
        The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.

        > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        """
        return pulumi.get(self, "default_provider")

    @property
    @pulumi.getter
    def facebook(self) -> Optional['outputs.LinuxWebAppAuthSettingsFacebook']:
        """
        A `facebook` block as defined below.
        """
        return pulumi.get(self, "facebook")

    @property
    @pulumi.getter
    def github(self) -> Optional['outputs.LinuxWebAppAuthSettingsGithub']:
        """
        A `github` block as defined below.
        """
        return pulumi.get(self, "github")

    @property
    @pulumi.getter
    def google(self) -> Optional['outputs.LinuxWebAppAuthSettingsGoogle']:
        """
        A `google` block as defined below.
        """
        return pulumi.get(self, "google")

    @property
    @pulumi.getter
    def issuer(self) -> Optional[str]:
        """
        The OpenID Connect Issuer URI that represents the entity that issues access tokens for this Linux Web App.

        > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def microsoft(self) -> Optional['outputs.LinuxWebAppAuthSettingsMicrosoft']:
        """
        A `microsoft` block as defined below.
        """
        return pulumi.get(self, "microsoft")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[str]:
        """
        The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> Optional[float]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        return pulumi.get(self, "token_refresh_extension_hours")

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[bool]:
        """
        Should the Linux Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        """
        return pulumi.get(self, "token_store_enabled")

    @property
    @pulumi.getter
    def twitter(self) -> Optional['outputs.LinuxWebAppAuthSettingsTwitter']:
        """
        A `twitter` block as defined below.
        """
        return pulumi.get(self, "twitter")

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> Optional[str]:
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        return pulumi.get(self, "unauthenticated_client_action")


@pulumi.output_type
class LinuxWebAppAuthSettingsActiveDirectory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppAuthSettingsActiveDirectory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppAuthSettingsActiveDirectory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppAuthSettingsActiveDirectory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param Sequence[str] allowed_audiences: Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
               
               > **Note:** The `client_id` value is always considered an allowed audience.
        :param str client_secret: The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        pulumi.set(__self__, "client_id", client_id)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **Note:** The `client_id` value is always considered an allowed audience.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")


@pulumi.output_type
class LinuxWebAppAuthSettingsFacebook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "appSecret":
            suggest = "app_secret"
        elif key == "appSecretSettingName":
            suggest = "app_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppAuthSettingsFacebook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppAuthSettingsFacebook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppAuthSettingsFacebook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: str,
                 app_secret: Optional[str] = None,
                 app_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str app_id: The App ID of the Facebook app used for login.
        :param str app_secret: The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        :param str app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        if app_secret is not None:
            pulumi.set(__self__, "app_secret", app_secret)
        if app_secret_setting_name is not None:
            pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appSecret")
    def app_secret(self) -> Optional[str]:
        """
        The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        """
        return pulumi.get(self, "app_secret")

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class LinuxWebAppAuthSettingsGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppAuthSettingsGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppAuthSettingsGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppAuthSettingsGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the GitHub app used for login.
        :param str client_secret: The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the GitHub app used for login.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class LinuxWebAppAuthSettingsGoogle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppAuthSettingsGoogle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppAuthSettingsGoogle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppAuthSettingsGoogle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OpenID Connect Client ID for the Google web application.
        :param str client_secret: The client secret associated with the Google web application. Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OpenID Connect Client ID for the Google web application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The client secret associated with the Google web application. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class LinuxWebAppAuthSettingsMicrosoft(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppAuthSettingsMicrosoft. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppAuthSettingsMicrosoft.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppAuthSettingsMicrosoft.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret: The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, "wl.basic" is used as the default scope.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, "wl.basic" is used as the default scope.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class LinuxWebAppAuthSettingsTwitter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerKey":
            suggest = "consumer_key"
        elif key == "consumerSecret":
            suggest = "consumer_secret"
        elif key == "consumerSecretSettingName":
            suggest = "consumer_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppAuthSettingsTwitter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppAuthSettingsTwitter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppAuthSettingsTwitter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_key: str,
                 consumer_secret: Optional[str] = None,
                 consumer_secret_setting_name: Optional[str] = None):
        """
        :param str consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param str consumer_secret: The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        :param str consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        if consumer_secret is not None:
            pulumi.set(__self__, "consumer_secret", consumer_secret)
        if consumer_secret_setting_name is not None:
            pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> str:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> Optional[str]:
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        """
        return pulumi.get(self, "consumer_secret")

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        return pulumi.get(self, "consumer_secret_setting_name")


@pulumi.output_type
class LinuxWebAppAuthSettingsV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeDirectoryV2":
            suggest = "active_directory_v2"
        elif key == "appleV2":
            suggest = "apple_v2"
        elif key == "authEnabled":
            suggest = "auth_enabled"
        elif key == "azureStaticWebAppV2":
            suggest = "azure_static_web_app_v2"
        elif key == "configFilePath":
            suggest = "config_file_path"
        elif key == "customOidcV2s":
            suggest = "custom_oidc_v2s"
        elif key == "defaultProvider":
            suggest = "default_provider"
        elif key == "excludedPaths":
            suggest = "excluded_paths"
        elif key == "facebookV2":
            suggest = "facebook_v2"
        elif key == "forwardProxyConvention":
            suggest = "forward_proxy_convention"
        elif key == "forwardProxyCustomHostHeaderName":
            suggest = "forward_proxy_custom_host_header_name"
        elif key == "forwardProxyCustomSchemeHeaderName":
            suggest = "forward_proxy_custom_scheme_header_name"
        elif key == "githubV2":
            suggest = "github_v2"
        elif key == "googleV2":
            suggest = "google_v2"
        elif key == "httpRouteApiPrefix":
            suggest = "http_route_api_prefix"
        elif key == "microsoftV2":
            suggest = "microsoft_v2"
        elif key == "requireAuthentication":
            suggest = "require_authentication"
        elif key == "requireHttps":
            suggest = "require_https"
        elif key == "runtimeVersion":
            suggest = "runtime_version"
        elif key == "twitterV2":
            suggest = "twitter_v2"
        elif key == "unauthenticatedAction":
            suggest = "unauthenticated_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppAuthSettingsV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppAuthSettingsV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppAuthSettingsV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 login: 'outputs.LinuxWebAppAuthSettingsV2Login',
                 active_directory_v2: Optional['outputs.LinuxWebAppAuthSettingsV2ActiveDirectoryV2'] = None,
                 apple_v2: Optional['outputs.LinuxWebAppAuthSettingsV2AppleV2'] = None,
                 auth_enabled: Optional[bool] = None,
                 azure_static_web_app_v2: Optional['outputs.LinuxWebAppAuthSettingsV2AzureStaticWebAppV2'] = None,
                 config_file_path: Optional[str] = None,
                 custom_oidc_v2s: Optional[Sequence['outputs.LinuxWebAppAuthSettingsV2CustomOidcV2']] = None,
                 default_provider: Optional[str] = None,
                 excluded_paths: Optional[Sequence[str]] = None,
                 facebook_v2: Optional['outputs.LinuxWebAppAuthSettingsV2FacebookV2'] = None,
                 forward_proxy_convention: Optional[str] = None,
                 forward_proxy_custom_host_header_name: Optional[str] = None,
                 forward_proxy_custom_scheme_header_name: Optional[str] = None,
                 github_v2: Optional['outputs.LinuxWebAppAuthSettingsV2GithubV2'] = None,
                 google_v2: Optional['outputs.LinuxWebAppAuthSettingsV2GoogleV2'] = None,
                 http_route_api_prefix: Optional[str] = None,
                 microsoft_v2: Optional['outputs.LinuxWebAppAuthSettingsV2MicrosoftV2'] = None,
                 require_authentication: Optional[bool] = None,
                 require_https: Optional[bool] = None,
                 runtime_version: Optional[str] = None,
                 twitter_v2: Optional['outputs.LinuxWebAppAuthSettingsV2TwitterV2'] = None,
                 unauthenticated_action: Optional[str] = None):
        """
        :param 'LinuxWebAppAuthSettingsV2LoginArgs' login: A `login` block as defined below.
        :param 'LinuxWebAppAuthSettingsV2ActiveDirectoryV2Args' active_directory_v2: An `active_directory_v2` block as defined below.
        :param 'LinuxWebAppAuthSettingsV2AppleV2Args' apple_v2: An `apple_v2` block as defined below.
        :param bool auth_enabled: Should the AuthV2 Settings be enabled. Defaults to `false`.
        :param 'LinuxWebAppAuthSettingsV2AzureStaticWebAppV2Args' azure_static_web_app_v2: An `azure_static_web_app_v2` block as defined below.
        :param str config_file_path: The path to the App Auth settings. 
               
               * > **Note:** Relative Paths are evaluated from the Site Root directory.
        :param Sequence['LinuxWebAppAuthSettingsV2CustomOidcV2Args'] custom_oidc_v2s: Zero or more `custom_oidc_v2` blocks as defined below.
        :param str default_provider: The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.
               
               > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        :param Sequence[str] excluded_paths: The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.
               
               > **NOTE:** This list should be used instead of setting `WEBSITE_WARMUP_PATH` in `app_settings` as it takes priority.
        :param 'LinuxWebAppAuthSettingsV2FacebookV2Args' facebook_v2: A `facebook_v2` block as defined below.
        :param str forward_proxy_convention: The convention used to determine the url of the request made. Possible values include `NoProxy`, `Standard`, `Custom`. Defaults to `NoProxy`.
        :param str forward_proxy_custom_host_header_name: The name of the custom header containing the host of the request.
        :param str forward_proxy_custom_scheme_header_name: The name of the custom header containing the scheme of the request.
        :param 'LinuxWebAppAuthSettingsV2GithubV2Args' github_v2: A `github_v2` block as defined below.
        :param 'LinuxWebAppAuthSettingsV2GoogleV2Args' google_v2: A `google_v2` block as defined below.
        :param str http_route_api_prefix: The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
        :param 'LinuxWebAppAuthSettingsV2MicrosoftV2Args' microsoft_v2: A `microsoft_v2` block as defined below.
        :param bool require_authentication: Should the authentication flow be used for all requests.
        :param bool require_https: Should HTTPS be required on connections? Defaults to `true`.
        :param str runtime_version: The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        :param 'LinuxWebAppAuthSettingsV2TwitterV2Args' twitter_v2: A `twitter_v2` block as defined below.
        :param str unauthenticated_action: The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
        """
        pulumi.set(__self__, "login", login)
        if active_directory_v2 is not None:
            pulumi.set(__self__, "active_directory_v2", active_directory_v2)
        if apple_v2 is not None:
            pulumi.set(__self__, "apple_v2", apple_v2)
        if auth_enabled is not None:
            pulumi.set(__self__, "auth_enabled", auth_enabled)
        if azure_static_web_app_v2 is not None:
            pulumi.set(__self__, "azure_static_web_app_v2", azure_static_web_app_v2)
        if config_file_path is not None:
            pulumi.set(__self__, "config_file_path", config_file_path)
        if custom_oidc_v2s is not None:
            pulumi.set(__self__, "custom_oidc_v2s", custom_oidc_v2s)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if excluded_paths is not None:
            pulumi.set(__self__, "excluded_paths", excluded_paths)
        if facebook_v2 is not None:
            pulumi.set(__self__, "facebook_v2", facebook_v2)
        if forward_proxy_convention is not None:
            pulumi.set(__self__, "forward_proxy_convention", forward_proxy_convention)
        if forward_proxy_custom_host_header_name is not None:
            pulumi.set(__self__, "forward_proxy_custom_host_header_name", forward_proxy_custom_host_header_name)
        if forward_proxy_custom_scheme_header_name is not None:
            pulumi.set(__self__, "forward_proxy_custom_scheme_header_name", forward_proxy_custom_scheme_header_name)
        if github_v2 is not None:
            pulumi.set(__self__, "github_v2", github_v2)
        if google_v2 is not None:
            pulumi.set(__self__, "google_v2", google_v2)
        if http_route_api_prefix is not None:
            pulumi.set(__self__, "http_route_api_prefix", http_route_api_prefix)
        if microsoft_v2 is not None:
            pulumi.set(__self__, "microsoft_v2", microsoft_v2)
        if require_authentication is not None:
            pulumi.set(__self__, "require_authentication", require_authentication)
        if require_https is not None:
            pulumi.set(__self__, "require_https", require_https)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if twitter_v2 is not None:
            pulumi.set(__self__, "twitter_v2", twitter_v2)
        if unauthenticated_action is not None:
            pulumi.set(__self__, "unauthenticated_action", unauthenticated_action)

    @property
    @pulumi.getter
    def login(self) -> 'outputs.LinuxWebAppAuthSettingsV2Login':
        """
        A `login` block as defined below.
        """
        return pulumi.get(self, "login")

    @property
    @pulumi.getter(name="activeDirectoryV2")
    def active_directory_v2(self) -> Optional['outputs.LinuxWebAppAuthSettingsV2ActiveDirectoryV2']:
        """
        An `active_directory_v2` block as defined below.
        """
        return pulumi.get(self, "active_directory_v2")

    @property
    @pulumi.getter(name="appleV2")
    def apple_v2(self) -> Optional['outputs.LinuxWebAppAuthSettingsV2AppleV2']:
        """
        An `apple_v2` block as defined below.
        """
        return pulumi.get(self, "apple_v2")

    @property
    @pulumi.getter(name="authEnabled")
    def auth_enabled(self) -> Optional[bool]:
        """
        Should the AuthV2 Settings be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "auth_enabled")

    @property
    @pulumi.getter(name="azureStaticWebAppV2")
    def azure_static_web_app_v2(self) -> Optional['outputs.LinuxWebAppAuthSettingsV2AzureStaticWebAppV2']:
        """
        An `azure_static_web_app_v2` block as defined below.
        """
        return pulumi.get(self, "azure_static_web_app_v2")

    @property
    @pulumi.getter(name="configFilePath")
    def config_file_path(self) -> Optional[str]:
        """
        The path to the App Auth settings. 

        * > **Note:** Relative Paths are evaluated from the Site Root directory.
        """
        return pulumi.get(self, "config_file_path")

    @property
    @pulumi.getter(name="customOidcV2s")
    def custom_oidc_v2s(self) -> Optional[Sequence['outputs.LinuxWebAppAuthSettingsV2CustomOidcV2']]:
        """
        Zero or more `custom_oidc_v2` blocks as defined below.
        """
        return pulumi.get(self, "custom_oidc_v2s")

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[str]:
        """
        The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.

        > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        """
        return pulumi.get(self, "default_provider")

    @property
    @pulumi.getter(name="excludedPaths")
    def excluded_paths(self) -> Optional[Sequence[str]]:
        """
        The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.

        > **NOTE:** This list should be used instead of setting `WEBSITE_WARMUP_PATH` in `app_settings` as it takes priority.
        """
        return pulumi.get(self, "excluded_paths")

    @property
    @pulumi.getter(name="facebookV2")
    def facebook_v2(self) -> Optional['outputs.LinuxWebAppAuthSettingsV2FacebookV2']:
        """
        A `facebook_v2` block as defined below.
        """
        return pulumi.get(self, "facebook_v2")

    @property
    @pulumi.getter(name="forwardProxyConvention")
    def forward_proxy_convention(self) -> Optional[str]:
        """
        The convention used to determine the url of the request made. Possible values include `NoProxy`, `Standard`, `Custom`. Defaults to `NoProxy`.
        """
        return pulumi.get(self, "forward_proxy_convention")

    @property
    @pulumi.getter(name="forwardProxyCustomHostHeaderName")
    def forward_proxy_custom_host_header_name(self) -> Optional[str]:
        """
        The name of the custom header containing the host of the request.
        """
        return pulumi.get(self, "forward_proxy_custom_host_header_name")

    @property
    @pulumi.getter(name="forwardProxyCustomSchemeHeaderName")
    def forward_proxy_custom_scheme_header_name(self) -> Optional[str]:
        """
        The name of the custom header containing the scheme of the request.
        """
        return pulumi.get(self, "forward_proxy_custom_scheme_header_name")

    @property
    @pulumi.getter(name="githubV2")
    def github_v2(self) -> Optional['outputs.LinuxWebAppAuthSettingsV2GithubV2']:
        """
        A `github_v2` block as defined below.
        """
        return pulumi.get(self, "github_v2")

    @property
    @pulumi.getter(name="googleV2")
    def google_v2(self) -> Optional['outputs.LinuxWebAppAuthSettingsV2GoogleV2']:
        """
        A `google_v2` block as defined below.
        """
        return pulumi.get(self, "google_v2")

    @property
    @pulumi.getter(name="httpRouteApiPrefix")
    def http_route_api_prefix(self) -> Optional[str]:
        """
        The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
        """
        return pulumi.get(self, "http_route_api_prefix")

    @property
    @pulumi.getter(name="microsoftV2")
    def microsoft_v2(self) -> Optional['outputs.LinuxWebAppAuthSettingsV2MicrosoftV2']:
        """
        A `microsoft_v2` block as defined below.
        """
        return pulumi.get(self, "microsoft_v2")

    @property
    @pulumi.getter(name="requireAuthentication")
    def require_authentication(self) -> Optional[bool]:
        """
        Should the authentication flow be used for all requests.
        """
        return pulumi.get(self, "require_authentication")

    @property
    @pulumi.getter(name="requireHttps")
    def require_https(self) -> Optional[bool]:
        """
        Should HTTPS be required on connections? Defaults to `true`.
        """
        return pulumi.get(self, "require_https")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[str]:
        """
        The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter(name="twitterV2")
    def twitter_v2(self) -> Optional['outputs.LinuxWebAppAuthSettingsV2TwitterV2']:
        """
        A `twitter_v2` block as defined below.
        """
        return pulumi.get(self, "twitter_v2")

    @property
    @pulumi.getter(name="unauthenticatedAction")
    def unauthenticated_action(self) -> Optional[str]:
        """
        The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
        """
        return pulumi.get(self, "unauthenticated_action")


@pulumi.output_type
class LinuxWebAppAuthSettingsV2ActiveDirectoryV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "tenantAuthEndpoint":
            suggest = "tenant_auth_endpoint"
        elif key == "allowedApplications":
            suggest = "allowed_applications"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "allowedGroups":
            suggest = "allowed_groups"
        elif key == "allowedIdentities":
            suggest = "allowed_identities"
        elif key == "clientSecretCertificateThumbprint":
            suggest = "client_secret_certificate_thumbprint"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "jwtAllowedClientApplications":
            suggest = "jwt_allowed_client_applications"
        elif key == "jwtAllowedGroups":
            suggest = "jwt_allowed_groups"
        elif key == "loginParameters":
            suggest = "login_parameters"
        elif key == "wwwAuthenticationDisabled":
            suggest = "www_authentication_disabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppAuthSettingsV2ActiveDirectoryV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppAuthSettingsV2ActiveDirectoryV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppAuthSettingsV2ActiveDirectoryV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 tenant_auth_endpoint: str,
                 allowed_applications: Optional[Sequence[str]] = None,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 allowed_groups: Optional[Sequence[str]] = None,
                 allowed_identities: Optional[Sequence[str]] = None,
                 client_secret_certificate_thumbprint: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 jwt_allowed_client_applications: Optional[Sequence[str]] = None,
                 jwt_allowed_groups: Optional[Sequence[str]] = None,
                 login_parameters: Optional[Mapping[str, str]] = None,
                 www_authentication_disabled: Optional[bool] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str tenant_auth_endpoint: The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`
        :param Sequence[str] allowed_applications: The list of allowed Applications for the Default Authorisation Policy.
        :param Sequence[str] allowed_audiences: Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
               
               > **Note:** The `client_id` value is always considered an allowed audience.
        :param Sequence[str] allowed_groups: The list of allowed Group Names for the Default Authorisation Policy.
        :param Sequence[str] allowed_identities: The list of allowed Identities for the Default Authorisation Policy.
        :param str client_secret_certificate_thumbprint: The thumbprint of the certificate used for signing purposes.
               
               > **NOTE:** One of `client_secret_setting_name` or `client_secret_certificate_thumbprint` must be specified.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param Sequence[str] jwt_allowed_client_applications: A list of Allowed Client Applications in the JWT Claim.
        :param Sequence[str] jwt_allowed_groups: A list of Allowed Groups in the JWT Claim.
        :param Mapping[str, str] login_parameters: A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
        :param bool www_authentication_disabled: Should the www-authenticate provider should be omitted from the request? Defaults to `false`
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "tenant_auth_endpoint", tenant_auth_endpoint)
        if allowed_applications is not None:
            pulumi.set(__self__, "allowed_applications", allowed_applications)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if allowed_groups is not None:
            pulumi.set(__self__, "allowed_groups", allowed_groups)
        if allowed_identities is not None:
            pulumi.set(__self__, "allowed_identities", allowed_identities)
        if client_secret_certificate_thumbprint is not None:
            pulumi.set(__self__, "client_secret_certificate_thumbprint", client_secret_certificate_thumbprint)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if jwt_allowed_client_applications is not None:
            pulumi.set(__self__, "jwt_allowed_client_applications", jwt_allowed_client_applications)
        if jwt_allowed_groups is not None:
            pulumi.set(__self__, "jwt_allowed_groups", jwt_allowed_groups)
        if login_parameters is not None:
            pulumi.set(__self__, "login_parameters", login_parameters)
        if www_authentication_disabled is not None:
            pulumi.set(__self__, "www_authentication_disabled", www_authentication_disabled)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="tenantAuthEndpoint")
    def tenant_auth_endpoint(self) -> str:
        """
        The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`
        """
        return pulumi.get(self, "tenant_auth_endpoint")

    @property
    @pulumi.getter(name="allowedApplications")
    def allowed_applications(self) -> Optional[Sequence[str]]:
        """
        The list of allowed Applications for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_applications")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **Note:** The `client_id` value is always considered an allowed audience.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="allowedGroups")
    def allowed_groups(self) -> Optional[Sequence[str]]:
        """
        The list of allowed Group Names for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_groups")

    @property
    @pulumi.getter(name="allowedIdentities")
    def allowed_identities(self) -> Optional[Sequence[str]]:
        """
        The list of allowed Identities for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_identities")

    @property
    @pulumi.getter(name="clientSecretCertificateThumbprint")
    def client_secret_certificate_thumbprint(self) -> Optional[str]:
        """
        The thumbprint of the certificate used for signing purposes.

        > **NOTE:** One of `client_secret_setting_name` or `client_secret_certificate_thumbprint` must be specified.
        """
        return pulumi.get(self, "client_secret_certificate_thumbprint")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="jwtAllowedClientApplications")
    def jwt_allowed_client_applications(self) -> Optional[Sequence[str]]:
        """
        A list of Allowed Client Applications in the JWT Claim.
        """
        return pulumi.get(self, "jwt_allowed_client_applications")

    @property
    @pulumi.getter(name="jwtAllowedGroups")
    def jwt_allowed_groups(self) -> Optional[Sequence[str]]:
        """
        A list of Allowed Groups in the JWT Claim.
        """
        return pulumi.get(self, "jwt_allowed_groups")

    @property
    @pulumi.getter(name="loginParameters")
    def login_parameters(self) -> Optional[Mapping[str, str]]:
        """
        A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
        """
        return pulumi.get(self, "login_parameters")

    @property
    @pulumi.getter(name="wwwAuthenticationDisabled")
    def www_authentication_disabled(self) -> Optional[bool]:
        """
        Should the www-authenticate provider should be omitted from the request? Defaults to `false`
        """
        return pulumi.get(self, "www_authentication_disabled")


@pulumi.output_type
class LinuxWebAppAuthSettingsV2AppleV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "loginScopes":
            suggest = "login_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppAuthSettingsV2AppleV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppAuthSettingsV2AppleV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppAuthSettingsV2AppleV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret_setting_name: str,
                 login_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param Sequence[str] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[Sequence[str]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class LinuxWebAppAuthSettingsV2AzureStaticWebAppV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppAuthSettingsV2AzureStaticWebAppV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppAuthSettingsV2AzureStaticWebAppV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppAuthSettingsV2AzureStaticWebAppV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        """
        pulumi.set(__self__, "client_id", client_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")


@pulumi.output_type
class LinuxWebAppAuthSettingsV2CustomOidcV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "openidConfigurationEndpoint":
            suggest = "openid_configuration_endpoint"
        elif key == "authorisationEndpoint":
            suggest = "authorisation_endpoint"
        elif key == "certificationUri":
            suggest = "certification_uri"
        elif key == "clientCredentialMethod":
            suggest = "client_credential_method"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "issuerEndpoint":
            suggest = "issuer_endpoint"
        elif key == "nameClaimType":
            suggest = "name_claim_type"
        elif key == "tokenEndpoint":
            suggest = "token_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppAuthSettingsV2CustomOidcV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppAuthSettingsV2CustomOidcV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppAuthSettingsV2CustomOidcV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 name: str,
                 openid_configuration_endpoint: str,
                 authorisation_endpoint: Optional[str] = None,
                 certification_uri: Optional[str] = None,
                 client_credential_method: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 issuer_endpoint: Optional[str] = None,
                 name_claim_type: Optional[str] = None,
                 scopes: Optional[Sequence[str]] = None,
                 token_endpoint: Optional[str] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str openid_configuration_endpoint: Specifies the endpoint used for OpenID Connect Discovery. For example `https://example.com/.well-known/openid-configuration`.
        :param str authorisation_endpoint: The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        :param str certification_uri: The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        :param str client_credential_method: The Client Credential Method used.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param str issuer_endpoint: The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        :param str name_claim_type: The name of the claim that contains the users name.
        :param Sequence[str] scopes: The list of the scopes that should be requested while authenticating.
        :param str token_endpoint: The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "openid_configuration_endpoint", openid_configuration_endpoint)
        if authorisation_endpoint is not None:
            pulumi.set(__self__, "authorisation_endpoint", authorisation_endpoint)
        if certification_uri is not None:
            pulumi.set(__self__, "certification_uri", certification_uri)
        if client_credential_method is not None:
            pulumi.set(__self__, "client_credential_method", client_credential_method)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if issuer_endpoint is not None:
            pulumi.set(__self__, "issuer_endpoint", issuer_endpoint)
        if name_claim_type is not None:
            pulumi.set(__self__, "name_claim_type", name_claim_type)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="openidConfigurationEndpoint")
    def openid_configuration_endpoint(self) -> str:
        """
        Specifies the endpoint used for OpenID Connect Discovery. For example `https://example.com/.well-known/openid-configuration`.
        """
        return pulumi.get(self, "openid_configuration_endpoint")

    @property
    @pulumi.getter(name="authorisationEndpoint")
    def authorisation_endpoint(self) -> Optional[str]:
        """
        The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "authorisation_endpoint")

    @property
    @pulumi.getter(name="certificationUri")
    def certification_uri(self) -> Optional[str]:
        """
        The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "certification_uri")

    @property
    @pulumi.getter(name="clientCredentialMethod")
    def client_credential_method(self) -> Optional[str]:
        """
        The Client Credential Method used.
        """
        return pulumi.get(self, "client_credential_method")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="issuerEndpoint")
    def issuer_endpoint(self) -> Optional[str]:
        """
        The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "issuer_endpoint")

    @property
    @pulumi.getter(name="nameClaimType")
    def name_claim_type(self) -> Optional[str]:
        """
        The name of the claim that contains the users name.
        """
        return pulumi.get(self, "name_claim_type")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[str]]:
        """
        The list of the scopes that should be requested while authenticating.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[str]:
        """
        The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "token_endpoint")


@pulumi.output_type
class LinuxWebAppAuthSettingsV2FacebookV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "appSecretSettingName":
            suggest = "app_secret_setting_name"
        elif key == "graphApiVersion":
            suggest = "graph_api_version"
        elif key == "loginScopes":
            suggest = "login_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppAuthSettingsV2FacebookV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppAuthSettingsV2FacebookV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppAuthSettingsV2FacebookV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: str,
                 app_secret_setting_name: str,
                 graph_api_version: Optional[str] = None,
                 login_scopes: Optional[Sequence[str]] = None):
        """
        :param str app_id: The App ID of the Facebook app used for login.
        :param str app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook Login.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param str graph_api_version: The version of the Facebook API to be used while logging in.
        :param Sequence[str] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        if graph_api_version is not None:
            pulumi.set(__self__, "graph_api_version", graph_api_version)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> str:
        """
        The app setting name that contains the `app_secret` value used for Facebook Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @property
    @pulumi.getter(name="graphApiVersion")
    def graph_api_version(self) -> Optional[str]:
        """
        The version of the Facebook API to be used while logging in.
        """
        return pulumi.get(self, "graph_api_version")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[Sequence[str]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class LinuxWebAppAuthSettingsV2GithubV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "loginScopes":
            suggest = "login_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppAuthSettingsV2GithubV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppAuthSettingsV2GithubV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppAuthSettingsV2GithubV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret_setting_name: str,
                 login_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param Sequence[str] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[Sequence[str]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class LinuxWebAppAuthSettingsV2GoogleV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "loginScopes":
            suggest = "login_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppAuthSettingsV2GoogleV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppAuthSettingsV2GoogleV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppAuthSettingsV2GoogleV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret_setting_name: str,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 login_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param Sequence[str] allowed_audiences: Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
               
               > **Note:** The `client_id` value is always considered an allowed audience.
        :param Sequence[str] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **Note:** The `client_id` value is always considered an allowed audience.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[Sequence[str]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class LinuxWebAppAuthSettingsV2Login(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedExternalRedirectUrls":
            suggest = "allowed_external_redirect_urls"
        elif key == "cookieExpirationConvention":
            suggest = "cookie_expiration_convention"
        elif key == "cookieExpirationTime":
            suggest = "cookie_expiration_time"
        elif key == "logoutEndpoint":
            suggest = "logout_endpoint"
        elif key == "nonceExpirationTime":
            suggest = "nonce_expiration_time"
        elif key == "preserveUrlFragmentsForLogins":
            suggest = "preserve_url_fragments_for_logins"
        elif key == "tokenRefreshExtensionTime":
            suggest = "token_refresh_extension_time"
        elif key == "tokenStoreEnabled":
            suggest = "token_store_enabled"
        elif key == "tokenStorePath":
            suggest = "token_store_path"
        elif key == "tokenStoreSasSettingName":
            suggest = "token_store_sas_setting_name"
        elif key == "validateNonce":
            suggest = "validate_nonce"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppAuthSettingsV2Login. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppAuthSettingsV2Login.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppAuthSettingsV2Login.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_external_redirect_urls: Optional[Sequence[str]] = None,
                 cookie_expiration_convention: Optional[str] = None,
                 cookie_expiration_time: Optional[str] = None,
                 logout_endpoint: Optional[str] = None,
                 nonce_expiration_time: Optional[str] = None,
                 preserve_url_fragments_for_logins: Optional[bool] = None,
                 token_refresh_extension_time: Optional[float] = None,
                 token_store_enabled: Optional[bool] = None,
                 token_store_path: Optional[str] = None,
                 token_store_sas_setting_name: Optional[str] = None,
                 validate_nonce: Optional[bool] = None):
        """
        :param Sequence[str] allowed_external_redirect_urls: External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends. 
               
               > **Note:** URLs within the current domain are always implicitly allowed.
        :param str cookie_expiration_convention: The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
        :param str cookie_expiration_time: The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
        :param str logout_endpoint: The endpoint to which logout requests should be made.
        :param str nonce_expiration_time: The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
        :param bool preserve_url_fragments_for_logins: Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
        :param float token_refresh_extension_time: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        :param bool token_store_enabled: Should the Token Store configuration Enabled. Defaults to `false`
        :param str token_store_path: The directory path in the App Filesystem in which the tokens will be stored.
        :param str token_store_sas_setting_name: The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        :param bool validate_nonce: Should the nonce be validated while completing the login flow. Defaults to `true`.
        """
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if cookie_expiration_convention is not None:
            pulumi.set(__self__, "cookie_expiration_convention", cookie_expiration_convention)
        if cookie_expiration_time is not None:
            pulumi.set(__self__, "cookie_expiration_time", cookie_expiration_time)
        if logout_endpoint is not None:
            pulumi.set(__self__, "logout_endpoint", logout_endpoint)
        if nonce_expiration_time is not None:
            pulumi.set(__self__, "nonce_expiration_time", nonce_expiration_time)
        if preserve_url_fragments_for_logins is not None:
            pulumi.set(__self__, "preserve_url_fragments_for_logins", preserve_url_fragments_for_logins)
        if token_refresh_extension_time is not None:
            pulumi.set(__self__, "token_refresh_extension_time", token_refresh_extension_time)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if token_store_path is not None:
            pulumi.set(__self__, "token_store_path", token_store_path)
        if token_store_sas_setting_name is not None:
            pulumi.set(__self__, "token_store_sas_setting_name", token_store_sas_setting_name)
        if validate_nonce is not None:
            pulumi.set(__self__, "validate_nonce", validate_nonce)

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[Sequence[str]]:
        """
        External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends. 

        > **Note:** URLs within the current domain are always implicitly allowed.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @property
    @pulumi.getter(name="cookieExpirationConvention")
    def cookie_expiration_convention(self) -> Optional[str]:
        """
        The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
        """
        return pulumi.get(self, "cookie_expiration_convention")

    @property
    @pulumi.getter(name="cookieExpirationTime")
    def cookie_expiration_time(self) -> Optional[str]:
        """
        The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
        """
        return pulumi.get(self, "cookie_expiration_time")

    @property
    @pulumi.getter(name="logoutEndpoint")
    def logout_endpoint(self) -> Optional[str]:
        """
        The endpoint to which logout requests should be made.
        """
        return pulumi.get(self, "logout_endpoint")

    @property
    @pulumi.getter(name="nonceExpirationTime")
    def nonce_expiration_time(self) -> Optional[str]:
        """
        The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
        """
        return pulumi.get(self, "nonce_expiration_time")

    @property
    @pulumi.getter(name="preserveUrlFragmentsForLogins")
    def preserve_url_fragments_for_logins(self) -> Optional[bool]:
        """
        Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
        """
        return pulumi.get(self, "preserve_url_fragments_for_logins")

    @property
    @pulumi.getter(name="tokenRefreshExtensionTime")
    def token_refresh_extension_time(self) -> Optional[float]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        return pulumi.get(self, "token_refresh_extension_time")

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[bool]:
        """
        Should the Token Store configuration Enabled. Defaults to `false`
        """
        return pulumi.get(self, "token_store_enabled")

    @property
    @pulumi.getter(name="tokenStorePath")
    def token_store_path(self) -> Optional[str]:
        """
        The directory path in the App Filesystem in which the tokens will be stored.
        """
        return pulumi.get(self, "token_store_path")

    @property
    @pulumi.getter(name="tokenStoreSasSettingName")
    def token_store_sas_setting_name(self) -> Optional[str]:
        """
        The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        """
        return pulumi.get(self, "token_store_sas_setting_name")

    @property
    @pulumi.getter(name="validateNonce")
    def validate_nonce(self) -> Optional[bool]:
        """
        Should the nonce be validated while completing the login flow. Defaults to `true`.
        """
        return pulumi.get(self, "validate_nonce")


@pulumi.output_type
class LinuxWebAppAuthSettingsV2MicrosoftV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "loginScopes":
            suggest = "login_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppAuthSettingsV2MicrosoftV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppAuthSettingsV2MicrosoftV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppAuthSettingsV2MicrosoftV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret_setting_name: str,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 login_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param Sequence[str] allowed_audiences: Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
               
               > **Note:** The `client_id` value is always considered an allowed audience.
        :param Sequence[str] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **Note:** The `client_id` value is always considered an allowed audience.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[Sequence[str]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class LinuxWebAppAuthSettingsV2TwitterV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerKey":
            suggest = "consumer_key"
        elif key == "consumerSecretSettingName":
            suggest = "consumer_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppAuthSettingsV2TwitterV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppAuthSettingsV2TwitterV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppAuthSettingsV2TwitterV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_key: str,
                 consumer_secret_setting_name: str):
        """
        :param str consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param str consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> str:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> str:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "consumer_secret_setting_name")


@pulumi.output_type
class LinuxWebAppBackup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageAccountUrl":
            suggest = "storage_account_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppBackup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppBackup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppBackup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 schedule: 'outputs.LinuxWebAppBackupSchedule',
                 storage_account_url: str,
                 enabled: Optional[bool] = None):
        """
        :param str name: The name which should be used for this Backup.
        :param 'LinuxWebAppBackupScheduleArgs' schedule: A `schedule` block as defined below.
        :param str storage_account_url: The SAS URL to the container.
        :param bool enabled: Should this backup job be enabled? Defaults to `true`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "storage_account_url", storage_account_url)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Backup.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def schedule(self) -> 'outputs.LinuxWebAppBackupSchedule':
        """
        A `schedule` block as defined below.
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter(name="storageAccountUrl")
    def storage_account_url(self) -> str:
        """
        The SAS URL to the container.
        """
        return pulumi.get(self, "storage_account_url")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Should this backup job be enabled? Defaults to `true`.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class LinuxWebAppBackupSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "frequencyUnit":
            suggest = "frequency_unit"
        elif key == "keepAtLeastOneBackup":
            suggest = "keep_at_least_one_backup"
        elif key == "lastExecutionTime":
            suggest = "last_execution_time"
        elif key == "retentionPeriodDays":
            suggest = "retention_period_days"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppBackupSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppBackupSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppBackupSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_unit: str,
                 keep_at_least_one_backup: Optional[bool] = None,
                 last_execution_time: Optional[str] = None,
                 retention_period_days: Optional[int] = None,
                 start_time: Optional[str] = None):
        """
        :param int frequency_interval: How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).
               
               > **NOTE:** Not all intervals are supported on all Linux Web App SKUs. Please refer to the official documentation for appropriate values.
        :param str frequency_unit: The unit of time for how often the backup should take place. Possible values include: `Day`, `Hour`
        :param bool keep_at_least_one_backup: Should the service keep at least one backup, regardless of the age of backup? Defaults to `false`.
        :param int retention_period_days: After how many days backups should be deleted. Defaults to `30`.
        :param str start_time: When the schedule should start working in RFC-3339 format.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_unit", frequency_unit)
        if keep_at_least_one_backup is not None:
            pulumi.set(__self__, "keep_at_least_one_backup", keep_at_least_one_backup)
        if last_execution_time is not None:
            pulumi.set(__self__, "last_execution_time", last_execution_time)
        if retention_period_days is not None:
            pulumi.set(__self__, "retention_period_days", retention_period_days)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).

        > **NOTE:** Not all intervals are supported on all Linux Web App SKUs. Please refer to the official documentation for appropriate values.
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyUnit")
    def frequency_unit(self) -> str:
        """
        The unit of time for how often the backup should take place. Possible values include: `Day`, `Hour`
        """
        return pulumi.get(self, "frequency_unit")

    @property
    @pulumi.getter(name="keepAtLeastOneBackup")
    def keep_at_least_one_backup(self) -> Optional[bool]:
        """
        Should the service keep at least one backup, regardless of the age of backup? Defaults to `false`.
        """
        return pulumi.get(self, "keep_at_least_one_backup")

    @property
    @pulumi.getter(name="lastExecutionTime")
    def last_execution_time(self) -> Optional[str]:
        return pulumi.get(self, "last_execution_time")

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> Optional[int]:
        """
        After how many days backups should be deleted. Defaults to `30`.
        """
        return pulumi.get(self, "retention_period_days")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        """
        When the schedule should start working in RFC-3339 format.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class LinuxWebAppConnectionString(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: The name of the Connection String.
        :param str type: Type of database. Possible values include: `MySQL`, `SQLServer`, `SQLAzure`, `Custom`, `NotificationHub`, `ServiceBus`, `EventHub`, `APIHub`, `DocDb`, `RedisCache`, and `PostgreSQL`.
        :param str value: The connection string value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Connection String.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of database. Possible values include: `MySQL`, `SQLServer`, `SQLAzure`, `Custom`, `NotificationHub`, `ServiceBus`, `EventHub`, `APIHub`, `DocDb`, `RedisCache`, and `PostgreSQL`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The connection string value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class LinuxWebAppIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 identity_ids: Optional[Sequence[str]] = None,
                 principal_id: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str type: Specifies the type of Managed Service Identity that should be configured on this Linux Web App. Possible values are `SystemAssigned`, `UserAssigned`, and `SystemAssigned, UserAssigned` (to enable both).
        :param Sequence[str] identity_ids: A list of User Assigned Managed Identity IDs to be assigned to this Linux Web App.
               
               > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        :param str principal_id: The Principal ID associated with this Managed Service Identity.
        :param str tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the type of Managed Service Identity that should be configured on this Linux Web App. Possible values are `SystemAssigned`, `UserAssigned`, and `SystemAssigned, UserAssigned` (to enable both).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[str]]:
        """
        A list of User Assigned Managed Identity IDs to be assigned to this Linux Web App.

        > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class LinuxWebAppLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationLogs":
            suggest = "application_logs"
        elif key == "detailedErrorMessages":
            suggest = "detailed_error_messages"
        elif key == "failedRequestTracing":
            suggest = "failed_request_tracing"
        elif key == "httpLogs":
            suggest = "http_logs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_logs: Optional['outputs.LinuxWebAppLogsApplicationLogs'] = None,
                 detailed_error_messages: Optional[bool] = None,
                 failed_request_tracing: Optional[bool] = None,
                 http_logs: Optional['outputs.LinuxWebAppLogsHttpLogs'] = None):
        """
        :param 'LinuxWebAppLogsApplicationLogsArgs' application_logs: A `application_logs` block as defined above.
        :param bool detailed_error_messages: Should detailed error messages be enabled?
        :param bool failed_request_tracing: Should the failed request tracing be enabled?
        :param 'LinuxWebAppLogsHttpLogsArgs' http_logs: An `http_logs` block as defined above.
        """
        if application_logs is not None:
            pulumi.set(__self__, "application_logs", application_logs)
        if detailed_error_messages is not None:
            pulumi.set(__self__, "detailed_error_messages", detailed_error_messages)
        if failed_request_tracing is not None:
            pulumi.set(__self__, "failed_request_tracing", failed_request_tracing)
        if http_logs is not None:
            pulumi.set(__self__, "http_logs", http_logs)

    @property
    @pulumi.getter(name="applicationLogs")
    def application_logs(self) -> Optional['outputs.LinuxWebAppLogsApplicationLogs']:
        """
        A `application_logs` block as defined above.
        """
        return pulumi.get(self, "application_logs")

    @property
    @pulumi.getter(name="detailedErrorMessages")
    def detailed_error_messages(self) -> Optional[bool]:
        """
        Should detailed error messages be enabled?
        """
        return pulumi.get(self, "detailed_error_messages")

    @property
    @pulumi.getter(name="failedRequestTracing")
    def failed_request_tracing(self) -> Optional[bool]:
        """
        Should the failed request tracing be enabled?
        """
        return pulumi.get(self, "failed_request_tracing")

    @property
    @pulumi.getter(name="httpLogs")
    def http_logs(self) -> Optional['outputs.LinuxWebAppLogsHttpLogs']:
        """
        An `http_logs` block as defined above.
        """
        return pulumi.get(self, "http_logs")


@pulumi.output_type
class LinuxWebAppLogsApplicationLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileSystemLevel":
            suggest = "file_system_level"
        elif key == "azureBlobStorage":
            suggest = "azure_blob_storage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppLogsApplicationLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppLogsApplicationLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppLogsApplicationLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_system_level: str,
                 azure_blob_storage: Optional['outputs.LinuxWebAppLogsApplicationLogsAzureBlobStorage'] = None):
        """
        :param str file_system_level: Log level. Possible values include: `Verbose`, `Information`, `Warning`, and `Error`.
        :param 'LinuxWebAppLogsApplicationLogsAzureBlobStorageArgs' azure_blob_storage: An `azure_blob_storage` block as defined below.
        """
        pulumi.set(__self__, "file_system_level", file_system_level)
        if azure_blob_storage is not None:
            pulumi.set(__self__, "azure_blob_storage", azure_blob_storage)

    @property
    @pulumi.getter(name="fileSystemLevel")
    def file_system_level(self) -> str:
        """
        Log level. Possible values include: `Verbose`, `Information`, `Warning`, and `Error`.
        """
        return pulumi.get(self, "file_system_level")

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional['outputs.LinuxWebAppLogsApplicationLogsAzureBlobStorage']:
        """
        An `azure_blob_storage` block as defined below.
        """
        return pulumi.get(self, "azure_blob_storage")


@pulumi.output_type
class LinuxWebAppLogsApplicationLogsAzureBlobStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retentionInDays":
            suggest = "retention_in_days"
        elif key == "sasUrl":
            suggest = "sas_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppLogsApplicationLogsAzureBlobStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppLogsApplicationLogsAzureBlobStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppLogsApplicationLogsAzureBlobStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 level: str,
                 retention_in_days: int,
                 sas_url: str):
        """
        :param str level: The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        :param int retention_in_days: The time in days after which to remove blobs. A value of `0` means no retention.
        :param str sas_url: SAS url to an Azure blob container with read/write/list/delete permissions.
        """
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "sas_url", sas_url)

    @property
    @pulumi.getter
    def level(self) -> str:
        """
        The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        """
        return pulumi.get(self, "level")

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> int:
        """
        The time in days after which to remove blobs. A value of `0` means no retention.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> str:
        """
        SAS url to an Azure blob container with read/write/list/delete permissions.
        """
        return pulumi.get(self, "sas_url")


@pulumi.output_type
class LinuxWebAppLogsHttpLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureBlobStorage":
            suggest = "azure_blob_storage"
        elif key == "fileSystem":
            suggest = "file_system"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppLogsHttpLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppLogsHttpLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppLogsHttpLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_blob_storage: Optional['outputs.LinuxWebAppLogsHttpLogsAzureBlobStorage'] = None,
                 file_system: Optional['outputs.LinuxWebAppLogsHttpLogsFileSystem'] = None):
        """
        :param 'LinuxWebAppLogsHttpLogsAzureBlobStorageArgs' azure_blob_storage: A `azure_blob_storage_http` block as defined below.
        :param 'LinuxWebAppLogsHttpLogsFileSystemArgs' file_system: A `file_system` block as defined above.
        """
        if azure_blob_storage is not None:
            pulumi.set(__self__, "azure_blob_storage", azure_blob_storage)
        if file_system is not None:
            pulumi.set(__self__, "file_system", file_system)

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional['outputs.LinuxWebAppLogsHttpLogsAzureBlobStorage']:
        """
        A `azure_blob_storage_http` block as defined below.
        """
        return pulumi.get(self, "azure_blob_storage")

    @property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional['outputs.LinuxWebAppLogsHttpLogsFileSystem']:
        """
        A `file_system` block as defined above.
        """
        return pulumi.get(self, "file_system")


@pulumi.output_type
class LinuxWebAppLogsHttpLogsAzureBlobStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sasUrl":
            suggest = "sas_url"
        elif key == "retentionInDays":
            suggest = "retention_in_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppLogsHttpLogsAzureBlobStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppLogsHttpLogsAzureBlobStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppLogsHttpLogsAzureBlobStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sas_url: str,
                 retention_in_days: Optional[int] = None):
        """
        :param str sas_url: SAS url to an Azure blob container with read/write/list/delete permissions.
        :param int retention_in_days: The time in days after which to remove blobs. A value of `0` means no retention.
        """
        pulumi.set(__self__, "sas_url", sas_url)
        if retention_in_days is not None:
            pulumi.set(__self__, "retention_in_days", retention_in_days)

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> str:
        """
        SAS url to an Azure blob container with read/write/list/delete permissions.
        """
        return pulumi.get(self, "sas_url")

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> Optional[int]:
        """
        The time in days after which to remove blobs. A value of `0` means no retention.
        """
        return pulumi.get(self, "retention_in_days")


@pulumi.output_type
class LinuxWebAppLogsHttpLogsFileSystem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retentionInDays":
            suggest = "retention_in_days"
        elif key == "retentionInMb":
            suggest = "retention_in_mb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppLogsHttpLogsFileSystem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppLogsHttpLogsFileSystem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppLogsHttpLogsFileSystem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 retention_in_days: int,
                 retention_in_mb: int):
        """
        :param int retention_in_days: The retention period in days. A value of `0` means no retention.
        :param int retention_in_mb: The maximum size in megabytes that log files can use.
        """
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "retention_in_mb", retention_in_mb)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> int:
        """
        The retention period in days. A value of `0` means no retention.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="retentionInMb")
    def retention_in_mb(self) -> int:
        """
        The maximum size in megabytes that log files can use.
        """
        return pulumi.get(self, "retention_in_mb")


@pulumi.output_type
class LinuxWebAppSiteConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alwaysOn":
            suggest = "always_on"
        elif key == "apiDefinitionUrl":
            suggest = "api_definition_url"
        elif key == "apiManagementApiId":
            suggest = "api_management_api_id"
        elif key == "appCommandLine":
            suggest = "app_command_line"
        elif key == "applicationStack":
            suggest = "application_stack"
        elif key == "autoHealEnabled":
            suggest = "auto_heal_enabled"
        elif key == "autoHealSetting":
            suggest = "auto_heal_setting"
        elif key == "containerRegistryManagedIdentityClientId":
            suggest = "container_registry_managed_identity_client_id"
        elif key == "containerRegistryUseManagedIdentity":
            suggest = "container_registry_use_managed_identity"
        elif key == "defaultDocuments":
            suggest = "default_documents"
        elif key == "detailedErrorLoggingEnabled":
            suggest = "detailed_error_logging_enabled"
        elif key == "ftpsState":
            suggest = "ftps_state"
        elif key == "healthCheckEvictionTimeInMin":
            suggest = "health_check_eviction_time_in_min"
        elif key == "healthCheckPath":
            suggest = "health_check_path"
        elif key == "http2Enabled":
            suggest = "http2_enabled"
        elif key == "ipRestrictions":
            suggest = "ip_restrictions"
        elif key == "linuxFxVersion":
            suggest = "linux_fx_version"
        elif key == "loadBalancingMode":
            suggest = "load_balancing_mode"
        elif key == "localMysqlEnabled":
            suggest = "local_mysql_enabled"
        elif key == "managedPipelineMode":
            suggest = "managed_pipeline_mode"
        elif key == "minimumTlsVersion":
            suggest = "minimum_tls_version"
        elif key == "remoteDebuggingEnabled":
            suggest = "remote_debugging_enabled"
        elif key == "remoteDebuggingVersion":
            suggest = "remote_debugging_version"
        elif key == "scmIpRestrictions":
            suggest = "scm_ip_restrictions"
        elif key == "scmMinimumTlsVersion":
            suggest = "scm_minimum_tls_version"
        elif key == "scmType":
            suggest = "scm_type"
        elif key == "scmUseMainIpRestriction":
            suggest = "scm_use_main_ip_restriction"
        elif key == "use32BitWorker":
            suggest = "use32_bit_worker"
        elif key == "vnetRouteAllEnabled":
            suggest = "vnet_route_all_enabled"
        elif key == "websocketsEnabled":
            suggest = "websockets_enabled"
        elif key == "workerCount":
            suggest = "worker_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSiteConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSiteConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSiteConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 always_on: Optional[bool] = None,
                 api_definition_url: Optional[str] = None,
                 api_management_api_id: Optional[str] = None,
                 app_command_line: Optional[str] = None,
                 application_stack: Optional['outputs.LinuxWebAppSiteConfigApplicationStack'] = None,
                 auto_heal_enabled: Optional[bool] = None,
                 auto_heal_setting: Optional['outputs.LinuxWebAppSiteConfigAutoHealSetting'] = None,
                 container_registry_managed_identity_client_id: Optional[str] = None,
                 container_registry_use_managed_identity: Optional[bool] = None,
                 cors: Optional['outputs.LinuxWebAppSiteConfigCors'] = None,
                 default_documents: Optional[Sequence[str]] = None,
                 detailed_error_logging_enabled: Optional[bool] = None,
                 ftps_state: Optional[str] = None,
                 health_check_eviction_time_in_min: Optional[int] = None,
                 health_check_path: Optional[str] = None,
                 http2_enabled: Optional[bool] = None,
                 ip_restrictions: Optional[Sequence['outputs.LinuxWebAppSiteConfigIpRestriction']] = None,
                 linux_fx_version: Optional[str] = None,
                 load_balancing_mode: Optional[str] = None,
                 local_mysql_enabled: Optional[bool] = None,
                 managed_pipeline_mode: Optional[str] = None,
                 minimum_tls_version: Optional[str] = None,
                 remote_debugging_enabled: Optional[bool] = None,
                 remote_debugging_version: Optional[str] = None,
                 scm_ip_restrictions: Optional[Sequence['outputs.LinuxWebAppSiteConfigScmIpRestriction']] = None,
                 scm_minimum_tls_version: Optional[str] = None,
                 scm_type: Optional[str] = None,
                 scm_use_main_ip_restriction: Optional[bool] = None,
                 use32_bit_worker: Optional[bool] = None,
                 vnet_route_all_enabled: Optional[bool] = None,
                 websockets_enabled: Optional[bool] = None,
                 worker_count: Optional[int] = None):
        """
        :param bool always_on: If this Linux Web App is Always On enabled. Defaults to `true`.
               
               > **NOTE:** `always_on` must be explicitly set to `false` when using `Free`, `F1`, `D1`, or `Shared` Service Plans.
        :param str api_definition_url: The URL to the API Definition for this Linux Web App.
        :param str api_management_api_id: The API Management API ID this Linux Web App is associated with.
        :param str app_command_line: The App command line to launch.
        :param 'LinuxWebAppSiteConfigApplicationStackArgs' application_stack: A `application_stack` block as defined above.
        :param bool auto_heal_enabled: Should Auto heal rules be enabled? Required with `auto_heal_setting`.
        :param 'LinuxWebAppSiteConfigAutoHealSettingArgs' auto_heal_setting: A `auto_heal_setting` block as defined above. Required with `auto_heal`.
        :param str container_registry_managed_identity_client_id: The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
        :param bool container_registry_use_managed_identity: Should connections for Azure Container Registry use Managed Identity.
        :param 'LinuxWebAppSiteConfigCorsArgs' cors: A `cors` block as defined above.
        :param Sequence[str] default_documents: Specifies a list of Default Documents for the Linux Web App.
        :param int health_check_eviction_time_in_min: The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        :param str health_check_path: The path to the Health Check.
        :param bool http2_enabled: Should the HTTP2 be enabled?
        :param Sequence['LinuxWebAppSiteConfigIpRestrictionArgs'] ip_restrictions: One or more `ip_restriction` blocks as defined above.
        :param str load_balancing_mode: The Site load balancing. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        :param bool local_mysql_enabled: Use Local MySQL. Defaults to `false`.
        :param str managed_pipeline_mode: Managed pipeline mode. Possible values include `Integrated`, and `Classic`.
        :param str minimum_tls_version: The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        :param bool remote_debugging_enabled: Should Remote Debugging be enabled? Defaults to `false`.
        :param str remote_debugging_version: The Remote Debugging Version. Possible values include `VS2017` and `VS2019`
        :param Sequence['LinuxWebAppSiteConfigScmIpRestrictionArgs'] scm_ip_restrictions: One or more `scm_ip_restriction` blocks as defined above.
        :param str scm_minimum_tls_version: The configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        :param bool scm_use_main_ip_restriction: Should the Linux Web App `ip_restriction` configuration be used for the SCM also.
        :param bool use32_bit_worker: Should the Linux Web App use a 32-bit worker? Defaults to `true`.
        :param bool vnet_route_all_enabled: Should all outbound traffic have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        :param bool websockets_enabled: Should Web Sockets be enabled? Defaults to `false`.
        :param int worker_count: The number of Workers for this Linux App Service.
        """
        if always_on is not None:
            pulumi.set(__self__, "always_on", always_on)
        if api_definition_url is not None:
            pulumi.set(__self__, "api_definition_url", api_definition_url)
        if api_management_api_id is not None:
            pulumi.set(__self__, "api_management_api_id", api_management_api_id)
        if app_command_line is not None:
            pulumi.set(__self__, "app_command_line", app_command_line)
        if application_stack is not None:
            pulumi.set(__self__, "application_stack", application_stack)
        if auto_heal_enabled is not None:
            pulumi.set(__self__, "auto_heal_enabled", auto_heal_enabled)
        if auto_heal_setting is not None:
            pulumi.set(__self__, "auto_heal_setting", auto_heal_setting)
        if container_registry_managed_identity_client_id is not None:
            pulumi.set(__self__, "container_registry_managed_identity_client_id", container_registry_managed_identity_client_id)
        if container_registry_use_managed_identity is not None:
            pulumi.set(__self__, "container_registry_use_managed_identity", container_registry_use_managed_identity)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if default_documents is not None:
            pulumi.set(__self__, "default_documents", default_documents)
        if detailed_error_logging_enabled is not None:
            pulumi.set(__self__, "detailed_error_logging_enabled", detailed_error_logging_enabled)
        if ftps_state is not None:
            pulumi.set(__self__, "ftps_state", ftps_state)
        if health_check_eviction_time_in_min is not None:
            pulumi.set(__self__, "health_check_eviction_time_in_min", health_check_eviction_time_in_min)
        if health_check_path is not None:
            pulumi.set(__self__, "health_check_path", health_check_path)
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if ip_restrictions is not None:
            pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        if linux_fx_version is not None:
            pulumi.set(__self__, "linux_fx_version", linux_fx_version)
        if load_balancing_mode is not None:
            pulumi.set(__self__, "load_balancing_mode", load_balancing_mode)
        if local_mysql_enabled is not None:
            pulumi.set(__self__, "local_mysql_enabled", local_mysql_enabled)
        if managed_pipeline_mode is not None:
            pulumi.set(__self__, "managed_pipeline_mode", managed_pipeline_mode)
        if minimum_tls_version is not None:
            pulumi.set(__self__, "minimum_tls_version", minimum_tls_version)
        if remote_debugging_enabled is not None:
            pulumi.set(__self__, "remote_debugging_enabled", remote_debugging_enabled)
        if remote_debugging_version is not None:
            pulumi.set(__self__, "remote_debugging_version", remote_debugging_version)
        if scm_ip_restrictions is not None:
            pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        if scm_minimum_tls_version is not None:
            pulumi.set(__self__, "scm_minimum_tls_version", scm_minimum_tls_version)
        if scm_type is not None:
            pulumi.set(__self__, "scm_type", scm_type)
        if scm_use_main_ip_restriction is not None:
            pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        if use32_bit_worker is not None:
            pulumi.set(__self__, "use32_bit_worker", use32_bit_worker)
        if vnet_route_all_enabled is not None:
            pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        if websockets_enabled is not None:
            pulumi.set(__self__, "websockets_enabled", websockets_enabled)
        if worker_count is not None:
            pulumi.set(__self__, "worker_count", worker_count)

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> Optional[bool]:
        """
        If this Linux Web App is Always On enabled. Defaults to `true`.

        > **NOTE:** `always_on` must be explicitly set to `false` when using `Free`, `F1`, `D1`, or `Shared` Service Plans.
        """
        return pulumi.get(self, "always_on")

    @property
    @pulumi.getter(name="apiDefinitionUrl")
    def api_definition_url(self) -> Optional[str]:
        """
        The URL to the API Definition for this Linux Web App.
        """
        return pulumi.get(self, "api_definition_url")

    @property
    @pulumi.getter(name="apiManagementApiId")
    def api_management_api_id(self) -> Optional[str]:
        """
        The API Management API ID this Linux Web App is associated with.
        """
        return pulumi.get(self, "api_management_api_id")

    @property
    @pulumi.getter(name="appCommandLine")
    def app_command_line(self) -> Optional[str]:
        """
        The App command line to launch.
        """
        return pulumi.get(self, "app_command_line")

    @property
    @pulumi.getter(name="applicationStack")
    def application_stack(self) -> Optional['outputs.LinuxWebAppSiteConfigApplicationStack']:
        """
        A `application_stack` block as defined above.
        """
        return pulumi.get(self, "application_stack")

    @property
    @pulumi.getter(name="autoHealEnabled")
    def auto_heal_enabled(self) -> Optional[bool]:
        """
        Should Auto heal rules be enabled? Required with `auto_heal_setting`.
        """
        return pulumi.get(self, "auto_heal_enabled")

    @property
    @pulumi.getter(name="autoHealSetting")
    def auto_heal_setting(self) -> Optional['outputs.LinuxWebAppSiteConfigAutoHealSetting']:
        """
        A `auto_heal_setting` block as defined above. Required with `auto_heal`.
        """
        return pulumi.get(self, "auto_heal_setting")

    @property
    @pulumi.getter(name="containerRegistryManagedIdentityClientId")
    def container_registry_managed_identity_client_id(self) -> Optional[str]:
        """
        The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
        """
        return pulumi.get(self, "container_registry_managed_identity_client_id")

    @property
    @pulumi.getter(name="containerRegistryUseManagedIdentity")
    def container_registry_use_managed_identity(self) -> Optional[bool]:
        """
        Should connections for Azure Container Registry use Managed Identity.
        """
        return pulumi.get(self, "container_registry_use_managed_identity")

    @property
    @pulumi.getter
    def cors(self) -> Optional['outputs.LinuxWebAppSiteConfigCors']:
        """
        A `cors` block as defined above.
        """
        return pulumi.get(self, "cors")

    @property
    @pulumi.getter(name="defaultDocuments")
    def default_documents(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Default Documents for the Linux Web App.
        """
        return pulumi.get(self, "default_documents")

    @property
    @pulumi.getter(name="detailedErrorLoggingEnabled")
    def detailed_error_logging_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "detailed_error_logging_enabled")

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> Optional[str]:
        return pulumi.get(self, "ftps_state")

    @property
    @pulumi.getter(name="healthCheckEvictionTimeInMin")
    def health_check_eviction_time_in_min(self) -> Optional[int]:
        """
        The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        """
        return pulumi.get(self, "health_check_eviction_time_in_min")

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> Optional[str]:
        """
        The path to the Health Check.
        """
        return pulumi.get(self, "health_check_path")

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[bool]:
        """
        Should the HTTP2 be enabled?
        """
        return pulumi.get(self, "http2_enabled")

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Optional[Sequence['outputs.LinuxWebAppSiteConfigIpRestriction']]:
        """
        One or more `ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "ip_restrictions")

    @property
    @pulumi.getter(name="linuxFxVersion")
    def linux_fx_version(self) -> Optional[str]:
        return pulumi.get(self, "linux_fx_version")

    @property
    @pulumi.getter(name="loadBalancingMode")
    def load_balancing_mode(self) -> Optional[str]:
        """
        The Site load balancing. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        """
        return pulumi.get(self, "load_balancing_mode")

    @property
    @pulumi.getter(name="localMysqlEnabled")
    def local_mysql_enabled(self) -> Optional[bool]:
        """
        Use Local MySQL. Defaults to `false`.
        """
        return pulumi.get(self, "local_mysql_enabled")

    @property
    @pulumi.getter(name="managedPipelineMode")
    def managed_pipeline_mode(self) -> Optional[str]:
        """
        Managed pipeline mode. Possible values include `Integrated`, and `Classic`.
        """
        return pulumi.get(self, "managed_pipeline_mode")

    @property
    @pulumi.getter(name="minimumTlsVersion")
    def minimum_tls_version(self) -> Optional[str]:
        """
        The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        """
        return pulumi.get(self, "minimum_tls_version")

    @property
    @pulumi.getter(name="remoteDebuggingEnabled")
    def remote_debugging_enabled(self) -> Optional[bool]:
        """
        Should Remote Debugging be enabled? Defaults to `false`.
        """
        return pulumi.get(self, "remote_debugging_enabled")

    @property
    @pulumi.getter(name="remoteDebuggingVersion")
    def remote_debugging_version(self) -> Optional[str]:
        """
        The Remote Debugging Version. Possible values include `VS2017` and `VS2019`
        """
        return pulumi.get(self, "remote_debugging_version")

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Optional[Sequence['outputs.LinuxWebAppSiteConfigScmIpRestriction']]:
        """
        One or more `scm_ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "scm_ip_restrictions")

    @property
    @pulumi.getter(name="scmMinimumTlsVersion")
    def scm_minimum_tls_version(self) -> Optional[str]:
        """
        The configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        """
        return pulumi.get(self, "scm_minimum_tls_version")

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> Optional[str]:
        return pulumi.get(self, "scm_type")

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> Optional[bool]:
        """
        Should the Linux Web App `ip_restriction` configuration be used for the SCM also.
        """
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @property
    @pulumi.getter(name="use32BitWorker")
    def use32_bit_worker(self) -> Optional[bool]:
        """
        Should the Linux Web App use a 32-bit worker? Defaults to `true`.
        """
        return pulumi.get(self, "use32_bit_worker")

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> Optional[bool]:
        """
        Should all outbound traffic have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        """
        return pulumi.get(self, "vnet_route_all_enabled")

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> Optional[bool]:
        """
        Should Web Sockets be enabled? Defaults to `false`.
        """
        return pulumi.get(self, "websockets_enabled")

    @property
    @pulumi.getter(name="workerCount")
    def worker_count(self) -> Optional[int]:
        """
        The number of Workers for this Linux App Service.
        """
        return pulumi.get(self, "worker_count")


@pulumi.output_type
class LinuxWebAppSiteConfigApplicationStack(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dockerImage":
            suggest = "docker_image"
        elif key == "dockerImageName":
            suggest = "docker_image_name"
        elif key == "dockerImageTag":
            suggest = "docker_image_tag"
        elif key == "dockerRegistryPassword":
            suggest = "docker_registry_password"
        elif key == "dockerRegistryUrl":
            suggest = "docker_registry_url"
        elif key == "dockerRegistryUsername":
            suggest = "docker_registry_username"
        elif key == "dotnetVersion":
            suggest = "dotnet_version"
        elif key == "goVersion":
            suggest = "go_version"
        elif key == "javaServer":
            suggest = "java_server"
        elif key == "javaServerVersion":
            suggest = "java_server_version"
        elif key == "javaVersion":
            suggest = "java_version"
        elif key == "nodeVersion":
            suggest = "node_version"
        elif key == "phpVersion":
            suggest = "php_version"
        elif key == "pythonVersion":
            suggest = "python_version"
        elif key == "rubyVersion":
            suggest = "ruby_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSiteConfigApplicationStack. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSiteConfigApplicationStack.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSiteConfigApplicationStack.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 docker_image: Optional[str] = None,
                 docker_image_name: Optional[str] = None,
                 docker_image_tag: Optional[str] = None,
                 docker_registry_password: Optional[str] = None,
                 docker_registry_url: Optional[str] = None,
                 docker_registry_username: Optional[str] = None,
                 dotnet_version: Optional[str] = None,
                 go_version: Optional[str] = None,
                 java_server: Optional[str] = None,
                 java_server_version: Optional[str] = None,
                 java_version: Optional[str] = None,
                 node_version: Optional[str] = None,
                 php_version: Optional[str] = None,
                 python_version: Optional[str] = None,
                 ruby_version: Optional[str] = None):
        """
        :param str docker_image_name: The docker image, including tag, to be used. e.g. `appsvc/staticsite:latest`.
        :param str docker_registry_password: The User Name to use for authentication against the registry to pull the image.
               
               > **NOTE:** `docker_registry_url`, `docker_registry_username`, and `docker_registry_password` replace the use of the `app_settings` values of `DOCKER_REGISTRY_SERVER_URL`, `DOCKER_REGISTRY_SERVER_USERNAME` and `DOCKER_REGISTRY_SERVER_PASSWORD` respectively, these values will be managed by the provider and should not be specified in the `app_settings` map.
        :param str docker_registry_url: The URL of the container registry where the `docker_image_name` is located. e.g. `https://index.docker.io` or `https://mcr.microsoft.com`. This value is required with `docker_image_name`.
        :param str docker_registry_username: The User Name to use for authentication against the registry to pull the image.
        :param str dotnet_version: The version of .NET to use. Possible values include `3.1`, `5.0`, `6.0` and `7.0`.
        :param str go_version: The version of Go to use. Possible values include `1.18`, and `1.19`.
        :param str java_server: The Java server type. Possible values include `JAVA`, `TOMCAT`, and `JBOSSEAP`.
               
               > **NOTE:** `JBOSSEAP` requires a Premium Service Plan SKU to be a valid option.
        :param str java_server_version: The Version of the `java_server` to use.
        :param str java_version: The Version of Java to use. Possible values include `8`, `11`, and `17`.
               
               > **NOTE:** The valid version combinations for `java_version`, `java_server` and `java_server_version` can be checked from the command line via `az webapp list-runtimes --linux`.
        :param str node_version: The version of Node to run. Possible values include `12-lts`, `14-lts`, `16-lts`, and `18-lts`. This property conflicts with `java_version`.
               
               > **NOTE:** 10.x versions have been/are being deprecated so may cease to work for new resources in the future and may be removed from the provider.
        :param str php_version: The version of PHP to run. Possible values are `8.0`, `8.1` and `8.2`.
               
               > **NOTE:** version `7.4` is deprecated and will be removed from the provider in a future version.
        :param str python_version: The version of Python to run. Possible values include `3.7`, `3.8`, `3.9`, `3.10` and `3.11`.
        :param str ruby_version: Te version of Ruby to run. Possible values include `2.6` and `2.7`.
        """
        if docker_image is not None:
            pulumi.set(__self__, "docker_image", docker_image)
        if docker_image_name is not None:
            pulumi.set(__self__, "docker_image_name", docker_image_name)
        if docker_image_tag is not None:
            pulumi.set(__self__, "docker_image_tag", docker_image_tag)
        if docker_registry_password is not None:
            pulumi.set(__self__, "docker_registry_password", docker_registry_password)
        if docker_registry_url is not None:
            pulumi.set(__self__, "docker_registry_url", docker_registry_url)
        if docker_registry_username is not None:
            pulumi.set(__self__, "docker_registry_username", docker_registry_username)
        if dotnet_version is not None:
            pulumi.set(__self__, "dotnet_version", dotnet_version)
        if go_version is not None:
            pulumi.set(__self__, "go_version", go_version)
        if java_server is not None:
            pulumi.set(__self__, "java_server", java_server)
        if java_server_version is not None:
            pulumi.set(__self__, "java_server_version", java_server_version)
        if java_version is not None:
            pulumi.set(__self__, "java_version", java_version)
        if node_version is not None:
            pulumi.set(__self__, "node_version", node_version)
        if php_version is not None:
            pulumi.set(__self__, "php_version", php_version)
        if python_version is not None:
            pulumi.set(__self__, "python_version", python_version)
        if ruby_version is not None:
            pulumi.set(__self__, "ruby_version", ruby_version)

    @property
    @pulumi.getter(name="dockerImage")
    def docker_image(self) -> Optional[str]:
        warnings.warn("""This property has been deprecated and will be removed in 4.0 of the provider.""", DeprecationWarning)
        pulumi.log.warn("""docker_image is deprecated: This property has been deprecated and will be removed in 4.0 of the provider.""")

        return pulumi.get(self, "docker_image")

    @property
    @pulumi.getter(name="dockerImageName")
    def docker_image_name(self) -> Optional[str]:
        """
        The docker image, including tag, to be used. e.g. `appsvc/staticsite:latest`.
        """
        return pulumi.get(self, "docker_image_name")

    @property
    @pulumi.getter(name="dockerImageTag")
    def docker_image_tag(self) -> Optional[str]:
        warnings.warn("""This property has been deprecated and will be removed in 4.0 of the provider.""", DeprecationWarning)
        pulumi.log.warn("""docker_image_tag is deprecated: This property has been deprecated and will be removed in 4.0 of the provider.""")

        return pulumi.get(self, "docker_image_tag")

    @property
    @pulumi.getter(name="dockerRegistryPassword")
    def docker_registry_password(self) -> Optional[str]:
        """
        The User Name to use for authentication against the registry to pull the image.

        > **NOTE:** `docker_registry_url`, `docker_registry_username`, and `docker_registry_password` replace the use of the `app_settings` values of `DOCKER_REGISTRY_SERVER_URL`, `DOCKER_REGISTRY_SERVER_USERNAME` and `DOCKER_REGISTRY_SERVER_PASSWORD` respectively, these values will be managed by the provider and should not be specified in the `app_settings` map.
        """
        return pulumi.get(self, "docker_registry_password")

    @property
    @pulumi.getter(name="dockerRegistryUrl")
    def docker_registry_url(self) -> Optional[str]:
        """
        The URL of the container registry where the `docker_image_name` is located. e.g. `https://index.docker.io` or `https://mcr.microsoft.com`. This value is required with `docker_image_name`.
        """
        return pulumi.get(self, "docker_registry_url")

    @property
    @pulumi.getter(name="dockerRegistryUsername")
    def docker_registry_username(self) -> Optional[str]:
        """
        The User Name to use for authentication against the registry to pull the image.
        """
        return pulumi.get(self, "docker_registry_username")

    @property
    @pulumi.getter(name="dotnetVersion")
    def dotnet_version(self) -> Optional[str]:
        """
        The version of .NET to use. Possible values include `3.1`, `5.0`, `6.0` and `7.0`.
        """
        return pulumi.get(self, "dotnet_version")

    @property
    @pulumi.getter(name="goVersion")
    def go_version(self) -> Optional[str]:
        """
        The version of Go to use. Possible values include `1.18`, and `1.19`.
        """
        return pulumi.get(self, "go_version")

    @property
    @pulumi.getter(name="javaServer")
    def java_server(self) -> Optional[str]:
        """
        The Java server type. Possible values include `JAVA`, `TOMCAT`, and `JBOSSEAP`.

        > **NOTE:** `JBOSSEAP` requires a Premium Service Plan SKU to be a valid option.
        """
        return pulumi.get(self, "java_server")

    @property
    @pulumi.getter(name="javaServerVersion")
    def java_server_version(self) -> Optional[str]:
        """
        The Version of the `java_server` to use.
        """
        return pulumi.get(self, "java_server_version")

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> Optional[str]:
        """
        The Version of Java to use. Possible values include `8`, `11`, and `17`.

        > **NOTE:** The valid version combinations for `java_version`, `java_server` and `java_server_version` can be checked from the command line via `az webapp list-runtimes --linux`.
        """
        return pulumi.get(self, "java_version")

    @property
    @pulumi.getter(name="nodeVersion")
    def node_version(self) -> Optional[str]:
        """
        The version of Node to run. Possible values include `12-lts`, `14-lts`, `16-lts`, and `18-lts`. This property conflicts with `java_version`.

        > **NOTE:** 10.x versions have been/are being deprecated so may cease to work for new resources in the future and may be removed from the provider.
        """
        return pulumi.get(self, "node_version")

    @property
    @pulumi.getter(name="phpVersion")
    def php_version(self) -> Optional[str]:
        """
        The version of PHP to run. Possible values are `8.0`, `8.1` and `8.2`.

        > **NOTE:** version `7.4` is deprecated and will be removed from the provider in a future version.
        """
        return pulumi.get(self, "php_version")

    @property
    @pulumi.getter(name="pythonVersion")
    def python_version(self) -> Optional[str]:
        """
        The version of Python to run. Possible values include `3.7`, `3.8`, `3.9`, `3.10` and `3.11`.
        """
        return pulumi.get(self, "python_version")

    @property
    @pulumi.getter(name="rubyVersion")
    def ruby_version(self) -> Optional[str]:
        """
        Te version of Ruby to run. Possible values include `2.6` and `2.7`.
        """
        return pulumi.get(self, "ruby_version")


@pulumi.output_type
class LinuxWebAppSiteConfigAutoHealSetting(dict):
    def __init__(__self__, *,
                 action: Optional['outputs.LinuxWebAppSiteConfigAutoHealSettingAction'] = None,
                 trigger: Optional['outputs.LinuxWebAppSiteConfigAutoHealSettingTrigger'] = None):
        """
        :param 'LinuxWebAppSiteConfigAutoHealSettingActionArgs' action: A `action` block as defined above.
        :param 'LinuxWebAppSiteConfigAutoHealSettingTriggerArgs' trigger: A `trigger` block as defined below.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if trigger is not None:
            pulumi.set(__self__, "trigger", trigger)

    @property
    @pulumi.getter
    def action(self) -> Optional['outputs.LinuxWebAppSiteConfigAutoHealSettingAction']:
        """
        A `action` block as defined above.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def trigger(self) -> Optional['outputs.LinuxWebAppSiteConfigAutoHealSettingTrigger']:
        """
        A `trigger` block as defined below.
        """
        return pulumi.get(self, "trigger")


@pulumi.output_type
class LinuxWebAppSiteConfigAutoHealSettingAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionType":
            suggest = "action_type"
        elif key == "minimumProcessExecutionTime":
            suggest = "minimum_process_execution_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSiteConfigAutoHealSettingAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSiteConfigAutoHealSettingAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSiteConfigAutoHealSettingAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_type: str,
                 minimum_process_execution_time: Optional[str] = None):
        """
        :param str action_type: Predefined action to be taken to an Auto Heal trigger. Possible values include: `Recycle`.
        :param str minimum_process_execution_time: The minimum amount of time in `hh:mm:ss` the Linux Web App must have been running before the defined action will be run in the event of a trigger.
        """
        pulumi.set(__self__, "action_type", action_type)
        if minimum_process_execution_time is not None:
            pulumi.set(__self__, "minimum_process_execution_time", minimum_process_execution_time)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> str:
        """
        Predefined action to be taken to an Auto Heal trigger. Possible values include: `Recycle`.
        """
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter(name="minimumProcessExecutionTime")
    def minimum_process_execution_time(self) -> Optional[str]:
        """
        The minimum amount of time in `hh:mm:ss` the Linux Web App must have been running before the defined action will be run in the event of a trigger.
        """
        return pulumi.get(self, "minimum_process_execution_time")


@pulumi.output_type
class LinuxWebAppSiteConfigAutoHealSettingTrigger(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slowRequests":
            suggest = "slow_requests"
        elif key == "statusCodes":
            suggest = "status_codes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSiteConfigAutoHealSettingTrigger. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSiteConfigAutoHealSettingTrigger.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSiteConfigAutoHealSettingTrigger.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 requests: Optional['outputs.LinuxWebAppSiteConfigAutoHealSettingTriggerRequests'] = None,
                 slow_requests: Optional[Sequence['outputs.LinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequest']] = None,
                 status_codes: Optional[Sequence['outputs.LinuxWebAppSiteConfigAutoHealSettingTriggerStatusCode']] = None):
        """
        :param 'LinuxWebAppSiteConfigAutoHealSettingTriggerRequestsArgs' requests: A `requests` block as defined above.
        :param Sequence['LinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequestArgs'] slow_requests: One or more `slow_request` blocks as defined above.
        :param Sequence['LinuxWebAppSiteConfigAutoHealSettingTriggerStatusCodeArgs'] status_codes: One or more `status_code` blocks as defined above.
        """
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if slow_requests is not None:
            pulumi.set(__self__, "slow_requests", slow_requests)
        if status_codes is not None:
            pulumi.set(__self__, "status_codes", status_codes)

    @property
    @pulumi.getter
    def requests(self) -> Optional['outputs.LinuxWebAppSiteConfigAutoHealSettingTriggerRequests']:
        """
        A `requests` block as defined above.
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="slowRequests")
    def slow_requests(self) -> Optional[Sequence['outputs.LinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequest']]:
        """
        One or more `slow_request` blocks as defined above.
        """
        return pulumi.get(self, "slow_requests")

    @property
    @pulumi.getter(name="statusCodes")
    def status_codes(self) -> Optional[Sequence['outputs.LinuxWebAppSiteConfigAutoHealSettingTriggerStatusCode']]:
        """
        One or more `status_code` blocks as defined above.
        """
        return pulumi.get(self, "status_codes")


@pulumi.output_type
class LinuxWebAppSiteConfigAutoHealSettingTriggerRequests(dict):
    def __init__(__self__, *,
                 count: int,
                 interval: str):
        """
        :param int count: The number of requests in the specified `interval` to trigger this rule.
        :param str interval: The interval in `hh:mm:ss`.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of requests in the specified `interval` to trigger this rule.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        The interval in `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class LinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeTaken":
            suggest = "time_taken"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: int,
                 interval: str,
                 time_taken: str,
                 path: Optional[str] = None):
        """
        :param int count: The number of Slow Requests in the time `interval` to trigger this rule.
        :param str interval: The time interval in the form `hh:mm:ss`.
        :param str time_taken: The threshold of time passed to qualify as a Slow Request in `hh:mm:ss`.
        :param str path: The path for which this slow request rule applies.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "time_taken", time_taken)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of Slow Requests in the time `interval` to trigger this rule.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        The time interval in the form `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="timeTaken")
    def time_taken(self) -> str:
        """
        The threshold of time passed to qualify as a Slow Request in `hh:mm:ss`.
        """
        return pulumi.get(self, "time_taken")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path for which this slow request rule applies.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class LinuxWebAppSiteConfigAutoHealSettingTriggerStatusCode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusCodeRange":
            suggest = "status_code_range"
        elif key == "subStatus":
            suggest = "sub_status"
        elif key == "win32StatusCode":
            suggest = "win32_status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSiteConfigAutoHealSettingTriggerStatusCode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSiteConfigAutoHealSettingTriggerStatusCode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSiteConfigAutoHealSettingTriggerStatusCode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: int,
                 interval: str,
                 status_code_range: str,
                 path: Optional[str] = None,
                 sub_status: Optional[int] = None,
                 win32_status_code: Optional[int] = None):
        """
        :param int count: The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        :param str interval: The time interval in the form `hh:mm:ss`.
        :param str status_code_range: The status code for this rule, accepts single status codes and status code ranges. e.g. `500` or `400-499`. Possible values are integers between `101` and `599`
        :param str path: The path to which this rule status code applies.
        :param int sub_status: The Request Sub Status of the Status Code.
        :param int win32_status_code: The Win32 Status Code of the Request.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "status_code_range", status_code_range)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if sub_status is not None:
            pulumi.set(__self__, "sub_status", sub_status)
        if win32_status_code is not None:
            pulumi.set(__self__, "win32_status_code", win32_status_code)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        The time interval in the form `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="statusCodeRange")
    def status_code_range(self) -> str:
        """
        The status code for this rule, accepts single status codes and status code ranges. e.g. `500` or `400-499`. Possible values are integers between `101` and `599`
        """
        return pulumi.get(self, "status_code_range")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path to which this rule status code applies.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="subStatus")
    def sub_status(self) -> Optional[int]:
        """
        The Request Sub Status of the Status Code.
        """
        return pulumi.get(self, "sub_status")

    @property
    @pulumi.getter(name="win32StatusCode")
    def win32_status_code(self) -> Optional[int]:
        """
        The Win32 Status Code of the Request.
        """
        return pulumi.get(self, "win32_status_code")


@pulumi.output_type
class LinuxWebAppSiteConfigCors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedOrigins":
            suggest = "allowed_origins"
        elif key == "supportCredentials":
            suggest = "support_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSiteConfigCors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSiteConfigCors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSiteConfigCors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_origins: Optional[Sequence[str]] = None,
                 support_credentials: Optional[bool] = None):
        """
        :param Sequence[str] allowed_origins: Specifies a list of origins that should be allowed to make cross-origin calls.
        :param bool support_credentials: Whether CORS requests with credentials are allowed. Defaults to `false`
        """
        if allowed_origins is not None:
            pulumi.set(__self__, "allowed_origins", allowed_origins)
        if support_credentials is not None:
            pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of origins that should be allowed to make cross-origin calls.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> Optional[bool]:
        """
        Whether CORS requests with credentials are allowed. Defaults to `false`
        """
        return pulumi.get(self, "support_credentials")


@pulumi.output_type
class LinuxWebAppSiteConfigIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSiteConfigIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSiteConfigIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSiteConfigIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.LinuxWebAppSiteConfigIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: The action to take. Possible values are `Allow` or `Deny`.
        :param 'LinuxWebAppSiteConfigIpRestrictionHeadersArgs' headers: A `headers` block as defined above.
        :param str ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param str name: The name which should be used for this `ip_restriction`.
        :param int priority: The priority value of this `ip_restriction`. Defaults to `65000`.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
               
               > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        The action to take. Possible values are `Allow` or `Deny`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.LinuxWebAppSiteConfigIpRestrictionHeaders']:
        """
        A `headers` block as defined above.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class LinuxWebAppSiteConfigIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSiteConfigIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param str x_fd_health_probe: Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        :param Sequence[str] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param Sequence[str] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class LinuxWebAppSiteConfigScmIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSiteConfigScmIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSiteConfigScmIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSiteConfigScmIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.LinuxWebAppSiteConfigScmIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: The action to take. Possible values are `Allow` or `Deny`.
        :param 'LinuxWebAppSiteConfigScmIpRestrictionHeadersArgs' headers: A `headers` block as defined above.
        :param str ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param str name: The name which should be used for this `ip_restriction`.
        :param int priority: The priority value of this `ip_restriction`. Defaults to `65000`.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
               
               > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        The action to take. Possible values are `Allow` or `Deny`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.LinuxWebAppSiteConfigScmIpRestrictionHeaders']:
        """
        A `headers` block as defined above.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class LinuxWebAppSiteConfigScmIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSiteConfigScmIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param str x_fd_health_probe: Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        :param Sequence[str] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param Sequence[str] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class LinuxWebAppSiteCredential(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 password: Optional[str] = None):
        """
        :param str password: The Site Credentials Password used for publishing.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The Site Credentials Password used for publishing.
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class LinuxWebAppSlotAuthSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeDirectory":
            suggest = "active_directory"
        elif key == "additionalLoginParameters":
            suggest = "additional_login_parameters"
        elif key == "allowedExternalRedirectUrls":
            suggest = "allowed_external_redirect_urls"
        elif key == "defaultProvider":
            suggest = "default_provider"
        elif key == "runtimeVersion":
            suggest = "runtime_version"
        elif key == "tokenRefreshExtensionHours":
            suggest = "token_refresh_extension_hours"
        elif key == "tokenStoreEnabled":
            suggest = "token_store_enabled"
        elif key == "unauthenticatedClientAction":
            suggest = "unauthenticated_client_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotAuthSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotAuthSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotAuthSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 active_directory: Optional['outputs.LinuxWebAppSlotAuthSettingsActiveDirectory'] = None,
                 additional_login_parameters: Optional[Mapping[str, str]] = None,
                 allowed_external_redirect_urls: Optional[Sequence[str]] = None,
                 default_provider: Optional[str] = None,
                 facebook: Optional['outputs.LinuxWebAppSlotAuthSettingsFacebook'] = None,
                 github: Optional['outputs.LinuxWebAppSlotAuthSettingsGithub'] = None,
                 google: Optional['outputs.LinuxWebAppSlotAuthSettingsGoogle'] = None,
                 issuer: Optional[str] = None,
                 microsoft: Optional['outputs.LinuxWebAppSlotAuthSettingsMicrosoft'] = None,
                 runtime_version: Optional[str] = None,
                 token_refresh_extension_hours: Optional[float] = None,
                 token_store_enabled: Optional[bool] = None,
                 twitter: Optional['outputs.LinuxWebAppSlotAuthSettingsTwitter'] = None,
                 unauthenticated_client_action: Optional[str] = None):
        """
        :param bool enabled: Should the Authentication / Authorization feature be enabled for the Linux Web App?
        :param 'LinuxWebAppSlotAuthSettingsActiveDirectoryArgs' active_directory: An `active_directory` block as defined above.
        :param Mapping[str, str] additional_login_parameters: Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        :param Sequence[str] allowed_external_redirect_urls: Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Linux Web App.
        :param str default_provider: The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.
               
               > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        :param 'LinuxWebAppSlotAuthSettingsFacebookArgs' facebook: A `facebook` block as defined below.
        :param 'LinuxWebAppSlotAuthSettingsGithubArgs' github: A `github` block as defined below.
        :param 'LinuxWebAppSlotAuthSettingsGoogleArgs' google: A `google` block as defined below.
        :param str issuer: The OpenID Connect Issuer URI that represents the entity that issues access tokens for this Linux Web App.
               
               > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        :param 'LinuxWebAppSlotAuthSettingsMicrosoftArgs' microsoft: A `microsoft` block as defined below.
        :param str runtime_version: The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        :param float token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        :param bool token_store_enabled: Should the Linux Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        :param 'LinuxWebAppSlotAuthSettingsTwitterArgs' twitter: A `twitter` block as defined below.
        :param str unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if active_directory is not None:
            pulumi.set(__self__, "active_directory", active_directory)
        if additional_login_parameters is not None:
            pulumi.set(__self__, "additional_login_parameters", additional_login_parameters)
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if facebook is not None:
            pulumi.set(__self__, "facebook", facebook)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if google is not None:
            pulumi.set(__self__, "google", google)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if microsoft is not None:
            pulumi.set(__self__, "microsoft", microsoft)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if token_refresh_extension_hours is not None:
            pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if twitter is not None:
            pulumi.set(__self__, "twitter", twitter)
        if unauthenticated_client_action is not None:
            pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Should the Authentication / Authorization feature be enabled for the Linux Web App?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="activeDirectory")
    def active_directory(self) -> Optional['outputs.LinuxWebAppSlotAuthSettingsActiveDirectory']:
        """
        An `active_directory` block as defined above.
        """
        return pulumi.get(self, "active_directory")

    @property
    @pulumi.getter(name="additionalLoginParameters")
    def additional_login_parameters(self) -> Optional[Mapping[str, str]]:
        """
        Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        """
        return pulumi.get(self, "additional_login_parameters")

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Linux Web App.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[str]:
        """
        The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.

        > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        """
        return pulumi.get(self, "default_provider")

    @property
    @pulumi.getter
    def facebook(self) -> Optional['outputs.LinuxWebAppSlotAuthSettingsFacebook']:
        """
        A `facebook` block as defined below.
        """
        return pulumi.get(self, "facebook")

    @property
    @pulumi.getter
    def github(self) -> Optional['outputs.LinuxWebAppSlotAuthSettingsGithub']:
        """
        A `github` block as defined below.
        """
        return pulumi.get(self, "github")

    @property
    @pulumi.getter
    def google(self) -> Optional['outputs.LinuxWebAppSlotAuthSettingsGoogle']:
        """
        A `google` block as defined below.
        """
        return pulumi.get(self, "google")

    @property
    @pulumi.getter
    def issuer(self) -> Optional[str]:
        """
        The OpenID Connect Issuer URI that represents the entity that issues access tokens for this Linux Web App.

        > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def microsoft(self) -> Optional['outputs.LinuxWebAppSlotAuthSettingsMicrosoft']:
        """
        A `microsoft` block as defined below.
        """
        return pulumi.get(self, "microsoft")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[str]:
        """
        The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> Optional[float]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        return pulumi.get(self, "token_refresh_extension_hours")

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[bool]:
        """
        Should the Linux Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        """
        return pulumi.get(self, "token_store_enabled")

    @property
    @pulumi.getter
    def twitter(self) -> Optional['outputs.LinuxWebAppSlotAuthSettingsTwitter']:
        """
        A `twitter` block as defined below.
        """
        return pulumi.get(self, "twitter")

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> Optional[str]:
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        return pulumi.get(self, "unauthenticated_client_action")


@pulumi.output_type
class LinuxWebAppSlotAuthSettingsActiveDirectory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotAuthSettingsActiveDirectory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotAuthSettingsActiveDirectory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotAuthSettingsActiveDirectory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param Sequence[str] allowed_audiences: Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
               
               > **Note:** The `client_id` value is always considered an allowed audience.
        :param str client_secret: The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        pulumi.set(__self__, "client_id", client_id)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **Note:** The `client_id` value is always considered an allowed audience.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")


@pulumi.output_type
class LinuxWebAppSlotAuthSettingsFacebook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "appSecret":
            suggest = "app_secret"
        elif key == "appSecretSettingName":
            suggest = "app_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotAuthSettingsFacebook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotAuthSettingsFacebook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotAuthSettingsFacebook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: str,
                 app_secret: Optional[str] = None,
                 app_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str app_id: The App ID of the Facebook app used for login.
        :param str app_secret: The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        :param str app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        if app_secret is not None:
            pulumi.set(__self__, "app_secret", app_secret)
        if app_secret_setting_name is not None:
            pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appSecret")
    def app_secret(self) -> Optional[str]:
        """
        The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        """
        return pulumi.get(self, "app_secret")

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class LinuxWebAppSlotAuthSettingsGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotAuthSettingsGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotAuthSettingsGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotAuthSettingsGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the GitHub app used for login.
        :param str client_secret: The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the GitHub app used for login.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class LinuxWebAppSlotAuthSettingsGoogle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotAuthSettingsGoogle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotAuthSettingsGoogle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotAuthSettingsGoogle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OpenID Connect Client ID for the Google web application.
        :param str client_secret: The client secret associated with the Google web application. Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OpenID Connect Client ID for the Google web application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The client secret associated with the Google web application. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class LinuxWebAppSlotAuthSettingsMicrosoft(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotAuthSettingsMicrosoft. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotAuthSettingsMicrosoft.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotAuthSettingsMicrosoft.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret: The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, "wl.basic" is used as the default scope.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, "wl.basic" is used as the default scope.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class LinuxWebAppSlotAuthSettingsTwitter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerKey":
            suggest = "consumer_key"
        elif key == "consumerSecret":
            suggest = "consumer_secret"
        elif key == "consumerSecretSettingName":
            suggest = "consumer_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotAuthSettingsTwitter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotAuthSettingsTwitter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotAuthSettingsTwitter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_key: str,
                 consumer_secret: Optional[str] = None,
                 consumer_secret_setting_name: Optional[str] = None):
        """
        :param str consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param str consumer_secret: The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        :param str consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        if consumer_secret is not None:
            pulumi.set(__self__, "consumer_secret", consumer_secret)
        if consumer_secret_setting_name is not None:
            pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> str:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> Optional[str]:
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        """
        return pulumi.get(self, "consumer_secret")

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        return pulumi.get(self, "consumer_secret_setting_name")


@pulumi.output_type
class LinuxWebAppSlotAuthSettingsV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeDirectoryV2":
            suggest = "active_directory_v2"
        elif key == "appleV2":
            suggest = "apple_v2"
        elif key == "authEnabled":
            suggest = "auth_enabled"
        elif key == "azureStaticWebAppV2":
            suggest = "azure_static_web_app_v2"
        elif key == "configFilePath":
            suggest = "config_file_path"
        elif key == "customOidcV2s":
            suggest = "custom_oidc_v2s"
        elif key == "defaultProvider":
            suggest = "default_provider"
        elif key == "excludedPaths":
            suggest = "excluded_paths"
        elif key == "facebookV2":
            suggest = "facebook_v2"
        elif key == "forwardProxyConvention":
            suggest = "forward_proxy_convention"
        elif key == "forwardProxyCustomHostHeaderName":
            suggest = "forward_proxy_custom_host_header_name"
        elif key == "forwardProxyCustomSchemeHeaderName":
            suggest = "forward_proxy_custom_scheme_header_name"
        elif key == "githubV2":
            suggest = "github_v2"
        elif key == "googleV2":
            suggest = "google_v2"
        elif key == "httpRouteApiPrefix":
            suggest = "http_route_api_prefix"
        elif key == "microsoftV2":
            suggest = "microsoft_v2"
        elif key == "requireAuthentication":
            suggest = "require_authentication"
        elif key == "requireHttps":
            suggest = "require_https"
        elif key == "runtimeVersion":
            suggest = "runtime_version"
        elif key == "twitterV2":
            suggest = "twitter_v2"
        elif key == "unauthenticatedAction":
            suggest = "unauthenticated_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotAuthSettingsV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotAuthSettingsV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotAuthSettingsV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 login: 'outputs.LinuxWebAppSlotAuthSettingsV2Login',
                 active_directory_v2: Optional['outputs.LinuxWebAppSlotAuthSettingsV2ActiveDirectoryV2'] = None,
                 apple_v2: Optional['outputs.LinuxWebAppSlotAuthSettingsV2AppleV2'] = None,
                 auth_enabled: Optional[bool] = None,
                 azure_static_web_app_v2: Optional['outputs.LinuxWebAppSlotAuthSettingsV2AzureStaticWebAppV2'] = None,
                 config_file_path: Optional[str] = None,
                 custom_oidc_v2s: Optional[Sequence['outputs.LinuxWebAppSlotAuthSettingsV2CustomOidcV2']] = None,
                 default_provider: Optional[str] = None,
                 excluded_paths: Optional[Sequence[str]] = None,
                 facebook_v2: Optional['outputs.LinuxWebAppSlotAuthSettingsV2FacebookV2'] = None,
                 forward_proxy_convention: Optional[str] = None,
                 forward_proxy_custom_host_header_name: Optional[str] = None,
                 forward_proxy_custom_scheme_header_name: Optional[str] = None,
                 github_v2: Optional['outputs.LinuxWebAppSlotAuthSettingsV2GithubV2'] = None,
                 google_v2: Optional['outputs.LinuxWebAppSlotAuthSettingsV2GoogleV2'] = None,
                 http_route_api_prefix: Optional[str] = None,
                 microsoft_v2: Optional['outputs.LinuxWebAppSlotAuthSettingsV2MicrosoftV2'] = None,
                 require_authentication: Optional[bool] = None,
                 require_https: Optional[bool] = None,
                 runtime_version: Optional[str] = None,
                 twitter_v2: Optional['outputs.LinuxWebAppSlotAuthSettingsV2TwitterV2'] = None,
                 unauthenticated_action: Optional[str] = None):
        """
        :param 'LinuxWebAppSlotAuthSettingsV2LoginArgs' login: A `login` block as defined below.
        :param 'LinuxWebAppSlotAuthSettingsV2ActiveDirectoryV2Args' active_directory_v2: An `active_directory_v2` block as defined below.
        :param 'LinuxWebAppSlotAuthSettingsV2AppleV2Args' apple_v2: An `apple_v2` block as defined below.
        :param bool auth_enabled: Should the AuthV2 Settings be enabled. Defaults to `false`.
        :param 'LinuxWebAppSlotAuthSettingsV2AzureStaticWebAppV2Args' azure_static_web_app_v2: An `azure_static_web_app_v2` block as defined below.
        :param str config_file_path: The path to the App Auth settings.
               
               * > **Note:** Relative Paths are evaluated from the Site Root directory.
        :param Sequence['LinuxWebAppSlotAuthSettingsV2CustomOidcV2Args'] custom_oidc_v2s: Zero or more `custom_oidc_v2` blocks as defined below.
        :param str default_provider: The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.
               
               > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        :param Sequence[str] excluded_paths: The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.
               
               > **NOTE:** This list should be used instead of setting `WEBSITE_WARMUP_PATH` in `app_settings` as it takes priority.
        :param 'LinuxWebAppSlotAuthSettingsV2FacebookV2Args' facebook_v2: A `facebook_v2` block as defined below.
        :param str forward_proxy_convention: The convention used to determine the url of the request made. Possible values include `NoProxy`, `Standard`, `Custom`. Defaults to `NoProxy`.
        :param str forward_proxy_custom_host_header_name: The name of the custom header containing the host of the request.
        :param str forward_proxy_custom_scheme_header_name: The name of the custom header containing the scheme of the request.
        :param 'LinuxWebAppSlotAuthSettingsV2GithubV2Args' github_v2: A `github_v2` block as defined below.
        :param 'LinuxWebAppSlotAuthSettingsV2GoogleV2Args' google_v2: A `google_v2` block as defined below.
        :param str http_route_api_prefix: The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
        :param 'LinuxWebAppSlotAuthSettingsV2MicrosoftV2Args' microsoft_v2: A `microsoft_v2` block as defined below.
        :param bool require_authentication: Should the authentication flow be used for all requests.
        :param bool require_https: Should HTTPS be required on connections? Defaults to `true`.
        :param str runtime_version: The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        :param 'LinuxWebAppSlotAuthSettingsV2TwitterV2Args' twitter_v2: A `twitter_v2` block as defined below.
        :param str unauthenticated_action: The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
        """
        pulumi.set(__self__, "login", login)
        if active_directory_v2 is not None:
            pulumi.set(__self__, "active_directory_v2", active_directory_v2)
        if apple_v2 is not None:
            pulumi.set(__self__, "apple_v2", apple_v2)
        if auth_enabled is not None:
            pulumi.set(__self__, "auth_enabled", auth_enabled)
        if azure_static_web_app_v2 is not None:
            pulumi.set(__self__, "azure_static_web_app_v2", azure_static_web_app_v2)
        if config_file_path is not None:
            pulumi.set(__self__, "config_file_path", config_file_path)
        if custom_oidc_v2s is not None:
            pulumi.set(__self__, "custom_oidc_v2s", custom_oidc_v2s)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if excluded_paths is not None:
            pulumi.set(__self__, "excluded_paths", excluded_paths)
        if facebook_v2 is not None:
            pulumi.set(__self__, "facebook_v2", facebook_v2)
        if forward_proxy_convention is not None:
            pulumi.set(__self__, "forward_proxy_convention", forward_proxy_convention)
        if forward_proxy_custom_host_header_name is not None:
            pulumi.set(__self__, "forward_proxy_custom_host_header_name", forward_proxy_custom_host_header_name)
        if forward_proxy_custom_scheme_header_name is not None:
            pulumi.set(__self__, "forward_proxy_custom_scheme_header_name", forward_proxy_custom_scheme_header_name)
        if github_v2 is not None:
            pulumi.set(__self__, "github_v2", github_v2)
        if google_v2 is not None:
            pulumi.set(__self__, "google_v2", google_v2)
        if http_route_api_prefix is not None:
            pulumi.set(__self__, "http_route_api_prefix", http_route_api_prefix)
        if microsoft_v2 is not None:
            pulumi.set(__self__, "microsoft_v2", microsoft_v2)
        if require_authentication is not None:
            pulumi.set(__self__, "require_authentication", require_authentication)
        if require_https is not None:
            pulumi.set(__self__, "require_https", require_https)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if twitter_v2 is not None:
            pulumi.set(__self__, "twitter_v2", twitter_v2)
        if unauthenticated_action is not None:
            pulumi.set(__self__, "unauthenticated_action", unauthenticated_action)

    @property
    @pulumi.getter
    def login(self) -> 'outputs.LinuxWebAppSlotAuthSettingsV2Login':
        """
        A `login` block as defined below.
        """
        return pulumi.get(self, "login")

    @property
    @pulumi.getter(name="activeDirectoryV2")
    def active_directory_v2(self) -> Optional['outputs.LinuxWebAppSlotAuthSettingsV2ActiveDirectoryV2']:
        """
        An `active_directory_v2` block as defined below.
        """
        return pulumi.get(self, "active_directory_v2")

    @property
    @pulumi.getter(name="appleV2")
    def apple_v2(self) -> Optional['outputs.LinuxWebAppSlotAuthSettingsV2AppleV2']:
        """
        An `apple_v2` block as defined below.
        """
        return pulumi.get(self, "apple_v2")

    @property
    @pulumi.getter(name="authEnabled")
    def auth_enabled(self) -> Optional[bool]:
        """
        Should the AuthV2 Settings be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "auth_enabled")

    @property
    @pulumi.getter(name="azureStaticWebAppV2")
    def azure_static_web_app_v2(self) -> Optional['outputs.LinuxWebAppSlotAuthSettingsV2AzureStaticWebAppV2']:
        """
        An `azure_static_web_app_v2` block as defined below.
        """
        return pulumi.get(self, "azure_static_web_app_v2")

    @property
    @pulumi.getter(name="configFilePath")
    def config_file_path(self) -> Optional[str]:
        """
        The path to the App Auth settings.

        * > **Note:** Relative Paths are evaluated from the Site Root directory.
        """
        return pulumi.get(self, "config_file_path")

    @property
    @pulumi.getter(name="customOidcV2s")
    def custom_oidc_v2s(self) -> Optional[Sequence['outputs.LinuxWebAppSlotAuthSettingsV2CustomOidcV2']]:
        """
        Zero or more `custom_oidc_v2` blocks as defined below.
        """
        return pulumi.get(self, "custom_oidc_v2s")

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[str]:
        """
        The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.

        > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        """
        return pulumi.get(self, "default_provider")

    @property
    @pulumi.getter(name="excludedPaths")
    def excluded_paths(self) -> Optional[Sequence[str]]:
        """
        The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.

        > **NOTE:** This list should be used instead of setting `WEBSITE_WARMUP_PATH` in `app_settings` as it takes priority.
        """
        return pulumi.get(self, "excluded_paths")

    @property
    @pulumi.getter(name="facebookV2")
    def facebook_v2(self) -> Optional['outputs.LinuxWebAppSlotAuthSettingsV2FacebookV2']:
        """
        A `facebook_v2` block as defined below.
        """
        return pulumi.get(self, "facebook_v2")

    @property
    @pulumi.getter(name="forwardProxyConvention")
    def forward_proxy_convention(self) -> Optional[str]:
        """
        The convention used to determine the url of the request made. Possible values include `NoProxy`, `Standard`, `Custom`. Defaults to `NoProxy`.
        """
        return pulumi.get(self, "forward_proxy_convention")

    @property
    @pulumi.getter(name="forwardProxyCustomHostHeaderName")
    def forward_proxy_custom_host_header_name(self) -> Optional[str]:
        """
        The name of the custom header containing the host of the request.
        """
        return pulumi.get(self, "forward_proxy_custom_host_header_name")

    @property
    @pulumi.getter(name="forwardProxyCustomSchemeHeaderName")
    def forward_proxy_custom_scheme_header_name(self) -> Optional[str]:
        """
        The name of the custom header containing the scheme of the request.
        """
        return pulumi.get(self, "forward_proxy_custom_scheme_header_name")

    @property
    @pulumi.getter(name="githubV2")
    def github_v2(self) -> Optional['outputs.LinuxWebAppSlotAuthSettingsV2GithubV2']:
        """
        A `github_v2` block as defined below.
        """
        return pulumi.get(self, "github_v2")

    @property
    @pulumi.getter(name="googleV2")
    def google_v2(self) -> Optional['outputs.LinuxWebAppSlotAuthSettingsV2GoogleV2']:
        """
        A `google_v2` block as defined below.
        """
        return pulumi.get(self, "google_v2")

    @property
    @pulumi.getter(name="httpRouteApiPrefix")
    def http_route_api_prefix(self) -> Optional[str]:
        """
        The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
        """
        return pulumi.get(self, "http_route_api_prefix")

    @property
    @pulumi.getter(name="microsoftV2")
    def microsoft_v2(self) -> Optional['outputs.LinuxWebAppSlotAuthSettingsV2MicrosoftV2']:
        """
        A `microsoft_v2` block as defined below.
        """
        return pulumi.get(self, "microsoft_v2")

    @property
    @pulumi.getter(name="requireAuthentication")
    def require_authentication(self) -> Optional[bool]:
        """
        Should the authentication flow be used for all requests.
        """
        return pulumi.get(self, "require_authentication")

    @property
    @pulumi.getter(name="requireHttps")
    def require_https(self) -> Optional[bool]:
        """
        Should HTTPS be required on connections? Defaults to `true`.
        """
        return pulumi.get(self, "require_https")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[str]:
        """
        The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter(name="twitterV2")
    def twitter_v2(self) -> Optional['outputs.LinuxWebAppSlotAuthSettingsV2TwitterV2']:
        """
        A `twitter_v2` block as defined below.
        """
        return pulumi.get(self, "twitter_v2")

    @property
    @pulumi.getter(name="unauthenticatedAction")
    def unauthenticated_action(self) -> Optional[str]:
        """
        The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
        """
        return pulumi.get(self, "unauthenticated_action")


@pulumi.output_type
class LinuxWebAppSlotAuthSettingsV2ActiveDirectoryV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "tenantAuthEndpoint":
            suggest = "tenant_auth_endpoint"
        elif key == "allowedApplications":
            suggest = "allowed_applications"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "allowedGroups":
            suggest = "allowed_groups"
        elif key == "allowedIdentities":
            suggest = "allowed_identities"
        elif key == "clientSecretCertificateThumbprint":
            suggest = "client_secret_certificate_thumbprint"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "jwtAllowedClientApplications":
            suggest = "jwt_allowed_client_applications"
        elif key == "jwtAllowedGroups":
            suggest = "jwt_allowed_groups"
        elif key == "loginParameters":
            suggest = "login_parameters"
        elif key == "wwwAuthenticationDisabled":
            suggest = "www_authentication_disabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotAuthSettingsV2ActiveDirectoryV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotAuthSettingsV2ActiveDirectoryV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotAuthSettingsV2ActiveDirectoryV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 tenant_auth_endpoint: str,
                 allowed_applications: Optional[Sequence[str]] = None,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 allowed_groups: Optional[Sequence[str]] = None,
                 allowed_identities: Optional[Sequence[str]] = None,
                 client_secret_certificate_thumbprint: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 jwt_allowed_client_applications: Optional[Sequence[str]] = None,
                 jwt_allowed_groups: Optional[Sequence[str]] = None,
                 login_parameters: Optional[Mapping[str, str]] = None,
                 www_authentication_disabled: Optional[bool] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str tenant_auth_endpoint: The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`
        :param Sequence[str] allowed_applications: The list of allowed Applications for the Default Authorisation Policy.
        :param Sequence[str] allowed_audiences: Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
               
               > **Note:** The `client_id` value is always considered an allowed audience.
        :param Sequence[str] allowed_groups: The list of allowed Group Names for the Default Authorisation Policy.
        :param Sequence[str] allowed_identities: The list of allowed Identities for the Default Authorisation Policy.
        :param str client_secret_certificate_thumbprint: The thumbprint of the certificate used for signing purposes.
               
               > **NOTE:** One of `client_secret_setting_name` or `client_secret_certificate_thumbprint` must be specified.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param Sequence[str] jwt_allowed_client_applications: A list of Allowed Client Applications in the JWT Claim.
        :param Sequence[str] jwt_allowed_groups: A list of Allowed Groups in the JWT Claim.
        :param Mapping[str, str] login_parameters: A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
        :param bool www_authentication_disabled: Should the www-authenticate provider should be omitted from the request? Defaults to `false`
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "tenant_auth_endpoint", tenant_auth_endpoint)
        if allowed_applications is not None:
            pulumi.set(__self__, "allowed_applications", allowed_applications)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if allowed_groups is not None:
            pulumi.set(__self__, "allowed_groups", allowed_groups)
        if allowed_identities is not None:
            pulumi.set(__self__, "allowed_identities", allowed_identities)
        if client_secret_certificate_thumbprint is not None:
            pulumi.set(__self__, "client_secret_certificate_thumbprint", client_secret_certificate_thumbprint)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if jwt_allowed_client_applications is not None:
            pulumi.set(__self__, "jwt_allowed_client_applications", jwt_allowed_client_applications)
        if jwt_allowed_groups is not None:
            pulumi.set(__self__, "jwt_allowed_groups", jwt_allowed_groups)
        if login_parameters is not None:
            pulumi.set(__self__, "login_parameters", login_parameters)
        if www_authentication_disabled is not None:
            pulumi.set(__self__, "www_authentication_disabled", www_authentication_disabled)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="tenantAuthEndpoint")
    def tenant_auth_endpoint(self) -> str:
        """
        The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`
        """
        return pulumi.get(self, "tenant_auth_endpoint")

    @property
    @pulumi.getter(name="allowedApplications")
    def allowed_applications(self) -> Optional[Sequence[str]]:
        """
        The list of allowed Applications for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_applications")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **Note:** The `client_id` value is always considered an allowed audience.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="allowedGroups")
    def allowed_groups(self) -> Optional[Sequence[str]]:
        """
        The list of allowed Group Names for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_groups")

    @property
    @pulumi.getter(name="allowedIdentities")
    def allowed_identities(self) -> Optional[Sequence[str]]:
        """
        The list of allowed Identities for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_identities")

    @property
    @pulumi.getter(name="clientSecretCertificateThumbprint")
    def client_secret_certificate_thumbprint(self) -> Optional[str]:
        """
        The thumbprint of the certificate used for signing purposes.

        > **NOTE:** One of `client_secret_setting_name` or `client_secret_certificate_thumbprint` must be specified.
        """
        return pulumi.get(self, "client_secret_certificate_thumbprint")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="jwtAllowedClientApplications")
    def jwt_allowed_client_applications(self) -> Optional[Sequence[str]]:
        """
        A list of Allowed Client Applications in the JWT Claim.
        """
        return pulumi.get(self, "jwt_allowed_client_applications")

    @property
    @pulumi.getter(name="jwtAllowedGroups")
    def jwt_allowed_groups(self) -> Optional[Sequence[str]]:
        """
        A list of Allowed Groups in the JWT Claim.
        """
        return pulumi.get(self, "jwt_allowed_groups")

    @property
    @pulumi.getter(name="loginParameters")
    def login_parameters(self) -> Optional[Mapping[str, str]]:
        """
        A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
        """
        return pulumi.get(self, "login_parameters")

    @property
    @pulumi.getter(name="wwwAuthenticationDisabled")
    def www_authentication_disabled(self) -> Optional[bool]:
        """
        Should the www-authenticate provider should be omitted from the request? Defaults to `false`
        """
        return pulumi.get(self, "www_authentication_disabled")


@pulumi.output_type
class LinuxWebAppSlotAuthSettingsV2AppleV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "loginScopes":
            suggest = "login_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotAuthSettingsV2AppleV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotAuthSettingsV2AppleV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotAuthSettingsV2AppleV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret_setting_name: str,
                 login_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param Sequence[str] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[Sequence[str]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class LinuxWebAppSlotAuthSettingsV2AzureStaticWebAppV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotAuthSettingsV2AzureStaticWebAppV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotAuthSettingsV2AzureStaticWebAppV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotAuthSettingsV2AzureStaticWebAppV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        """
        pulumi.set(__self__, "client_id", client_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")


@pulumi.output_type
class LinuxWebAppSlotAuthSettingsV2CustomOidcV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "openidConfigurationEndpoint":
            suggest = "openid_configuration_endpoint"
        elif key == "authorisationEndpoint":
            suggest = "authorisation_endpoint"
        elif key == "certificationUri":
            suggest = "certification_uri"
        elif key == "clientCredentialMethod":
            suggest = "client_credential_method"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "issuerEndpoint":
            suggest = "issuer_endpoint"
        elif key == "nameClaimType":
            suggest = "name_claim_type"
        elif key == "tokenEndpoint":
            suggest = "token_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotAuthSettingsV2CustomOidcV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotAuthSettingsV2CustomOidcV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotAuthSettingsV2CustomOidcV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 name: str,
                 openid_configuration_endpoint: str,
                 authorisation_endpoint: Optional[str] = None,
                 certification_uri: Optional[str] = None,
                 client_credential_method: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 issuer_endpoint: Optional[str] = None,
                 name_claim_type: Optional[str] = None,
                 scopes: Optional[Sequence[str]] = None,
                 token_endpoint: Optional[str] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str openid_configuration_endpoint: The app setting name that contains the `client_secret` value used for the Custom OIDC Login.
        :param str authorisation_endpoint: The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        :param str certification_uri: The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        :param str client_credential_method: The Client Credential Method used.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param str issuer_endpoint: The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        :param str name_claim_type: The name of the claim that contains the users name.
        :param Sequence[str] scopes: The list of the scopes that should be requested while authenticating.
        :param str token_endpoint: The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "openid_configuration_endpoint", openid_configuration_endpoint)
        if authorisation_endpoint is not None:
            pulumi.set(__self__, "authorisation_endpoint", authorisation_endpoint)
        if certification_uri is not None:
            pulumi.set(__self__, "certification_uri", certification_uri)
        if client_credential_method is not None:
            pulumi.set(__self__, "client_credential_method", client_credential_method)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if issuer_endpoint is not None:
            pulumi.set(__self__, "issuer_endpoint", issuer_endpoint)
        if name_claim_type is not None:
            pulumi.set(__self__, "name_claim_type", name_claim_type)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="openidConfigurationEndpoint")
    def openid_configuration_endpoint(self) -> str:
        """
        The app setting name that contains the `client_secret` value used for the Custom OIDC Login.
        """
        return pulumi.get(self, "openid_configuration_endpoint")

    @property
    @pulumi.getter(name="authorisationEndpoint")
    def authorisation_endpoint(self) -> Optional[str]:
        """
        The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "authorisation_endpoint")

    @property
    @pulumi.getter(name="certificationUri")
    def certification_uri(self) -> Optional[str]:
        """
        The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "certification_uri")

    @property
    @pulumi.getter(name="clientCredentialMethod")
    def client_credential_method(self) -> Optional[str]:
        """
        The Client Credential Method used.
        """
        return pulumi.get(self, "client_credential_method")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="issuerEndpoint")
    def issuer_endpoint(self) -> Optional[str]:
        """
        The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "issuer_endpoint")

    @property
    @pulumi.getter(name="nameClaimType")
    def name_claim_type(self) -> Optional[str]:
        """
        The name of the claim that contains the users name.
        """
        return pulumi.get(self, "name_claim_type")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[str]]:
        """
        The list of the scopes that should be requested while authenticating.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[str]:
        """
        The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "token_endpoint")


@pulumi.output_type
class LinuxWebAppSlotAuthSettingsV2FacebookV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "appSecretSettingName":
            suggest = "app_secret_setting_name"
        elif key == "graphApiVersion":
            suggest = "graph_api_version"
        elif key == "loginScopes":
            suggest = "login_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotAuthSettingsV2FacebookV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotAuthSettingsV2FacebookV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotAuthSettingsV2FacebookV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: str,
                 app_secret_setting_name: str,
                 graph_api_version: Optional[str] = None,
                 login_scopes: Optional[Sequence[str]] = None):
        """
        :param str app_id: The App ID of the Facebook app used for login.
        :param str app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook Login.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param str graph_api_version: The version of the Facebook API to be used while logging in.
        :param Sequence[str] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        if graph_api_version is not None:
            pulumi.set(__self__, "graph_api_version", graph_api_version)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> str:
        """
        The app setting name that contains the `app_secret` value used for Facebook Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @property
    @pulumi.getter(name="graphApiVersion")
    def graph_api_version(self) -> Optional[str]:
        """
        The version of the Facebook API to be used while logging in.
        """
        return pulumi.get(self, "graph_api_version")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[Sequence[str]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class LinuxWebAppSlotAuthSettingsV2GithubV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "loginScopes":
            suggest = "login_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotAuthSettingsV2GithubV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotAuthSettingsV2GithubV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotAuthSettingsV2GithubV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret_setting_name: str,
                 login_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param Sequence[str] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[Sequence[str]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class LinuxWebAppSlotAuthSettingsV2GoogleV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "loginScopes":
            suggest = "login_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotAuthSettingsV2GoogleV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotAuthSettingsV2GoogleV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotAuthSettingsV2GoogleV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret_setting_name: str,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 login_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param Sequence[str] allowed_audiences: Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
               
               > **Note:** The `client_id` value is always considered an allowed audience.
        :param Sequence[str] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **Note:** The `client_id` value is always considered an allowed audience.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[Sequence[str]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class LinuxWebAppSlotAuthSettingsV2Login(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedExternalRedirectUrls":
            suggest = "allowed_external_redirect_urls"
        elif key == "cookieExpirationConvention":
            suggest = "cookie_expiration_convention"
        elif key == "cookieExpirationTime":
            suggest = "cookie_expiration_time"
        elif key == "logoutEndpoint":
            suggest = "logout_endpoint"
        elif key == "nonceExpirationTime":
            suggest = "nonce_expiration_time"
        elif key == "preserveUrlFragmentsForLogins":
            suggest = "preserve_url_fragments_for_logins"
        elif key == "tokenRefreshExtensionTime":
            suggest = "token_refresh_extension_time"
        elif key == "tokenStoreEnabled":
            suggest = "token_store_enabled"
        elif key == "tokenStorePath":
            suggest = "token_store_path"
        elif key == "tokenStoreSasSettingName":
            suggest = "token_store_sas_setting_name"
        elif key == "validateNonce":
            suggest = "validate_nonce"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotAuthSettingsV2Login. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotAuthSettingsV2Login.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotAuthSettingsV2Login.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_external_redirect_urls: Optional[Sequence[str]] = None,
                 cookie_expiration_convention: Optional[str] = None,
                 cookie_expiration_time: Optional[str] = None,
                 logout_endpoint: Optional[str] = None,
                 nonce_expiration_time: Optional[str] = None,
                 preserve_url_fragments_for_logins: Optional[bool] = None,
                 token_refresh_extension_time: Optional[float] = None,
                 token_store_enabled: Optional[bool] = None,
                 token_store_path: Optional[str] = None,
                 token_store_sas_setting_name: Optional[str] = None,
                 validate_nonce: Optional[bool] = None):
        """
        :param Sequence[str] allowed_external_redirect_urls: External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends.
               
               > **Note:** URLs within the current domain are always implicitly allowed.
        :param str cookie_expiration_convention: The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
        :param str cookie_expiration_time: The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
        :param str logout_endpoint: The endpoint to which logout requests should be made.
        :param str nonce_expiration_time: The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
        :param bool preserve_url_fragments_for_logins: Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
        :param float token_refresh_extension_time: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        :param bool token_store_enabled: Should the Token Store configuration Enabled. Defaults to `false`
        :param str token_store_path: The directory path in the App Filesystem in which the tokens will be stored.
        :param str token_store_sas_setting_name: The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        :param bool validate_nonce: Should the nonce be validated while completing the login flow. Defaults to `true`.
        """
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if cookie_expiration_convention is not None:
            pulumi.set(__self__, "cookie_expiration_convention", cookie_expiration_convention)
        if cookie_expiration_time is not None:
            pulumi.set(__self__, "cookie_expiration_time", cookie_expiration_time)
        if logout_endpoint is not None:
            pulumi.set(__self__, "logout_endpoint", logout_endpoint)
        if nonce_expiration_time is not None:
            pulumi.set(__self__, "nonce_expiration_time", nonce_expiration_time)
        if preserve_url_fragments_for_logins is not None:
            pulumi.set(__self__, "preserve_url_fragments_for_logins", preserve_url_fragments_for_logins)
        if token_refresh_extension_time is not None:
            pulumi.set(__self__, "token_refresh_extension_time", token_refresh_extension_time)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if token_store_path is not None:
            pulumi.set(__self__, "token_store_path", token_store_path)
        if token_store_sas_setting_name is not None:
            pulumi.set(__self__, "token_store_sas_setting_name", token_store_sas_setting_name)
        if validate_nonce is not None:
            pulumi.set(__self__, "validate_nonce", validate_nonce)

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[Sequence[str]]:
        """
        External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends.

        > **Note:** URLs within the current domain are always implicitly allowed.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @property
    @pulumi.getter(name="cookieExpirationConvention")
    def cookie_expiration_convention(self) -> Optional[str]:
        """
        The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
        """
        return pulumi.get(self, "cookie_expiration_convention")

    @property
    @pulumi.getter(name="cookieExpirationTime")
    def cookie_expiration_time(self) -> Optional[str]:
        """
        The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
        """
        return pulumi.get(self, "cookie_expiration_time")

    @property
    @pulumi.getter(name="logoutEndpoint")
    def logout_endpoint(self) -> Optional[str]:
        """
        The endpoint to which logout requests should be made.
        """
        return pulumi.get(self, "logout_endpoint")

    @property
    @pulumi.getter(name="nonceExpirationTime")
    def nonce_expiration_time(self) -> Optional[str]:
        """
        The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
        """
        return pulumi.get(self, "nonce_expiration_time")

    @property
    @pulumi.getter(name="preserveUrlFragmentsForLogins")
    def preserve_url_fragments_for_logins(self) -> Optional[bool]:
        """
        Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
        """
        return pulumi.get(self, "preserve_url_fragments_for_logins")

    @property
    @pulumi.getter(name="tokenRefreshExtensionTime")
    def token_refresh_extension_time(self) -> Optional[float]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        return pulumi.get(self, "token_refresh_extension_time")

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[bool]:
        """
        Should the Token Store configuration Enabled. Defaults to `false`
        """
        return pulumi.get(self, "token_store_enabled")

    @property
    @pulumi.getter(name="tokenStorePath")
    def token_store_path(self) -> Optional[str]:
        """
        The directory path in the App Filesystem in which the tokens will be stored.
        """
        return pulumi.get(self, "token_store_path")

    @property
    @pulumi.getter(name="tokenStoreSasSettingName")
    def token_store_sas_setting_name(self) -> Optional[str]:
        """
        The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        """
        return pulumi.get(self, "token_store_sas_setting_name")

    @property
    @pulumi.getter(name="validateNonce")
    def validate_nonce(self) -> Optional[bool]:
        """
        Should the nonce be validated while completing the login flow. Defaults to `true`.
        """
        return pulumi.get(self, "validate_nonce")


@pulumi.output_type
class LinuxWebAppSlotAuthSettingsV2MicrosoftV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "loginScopes":
            suggest = "login_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotAuthSettingsV2MicrosoftV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotAuthSettingsV2MicrosoftV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotAuthSettingsV2MicrosoftV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret_setting_name: str,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 login_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param Sequence[str] allowed_audiences: Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
               
               > **Note:** The `client_id` value is always considered an allowed audience.
        :param Sequence[str] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **Note:** The `client_id` value is always considered an allowed audience.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[Sequence[str]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class LinuxWebAppSlotAuthSettingsV2TwitterV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerKey":
            suggest = "consumer_key"
        elif key == "consumerSecretSettingName":
            suggest = "consumer_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotAuthSettingsV2TwitterV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotAuthSettingsV2TwitterV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotAuthSettingsV2TwitterV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_key: str,
                 consumer_secret_setting_name: str):
        """
        :param str consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param str consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> str:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> str:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "consumer_secret_setting_name")


@pulumi.output_type
class LinuxWebAppSlotBackup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageAccountUrl":
            suggest = "storage_account_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotBackup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotBackup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotBackup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 schedule: 'outputs.LinuxWebAppSlotBackupSchedule',
                 storage_account_url: str,
                 enabled: Optional[bool] = None):
        """
        :param str name: The name which should be used for this Backup.
        :param 'LinuxWebAppSlotBackupScheduleArgs' schedule: An `schedule` block as defined below.
        :param str storage_account_url: The SAS URL to the container.
        :param bool enabled: Should this backup job be enabled? Defaults to `true`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "storage_account_url", storage_account_url)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Backup.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def schedule(self) -> 'outputs.LinuxWebAppSlotBackupSchedule':
        """
        An `schedule` block as defined below.
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter(name="storageAccountUrl")
    def storage_account_url(self) -> str:
        """
        The SAS URL to the container.
        """
        return pulumi.get(self, "storage_account_url")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Should this backup job be enabled? Defaults to `true`.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class LinuxWebAppSlotBackupSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "frequencyUnit":
            suggest = "frequency_unit"
        elif key == "keepAtLeastOneBackup":
            suggest = "keep_at_least_one_backup"
        elif key == "lastExecutionTime":
            suggest = "last_execution_time"
        elif key == "retentionPeriodDays":
            suggest = "retention_period_days"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotBackupSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotBackupSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotBackupSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_unit: str,
                 keep_at_least_one_backup: Optional[bool] = None,
                 last_execution_time: Optional[str] = None,
                 retention_period_days: Optional[int] = None,
                 start_time: Optional[str] = None):
        """
        :param int frequency_interval: How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).
               
               > **NOTE:** Not all intervals are supported on all Linux Web App SKUs. Please refer to the official documentation for appropriate values.
        :param str frequency_unit: The unit of time for how often the backup should take place. Possible values include: `Day`, `Hour`
        :param bool keep_at_least_one_backup: Should the service keep at least one backup, regardless of the age of backup? Defaults to `false`.
        :param int retention_period_days: After how many days backups should be deleted. Defaults to `30`.
        :param str start_time: When the schedule should start working in RFC-3339 format.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_unit", frequency_unit)
        if keep_at_least_one_backup is not None:
            pulumi.set(__self__, "keep_at_least_one_backup", keep_at_least_one_backup)
        if last_execution_time is not None:
            pulumi.set(__self__, "last_execution_time", last_execution_time)
        if retention_period_days is not None:
            pulumi.set(__self__, "retention_period_days", retention_period_days)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).

        > **NOTE:** Not all intervals are supported on all Linux Web App SKUs. Please refer to the official documentation for appropriate values.
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyUnit")
    def frequency_unit(self) -> str:
        """
        The unit of time for how often the backup should take place. Possible values include: `Day`, `Hour`
        """
        return pulumi.get(self, "frequency_unit")

    @property
    @pulumi.getter(name="keepAtLeastOneBackup")
    def keep_at_least_one_backup(self) -> Optional[bool]:
        """
        Should the service keep at least one backup, regardless of the age of backup? Defaults to `false`.
        """
        return pulumi.get(self, "keep_at_least_one_backup")

    @property
    @pulumi.getter(name="lastExecutionTime")
    def last_execution_time(self) -> Optional[str]:
        return pulumi.get(self, "last_execution_time")

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> Optional[int]:
        """
        After how many days backups should be deleted. Defaults to `30`.
        """
        return pulumi.get(self, "retention_period_days")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        """
        When the schedule should start working in RFC-3339 format.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class LinuxWebAppSlotConnectionString(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: The name of the Connection String.
        :param str type: Type of database. Possible values include `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
        :param str value: The connection string value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Connection String.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of database. Possible values include `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The connection string value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class LinuxWebAppSlotIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 identity_ids: Optional[Sequence[str]] = None,
                 principal_id: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str type: Specifies the type of Managed Service Identity that should be configured on this Linux Web App Slot. Possible values are `SystemAssigned`, `UserAssigned` and `SystemAssigned, UserAssigned` (to enable both).
        :param Sequence[str] identity_ids: A list of User Assigned Managed Identity IDs to be assigned to this Linux Web App Slot.
               
               > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        :param str principal_id: The Principal ID associated with this Managed Service Identity.
        :param str tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the type of Managed Service Identity that should be configured on this Linux Web App Slot. Possible values are `SystemAssigned`, `UserAssigned` and `SystemAssigned, UserAssigned` (to enable both).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[str]]:
        """
        A list of User Assigned Managed Identity IDs to be assigned to this Linux Web App Slot.

        > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class LinuxWebAppSlotLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationLogs":
            suggest = "application_logs"
        elif key == "detailedErrorMessages":
            suggest = "detailed_error_messages"
        elif key == "failedRequestTracing":
            suggest = "failed_request_tracing"
        elif key == "httpLogs":
            suggest = "http_logs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_logs: Optional['outputs.LinuxWebAppSlotLogsApplicationLogs'] = None,
                 detailed_error_messages: Optional[bool] = None,
                 failed_request_tracing: Optional[bool] = None,
                 http_logs: Optional['outputs.LinuxWebAppSlotLogsHttpLogs'] = None):
        """
        :param 'LinuxWebAppSlotLogsApplicationLogsArgs' application_logs: A `application_logs` block as defined above.
        :param bool detailed_error_messages: Should detailed error messages be enabled?
        :param bool failed_request_tracing: Should the failed request tracing be enabled?
        :param 'LinuxWebAppSlotLogsHttpLogsArgs' http_logs: An `http_logs` block as defined above.
        """
        if application_logs is not None:
            pulumi.set(__self__, "application_logs", application_logs)
        if detailed_error_messages is not None:
            pulumi.set(__self__, "detailed_error_messages", detailed_error_messages)
        if failed_request_tracing is not None:
            pulumi.set(__self__, "failed_request_tracing", failed_request_tracing)
        if http_logs is not None:
            pulumi.set(__self__, "http_logs", http_logs)

    @property
    @pulumi.getter(name="applicationLogs")
    def application_logs(self) -> Optional['outputs.LinuxWebAppSlotLogsApplicationLogs']:
        """
        A `application_logs` block as defined above.
        """
        return pulumi.get(self, "application_logs")

    @property
    @pulumi.getter(name="detailedErrorMessages")
    def detailed_error_messages(self) -> Optional[bool]:
        """
        Should detailed error messages be enabled?
        """
        return pulumi.get(self, "detailed_error_messages")

    @property
    @pulumi.getter(name="failedRequestTracing")
    def failed_request_tracing(self) -> Optional[bool]:
        """
        Should the failed request tracing be enabled?
        """
        return pulumi.get(self, "failed_request_tracing")

    @property
    @pulumi.getter(name="httpLogs")
    def http_logs(self) -> Optional['outputs.LinuxWebAppSlotLogsHttpLogs']:
        """
        An `http_logs` block as defined above.
        """
        return pulumi.get(self, "http_logs")


@pulumi.output_type
class LinuxWebAppSlotLogsApplicationLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileSystemLevel":
            suggest = "file_system_level"
        elif key == "azureBlobStorage":
            suggest = "azure_blob_storage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotLogsApplicationLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotLogsApplicationLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotLogsApplicationLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_system_level: str,
                 azure_blob_storage: Optional['outputs.LinuxWebAppSlotLogsApplicationLogsAzureBlobStorage'] = None):
        """
        :param str file_system_level: Log level. Possible values include `Verbose`, `Information`, `Warning`, and `Error`.
        :param 'LinuxWebAppSlotLogsApplicationLogsAzureBlobStorageArgs' azure_blob_storage: An `azure_blob_storage` block as defined below.
        """
        pulumi.set(__self__, "file_system_level", file_system_level)
        if azure_blob_storage is not None:
            pulumi.set(__self__, "azure_blob_storage", azure_blob_storage)

    @property
    @pulumi.getter(name="fileSystemLevel")
    def file_system_level(self) -> str:
        """
        Log level. Possible values include `Verbose`, `Information`, `Warning`, and `Error`.
        """
        return pulumi.get(self, "file_system_level")

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional['outputs.LinuxWebAppSlotLogsApplicationLogsAzureBlobStorage']:
        """
        An `azure_blob_storage` block as defined below.
        """
        return pulumi.get(self, "azure_blob_storage")


@pulumi.output_type
class LinuxWebAppSlotLogsApplicationLogsAzureBlobStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retentionInDays":
            suggest = "retention_in_days"
        elif key == "sasUrl":
            suggest = "sas_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotLogsApplicationLogsAzureBlobStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotLogsApplicationLogsAzureBlobStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotLogsApplicationLogsAzureBlobStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 level: str,
                 retention_in_days: int,
                 sas_url: str):
        """
        :param str level: The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        :param int retention_in_days: The time in days after which to remove blobs. A value of `0` means no retention.
        :param str sas_url: SAS URL to an Azure blob container with read/write/list/delete permissions.
        """
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "sas_url", sas_url)

    @property
    @pulumi.getter
    def level(self) -> str:
        """
        The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        """
        return pulumi.get(self, "level")

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> int:
        """
        The time in days after which to remove blobs. A value of `0` means no retention.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> str:
        """
        SAS URL to an Azure blob container with read/write/list/delete permissions.
        """
        return pulumi.get(self, "sas_url")


@pulumi.output_type
class LinuxWebAppSlotLogsHttpLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureBlobStorage":
            suggest = "azure_blob_storage"
        elif key == "fileSystem":
            suggest = "file_system"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotLogsHttpLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotLogsHttpLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotLogsHttpLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_blob_storage: Optional['outputs.LinuxWebAppSlotLogsHttpLogsAzureBlobStorage'] = None,
                 file_system: Optional['outputs.LinuxWebAppSlotLogsHttpLogsFileSystem'] = None):
        """
        :param 'LinuxWebAppSlotLogsHttpLogsAzureBlobStorageArgs' azure_blob_storage: A `azure_blob_storage_http` block as defined above.
        :param 'LinuxWebAppSlotLogsHttpLogsFileSystemArgs' file_system: A `file_system` block as defined above.
        """
        if azure_blob_storage is not None:
            pulumi.set(__self__, "azure_blob_storage", azure_blob_storage)
        if file_system is not None:
            pulumi.set(__self__, "file_system", file_system)

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional['outputs.LinuxWebAppSlotLogsHttpLogsAzureBlobStorage']:
        """
        A `azure_blob_storage_http` block as defined above.
        """
        return pulumi.get(self, "azure_blob_storage")

    @property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional['outputs.LinuxWebAppSlotLogsHttpLogsFileSystem']:
        """
        A `file_system` block as defined above.
        """
        return pulumi.get(self, "file_system")


@pulumi.output_type
class LinuxWebAppSlotLogsHttpLogsAzureBlobStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sasUrl":
            suggest = "sas_url"
        elif key == "retentionInDays":
            suggest = "retention_in_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotLogsHttpLogsAzureBlobStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotLogsHttpLogsAzureBlobStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotLogsHttpLogsAzureBlobStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sas_url: str,
                 retention_in_days: Optional[int] = None):
        """
        :param str sas_url: SAS URL to an Azure blob container with read/write/list/delete permissions.
        :param int retention_in_days: The time in days after which to remove blobs. A value of `0` means no retention.
        """
        pulumi.set(__self__, "sas_url", sas_url)
        if retention_in_days is not None:
            pulumi.set(__self__, "retention_in_days", retention_in_days)

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> str:
        """
        SAS URL to an Azure blob container with read/write/list/delete permissions.
        """
        return pulumi.get(self, "sas_url")

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> Optional[int]:
        """
        The time in days after which to remove blobs. A value of `0` means no retention.
        """
        return pulumi.get(self, "retention_in_days")


@pulumi.output_type
class LinuxWebAppSlotLogsHttpLogsFileSystem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retentionInDays":
            suggest = "retention_in_days"
        elif key == "retentionInMb":
            suggest = "retention_in_mb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotLogsHttpLogsFileSystem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotLogsHttpLogsFileSystem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotLogsHttpLogsFileSystem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 retention_in_days: int,
                 retention_in_mb: int):
        """
        :param int retention_in_days: The retention period in days. A values of `0` means no retention.
        :param int retention_in_mb: The maximum size in megabytes that log files can use.
        """
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "retention_in_mb", retention_in_mb)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> int:
        """
        The retention period in days. A values of `0` means no retention.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="retentionInMb")
    def retention_in_mb(self) -> int:
        """
        The maximum size in megabytes that log files can use.
        """
        return pulumi.get(self, "retention_in_mb")


@pulumi.output_type
class LinuxWebAppSlotSiteConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alwaysOn":
            suggest = "always_on"
        elif key == "apiDefinitionUrl":
            suggest = "api_definition_url"
        elif key == "apiManagementApiId":
            suggest = "api_management_api_id"
        elif key == "appCommandLine":
            suggest = "app_command_line"
        elif key == "applicationStack":
            suggest = "application_stack"
        elif key == "autoHealEnabled":
            suggest = "auto_heal_enabled"
        elif key == "autoHealSetting":
            suggest = "auto_heal_setting"
        elif key == "autoSwapSlotName":
            suggest = "auto_swap_slot_name"
        elif key == "containerRegistryManagedIdentityClientId":
            suggest = "container_registry_managed_identity_client_id"
        elif key == "containerRegistryUseManagedIdentity":
            suggest = "container_registry_use_managed_identity"
        elif key == "defaultDocuments":
            suggest = "default_documents"
        elif key == "detailedErrorLoggingEnabled":
            suggest = "detailed_error_logging_enabled"
        elif key == "ftpsState":
            suggest = "ftps_state"
        elif key == "healthCheckEvictionTimeInMin":
            suggest = "health_check_eviction_time_in_min"
        elif key == "healthCheckPath":
            suggest = "health_check_path"
        elif key == "http2Enabled":
            suggest = "http2_enabled"
        elif key == "ipRestrictions":
            suggest = "ip_restrictions"
        elif key == "linuxFxVersion":
            suggest = "linux_fx_version"
        elif key == "loadBalancingMode":
            suggest = "load_balancing_mode"
        elif key == "localMysqlEnabled":
            suggest = "local_mysql_enabled"
        elif key == "managedPipelineMode":
            suggest = "managed_pipeline_mode"
        elif key == "minimumTlsVersion":
            suggest = "minimum_tls_version"
        elif key == "remoteDebuggingEnabled":
            suggest = "remote_debugging_enabled"
        elif key == "remoteDebuggingVersion":
            suggest = "remote_debugging_version"
        elif key == "scmIpRestrictions":
            suggest = "scm_ip_restrictions"
        elif key == "scmMinimumTlsVersion":
            suggest = "scm_minimum_tls_version"
        elif key == "scmType":
            suggest = "scm_type"
        elif key == "scmUseMainIpRestriction":
            suggest = "scm_use_main_ip_restriction"
        elif key == "use32BitWorker":
            suggest = "use32_bit_worker"
        elif key == "vnetRouteAllEnabled":
            suggest = "vnet_route_all_enabled"
        elif key == "websocketsEnabled":
            suggest = "websockets_enabled"
        elif key == "workerCount":
            suggest = "worker_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotSiteConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotSiteConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotSiteConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 always_on: Optional[bool] = None,
                 api_definition_url: Optional[str] = None,
                 api_management_api_id: Optional[str] = None,
                 app_command_line: Optional[str] = None,
                 application_stack: Optional['outputs.LinuxWebAppSlotSiteConfigApplicationStack'] = None,
                 auto_heal_enabled: Optional[bool] = None,
                 auto_heal_setting: Optional['outputs.LinuxWebAppSlotSiteConfigAutoHealSetting'] = None,
                 auto_swap_slot_name: Optional[str] = None,
                 container_registry_managed_identity_client_id: Optional[str] = None,
                 container_registry_use_managed_identity: Optional[bool] = None,
                 cors: Optional['outputs.LinuxWebAppSlotSiteConfigCors'] = None,
                 default_documents: Optional[Sequence[str]] = None,
                 detailed_error_logging_enabled: Optional[bool] = None,
                 ftps_state: Optional[str] = None,
                 health_check_eviction_time_in_min: Optional[int] = None,
                 health_check_path: Optional[str] = None,
                 http2_enabled: Optional[bool] = None,
                 ip_restrictions: Optional[Sequence['outputs.LinuxWebAppSlotSiteConfigIpRestriction']] = None,
                 linux_fx_version: Optional[str] = None,
                 load_balancing_mode: Optional[str] = None,
                 local_mysql_enabled: Optional[bool] = None,
                 managed_pipeline_mode: Optional[str] = None,
                 minimum_tls_version: Optional[str] = None,
                 remote_debugging_enabled: Optional[bool] = None,
                 remote_debugging_version: Optional[str] = None,
                 scm_ip_restrictions: Optional[Sequence['outputs.LinuxWebAppSlotSiteConfigScmIpRestriction']] = None,
                 scm_minimum_tls_version: Optional[str] = None,
                 scm_type: Optional[str] = None,
                 scm_use_main_ip_restriction: Optional[bool] = None,
                 use32_bit_worker: Optional[bool] = None,
                 vnet_route_all_enabled: Optional[bool] = None,
                 websockets_enabled: Optional[bool] = None,
                 worker_count: Optional[int] = None):
        """
        :param bool always_on: If this Linux Web App is Always On enabled. Defaults to `true`.
        :param str api_definition_url: The URL to the API Definition for this Linux Web App Slot.
        :param str api_management_api_id: The API Management API ID this Linux Web App Slot is associated with.
        :param str app_command_line: The App command line to launch.
        :param 'LinuxWebAppSlotSiteConfigApplicationStackArgs' application_stack: A `application_stack` block as defined above.
        :param bool auto_heal_enabled: Should Auto heal rules be enabled? Required with `auto_heal_setting`.
        :param 'LinuxWebAppSlotSiteConfigAutoHealSettingArgs' auto_heal_setting: A `auto_heal_setting` block as defined above. Required with `auto_heal`.
        :param str auto_swap_slot_name: The Linux Web App Slot Name to automatically swap to when deployment to that slot is successfully completed.
               
               > **Note:** This must be a valid slot name on the target Linux Web App.
        :param str container_registry_managed_identity_client_id: The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
        :param bool container_registry_use_managed_identity: Should connections for Azure Container Registry use Managed Identity.
        :param 'LinuxWebAppSlotSiteConfigCorsArgs' cors: A `cors` block as defined above.
        :param Sequence[str] default_documents: Specifies a list of Default Documents for the Linux Web App.
        :param int health_check_eviction_time_in_min: The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        :param str health_check_path: The path to the Health Check.
        :param bool http2_enabled: Should the HTTP2 be enabled?
        :param Sequence['LinuxWebAppSlotSiteConfigIpRestrictionArgs'] ip_restrictions: One or more `ip_restriction` blocks as defined above.
        :param str load_balancing_mode: The Site load balancing. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        :param bool local_mysql_enabled: Use Local MySQL. Defaults to `false`.
        :param str managed_pipeline_mode: Managed pipeline mode. Possible values include: `Integrated`, `Classic`.
        :param str minimum_tls_version: The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        :param bool remote_debugging_enabled: Should Remote Debugging be enabled? Defaults to `false`.
        :param str remote_debugging_version: The Remote Debugging Version. Possible values include `VS2017` and `VS2019`
        :param Sequence['LinuxWebAppSlotSiteConfigScmIpRestrictionArgs'] scm_ip_restrictions: One or more `scm_ip_restriction` blocks as defined above.
        :param str scm_minimum_tls_version: The configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        :param bool scm_use_main_ip_restriction: Should the Linux Web App `ip_restriction` configuration be used for the SCM also.
        :param bool use32_bit_worker: Should the Linux Web App use a 32-bit worker? Defaults to `true`.
        :param bool vnet_route_all_enabled: Should all outbound traffic have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        :param bool websockets_enabled: Should Web Sockets be enabled? Defaults to `false`.
        :param int worker_count: The number of Workers for this Linux App Service Slot.
        """
        if always_on is not None:
            pulumi.set(__self__, "always_on", always_on)
        if api_definition_url is not None:
            pulumi.set(__self__, "api_definition_url", api_definition_url)
        if api_management_api_id is not None:
            pulumi.set(__self__, "api_management_api_id", api_management_api_id)
        if app_command_line is not None:
            pulumi.set(__self__, "app_command_line", app_command_line)
        if application_stack is not None:
            pulumi.set(__self__, "application_stack", application_stack)
        if auto_heal_enabled is not None:
            pulumi.set(__self__, "auto_heal_enabled", auto_heal_enabled)
        if auto_heal_setting is not None:
            pulumi.set(__self__, "auto_heal_setting", auto_heal_setting)
        if auto_swap_slot_name is not None:
            pulumi.set(__self__, "auto_swap_slot_name", auto_swap_slot_name)
        if container_registry_managed_identity_client_id is not None:
            pulumi.set(__self__, "container_registry_managed_identity_client_id", container_registry_managed_identity_client_id)
        if container_registry_use_managed_identity is not None:
            pulumi.set(__self__, "container_registry_use_managed_identity", container_registry_use_managed_identity)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if default_documents is not None:
            pulumi.set(__self__, "default_documents", default_documents)
        if detailed_error_logging_enabled is not None:
            pulumi.set(__self__, "detailed_error_logging_enabled", detailed_error_logging_enabled)
        if ftps_state is not None:
            pulumi.set(__self__, "ftps_state", ftps_state)
        if health_check_eviction_time_in_min is not None:
            pulumi.set(__self__, "health_check_eviction_time_in_min", health_check_eviction_time_in_min)
        if health_check_path is not None:
            pulumi.set(__self__, "health_check_path", health_check_path)
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if ip_restrictions is not None:
            pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        if linux_fx_version is not None:
            pulumi.set(__self__, "linux_fx_version", linux_fx_version)
        if load_balancing_mode is not None:
            pulumi.set(__self__, "load_balancing_mode", load_balancing_mode)
        if local_mysql_enabled is not None:
            pulumi.set(__self__, "local_mysql_enabled", local_mysql_enabled)
        if managed_pipeline_mode is not None:
            pulumi.set(__self__, "managed_pipeline_mode", managed_pipeline_mode)
        if minimum_tls_version is not None:
            pulumi.set(__self__, "minimum_tls_version", minimum_tls_version)
        if remote_debugging_enabled is not None:
            pulumi.set(__self__, "remote_debugging_enabled", remote_debugging_enabled)
        if remote_debugging_version is not None:
            pulumi.set(__self__, "remote_debugging_version", remote_debugging_version)
        if scm_ip_restrictions is not None:
            pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        if scm_minimum_tls_version is not None:
            pulumi.set(__self__, "scm_minimum_tls_version", scm_minimum_tls_version)
        if scm_type is not None:
            pulumi.set(__self__, "scm_type", scm_type)
        if scm_use_main_ip_restriction is not None:
            pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        if use32_bit_worker is not None:
            pulumi.set(__self__, "use32_bit_worker", use32_bit_worker)
        if vnet_route_all_enabled is not None:
            pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        if websockets_enabled is not None:
            pulumi.set(__self__, "websockets_enabled", websockets_enabled)
        if worker_count is not None:
            pulumi.set(__self__, "worker_count", worker_count)

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> Optional[bool]:
        """
        If this Linux Web App is Always On enabled. Defaults to `true`.
        """
        return pulumi.get(self, "always_on")

    @property
    @pulumi.getter(name="apiDefinitionUrl")
    def api_definition_url(self) -> Optional[str]:
        """
        The URL to the API Definition for this Linux Web App Slot.
        """
        return pulumi.get(self, "api_definition_url")

    @property
    @pulumi.getter(name="apiManagementApiId")
    def api_management_api_id(self) -> Optional[str]:
        """
        The API Management API ID this Linux Web App Slot is associated with.
        """
        return pulumi.get(self, "api_management_api_id")

    @property
    @pulumi.getter(name="appCommandLine")
    def app_command_line(self) -> Optional[str]:
        """
        The App command line to launch.
        """
        return pulumi.get(self, "app_command_line")

    @property
    @pulumi.getter(name="applicationStack")
    def application_stack(self) -> Optional['outputs.LinuxWebAppSlotSiteConfigApplicationStack']:
        """
        A `application_stack` block as defined above.
        """
        return pulumi.get(self, "application_stack")

    @property
    @pulumi.getter(name="autoHealEnabled")
    def auto_heal_enabled(self) -> Optional[bool]:
        """
        Should Auto heal rules be enabled? Required with `auto_heal_setting`.
        """
        return pulumi.get(self, "auto_heal_enabled")

    @property
    @pulumi.getter(name="autoHealSetting")
    def auto_heal_setting(self) -> Optional['outputs.LinuxWebAppSlotSiteConfigAutoHealSetting']:
        """
        A `auto_heal_setting` block as defined above. Required with `auto_heal`.
        """
        return pulumi.get(self, "auto_heal_setting")

    @property
    @pulumi.getter(name="autoSwapSlotName")
    def auto_swap_slot_name(self) -> Optional[str]:
        """
        The Linux Web App Slot Name to automatically swap to when deployment to that slot is successfully completed.

        > **Note:** This must be a valid slot name on the target Linux Web App.
        """
        return pulumi.get(self, "auto_swap_slot_name")

    @property
    @pulumi.getter(name="containerRegistryManagedIdentityClientId")
    def container_registry_managed_identity_client_id(self) -> Optional[str]:
        """
        The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
        """
        return pulumi.get(self, "container_registry_managed_identity_client_id")

    @property
    @pulumi.getter(name="containerRegistryUseManagedIdentity")
    def container_registry_use_managed_identity(self) -> Optional[bool]:
        """
        Should connections for Azure Container Registry use Managed Identity.
        """
        return pulumi.get(self, "container_registry_use_managed_identity")

    @property
    @pulumi.getter
    def cors(self) -> Optional['outputs.LinuxWebAppSlotSiteConfigCors']:
        """
        A `cors` block as defined above.
        """
        return pulumi.get(self, "cors")

    @property
    @pulumi.getter(name="defaultDocuments")
    def default_documents(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Default Documents for the Linux Web App.
        """
        return pulumi.get(self, "default_documents")

    @property
    @pulumi.getter(name="detailedErrorLoggingEnabled")
    def detailed_error_logging_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "detailed_error_logging_enabled")

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> Optional[str]:
        return pulumi.get(self, "ftps_state")

    @property
    @pulumi.getter(name="healthCheckEvictionTimeInMin")
    def health_check_eviction_time_in_min(self) -> Optional[int]:
        """
        The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        """
        return pulumi.get(self, "health_check_eviction_time_in_min")

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> Optional[str]:
        """
        The path to the Health Check.
        """
        return pulumi.get(self, "health_check_path")

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[bool]:
        """
        Should the HTTP2 be enabled?
        """
        return pulumi.get(self, "http2_enabled")

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Optional[Sequence['outputs.LinuxWebAppSlotSiteConfigIpRestriction']]:
        """
        One or more `ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "ip_restrictions")

    @property
    @pulumi.getter(name="linuxFxVersion")
    def linux_fx_version(self) -> Optional[str]:
        return pulumi.get(self, "linux_fx_version")

    @property
    @pulumi.getter(name="loadBalancingMode")
    def load_balancing_mode(self) -> Optional[str]:
        """
        The Site load balancing. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        """
        return pulumi.get(self, "load_balancing_mode")

    @property
    @pulumi.getter(name="localMysqlEnabled")
    def local_mysql_enabled(self) -> Optional[bool]:
        """
        Use Local MySQL. Defaults to `false`.
        """
        return pulumi.get(self, "local_mysql_enabled")

    @property
    @pulumi.getter(name="managedPipelineMode")
    def managed_pipeline_mode(self) -> Optional[str]:
        """
        Managed pipeline mode. Possible values include: `Integrated`, `Classic`.
        """
        return pulumi.get(self, "managed_pipeline_mode")

    @property
    @pulumi.getter(name="minimumTlsVersion")
    def minimum_tls_version(self) -> Optional[str]:
        """
        The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        """
        return pulumi.get(self, "minimum_tls_version")

    @property
    @pulumi.getter(name="remoteDebuggingEnabled")
    def remote_debugging_enabled(self) -> Optional[bool]:
        """
        Should Remote Debugging be enabled? Defaults to `false`.
        """
        return pulumi.get(self, "remote_debugging_enabled")

    @property
    @pulumi.getter(name="remoteDebuggingVersion")
    def remote_debugging_version(self) -> Optional[str]:
        """
        The Remote Debugging Version. Possible values include `VS2017` and `VS2019`
        """
        return pulumi.get(self, "remote_debugging_version")

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Optional[Sequence['outputs.LinuxWebAppSlotSiteConfigScmIpRestriction']]:
        """
        One or more `scm_ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "scm_ip_restrictions")

    @property
    @pulumi.getter(name="scmMinimumTlsVersion")
    def scm_minimum_tls_version(self) -> Optional[str]:
        """
        The configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        """
        return pulumi.get(self, "scm_minimum_tls_version")

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> Optional[str]:
        return pulumi.get(self, "scm_type")

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> Optional[bool]:
        """
        Should the Linux Web App `ip_restriction` configuration be used for the SCM also.
        """
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @property
    @pulumi.getter(name="use32BitWorker")
    def use32_bit_worker(self) -> Optional[bool]:
        """
        Should the Linux Web App use a 32-bit worker? Defaults to `true`.
        """
        return pulumi.get(self, "use32_bit_worker")

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> Optional[bool]:
        """
        Should all outbound traffic have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        """
        return pulumi.get(self, "vnet_route_all_enabled")

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> Optional[bool]:
        """
        Should Web Sockets be enabled? Defaults to `false`.
        """
        return pulumi.get(self, "websockets_enabled")

    @property
    @pulumi.getter(name="workerCount")
    def worker_count(self) -> Optional[int]:
        """
        The number of Workers for this Linux App Service Slot.
        """
        return pulumi.get(self, "worker_count")


@pulumi.output_type
class LinuxWebAppSlotSiteConfigApplicationStack(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dockerImage":
            suggest = "docker_image"
        elif key == "dockerImageName":
            suggest = "docker_image_name"
        elif key == "dockerImageTag":
            suggest = "docker_image_tag"
        elif key == "dockerRegistryPassword":
            suggest = "docker_registry_password"
        elif key == "dockerRegistryUrl":
            suggest = "docker_registry_url"
        elif key == "dockerRegistryUsername":
            suggest = "docker_registry_username"
        elif key == "dotnetVersion":
            suggest = "dotnet_version"
        elif key == "goVersion":
            suggest = "go_version"
        elif key == "javaServer":
            suggest = "java_server"
        elif key == "javaServerVersion":
            suggest = "java_server_version"
        elif key == "javaVersion":
            suggest = "java_version"
        elif key == "nodeVersion":
            suggest = "node_version"
        elif key == "phpVersion":
            suggest = "php_version"
        elif key == "pythonVersion":
            suggest = "python_version"
        elif key == "rubyVersion":
            suggest = "ruby_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotSiteConfigApplicationStack. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotSiteConfigApplicationStack.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotSiteConfigApplicationStack.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 docker_image: Optional[str] = None,
                 docker_image_name: Optional[str] = None,
                 docker_image_tag: Optional[str] = None,
                 docker_registry_password: Optional[str] = None,
                 docker_registry_url: Optional[str] = None,
                 docker_registry_username: Optional[str] = None,
                 dotnet_version: Optional[str] = None,
                 go_version: Optional[str] = None,
                 java_server: Optional[str] = None,
                 java_server_version: Optional[str] = None,
                 java_version: Optional[str] = None,
                 node_version: Optional[str] = None,
                 php_version: Optional[str] = None,
                 python_version: Optional[str] = None,
                 ruby_version: Optional[str] = None):
        """
        :param str docker_image_name: The docker image, including tag, to be used. e.g. `appsvc/staticsite:latest`.
        :param str docker_registry_password: The User Name to use for authentication against the registry to pull the image.
               
               > **NOTE:** `docker_registry_url`, `docker_registry_username`, and `docker_registry_password` replace the use of the `app_settings` values of `DOCKER_REGISTRY_SERVER_URL`, `DOCKER_REGISTRY_SERVER_USERNAME` and `DOCKER_REGISTRY_SERVER_PASSWORD` respectively, these values will be managed by the provider and should not be specified in the `app_settings` map.
        :param str docker_registry_url: The URL of the container registry where the `docker_image_name` is located. e.g. `https://index.docker.io` or `https://mcr.microsoft.com`. This value is required with `docker_image_name`.
        :param str docker_registry_username: The User Name to use for authentication against the registry to pull the image.
        :param str dotnet_version: The version of .NET to use. Possible values include `3.1`, `5.0`, `6.0` and `7.0`.
        :param str go_version: The version of Go to use. Possible values include `1.18`, and `1.19`.
        :param str java_server: The Java server type. Possible values include `JAVA`, `TOMCAT`, and `JBOSSEAP`.
               
               > **NOTE:** `JBOSSEAP` requires a Premium Service Plan SKU to be a valid option.
        :param str java_server_version: The Version of the `java_server` to use.
        :param str java_version: The Version of Java to use. Possible values include `8`, `11`, and `17`.
               
               > **NOTE:** The valid version combinations for `java_version`, `java_server` and `java_server_version` can be checked from the command line via `az webapp list-runtimes --linux`.
        :param str node_version: The version of Node to run. Possible values include `12-lts`, `14-lts`, `16-lts`, and `18-lts`. This property conflicts with `java_version`.
               
               > **NOTE:** 10.x versions have been/are being deprecated so may cease to work for new resources in the future and may be removed from the provider.
        :param str php_version: The version of PHP to run. Possible values are `8.0`, `8.1` and `8.2`.
               
               > **NOTE:** version `7.4` is deprecated and will be removed from the provider in a future version.
        :param str python_version: The version of Python to run. Possible values include `3.7`, `3.8`, `3.9`, `3.10` and `3.11`.
        :param str ruby_version: Te version of Ruby to run. Possible values include `2.6` and `2.7`.
        """
        if docker_image is not None:
            pulumi.set(__self__, "docker_image", docker_image)
        if docker_image_name is not None:
            pulumi.set(__self__, "docker_image_name", docker_image_name)
        if docker_image_tag is not None:
            pulumi.set(__self__, "docker_image_tag", docker_image_tag)
        if docker_registry_password is not None:
            pulumi.set(__self__, "docker_registry_password", docker_registry_password)
        if docker_registry_url is not None:
            pulumi.set(__self__, "docker_registry_url", docker_registry_url)
        if docker_registry_username is not None:
            pulumi.set(__self__, "docker_registry_username", docker_registry_username)
        if dotnet_version is not None:
            pulumi.set(__self__, "dotnet_version", dotnet_version)
        if go_version is not None:
            pulumi.set(__self__, "go_version", go_version)
        if java_server is not None:
            pulumi.set(__self__, "java_server", java_server)
        if java_server_version is not None:
            pulumi.set(__self__, "java_server_version", java_server_version)
        if java_version is not None:
            pulumi.set(__self__, "java_version", java_version)
        if node_version is not None:
            pulumi.set(__self__, "node_version", node_version)
        if php_version is not None:
            pulumi.set(__self__, "php_version", php_version)
        if python_version is not None:
            pulumi.set(__self__, "python_version", python_version)
        if ruby_version is not None:
            pulumi.set(__self__, "ruby_version", ruby_version)

    @property
    @pulumi.getter(name="dockerImage")
    def docker_image(self) -> Optional[str]:
        warnings.warn("""This property has been deprecated and will be removed in 4.0 of the provider.""", DeprecationWarning)
        pulumi.log.warn("""docker_image is deprecated: This property has been deprecated and will be removed in 4.0 of the provider.""")

        return pulumi.get(self, "docker_image")

    @property
    @pulumi.getter(name="dockerImageName")
    def docker_image_name(self) -> Optional[str]:
        """
        The docker image, including tag, to be used. e.g. `appsvc/staticsite:latest`.
        """
        return pulumi.get(self, "docker_image_name")

    @property
    @pulumi.getter(name="dockerImageTag")
    def docker_image_tag(self) -> Optional[str]:
        warnings.warn("""This property has been deprecated and will be removed in 4.0 of the provider.""", DeprecationWarning)
        pulumi.log.warn("""docker_image_tag is deprecated: This property has been deprecated and will be removed in 4.0 of the provider.""")

        return pulumi.get(self, "docker_image_tag")

    @property
    @pulumi.getter(name="dockerRegistryPassword")
    def docker_registry_password(self) -> Optional[str]:
        """
        The User Name to use for authentication against the registry to pull the image.

        > **NOTE:** `docker_registry_url`, `docker_registry_username`, and `docker_registry_password` replace the use of the `app_settings` values of `DOCKER_REGISTRY_SERVER_URL`, `DOCKER_REGISTRY_SERVER_USERNAME` and `DOCKER_REGISTRY_SERVER_PASSWORD` respectively, these values will be managed by the provider and should not be specified in the `app_settings` map.
        """
        return pulumi.get(self, "docker_registry_password")

    @property
    @pulumi.getter(name="dockerRegistryUrl")
    def docker_registry_url(self) -> Optional[str]:
        """
        The URL of the container registry where the `docker_image_name` is located. e.g. `https://index.docker.io` or `https://mcr.microsoft.com`. This value is required with `docker_image_name`.
        """
        return pulumi.get(self, "docker_registry_url")

    @property
    @pulumi.getter(name="dockerRegistryUsername")
    def docker_registry_username(self) -> Optional[str]:
        """
        The User Name to use for authentication against the registry to pull the image.
        """
        return pulumi.get(self, "docker_registry_username")

    @property
    @pulumi.getter(name="dotnetVersion")
    def dotnet_version(self) -> Optional[str]:
        """
        The version of .NET to use. Possible values include `3.1`, `5.0`, `6.0` and `7.0`.
        """
        return pulumi.get(self, "dotnet_version")

    @property
    @pulumi.getter(name="goVersion")
    def go_version(self) -> Optional[str]:
        """
        The version of Go to use. Possible values include `1.18`, and `1.19`.
        """
        return pulumi.get(self, "go_version")

    @property
    @pulumi.getter(name="javaServer")
    def java_server(self) -> Optional[str]:
        """
        The Java server type. Possible values include `JAVA`, `TOMCAT`, and `JBOSSEAP`.

        > **NOTE:** `JBOSSEAP` requires a Premium Service Plan SKU to be a valid option.
        """
        return pulumi.get(self, "java_server")

    @property
    @pulumi.getter(name="javaServerVersion")
    def java_server_version(self) -> Optional[str]:
        """
        The Version of the `java_server` to use.
        """
        return pulumi.get(self, "java_server_version")

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> Optional[str]:
        """
        The Version of Java to use. Possible values include `8`, `11`, and `17`.

        > **NOTE:** The valid version combinations for `java_version`, `java_server` and `java_server_version` can be checked from the command line via `az webapp list-runtimes --linux`.
        """
        return pulumi.get(self, "java_version")

    @property
    @pulumi.getter(name="nodeVersion")
    def node_version(self) -> Optional[str]:
        """
        The version of Node to run. Possible values include `12-lts`, `14-lts`, `16-lts`, and `18-lts`. This property conflicts with `java_version`.

        > **NOTE:** 10.x versions have been/are being deprecated so may cease to work for new resources in the future and may be removed from the provider.
        """
        return pulumi.get(self, "node_version")

    @property
    @pulumi.getter(name="phpVersion")
    def php_version(self) -> Optional[str]:
        """
        The version of PHP to run. Possible values are `8.0`, `8.1` and `8.2`.

        > **NOTE:** version `7.4` is deprecated and will be removed from the provider in a future version.
        """
        return pulumi.get(self, "php_version")

    @property
    @pulumi.getter(name="pythonVersion")
    def python_version(self) -> Optional[str]:
        """
        The version of Python to run. Possible values include `3.7`, `3.8`, `3.9`, `3.10` and `3.11`.
        """
        return pulumi.get(self, "python_version")

    @property
    @pulumi.getter(name="rubyVersion")
    def ruby_version(self) -> Optional[str]:
        """
        Te version of Ruby to run. Possible values include `2.6` and `2.7`.
        """
        return pulumi.get(self, "ruby_version")


@pulumi.output_type
class LinuxWebAppSlotSiteConfigAutoHealSetting(dict):
    def __init__(__self__, *,
                 action: Optional['outputs.LinuxWebAppSlotSiteConfigAutoHealSettingAction'] = None,
                 trigger: Optional['outputs.LinuxWebAppSlotSiteConfigAutoHealSettingTrigger'] = None):
        """
        :param 'LinuxWebAppSlotSiteConfigAutoHealSettingActionArgs' action: A `action` block as defined above.
        :param 'LinuxWebAppSlotSiteConfigAutoHealSettingTriggerArgs' trigger: A `trigger` block as defined below.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if trigger is not None:
            pulumi.set(__self__, "trigger", trigger)

    @property
    @pulumi.getter
    def action(self) -> Optional['outputs.LinuxWebAppSlotSiteConfigAutoHealSettingAction']:
        """
        A `action` block as defined above.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def trigger(self) -> Optional['outputs.LinuxWebAppSlotSiteConfigAutoHealSettingTrigger']:
        """
        A `trigger` block as defined below.
        """
        return pulumi.get(self, "trigger")


@pulumi.output_type
class LinuxWebAppSlotSiteConfigAutoHealSettingAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionType":
            suggest = "action_type"
        elif key == "minimumProcessExecutionTime":
            suggest = "minimum_process_execution_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotSiteConfigAutoHealSettingAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotSiteConfigAutoHealSettingAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotSiteConfigAutoHealSettingAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_type: str,
                 minimum_process_execution_time: Optional[str] = None):
        """
        :param str action_type: Predefined action to be taken to an Auto Heal trigger. Possible values include: `Recycle`.
        :param str minimum_process_execution_time: The minimum amount of time in `hh:mm:ss` the Linux Web App must have been running before the defined action will be run in the event of a trigger.
        """
        pulumi.set(__self__, "action_type", action_type)
        if minimum_process_execution_time is not None:
            pulumi.set(__self__, "minimum_process_execution_time", minimum_process_execution_time)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> str:
        """
        Predefined action to be taken to an Auto Heal trigger. Possible values include: `Recycle`.
        """
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter(name="minimumProcessExecutionTime")
    def minimum_process_execution_time(self) -> Optional[str]:
        """
        The minimum amount of time in `hh:mm:ss` the Linux Web App must have been running before the defined action will be run in the event of a trigger.
        """
        return pulumi.get(self, "minimum_process_execution_time")


@pulumi.output_type
class LinuxWebAppSlotSiteConfigAutoHealSettingTrigger(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slowRequests":
            suggest = "slow_requests"
        elif key == "statusCodes":
            suggest = "status_codes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotSiteConfigAutoHealSettingTrigger. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotSiteConfigAutoHealSettingTrigger.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotSiteConfigAutoHealSettingTrigger.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 requests: Optional['outputs.LinuxWebAppSlotSiteConfigAutoHealSettingTriggerRequests'] = None,
                 slow_requests: Optional[Sequence['outputs.LinuxWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequest']] = None,
                 status_codes: Optional[Sequence['outputs.LinuxWebAppSlotSiteConfigAutoHealSettingTriggerStatusCode']] = None):
        """
        :param 'LinuxWebAppSlotSiteConfigAutoHealSettingTriggerRequestsArgs' requests: A `requests` block as defined above.
        :param Sequence['LinuxWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestArgs'] slow_requests: One or more `slow_request` blocks as defined above.
        :param Sequence['LinuxWebAppSlotSiteConfigAutoHealSettingTriggerStatusCodeArgs'] status_codes: One or more `status_code` blocks as defined above.
        """
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if slow_requests is not None:
            pulumi.set(__self__, "slow_requests", slow_requests)
        if status_codes is not None:
            pulumi.set(__self__, "status_codes", status_codes)

    @property
    @pulumi.getter
    def requests(self) -> Optional['outputs.LinuxWebAppSlotSiteConfigAutoHealSettingTriggerRequests']:
        """
        A `requests` block as defined above.
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="slowRequests")
    def slow_requests(self) -> Optional[Sequence['outputs.LinuxWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequest']]:
        """
        One or more `slow_request` blocks as defined above.
        """
        return pulumi.get(self, "slow_requests")

    @property
    @pulumi.getter(name="statusCodes")
    def status_codes(self) -> Optional[Sequence['outputs.LinuxWebAppSlotSiteConfigAutoHealSettingTriggerStatusCode']]:
        """
        One or more `status_code` blocks as defined above.
        """
        return pulumi.get(self, "status_codes")


@pulumi.output_type
class LinuxWebAppSlotSiteConfigAutoHealSettingTriggerRequests(dict):
    def __init__(__self__, *,
                 count: int,
                 interval: str):
        """
        :param int count: The number of requests in the specified `interval` to trigger this rule.
        :param str interval: The interval in `hh:mm:ss`.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of requests in the specified `interval` to trigger this rule.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        The interval in `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class LinuxWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeTaken":
            suggest = "time_taken"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: int,
                 interval: str,
                 time_taken: str,
                 path: Optional[str] = None):
        """
        :param int count: The number of Slow Requests in the time `interval` to trigger this rule.
        :param str interval: The time interval in the form `hh:mm:ss`.
        :param str time_taken: The threshold of time passed to qualify as a Slow Request in `hh:mm:ss`.
        :param str path: The path for which this slow request rule applies.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "time_taken", time_taken)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of Slow Requests in the time `interval` to trigger this rule.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        The time interval in the form `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="timeTaken")
    def time_taken(self) -> str:
        """
        The threshold of time passed to qualify as a Slow Request in `hh:mm:ss`.
        """
        return pulumi.get(self, "time_taken")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path for which this slow request rule applies.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class LinuxWebAppSlotSiteConfigAutoHealSettingTriggerStatusCode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusCodeRange":
            suggest = "status_code_range"
        elif key == "subStatus":
            suggest = "sub_status"
        elif key == "win32StatusCode":
            suggest = "win32_status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotSiteConfigAutoHealSettingTriggerStatusCode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotSiteConfigAutoHealSettingTriggerStatusCode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotSiteConfigAutoHealSettingTriggerStatusCode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: int,
                 interval: str,
                 status_code_range: str,
                 path: Optional[str] = None,
                 sub_status: Optional[int] = None,
                 win32_status_code: Optional[int] = None):
        """
        :param int count: The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        :param str interval: The time interval in the form `hh:mm:ss`.
        :param str status_code_range: The status code for this rule, accepts single status codes and status code ranges. e.g. `500` or `400-499`. Possible values are integers between `101` and `599`
        :param str path: The path to which this rule status code applies.
        :param int sub_status: The Request Sub Status of the Status Code.
        :param int win32_status_code: The Win32 Status Code of the Request.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "status_code_range", status_code_range)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if sub_status is not None:
            pulumi.set(__self__, "sub_status", sub_status)
        if win32_status_code is not None:
            pulumi.set(__self__, "win32_status_code", win32_status_code)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        The time interval in the form `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="statusCodeRange")
    def status_code_range(self) -> str:
        """
        The status code for this rule, accepts single status codes and status code ranges. e.g. `500` or `400-499`. Possible values are integers between `101` and `599`
        """
        return pulumi.get(self, "status_code_range")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path to which this rule status code applies.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="subStatus")
    def sub_status(self) -> Optional[int]:
        """
        The Request Sub Status of the Status Code.
        """
        return pulumi.get(self, "sub_status")

    @property
    @pulumi.getter(name="win32StatusCode")
    def win32_status_code(self) -> Optional[int]:
        """
        The Win32 Status Code of the Request.
        """
        return pulumi.get(self, "win32_status_code")


@pulumi.output_type
class LinuxWebAppSlotSiteConfigCors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedOrigins":
            suggest = "allowed_origins"
        elif key == "supportCredentials":
            suggest = "support_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotSiteConfigCors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotSiteConfigCors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotSiteConfigCors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_origins: Optional[Sequence[str]] = None,
                 support_credentials: Optional[bool] = None):
        """
        :param Sequence[str] allowed_origins: Specifies a list of origins that should be allowed to make cross-origin calls.
        :param bool support_credentials: Whether CORS requests with credentials are allowed. Defaults to `false`
        """
        if allowed_origins is not None:
            pulumi.set(__self__, "allowed_origins", allowed_origins)
        if support_credentials is not None:
            pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of origins that should be allowed to make cross-origin calls.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> Optional[bool]:
        """
        Whether CORS requests with credentials are allowed. Defaults to `false`
        """
        return pulumi.get(self, "support_credentials")


@pulumi.output_type
class LinuxWebAppSlotSiteConfigIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotSiteConfigIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotSiteConfigIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotSiteConfigIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.LinuxWebAppSlotSiteConfigIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: The action to take. Possible values are `Allow` or `Deny`.
        :param 'LinuxWebAppSlotSiteConfigIpRestrictionHeadersArgs' headers: A `headers` block as defined above.
        :param str ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param str name: The name which should be used for this `ip_restriction`.
        :param int priority: The priority value of this `ip_restriction`. Defaults to `65000`.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
               
               > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        The action to take. Possible values are `Allow` or `Deny`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.LinuxWebAppSlotSiteConfigIpRestrictionHeaders']:
        """
        A `headers` block as defined above.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class LinuxWebAppSlotSiteConfigIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotSiteConfigIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param str x_fd_health_probe: Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        :param Sequence[str] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param Sequence[str] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class LinuxWebAppSlotSiteConfigScmIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotSiteConfigScmIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotSiteConfigScmIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotSiteConfigScmIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.LinuxWebAppSlotSiteConfigScmIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: The action to take. Possible values are `Allow` or `Deny`.
        :param 'LinuxWebAppSlotSiteConfigScmIpRestrictionHeadersArgs' headers: A `headers` block as defined above.
        :param str ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param str name: The name which should be used for this `ip_restriction`.
        :param int priority: The priority value of this `ip_restriction`. Defaults to `65000`.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
               
               > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        The action to take. Possible values are `Allow` or `Deny`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.LinuxWebAppSlotSiteConfigScmIpRestrictionHeaders']:
        """
        A `headers` block as defined above.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class LinuxWebAppSlotSiteConfigScmIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotSiteConfigScmIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param str x_fd_health_probe: Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        :param Sequence[str] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param Sequence[str] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class LinuxWebAppSlotSiteCredential(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 password: Optional[str] = None):
        """
        :param str password: The Site Credentials Password used for publishing.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The Site Credentials Password used for publishing.
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class LinuxWebAppSlotStorageAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "accountName":
            suggest = "account_name"
        elif key == "shareName":
            suggest = "share_name"
        elif key == "mountPath":
            suggest = "mount_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotStorageAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotStorageAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotStorageAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: str,
                 account_name: str,
                 name: str,
                 share_name: str,
                 type: str,
                 mount_path: Optional[str] = None):
        """
        :param str access_key: The Access key for the storage account.
        :param str account_name: The Name of the Storage Account.
        :param str name: The name which should be used for this Storage Account.
        :param str share_name: The Name of the File Share or Container Name for Blob storage.
        :param str type: The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`
        :param str mount_path: The path at which to mount the storage share.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "share_name", share_name)
        pulumi.set(__self__, "type", type)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> str:
        """
        The Access key for the storage account.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> str:
        """
        The Name of the Storage Account.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Storage Account.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> str:
        """
        The Name of the File Share or Container Name for Blob storage.
        """
        return pulumi.get(self, "share_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[str]:
        """
        The path at which to mount the storage share.
        """
        return pulumi.get(self, "mount_path")


@pulumi.output_type
class LinuxWebAppStickySettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appSettingNames":
            suggest = "app_setting_names"
        elif key == "connectionStringNames":
            suggest = "connection_string_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppStickySettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppStickySettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppStickySettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_setting_names: Optional[Sequence[str]] = None,
                 connection_string_names: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] app_setting_names: A list of `app_setting` names that the Linux Web App will not swap between Slots when a swap operation is triggered.
        :param Sequence[str] connection_string_names: A list of `connection_string` names that the Linux Web App will not swap between Slots when a swap operation is triggered.
        """
        if app_setting_names is not None:
            pulumi.set(__self__, "app_setting_names", app_setting_names)
        if connection_string_names is not None:
            pulumi.set(__self__, "connection_string_names", connection_string_names)

    @property
    @pulumi.getter(name="appSettingNames")
    def app_setting_names(self) -> Optional[Sequence[str]]:
        """
        A list of `app_setting` names that the Linux Web App will not swap between Slots when a swap operation is triggered.
        """
        return pulumi.get(self, "app_setting_names")

    @property
    @pulumi.getter(name="connectionStringNames")
    def connection_string_names(self) -> Optional[Sequence[str]]:
        """
        A list of `connection_string` names that the Linux Web App will not swap between Slots when a swap operation is triggered.
        """
        return pulumi.get(self, "connection_string_names")


@pulumi.output_type
class LinuxWebAppStorageAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "accountName":
            suggest = "account_name"
        elif key == "shareName":
            suggest = "share_name"
        elif key == "mountPath":
            suggest = "mount_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppStorageAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppStorageAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppStorageAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: str,
                 account_name: str,
                 name: str,
                 share_name: str,
                 type: str,
                 mount_path: Optional[str] = None):
        """
        :param str access_key: The Access key for the storage account.
        :param str account_name: The Name of the Storage Account.
        :param str name: The name which should be used for this Storage Account.
        :param str share_name: The Name of the File Share or Container Name for Blob storage.
        :param str type: The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`
        :param str mount_path: The path at which to mount the storage share.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "share_name", share_name)
        pulumi.set(__self__, "type", type)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> str:
        """
        The Access key for the storage account.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> str:
        """
        The Name of the Storage Account.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Storage Account.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> str:
        """
        The Name of the File Share or Container Name for Blob storage.
        """
        return pulumi.get(self, "share_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[str]:
        """
        The path at which to mount the storage share.
        """
        return pulumi.get(self, "mount_path")


@pulumi.output_type
class PlanSku(dict):
    def __init__(__self__, *,
                 size: str,
                 tier: str,
                 capacity: Optional[int] = None):
        """
        :param str size: Specifies the plan's instance size.
        :param str tier: Specifies the plan's pricing tier.
        :param int capacity: Specifies the number of workers associated with this App Service Plan.
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "tier", tier)
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)

    @property
    @pulumi.getter
    def size(self) -> str:
        """
        Specifies the plan's instance size.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def tier(self) -> str:
        """
        Specifies the plan's pricing tier.
        """
        return pulumi.get(self, "tier")

    @property
    @pulumi.getter
    def capacity(self) -> Optional[int]:
        """
        Specifies the number of workers associated with this App Service Plan.
        """
        return pulumi.get(self, "capacity")


@pulumi.output_type
class SlotAuthSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeDirectory":
            suggest = "active_directory"
        elif key == "additionalLoginParams":
            suggest = "additional_login_params"
        elif key == "allowedExternalRedirectUrls":
            suggest = "allowed_external_redirect_urls"
        elif key == "defaultProvider":
            suggest = "default_provider"
        elif key == "runtimeVersion":
            suggest = "runtime_version"
        elif key == "tokenRefreshExtensionHours":
            suggest = "token_refresh_extension_hours"
        elif key == "tokenStoreEnabled":
            suggest = "token_store_enabled"
        elif key == "unauthenticatedClientAction":
            suggest = "unauthenticated_client_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SlotAuthSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SlotAuthSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SlotAuthSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 active_directory: Optional['outputs.SlotAuthSettingsActiveDirectory'] = None,
                 additional_login_params: Optional[Mapping[str, str]] = None,
                 allowed_external_redirect_urls: Optional[Sequence[str]] = None,
                 default_provider: Optional[str] = None,
                 facebook: Optional['outputs.SlotAuthSettingsFacebook'] = None,
                 google: Optional['outputs.SlotAuthSettingsGoogle'] = None,
                 issuer: Optional[str] = None,
                 microsoft: Optional['outputs.SlotAuthSettingsMicrosoft'] = None,
                 runtime_version: Optional[str] = None,
                 token_refresh_extension_hours: Optional[float] = None,
                 token_store_enabled: Optional[bool] = None,
                 twitter: Optional['outputs.SlotAuthSettingsTwitter'] = None,
                 unauthenticated_client_action: Optional[str] = None):
        """
        :param bool enabled: Is Authentication enabled?
        :param 'SlotAuthSettingsActiveDirectoryArgs' active_directory: A `active_directory` block as defined below.
        :param Mapping[str, str] additional_login_params: Login parameters to send to the OpenID Connect authorization endpoint when a user logs in. Each parameter must be in the form "key=value".
        :param Sequence[str] allowed_external_redirect_urls: External URLs that can be redirected to as part of logging in or logging out of the app.
        :param str default_provider: The default provider to use when multiple providers have been set up. Possible values are `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount` and `Twitter`.
               
               > **NOTE:** When using multiple providers, the default provider must be set for settings like `unauthenticated_client_action` to work.
        :param 'SlotAuthSettingsFacebookArgs' facebook: A `facebook` block as defined below.
        :param 'SlotAuthSettingsGoogleArgs' google: A `google` block as defined below.
        :param str issuer: Issuer URI. When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        :param 'SlotAuthSettingsMicrosoftArgs' microsoft: A `microsoft` block as defined below.
        :param str runtime_version: The runtime version of the Authentication/Authorization module.
        :param float token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72`.
        :param bool token_store_enabled: If enabled the module will durably store platform-specific security tokens that are obtained during login flows. Defaults to `false`.
        :param 'SlotAuthSettingsTwitterArgs' twitter: A `twitter` block as defined below.
        :param str unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app. Possible values are `AllowAnonymous` and `RedirectToLoginPage`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if active_directory is not None:
            pulumi.set(__self__, "active_directory", active_directory)
        if additional_login_params is not None:
            pulumi.set(__self__, "additional_login_params", additional_login_params)
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if facebook is not None:
            pulumi.set(__self__, "facebook", facebook)
        if google is not None:
            pulumi.set(__self__, "google", google)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if microsoft is not None:
            pulumi.set(__self__, "microsoft", microsoft)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if token_refresh_extension_hours is not None:
            pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if twitter is not None:
            pulumi.set(__self__, "twitter", twitter)
        if unauthenticated_client_action is not None:
            pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is Authentication enabled?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="activeDirectory")
    def active_directory(self) -> Optional['outputs.SlotAuthSettingsActiveDirectory']:
        """
        A `active_directory` block as defined below.
        """
        return pulumi.get(self, "active_directory")

    @property
    @pulumi.getter(name="additionalLoginParams")
    def additional_login_params(self) -> Optional[Mapping[str, str]]:
        """
        Login parameters to send to the OpenID Connect authorization endpoint when a user logs in. Each parameter must be in the form "key=value".
        """
        return pulumi.get(self, "additional_login_params")

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[Sequence[str]]:
        """
        External URLs that can be redirected to as part of logging in or logging out of the app.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[str]:
        """
        The default provider to use when multiple providers have been set up. Possible values are `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount` and `Twitter`.

        > **NOTE:** When using multiple providers, the default provider must be set for settings like `unauthenticated_client_action` to work.
        """
        return pulumi.get(self, "default_provider")

    @property
    @pulumi.getter
    def facebook(self) -> Optional['outputs.SlotAuthSettingsFacebook']:
        """
        A `facebook` block as defined below.
        """
        return pulumi.get(self, "facebook")

    @property
    @pulumi.getter
    def google(self) -> Optional['outputs.SlotAuthSettingsGoogle']:
        """
        A `google` block as defined below.
        """
        return pulumi.get(self, "google")

    @property
    @pulumi.getter
    def issuer(self) -> Optional[str]:
        """
        Issuer URI. When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def microsoft(self) -> Optional['outputs.SlotAuthSettingsMicrosoft']:
        """
        A `microsoft` block as defined below.
        """
        return pulumi.get(self, "microsoft")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[str]:
        """
        The runtime version of the Authentication/Authorization module.
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> Optional[float]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72`.
        """
        return pulumi.get(self, "token_refresh_extension_hours")

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[bool]:
        """
        If enabled the module will durably store platform-specific security tokens that are obtained during login flows. Defaults to `false`.
        """
        return pulumi.get(self, "token_store_enabled")

    @property
    @pulumi.getter
    def twitter(self) -> Optional['outputs.SlotAuthSettingsTwitter']:
        """
        A `twitter` block as defined below.
        """
        return pulumi.get(self, "twitter")

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> Optional[str]:
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values are `AllowAnonymous` and `RedirectToLoginPage`.
        """
        return pulumi.get(self, "unauthenticated_client_action")


@pulumi.output_type
class SlotAuthSettingsActiveDirectory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "clientSecret":
            suggest = "client_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SlotAuthSettingsActiveDirectory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SlotAuthSettingsActiveDirectory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SlotAuthSettingsActiveDirectory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 client_secret: Optional[str] = None):
        """
        :param str client_id: The Client ID of this relying party application. Enables OpenIDConnection authentication with Azure Active Directory.
        :param Sequence[str] allowed_audiences: Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
        :param str client_secret: The Client Secret of this relying party application. If no secret is provided, implicit flow will be used.
        """
        pulumi.set(__self__, "client_id", client_id)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The Client ID of this relying party application. Enables OpenIDConnection authentication with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret of this relying party application. If no secret is provided, implicit flow will be used.
        """
        return pulumi.get(self, "client_secret")


@pulumi.output_type
class SlotAuthSettingsFacebook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "appSecret":
            suggest = "app_secret"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SlotAuthSettingsFacebook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SlotAuthSettingsFacebook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SlotAuthSettingsFacebook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: str,
                 app_secret: str,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str app_id: The App ID of the Facebook app used for login
        :param str app_secret: The App Secret of the Facebook app used for Facebook login.
        :param Sequence[str] oauth_scopes: The OAuth 2.0 scopes that will be requested as part of Facebook login authentication. <https://developers.facebook.com/docs/facebook-login>
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "app_secret", app_secret)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        The App ID of the Facebook app used for login
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appSecret")
    def app_secret(self) -> str:
        """
        The App Secret of the Facebook app used for Facebook login.
        """
        return pulumi.get(self, "app_secret")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        The OAuth 2.0 scopes that will be requested as part of Facebook login authentication. <https://developers.facebook.com/docs/facebook-login>
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class SlotAuthSettingsGoogle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SlotAuthSettingsGoogle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SlotAuthSettingsGoogle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SlotAuthSettingsGoogle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OpenID Connect Client ID for the Google web application.
        :param str client_secret: The client secret associated with the Google web application.
        :param Sequence[str] oauth_scopes: The OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. <https://developers.google.com/identity/sign-in/web/>
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OpenID Connect Client ID for the Google web application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The client secret associated with the Google web application.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        The OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. <https://developers.google.com/identity/sign-in/web/>
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class SlotAuthSettingsMicrosoft(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SlotAuthSettingsMicrosoft. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SlotAuthSettingsMicrosoft.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SlotAuthSettingsMicrosoft.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret: The OAuth 2.0 client secret that was created for the app used for authentication.
        :param Sequence[str] oauth_scopes: The OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. <https://msdn.microsoft.com/en-us/library/dn631845.aspx>
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        The OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. <https://msdn.microsoft.com/en-us/library/dn631845.aspx>
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class SlotAuthSettingsTwitter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerKey":
            suggest = "consumer_key"
        elif key == "consumerSecret":
            suggest = "consumer_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SlotAuthSettingsTwitter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SlotAuthSettingsTwitter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SlotAuthSettingsTwitter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_key: str,
                 consumer_secret: str):
        """
        :param str consumer_key: The consumer key of the Twitter app used for login
        :param str consumer_secret: The consumer secret of the Twitter app used for login.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        pulumi.set(__self__, "consumer_secret", consumer_secret)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> str:
        """
        The consumer key of the Twitter app used for login
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> str:
        """
        The consumer secret of the Twitter app used for login.
        """
        return pulumi.get(self, "consumer_secret")


@pulumi.output_type
class SlotConnectionString(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: The name of the Connection String.
        :param str type: The type of the Connection String. Possible values are `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
        :param str value: The value for the Connection String.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Connection String.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the Connection String. Possible values are `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the Connection String.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SlotIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SlotIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SlotIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SlotIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 identity_ids: Optional[Sequence[str]] = None,
                 principal_id: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str type: Specifies the identity type of the App Service. Possible values are `SystemAssigned` (where Azure will generate a Service Principal for you), `UserAssigned` where you can specify the Service Principal IDs in the `identity_ids` field, and `SystemAssigned, UserAssigned` which assigns both a system managed identity as well as the specified user assigned identities.
               
               > **NOTE:** When `type` is set to `SystemAssigned`, The assigned `principal_id` and `tenant_id` can be retrieved after the App Service has been created. More details are available below.
        :param Sequence[str] identity_ids: Specifies a list of user managed identity ids to be assigned. Required if `type` is `UserAssigned`.
        :param str principal_id: The Principal ID for the Service Principal associated with the Managed Service Identity of this App Service slot.
        :param str tenant_id: The Tenant ID for the Service Principal associated with the Managed Service Identity of this App Service slot.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the identity type of the App Service. Possible values are `SystemAssigned` (where Azure will generate a Service Principal for you), `UserAssigned` where you can specify the Service Principal IDs in the `identity_ids` field, and `SystemAssigned, UserAssigned` which assigns both a system managed identity as well as the specified user assigned identities.

        > **NOTE:** When `type` is set to `SystemAssigned`, The assigned `principal_id` and `tenant_id` can be retrieved after the App Service has been created. More details are available below.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of user managed identity ids to be assigned. Required if `type` is `UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        """
        The Principal ID for the Service Principal associated with the Managed Service Identity of this App Service slot.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The Tenant ID for the Service Principal associated with the Managed Service Identity of this App Service slot.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class SlotLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationLogs":
            suggest = "application_logs"
        elif key == "detailedErrorMessagesEnabled":
            suggest = "detailed_error_messages_enabled"
        elif key == "failedRequestTracingEnabled":
            suggest = "failed_request_tracing_enabled"
        elif key == "httpLogs":
            suggest = "http_logs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SlotLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SlotLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SlotLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_logs: Optional['outputs.SlotLogsApplicationLogs'] = None,
                 detailed_error_messages_enabled: Optional[bool] = None,
                 failed_request_tracing_enabled: Optional[bool] = None,
                 http_logs: Optional['outputs.SlotLogsHttpLogs'] = None):
        """
        :param 'SlotLogsApplicationLogsArgs' application_logs: An `application_logs` block as defined below.
        :param bool detailed_error_messages_enabled: Should `Detailed error messages` be enabled on this App Service slot? Defaults to `false`.
        :param bool failed_request_tracing_enabled: Should `Failed request tracing` be enabled on this App Service slot? Defaults to `false`.
        :param 'SlotLogsHttpLogsArgs' http_logs: An `http_logs` block as defined below.
        """
        if application_logs is not None:
            pulumi.set(__self__, "application_logs", application_logs)
        if detailed_error_messages_enabled is not None:
            pulumi.set(__self__, "detailed_error_messages_enabled", detailed_error_messages_enabled)
        if failed_request_tracing_enabled is not None:
            pulumi.set(__self__, "failed_request_tracing_enabled", failed_request_tracing_enabled)
        if http_logs is not None:
            pulumi.set(__self__, "http_logs", http_logs)

    @property
    @pulumi.getter(name="applicationLogs")
    def application_logs(self) -> Optional['outputs.SlotLogsApplicationLogs']:
        """
        An `application_logs` block as defined below.
        """
        return pulumi.get(self, "application_logs")

    @property
    @pulumi.getter(name="detailedErrorMessagesEnabled")
    def detailed_error_messages_enabled(self) -> Optional[bool]:
        """
        Should `Detailed error messages` be enabled on this App Service slot? Defaults to `false`.
        """
        return pulumi.get(self, "detailed_error_messages_enabled")

    @property
    @pulumi.getter(name="failedRequestTracingEnabled")
    def failed_request_tracing_enabled(self) -> Optional[bool]:
        """
        Should `Failed request tracing` be enabled on this App Service slot? Defaults to `false`.
        """
        return pulumi.get(self, "failed_request_tracing_enabled")

    @property
    @pulumi.getter(name="httpLogs")
    def http_logs(self) -> Optional['outputs.SlotLogsHttpLogs']:
        """
        An `http_logs` block as defined below.
        """
        return pulumi.get(self, "http_logs")


@pulumi.output_type
class SlotLogsApplicationLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureBlobStorage":
            suggest = "azure_blob_storage"
        elif key == "fileSystemLevel":
            suggest = "file_system_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SlotLogsApplicationLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SlotLogsApplicationLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SlotLogsApplicationLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_blob_storage: Optional['outputs.SlotLogsApplicationLogsAzureBlobStorage'] = None,
                 file_system_level: Optional[str] = None):
        """
        :param 'SlotLogsApplicationLogsAzureBlobStorageArgs' azure_blob_storage: An `azure_blob_storage` block as defined below.
        :param str file_system_level: The file system log level. Possible values are `Off`, `Error`, `Warning`, `Information`, and `Verbose`.
        """
        if azure_blob_storage is not None:
            pulumi.set(__self__, "azure_blob_storage", azure_blob_storage)
        if file_system_level is not None:
            pulumi.set(__self__, "file_system_level", file_system_level)

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional['outputs.SlotLogsApplicationLogsAzureBlobStorage']:
        """
        An `azure_blob_storage` block as defined below.
        """
        return pulumi.get(self, "azure_blob_storage")

    @property
    @pulumi.getter(name="fileSystemLevel")
    def file_system_level(self) -> Optional[str]:
        """
        The file system log level. Possible values are `Off`, `Error`, `Warning`, `Information`, and `Verbose`.
        """
        return pulumi.get(self, "file_system_level")


@pulumi.output_type
class SlotLogsApplicationLogsAzureBlobStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retentionInDays":
            suggest = "retention_in_days"
        elif key == "sasUrl":
            suggest = "sas_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SlotLogsApplicationLogsAzureBlobStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SlotLogsApplicationLogsAzureBlobStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SlotLogsApplicationLogsAzureBlobStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 level: str,
                 retention_in_days: int,
                 sas_url: str):
        """
        :param str level: The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        :param int retention_in_days: The number of days to retain logs for.
        :param str sas_url: The URL to the storage container, with a Service SAS token appended. **NOTE:** there is currently no means of generating Service SAS tokens with the `azurerm` provider.
        """
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "sas_url", sas_url)

    @property
    @pulumi.getter
    def level(self) -> str:
        """
        The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        """
        return pulumi.get(self, "level")

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> int:
        """
        The number of days to retain logs for.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> str:
        """
        The URL to the storage container, with a Service SAS token appended. **NOTE:** there is currently no means of generating Service SAS tokens with the `azurerm` provider.
        """
        return pulumi.get(self, "sas_url")


@pulumi.output_type
class SlotLogsHttpLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureBlobStorage":
            suggest = "azure_blob_storage"
        elif key == "fileSystem":
            suggest = "file_system"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SlotLogsHttpLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SlotLogsHttpLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SlotLogsHttpLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_blob_storage: Optional['outputs.SlotLogsHttpLogsAzureBlobStorage'] = None,
                 file_system: Optional['outputs.SlotLogsHttpLogsFileSystem'] = None):
        """
        :param 'SlotLogsHttpLogsAzureBlobStorageArgs' azure_blob_storage: An `azure_blob_storage` block as defined below.
        :param 'SlotLogsHttpLogsFileSystemArgs' file_system: A `file_system` block as defined below.
        """
        if azure_blob_storage is not None:
            pulumi.set(__self__, "azure_blob_storage", azure_blob_storage)
        if file_system is not None:
            pulumi.set(__self__, "file_system", file_system)

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional['outputs.SlotLogsHttpLogsAzureBlobStorage']:
        """
        An `azure_blob_storage` block as defined below.
        """
        return pulumi.get(self, "azure_blob_storage")

    @property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional['outputs.SlotLogsHttpLogsFileSystem']:
        """
        A `file_system` block as defined below.
        """
        return pulumi.get(self, "file_system")


@pulumi.output_type
class SlotLogsHttpLogsAzureBlobStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retentionInDays":
            suggest = "retention_in_days"
        elif key == "sasUrl":
            suggest = "sas_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SlotLogsHttpLogsAzureBlobStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SlotLogsHttpLogsAzureBlobStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SlotLogsHttpLogsAzureBlobStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 retention_in_days: int,
                 sas_url: str):
        """
        :param int retention_in_days: The number of days to retain logs for.
        :param str sas_url: The URL to the storage container, with a Service SAS token appended. **NOTE:** there is currently no means of generating Service SAS tokens with the `azurerm` provider.
        """
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "sas_url", sas_url)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> int:
        """
        The number of days to retain logs for.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> str:
        """
        The URL to the storage container, with a Service SAS token appended. **NOTE:** there is currently no means of generating Service SAS tokens with the `azurerm` provider.
        """
        return pulumi.get(self, "sas_url")


@pulumi.output_type
class SlotLogsHttpLogsFileSystem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retentionInDays":
            suggest = "retention_in_days"
        elif key == "retentionInMb":
            suggest = "retention_in_mb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SlotLogsHttpLogsFileSystem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SlotLogsHttpLogsFileSystem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SlotLogsHttpLogsFileSystem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 retention_in_days: int,
                 retention_in_mb: int):
        """
        :param int retention_in_days: The number of days to retain logs for.
        :param int retention_in_mb: The maximum size in megabytes that HTTP log files can use before being removed.
        """
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "retention_in_mb", retention_in_mb)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> int:
        """
        The number of days to retain logs for.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="retentionInMb")
    def retention_in_mb(self) -> int:
        """
        The maximum size in megabytes that HTTP log files can use before being removed.
        """
        return pulumi.get(self, "retention_in_mb")


@pulumi.output_type
class SlotSiteConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acrUseManagedIdentityCredentials":
            suggest = "acr_use_managed_identity_credentials"
        elif key == "acrUserManagedIdentityClientId":
            suggest = "acr_user_managed_identity_client_id"
        elif key == "alwaysOn":
            suggest = "always_on"
        elif key == "appCommandLine":
            suggest = "app_command_line"
        elif key == "autoSwapSlotName":
            suggest = "auto_swap_slot_name"
        elif key == "defaultDocuments":
            suggest = "default_documents"
        elif key == "dotnetFrameworkVersion":
            suggest = "dotnet_framework_version"
        elif key == "ftpsState":
            suggest = "ftps_state"
        elif key == "healthCheckPath":
            suggest = "health_check_path"
        elif key == "http2Enabled":
            suggest = "http2_enabled"
        elif key == "ipRestrictions":
            suggest = "ip_restrictions"
        elif key == "javaContainer":
            suggest = "java_container"
        elif key == "javaContainerVersion":
            suggest = "java_container_version"
        elif key == "javaVersion":
            suggest = "java_version"
        elif key == "linuxFxVersion":
            suggest = "linux_fx_version"
        elif key == "localMysqlEnabled":
            suggest = "local_mysql_enabled"
        elif key == "managedPipelineMode":
            suggest = "managed_pipeline_mode"
        elif key == "minTlsVersion":
            suggest = "min_tls_version"
        elif key == "numberOfWorkers":
            suggest = "number_of_workers"
        elif key == "phpVersion":
            suggest = "php_version"
        elif key == "pythonVersion":
            suggest = "python_version"
        elif key == "remoteDebuggingEnabled":
            suggest = "remote_debugging_enabled"
        elif key == "remoteDebuggingVersion":
            suggest = "remote_debugging_version"
        elif key == "scmIpRestrictions":
            suggest = "scm_ip_restrictions"
        elif key == "scmType":
            suggest = "scm_type"
        elif key == "scmUseMainIpRestriction":
            suggest = "scm_use_main_ip_restriction"
        elif key == "use32BitWorkerProcess":
            suggest = "use32_bit_worker_process"
        elif key == "vnetRouteAllEnabled":
            suggest = "vnet_route_all_enabled"
        elif key == "websocketsEnabled":
            suggest = "websockets_enabled"
        elif key == "windowsFxVersion":
            suggest = "windows_fx_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SlotSiteConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SlotSiteConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SlotSiteConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acr_use_managed_identity_credentials: Optional[bool] = None,
                 acr_user_managed_identity_client_id: Optional[str] = None,
                 always_on: Optional[bool] = None,
                 app_command_line: Optional[str] = None,
                 auto_swap_slot_name: Optional[str] = None,
                 cors: Optional['outputs.SlotSiteConfigCors'] = None,
                 default_documents: Optional[Sequence[str]] = None,
                 dotnet_framework_version: Optional[str] = None,
                 ftps_state: Optional[str] = None,
                 health_check_path: Optional[str] = None,
                 http2_enabled: Optional[bool] = None,
                 ip_restrictions: Optional[Sequence['outputs.SlotSiteConfigIpRestriction']] = None,
                 java_container: Optional[str] = None,
                 java_container_version: Optional[str] = None,
                 java_version: Optional[str] = None,
                 linux_fx_version: Optional[str] = None,
                 local_mysql_enabled: Optional[bool] = None,
                 managed_pipeline_mode: Optional[str] = None,
                 min_tls_version: Optional[str] = None,
                 number_of_workers: Optional[int] = None,
                 php_version: Optional[str] = None,
                 python_version: Optional[str] = None,
                 remote_debugging_enabled: Optional[bool] = None,
                 remote_debugging_version: Optional[str] = None,
                 scm_ip_restrictions: Optional[Sequence['outputs.SlotSiteConfigScmIpRestriction']] = None,
                 scm_type: Optional[str] = None,
                 scm_use_main_ip_restriction: Optional[bool] = None,
                 use32_bit_worker_process: Optional[bool] = None,
                 vnet_route_all_enabled: Optional[bool] = None,
                 websockets_enabled: Optional[bool] = None,
                 windows_fx_version: Optional[str] = None):
        """
        :param bool acr_use_managed_identity_credentials: Are Managed Identity Credentials used for Azure Container Registry pull
        :param str acr_user_managed_identity_client_id: If using User Managed Identity, the User Managed Identity Client Id
               
               > **NOTE:** When using User Managed Identity with Azure Container Registry the Identity will need to have the [ACRPull role assigned](https://docs.microsoft.com/azure/container-registry/container-registry-authentication-managed-identity#example-1-access-with-a-user-assigned-identity)
        :param bool always_on: Should the slot be loaded at all times? Defaults to `false`.
               
               > **NOTE:** when using an App Service Plan in the `Free` or `Shared` Tiers `always_on` must be set to `false`.
        :param str app_command_line: App command line to launch, e.g. `/sbin/myserver -b 0.0.0.0`.
        :param str auto_swap_slot_name: The name of the slot to automatically swap to during deployment
        :param 'SlotSiteConfigCorsArgs' cors: A `cors` block as defined below.
        :param Sequence[str] default_documents: The ordering of default documents to load, if an address isn't specified.
        :param str dotnet_framework_version: The version of the .NET framework's CLR used in this App Service Slot. Possible values are `v2.0` (which will use the latest version of the .NET framework for the .NET CLR v2 - currently `.net 3.5`), `v4.0` (which corresponds to the latest version of the .NET CLR v4 - which at the time of writing is `.net 4.7.1`), `v5.0` and `v6.0`. [For more information on which .NET CLR version to use based on the .NET framework you're targeting - please see this table](https://en.wikipedia.org/wiki/.NET_Framework_version_history#Overview). Defaults to `v4.0`.
        :param str ftps_state: State of FTP / FTPS service for this App Service Slot. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`.
        :param str health_check_path: The health check path to be pinged by App Service Slot. [For more information - please see App Service health check announcement](https://azure.github.io/AppService/2020/08/24/healthcheck-on-app-service.html).
        :param bool http2_enabled: Is HTTP2 Enabled on this App Service? Defaults to `false`.
        :param Sequence['SlotSiteConfigIpRestrictionArgs'] ip_restrictions: A list of objects representing ip restrictions as defined below.
               
               > **NOTE** User has to explicitly set `ip_restriction` to empty slice (`[]`) to remove it.
        :param str java_container: The Java Container to use. If specified `java_version` and `java_container_version` must also be specified. Possible values are `JAVA`, `JETTY`, and `TOMCAT`.
        :param str java_container_version: The version of the Java Container to use. If specified `java_version` and `java_container` must also be specified.
        :param str java_version: The version of Java to use. If specified `java_container` and `java_container_version` must also be specified. Possible values are `1.7`, `1.8`, and `11` and their specific versions - except for Java 11 (e.g. `1.7.0_80`, `1.8.0_181`, `11`)
        :param str linux_fx_version: Linux App Framework and version for the App Service Slot. Possible options are a Docker container (`DOCKER|<user/image:tag>`), a base-64 encoded Docker Compose file (`COMPOSE|${filebase64("compose.yml")}`) or a base-64 encoded Kubernetes Manifest (`KUBE|${filebase64("kubernetes.yml")}`).
               
               > **NOTE:** To set this property the App Service Plan to which the App belongs must be configured with `kind = "Linux"`, and `reserved = true` or the API will reject any value supplied.
        :param bool local_mysql_enabled: Is "MySQL In App" Enabled? This runs a local MySQL instance with your app and shares resources from the App Service plan.
               
               > **NOTE:** MySQL In App is not intended for production environments and will not scale beyond a single instance. Instead you may wish to use Azure Database for MySQL.
        :param str managed_pipeline_mode: The Managed Pipeline Mode. Possible values are `Integrated` and `Classic`. Defaults to `Integrated`.
        :param str min_tls_version: The minimum supported TLS version for the app service. Possible values are `1.0`, `1.1`, and `1.2`. Defaults to `1.2` for new app services.
        :param int number_of_workers: The scaled number of workers (for per site scaling) of this App Service Slot. Requires that `per_site_scaling` is enabled on the `appservice.Plan`. [For more information - please see Microsoft documentation on high-density hosting](https://docs.microsoft.com/azure/app-service/manage-scale-per-app).
        :param str php_version: The version of PHP to use in this App Service Slot. Possible values are `5.5`, `5.6`, `7.0`, `7.1`, `7.2`, `7.3`, and `7.4`.
        :param str python_version: The version of Python to use in this App Service Slot. Possible values are `2.7` and `3.4`.
        :param bool remote_debugging_enabled: Is Remote Debugging Enabled? Defaults to `false`.
        :param str remote_debugging_version: Which version of Visual Studio should the Remote Debugger be compatible with? Possible values are `VS2017` and `VS2019`.
        :param Sequence['SlotSiteConfigScmIpRestrictionArgs'] scm_ip_restrictions: A [List of objects](https://www.terraform.io/docs/configuration/attr-as-blocks.html) representing IP restrictions as defined below.
               
               > **NOTE** User has to explicitly set `scm_ip_restriction` to empty slice (`[]`) to remove it.
        :param str scm_type: The type of Source Control enabled for this App Service Slot. Defaults to `None`. Possible values are: `BitbucketGit`, `BitbucketHg`, `CodePlexGit`, `CodePlexHg`, `Dropbox`, `ExternalGit`, `ExternalHg`, `GitHub`, `LocalGit`, `None`, `OneDrive`, `Tfs`, `VSO`, and `VSTSRM`
        :param bool scm_use_main_ip_restriction: IP security restrictions for scm to use main. Defaults to `false`. 
               
               > **NOTE** Any `scm_ip_restriction` blocks configured are ignored by the service when `scm_use_main_ip_restriction` is set to `true`. Any scm restrictions will become active if this is subsequently set to `false` or removed.
        :param bool use32_bit_worker_process: Should the App Service Slot run in 32 bit mode, rather than 64 bit mode?
               
               > **NOTE:** when using an App Service Plan in the `Free` or `Shared` Tiers `use_32_bit_worker_process` must be set to `true`.
        :param bool websockets_enabled: Should WebSockets be enabled?
        """
        if acr_use_managed_identity_credentials is not None:
            pulumi.set(__self__, "acr_use_managed_identity_credentials", acr_use_managed_identity_credentials)
        if acr_user_managed_identity_client_id is not None:
            pulumi.set(__self__, "acr_user_managed_identity_client_id", acr_user_managed_identity_client_id)
        if always_on is not None:
            pulumi.set(__self__, "always_on", always_on)
        if app_command_line is not None:
            pulumi.set(__self__, "app_command_line", app_command_line)
        if auto_swap_slot_name is not None:
            pulumi.set(__self__, "auto_swap_slot_name", auto_swap_slot_name)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if default_documents is not None:
            pulumi.set(__self__, "default_documents", default_documents)
        if dotnet_framework_version is not None:
            pulumi.set(__self__, "dotnet_framework_version", dotnet_framework_version)
        if ftps_state is not None:
            pulumi.set(__self__, "ftps_state", ftps_state)
        if health_check_path is not None:
            pulumi.set(__self__, "health_check_path", health_check_path)
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if ip_restrictions is not None:
            pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        if java_container is not None:
            pulumi.set(__self__, "java_container", java_container)
        if java_container_version is not None:
            pulumi.set(__self__, "java_container_version", java_container_version)
        if java_version is not None:
            pulumi.set(__self__, "java_version", java_version)
        if linux_fx_version is not None:
            pulumi.set(__self__, "linux_fx_version", linux_fx_version)
        if local_mysql_enabled is not None:
            pulumi.set(__self__, "local_mysql_enabled", local_mysql_enabled)
        if managed_pipeline_mode is not None:
            pulumi.set(__self__, "managed_pipeline_mode", managed_pipeline_mode)
        if min_tls_version is not None:
            pulumi.set(__self__, "min_tls_version", min_tls_version)
        if number_of_workers is not None:
            pulumi.set(__self__, "number_of_workers", number_of_workers)
        if php_version is not None:
            pulumi.set(__self__, "php_version", php_version)
        if python_version is not None:
            pulumi.set(__self__, "python_version", python_version)
        if remote_debugging_enabled is not None:
            pulumi.set(__self__, "remote_debugging_enabled", remote_debugging_enabled)
        if remote_debugging_version is not None:
            pulumi.set(__self__, "remote_debugging_version", remote_debugging_version)
        if scm_ip_restrictions is not None:
            pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        if scm_type is not None:
            pulumi.set(__self__, "scm_type", scm_type)
        if scm_use_main_ip_restriction is not None:
            pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        if use32_bit_worker_process is not None:
            pulumi.set(__self__, "use32_bit_worker_process", use32_bit_worker_process)
        if vnet_route_all_enabled is not None:
            pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        if websockets_enabled is not None:
            pulumi.set(__self__, "websockets_enabled", websockets_enabled)
        if windows_fx_version is not None:
            pulumi.set(__self__, "windows_fx_version", windows_fx_version)

    @property
    @pulumi.getter(name="acrUseManagedIdentityCredentials")
    def acr_use_managed_identity_credentials(self) -> Optional[bool]:
        """
        Are Managed Identity Credentials used for Azure Container Registry pull
        """
        return pulumi.get(self, "acr_use_managed_identity_credentials")

    @property
    @pulumi.getter(name="acrUserManagedIdentityClientId")
    def acr_user_managed_identity_client_id(self) -> Optional[str]:
        """
        If using User Managed Identity, the User Managed Identity Client Id

        > **NOTE:** When using User Managed Identity with Azure Container Registry the Identity will need to have the [ACRPull role assigned](https://docs.microsoft.com/azure/container-registry/container-registry-authentication-managed-identity#example-1-access-with-a-user-assigned-identity)
        """
        return pulumi.get(self, "acr_user_managed_identity_client_id")

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> Optional[bool]:
        """
        Should the slot be loaded at all times? Defaults to `false`.

        > **NOTE:** when using an App Service Plan in the `Free` or `Shared` Tiers `always_on` must be set to `false`.
        """
        return pulumi.get(self, "always_on")

    @property
    @pulumi.getter(name="appCommandLine")
    def app_command_line(self) -> Optional[str]:
        """
        App command line to launch, e.g. `/sbin/myserver -b 0.0.0.0`.
        """
        return pulumi.get(self, "app_command_line")

    @property
    @pulumi.getter(name="autoSwapSlotName")
    def auto_swap_slot_name(self) -> Optional[str]:
        """
        The name of the slot to automatically swap to during deployment
        """
        return pulumi.get(self, "auto_swap_slot_name")

    @property
    @pulumi.getter
    def cors(self) -> Optional['outputs.SlotSiteConfigCors']:
        """
        A `cors` block as defined below.
        """
        return pulumi.get(self, "cors")

    @property
    @pulumi.getter(name="defaultDocuments")
    def default_documents(self) -> Optional[Sequence[str]]:
        """
        The ordering of default documents to load, if an address isn't specified.
        """
        return pulumi.get(self, "default_documents")

    @property
    @pulumi.getter(name="dotnetFrameworkVersion")
    def dotnet_framework_version(self) -> Optional[str]:
        """
        The version of the .NET framework's CLR used in this App Service Slot. Possible values are `v2.0` (which will use the latest version of the .NET framework for the .NET CLR v2 - currently `.net 3.5`), `v4.0` (which corresponds to the latest version of the .NET CLR v4 - which at the time of writing is `.net 4.7.1`), `v5.0` and `v6.0`. [For more information on which .NET CLR version to use based on the .NET framework you're targeting - please see this table](https://en.wikipedia.org/wiki/.NET_Framework_version_history#Overview). Defaults to `v4.0`.
        """
        return pulumi.get(self, "dotnet_framework_version")

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> Optional[str]:
        """
        State of FTP / FTPS service for this App Service Slot. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`.
        """
        return pulumi.get(self, "ftps_state")

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> Optional[str]:
        """
        The health check path to be pinged by App Service Slot. [For more information - please see App Service health check announcement](https://azure.github.io/AppService/2020/08/24/healthcheck-on-app-service.html).
        """
        return pulumi.get(self, "health_check_path")

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[bool]:
        """
        Is HTTP2 Enabled on this App Service? Defaults to `false`.
        """
        return pulumi.get(self, "http2_enabled")

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Optional[Sequence['outputs.SlotSiteConfigIpRestriction']]:
        """
        A list of objects representing ip restrictions as defined below.

        > **NOTE** User has to explicitly set `ip_restriction` to empty slice (`[]`) to remove it.
        """
        return pulumi.get(self, "ip_restrictions")

    @property
    @pulumi.getter(name="javaContainer")
    def java_container(self) -> Optional[str]:
        """
        The Java Container to use. If specified `java_version` and `java_container_version` must also be specified. Possible values are `JAVA`, `JETTY`, and `TOMCAT`.
        """
        return pulumi.get(self, "java_container")

    @property
    @pulumi.getter(name="javaContainerVersion")
    def java_container_version(self) -> Optional[str]:
        """
        The version of the Java Container to use. If specified `java_version` and `java_container` must also be specified.
        """
        return pulumi.get(self, "java_container_version")

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> Optional[str]:
        """
        The version of Java to use. If specified `java_container` and `java_container_version` must also be specified. Possible values are `1.7`, `1.8`, and `11` and their specific versions - except for Java 11 (e.g. `1.7.0_80`, `1.8.0_181`, `11`)
        """
        return pulumi.get(self, "java_version")

    @property
    @pulumi.getter(name="linuxFxVersion")
    def linux_fx_version(self) -> Optional[str]:
        """
        Linux App Framework and version for the App Service Slot. Possible options are a Docker container (`DOCKER|<user/image:tag>`), a base-64 encoded Docker Compose file (`COMPOSE|${filebase64("compose.yml")}`) or a base-64 encoded Kubernetes Manifest (`KUBE|${filebase64("kubernetes.yml")}`).

        > **NOTE:** To set this property the App Service Plan to which the App belongs must be configured with `kind = "Linux"`, and `reserved = true` or the API will reject any value supplied.
        """
        return pulumi.get(self, "linux_fx_version")

    @property
    @pulumi.getter(name="localMysqlEnabled")
    def local_mysql_enabled(self) -> Optional[bool]:
        """
        Is "MySQL In App" Enabled? This runs a local MySQL instance with your app and shares resources from the App Service plan.

        > **NOTE:** MySQL In App is not intended for production environments and will not scale beyond a single instance. Instead you may wish to use Azure Database for MySQL.
        """
        return pulumi.get(self, "local_mysql_enabled")

    @property
    @pulumi.getter(name="managedPipelineMode")
    def managed_pipeline_mode(self) -> Optional[str]:
        """
        The Managed Pipeline Mode. Possible values are `Integrated` and `Classic`. Defaults to `Integrated`.
        """
        return pulumi.get(self, "managed_pipeline_mode")

    @property
    @pulumi.getter(name="minTlsVersion")
    def min_tls_version(self) -> Optional[str]:
        """
        The minimum supported TLS version for the app service. Possible values are `1.0`, `1.1`, and `1.2`. Defaults to `1.2` for new app services.
        """
        return pulumi.get(self, "min_tls_version")

    @property
    @pulumi.getter(name="numberOfWorkers")
    def number_of_workers(self) -> Optional[int]:
        """
        The scaled number of workers (for per site scaling) of this App Service Slot. Requires that `per_site_scaling` is enabled on the `appservice.Plan`. [For more information - please see Microsoft documentation on high-density hosting](https://docs.microsoft.com/azure/app-service/manage-scale-per-app).
        """
        return pulumi.get(self, "number_of_workers")

    @property
    @pulumi.getter(name="phpVersion")
    def php_version(self) -> Optional[str]:
        """
        The version of PHP to use in this App Service Slot. Possible values are `5.5`, `5.6`, `7.0`, `7.1`, `7.2`, `7.3`, and `7.4`.
        """
        return pulumi.get(self, "php_version")

    @property
    @pulumi.getter(name="pythonVersion")
    def python_version(self) -> Optional[str]:
        """
        The version of Python to use in this App Service Slot. Possible values are `2.7` and `3.4`.
        """
        return pulumi.get(self, "python_version")

    @property
    @pulumi.getter(name="remoteDebuggingEnabled")
    def remote_debugging_enabled(self) -> Optional[bool]:
        """
        Is Remote Debugging Enabled? Defaults to `false`.
        """
        return pulumi.get(self, "remote_debugging_enabled")

    @property
    @pulumi.getter(name="remoteDebuggingVersion")
    def remote_debugging_version(self) -> Optional[str]:
        """
        Which version of Visual Studio should the Remote Debugger be compatible with? Possible values are `VS2017` and `VS2019`.
        """
        return pulumi.get(self, "remote_debugging_version")

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Optional[Sequence['outputs.SlotSiteConfigScmIpRestriction']]:
        """
        A [List of objects](https://www.terraform.io/docs/configuration/attr-as-blocks.html) representing IP restrictions as defined below.

        > **NOTE** User has to explicitly set `scm_ip_restriction` to empty slice (`[]`) to remove it.
        """
        return pulumi.get(self, "scm_ip_restrictions")

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> Optional[str]:
        """
        The type of Source Control enabled for this App Service Slot. Defaults to `None`. Possible values are: `BitbucketGit`, `BitbucketHg`, `CodePlexGit`, `CodePlexHg`, `Dropbox`, `ExternalGit`, `ExternalHg`, `GitHub`, `LocalGit`, `None`, `OneDrive`, `Tfs`, `VSO`, and `VSTSRM`
        """
        return pulumi.get(self, "scm_type")

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> Optional[bool]:
        """
        IP security restrictions for scm to use main. Defaults to `false`. 

        > **NOTE** Any `scm_ip_restriction` blocks configured are ignored by the service when `scm_use_main_ip_restriction` is set to `true`. Any scm restrictions will become active if this is subsequently set to `false` or removed.
        """
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @property
    @pulumi.getter(name="use32BitWorkerProcess")
    def use32_bit_worker_process(self) -> Optional[bool]:
        """
        Should the App Service Slot run in 32 bit mode, rather than 64 bit mode?

        > **NOTE:** when using an App Service Plan in the `Free` or `Shared` Tiers `use_32_bit_worker_process` must be set to `true`.
        """
        return pulumi.get(self, "use32_bit_worker_process")

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "vnet_route_all_enabled")

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> Optional[bool]:
        """
        Should WebSockets be enabled?
        """
        return pulumi.get(self, "websockets_enabled")

    @property
    @pulumi.getter(name="windowsFxVersion")
    def windows_fx_version(self) -> Optional[str]:
        return pulumi.get(self, "windows_fx_version")


@pulumi.output_type
class SlotSiteConfigCors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedOrigins":
            suggest = "allowed_origins"
        elif key == "supportCredentials":
            suggest = "support_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SlotSiteConfigCors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SlotSiteConfigCors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SlotSiteConfigCors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_origins: Sequence[str],
                 support_credentials: Optional[bool] = None):
        """
        :param Sequence[str] allowed_origins: A list of origins which should be able to make cross-origin calls. `*` can be used to allow all calls.
        :param bool support_credentials: Are credentials supported?
        """
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        if support_credentials is not None:
            pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Sequence[str]:
        """
        A list of origins which should be able to make cross-origin calls. `*` can be used to allow all calls.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> Optional[bool]:
        """
        Are credentials supported?
        """
        return pulumi.get(self, "support_credentials")


@pulumi.output_type
class SlotSiteConfigIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SlotSiteConfigIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SlotSiteConfigIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SlotSiteConfigIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.SlotSiteConfigIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: Does this restriction `Allow` or `Deny` access for this IP range. Defaults to `Allow`.
        :param 'SlotSiteConfigIpRestrictionHeadersArgs' headers: The headers for this specific `ip_restriction` as defined below. The HTTP header filters are evaluated after the rule itself and both conditions must be true for the rule to apply.
        :param str ip_address: The IP Address used for this IP Restriction in CIDR notation.
        :param str name: The name for this IP Restriction.
        :param int priority: The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
               
               > **NOTE:** One of either `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        Does this restriction `Allow` or `Deny` access for this IP range. Defaults to `Allow`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.SlotSiteConfigIpRestrictionHeaders']:
        """
        The headers for this specific `ip_restriction` as defined below. The HTTP header filters are evaluated after the rule itself and both conditions must be true for the rule to apply.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The IP Address used for this IP Restriction in CIDR notation.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name for this IP Restriction.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One of either `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class SlotSiteConfigIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SlotSiteConfigIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SlotSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SlotSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        :param str x_fd_health_probe: A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        :param Sequence[str] x_forwarded_fors: A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        :param Sequence[str] x_forwarded_hosts: A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class SlotSiteConfigScmIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SlotSiteConfigScmIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SlotSiteConfigScmIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SlotSiteConfigScmIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.SlotSiteConfigScmIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: Allow or Deny access for this IP range. Defaults to `Allow`.
        :param 'SlotSiteConfigScmIpRestrictionHeadersArgs' headers: The headers for this specific `scm_ip_restriction` as defined below.
        :param str ip_address: The IP Address used for this IP Restriction in CIDR notation.
        :param str name: The name for this IP Restriction.
        :param int priority: The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
               
               > **NOTE:** One of either `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        Allow or Deny access for this IP range. Defaults to `Allow`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.SlotSiteConfigScmIpRestrictionHeaders']:
        """
        The headers for this specific `scm_ip_restriction` as defined below.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The IP Address used for this IP Restriction in CIDR notation.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name for this IP Restriction.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One of either `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class SlotSiteConfigScmIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SlotSiteConfigScmIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SlotSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SlotSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        :param str x_fd_health_probe: A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        :param Sequence[str] x_forwarded_fors: A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        :param Sequence[str] x_forwarded_hosts: A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class SlotSiteCredential(dict):
    def __init__(__self__, *,
                 password: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str password: The password associated with the username, which can be used to publish to this App Service.
        :param str username: The username which can be used to publish to this App Service
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password associated with the username, which can be used to publish to this App Service.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username which can be used to publish to this App Service
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class SlotStorageAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "accountName":
            suggest = "account_name"
        elif key == "shareName":
            suggest = "share_name"
        elif key == "mountPath":
            suggest = "mount_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SlotStorageAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SlotStorageAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SlotStorageAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: str,
                 account_name: str,
                 name: str,
                 share_name: str,
                 type: str,
                 mount_path: Optional[str] = None):
        """
        :param str access_key: The access key for the storage account.
        :param str account_name: The name of the storage account.
        :param str name: The name of the storage account identifier.
        :param str share_name: The name of the file share (container name, for Blob storage).
        :param str type: The type of storage. Possible values are `AzureBlob` and `AzureFiles`.
        :param str mount_path: The path to mount the storage within the site's runtime environment.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "share_name", share_name)
        pulumi.set(__self__, "type", type)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> str:
        """
        The access key for the storage account.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> str:
        """
        The name of the storage account.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the storage account identifier.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> str:
        """
        The name of the file share (container name, for Blob storage).
        """
        return pulumi.get(self, "share_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of storage. Possible values are `AzureBlob` and `AzureFiles`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[str]:
        """
        The path to mount the storage within the site's runtime environment.
        """
        return pulumi.get(self, "mount_path")


@pulumi.output_type
class SourceControlGithubActionConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "codeConfiguration":
            suggest = "code_configuration"
        elif key == "containerConfiguration":
            suggest = "container_configuration"
        elif key == "generateWorkflowFile":
            suggest = "generate_workflow_file"
        elif key == "linuxAction":
            suggest = "linux_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceControlGithubActionConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceControlGithubActionConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceControlGithubActionConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 code_configuration: Optional['outputs.SourceControlGithubActionConfigurationCodeConfiguration'] = None,
                 container_configuration: Optional['outputs.SourceControlGithubActionConfigurationContainerConfiguration'] = None,
                 generate_workflow_file: Optional[bool] = None,
                 linux_action: Optional[bool] = None):
        """
        :param 'SourceControlGithubActionConfigurationCodeConfigurationArgs' code_configuration: A `code_configuration` block as defined above. Changing this forces a new resource to be created.
        :param 'SourceControlGithubActionConfigurationContainerConfigurationArgs' container_configuration: A `container_configuration` block as defined above.
        :param bool generate_workflow_file: Whether to generate the GitHub work flow file. Defaults to `true`. Changing this forces a new resource to be created.
        """
        if code_configuration is not None:
            pulumi.set(__self__, "code_configuration", code_configuration)
        if container_configuration is not None:
            pulumi.set(__self__, "container_configuration", container_configuration)
        if generate_workflow_file is not None:
            pulumi.set(__self__, "generate_workflow_file", generate_workflow_file)
        if linux_action is not None:
            pulumi.set(__self__, "linux_action", linux_action)

    @property
    @pulumi.getter(name="codeConfiguration")
    def code_configuration(self) -> Optional['outputs.SourceControlGithubActionConfigurationCodeConfiguration']:
        """
        A `code_configuration` block as defined above. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "code_configuration")

    @property
    @pulumi.getter(name="containerConfiguration")
    def container_configuration(self) -> Optional['outputs.SourceControlGithubActionConfigurationContainerConfiguration']:
        """
        A `container_configuration` block as defined above.
        """
        return pulumi.get(self, "container_configuration")

    @property
    @pulumi.getter(name="generateWorkflowFile")
    def generate_workflow_file(self) -> Optional[bool]:
        """
        Whether to generate the GitHub work flow file. Defaults to `true`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "generate_workflow_file")

    @property
    @pulumi.getter(name="linuxAction")
    def linux_action(self) -> Optional[bool]:
        return pulumi.get(self, "linux_action")


@pulumi.output_type
class SourceControlGithubActionConfigurationCodeConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "runtimeStack":
            suggest = "runtime_stack"
        elif key == "runtimeVersion":
            suggest = "runtime_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceControlGithubActionConfigurationCodeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceControlGithubActionConfigurationCodeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceControlGithubActionConfigurationCodeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 runtime_stack: str,
                 runtime_version: str):
        """
        :param str runtime_stack: The value to use for the Runtime Stack in the workflow file content for code base apps. Possible values are `dotnetcore`, `spring`, `tomcat`, `node` and `python`. Changing this forces a new resource to be created.
        :param str runtime_version: The value to use for the Runtime Version in the workflow file content for code base apps. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "runtime_stack", runtime_stack)
        pulumi.set(__self__, "runtime_version", runtime_version)

    @property
    @pulumi.getter(name="runtimeStack")
    def runtime_stack(self) -> str:
        """
        The value to use for the Runtime Stack in the workflow file content for code base apps. Possible values are `dotnetcore`, `spring`, `tomcat`, `node` and `python`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "runtime_stack")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> str:
        """
        The value to use for the Runtime Version in the workflow file content for code base apps. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "runtime_version")


@pulumi.output_type
class SourceControlGithubActionConfigurationContainerConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageName":
            suggest = "image_name"
        elif key == "registryUrl":
            suggest = "registry_url"
        elif key == "registryPassword":
            suggest = "registry_password"
        elif key == "registryUsername":
            suggest = "registry_username"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceControlGithubActionConfigurationContainerConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceControlGithubActionConfigurationContainerConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceControlGithubActionConfigurationContainerConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_name: str,
                 registry_url: str,
                 registry_password: Optional[str] = None,
                 registry_username: Optional[str] = None):
        """
        :param str image_name: The image name for the build. Changing this forces a new resource to be created.
        :param str registry_url: The server URL for the container registry where the build will be hosted. Changing this forces a new resource to be created.
        :param str registry_password: The password used to upload the image to the container registry. Changing this forces a new resource to be created.
        :param str registry_username: The username used to upload the image to the container registry. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "image_name", image_name)
        pulumi.set(__self__, "registry_url", registry_url)
        if registry_password is not None:
            pulumi.set(__self__, "registry_password", registry_password)
        if registry_username is not None:
            pulumi.set(__self__, "registry_username", registry_username)

    @property
    @pulumi.getter(name="imageName")
    def image_name(self) -> str:
        """
        The image name for the build. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "image_name")

    @property
    @pulumi.getter(name="registryUrl")
    def registry_url(self) -> str:
        """
        The server URL for the container registry where the build will be hosted. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "registry_url")

    @property
    @pulumi.getter(name="registryPassword")
    def registry_password(self) -> Optional[str]:
        """
        The password used to upload the image to the container registry. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "registry_password")

    @property
    @pulumi.getter(name="registryUsername")
    def registry_username(self) -> Optional[str]:
        """
        The username used to upload the image to the container registry. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "registry_username")


@pulumi.output_type
class SourceControlSlotGithubActionConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "codeConfiguration":
            suggest = "code_configuration"
        elif key == "containerConfiguration":
            suggest = "container_configuration"
        elif key == "generateWorkflowFile":
            suggest = "generate_workflow_file"
        elif key == "linuxAction":
            suggest = "linux_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceControlSlotGithubActionConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceControlSlotGithubActionConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceControlSlotGithubActionConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 code_configuration: Optional['outputs.SourceControlSlotGithubActionConfigurationCodeConfiguration'] = None,
                 container_configuration: Optional['outputs.SourceControlSlotGithubActionConfigurationContainerConfiguration'] = None,
                 generate_workflow_file: Optional[bool] = None,
                 linux_action: Optional[bool] = None):
        """
        :param 'SourceControlSlotGithubActionConfigurationCodeConfigurationArgs' code_configuration: A `code_configuration` block as detailed below. Changing this forces a new resource to be created.
        :param 'SourceControlSlotGithubActionConfigurationContainerConfigurationArgs' container_configuration: A `container_configuration` block as detailed below.
        :param bool generate_workflow_file: Should the service generate the GitHub Action Workflow file. Defaults to `true` Changing this forces a new resource to be created.
        :param bool linux_action: Denotes this action uses a Linux base image.
        """
        if code_configuration is not None:
            pulumi.set(__self__, "code_configuration", code_configuration)
        if container_configuration is not None:
            pulumi.set(__self__, "container_configuration", container_configuration)
        if generate_workflow_file is not None:
            pulumi.set(__self__, "generate_workflow_file", generate_workflow_file)
        if linux_action is not None:
            pulumi.set(__self__, "linux_action", linux_action)

    @property
    @pulumi.getter(name="codeConfiguration")
    def code_configuration(self) -> Optional['outputs.SourceControlSlotGithubActionConfigurationCodeConfiguration']:
        """
        A `code_configuration` block as detailed below. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "code_configuration")

    @property
    @pulumi.getter(name="containerConfiguration")
    def container_configuration(self) -> Optional['outputs.SourceControlSlotGithubActionConfigurationContainerConfiguration']:
        """
        A `container_configuration` block as detailed below.
        """
        return pulumi.get(self, "container_configuration")

    @property
    @pulumi.getter(name="generateWorkflowFile")
    def generate_workflow_file(self) -> Optional[bool]:
        """
        Should the service generate the GitHub Action Workflow file. Defaults to `true` Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "generate_workflow_file")

    @property
    @pulumi.getter(name="linuxAction")
    def linux_action(self) -> Optional[bool]:
        """
        Denotes this action uses a Linux base image.
        """
        return pulumi.get(self, "linux_action")


@pulumi.output_type
class SourceControlSlotGithubActionConfigurationCodeConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "runtimeStack":
            suggest = "runtime_stack"
        elif key == "runtimeVersion":
            suggest = "runtime_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceControlSlotGithubActionConfigurationCodeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceControlSlotGithubActionConfigurationCodeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceControlSlotGithubActionConfigurationCodeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 runtime_stack: str,
                 runtime_version: str):
        """
        :param str runtime_stack: The value to use for the Runtime Stack in the workflow file content for code base apps. Changing this forces a new resource to be created. Possible values are `dotnetcore`, `spring`, `tomcat`, `node` and `python`.
        :param str runtime_version: The value to use for the Runtime Version in the workflow file content for code base apps. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "runtime_stack", runtime_stack)
        pulumi.set(__self__, "runtime_version", runtime_version)

    @property
    @pulumi.getter(name="runtimeStack")
    def runtime_stack(self) -> str:
        """
        The value to use for the Runtime Stack in the workflow file content for code base apps. Changing this forces a new resource to be created. Possible values are `dotnetcore`, `spring`, `tomcat`, `node` and `python`.
        """
        return pulumi.get(self, "runtime_stack")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> str:
        """
        The value to use for the Runtime Version in the workflow file content for code base apps. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "runtime_version")


@pulumi.output_type
class SourceControlSlotGithubActionConfigurationContainerConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageName":
            suggest = "image_name"
        elif key == "registryUrl":
            suggest = "registry_url"
        elif key == "registryPassword":
            suggest = "registry_password"
        elif key == "registryUsername":
            suggest = "registry_username"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceControlSlotGithubActionConfigurationContainerConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceControlSlotGithubActionConfigurationContainerConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceControlSlotGithubActionConfigurationContainerConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_name: str,
                 registry_url: str,
                 registry_password: Optional[str] = None,
                 registry_username: Optional[str] = None):
        """
        :param str image_name: The image name for the build. Changing this forces a new resource to be created.
        :param str registry_url: The server URL for the container registry where the build will be hosted. Changing this forces a new resource to be created.
        :param str registry_password: The password used to upload the image to the container registry. Changing this forces a new resource to be created.
        :param str registry_username: The username used to upload the image to the container registry. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "image_name", image_name)
        pulumi.set(__self__, "registry_url", registry_url)
        if registry_password is not None:
            pulumi.set(__self__, "registry_password", registry_password)
        if registry_username is not None:
            pulumi.set(__self__, "registry_username", registry_username)

    @property
    @pulumi.getter(name="imageName")
    def image_name(self) -> str:
        """
        The image name for the build. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "image_name")

    @property
    @pulumi.getter(name="registryUrl")
    def registry_url(self) -> str:
        """
        The server URL for the container registry where the build will be hosted. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "registry_url")

    @property
    @pulumi.getter(name="registryPassword")
    def registry_password(self) -> Optional[str]:
        """
        The password used to upload the image to the container registry. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "registry_password")

    @property
    @pulumi.getter(name="registryUsername")
    def registry_username(self) -> Optional[str]:
        """
        The username used to upload the image to the container registry. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "registry_username")


@pulumi.output_type
class StaticSiteIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StaticSiteIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StaticSiteIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StaticSiteIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 identity_ids: Optional[Sequence[str]] = None,
                 principal_id: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str type: The Type of Managed Identity assigned to this Static Site resource. Possible values are `SystemAssigned`, `UserAssigned` and `SystemAssigned, UserAssigned`.
        :param Sequence[str] identity_ids: A list of Managed Identity IDs which should be assigned to this Static Site resource.
        :param str principal_id: (Optional) The Principal ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The Type of Managed Identity assigned to this Static Site resource. Possible values are `SystemAssigned`, `UserAssigned` and `SystemAssigned, UserAssigned`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[str]]:
        """
        A list of Managed Identity IDs which should be assigned to this Static Site resource.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        """
        (Optional) The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class WindowsFunctionAppAuthSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeDirectory":
            suggest = "active_directory"
        elif key == "additionalLoginParameters":
            suggest = "additional_login_parameters"
        elif key == "allowedExternalRedirectUrls":
            suggest = "allowed_external_redirect_urls"
        elif key == "defaultProvider":
            suggest = "default_provider"
        elif key == "runtimeVersion":
            suggest = "runtime_version"
        elif key == "tokenRefreshExtensionHours":
            suggest = "token_refresh_extension_hours"
        elif key == "tokenStoreEnabled":
            suggest = "token_store_enabled"
        elif key == "unauthenticatedClientAction":
            suggest = "unauthenticated_client_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppAuthSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppAuthSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppAuthSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 active_directory: Optional['outputs.WindowsFunctionAppAuthSettingsActiveDirectory'] = None,
                 additional_login_parameters: Optional[Mapping[str, str]] = None,
                 allowed_external_redirect_urls: Optional[Sequence[str]] = None,
                 default_provider: Optional[str] = None,
                 facebook: Optional['outputs.WindowsFunctionAppAuthSettingsFacebook'] = None,
                 github: Optional['outputs.WindowsFunctionAppAuthSettingsGithub'] = None,
                 google: Optional['outputs.WindowsFunctionAppAuthSettingsGoogle'] = None,
                 issuer: Optional[str] = None,
                 microsoft: Optional['outputs.WindowsFunctionAppAuthSettingsMicrosoft'] = None,
                 runtime_version: Optional[str] = None,
                 token_refresh_extension_hours: Optional[float] = None,
                 token_store_enabled: Optional[bool] = None,
                 twitter: Optional['outputs.WindowsFunctionAppAuthSettingsTwitter'] = None,
                 unauthenticated_client_action: Optional[str] = None):
        """
        :param bool enabled: Should the Authentication / Authorization feature be enabled for the Windows Function App?
        :param 'WindowsFunctionAppAuthSettingsActiveDirectoryArgs' active_directory: An `active_directory` block as defined above.
        :param Mapping[str, str] additional_login_parameters: Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        :param Sequence[str] allowed_external_redirect_urls: Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Windows Function App.
        :param str default_provider: The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.
               
               > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        :param 'WindowsFunctionAppAuthSettingsFacebookArgs' facebook: A `facebook` block as defined below.
        :param 'WindowsFunctionAppAuthSettingsGithubArgs' github: A `github` block as defined below.
        :param 'WindowsFunctionAppAuthSettingsGoogleArgs' google: A `google` block as defined below.
        :param str issuer: The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Windows Function App.
               
               > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        :param 'WindowsFunctionAppAuthSettingsMicrosoftArgs' microsoft: A `microsoft` block as defined below.
        :param str runtime_version: The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        :param float token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        :param bool token_store_enabled: Should the Windows Function App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        :param 'WindowsFunctionAppAuthSettingsTwitterArgs' twitter: A `twitter` block as defined below.
        :param str unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if active_directory is not None:
            pulumi.set(__self__, "active_directory", active_directory)
        if additional_login_parameters is not None:
            pulumi.set(__self__, "additional_login_parameters", additional_login_parameters)
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if facebook is not None:
            pulumi.set(__self__, "facebook", facebook)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if google is not None:
            pulumi.set(__self__, "google", google)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if microsoft is not None:
            pulumi.set(__self__, "microsoft", microsoft)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if token_refresh_extension_hours is not None:
            pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if twitter is not None:
            pulumi.set(__self__, "twitter", twitter)
        if unauthenticated_client_action is not None:
            pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Should the Authentication / Authorization feature be enabled for the Windows Function App?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="activeDirectory")
    def active_directory(self) -> Optional['outputs.WindowsFunctionAppAuthSettingsActiveDirectory']:
        """
        An `active_directory` block as defined above.
        """
        return pulumi.get(self, "active_directory")

    @property
    @pulumi.getter(name="additionalLoginParameters")
    def additional_login_parameters(self) -> Optional[Mapping[str, str]]:
        """
        Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        """
        return pulumi.get(self, "additional_login_parameters")

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Windows Function App.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[str]:
        """
        The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.

        > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        """
        return pulumi.get(self, "default_provider")

    @property
    @pulumi.getter
    def facebook(self) -> Optional['outputs.WindowsFunctionAppAuthSettingsFacebook']:
        """
        A `facebook` block as defined below.
        """
        return pulumi.get(self, "facebook")

    @property
    @pulumi.getter
    def github(self) -> Optional['outputs.WindowsFunctionAppAuthSettingsGithub']:
        """
        A `github` block as defined below.
        """
        return pulumi.get(self, "github")

    @property
    @pulumi.getter
    def google(self) -> Optional['outputs.WindowsFunctionAppAuthSettingsGoogle']:
        """
        A `google` block as defined below.
        """
        return pulumi.get(self, "google")

    @property
    @pulumi.getter
    def issuer(self) -> Optional[str]:
        """
        The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Windows Function App.

        > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def microsoft(self) -> Optional['outputs.WindowsFunctionAppAuthSettingsMicrosoft']:
        """
        A `microsoft` block as defined below.
        """
        return pulumi.get(self, "microsoft")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[str]:
        """
        The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> Optional[float]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        return pulumi.get(self, "token_refresh_extension_hours")

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[bool]:
        """
        Should the Windows Function App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        """
        return pulumi.get(self, "token_store_enabled")

    @property
    @pulumi.getter
    def twitter(self) -> Optional['outputs.WindowsFunctionAppAuthSettingsTwitter']:
        """
        A `twitter` block as defined below.
        """
        return pulumi.get(self, "twitter")

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> Optional[str]:
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        return pulumi.get(self, "unauthenticated_client_action")


@pulumi.output_type
class WindowsFunctionAppAuthSettingsActiveDirectory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppAuthSettingsActiveDirectory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppAuthSettingsActiveDirectory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppAuthSettingsActiveDirectory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param Sequence[str] allowed_audiences: Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
               
               > **Note:** The `client_id` value is always considered an allowed audience.
        :param str client_secret: The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        pulumi.set(__self__, "client_id", client_id)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **Note:** The `client_id` value is always considered an allowed audience.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")


@pulumi.output_type
class WindowsFunctionAppAuthSettingsFacebook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "appSecret":
            suggest = "app_secret"
        elif key == "appSecretSettingName":
            suggest = "app_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppAuthSettingsFacebook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppAuthSettingsFacebook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppAuthSettingsFacebook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: str,
                 app_secret: Optional[str] = None,
                 app_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str app_id: The App ID of the Facebook app used for login.
        :param str app_secret: The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        :param str app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        if app_secret is not None:
            pulumi.set(__self__, "app_secret", app_secret)
        if app_secret_setting_name is not None:
            pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appSecret")
    def app_secret(self) -> Optional[str]:
        """
        The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        """
        return pulumi.get(self, "app_secret")

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class WindowsFunctionAppAuthSettingsGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppAuthSettingsGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppAuthSettingsGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppAuthSettingsGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the GitHub app used for login.
        :param str client_secret: The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the GitHub app used for login.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class WindowsFunctionAppAuthSettingsGoogle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppAuthSettingsGoogle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppAuthSettingsGoogle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppAuthSettingsGoogle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OpenID Connect Client ID for the Google web application.
        :param str client_secret: The client secret associated with the Google web application. Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OpenID Connect Client ID for the Google web application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The client secret associated with the Google web application. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class WindowsFunctionAppAuthSettingsMicrosoft(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppAuthSettingsMicrosoft. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppAuthSettingsMicrosoft.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppAuthSettingsMicrosoft.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret: The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, `wl.basic` is used as the default scope.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, `wl.basic` is used as the default scope.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class WindowsFunctionAppAuthSettingsTwitter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerKey":
            suggest = "consumer_key"
        elif key == "consumerSecret":
            suggest = "consumer_secret"
        elif key == "consumerSecretSettingName":
            suggest = "consumer_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppAuthSettingsTwitter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppAuthSettingsTwitter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppAuthSettingsTwitter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_key: str,
                 consumer_secret: Optional[str] = None,
                 consumer_secret_setting_name: Optional[str] = None):
        """
        :param str consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param str consumer_secret: The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        :param str consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        if consumer_secret is not None:
            pulumi.set(__self__, "consumer_secret", consumer_secret)
        if consumer_secret_setting_name is not None:
            pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> str:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> Optional[str]:
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        """
        return pulumi.get(self, "consumer_secret")

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        return pulumi.get(self, "consumer_secret_setting_name")


@pulumi.output_type
class WindowsFunctionAppAuthSettingsV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeDirectoryV2":
            suggest = "active_directory_v2"
        elif key == "appleV2":
            suggest = "apple_v2"
        elif key == "authEnabled":
            suggest = "auth_enabled"
        elif key == "azureStaticWebAppV2":
            suggest = "azure_static_web_app_v2"
        elif key == "configFilePath":
            suggest = "config_file_path"
        elif key == "customOidcV2s":
            suggest = "custom_oidc_v2s"
        elif key == "defaultProvider":
            suggest = "default_provider"
        elif key == "excludedPaths":
            suggest = "excluded_paths"
        elif key == "facebookV2":
            suggest = "facebook_v2"
        elif key == "forwardProxyConvention":
            suggest = "forward_proxy_convention"
        elif key == "forwardProxyCustomHostHeaderName":
            suggest = "forward_proxy_custom_host_header_name"
        elif key == "forwardProxyCustomSchemeHeaderName":
            suggest = "forward_proxy_custom_scheme_header_name"
        elif key == "githubV2":
            suggest = "github_v2"
        elif key == "googleV2":
            suggest = "google_v2"
        elif key == "httpRouteApiPrefix":
            suggest = "http_route_api_prefix"
        elif key == "microsoftV2":
            suggest = "microsoft_v2"
        elif key == "requireAuthentication":
            suggest = "require_authentication"
        elif key == "requireHttps":
            suggest = "require_https"
        elif key == "runtimeVersion":
            suggest = "runtime_version"
        elif key == "twitterV2":
            suggest = "twitter_v2"
        elif key == "unauthenticatedAction":
            suggest = "unauthenticated_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppAuthSettingsV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppAuthSettingsV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppAuthSettingsV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 login: 'outputs.WindowsFunctionAppAuthSettingsV2Login',
                 active_directory_v2: Optional['outputs.WindowsFunctionAppAuthSettingsV2ActiveDirectoryV2'] = None,
                 apple_v2: Optional['outputs.WindowsFunctionAppAuthSettingsV2AppleV2'] = None,
                 auth_enabled: Optional[bool] = None,
                 azure_static_web_app_v2: Optional['outputs.WindowsFunctionAppAuthSettingsV2AzureStaticWebAppV2'] = None,
                 config_file_path: Optional[str] = None,
                 custom_oidc_v2s: Optional[Sequence['outputs.WindowsFunctionAppAuthSettingsV2CustomOidcV2']] = None,
                 default_provider: Optional[str] = None,
                 excluded_paths: Optional[Sequence[str]] = None,
                 facebook_v2: Optional['outputs.WindowsFunctionAppAuthSettingsV2FacebookV2'] = None,
                 forward_proxy_convention: Optional[str] = None,
                 forward_proxy_custom_host_header_name: Optional[str] = None,
                 forward_proxy_custom_scheme_header_name: Optional[str] = None,
                 github_v2: Optional['outputs.WindowsFunctionAppAuthSettingsV2GithubV2'] = None,
                 google_v2: Optional['outputs.WindowsFunctionAppAuthSettingsV2GoogleV2'] = None,
                 http_route_api_prefix: Optional[str] = None,
                 microsoft_v2: Optional['outputs.WindowsFunctionAppAuthSettingsV2MicrosoftV2'] = None,
                 require_authentication: Optional[bool] = None,
                 require_https: Optional[bool] = None,
                 runtime_version: Optional[str] = None,
                 twitter_v2: Optional['outputs.WindowsFunctionAppAuthSettingsV2TwitterV2'] = None,
                 unauthenticated_action: Optional[str] = None):
        """
        :param 'WindowsFunctionAppAuthSettingsV2LoginArgs' login: A `login` block as defined below.
        :param 'WindowsFunctionAppAuthSettingsV2ActiveDirectoryV2Args' active_directory_v2: An `active_directory_v2` block as defined below.
        :param 'WindowsFunctionAppAuthSettingsV2AppleV2Args' apple_v2: An `apple_v2` block as defined below.
        :param bool auth_enabled: Should the AuthV2 Settings be enabled. Defaults to `false`.
        :param 'WindowsFunctionAppAuthSettingsV2AzureStaticWebAppV2Args' azure_static_web_app_v2: An `azure_static_web_app_v2` block as defined below.
        :param str config_file_path: The path to the App Auth settings.
               
               * > **Note:** Relative Paths are evaluated from the Site Root directory.
        :param Sequence['WindowsFunctionAppAuthSettingsV2CustomOidcV2Args'] custom_oidc_v2s: Zero or more `custom_oidc_v2` blocks as defined below.
        :param str default_provider: The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.
               
               > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        :param Sequence[str] excluded_paths: The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.
               
               > **NOTE:** This list should be used instead of setting `WEBSITE_WARMUP_PATH` in `app_settings` as it takes priority.
        :param 'WindowsFunctionAppAuthSettingsV2FacebookV2Args' facebook_v2: A `facebook_v2` block as defined below.
        :param str forward_proxy_convention: The convention used to determine the url of the request made. Possible values include `NoProxy`, `Standard`, `Custom`. Defaults to `NoProxy`.
        :param str forward_proxy_custom_host_header_name: The name of the custom header containing the host of the request.
        :param str forward_proxy_custom_scheme_header_name: The name of the custom header containing the scheme of the request.
        :param 'WindowsFunctionAppAuthSettingsV2GithubV2Args' github_v2: A `github_v2` block as defined below.
        :param 'WindowsFunctionAppAuthSettingsV2GoogleV2Args' google_v2: A `google_v2` block as defined below.
        :param str http_route_api_prefix: The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
        :param 'WindowsFunctionAppAuthSettingsV2MicrosoftV2Args' microsoft_v2: A `microsoft_v2` block as defined below.
        :param bool require_authentication: Should the authentication flow be used for all requests.
        :param bool require_https: Should HTTPS be required on connections? Defaults to `true`.
        :param str runtime_version: The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        :param 'WindowsFunctionAppAuthSettingsV2TwitterV2Args' twitter_v2: A `twitter_v2` block as defined below.
        :param str unauthenticated_action: The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
        """
        pulumi.set(__self__, "login", login)
        if active_directory_v2 is not None:
            pulumi.set(__self__, "active_directory_v2", active_directory_v2)
        if apple_v2 is not None:
            pulumi.set(__self__, "apple_v2", apple_v2)
        if auth_enabled is not None:
            pulumi.set(__self__, "auth_enabled", auth_enabled)
        if azure_static_web_app_v2 is not None:
            pulumi.set(__self__, "azure_static_web_app_v2", azure_static_web_app_v2)
        if config_file_path is not None:
            pulumi.set(__self__, "config_file_path", config_file_path)
        if custom_oidc_v2s is not None:
            pulumi.set(__self__, "custom_oidc_v2s", custom_oidc_v2s)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if excluded_paths is not None:
            pulumi.set(__self__, "excluded_paths", excluded_paths)
        if facebook_v2 is not None:
            pulumi.set(__self__, "facebook_v2", facebook_v2)
        if forward_proxy_convention is not None:
            pulumi.set(__self__, "forward_proxy_convention", forward_proxy_convention)
        if forward_proxy_custom_host_header_name is not None:
            pulumi.set(__self__, "forward_proxy_custom_host_header_name", forward_proxy_custom_host_header_name)
        if forward_proxy_custom_scheme_header_name is not None:
            pulumi.set(__self__, "forward_proxy_custom_scheme_header_name", forward_proxy_custom_scheme_header_name)
        if github_v2 is not None:
            pulumi.set(__self__, "github_v2", github_v2)
        if google_v2 is not None:
            pulumi.set(__self__, "google_v2", google_v2)
        if http_route_api_prefix is not None:
            pulumi.set(__self__, "http_route_api_prefix", http_route_api_prefix)
        if microsoft_v2 is not None:
            pulumi.set(__self__, "microsoft_v2", microsoft_v2)
        if require_authentication is not None:
            pulumi.set(__self__, "require_authentication", require_authentication)
        if require_https is not None:
            pulumi.set(__self__, "require_https", require_https)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if twitter_v2 is not None:
            pulumi.set(__self__, "twitter_v2", twitter_v2)
        if unauthenticated_action is not None:
            pulumi.set(__self__, "unauthenticated_action", unauthenticated_action)

    @property
    @pulumi.getter
    def login(self) -> 'outputs.WindowsFunctionAppAuthSettingsV2Login':
        """
        A `login` block as defined below.
        """
        return pulumi.get(self, "login")

    @property
    @pulumi.getter(name="activeDirectoryV2")
    def active_directory_v2(self) -> Optional['outputs.WindowsFunctionAppAuthSettingsV2ActiveDirectoryV2']:
        """
        An `active_directory_v2` block as defined below.
        """
        return pulumi.get(self, "active_directory_v2")

    @property
    @pulumi.getter(name="appleV2")
    def apple_v2(self) -> Optional['outputs.WindowsFunctionAppAuthSettingsV2AppleV2']:
        """
        An `apple_v2` block as defined below.
        """
        return pulumi.get(self, "apple_v2")

    @property
    @pulumi.getter(name="authEnabled")
    def auth_enabled(self) -> Optional[bool]:
        """
        Should the AuthV2 Settings be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "auth_enabled")

    @property
    @pulumi.getter(name="azureStaticWebAppV2")
    def azure_static_web_app_v2(self) -> Optional['outputs.WindowsFunctionAppAuthSettingsV2AzureStaticWebAppV2']:
        """
        An `azure_static_web_app_v2` block as defined below.
        """
        return pulumi.get(self, "azure_static_web_app_v2")

    @property
    @pulumi.getter(name="configFilePath")
    def config_file_path(self) -> Optional[str]:
        """
        The path to the App Auth settings.

        * > **Note:** Relative Paths are evaluated from the Site Root directory.
        """
        return pulumi.get(self, "config_file_path")

    @property
    @pulumi.getter(name="customOidcV2s")
    def custom_oidc_v2s(self) -> Optional[Sequence['outputs.WindowsFunctionAppAuthSettingsV2CustomOidcV2']]:
        """
        Zero or more `custom_oidc_v2` blocks as defined below.
        """
        return pulumi.get(self, "custom_oidc_v2s")

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[str]:
        """
        The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.

        > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        """
        return pulumi.get(self, "default_provider")

    @property
    @pulumi.getter(name="excludedPaths")
    def excluded_paths(self) -> Optional[Sequence[str]]:
        """
        The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.

        > **NOTE:** This list should be used instead of setting `WEBSITE_WARMUP_PATH` in `app_settings` as it takes priority.
        """
        return pulumi.get(self, "excluded_paths")

    @property
    @pulumi.getter(name="facebookV2")
    def facebook_v2(self) -> Optional['outputs.WindowsFunctionAppAuthSettingsV2FacebookV2']:
        """
        A `facebook_v2` block as defined below.
        """
        return pulumi.get(self, "facebook_v2")

    @property
    @pulumi.getter(name="forwardProxyConvention")
    def forward_proxy_convention(self) -> Optional[str]:
        """
        The convention used to determine the url of the request made. Possible values include `NoProxy`, `Standard`, `Custom`. Defaults to `NoProxy`.
        """
        return pulumi.get(self, "forward_proxy_convention")

    @property
    @pulumi.getter(name="forwardProxyCustomHostHeaderName")
    def forward_proxy_custom_host_header_name(self) -> Optional[str]:
        """
        The name of the custom header containing the host of the request.
        """
        return pulumi.get(self, "forward_proxy_custom_host_header_name")

    @property
    @pulumi.getter(name="forwardProxyCustomSchemeHeaderName")
    def forward_proxy_custom_scheme_header_name(self) -> Optional[str]:
        """
        The name of the custom header containing the scheme of the request.
        """
        return pulumi.get(self, "forward_proxy_custom_scheme_header_name")

    @property
    @pulumi.getter(name="githubV2")
    def github_v2(self) -> Optional['outputs.WindowsFunctionAppAuthSettingsV2GithubV2']:
        """
        A `github_v2` block as defined below.
        """
        return pulumi.get(self, "github_v2")

    @property
    @pulumi.getter(name="googleV2")
    def google_v2(self) -> Optional['outputs.WindowsFunctionAppAuthSettingsV2GoogleV2']:
        """
        A `google_v2` block as defined below.
        """
        return pulumi.get(self, "google_v2")

    @property
    @pulumi.getter(name="httpRouteApiPrefix")
    def http_route_api_prefix(self) -> Optional[str]:
        """
        The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
        """
        return pulumi.get(self, "http_route_api_prefix")

    @property
    @pulumi.getter(name="microsoftV2")
    def microsoft_v2(self) -> Optional['outputs.WindowsFunctionAppAuthSettingsV2MicrosoftV2']:
        """
        A `microsoft_v2` block as defined below.
        """
        return pulumi.get(self, "microsoft_v2")

    @property
    @pulumi.getter(name="requireAuthentication")
    def require_authentication(self) -> Optional[bool]:
        """
        Should the authentication flow be used for all requests.
        """
        return pulumi.get(self, "require_authentication")

    @property
    @pulumi.getter(name="requireHttps")
    def require_https(self) -> Optional[bool]:
        """
        Should HTTPS be required on connections? Defaults to `true`.
        """
        return pulumi.get(self, "require_https")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[str]:
        """
        The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter(name="twitterV2")
    def twitter_v2(self) -> Optional['outputs.WindowsFunctionAppAuthSettingsV2TwitterV2']:
        """
        A `twitter_v2` block as defined below.
        """
        return pulumi.get(self, "twitter_v2")

    @property
    @pulumi.getter(name="unauthenticatedAction")
    def unauthenticated_action(self) -> Optional[str]:
        """
        The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
        """
        return pulumi.get(self, "unauthenticated_action")


@pulumi.output_type
class WindowsFunctionAppAuthSettingsV2ActiveDirectoryV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "tenantAuthEndpoint":
            suggest = "tenant_auth_endpoint"
        elif key == "allowedApplications":
            suggest = "allowed_applications"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "allowedGroups":
            suggest = "allowed_groups"
        elif key == "allowedIdentities":
            suggest = "allowed_identities"
        elif key == "clientSecretCertificateThumbprint":
            suggest = "client_secret_certificate_thumbprint"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "jwtAllowedClientApplications":
            suggest = "jwt_allowed_client_applications"
        elif key == "jwtAllowedGroups":
            suggest = "jwt_allowed_groups"
        elif key == "loginParameters":
            suggest = "login_parameters"
        elif key == "wwwAuthenticationDisabled":
            suggest = "www_authentication_disabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppAuthSettingsV2ActiveDirectoryV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppAuthSettingsV2ActiveDirectoryV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppAuthSettingsV2ActiveDirectoryV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 tenant_auth_endpoint: str,
                 allowed_applications: Optional[Sequence[str]] = None,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 allowed_groups: Optional[Sequence[str]] = None,
                 allowed_identities: Optional[Sequence[str]] = None,
                 client_secret_certificate_thumbprint: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 jwt_allowed_client_applications: Optional[Sequence[str]] = None,
                 jwt_allowed_groups: Optional[Sequence[str]] = None,
                 login_parameters: Optional[Mapping[str, str]] = None,
                 www_authentication_disabled: Optional[bool] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str tenant_auth_endpoint: The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`
        :param Sequence[str] allowed_applications: The list of allowed Applications for the Default Authorisation Policy.
        :param Sequence[str] allowed_audiences: Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
               
               > **Note:** The `client_id` value is always considered an allowed audience.
        :param Sequence[str] allowed_groups: The list of allowed Group Names for the Default Authorisation Policy.
        :param Sequence[str] allowed_identities: The list of allowed Identities for the Default Authorisation Policy.
        :param str client_secret_certificate_thumbprint: The thumbprint of the certificate used for signing purposes.
               
               > **NOTE:** One of `client_secret_setting_name` or `client_secret_certificate_thumbprint` must be specified.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param Sequence[str] jwt_allowed_client_applications: A list of Allowed Client Applications in the JWT Claim.
        :param Sequence[str] jwt_allowed_groups: A list of Allowed Groups in the JWT Claim.
        :param Mapping[str, str] login_parameters: A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
        :param bool www_authentication_disabled: Should the www-authenticate provider should be omitted from the request? Defaults to `false`
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "tenant_auth_endpoint", tenant_auth_endpoint)
        if allowed_applications is not None:
            pulumi.set(__self__, "allowed_applications", allowed_applications)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if allowed_groups is not None:
            pulumi.set(__self__, "allowed_groups", allowed_groups)
        if allowed_identities is not None:
            pulumi.set(__self__, "allowed_identities", allowed_identities)
        if client_secret_certificate_thumbprint is not None:
            pulumi.set(__self__, "client_secret_certificate_thumbprint", client_secret_certificate_thumbprint)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if jwt_allowed_client_applications is not None:
            pulumi.set(__self__, "jwt_allowed_client_applications", jwt_allowed_client_applications)
        if jwt_allowed_groups is not None:
            pulumi.set(__self__, "jwt_allowed_groups", jwt_allowed_groups)
        if login_parameters is not None:
            pulumi.set(__self__, "login_parameters", login_parameters)
        if www_authentication_disabled is not None:
            pulumi.set(__self__, "www_authentication_disabled", www_authentication_disabled)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="tenantAuthEndpoint")
    def tenant_auth_endpoint(self) -> str:
        """
        The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`
        """
        return pulumi.get(self, "tenant_auth_endpoint")

    @property
    @pulumi.getter(name="allowedApplications")
    def allowed_applications(self) -> Optional[Sequence[str]]:
        """
        The list of allowed Applications for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_applications")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **Note:** The `client_id` value is always considered an allowed audience.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="allowedGroups")
    def allowed_groups(self) -> Optional[Sequence[str]]:
        """
        The list of allowed Group Names for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_groups")

    @property
    @pulumi.getter(name="allowedIdentities")
    def allowed_identities(self) -> Optional[Sequence[str]]:
        """
        The list of allowed Identities for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_identities")

    @property
    @pulumi.getter(name="clientSecretCertificateThumbprint")
    def client_secret_certificate_thumbprint(self) -> Optional[str]:
        """
        The thumbprint of the certificate used for signing purposes.

        > **NOTE:** One of `client_secret_setting_name` or `client_secret_certificate_thumbprint` must be specified.
        """
        return pulumi.get(self, "client_secret_certificate_thumbprint")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="jwtAllowedClientApplications")
    def jwt_allowed_client_applications(self) -> Optional[Sequence[str]]:
        """
        A list of Allowed Client Applications in the JWT Claim.
        """
        return pulumi.get(self, "jwt_allowed_client_applications")

    @property
    @pulumi.getter(name="jwtAllowedGroups")
    def jwt_allowed_groups(self) -> Optional[Sequence[str]]:
        """
        A list of Allowed Groups in the JWT Claim.
        """
        return pulumi.get(self, "jwt_allowed_groups")

    @property
    @pulumi.getter(name="loginParameters")
    def login_parameters(self) -> Optional[Mapping[str, str]]:
        """
        A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
        """
        return pulumi.get(self, "login_parameters")

    @property
    @pulumi.getter(name="wwwAuthenticationDisabled")
    def www_authentication_disabled(self) -> Optional[bool]:
        """
        Should the www-authenticate provider should be omitted from the request? Defaults to `false`
        """
        return pulumi.get(self, "www_authentication_disabled")


@pulumi.output_type
class WindowsFunctionAppAuthSettingsV2AppleV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "loginScopes":
            suggest = "login_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppAuthSettingsV2AppleV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppAuthSettingsV2AppleV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppAuthSettingsV2AppleV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret_setting_name: str,
                 login_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param Sequence[str] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[Sequence[str]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class WindowsFunctionAppAuthSettingsV2AzureStaticWebAppV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppAuthSettingsV2AzureStaticWebAppV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppAuthSettingsV2AzureStaticWebAppV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppAuthSettingsV2AzureStaticWebAppV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        """
        pulumi.set(__self__, "client_id", client_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")


@pulumi.output_type
class WindowsFunctionAppAuthSettingsV2CustomOidcV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "openidConfigurationEndpoint":
            suggest = "openid_configuration_endpoint"
        elif key == "authorisationEndpoint":
            suggest = "authorisation_endpoint"
        elif key == "certificationUri":
            suggest = "certification_uri"
        elif key == "clientCredentialMethod":
            suggest = "client_credential_method"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "issuerEndpoint":
            suggest = "issuer_endpoint"
        elif key == "nameClaimType":
            suggest = "name_claim_type"
        elif key == "tokenEndpoint":
            suggest = "token_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppAuthSettingsV2CustomOidcV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppAuthSettingsV2CustomOidcV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppAuthSettingsV2CustomOidcV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 name: str,
                 openid_configuration_endpoint: str,
                 authorisation_endpoint: Optional[str] = None,
                 certification_uri: Optional[str] = None,
                 client_credential_method: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 issuer_endpoint: Optional[str] = None,
                 name_claim_type: Optional[str] = None,
                 scopes: Optional[Sequence[str]] = None,
                 token_endpoint: Optional[str] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str name: The name which should be used for this Windows Function App. Changing this forces a new Windows Function App to be created. Limit the function name to 32 characters to avoid naming collisions. For more information about [Function App naming rule](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/resource-name-rules#microsoftweb) and [Host ID Collisions](https://github.com/Azure/azure-functions-host/wiki/Host-IDs#host-id-collisions)
        :param str openid_configuration_endpoint: The app setting name that contains the `client_secret` value used for the Custom OIDC Login.
        :param str authorisation_endpoint: The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        :param str certification_uri: The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        :param str client_credential_method: The Client Credential Method used.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param str issuer_endpoint: The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        :param str name_claim_type: The name of the claim that contains the users name.
        :param Sequence[str] scopes: The list of the scopes that should be requested while authenticating.
        :param str token_endpoint: The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "openid_configuration_endpoint", openid_configuration_endpoint)
        if authorisation_endpoint is not None:
            pulumi.set(__self__, "authorisation_endpoint", authorisation_endpoint)
        if certification_uri is not None:
            pulumi.set(__self__, "certification_uri", certification_uri)
        if client_credential_method is not None:
            pulumi.set(__self__, "client_credential_method", client_credential_method)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if issuer_endpoint is not None:
            pulumi.set(__self__, "issuer_endpoint", issuer_endpoint)
        if name_claim_type is not None:
            pulumi.set(__self__, "name_claim_type", name_claim_type)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Windows Function App. Changing this forces a new Windows Function App to be created. Limit the function name to 32 characters to avoid naming collisions. For more information about [Function App naming rule](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/resource-name-rules#microsoftweb) and [Host ID Collisions](https://github.com/Azure/azure-functions-host/wiki/Host-IDs#host-id-collisions)
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="openidConfigurationEndpoint")
    def openid_configuration_endpoint(self) -> str:
        """
        The app setting name that contains the `client_secret` value used for the Custom OIDC Login.
        """
        return pulumi.get(self, "openid_configuration_endpoint")

    @property
    @pulumi.getter(name="authorisationEndpoint")
    def authorisation_endpoint(self) -> Optional[str]:
        """
        The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "authorisation_endpoint")

    @property
    @pulumi.getter(name="certificationUri")
    def certification_uri(self) -> Optional[str]:
        """
        The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "certification_uri")

    @property
    @pulumi.getter(name="clientCredentialMethod")
    def client_credential_method(self) -> Optional[str]:
        """
        The Client Credential Method used.
        """
        return pulumi.get(self, "client_credential_method")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="issuerEndpoint")
    def issuer_endpoint(self) -> Optional[str]:
        """
        The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "issuer_endpoint")

    @property
    @pulumi.getter(name="nameClaimType")
    def name_claim_type(self) -> Optional[str]:
        """
        The name of the claim that contains the users name.
        """
        return pulumi.get(self, "name_claim_type")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[str]]:
        """
        The list of the scopes that should be requested while authenticating.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[str]:
        """
        The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "token_endpoint")


@pulumi.output_type
class WindowsFunctionAppAuthSettingsV2FacebookV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "appSecretSettingName":
            suggest = "app_secret_setting_name"
        elif key == "graphApiVersion":
            suggest = "graph_api_version"
        elif key == "loginScopes":
            suggest = "login_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppAuthSettingsV2FacebookV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppAuthSettingsV2FacebookV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppAuthSettingsV2FacebookV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: str,
                 app_secret_setting_name: str,
                 graph_api_version: Optional[str] = None,
                 login_scopes: Optional[Sequence[str]] = None):
        """
        :param str app_id: The App ID of the Facebook app used for login.
        :param str app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook Login.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param str graph_api_version: The version of the Facebook API to be used while logging in.
        :param Sequence[str] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        if graph_api_version is not None:
            pulumi.set(__self__, "graph_api_version", graph_api_version)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> str:
        """
        The app setting name that contains the `app_secret` value used for Facebook Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @property
    @pulumi.getter(name="graphApiVersion")
    def graph_api_version(self) -> Optional[str]:
        """
        The version of the Facebook API to be used while logging in.
        """
        return pulumi.get(self, "graph_api_version")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[Sequence[str]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class WindowsFunctionAppAuthSettingsV2GithubV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "loginScopes":
            suggest = "login_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppAuthSettingsV2GithubV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppAuthSettingsV2GithubV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppAuthSettingsV2GithubV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret_setting_name: str,
                 login_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param Sequence[str] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[Sequence[str]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class WindowsFunctionAppAuthSettingsV2GoogleV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "loginScopes":
            suggest = "login_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppAuthSettingsV2GoogleV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppAuthSettingsV2GoogleV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppAuthSettingsV2GoogleV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret_setting_name: str,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 login_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param Sequence[str] allowed_audiences: Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
               
               > **Note:** The `client_id` value is always considered an allowed audience.
        :param Sequence[str] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **Note:** The `client_id` value is always considered an allowed audience.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[Sequence[str]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class WindowsFunctionAppAuthSettingsV2Login(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedExternalRedirectUrls":
            suggest = "allowed_external_redirect_urls"
        elif key == "cookieExpirationConvention":
            suggest = "cookie_expiration_convention"
        elif key == "cookieExpirationTime":
            suggest = "cookie_expiration_time"
        elif key == "logoutEndpoint":
            suggest = "logout_endpoint"
        elif key == "nonceExpirationTime":
            suggest = "nonce_expiration_time"
        elif key == "preserveUrlFragmentsForLogins":
            suggest = "preserve_url_fragments_for_logins"
        elif key == "tokenRefreshExtensionTime":
            suggest = "token_refresh_extension_time"
        elif key == "tokenStoreEnabled":
            suggest = "token_store_enabled"
        elif key == "tokenStorePath":
            suggest = "token_store_path"
        elif key == "tokenStoreSasSettingName":
            suggest = "token_store_sas_setting_name"
        elif key == "validateNonce":
            suggest = "validate_nonce"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppAuthSettingsV2Login. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppAuthSettingsV2Login.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppAuthSettingsV2Login.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_external_redirect_urls: Optional[Sequence[str]] = None,
                 cookie_expiration_convention: Optional[str] = None,
                 cookie_expiration_time: Optional[str] = None,
                 logout_endpoint: Optional[str] = None,
                 nonce_expiration_time: Optional[str] = None,
                 preserve_url_fragments_for_logins: Optional[bool] = None,
                 token_refresh_extension_time: Optional[float] = None,
                 token_store_enabled: Optional[bool] = None,
                 token_store_path: Optional[str] = None,
                 token_store_sas_setting_name: Optional[str] = None,
                 validate_nonce: Optional[bool] = None):
        """
        :param Sequence[str] allowed_external_redirect_urls: External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends.
               
               > **Note:** URLs within the current domain are always implicitly allowed.
        :param str cookie_expiration_convention: The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
        :param str cookie_expiration_time: The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
        :param str logout_endpoint: The endpoint to which logout requests should be made.
        :param str nonce_expiration_time: The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
        :param bool preserve_url_fragments_for_logins: Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
        :param float token_refresh_extension_time: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        :param bool token_store_enabled: Should the Token Store configuration Enabled. Defaults to `false`
        :param str token_store_path: The directory path in the App Filesystem in which the tokens will be stored.
        :param str token_store_sas_setting_name: The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        :param bool validate_nonce: Should the nonce be validated while completing the login flow. Defaults to `true`.
        """
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if cookie_expiration_convention is not None:
            pulumi.set(__self__, "cookie_expiration_convention", cookie_expiration_convention)
        if cookie_expiration_time is not None:
            pulumi.set(__self__, "cookie_expiration_time", cookie_expiration_time)
        if logout_endpoint is not None:
            pulumi.set(__self__, "logout_endpoint", logout_endpoint)
        if nonce_expiration_time is not None:
            pulumi.set(__self__, "nonce_expiration_time", nonce_expiration_time)
        if preserve_url_fragments_for_logins is not None:
            pulumi.set(__self__, "preserve_url_fragments_for_logins", preserve_url_fragments_for_logins)
        if token_refresh_extension_time is not None:
            pulumi.set(__self__, "token_refresh_extension_time", token_refresh_extension_time)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if token_store_path is not None:
            pulumi.set(__self__, "token_store_path", token_store_path)
        if token_store_sas_setting_name is not None:
            pulumi.set(__self__, "token_store_sas_setting_name", token_store_sas_setting_name)
        if validate_nonce is not None:
            pulumi.set(__self__, "validate_nonce", validate_nonce)

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[Sequence[str]]:
        """
        External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends.

        > **Note:** URLs within the current domain are always implicitly allowed.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @property
    @pulumi.getter(name="cookieExpirationConvention")
    def cookie_expiration_convention(self) -> Optional[str]:
        """
        The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
        """
        return pulumi.get(self, "cookie_expiration_convention")

    @property
    @pulumi.getter(name="cookieExpirationTime")
    def cookie_expiration_time(self) -> Optional[str]:
        """
        The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
        """
        return pulumi.get(self, "cookie_expiration_time")

    @property
    @pulumi.getter(name="logoutEndpoint")
    def logout_endpoint(self) -> Optional[str]:
        """
        The endpoint to which logout requests should be made.
        """
        return pulumi.get(self, "logout_endpoint")

    @property
    @pulumi.getter(name="nonceExpirationTime")
    def nonce_expiration_time(self) -> Optional[str]:
        """
        The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
        """
        return pulumi.get(self, "nonce_expiration_time")

    @property
    @pulumi.getter(name="preserveUrlFragmentsForLogins")
    def preserve_url_fragments_for_logins(self) -> Optional[bool]:
        """
        Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
        """
        return pulumi.get(self, "preserve_url_fragments_for_logins")

    @property
    @pulumi.getter(name="tokenRefreshExtensionTime")
    def token_refresh_extension_time(self) -> Optional[float]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        return pulumi.get(self, "token_refresh_extension_time")

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[bool]:
        """
        Should the Token Store configuration Enabled. Defaults to `false`
        """
        return pulumi.get(self, "token_store_enabled")

    @property
    @pulumi.getter(name="tokenStorePath")
    def token_store_path(self) -> Optional[str]:
        """
        The directory path in the App Filesystem in which the tokens will be stored.
        """
        return pulumi.get(self, "token_store_path")

    @property
    @pulumi.getter(name="tokenStoreSasSettingName")
    def token_store_sas_setting_name(self) -> Optional[str]:
        """
        The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        """
        return pulumi.get(self, "token_store_sas_setting_name")

    @property
    @pulumi.getter(name="validateNonce")
    def validate_nonce(self) -> Optional[bool]:
        """
        Should the nonce be validated while completing the login flow. Defaults to `true`.
        """
        return pulumi.get(self, "validate_nonce")


@pulumi.output_type
class WindowsFunctionAppAuthSettingsV2MicrosoftV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "loginScopes":
            suggest = "login_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppAuthSettingsV2MicrosoftV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppAuthSettingsV2MicrosoftV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppAuthSettingsV2MicrosoftV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret_setting_name: str,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 login_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param Sequence[str] allowed_audiences: Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
               
               > **Note:** The `client_id` value is always considered an allowed audience.
        :param Sequence[str] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **Note:** The `client_id` value is always considered an allowed audience.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[Sequence[str]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class WindowsFunctionAppAuthSettingsV2TwitterV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerKey":
            suggest = "consumer_key"
        elif key == "consumerSecretSettingName":
            suggest = "consumer_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppAuthSettingsV2TwitterV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppAuthSettingsV2TwitterV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppAuthSettingsV2TwitterV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_key: str,
                 consumer_secret_setting_name: str):
        """
        :param str consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param str consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> str:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> str:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "consumer_secret_setting_name")


@pulumi.output_type
class WindowsFunctionAppBackup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageAccountUrl":
            suggest = "storage_account_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppBackup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppBackup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppBackup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 schedule: 'outputs.WindowsFunctionAppBackupSchedule',
                 storage_account_url: str,
                 enabled: Optional[bool] = None):
        """
        :param str name: The name which should be used for this Backup.
        :param 'WindowsFunctionAppBackupScheduleArgs' schedule: A `schedule` block as defined below.
        :param str storage_account_url: The SAS URL to the container.
        :param bool enabled: Should this backup job be enabled? Defaults to `true`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "storage_account_url", storage_account_url)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Backup.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def schedule(self) -> 'outputs.WindowsFunctionAppBackupSchedule':
        """
        A `schedule` block as defined below.
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter(name="storageAccountUrl")
    def storage_account_url(self) -> str:
        """
        The SAS URL to the container.
        """
        return pulumi.get(self, "storage_account_url")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Should this backup job be enabled? Defaults to `true`.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class WindowsFunctionAppBackupSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "frequencyUnit":
            suggest = "frequency_unit"
        elif key == "keepAtLeastOneBackup":
            suggest = "keep_at_least_one_backup"
        elif key == "lastExecutionTime":
            suggest = "last_execution_time"
        elif key == "retentionPeriodDays":
            suggest = "retention_period_days"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppBackupSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppBackupSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppBackupSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_unit: str,
                 keep_at_least_one_backup: Optional[bool] = None,
                 last_execution_time: Optional[str] = None,
                 retention_period_days: Optional[int] = None,
                 start_time: Optional[str] = None):
        """
        :param int frequency_interval: How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).
               
               > **NOTE:** Not all intervals are supported on all Windows Function App SKUs. Please refer to the official documentation for appropriate values.
        :param str frequency_unit: The unit of time for how often the backup should take place. Possible values include: `Day` and `Hour`.
        :param bool keep_at_least_one_backup: Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
        :param int retention_period_days: After how many days backups should be deleted. Defaults to `30`.
        :param str start_time: When the schedule should start working in RFC-3339 format.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_unit", frequency_unit)
        if keep_at_least_one_backup is not None:
            pulumi.set(__self__, "keep_at_least_one_backup", keep_at_least_one_backup)
        if last_execution_time is not None:
            pulumi.set(__self__, "last_execution_time", last_execution_time)
        if retention_period_days is not None:
            pulumi.set(__self__, "retention_period_days", retention_period_days)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).

        > **NOTE:** Not all intervals are supported on all Windows Function App SKUs. Please refer to the official documentation for appropriate values.
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyUnit")
    def frequency_unit(self) -> str:
        """
        The unit of time for how often the backup should take place. Possible values include: `Day` and `Hour`.
        """
        return pulumi.get(self, "frequency_unit")

    @property
    @pulumi.getter(name="keepAtLeastOneBackup")
    def keep_at_least_one_backup(self) -> Optional[bool]:
        """
        Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
        """
        return pulumi.get(self, "keep_at_least_one_backup")

    @property
    @pulumi.getter(name="lastExecutionTime")
    def last_execution_time(self) -> Optional[str]:
        return pulumi.get(self, "last_execution_time")

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> Optional[int]:
        """
        After how many days backups should be deleted. Defaults to `30`.
        """
        return pulumi.get(self, "retention_period_days")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        """
        When the schedule should start working in RFC-3339 format.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class WindowsFunctionAppConnectionString(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: The name which should be used for this Connection.
        :param str type: Type of database. Possible values include: `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
        :param str value: The connection string value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Connection.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of database. Possible values include: `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The connection string value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class WindowsFunctionAppIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 identity_ids: Optional[Sequence[str]] = None,
                 principal_id: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str type: Specifies the type of Managed Service Identity that should be configured on this Windows Function App. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        :param Sequence[str] identity_ids: A list of User Assigned Managed Identity IDs to be assigned to this Windows Function App.
               
               > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        :param str principal_id: The Principal ID associated with this Managed Service Identity.
        :param str tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the type of Managed Service Identity that should be configured on this Windows Function App. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[str]]:
        """
        A list of User Assigned Managed Identity IDs to be assigned to this Windows Function App.

        > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class WindowsFunctionAppSiteConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alwaysOn":
            suggest = "always_on"
        elif key == "apiDefinitionUrl":
            suggest = "api_definition_url"
        elif key == "apiManagementApiId":
            suggest = "api_management_api_id"
        elif key == "appCommandLine":
            suggest = "app_command_line"
        elif key == "appScaleLimit":
            suggest = "app_scale_limit"
        elif key == "appServiceLogs":
            suggest = "app_service_logs"
        elif key == "applicationInsightsConnectionString":
            suggest = "application_insights_connection_string"
        elif key == "applicationInsightsKey":
            suggest = "application_insights_key"
        elif key == "applicationStack":
            suggest = "application_stack"
        elif key == "defaultDocuments":
            suggest = "default_documents"
        elif key == "detailedErrorLoggingEnabled":
            suggest = "detailed_error_logging_enabled"
        elif key == "elasticInstanceMinimum":
            suggest = "elastic_instance_minimum"
        elif key == "ftpsState":
            suggest = "ftps_state"
        elif key == "healthCheckEvictionTimeInMin":
            suggest = "health_check_eviction_time_in_min"
        elif key == "healthCheckPath":
            suggest = "health_check_path"
        elif key == "http2Enabled":
            suggest = "http2_enabled"
        elif key == "ipRestrictions":
            suggest = "ip_restrictions"
        elif key == "loadBalancingMode":
            suggest = "load_balancing_mode"
        elif key == "managedPipelineMode":
            suggest = "managed_pipeline_mode"
        elif key == "minimumTlsVersion":
            suggest = "minimum_tls_version"
        elif key == "preWarmedInstanceCount":
            suggest = "pre_warmed_instance_count"
        elif key == "remoteDebuggingEnabled":
            suggest = "remote_debugging_enabled"
        elif key == "remoteDebuggingVersion":
            suggest = "remote_debugging_version"
        elif key == "runtimeScaleMonitoringEnabled":
            suggest = "runtime_scale_monitoring_enabled"
        elif key == "scmIpRestrictions":
            suggest = "scm_ip_restrictions"
        elif key == "scmMinimumTlsVersion":
            suggest = "scm_minimum_tls_version"
        elif key == "scmType":
            suggest = "scm_type"
        elif key == "scmUseMainIpRestriction":
            suggest = "scm_use_main_ip_restriction"
        elif key == "use32BitWorker":
            suggest = "use32_bit_worker"
        elif key == "vnetRouteAllEnabled":
            suggest = "vnet_route_all_enabled"
        elif key == "websocketsEnabled":
            suggest = "websockets_enabled"
        elif key == "windowsFxVersion":
            suggest = "windows_fx_version"
        elif key == "workerCount":
            suggest = "worker_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSiteConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSiteConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSiteConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 always_on: Optional[bool] = None,
                 api_definition_url: Optional[str] = None,
                 api_management_api_id: Optional[str] = None,
                 app_command_line: Optional[str] = None,
                 app_scale_limit: Optional[int] = None,
                 app_service_logs: Optional['outputs.WindowsFunctionAppSiteConfigAppServiceLogs'] = None,
                 application_insights_connection_string: Optional[str] = None,
                 application_insights_key: Optional[str] = None,
                 application_stack: Optional['outputs.WindowsFunctionAppSiteConfigApplicationStack'] = None,
                 cors: Optional['outputs.WindowsFunctionAppSiteConfigCors'] = None,
                 default_documents: Optional[Sequence[str]] = None,
                 detailed_error_logging_enabled: Optional[bool] = None,
                 elastic_instance_minimum: Optional[int] = None,
                 ftps_state: Optional[str] = None,
                 health_check_eviction_time_in_min: Optional[int] = None,
                 health_check_path: Optional[str] = None,
                 http2_enabled: Optional[bool] = None,
                 ip_restrictions: Optional[Sequence['outputs.WindowsFunctionAppSiteConfigIpRestriction']] = None,
                 load_balancing_mode: Optional[str] = None,
                 managed_pipeline_mode: Optional[str] = None,
                 minimum_tls_version: Optional[str] = None,
                 pre_warmed_instance_count: Optional[int] = None,
                 remote_debugging_enabled: Optional[bool] = None,
                 remote_debugging_version: Optional[str] = None,
                 runtime_scale_monitoring_enabled: Optional[bool] = None,
                 scm_ip_restrictions: Optional[Sequence['outputs.WindowsFunctionAppSiteConfigScmIpRestriction']] = None,
                 scm_minimum_tls_version: Optional[str] = None,
                 scm_type: Optional[str] = None,
                 scm_use_main_ip_restriction: Optional[bool] = None,
                 use32_bit_worker: Optional[bool] = None,
                 vnet_route_all_enabled: Optional[bool] = None,
                 websockets_enabled: Optional[bool] = None,
                 windows_fx_version: Optional[str] = None,
                 worker_count: Optional[int] = None):
        """
        :param bool always_on: If this Windows Function App is Always On enabled. Defaults to `false`.
               
               > **NOTE:** when running in a Consumption or Premium Plan, `always_on` feature should be turned off. Please turn it off before upgrading the service plan from standard to premium.
        :param str api_definition_url: The URL of the API definition that describes this Windows Function App.
        :param str api_management_api_id: The ID of the API Management API for this Windows Function App.
        :param str app_command_line: The App command line to launch.
        :param int app_scale_limit: The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
        :param 'WindowsFunctionAppSiteConfigAppServiceLogsArgs' app_service_logs: An `app_service_logs` block as defined above.
        :param str application_insights_connection_string: The Connection String for linking the Windows Function App to Application Insights.
        :param str application_insights_key: The Instrumentation Key for connecting the Windows Function App to Application Insights.
        :param 'WindowsFunctionAppSiteConfigApplicationStackArgs' application_stack: An `application_stack` block as defined above.
               
               > **Note:** If this is set, there must not be an application setting `FUNCTIONS_WORKER_RUNTIME`.
        :param 'WindowsFunctionAppSiteConfigCorsArgs' cors: A `cors` block as defined above.
        :param Sequence[str] default_documents: Specifies a list of Default Documents for the Windows Function App.
        :param int elastic_instance_minimum: The number of minimum instances for this Windows Function App. Only affects apps on Elastic Premium plans.
        :param str ftps_state: State of FTP / FTPS service for this Windows Function App. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`. Defaults to `Disabled`.
        :param int health_check_eviction_time_in_min: The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        :param str health_check_path: The path to be checked for this Windows Function App health.
        :param bool http2_enabled: Specifies if the HTTP2 protocol should be enabled. Defaults to `false`.
        :param Sequence['WindowsFunctionAppSiteConfigIpRestrictionArgs'] ip_restrictions: One or more `ip_restriction` blocks as defined above.
        :param str load_balancing_mode: The Site load balancing mode. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        :param str managed_pipeline_mode: Managed pipeline mode. Possible values include: `Integrated`, `Classic`. Defaults to `Integrated`.
        :param str minimum_tls_version: Configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        :param int pre_warmed_instance_count: The number of pre-warmed instances for this Windows Function App. Only affects apps on an Elastic Premium plan.
        :param bool remote_debugging_enabled: Should Remote Debugging be enabled. Defaults to `false`.
        :param str remote_debugging_version: The Remote Debugging Version. Possible values include `VS2017`, `VS2019`, and `VS2022`.
        :param bool runtime_scale_monitoring_enabled: Should Scale Monitoring of the Functions Runtime be enabled?
               
               > **NOTE:** Functions runtime scale monitoring can only be enabled for Elastic Premium Function Apps or Workflow Standard Logic Apps and requires a minimum prewarmed instance count of 1.
        :param Sequence['WindowsFunctionAppSiteConfigScmIpRestrictionArgs'] scm_ip_restrictions: One or more `scm_ip_restriction` blocks as defined above.
        :param str scm_minimum_tls_version: Configures the minimum version of TLS required for SSL requests to the SCM site. Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        :param bool scm_use_main_ip_restriction: Should the Windows Function App `ip_restriction` configuration be used for the SCM also.
        :param bool use32_bit_worker: Should the Windows Function App use a 32-bit worker process. Defaults to `true`.
        :param bool vnet_route_all_enabled: Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        :param bool websockets_enabled: Should Web Sockets be enabled. Defaults to `false`.
        :param int worker_count: The number of Workers for this Windows Function App.
        """
        if always_on is not None:
            pulumi.set(__self__, "always_on", always_on)
        if api_definition_url is not None:
            pulumi.set(__self__, "api_definition_url", api_definition_url)
        if api_management_api_id is not None:
            pulumi.set(__self__, "api_management_api_id", api_management_api_id)
        if app_command_line is not None:
            pulumi.set(__self__, "app_command_line", app_command_line)
        if app_scale_limit is not None:
            pulumi.set(__self__, "app_scale_limit", app_scale_limit)
        if app_service_logs is not None:
            pulumi.set(__self__, "app_service_logs", app_service_logs)
        if application_insights_connection_string is not None:
            pulumi.set(__self__, "application_insights_connection_string", application_insights_connection_string)
        if application_insights_key is not None:
            pulumi.set(__self__, "application_insights_key", application_insights_key)
        if application_stack is not None:
            pulumi.set(__self__, "application_stack", application_stack)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if default_documents is not None:
            pulumi.set(__self__, "default_documents", default_documents)
        if detailed_error_logging_enabled is not None:
            pulumi.set(__self__, "detailed_error_logging_enabled", detailed_error_logging_enabled)
        if elastic_instance_minimum is not None:
            pulumi.set(__self__, "elastic_instance_minimum", elastic_instance_minimum)
        if ftps_state is not None:
            pulumi.set(__self__, "ftps_state", ftps_state)
        if health_check_eviction_time_in_min is not None:
            pulumi.set(__self__, "health_check_eviction_time_in_min", health_check_eviction_time_in_min)
        if health_check_path is not None:
            pulumi.set(__self__, "health_check_path", health_check_path)
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if ip_restrictions is not None:
            pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        if load_balancing_mode is not None:
            pulumi.set(__self__, "load_balancing_mode", load_balancing_mode)
        if managed_pipeline_mode is not None:
            pulumi.set(__self__, "managed_pipeline_mode", managed_pipeline_mode)
        if minimum_tls_version is not None:
            pulumi.set(__self__, "minimum_tls_version", minimum_tls_version)
        if pre_warmed_instance_count is not None:
            pulumi.set(__self__, "pre_warmed_instance_count", pre_warmed_instance_count)
        if remote_debugging_enabled is not None:
            pulumi.set(__self__, "remote_debugging_enabled", remote_debugging_enabled)
        if remote_debugging_version is not None:
            pulumi.set(__self__, "remote_debugging_version", remote_debugging_version)
        if runtime_scale_monitoring_enabled is not None:
            pulumi.set(__self__, "runtime_scale_monitoring_enabled", runtime_scale_monitoring_enabled)
        if scm_ip_restrictions is not None:
            pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        if scm_minimum_tls_version is not None:
            pulumi.set(__self__, "scm_minimum_tls_version", scm_minimum_tls_version)
        if scm_type is not None:
            pulumi.set(__self__, "scm_type", scm_type)
        if scm_use_main_ip_restriction is not None:
            pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        if use32_bit_worker is not None:
            pulumi.set(__self__, "use32_bit_worker", use32_bit_worker)
        if vnet_route_all_enabled is not None:
            pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        if websockets_enabled is not None:
            pulumi.set(__self__, "websockets_enabled", websockets_enabled)
        if windows_fx_version is not None:
            pulumi.set(__self__, "windows_fx_version", windows_fx_version)
        if worker_count is not None:
            pulumi.set(__self__, "worker_count", worker_count)

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> Optional[bool]:
        """
        If this Windows Function App is Always On enabled. Defaults to `false`.

        > **NOTE:** when running in a Consumption or Premium Plan, `always_on` feature should be turned off. Please turn it off before upgrading the service plan from standard to premium.
        """
        return pulumi.get(self, "always_on")

    @property
    @pulumi.getter(name="apiDefinitionUrl")
    def api_definition_url(self) -> Optional[str]:
        """
        The URL of the API definition that describes this Windows Function App.
        """
        return pulumi.get(self, "api_definition_url")

    @property
    @pulumi.getter(name="apiManagementApiId")
    def api_management_api_id(self) -> Optional[str]:
        """
        The ID of the API Management API for this Windows Function App.
        """
        return pulumi.get(self, "api_management_api_id")

    @property
    @pulumi.getter(name="appCommandLine")
    def app_command_line(self) -> Optional[str]:
        """
        The App command line to launch.
        """
        return pulumi.get(self, "app_command_line")

    @property
    @pulumi.getter(name="appScaleLimit")
    def app_scale_limit(self) -> Optional[int]:
        """
        The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
        """
        return pulumi.get(self, "app_scale_limit")

    @property
    @pulumi.getter(name="appServiceLogs")
    def app_service_logs(self) -> Optional['outputs.WindowsFunctionAppSiteConfigAppServiceLogs']:
        """
        An `app_service_logs` block as defined above.
        """
        return pulumi.get(self, "app_service_logs")

    @property
    @pulumi.getter(name="applicationInsightsConnectionString")
    def application_insights_connection_string(self) -> Optional[str]:
        """
        The Connection String for linking the Windows Function App to Application Insights.
        """
        return pulumi.get(self, "application_insights_connection_string")

    @property
    @pulumi.getter(name="applicationInsightsKey")
    def application_insights_key(self) -> Optional[str]:
        """
        The Instrumentation Key for connecting the Windows Function App to Application Insights.
        """
        return pulumi.get(self, "application_insights_key")

    @property
    @pulumi.getter(name="applicationStack")
    def application_stack(self) -> Optional['outputs.WindowsFunctionAppSiteConfigApplicationStack']:
        """
        An `application_stack` block as defined above.

        > **Note:** If this is set, there must not be an application setting `FUNCTIONS_WORKER_RUNTIME`.
        """
        return pulumi.get(self, "application_stack")

    @property
    @pulumi.getter
    def cors(self) -> Optional['outputs.WindowsFunctionAppSiteConfigCors']:
        """
        A `cors` block as defined above.
        """
        return pulumi.get(self, "cors")

    @property
    @pulumi.getter(name="defaultDocuments")
    def default_documents(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Default Documents for the Windows Function App.
        """
        return pulumi.get(self, "default_documents")

    @property
    @pulumi.getter(name="detailedErrorLoggingEnabled")
    def detailed_error_logging_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "detailed_error_logging_enabled")

    @property
    @pulumi.getter(name="elasticInstanceMinimum")
    def elastic_instance_minimum(self) -> Optional[int]:
        """
        The number of minimum instances for this Windows Function App. Only affects apps on Elastic Premium plans.
        """
        return pulumi.get(self, "elastic_instance_minimum")

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> Optional[str]:
        """
        State of FTP / FTPS service for this Windows Function App. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`. Defaults to `Disabled`.
        """
        return pulumi.get(self, "ftps_state")

    @property
    @pulumi.getter(name="healthCheckEvictionTimeInMin")
    def health_check_eviction_time_in_min(self) -> Optional[int]:
        """
        The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        """
        return pulumi.get(self, "health_check_eviction_time_in_min")

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> Optional[str]:
        """
        The path to be checked for this Windows Function App health.
        """
        return pulumi.get(self, "health_check_path")

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[bool]:
        """
        Specifies if the HTTP2 protocol should be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "http2_enabled")

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Optional[Sequence['outputs.WindowsFunctionAppSiteConfigIpRestriction']]:
        """
        One or more `ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "ip_restrictions")

    @property
    @pulumi.getter(name="loadBalancingMode")
    def load_balancing_mode(self) -> Optional[str]:
        """
        The Site load balancing mode. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        """
        return pulumi.get(self, "load_balancing_mode")

    @property
    @pulumi.getter(name="managedPipelineMode")
    def managed_pipeline_mode(self) -> Optional[str]:
        """
        Managed pipeline mode. Possible values include: `Integrated`, `Classic`. Defaults to `Integrated`.
        """
        return pulumi.get(self, "managed_pipeline_mode")

    @property
    @pulumi.getter(name="minimumTlsVersion")
    def minimum_tls_version(self) -> Optional[str]:
        """
        Configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        """
        return pulumi.get(self, "minimum_tls_version")

    @property
    @pulumi.getter(name="preWarmedInstanceCount")
    def pre_warmed_instance_count(self) -> Optional[int]:
        """
        The number of pre-warmed instances for this Windows Function App. Only affects apps on an Elastic Premium plan.
        """
        return pulumi.get(self, "pre_warmed_instance_count")

    @property
    @pulumi.getter(name="remoteDebuggingEnabled")
    def remote_debugging_enabled(self) -> Optional[bool]:
        """
        Should Remote Debugging be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "remote_debugging_enabled")

    @property
    @pulumi.getter(name="remoteDebuggingVersion")
    def remote_debugging_version(self) -> Optional[str]:
        """
        The Remote Debugging Version. Possible values include `VS2017`, `VS2019`, and `VS2022`.
        """
        return pulumi.get(self, "remote_debugging_version")

    @property
    @pulumi.getter(name="runtimeScaleMonitoringEnabled")
    def runtime_scale_monitoring_enabled(self) -> Optional[bool]:
        """
        Should Scale Monitoring of the Functions Runtime be enabled?

        > **NOTE:** Functions runtime scale monitoring can only be enabled for Elastic Premium Function Apps or Workflow Standard Logic Apps and requires a minimum prewarmed instance count of 1.
        """
        return pulumi.get(self, "runtime_scale_monitoring_enabled")

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Optional[Sequence['outputs.WindowsFunctionAppSiteConfigScmIpRestriction']]:
        """
        One or more `scm_ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "scm_ip_restrictions")

    @property
    @pulumi.getter(name="scmMinimumTlsVersion")
    def scm_minimum_tls_version(self) -> Optional[str]:
        """
        Configures the minimum version of TLS required for SSL requests to the SCM site. Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        """
        return pulumi.get(self, "scm_minimum_tls_version")

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> Optional[str]:
        return pulumi.get(self, "scm_type")

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> Optional[bool]:
        """
        Should the Windows Function App `ip_restriction` configuration be used for the SCM also.
        """
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @property
    @pulumi.getter(name="use32BitWorker")
    def use32_bit_worker(self) -> Optional[bool]:
        """
        Should the Windows Function App use a 32-bit worker process. Defaults to `true`.
        """
        return pulumi.get(self, "use32_bit_worker")

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> Optional[bool]:
        """
        Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        """
        return pulumi.get(self, "vnet_route_all_enabled")

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> Optional[bool]:
        """
        Should Web Sockets be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "websockets_enabled")

    @property
    @pulumi.getter(name="windowsFxVersion")
    def windows_fx_version(self) -> Optional[str]:
        return pulumi.get(self, "windows_fx_version")

    @property
    @pulumi.getter(name="workerCount")
    def worker_count(self) -> Optional[int]:
        """
        The number of Workers for this Windows Function App.
        """
        return pulumi.get(self, "worker_count")


@pulumi.output_type
class WindowsFunctionAppSiteConfigAppServiceLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskQuotaMb":
            suggest = "disk_quota_mb"
        elif key == "retentionPeriodDays":
            suggest = "retention_period_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSiteConfigAppServiceLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSiteConfigAppServiceLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSiteConfigAppServiceLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_quota_mb: Optional[int] = None,
                 retention_period_days: Optional[int] = None):
        """
        :param int disk_quota_mb: The amount of disk space to use for logs. Valid values are between `25` and `100`. Defaults to `35`.
        :param int retention_period_days: The retention period for logs in days. Valid values are between `0` and `99999`.(never delete).
               
               > **NOTE:** This block is not supported on Consumption plans.
        """
        if disk_quota_mb is not None:
            pulumi.set(__self__, "disk_quota_mb", disk_quota_mb)
        if retention_period_days is not None:
            pulumi.set(__self__, "retention_period_days", retention_period_days)

    @property
    @pulumi.getter(name="diskQuotaMb")
    def disk_quota_mb(self) -> Optional[int]:
        """
        The amount of disk space to use for logs. Valid values are between `25` and `100`. Defaults to `35`.
        """
        return pulumi.get(self, "disk_quota_mb")

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> Optional[int]:
        """
        The retention period for logs in days. Valid values are between `0` and `99999`.(never delete).

        > **NOTE:** This block is not supported on Consumption plans.
        """
        return pulumi.get(self, "retention_period_days")


@pulumi.output_type
class WindowsFunctionAppSiteConfigApplicationStack(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dotnetVersion":
            suggest = "dotnet_version"
        elif key == "javaVersion":
            suggest = "java_version"
        elif key == "nodeVersion":
            suggest = "node_version"
        elif key == "powershellCoreVersion":
            suggest = "powershell_core_version"
        elif key == "useCustomRuntime":
            suggest = "use_custom_runtime"
        elif key == "useDotnetIsolatedRuntime":
            suggest = "use_dotnet_isolated_runtime"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSiteConfigApplicationStack. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSiteConfigApplicationStack.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSiteConfigApplicationStack.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dotnet_version: Optional[str] = None,
                 java_version: Optional[str] = None,
                 node_version: Optional[str] = None,
                 powershell_core_version: Optional[str] = None,
                 use_custom_runtime: Optional[bool] = None,
                 use_dotnet_isolated_runtime: Optional[bool] = None):
        """
        :param str dotnet_version: The version of .NET to use. Possible values include `v3.0`, `v4.0` `v6.0` and `v7.0`.
        :param str java_version: The Version of Java to use. Supported versions include `1.8`, `11` & `17` (In-Preview).
        :param str node_version: The version of Node to run. Possible values include `~12`, `~14`, `~16` and `~18`.
        :param str powershell_core_version: The version of PowerShell Core to run. Possible values are `7`, and `7.2`.
               
               > **NOTE:** A value of `7` will provide the latest stable version. `7.2` is in preview at the time of writing.
        :param bool use_custom_runtime: Should the Windows Function App use a custom runtime?
        :param bool use_dotnet_isolated_runtime: Should the DotNet process use an isolated runtime. Defaults to `false`.
        """
        if dotnet_version is not None:
            pulumi.set(__self__, "dotnet_version", dotnet_version)
        if java_version is not None:
            pulumi.set(__self__, "java_version", java_version)
        if node_version is not None:
            pulumi.set(__self__, "node_version", node_version)
        if powershell_core_version is not None:
            pulumi.set(__self__, "powershell_core_version", powershell_core_version)
        if use_custom_runtime is not None:
            pulumi.set(__self__, "use_custom_runtime", use_custom_runtime)
        if use_dotnet_isolated_runtime is not None:
            pulumi.set(__self__, "use_dotnet_isolated_runtime", use_dotnet_isolated_runtime)

    @property
    @pulumi.getter(name="dotnetVersion")
    def dotnet_version(self) -> Optional[str]:
        """
        The version of .NET to use. Possible values include `v3.0`, `v4.0` `v6.0` and `v7.0`.
        """
        return pulumi.get(self, "dotnet_version")

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> Optional[str]:
        """
        The Version of Java to use. Supported versions include `1.8`, `11` & `17` (In-Preview).
        """
        return pulumi.get(self, "java_version")

    @property
    @pulumi.getter(name="nodeVersion")
    def node_version(self) -> Optional[str]:
        """
        The version of Node to run. Possible values include `~12`, `~14`, `~16` and `~18`.
        """
        return pulumi.get(self, "node_version")

    @property
    @pulumi.getter(name="powershellCoreVersion")
    def powershell_core_version(self) -> Optional[str]:
        """
        The version of PowerShell Core to run. Possible values are `7`, and `7.2`.

        > **NOTE:** A value of `7` will provide the latest stable version. `7.2` is in preview at the time of writing.
        """
        return pulumi.get(self, "powershell_core_version")

    @property
    @pulumi.getter(name="useCustomRuntime")
    def use_custom_runtime(self) -> Optional[bool]:
        """
        Should the Windows Function App use a custom runtime?
        """
        return pulumi.get(self, "use_custom_runtime")

    @property
    @pulumi.getter(name="useDotnetIsolatedRuntime")
    def use_dotnet_isolated_runtime(self) -> Optional[bool]:
        """
        Should the DotNet process use an isolated runtime. Defaults to `false`.
        """
        return pulumi.get(self, "use_dotnet_isolated_runtime")


@pulumi.output_type
class WindowsFunctionAppSiteConfigCors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedOrigins":
            suggest = "allowed_origins"
        elif key == "supportCredentials":
            suggest = "support_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSiteConfigCors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSiteConfigCors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSiteConfigCors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_origins: Optional[Sequence[str]] = None,
                 support_credentials: Optional[bool] = None):
        """
        :param Sequence[str] allowed_origins: Specifies a list of origins that should be allowed to make cross-origin calls.
        :param bool support_credentials: Are credentials allowed in CORS requests? Defaults to `false`.
        """
        if allowed_origins is not None:
            pulumi.set(__self__, "allowed_origins", allowed_origins)
        if support_credentials is not None:
            pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of origins that should be allowed to make cross-origin calls.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> Optional[bool]:
        """
        Are credentials allowed in CORS requests? Defaults to `false`.
        """
        return pulumi.get(self, "support_credentials")


@pulumi.output_type
class WindowsFunctionAppSiteConfigIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSiteConfigIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSiteConfigIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSiteConfigIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.WindowsFunctionAppSiteConfigIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: The action to take. Possible values are `Allow` or `Deny`.
        :param 'WindowsFunctionAppSiteConfigIpRestrictionHeadersArgs' headers: A `headers` block as defined above.
        :param str ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param str name: The name which should be used for this `ip_restriction`.
        :param int priority: The priority value of this `ip_restriction`. Defaults to `65000`.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
               
               > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        The action to take. Possible values are `Allow` or `Deny`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.WindowsFunctionAppSiteConfigIpRestrictionHeaders']:
        """
        A `headers` block as defined above.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class WindowsFunctionAppSiteConfigIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSiteConfigIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param str x_fd_health_probe: Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        :param Sequence[str] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param Sequence[str] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class WindowsFunctionAppSiteConfigScmIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSiteConfigScmIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSiteConfigScmIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSiteConfigScmIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.WindowsFunctionAppSiteConfigScmIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: The action to take. Possible values are `Allow` or `Deny`.
        :param 'WindowsFunctionAppSiteConfigScmIpRestrictionHeadersArgs' headers: A `headers` block as defined above.
        :param str ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param str name: The name which should be used for this `ip_restriction`.
        :param int priority: The priority value of this `ip_restriction`. Defaults to `65000`.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
               
               > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        The action to take. Possible values are `Allow` or `Deny`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.WindowsFunctionAppSiteConfigScmIpRestrictionHeaders']:
        """
        A `headers` block as defined above.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class WindowsFunctionAppSiteConfigScmIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSiteConfigScmIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param str x_fd_health_probe: Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        :param Sequence[str] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param Sequence[str] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class WindowsFunctionAppSiteCredential(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 password: Optional[str] = None):
        """
        :param str name: The name which should be used for this Windows Function App. Changing this forces a new Windows Function App to be created. Limit the function name to 32 characters to avoid naming collisions. For more information about [Function App naming rule](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/resource-name-rules#microsoftweb) and [Host ID Collisions](https://github.com/Azure/azure-functions-host/wiki/Host-IDs#host-id-collisions)
        :param str password: The Site Credentials Password used for publishing.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name which should be used for this Windows Function App. Changing this forces a new Windows Function App to be created. Limit the function name to 32 characters to avoid naming collisions. For more information about [Function App naming rule](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/resource-name-rules#microsoftweb) and [Host ID Collisions](https://github.com/Azure/azure-functions-host/wiki/Host-IDs#host-id-collisions)
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The Site Credentials Password used for publishing.
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class WindowsFunctionAppSlotAuthSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeDirectory":
            suggest = "active_directory"
        elif key == "additionalLoginParameters":
            suggest = "additional_login_parameters"
        elif key == "allowedExternalRedirectUrls":
            suggest = "allowed_external_redirect_urls"
        elif key == "defaultProvider":
            suggest = "default_provider"
        elif key == "runtimeVersion":
            suggest = "runtime_version"
        elif key == "tokenRefreshExtensionHours":
            suggest = "token_refresh_extension_hours"
        elif key == "tokenStoreEnabled":
            suggest = "token_store_enabled"
        elif key == "unauthenticatedClientAction":
            suggest = "unauthenticated_client_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotAuthSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotAuthSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotAuthSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 active_directory: Optional['outputs.WindowsFunctionAppSlotAuthSettingsActiveDirectory'] = None,
                 additional_login_parameters: Optional[Mapping[str, str]] = None,
                 allowed_external_redirect_urls: Optional[Sequence[str]] = None,
                 default_provider: Optional[str] = None,
                 facebook: Optional['outputs.WindowsFunctionAppSlotAuthSettingsFacebook'] = None,
                 github: Optional['outputs.WindowsFunctionAppSlotAuthSettingsGithub'] = None,
                 google: Optional['outputs.WindowsFunctionAppSlotAuthSettingsGoogle'] = None,
                 issuer: Optional[str] = None,
                 microsoft: Optional['outputs.WindowsFunctionAppSlotAuthSettingsMicrosoft'] = None,
                 runtime_version: Optional[str] = None,
                 token_refresh_extension_hours: Optional[float] = None,
                 token_store_enabled: Optional[bool] = None,
                 twitter: Optional['outputs.WindowsFunctionAppSlotAuthSettingsTwitter'] = None,
                 unauthenticated_client_action: Optional[str] = None):
        """
        :param bool enabled: Should the Authentication / Authorization feature be enabled?
        :param 'WindowsFunctionAppSlotAuthSettingsActiveDirectoryArgs' active_directory: an `active_directory` block as detailed below.
        :param Mapping[str, str] additional_login_parameters: Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        :param Sequence[str] allowed_external_redirect_urls: an `allowed_external_redirect_urls` block as detailed below.
        :param str default_provider: The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.
               
               > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        :param 'WindowsFunctionAppSlotAuthSettingsFacebookArgs' facebook: a `facebook` block as detailed below.
        :param 'WindowsFunctionAppSlotAuthSettingsGithubArgs' github: a `github` block as detailed below.
        :param 'WindowsFunctionAppSlotAuthSettingsGoogleArgs' google: a `google` block as detailed below.
        :param str issuer: The OpenID Connect Issuer URI that represents the entity which issues access tokens.
               
               > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        :param 'WindowsFunctionAppSlotAuthSettingsMicrosoftArgs' microsoft: a `microsoft` block as detailed below.
        :param str runtime_version: The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        :param float token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        :param bool token_store_enabled: Should the Windows Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        :param 'WindowsFunctionAppSlotAuthSettingsTwitterArgs' twitter: a `twitter` block as detailed below.
        :param str unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if active_directory is not None:
            pulumi.set(__self__, "active_directory", active_directory)
        if additional_login_parameters is not None:
            pulumi.set(__self__, "additional_login_parameters", additional_login_parameters)
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if facebook is not None:
            pulumi.set(__self__, "facebook", facebook)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if google is not None:
            pulumi.set(__self__, "google", google)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if microsoft is not None:
            pulumi.set(__self__, "microsoft", microsoft)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if token_refresh_extension_hours is not None:
            pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if twitter is not None:
            pulumi.set(__self__, "twitter", twitter)
        if unauthenticated_client_action is not None:
            pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Should the Authentication / Authorization feature be enabled?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="activeDirectory")
    def active_directory(self) -> Optional['outputs.WindowsFunctionAppSlotAuthSettingsActiveDirectory']:
        """
        an `active_directory` block as detailed below.
        """
        return pulumi.get(self, "active_directory")

    @property
    @pulumi.getter(name="additionalLoginParameters")
    def additional_login_parameters(self) -> Optional[Mapping[str, str]]:
        """
        Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        """
        return pulumi.get(self, "additional_login_parameters")

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[Sequence[str]]:
        """
        an `allowed_external_redirect_urls` block as detailed below.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[str]:
        """
        The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.

        > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        """
        return pulumi.get(self, "default_provider")

    @property
    @pulumi.getter
    def facebook(self) -> Optional['outputs.WindowsFunctionAppSlotAuthSettingsFacebook']:
        """
        a `facebook` block as detailed below.
        """
        return pulumi.get(self, "facebook")

    @property
    @pulumi.getter
    def github(self) -> Optional['outputs.WindowsFunctionAppSlotAuthSettingsGithub']:
        """
        a `github` block as detailed below.
        """
        return pulumi.get(self, "github")

    @property
    @pulumi.getter
    def google(self) -> Optional['outputs.WindowsFunctionAppSlotAuthSettingsGoogle']:
        """
        a `google` block as detailed below.
        """
        return pulumi.get(self, "google")

    @property
    @pulumi.getter
    def issuer(self) -> Optional[str]:
        """
        The OpenID Connect Issuer URI that represents the entity which issues access tokens.

        > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def microsoft(self) -> Optional['outputs.WindowsFunctionAppSlotAuthSettingsMicrosoft']:
        """
        a `microsoft` block as detailed below.
        """
        return pulumi.get(self, "microsoft")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[str]:
        """
        The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> Optional[float]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        return pulumi.get(self, "token_refresh_extension_hours")

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[bool]:
        """
        Should the Windows Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        """
        return pulumi.get(self, "token_store_enabled")

    @property
    @pulumi.getter
    def twitter(self) -> Optional['outputs.WindowsFunctionAppSlotAuthSettingsTwitter']:
        """
        a `twitter` block as detailed below.
        """
        return pulumi.get(self, "twitter")

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> Optional[str]:
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        return pulumi.get(self, "unauthenticated_client_action")


@pulumi.output_type
class WindowsFunctionAppSlotAuthSettingsActiveDirectory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotAuthSettingsActiveDirectory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotAuthSettingsActiveDirectory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotAuthSettingsActiveDirectory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param Sequence[str] allowed_audiences: an `allowed_audiences` block as detailed below.
               
               > **Note:** The `client_id` value is always considered an allowed audience.
        :param str client_secret: The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        pulumi.set(__self__, "client_id", client_id)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        an `allowed_audiences` block as detailed below.

        > **Note:** The `client_id` value is always considered an allowed audience.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")


@pulumi.output_type
class WindowsFunctionAppSlotAuthSettingsFacebook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "appSecret":
            suggest = "app_secret"
        elif key == "appSecretSettingName":
            suggest = "app_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotAuthSettingsFacebook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotAuthSettingsFacebook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotAuthSettingsFacebook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: str,
                 app_secret: Optional[str] = None,
                 app_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str app_id: The App ID of the Facebook app used for login.
        :param str app_secret: The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        :param str app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        :param Sequence[str] oauth_scopes: an `oauth_scopes` block as detailed below.
        """
        pulumi.set(__self__, "app_id", app_id)
        if app_secret is not None:
            pulumi.set(__self__, "app_secret", app_secret)
        if app_secret_setting_name is not None:
            pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appSecret")
    def app_secret(self) -> Optional[str]:
        """
        The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        """
        return pulumi.get(self, "app_secret")

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        an `oauth_scopes` block as detailed below.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class WindowsFunctionAppSlotAuthSettingsGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotAuthSettingsGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotAuthSettingsGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotAuthSettingsGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the GitHub app used for login.
        :param str client_secret: The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: an `oauth_scopes` block as detailed below.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the GitHub app used for login.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        an `oauth_scopes` block as detailed below.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class WindowsFunctionAppSlotAuthSettingsGoogle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotAuthSettingsGoogle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotAuthSettingsGoogle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotAuthSettingsGoogle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OpenID Connect Client ID for the Google web application.
        :param str client_secret: The client secret associated with the Google web application. Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: an `oauth_scopes` block as detailed below.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OpenID Connect Client ID for the Google web application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The client secret associated with the Google web application. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        an `oauth_scopes` block as detailed below.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class WindowsFunctionAppSlotAuthSettingsMicrosoft(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotAuthSettingsMicrosoft. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotAuthSettingsMicrosoft.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotAuthSettingsMicrosoft.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret: The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, `wl.basic` is used as the default scope.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, `wl.basic` is used as the default scope.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class WindowsFunctionAppSlotAuthSettingsTwitter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerKey":
            suggest = "consumer_key"
        elif key == "consumerSecret":
            suggest = "consumer_secret"
        elif key == "consumerSecretSettingName":
            suggest = "consumer_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotAuthSettingsTwitter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotAuthSettingsTwitter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotAuthSettingsTwitter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_key: str,
                 consumer_secret: Optional[str] = None,
                 consumer_secret_setting_name: Optional[str] = None):
        """
        :param str consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param str consumer_secret: The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        :param str consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        if consumer_secret is not None:
            pulumi.set(__self__, "consumer_secret", consumer_secret)
        if consumer_secret_setting_name is not None:
            pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> str:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> Optional[str]:
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        """
        return pulumi.get(self, "consumer_secret")

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        return pulumi.get(self, "consumer_secret_setting_name")


@pulumi.output_type
class WindowsFunctionAppSlotAuthSettingsV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeDirectoryV2":
            suggest = "active_directory_v2"
        elif key == "appleV2":
            suggest = "apple_v2"
        elif key == "authEnabled":
            suggest = "auth_enabled"
        elif key == "azureStaticWebAppV2":
            suggest = "azure_static_web_app_v2"
        elif key == "configFilePath":
            suggest = "config_file_path"
        elif key == "customOidcV2s":
            suggest = "custom_oidc_v2s"
        elif key == "defaultProvider":
            suggest = "default_provider"
        elif key == "excludedPaths":
            suggest = "excluded_paths"
        elif key == "facebookV2":
            suggest = "facebook_v2"
        elif key == "forwardProxyConvention":
            suggest = "forward_proxy_convention"
        elif key == "forwardProxyCustomHostHeaderName":
            suggest = "forward_proxy_custom_host_header_name"
        elif key == "forwardProxyCustomSchemeHeaderName":
            suggest = "forward_proxy_custom_scheme_header_name"
        elif key == "githubV2":
            suggest = "github_v2"
        elif key == "googleV2":
            suggest = "google_v2"
        elif key == "httpRouteApiPrefix":
            suggest = "http_route_api_prefix"
        elif key == "microsoftV2":
            suggest = "microsoft_v2"
        elif key == "requireAuthentication":
            suggest = "require_authentication"
        elif key == "requireHttps":
            suggest = "require_https"
        elif key == "runtimeVersion":
            suggest = "runtime_version"
        elif key == "twitterV2":
            suggest = "twitter_v2"
        elif key == "unauthenticatedAction":
            suggest = "unauthenticated_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotAuthSettingsV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotAuthSettingsV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotAuthSettingsV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 login: 'outputs.WindowsFunctionAppSlotAuthSettingsV2Login',
                 active_directory_v2: Optional['outputs.WindowsFunctionAppSlotAuthSettingsV2ActiveDirectoryV2'] = None,
                 apple_v2: Optional['outputs.WindowsFunctionAppSlotAuthSettingsV2AppleV2'] = None,
                 auth_enabled: Optional[bool] = None,
                 azure_static_web_app_v2: Optional['outputs.WindowsFunctionAppSlotAuthSettingsV2AzureStaticWebAppV2'] = None,
                 config_file_path: Optional[str] = None,
                 custom_oidc_v2s: Optional[Sequence['outputs.WindowsFunctionAppSlotAuthSettingsV2CustomOidcV2']] = None,
                 default_provider: Optional[str] = None,
                 excluded_paths: Optional[Sequence[str]] = None,
                 facebook_v2: Optional['outputs.WindowsFunctionAppSlotAuthSettingsV2FacebookV2'] = None,
                 forward_proxy_convention: Optional[str] = None,
                 forward_proxy_custom_host_header_name: Optional[str] = None,
                 forward_proxy_custom_scheme_header_name: Optional[str] = None,
                 github_v2: Optional['outputs.WindowsFunctionAppSlotAuthSettingsV2GithubV2'] = None,
                 google_v2: Optional['outputs.WindowsFunctionAppSlotAuthSettingsV2GoogleV2'] = None,
                 http_route_api_prefix: Optional[str] = None,
                 microsoft_v2: Optional['outputs.WindowsFunctionAppSlotAuthSettingsV2MicrosoftV2'] = None,
                 require_authentication: Optional[bool] = None,
                 require_https: Optional[bool] = None,
                 runtime_version: Optional[str] = None,
                 twitter_v2: Optional['outputs.WindowsFunctionAppSlotAuthSettingsV2TwitterV2'] = None,
                 unauthenticated_action: Optional[str] = None):
        """
        :param 'WindowsFunctionAppSlotAuthSettingsV2LoginArgs' login: A `login` block as defined below.
        :param 'WindowsFunctionAppSlotAuthSettingsV2ActiveDirectoryV2Args' active_directory_v2: An `active_directory_v2` block as defined below.
        :param 'WindowsFunctionAppSlotAuthSettingsV2AppleV2Args' apple_v2: An `apple_v2` block as defined below.
        :param bool auth_enabled: Should the AuthV2 Settings be enabled. Defaults to `false`.
        :param 'WindowsFunctionAppSlotAuthSettingsV2AzureStaticWebAppV2Args' azure_static_web_app_v2: An `azure_static_web_app_v2` block as defined below.
        :param str config_file_path: The path to the App Auth settings.
               
               * > **Note:** Relative Paths are evaluated from the Site Root directory.
        :param Sequence['WindowsFunctionAppSlotAuthSettingsV2CustomOidcV2Args'] custom_oidc_v2s: Zero or more `custom_oidc_v2` blocks as defined below.
        :param str default_provider: The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.
               
               > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        :param Sequence[str] excluded_paths: The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.
               
               > **NOTE:** This list should be used instead of setting `WEBSITE_WARMUP_PATH` in `app_settings` as it takes priority.
        :param 'WindowsFunctionAppSlotAuthSettingsV2FacebookV2Args' facebook_v2: A `facebook_v2` block as defined below.
        :param str forward_proxy_convention: The convention used to determine the url of the request made. Possible values include `NoProxy`, `Standard`, `Custom`. Defaults to `NoProxy`.
        :param str forward_proxy_custom_host_header_name: The name of the custom header containing the host of the request.
        :param str forward_proxy_custom_scheme_header_name: The name of the custom header containing the scheme of the request.
        :param 'WindowsFunctionAppSlotAuthSettingsV2GithubV2Args' github_v2: A `github_v2` block as defined below.
        :param 'WindowsFunctionAppSlotAuthSettingsV2GoogleV2Args' google_v2: A `google_v2` block as defined below.
        :param str http_route_api_prefix: The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
        :param 'WindowsFunctionAppSlotAuthSettingsV2MicrosoftV2Args' microsoft_v2: A `microsoft_v2` block as defined below.
        :param bool require_authentication: Should the authentication flow be used for all requests.
        :param bool require_https: Should HTTPS be required on connections? Defaults to `true`.
        :param str runtime_version: The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        :param 'WindowsFunctionAppSlotAuthSettingsV2TwitterV2Args' twitter_v2: A `twitter_v2` block as defined below.
        :param str unauthenticated_action: The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
        """
        pulumi.set(__self__, "login", login)
        if active_directory_v2 is not None:
            pulumi.set(__self__, "active_directory_v2", active_directory_v2)
        if apple_v2 is not None:
            pulumi.set(__self__, "apple_v2", apple_v2)
        if auth_enabled is not None:
            pulumi.set(__self__, "auth_enabled", auth_enabled)
        if azure_static_web_app_v2 is not None:
            pulumi.set(__self__, "azure_static_web_app_v2", azure_static_web_app_v2)
        if config_file_path is not None:
            pulumi.set(__self__, "config_file_path", config_file_path)
        if custom_oidc_v2s is not None:
            pulumi.set(__self__, "custom_oidc_v2s", custom_oidc_v2s)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if excluded_paths is not None:
            pulumi.set(__self__, "excluded_paths", excluded_paths)
        if facebook_v2 is not None:
            pulumi.set(__self__, "facebook_v2", facebook_v2)
        if forward_proxy_convention is not None:
            pulumi.set(__self__, "forward_proxy_convention", forward_proxy_convention)
        if forward_proxy_custom_host_header_name is not None:
            pulumi.set(__self__, "forward_proxy_custom_host_header_name", forward_proxy_custom_host_header_name)
        if forward_proxy_custom_scheme_header_name is not None:
            pulumi.set(__self__, "forward_proxy_custom_scheme_header_name", forward_proxy_custom_scheme_header_name)
        if github_v2 is not None:
            pulumi.set(__self__, "github_v2", github_v2)
        if google_v2 is not None:
            pulumi.set(__self__, "google_v2", google_v2)
        if http_route_api_prefix is not None:
            pulumi.set(__self__, "http_route_api_prefix", http_route_api_prefix)
        if microsoft_v2 is not None:
            pulumi.set(__self__, "microsoft_v2", microsoft_v2)
        if require_authentication is not None:
            pulumi.set(__self__, "require_authentication", require_authentication)
        if require_https is not None:
            pulumi.set(__self__, "require_https", require_https)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if twitter_v2 is not None:
            pulumi.set(__self__, "twitter_v2", twitter_v2)
        if unauthenticated_action is not None:
            pulumi.set(__self__, "unauthenticated_action", unauthenticated_action)

    @property
    @pulumi.getter
    def login(self) -> 'outputs.WindowsFunctionAppSlotAuthSettingsV2Login':
        """
        A `login` block as defined below.
        """
        return pulumi.get(self, "login")

    @property
    @pulumi.getter(name="activeDirectoryV2")
    def active_directory_v2(self) -> Optional['outputs.WindowsFunctionAppSlotAuthSettingsV2ActiveDirectoryV2']:
        """
        An `active_directory_v2` block as defined below.
        """
        return pulumi.get(self, "active_directory_v2")

    @property
    @pulumi.getter(name="appleV2")
    def apple_v2(self) -> Optional['outputs.WindowsFunctionAppSlotAuthSettingsV2AppleV2']:
        """
        An `apple_v2` block as defined below.
        """
        return pulumi.get(self, "apple_v2")

    @property
    @pulumi.getter(name="authEnabled")
    def auth_enabled(self) -> Optional[bool]:
        """
        Should the AuthV2 Settings be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "auth_enabled")

    @property
    @pulumi.getter(name="azureStaticWebAppV2")
    def azure_static_web_app_v2(self) -> Optional['outputs.WindowsFunctionAppSlotAuthSettingsV2AzureStaticWebAppV2']:
        """
        An `azure_static_web_app_v2` block as defined below.
        """
        return pulumi.get(self, "azure_static_web_app_v2")

    @property
    @pulumi.getter(name="configFilePath")
    def config_file_path(self) -> Optional[str]:
        """
        The path to the App Auth settings.

        * > **Note:** Relative Paths are evaluated from the Site Root directory.
        """
        return pulumi.get(self, "config_file_path")

    @property
    @pulumi.getter(name="customOidcV2s")
    def custom_oidc_v2s(self) -> Optional[Sequence['outputs.WindowsFunctionAppSlotAuthSettingsV2CustomOidcV2']]:
        """
        Zero or more `custom_oidc_v2` blocks as defined below.
        """
        return pulumi.get(self, "custom_oidc_v2s")

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[str]:
        """
        The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.

        > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        """
        return pulumi.get(self, "default_provider")

    @property
    @pulumi.getter(name="excludedPaths")
    def excluded_paths(self) -> Optional[Sequence[str]]:
        """
        The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.

        > **NOTE:** This list should be used instead of setting `WEBSITE_WARMUP_PATH` in `app_settings` as it takes priority.
        """
        return pulumi.get(self, "excluded_paths")

    @property
    @pulumi.getter(name="facebookV2")
    def facebook_v2(self) -> Optional['outputs.WindowsFunctionAppSlotAuthSettingsV2FacebookV2']:
        """
        A `facebook_v2` block as defined below.
        """
        return pulumi.get(self, "facebook_v2")

    @property
    @pulumi.getter(name="forwardProxyConvention")
    def forward_proxy_convention(self) -> Optional[str]:
        """
        The convention used to determine the url of the request made. Possible values include `NoProxy`, `Standard`, `Custom`. Defaults to `NoProxy`.
        """
        return pulumi.get(self, "forward_proxy_convention")

    @property
    @pulumi.getter(name="forwardProxyCustomHostHeaderName")
    def forward_proxy_custom_host_header_name(self) -> Optional[str]:
        """
        The name of the custom header containing the host of the request.
        """
        return pulumi.get(self, "forward_proxy_custom_host_header_name")

    @property
    @pulumi.getter(name="forwardProxyCustomSchemeHeaderName")
    def forward_proxy_custom_scheme_header_name(self) -> Optional[str]:
        """
        The name of the custom header containing the scheme of the request.
        """
        return pulumi.get(self, "forward_proxy_custom_scheme_header_name")

    @property
    @pulumi.getter(name="githubV2")
    def github_v2(self) -> Optional['outputs.WindowsFunctionAppSlotAuthSettingsV2GithubV2']:
        """
        A `github_v2` block as defined below.
        """
        return pulumi.get(self, "github_v2")

    @property
    @pulumi.getter(name="googleV2")
    def google_v2(self) -> Optional['outputs.WindowsFunctionAppSlotAuthSettingsV2GoogleV2']:
        """
        A `google_v2` block as defined below.
        """
        return pulumi.get(self, "google_v2")

    @property
    @pulumi.getter(name="httpRouteApiPrefix")
    def http_route_api_prefix(self) -> Optional[str]:
        """
        The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
        """
        return pulumi.get(self, "http_route_api_prefix")

    @property
    @pulumi.getter(name="microsoftV2")
    def microsoft_v2(self) -> Optional['outputs.WindowsFunctionAppSlotAuthSettingsV2MicrosoftV2']:
        """
        A `microsoft_v2` block as defined below.
        """
        return pulumi.get(self, "microsoft_v2")

    @property
    @pulumi.getter(name="requireAuthentication")
    def require_authentication(self) -> Optional[bool]:
        """
        Should the authentication flow be used for all requests.
        """
        return pulumi.get(self, "require_authentication")

    @property
    @pulumi.getter(name="requireHttps")
    def require_https(self) -> Optional[bool]:
        """
        Should HTTPS be required on connections? Defaults to `true`.
        """
        return pulumi.get(self, "require_https")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[str]:
        """
        The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter(name="twitterV2")
    def twitter_v2(self) -> Optional['outputs.WindowsFunctionAppSlotAuthSettingsV2TwitterV2']:
        """
        A `twitter_v2` block as defined below.
        """
        return pulumi.get(self, "twitter_v2")

    @property
    @pulumi.getter(name="unauthenticatedAction")
    def unauthenticated_action(self) -> Optional[str]:
        """
        The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
        """
        return pulumi.get(self, "unauthenticated_action")


@pulumi.output_type
class WindowsFunctionAppSlotAuthSettingsV2ActiveDirectoryV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "tenantAuthEndpoint":
            suggest = "tenant_auth_endpoint"
        elif key == "allowedApplications":
            suggest = "allowed_applications"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "allowedGroups":
            suggest = "allowed_groups"
        elif key == "allowedIdentities":
            suggest = "allowed_identities"
        elif key == "clientSecretCertificateThumbprint":
            suggest = "client_secret_certificate_thumbprint"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "jwtAllowedClientApplications":
            suggest = "jwt_allowed_client_applications"
        elif key == "jwtAllowedGroups":
            suggest = "jwt_allowed_groups"
        elif key == "loginParameters":
            suggest = "login_parameters"
        elif key == "wwwAuthenticationDisabled":
            suggest = "www_authentication_disabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotAuthSettingsV2ActiveDirectoryV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotAuthSettingsV2ActiveDirectoryV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotAuthSettingsV2ActiveDirectoryV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 tenant_auth_endpoint: str,
                 allowed_applications: Optional[Sequence[str]] = None,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 allowed_groups: Optional[Sequence[str]] = None,
                 allowed_identities: Optional[Sequence[str]] = None,
                 client_secret_certificate_thumbprint: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 jwt_allowed_client_applications: Optional[Sequence[str]] = None,
                 jwt_allowed_groups: Optional[Sequence[str]] = None,
                 login_parameters: Optional[Mapping[str, str]] = None,
                 www_authentication_disabled: Optional[bool] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str tenant_auth_endpoint: The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`
        :param Sequence[str] allowed_applications: The list of allowed Applications for the Default Authorisation Policy.
        :param Sequence[str] allowed_audiences: an `allowed_audiences` block as detailed below.
               
               > **Note:** The `client_id` value is always considered an allowed audience.
        :param Sequence[str] allowed_groups: The list of allowed Group Names for the Default Authorisation Policy.
        :param Sequence[str] allowed_identities: The list of allowed Identities for the Default Authorisation Policy.
        :param str client_secret_certificate_thumbprint: The thumbprint of the certificate used for signing purposes.
               
               > **NOTE:** One of `client_secret_setting_name` or `client_secret_certificate_thumbprint` must be specified.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param Sequence[str] jwt_allowed_client_applications: A list of Allowed Client Applications in the JWT Claim.
        :param Sequence[str] jwt_allowed_groups: A list of Allowed Groups in the JWT Claim.
        :param Mapping[str, str] login_parameters: A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
        :param bool www_authentication_disabled: Should the www-authenticate provider should be omitted from the request? Defaults to `false`
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "tenant_auth_endpoint", tenant_auth_endpoint)
        if allowed_applications is not None:
            pulumi.set(__self__, "allowed_applications", allowed_applications)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if allowed_groups is not None:
            pulumi.set(__self__, "allowed_groups", allowed_groups)
        if allowed_identities is not None:
            pulumi.set(__self__, "allowed_identities", allowed_identities)
        if client_secret_certificate_thumbprint is not None:
            pulumi.set(__self__, "client_secret_certificate_thumbprint", client_secret_certificate_thumbprint)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if jwt_allowed_client_applications is not None:
            pulumi.set(__self__, "jwt_allowed_client_applications", jwt_allowed_client_applications)
        if jwt_allowed_groups is not None:
            pulumi.set(__self__, "jwt_allowed_groups", jwt_allowed_groups)
        if login_parameters is not None:
            pulumi.set(__self__, "login_parameters", login_parameters)
        if www_authentication_disabled is not None:
            pulumi.set(__self__, "www_authentication_disabled", www_authentication_disabled)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="tenantAuthEndpoint")
    def tenant_auth_endpoint(self) -> str:
        """
        The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`
        """
        return pulumi.get(self, "tenant_auth_endpoint")

    @property
    @pulumi.getter(name="allowedApplications")
    def allowed_applications(self) -> Optional[Sequence[str]]:
        """
        The list of allowed Applications for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_applications")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        an `allowed_audiences` block as detailed below.

        > **Note:** The `client_id` value is always considered an allowed audience.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="allowedGroups")
    def allowed_groups(self) -> Optional[Sequence[str]]:
        """
        The list of allowed Group Names for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_groups")

    @property
    @pulumi.getter(name="allowedIdentities")
    def allowed_identities(self) -> Optional[Sequence[str]]:
        """
        The list of allowed Identities for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_identities")

    @property
    @pulumi.getter(name="clientSecretCertificateThumbprint")
    def client_secret_certificate_thumbprint(self) -> Optional[str]:
        """
        The thumbprint of the certificate used for signing purposes.

        > **NOTE:** One of `client_secret_setting_name` or `client_secret_certificate_thumbprint` must be specified.
        """
        return pulumi.get(self, "client_secret_certificate_thumbprint")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="jwtAllowedClientApplications")
    def jwt_allowed_client_applications(self) -> Optional[Sequence[str]]:
        """
        A list of Allowed Client Applications in the JWT Claim.
        """
        return pulumi.get(self, "jwt_allowed_client_applications")

    @property
    @pulumi.getter(name="jwtAllowedGroups")
    def jwt_allowed_groups(self) -> Optional[Sequence[str]]:
        """
        A list of Allowed Groups in the JWT Claim.
        """
        return pulumi.get(self, "jwt_allowed_groups")

    @property
    @pulumi.getter(name="loginParameters")
    def login_parameters(self) -> Optional[Mapping[str, str]]:
        """
        A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
        """
        return pulumi.get(self, "login_parameters")

    @property
    @pulumi.getter(name="wwwAuthenticationDisabled")
    def www_authentication_disabled(self) -> Optional[bool]:
        """
        Should the www-authenticate provider should be omitted from the request? Defaults to `false`
        """
        return pulumi.get(self, "www_authentication_disabled")


@pulumi.output_type
class WindowsFunctionAppSlotAuthSettingsV2AppleV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "loginScopes":
            suggest = "login_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotAuthSettingsV2AppleV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotAuthSettingsV2AppleV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotAuthSettingsV2AppleV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret_setting_name: str,
                 login_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param Sequence[str] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[Sequence[str]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class WindowsFunctionAppSlotAuthSettingsV2AzureStaticWebAppV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotAuthSettingsV2AzureStaticWebAppV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotAuthSettingsV2AzureStaticWebAppV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotAuthSettingsV2AzureStaticWebAppV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        """
        pulumi.set(__self__, "client_id", client_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")


@pulumi.output_type
class WindowsFunctionAppSlotAuthSettingsV2CustomOidcV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "openidConfigurationEndpoint":
            suggest = "openid_configuration_endpoint"
        elif key == "authorisationEndpoint":
            suggest = "authorisation_endpoint"
        elif key == "certificationUri":
            suggest = "certification_uri"
        elif key == "clientCredentialMethod":
            suggest = "client_credential_method"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "issuerEndpoint":
            suggest = "issuer_endpoint"
        elif key == "nameClaimType":
            suggest = "name_claim_type"
        elif key == "tokenEndpoint":
            suggest = "token_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotAuthSettingsV2CustomOidcV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotAuthSettingsV2CustomOidcV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotAuthSettingsV2CustomOidcV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 name: str,
                 openid_configuration_endpoint: str,
                 authorisation_endpoint: Optional[str] = None,
                 certification_uri: Optional[str] = None,
                 client_credential_method: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 issuer_endpoint: Optional[str] = None,
                 name_claim_type: Optional[str] = None,
                 scopes: Optional[Sequence[str]] = None,
                 token_endpoint: Optional[str] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str name: Specifies the name of the Windows Function App Slot. Changing this forces a new resource to be created.
        :param str openid_configuration_endpoint: The app setting name that contains the `client_secret` value used for the Custom OIDC Login.
        :param str authorisation_endpoint: The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        :param str certification_uri: The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        :param str client_credential_method: The Client Credential Method used.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param str issuer_endpoint: The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        :param str name_claim_type: The name of the claim that contains the users name.
        :param Sequence[str] scopes: The list of the scopes that should be requested while authenticating.
        :param str token_endpoint: The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "openid_configuration_endpoint", openid_configuration_endpoint)
        if authorisation_endpoint is not None:
            pulumi.set(__self__, "authorisation_endpoint", authorisation_endpoint)
        if certification_uri is not None:
            pulumi.set(__self__, "certification_uri", certification_uri)
        if client_credential_method is not None:
            pulumi.set(__self__, "client_credential_method", client_credential_method)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if issuer_endpoint is not None:
            pulumi.set(__self__, "issuer_endpoint", issuer_endpoint)
        if name_claim_type is not None:
            pulumi.set(__self__, "name_claim_type", name_claim_type)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Windows Function App Slot. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="openidConfigurationEndpoint")
    def openid_configuration_endpoint(self) -> str:
        """
        The app setting name that contains the `client_secret` value used for the Custom OIDC Login.
        """
        return pulumi.get(self, "openid_configuration_endpoint")

    @property
    @pulumi.getter(name="authorisationEndpoint")
    def authorisation_endpoint(self) -> Optional[str]:
        """
        The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "authorisation_endpoint")

    @property
    @pulumi.getter(name="certificationUri")
    def certification_uri(self) -> Optional[str]:
        """
        The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "certification_uri")

    @property
    @pulumi.getter(name="clientCredentialMethod")
    def client_credential_method(self) -> Optional[str]:
        """
        The Client Credential Method used.
        """
        return pulumi.get(self, "client_credential_method")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="issuerEndpoint")
    def issuer_endpoint(self) -> Optional[str]:
        """
        The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "issuer_endpoint")

    @property
    @pulumi.getter(name="nameClaimType")
    def name_claim_type(self) -> Optional[str]:
        """
        The name of the claim that contains the users name.
        """
        return pulumi.get(self, "name_claim_type")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[str]]:
        """
        The list of the scopes that should be requested while authenticating.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[str]:
        """
        The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "token_endpoint")


@pulumi.output_type
class WindowsFunctionAppSlotAuthSettingsV2FacebookV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "appSecretSettingName":
            suggest = "app_secret_setting_name"
        elif key == "graphApiVersion":
            suggest = "graph_api_version"
        elif key == "loginScopes":
            suggest = "login_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotAuthSettingsV2FacebookV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotAuthSettingsV2FacebookV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotAuthSettingsV2FacebookV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: str,
                 app_secret_setting_name: str,
                 graph_api_version: Optional[str] = None,
                 login_scopes: Optional[Sequence[str]] = None):
        """
        :param str app_id: The App ID of the Facebook app used for login.
        :param str app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook Login.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param str graph_api_version: The version of the Facebook API to be used while logging in.
        :param Sequence[str] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        if graph_api_version is not None:
            pulumi.set(__self__, "graph_api_version", graph_api_version)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> str:
        """
        The app setting name that contains the `app_secret` value used for Facebook Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @property
    @pulumi.getter(name="graphApiVersion")
    def graph_api_version(self) -> Optional[str]:
        """
        The version of the Facebook API to be used while logging in.
        """
        return pulumi.get(self, "graph_api_version")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[Sequence[str]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class WindowsFunctionAppSlotAuthSettingsV2GithubV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "loginScopes":
            suggest = "login_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotAuthSettingsV2GithubV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotAuthSettingsV2GithubV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotAuthSettingsV2GithubV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret_setting_name: str,
                 login_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param Sequence[str] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[Sequence[str]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class WindowsFunctionAppSlotAuthSettingsV2GoogleV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "loginScopes":
            suggest = "login_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotAuthSettingsV2GoogleV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotAuthSettingsV2GoogleV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotAuthSettingsV2GoogleV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret_setting_name: str,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 login_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param Sequence[str] allowed_audiences: an `allowed_audiences` block as detailed below.
               
               > **Note:** The `client_id` value is always considered an allowed audience.
        :param Sequence[str] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        an `allowed_audiences` block as detailed below.

        > **Note:** The `client_id` value is always considered an allowed audience.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[Sequence[str]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class WindowsFunctionAppSlotAuthSettingsV2Login(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedExternalRedirectUrls":
            suggest = "allowed_external_redirect_urls"
        elif key == "cookieExpirationConvention":
            suggest = "cookie_expiration_convention"
        elif key == "cookieExpirationTime":
            suggest = "cookie_expiration_time"
        elif key == "logoutEndpoint":
            suggest = "logout_endpoint"
        elif key == "nonceExpirationTime":
            suggest = "nonce_expiration_time"
        elif key == "preserveUrlFragmentsForLogins":
            suggest = "preserve_url_fragments_for_logins"
        elif key == "tokenRefreshExtensionTime":
            suggest = "token_refresh_extension_time"
        elif key == "tokenStoreEnabled":
            suggest = "token_store_enabled"
        elif key == "tokenStorePath":
            suggest = "token_store_path"
        elif key == "tokenStoreSasSettingName":
            suggest = "token_store_sas_setting_name"
        elif key == "validateNonce":
            suggest = "validate_nonce"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotAuthSettingsV2Login. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotAuthSettingsV2Login.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotAuthSettingsV2Login.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_external_redirect_urls: Optional[Sequence[str]] = None,
                 cookie_expiration_convention: Optional[str] = None,
                 cookie_expiration_time: Optional[str] = None,
                 logout_endpoint: Optional[str] = None,
                 nonce_expiration_time: Optional[str] = None,
                 preserve_url_fragments_for_logins: Optional[bool] = None,
                 token_refresh_extension_time: Optional[float] = None,
                 token_store_enabled: Optional[bool] = None,
                 token_store_path: Optional[str] = None,
                 token_store_sas_setting_name: Optional[str] = None,
                 validate_nonce: Optional[bool] = None):
        """
        :param Sequence[str] allowed_external_redirect_urls: External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends.
               
               > **Note:** URLs within the current domain are always implicitly allowed.
        :param str cookie_expiration_convention: The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
        :param str cookie_expiration_time: The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
        :param str logout_endpoint: The endpoint to which logout requests should be made.
        :param str nonce_expiration_time: The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
        :param bool preserve_url_fragments_for_logins: Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
        :param float token_refresh_extension_time: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        :param bool token_store_enabled: Should the Token Store configuration Enabled. Defaults to `false`
        :param str token_store_path: The directory path in the App Filesystem in which the tokens will be stored.
        :param str token_store_sas_setting_name: The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        :param bool validate_nonce: Should the nonce be validated while completing the login flow. Defaults to `true`.
        """
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if cookie_expiration_convention is not None:
            pulumi.set(__self__, "cookie_expiration_convention", cookie_expiration_convention)
        if cookie_expiration_time is not None:
            pulumi.set(__self__, "cookie_expiration_time", cookie_expiration_time)
        if logout_endpoint is not None:
            pulumi.set(__self__, "logout_endpoint", logout_endpoint)
        if nonce_expiration_time is not None:
            pulumi.set(__self__, "nonce_expiration_time", nonce_expiration_time)
        if preserve_url_fragments_for_logins is not None:
            pulumi.set(__self__, "preserve_url_fragments_for_logins", preserve_url_fragments_for_logins)
        if token_refresh_extension_time is not None:
            pulumi.set(__self__, "token_refresh_extension_time", token_refresh_extension_time)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if token_store_path is not None:
            pulumi.set(__self__, "token_store_path", token_store_path)
        if token_store_sas_setting_name is not None:
            pulumi.set(__self__, "token_store_sas_setting_name", token_store_sas_setting_name)
        if validate_nonce is not None:
            pulumi.set(__self__, "validate_nonce", validate_nonce)

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[Sequence[str]]:
        """
        External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends.

        > **Note:** URLs within the current domain are always implicitly allowed.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @property
    @pulumi.getter(name="cookieExpirationConvention")
    def cookie_expiration_convention(self) -> Optional[str]:
        """
        The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
        """
        return pulumi.get(self, "cookie_expiration_convention")

    @property
    @pulumi.getter(name="cookieExpirationTime")
    def cookie_expiration_time(self) -> Optional[str]:
        """
        The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
        """
        return pulumi.get(self, "cookie_expiration_time")

    @property
    @pulumi.getter(name="logoutEndpoint")
    def logout_endpoint(self) -> Optional[str]:
        """
        The endpoint to which logout requests should be made.
        """
        return pulumi.get(self, "logout_endpoint")

    @property
    @pulumi.getter(name="nonceExpirationTime")
    def nonce_expiration_time(self) -> Optional[str]:
        """
        The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
        """
        return pulumi.get(self, "nonce_expiration_time")

    @property
    @pulumi.getter(name="preserveUrlFragmentsForLogins")
    def preserve_url_fragments_for_logins(self) -> Optional[bool]:
        """
        Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
        """
        return pulumi.get(self, "preserve_url_fragments_for_logins")

    @property
    @pulumi.getter(name="tokenRefreshExtensionTime")
    def token_refresh_extension_time(self) -> Optional[float]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        return pulumi.get(self, "token_refresh_extension_time")

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[bool]:
        """
        Should the Token Store configuration Enabled. Defaults to `false`
        """
        return pulumi.get(self, "token_store_enabled")

    @property
    @pulumi.getter(name="tokenStorePath")
    def token_store_path(self) -> Optional[str]:
        """
        The directory path in the App Filesystem in which the tokens will be stored.
        """
        return pulumi.get(self, "token_store_path")

    @property
    @pulumi.getter(name="tokenStoreSasSettingName")
    def token_store_sas_setting_name(self) -> Optional[str]:
        """
        The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        """
        return pulumi.get(self, "token_store_sas_setting_name")

    @property
    @pulumi.getter(name="validateNonce")
    def validate_nonce(self) -> Optional[bool]:
        """
        Should the nonce be validated while completing the login flow. Defaults to `true`.
        """
        return pulumi.get(self, "validate_nonce")


@pulumi.output_type
class WindowsFunctionAppSlotAuthSettingsV2MicrosoftV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "loginScopes":
            suggest = "login_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotAuthSettingsV2MicrosoftV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotAuthSettingsV2MicrosoftV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotAuthSettingsV2MicrosoftV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret_setting_name: str,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 login_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param Sequence[str] allowed_audiences: an `allowed_audiences` block as detailed below.
               
               > **Note:** The `client_id` value is always considered an allowed audience.
        :param Sequence[str] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        an `allowed_audiences` block as detailed below.

        > **Note:** The `client_id` value is always considered an allowed audience.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[Sequence[str]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class WindowsFunctionAppSlotAuthSettingsV2TwitterV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerKey":
            suggest = "consumer_key"
        elif key == "consumerSecretSettingName":
            suggest = "consumer_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotAuthSettingsV2TwitterV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotAuthSettingsV2TwitterV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotAuthSettingsV2TwitterV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_key: str,
                 consumer_secret_setting_name: str):
        """
        :param str consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param str consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> str:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> str:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "consumer_secret_setting_name")


@pulumi.output_type
class WindowsFunctionAppSlotBackup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageAccountUrl":
            suggest = "storage_account_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotBackup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotBackup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotBackup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 schedule: 'outputs.WindowsFunctionAppSlotBackupSchedule',
                 storage_account_url: str,
                 enabled: Optional[bool] = None):
        """
        :param str name: The name which should be used for this Backup.
        :param 'WindowsFunctionAppSlotBackupScheduleArgs' schedule: a `schedule` block as detailed below.
        :param str storage_account_url: The SAS URL to the container.
        :param bool enabled: Should this backup job be enabled? Defaults to `true`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "storage_account_url", storage_account_url)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Backup.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def schedule(self) -> 'outputs.WindowsFunctionAppSlotBackupSchedule':
        """
        a `schedule` block as detailed below.
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter(name="storageAccountUrl")
    def storage_account_url(self) -> str:
        """
        The SAS URL to the container.
        """
        return pulumi.get(self, "storage_account_url")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Should this backup job be enabled? Defaults to `true`.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class WindowsFunctionAppSlotBackupSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "frequencyUnit":
            suggest = "frequency_unit"
        elif key == "keepAtLeastOneBackup":
            suggest = "keep_at_least_one_backup"
        elif key == "lastExecutionTime":
            suggest = "last_execution_time"
        elif key == "retentionPeriodDays":
            suggest = "retention_period_days"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotBackupSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotBackupSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotBackupSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_unit: str,
                 keep_at_least_one_backup: Optional[bool] = None,
                 last_execution_time: Optional[str] = None,
                 retention_period_days: Optional[int] = None,
                 start_time: Optional[str] = None):
        """
        :param int frequency_interval: How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).
               
               > **NOTE:** Not all intervals are supported on all SKUs. Please refer to the official documentation for appropriate values.
        :param str frequency_unit: The unit of time for how often the backup should take place. Possible values include: `Day` and `Hour`.
        :param bool keep_at_least_one_backup: Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
        :param str last_execution_time: The time the backup was last attempted.
        :param int retention_period_days: After how many days backups should be deleted. Defaults to `30`.
        :param str start_time: When the schedule should start working in RFC-3339 format.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_unit", frequency_unit)
        if keep_at_least_one_backup is not None:
            pulumi.set(__self__, "keep_at_least_one_backup", keep_at_least_one_backup)
        if last_execution_time is not None:
            pulumi.set(__self__, "last_execution_time", last_execution_time)
        if retention_period_days is not None:
            pulumi.set(__self__, "retention_period_days", retention_period_days)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).

        > **NOTE:** Not all intervals are supported on all SKUs. Please refer to the official documentation for appropriate values.
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyUnit")
    def frequency_unit(self) -> str:
        """
        The unit of time for how often the backup should take place. Possible values include: `Day` and `Hour`.
        """
        return pulumi.get(self, "frequency_unit")

    @property
    @pulumi.getter(name="keepAtLeastOneBackup")
    def keep_at_least_one_backup(self) -> Optional[bool]:
        """
        Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
        """
        return pulumi.get(self, "keep_at_least_one_backup")

    @property
    @pulumi.getter(name="lastExecutionTime")
    def last_execution_time(self) -> Optional[str]:
        """
        The time the backup was last attempted.
        """
        return pulumi.get(self, "last_execution_time")

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> Optional[int]:
        """
        After how many days backups should be deleted. Defaults to `30`.
        """
        return pulumi.get(self, "retention_period_days")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        """
        When the schedule should start working in RFC-3339 format.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class WindowsFunctionAppSlotConnectionString(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: The name which should be used for this Connection.
        :param str type: Type of database. Possible values include: `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
        :param str value: The connection string value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Connection.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of database. Possible values include: `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The connection string value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class WindowsFunctionAppSlotIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 identity_ids: Optional[Sequence[str]] = None,
                 principal_id: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str type: Specifies the type of Managed Service Identity that should be configured on this Windows Function App Slot. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        :param Sequence[str] identity_ids: A list of User Assigned Managed Identity IDs to be assigned to this Windows Function App Slot.
               
               > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        :param str principal_id: The Principal ID associated with this Managed Service Identity.
        :param str tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the type of Managed Service Identity that should be configured on this Windows Function App Slot. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[str]]:
        """
        A list of User Assigned Managed Identity IDs to be assigned to this Windows Function App Slot.

        > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class WindowsFunctionAppSlotSiteConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alwaysOn":
            suggest = "always_on"
        elif key == "apiDefinitionUrl":
            suggest = "api_definition_url"
        elif key == "apiManagementApiId":
            suggest = "api_management_api_id"
        elif key == "appCommandLine":
            suggest = "app_command_line"
        elif key == "appScaleLimit":
            suggest = "app_scale_limit"
        elif key == "appServiceLogs":
            suggest = "app_service_logs"
        elif key == "applicationInsightsConnectionString":
            suggest = "application_insights_connection_string"
        elif key == "applicationInsightsKey":
            suggest = "application_insights_key"
        elif key == "applicationStack":
            suggest = "application_stack"
        elif key == "autoSwapSlotName":
            suggest = "auto_swap_slot_name"
        elif key == "defaultDocuments":
            suggest = "default_documents"
        elif key == "detailedErrorLoggingEnabled":
            suggest = "detailed_error_logging_enabled"
        elif key == "elasticInstanceMinimum":
            suggest = "elastic_instance_minimum"
        elif key == "ftpsState":
            suggest = "ftps_state"
        elif key == "healthCheckEvictionTimeInMin":
            suggest = "health_check_eviction_time_in_min"
        elif key == "healthCheckPath":
            suggest = "health_check_path"
        elif key == "http2Enabled":
            suggest = "http2_enabled"
        elif key == "ipRestrictions":
            suggest = "ip_restrictions"
        elif key == "loadBalancingMode":
            suggest = "load_balancing_mode"
        elif key == "managedPipelineMode":
            suggest = "managed_pipeline_mode"
        elif key == "minimumTlsVersion":
            suggest = "minimum_tls_version"
        elif key == "preWarmedInstanceCount":
            suggest = "pre_warmed_instance_count"
        elif key == "remoteDebuggingEnabled":
            suggest = "remote_debugging_enabled"
        elif key == "remoteDebuggingVersion":
            suggest = "remote_debugging_version"
        elif key == "runtimeScaleMonitoringEnabled":
            suggest = "runtime_scale_monitoring_enabled"
        elif key == "scmIpRestrictions":
            suggest = "scm_ip_restrictions"
        elif key == "scmMinimumTlsVersion":
            suggest = "scm_minimum_tls_version"
        elif key == "scmType":
            suggest = "scm_type"
        elif key == "scmUseMainIpRestriction":
            suggest = "scm_use_main_ip_restriction"
        elif key == "use32BitWorker":
            suggest = "use32_bit_worker"
        elif key == "vnetRouteAllEnabled":
            suggest = "vnet_route_all_enabled"
        elif key == "websocketsEnabled":
            suggest = "websockets_enabled"
        elif key == "windowsFxVersion":
            suggest = "windows_fx_version"
        elif key == "workerCount":
            suggest = "worker_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotSiteConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotSiteConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotSiteConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 always_on: Optional[bool] = None,
                 api_definition_url: Optional[str] = None,
                 api_management_api_id: Optional[str] = None,
                 app_command_line: Optional[str] = None,
                 app_scale_limit: Optional[int] = None,
                 app_service_logs: Optional['outputs.WindowsFunctionAppSlotSiteConfigAppServiceLogs'] = None,
                 application_insights_connection_string: Optional[str] = None,
                 application_insights_key: Optional[str] = None,
                 application_stack: Optional['outputs.WindowsFunctionAppSlotSiteConfigApplicationStack'] = None,
                 auto_swap_slot_name: Optional[str] = None,
                 cors: Optional['outputs.WindowsFunctionAppSlotSiteConfigCors'] = None,
                 default_documents: Optional[Sequence[str]] = None,
                 detailed_error_logging_enabled: Optional[bool] = None,
                 elastic_instance_minimum: Optional[int] = None,
                 ftps_state: Optional[str] = None,
                 health_check_eviction_time_in_min: Optional[int] = None,
                 health_check_path: Optional[str] = None,
                 http2_enabled: Optional[bool] = None,
                 ip_restrictions: Optional[Sequence['outputs.WindowsFunctionAppSlotSiteConfigIpRestriction']] = None,
                 load_balancing_mode: Optional[str] = None,
                 managed_pipeline_mode: Optional[str] = None,
                 minimum_tls_version: Optional[str] = None,
                 pre_warmed_instance_count: Optional[int] = None,
                 remote_debugging_enabled: Optional[bool] = None,
                 remote_debugging_version: Optional[str] = None,
                 runtime_scale_monitoring_enabled: Optional[bool] = None,
                 scm_ip_restrictions: Optional[Sequence['outputs.WindowsFunctionAppSlotSiteConfigScmIpRestriction']] = None,
                 scm_minimum_tls_version: Optional[str] = None,
                 scm_type: Optional[str] = None,
                 scm_use_main_ip_restriction: Optional[bool] = None,
                 use32_bit_worker: Optional[bool] = None,
                 vnet_route_all_enabled: Optional[bool] = None,
                 websockets_enabled: Optional[bool] = None,
                 windows_fx_version: Optional[str] = None,
                 worker_count: Optional[int] = None):
        """
        :param bool always_on: If this Windows Web App is Always On enabled. Defaults to `false`.
        :param str api_definition_url: The URL of the API definition that describes this Windows Function App.
        :param str api_management_api_id: The ID of the API Management API for this Windows Function App.
        :param str app_command_line: The program and any arguments used to launch this app via the command line. (Example `node myapp.js`).
        :param int app_scale_limit: The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
        :param 'WindowsFunctionAppSlotSiteConfigAppServiceLogsArgs' app_service_logs: an `app_service_logs` block as detailed below.
        :param str application_insights_connection_string: The Connection String for linking the Windows Function App to Application Insights.
        :param str application_insights_key: The Instrumentation Key for connecting the Windows Function App to Application Insights.
        :param 'WindowsFunctionAppSlotSiteConfigApplicationStackArgs' application_stack: an `application_stack` block as detailed below.
        :param str auto_swap_slot_name: The name of the slot to automatically swap with when this slot is successfully deployed.
        :param 'WindowsFunctionAppSlotSiteConfigCorsArgs' cors: a `cors` block as detailed below.
        :param Sequence[str] default_documents: a `default_documents` block as detailed below.
        :param bool detailed_error_logging_enabled: Is detailed error logging enabled
        :param int elastic_instance_minimum: The number of minimum instances for this Windows Function App. Only affects apps on Elastic Premium plans.
        :param str ftps_state: State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`. Defaults to `Disabled`.
        :param int health_check_eviction_time_in_min: The amount of time in minutes that a node is unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Defaults to `10`. Only valid in conjunction with `health_check_path`
        :param str health_check_path: The path to be checked for this function app health.
        :param bool http2_enabled: Specifies if the HTTP2 protocol should be enabled. Defaults to `false`.
        :param Sequence['WindowsFunctionAppSlotSiteConfigIpRestrictionArgs'] ip_restrictions: an `ip_restriction` block as detailed below.
        :param str load_balancing_mode: The Site load balancing mode. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        :param str managed_pipeline_mode: The Managed Pipeline mode. Possible values include: `Integrated`, `Classic`. Defaults to `Integrated`.
        :param str minimum_tls_version: The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        :param int pre_warmed_instance_count: The number of pre-warmed instances for this function app. Only affects apps on an Elastic Premium plan.
        :param bool remote_debugging_enabled: Should Remote Debugging be enabled. Defaults to `false`.
        :param str remote_debugging_version: The Remote Debugging Version. Possible values include `VS2017`, `VS2019`, and `VS2022`
        :param bool runtime_scale_monitoring_enabled: Should Scale Monitoring of the Functions Runtime be enabled?
               
               > **NOTE:** Functions runtime scale monitoring can only be enabled for Elastic Premium Function Apps or Workflow Standard Logic Apps and requires a minimum prewarmed instance count of 1.
        :param Sequence['WindowsFunctionAppSlotSiteConfigScmIpRestrictionArgs'] scm_ip_restrictions: a `scm_ip_restriction` block as detailed below.
        :param str scm_minimum_tls_version: Configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        :param str scm_type: The SCM Type in use by the Windows Function App.
        :param bool scm_use_main_ip_restriction: Should the Windows Function App `ip_restriction` configuration be used for the SCM also.
        :param bool use32_bit_worker: Should the Windows Web App use a 32-bit worker. Defaults to `true`.
        :param bool vnet_route_all_enabled: Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        :param bool websockets_enabled: Should Web Sockets be enabled. Defaults to `false`.
        :param str windows_fx_version: The Windows FX Version string.
        :param int worker_count: The number of Workers for this Windows Function App.
        """
        if always_on is not None:
            pulumi.set(__self__, "always_on", always_on)
        if api_definition_url is not None:
            pulumi.set(__self__, "api_definition_url", api_definition_url)
        if api_management_api_id is not None:
            pulumi.set(__self__, "api_management_api_id", api_management_api_id)
        if app_command_line is not None:
            pulumi.set(__self__, "app_command_line", app_command_line)
        if app_scale_limit is not None:
            pulumi.set(__self__, "app_scale_limit", app_scale_limit)
        if app_service_logs is not None:
            pulumi.set(__self__, "app_service_logs", app_service_logs)
        if application_insights_connection_string is not None:
            pulumi.set(__self__, "application_insights_connection_string", application_insights_connection_string)
        if application_insights_key is not None:
            pulumi.set(__self__, "application_insights_key", application_insights_key)
        if application_stack is not None:
            pulumi.set(__self__, "application_stack", application_stack)
        if auto_swap_slot_name is not None:
            pulumi.set(__self__, "auto_swap_slot_name", auto_swap_slot_name)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if default_documents is not None:
            pulumi.set(__self__, "default_documents", default_documents)
        if detailed_error_logging_enabled is not None:
            pulumi.set(__self__, "detailed_error_logging_enabled", detailed_error_logging_enabled)
        if elastic_instance_minimum is not None:
            pulumi.set(__self__, "elastic_instance_minimum", elastic_instance_minimum)
        if ftps_state is not None:
            pulumi.set(__self__, "ftps_state", ftps_state)
        if health_check_eviction_time_in_min is not None:
            pulumi.set(__self__, "health_check_eviction_time_in_min", health_check_eviction_time_in_min)
        if health_check_path is not None:
            pulumi.set(__self__, "health_check_path", health_check_path)
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if ip_restrictions is not None:
            pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        if load_balancing_mode is not None:
            pulumi.set(__self__, "load_balancing_mode", load_balancing_mode)
        if managed_pipeline_mode is not None:
            pulumi.set(__self__, "managed_pipeline_mode", managed_pipeline_mode)
        if minimum_tls_version is not None:
            pulumi.set(__self__, "minimum_tls_version", minimum_tls_version)
        if pre_warmed_instance_count is not None:
            pulumi.set(__self__, "pre_warmed_instance_count", pre_warmed_instance_count)
        if remote_debugging_enabled is not None:
            pulumi.set(__self__, "remote_debugging_enabled", remote_debugging_enabled)
        if remote_debugging_version is not None:
            pulumi.set(__self__, "remote_debugging_version", remote_debugging_version)
        if runtime_scale_monitoring_enabled is not None:
            pulumi.set(__self__, "runtime_scale_monitoring_enabled", runtime_scale_monitoring_enabled)
        if scm_ip_restrictions is not None:
            pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        if scm_minimum_tls_version is not None:
            pulumi.set(__self__, "scm_minimum_tls_version", scm_minimum_tls_version)
        if scm_type is not None:
            pulumi.set(__self__, "scm_type", scm_type)
        if scm_use_main_ip_restriction is not None:
            pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        if use32_bit_worker is not None:
            pulumi.set(__self__, "use32_bit_worker", use32_bit_worker)
        if vnet_route_all_enabled is not None:
            pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        if websockets_enabled is not None:
            pulumi.set(__self__, "websockets_enabled", websockets_enabled)
        if windows_fx_version is not None:
            pulumi.set(__self__, "windows_fx_version", windows_fx_version)
        if worker_count is not None:
            pulumi.set(__self__, "worker_count", worker_count)

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> Optional[bool]:
        """
        If this Windows Web App is Always On enabled. Defaults to `false`.
        """
        return pulumi.get(self, "always_on")

    @property
    @pulumi.getter(name="apiDefinitionUrl")
    def api_definition_url(self) -> Optional[str]:
        """
        The URL of the API definition that describes this Windows Function App.
        """
        return pulumi.get(self, "api_definition_url")

    @property
    @pulumi.getter(name="apiManagementApiId")
    def api_management_api_id(self) -> Optional[str]:
        """
        The ID of the API Management API for this Windows Function App.
        """
        return pulumi.get(self, "api_management_api_id")

    @property
    @pulumi.getter(name="appCommandLine")
    def app_command_line(self) -> Optional[str]:
        """
        The program and any arguments used to launch this app via the command line. (Example `node myapp.js`).
        """
        return pulumi.get(self, "app_command_line")

    @property
    @pulumi.getter(name="appScaleLimit")
    def app_scale_limit(self) -> Optional[int]:
        """
        The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
        """
        return pulumi.get(self, "app_scale_limit")

    @property
    @pulumi.getter(name="appServiceLogs")
    def app_service_logs(self) -> Optional['outputs.WindowsFunctionAppSlotSiteConfigAppServiceLogs']:
        """
        an `app_service_logs` block as detailed below.
        """
        return pulumi.get(self, "app_service_logs")

    @property
    @pulumi.getter(name="applicationInsightsConnectionString")
    def application_insights_connection_string(self) -> Optional[str]:
        """
        The Connection String for linking the Windows Function App to Application Insights.
        """
        return pulumi.get(self, "application_insights_connection_string")

    @property
    @pulumi.getter(name="applicationInsightsKey")
    def application_insights_key(self) -> Optional[str]:
        """
        The Instrumentation Key for connecting the Windows Function App to Application Insights.
        """
        return pulumi.get(self, "application_insights_key")

    @property
    @pulumi.getter(name="applicationStack")
    def application_stack(self) -> Optional['outputs.WindowsFunctionAppSlotSiteConfigApplicationStack']:
        """
        an `application_stack` block as detailed below.
        """
        return pulumi.get(self, "application_stack")

    @property
    @pulumi.getter(name="autoSwapSlotName")
    def auto_swap_slot_name(self) -> Optional[str]:
        """
        The name of the slot to automatically swap with when this slot is successfully deployed.
        """
        return pulumi.get(self, "auto_swap_slot_name")

    @property
    @pulumi.getter
    def cors(self) -> Optional['outputs.WindowsFunctionAppSlotSiteConfigCors']:
        """
        a `cors` block as detailed below.
        """
        return pulumi.get(self, "cors")

    @property
    @pulumi.getter(name="defaultDocuments")
    def default_documents(self) -> Optional[Sequence[str]]:
        """
        a `default_documents` block as detailed below.
        """
        return pulumi.get(self, "default_documents")

    @property
    @pulumi.getter(name="detailedErrorLoggingEnabled")
    def detailed_error_logging_enabled(self) -> Optional[bool]:
        """
        Is detailed error logging enabled
        """
        return pulumi.get(self, "detailed_error_logging_enabled")

    @property
    @pulumi.getter(name="elasticInstanceMinimum")
    def elastic_instance_minimum(self) -> Optional[int]:
        """
        The number of minimum instances for this Windows Function App. Only affects apps on Elastic Premium plans.
        """
        return pulumi.get(self, "elastic_instance_minimum")

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> Optional[str]:
        """
        State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`. Defaults to `Disabled`.
        """
        return pulumi.get(self, "ftps_state")

    @property
    @pulumi.getter(name="healthCheckEvictionTimeInMin")
    def health_check_eviction_time_in_min(self) -> Optional[int]:
        """
        The amount of time in minutes that a node is unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Defaults to `10`. Only valid in conjunction with `health_check_path`
        """
        return pulumi.get(self, "health_check_eviction_time_in_min")

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> Optional[str]:
        """
        The path to be checked for this function app health.
        """
        return pulumi.get(self, "health_check_path")

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[bool]:
        """
        Specifies if the HTTP2 protocol should be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "http2_enabled")

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Optional[Sequence['outputs.WindowsFunctionAppSlotSiteConfigIpRestriction']]:
        """
        an `ip_restriction` block as detailed below.
        """
        return pulumi.get(self, "ip_restrictions")

    @property
    @pulumi.getter(name="loadBalancingMode")
    def load_balancing_mode(self) -> Optional[str]:
        """
        The Site load balancing mode. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        """
        return pulumi.get(self, "load_balancing_mode")

    @property
    @pulumi.getter(name="managedPipelineMode")
    def managed_pipeline_mode(self) -> Optional[str]:
        """
        The Managed Pipeline mode. Possible values include: `Integrated`, `Classic`. Defaults to `Integrated`.
        """
        return pulumi.get(self, "managed_pipeline_mode")

    @property
    @pulumi.getter(name="minimumTlsVersion")
    def minimum_tls_version(self) -> Optional[str]:
        """
        The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        """
        return pulumi.get(self, "minimum_tls_version")

    @property
    @pulumi.getter(name="preWarmedInstanceCount")
    def pre_warmed_instance_count(self) -> Optional[int]:
        """
        The number of pre-warmed instances for this function app. Only affects apps on an Elastic Premium plan.
        """
        return pulumi.get(self, "pre_warmed_instance_count")

    @property
    @pulumi.getter(name="remoteDebuggingEnabled")
    def remote_debugging_enabled(self) -> Optional[bool]:
        """
        Should Remote Debugging be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "remote_debugging_enabled")

    @property
    @pulumi.getter(name="remoteDebuggingVersion")
    def remote_debugging_version(self) -> Optional[str]:
        """
        The Remote Debugging Version. Possible values include `VS2017`, `VS2019`, and `VS2022`
        """
        return pulumi.get(self, "remote_debugging_version")

    @property
    @pulumi.getter(name="runtimeScaleMonitoringEnabled")
    def runtime_scale_monitoring_enabled(self) -> Optional[bool]:
        """
        Should Scale Monitoring of the Functions Runtime be enabled?

        > **NOTE:** Functions runtime scale monitoring can only be enabled for Elastic Premium Function Apps or Workflow Standard Logic Apps and requires a minimum prewarmed instance count of 1.
        """
        return pulumi.get(self, "runtime_scale_monitoring_enabled")

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Optional[Sequence['outputs.WindowsFunctionAppSlotSiteConfigScmIpRestriction']]:
        """
        a `scm_ip_restriction` block as detailed below.
        """
        return pulumi.get(self, "scm_ip_restrictions")

    @property
    @pulumi.getter(name="scmMinimumTlsVersion")
    def scm_minimum_tls_version(self) -> Optional[str]:
        """
        Configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        """
        return pulumi.get(self, "scm_minimum_tls_version")

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> Optional[str]:
        """
        The SCM Type in use by the Windows Function App.
        """
        return pulumi.get(self, "scm_type")

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> Optional[bool]:
        """
        Should the Windows Function App `ip_restriction` configuration be used for the SCM also.
        """
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @property
    @pulumi.getter(name="use32BitWorker")
    def use32_bit_worker(self) -> Optional[bool]:
        """
        Should the Windows Web App use a 32-bit worker. Defaults to `true`.
        """
        return pulumi.get(self, "use32_bit_worker")

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> Optional[bool]:
        """
        Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        """
        return pulumi.get(self, "vnet_route_all_enabled")

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> Optional[bool]:
        """
        Should Web Sockets be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "websockets_enabled")

    @property
    @pulumi.getter(name="windowsFxVersion")
    def windows_fx_version(self) -> Optional[str]:
        """
        The Windows FX Version string.
        """
        return pulumi.get(self, "windows_fx_version")

    @property
    @pulumi.getter(name="workerCount")
    def worker_count(self) -> Optional[int]:
        """
        The number of Workers for this Windows Function App.
        """
        return pulumi.get(self, "worker_count")


@pulumi.output_type
class WindowsFunctionAppSlotSiteConfigAppServiceLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskQuotaMb":
            suggest = "disk_quota_mb"
        elif key == "retentionPeriodDays":
            suggest = "retention_period_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotSiteConfigAppServiceLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotSiteConfigAppServiceLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotSiteConfigAppServiceLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_quota_mb: Optional[int] = None,
                 retention_period_days: Optional[int] = None):
        """
        :param int disk_quota_mb: The amount of disk space to use for logs. Valid values are between `25` and `100`. Defaults to `35`.
        :param int retention_period_days: The retention period for logs in days. Valid values are between `0` and `99999`.(never delete).
               
               > **NOTE:** This block is not supported on Consumption plans.
        """
        if disk_quota_mb is not None:
            pulumi.set(__self__, "disk_quota_mb", disk_quota_mb)
        if retention_period_days is not None:
            pulumi.set(__self__, "retention_period_days", retention_period_days)

    @property
    @pulumi.getter(name="diskQuotaMb")
    def disk_quota_mb(self) -> Optional[int]:
        """
        The amount of disk space to use for logs. Valid values are between `25` and `100`. Defaults to `35`.
        """
        return pulumi.get(self, "disk_quota_mb")

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> Optional[int]:
        """
        The retention period for logs in days. Valid values are between `0` and `99999`.(never delete).

        > **NOTE:** This block is not supported on Consumption plans.
        """
        return pulumi.get(self, "retention_period_days")


@pulumi.output_type
class WindowsFunctionAppSlotSiteConfigApplicationStack(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dotnetVersion":
            suggest = "dotnet_version"
        elif key == "javaVersion":
            suggest = "java_version"
        elif key == "nodeVersion":
            suggest = "node_version"
        elif key == "powershellCoreVersion":
            suggest = "powershell_core_version"
        elif key == "useCustomRuntime":
            suggest = "use_custom_runtime"
        elif key == "useDotnetIsolatedRuntime":
            suggest = "use_dotnet_isolated_runtime"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotSiteConfigApplicationStack. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotSiteConfigApplicationStack.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotSiteConfigApplicationStack.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dotnet_version: Optional[str] = None,
                 java_version: Optional[str] = None,
                 node_version: Optional[str] = None,
                 powershell_core_version: Optional[str] = None,
                 use_custom_runtime: Optional[bool] = None,
                 use_dotnet_isolated_runtime: Optional[bool] = None):
        """
        :param str dotnet_version: The version of .Net. Possible values are `v3.0`, `v4.0`, `v6.0` and `v7.0`. Defaults to `v4.0`.
        :param str java_version: The version of Java to use. Possible values are `1.8`, `11` and `17` (In-Preview).
        :param str node_version: The version of Node to use. Possible values are `~12`, `~14`, `~16` and `~18`.
        :param str powershell_core_version: The PowerShell Core version to use. Possible values are `7`, and `7.2`.
        :param bool use_custom_runtime: Does the Function App use a custom Application Stack?
        :param bool use_dotnet_isolated_runtime: Should the DotNet process use an isolated runtime. Defaults to `false`.
        """
        if dotnet_version is not None:
            pulumi.set(__self__, "dotnet_version", dotnet_version)
        if java_version is not None:
            pulumi.set(__self__, "java_version", java_version)
        if node_version is not None:
            pulumi.set(__self__, "node_version", node_version)
        if powershell_core_version is not None:
            pulumi.set(__self__, "powershell_core_version", powershell_core_version)
        if use_custom_runtime is not None:
            pulumi.set(__self__, "use_custom_runtime", use_custom_runtime)
        if use_dotnet_isolated_runtime is not None:
            pulumi.set(__self__, "use_dotnet_isolated_runtime", use_dotnet_isolated_runtime)

    @property
    @pulumi.getter(name="dotnetVersion")
    def dotnet_version(self) -> Optional[str]:
        """
        The version of .Net. Possible values are `v3.0`, `v4.0`, `v6.0` and `v7.0`. Defaults to `v4.0`.
        """
        return pulumi.get(self, "dotnet_version")

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> Optional[str]:
        """
        The version of Java to use. Possible values are `1.8`, `11` and `17` (In-Preview).
        """
        return pulumi.get(self, "java_version")

    @property
    @pulumi.getter(name="nodeVersion")
    def node_version(self) -> Optional[str]:
        """
        The version of Node to use. Possible values are `~12`, `~14`, `~16` and `~18`.
        """
        return pulumi.get(self, "node_version")

    @property
    @pulumi.getter(name="powershellCoreVersion")
    def powershell_core_version(self) -> Optional[str]:
        """
        The PowerShell Core version to use. Possible values are `7`, and `7.2`.
        """
        return pulumi.get(self, "powershell_core_version")

    @property
    @pulumi.getter(name="useCustomRuntime")
    def use_custom_runtime(self) -> Optional[bool]:
        """
        Does the Function App use a custom Application Stack?
        """
        return pulumi.get(self, "use_custom_runtime")

    @property
    @pulumi.getter(name="useDotnetIsolatedRuntime")
    def use_dotnet_isolated_runtime(self) -> Optional[bool]:
        """
        Should the DotNet process use an isolated runtime. Defaults to `false`.
        """
        return pulumi.get(self, "use_dotnet_isolated_runtime")


@pulumi.output_type
class WindowsFunctionAppSlotSiteConfigCors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedOrigins":
            suggest = "allowed_origins"
        elif key == "supportCredentials":
            suggest = "support_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotSiteConfigCors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotSiteConfigCors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotSiteConfigCors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_origins: Optional[Sequence[str]] = None,
                 support_credentials: Optional[bool] = None):
        """
        :param Sequence[str] allowed_origins: an `allowed_origins` block as detailed below.
        :param bool support_credentials: Are credentials allowed in CORS requests? Defaults to `false`.
        """
        if allowed_origins is not None:
            pulumi.set(__self__, "allowed_origins", allowed_origins)
        if support_credentials is not None:
            pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Optional[Sequence[str]]:
        """
        an `allowed_origins` block as detailed below.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> Optional[bool]:
        """
        Are credentials allowed in CORS requests? Defaults to `false`.
        """
        return pulumi.get(self, "support_credentials")


@pulumi.output_type
class WindowsFunctionAppSlotSiteConfigIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotSiteConfigIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotSiteConfigIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotSiteConfigIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.WindowsFunctionAppSlotSiteConfigIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: The action to take. Possible values are `Allow` or `Deny`.
        :param 'WindowsFunctionAppSlotSiteConfigIpRestrictionHeadersArgs' headers: a `headers` block as detailed below.
        :param str ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param str name: The name which should be used for this `ip_restriction`.
        :param int priority: The priority value of this `ip_restriction`. Defaults to `65000`.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
               
               > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        The action to take. Possible values are `Allow` or `Deny`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.WindowsFunctionAppSlotSiteConfigIpRestrictionHeaders']:
        """
        a `headers` block as detailed below.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class WindowsFunctionAppSlotSiteConfigIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotSiteConfigIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param str x_fd_health_probe: Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        :param Sequence[str] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param Sequence[str] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class WindowsFunctionAppSlotSiteConfigScmIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotSiteConfigScmIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotSiteConfigScmIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotSiteConfigScmIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.WindowsFunctionAppSlotSiteConfigScmIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: The action to take. Possible values are `Allow` or `Deny`.
        :param 'WindowsFunctionAppSlotSiteConfigScmIpRestrictionHeadersArgs' headers: a `headers` block as detailed below.
        :param str ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param str name: The name which should be used for this `ip_restriction`.
        :param int priority: The priority value of this `ip_restriction`. Defaults to `65000`.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.ENDEXPERIMENT
               
               > **NOTE:** Exactly one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        The action to take. Possible values are `Allow` or `Deny`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.WindowsFunctionAppSlotSiteConfigScmIpRestrictionHeaders']:
        """
        a `headers` block as detailed below.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.ENDEXPERIMENT

        > **NOTE:** Exactly one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class WindowsFunctionAppSlotSiteConfigScmIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotSiteConfigScmIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param str x_fd_health_probe: Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        :param Sequence[str] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param Sequence[str] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class WindowsFunctionAppSlotSiteCredential(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 password: Optional[str] = None):
        """
        :param str name: The Site Credentials Username used for publishing.
        :param str password: The Site Credentials Password used for publishing.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The Site Credentials Username used for publishing.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The Site Credentials Password used for publishing.
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class WindowsFunctionAppSlotStorageAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "accountName":
            suggest = "account_name"
        elif key == "shareName":
            suggest = "share_name"
        elif key == "mountPath":
            suggest = "mount_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotStorageAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotStorageAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotStorageAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: str,
                 account_name: str,
                 name: str,
                 share_name: str,
                 type: str,
                 mount_path: Optional[str] = None):
        """
        :param str access_key: The Access key for the storage account.
        :param str account_name: The Name of the Storage Account.
        :param str name: The name which should be used for this Storage Account.
        :param str share_name: The Name of the File Share or Container Name for Blob storage.
        :param str type: The Azure Storage Type. Possible values include `AzureFiles`.
        :param str mount_path: The path at which to mount the storage share.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "share_name", share_name)
        pulumi.set(__self__, "type", type)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> str:
        """
        The Access key for the storage account.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> str:
        """
        The Name of the Storage Account.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Storage Account.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> str:
        """
        The Name of the File Share or Container Name for Blob storage.
        """
        return pulumi.get(self, "share_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The Azure Storage Type. Possible values include `AzureFiles`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[str]:
        """
        The path at which to mount the storage share.
        """
        return pulumi.get(self, "mount_path")


@pulumi.output_type
class WindowsFunctionAppStickySettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appSettingNames":
            suggest = "app_setting_names"
        elif key == "connectionStringNames":
            suggest = "connection_string_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppStickySettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppStickySettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppStickySettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_setting_names: Optional[Sequence[str]] = None,
                 connection_string_names: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] app_setting_names: A list of `app_setting` names that the Windows Function App will not swap between Slots when a swap operation is triggered.
        :param Sequence[str] connection_string_names: A list of `connection_string` names that the Windows Function App will not swap between Slots when a swap operation is triggered.
        """
        if app_setting_names is not None:
            pulumi.set(__self__, "app_setting_names", app_setting_names)
        if connection_string_names is not None:
            pulumi.set(__self__, "connection_string_names", connection_string_names)

    @property
    @pulumi.getter(name="appSettingNames")
    def app_setting_names(self) -> Optional[Sequence[str]]:
        """
        A list of `app_setting` names that the Windows Function App will not swap between Slots when a swap operation is triggered.
        """
        return pulumi.get(self, "app_setting_names")

    @property
    @pulumi.getter(name="connectionStringNames")
    def connection_string_names(self) -> Optional[Sequence[str]]:
        """
        A list of `connection_string` names that the Windows Function App will not swap between Slots when a swap operation is triggered.
        """
        return pulumi.get(self, "connection_string_names")


@pulumi.output_type
class WindowsFunctionAppStorageAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "accountName":
            suggest = "account_name"
        elif key == "shareName":
            suggest = "share_name"
        elif key == "mountPath":
            suggest = "mount_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppStorageAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppStorageAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppStorageAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: str,
                 account_name: str,
                 name: str,
                 share_name: str,
                 type: str,
                 mount_path: Optional[str] = None):
        """
        :param str access_key: The Access key for the storage account.
        :param str account_name: The Name of the Storage Account.
        :param str name: The name which should be used for this Storage Account.
        :param str share_name: The Name of the File Share or Container Name for Blob storage.
        :param str type: The Azure Storage Type. Possible values include `AzureFiles`.
        :param str mount_path: The path at which to mount the storage share.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "share_name", share_name)
        pulumi.set(__self__, "type", type)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> str:
        """
        The Access key for the storage account.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> str:
        """
        The Name of the Storage Account.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Storage Account.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> str:
        """
        The Name of the File Share or Container Name for Blob storage.
        """
        return pulumi.get(self, "share_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The Azure Storage Type. Possible values include `AzureFiles`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[str]:
        """
        The path at which to mount the storage share.
        """
        return pulumi.get(self, "mount_path")


@pulumi.output_type
class WindowsWebAppAuthSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeDirectory":
            suggest = "active_directory"
        elif key == "additionalLoginParameters":
            suggest = "additional_login_parameters"
        elif key == "allowedExternalRedirectUrls":
            suggest = "allowed_external_redirect_urls"
        elif key == "defaultProvider":
            suggest = "default_provider"
        elif key == "runtimeVersion":
            suggest = "runtime_version"
        elif key == "tokenRefreshExtensionHours":
            suggest = "token_refresh_extension_hours"
        elif key == "tokenStoreEnabled":
            suggest = "token_store_enabled"
        elif key == "unauthenticatedClientAction":
            suggest = "unauthenticated_client_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppAuthSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppAuthSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppAuthSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 active_directory: Optional['outputs.WindowsWebAppAuthSettingsActiveDirectory'] = None,
                 additional_login_parameters: Optional[Mapping[str, str]] = None,
                 allowed_external_redirect_urls: Optional[Sequence[str]] = None,
                 default_provider: Optional[str] = None,
                 facebook: Optional['outputs.WindowsWebAppAuthSettingsFacebook'] = None,
                 github: Optional['outputs.WindowsWebAppAuthSettingsGithub'] = None,
                 google: Optional['outputs.WindowsWebAppAuthSettingsGoogle'] = None,
                 issuer: Optional[str] = None,
                 microsoft: Optional['outputs.WindowsWebAppAuthSettingsMicrosoft'] = None,
                 runtime_version: Optional[str] = None,
                 token_refresh_extension_hours: Optional[float] = None,
                 token_store_enabled: Optional[bool] = None,
                 twitter: Optional['outputs.WindowsWebAppAuthSettingsTwitter'] = None,
                 unauthenticated_client_action: Optional[str] = None):
        """
        :param bool enabled: Should the Authentication / Authorization feature is enabled for the Windows Web App be enabled?
        :param 'WindowsWebAppAuthSettingsActiveDirectoryArgs' active_directory: An `active_directory` block as defined above.
        :param Mapping[str, str] additional_login_parameters: Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        :param Sequence[str] allowed_external_redirect_urls: Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Windows Web App.
        :param str default_provider: The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.
               
               > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        :param 'WindowsWebAppAuthSettingsFacebookArgs' facebook: A `facebook` block as defined below.
        :param 'WindowsWebAppAuthSettingsGithubArgs' github: A `github` block as defined below.
        :param 'WindowsWebAppAuthSettingsGoogleArgs' google: A `google` block as defined below.
        :param str issuer: The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Windows Web App.
               
               > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        :param 'WindowsWebAppAuthSettingsMicrosoftArgs' microsoft: A `microsoft` block as defined below.
        :param str runtime_version: The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        :param float token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        :param bool token_store_enabled: Should the Windows Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        :param 'WindowsWebAppAuthSettingsTwitterArgs' twitter: A `twitter` block as defined below.
        :param str unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if active_directory is not None:
            pulumi.set(__self__, "active_directory", active_directory)
        if additional_login_parameters is not None:
            pulumi.set(__self__, "additional_login_parameters", additional_login_parameters)
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if facebook is not None:
            pulumi.set(__self__, "facebook", facebook)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if google is not None:
            pulumi.set(__self__, "google", google)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if microsoft is not None:
            pulumi.set(__self__, "microsoft", microsoft)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if token_refresh_extension_hours is not None:
            pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if twitter is not None:
            pulumi.set(__self__, "twitter", twitter)
        if unauthenticated_client_action is not None:
            pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Should the Authentication / Authorization feature is enabled for the Windows Web App be enabled?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="activeDirectory")
    def active_directory(self) -> Optional['outputs.WindowsWebAppAuthSettingsActiveDirectory']:
        """
        An `active_directory` block as defined above.
        """
        return pulumi.get(self, "active_directory")

    @property
    @pulumi.getter(name="additionalLoginParameters")
    def additional_login_parameters(self) -> Optional[Mapping[str, str]]:
        """
        Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        """
        return pulumi.get(self, "additional_login_parameters")

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Windows Web App.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[str]:
        """
        The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.

        > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        """
        return pulumi.get(self, "default_provider")

    @property
    @pulumi.getter
    def facebook(self) -> Optional['outputs.WindowsWebAppAuthSettingsFacebook']:
        """
        A `facebook` block as defined below.
        """
        return pulumi.get(self, "facebook")

    @property
    @pulumi.getter
    def github(self) -> Optional['outputs.WindowsWebAppAuthSettingsGithub']:
        """
        A `github` block as defined below.
        """
        return pulumi.get(self, "github")

    @property
    @pulumi.getter
    def google(self) -> Optional['outputs.WindowsWebAppAuthSettingsGoogle']:
        """
        A `google` block as defined below.
        """
        return pulumi.get(self, "google")

    @property
    @pulumi.getter
    def issuer(self) -> Optional[str]:
        """
        The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Windows Web App.

        > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def microsoft(self) -> Optional['outputs.WindowsWebAppAuthSettingsMicrosoft']:
        """
        A `microsoft` block as defined below.
        """
        return pulumi.get(self, "microsoft")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[str]:
        """
        The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> Optional[float]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        return pulumi.get(self, "token_refresh_extension_hours")

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[bool]:
        """
        Should the Windows Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        """
        return pulumi.get(self, "token_store_enabled")

    @property
    @pulumi.getter
    def twitter(self) -> Optional['outputs.WindowsWebAppAuthSettingsTwitter']:
        """
        A `twitter` block as defined below.
        """
        return pulumi.get(self, "twitter")

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> Optional[str]:
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        return pulumi.get(self, "unauthenticated_client_action")


@pulumi.output_type
class WindowsWebAppAuthSettingsActiveDirectory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppAuthSettingsActiveDirectory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppAuthSettingsActiveDirectory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppAuthSettingsActiveDirectory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param Sequence[str] allowed_audiences: Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
               
               > **Note:** The `client_id` value is always considered an allowed audience.
        :param str client_secret: The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        pulumi.set(__self__, "client_id", client_id)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **Note:** The `client_id` value is always considered an allowed audience.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")


@pulumi.output_type
class WindowsWebAppAuthSettingsFacebook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "appSecret":
            suggest = "app_secret"
        elif key == "appSecretSettingName":
            suggest = "app_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppAuthSettingsFacebook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppAuthSettingsFacebook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppAuthSettingsFacebook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: str,
                 app_secret: Optional[str] = None,
                 app_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str app_id: The App ID of the Facebook app used for login.
        :param str app_secret: The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        :param str app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        if app_secret is not None:
            pulumi.set(__self__, "app_secret", app_secret)
        if app_secret_setting_name is not None:
            pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appSecret")
    def app_secret(self) -> Optional[str]:
        """
        The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        """
        return pulumi.get(self, "app_secret")

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class WindowsWebAppAuthSettingsGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppAuthSettingsGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppAuthSettingsGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppAuthSettingsGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the GitHub app used for login.
        :param str client_secret: The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the GitHub app used for login.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class WindowsWebAppAuthSettingsGoogle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppAuthSettingsGoogle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppAuthSettingsGoogle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppAuthSettingsGoogle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OpenID Connect Client ID for the Google web application.
        :param str client_secret: The client secret associated with the Google web application. Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OpenID Connect Client ID for the Google web application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The client secret associated with the Google web application. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class WindowsWebAppAuthSettingsMicrosoft(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppAuthSettingsMicrosoft. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppAuthSettingsMicrosoft.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppAuthSettingsMicrosoft.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret: The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, "wl.basic" is used as the default scope.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, "wl.basic" is used as the default scope.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class WindowsWebAppAuthSettingsTwitter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerKey":
            suggest = "consumer_key"
        elif key == "consumerSecret":
            suggest = "consumer_secret"
        elif key == "consumerSecretSettingName":
            suggest = "consumer_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppAuthSettingsTwitter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppAuthSettingsTwitter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppAuthSettingsTwitter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_key: str,
                 consumer_secret: Optional[str] = None,
                 consumer_secret_setting_name: Optional[str] = None):
        """
        :param str consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param str consumer_secret: The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        :param str consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        if consumer_secret is not None:
            pulumi.set(__self__, "consumer_secret", consumer_secret)
        if consumer_secret_setting_name is not None:
            pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> str:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> Optional[str]:
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        """
        return pulumi.get(self, "consumer_secret")

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        return pulumi.get(self, "consumer_secret_setting_name")


@pulumi.output_type
class WindowsWebAppAuthSettingsV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeDirectoryV2":
            suggest = "active_directory_v2"
        elif key == "appleV2":
            suggest = "apple_v2"
        elif key == "authEnabled":
            suggest = "auth_enabled"
        elif key == "azureStaticWebAppV2":
            suggest = "azure_static_web_app_v2"
        elif key == "configFilePath":
            suggest = "config_file_path"
        elif key == "customOidcV2s":
            suggest = "custom_oidc_v2s"
        elif key == "defaultProvider":
            suggest = "default_provider"
        elif key == "excludedPaths":
            suggest = "excluded_paths"
        elif key == "facebookV2":
            suggest = "facebook_v2"
        elif key == "forwardProxyConvention":
            suggest = "forward_proxy_convention"
        elif key == "forwardProxyCustomHostHeaderName":
            suggest = "forward_proxy_custom_host_header_name"
        elif key == "forwardProxyCustomSchemeHeaderName":
            suggest = "forward_proxy_custom_scheme_header_name"
        elif key == "githubV2":
            suggest = "github_v2"
        elif key == "googleV2":
            suggest = "google_v2"
        elif key == "httpRouteApiPrefix":
            suggest = "http_route_api_prefix"
        elif key == "microsoftV2":
            suggest = "microsoft_v2"
        elif key == "requireAuthentication":
            suggest = "require_authentication"
        elif key == "requireHttps":
            suggest = "require_https"
        elif key == "runtimeVersion":
            suggest = "runtime_version"
        elif key == "twitterV2":
            suggest = "twitter_v2"
        elif key == "unauthenticatedAction":
            suggest = "unauthenticated_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppAuthSettingsV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppAuthSettingsV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppAuthSettingsV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 login: 'outputs.WindowsWebAppAuthSettingsV2Login',
                 active_directory_v2: Optional['outputs.WindowsWebAppAuthSettingsV2ActiveDirectoryV2'] = None,
                 apple_v2: Optional['outputs.WindowsWebAppAuthSettingsV2AppleV2'] = None,
                 auth_enabled: Optional[bool] = None,
                 azure_static_web_app_v2: Optional['outputs.WindowsWebAppAuthSettingsV2AzureStaticWebAppV2'] = None,
                 config_file_path: Optional[str] = None,
                 custom_oidc_v2s: Optional[Sequence['outputs.WindowsWebAppAuthSettingsV2CustomOidcV2']] = None,
                 default_provider: Optional[str] = None,
                 excluded_paths: Optional[Sequence[str]] = None,
                 facebook_v2: Optional['outputs.WindowsWebAppAuthSettingsV2FacebookV2'] = None,
                 forward_proxy_convention: Optional[str] = None,
                 forward_proxy_custom_host_header_name: Optional[str] = None,
                 forward_proxy_custom_scheme_header_name: Optional[str] = None,
                 github_v2: Optional['outputs.WindowsWebAppAuthSettingsV2GithubV2'] = None,
                 google_v2: Optional['outputs.WindowsWebAppAuthSettingsV2GoogleV2'] = None,
                 http_route_api_prefix: Optional[str] = None,
                 microsoft_v2: Optional['outputs.WindowsWebAppAuthSettingsV2MicrosoftV2'] = None,
                 require_authentication: Optional[bool] = None,
                 require_https: Optional[bool] = None,
                 runtime_version: Optional[str] = None,
                 twitter_v2: Optional['outputs.WindowsWebAppAuthSettingsV2TwitterV2'] = None,
                 unauthenticated_action: Optional[str] = None):
        """
        :param 'WindowsWebAppAuthSettingsV2LoginArgs' login: A `login` block as defined below.
        :param 'WindowsWebAppAuthSettingsV2ActiveDirectoryV2Args' active_directory_v2: An `active_directory_v2` block as defined below.
        :param 'WindowsWebAppAuthSettingsV2AppleV2Args' apple_v2: An `apple_v2` block as defined below.
        :param bool auth_enabled: Should the AuthV2 Settings be enabled. Defaults to `false`.
        :param 'WindowsWebAppAuthSettingsV2AzureStaticWebAppV2Args' azure_static_web_app_v2: An `azure_static_web_app_v2` block as defined below.
        :param str config_file_path: The path to the App Auth settings.
               
               * > **Note:** Relative Paths are evaluated from the Site Root directory.
        :param Sequence['WindowsWebAppAuthSettingsV2CustomOidcV2Args'] custom_oidc_v2s: Zero or more `custom_oidc_v2` blocks as defined below.
        :param str default_provider: The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.
               
               > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        :param Sequence[str] excluded_paths: The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.
               
               > **NOTE:** This list should be used instead of setting `WEBSITE_WARMUP_PATH` in `app_settings` as it takes priority.
        :param 'WindowsWebAppAuthSettingsV2FacebookV2Args' facebook_v2: A `facebook_v2` block as defined below.
        :param str forward_proxy_convention: The convention used to determine the url of the request made. Possible values include `NoProxy`, `Standard`, `Custom`. Defaults to `NoProxy`.
        :param str forward_proxy_custom_host_header_name: The name of the custom header containing the host of the request.
        :param str forward_proxy_custom_scheme_header_name: The name of the custom header containing the scheme of the request.
        :param 'WindowsWebAppAuthSettingsV2GithubV2Args' github_v2: A `github_v2` block as defined below.
        :param 'WindowsWebAppAuthSettingsV2GoogleV2Args' google_v2: A `google_v2` block as defined below.
        :param str http_route_api_prefix: The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
        :param 'WindowsWebAppAuthSettingsV2MicrosoftV2Args' microsoft_v2: A `microsoft_v2` block as defined below.
        :param bool require_authentication: Should the authentication flow be used for all requests.
        :param bool require_https: Should HTTPS be required on connections? Defaults to `true`.
        :param str runtime_version: The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        :param 'WindowsWebAppAuthSettingsV2TwitterV2Args' twitter_v2: A `twitter_v2` block as defined below.
        :param str unauthenticated_action: The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
        """
        pulumi.set(__self__, "login", login)
        if active_directory_v2 is not None:
            pulumi.set(__self__, "active_directory_v2", active_directory_v2)
        if apple_v2 is not None:
            pulumi.set(__self__, "apple_v2", apple_v2)
        if auth_enabled is not None:
            pulumi.set(__self__, "auth_enabled", auth_enabled)
        if azure_static_web_app_v2 is not None:
            pulumi.set(__self__, "azure_static_web_app_v2", azure_static_web_app_v2)
        if config_file_path is not None:
            pulumi.set(__self__, "config_file_path", config_file_path)
        if custom_oidc_v2s is not None:
            pulumi.set(__self__, "custom_oidc_v2s", custom_oidc_v2s)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if excluded_paths is not None:
            pulumi.set(__self__, "excluded_paths", excluded_paths)
        if facebook_v2 is not None:
            pulumi.set(__self__, "facebook_v2", facebook_v2)
        if forward_proxy_convention is not None:
            pulumi.set(__self__, "forward_proxy_convention", forward_proxy_convention)
        if forward_proxy_custom_host_header_name is not None:
            pulumi.set(__self__, "forward_proxy_custom_host_header_name", forward_proxy_custom_host_header_name)
        if forward_proxy_custom_scheme_header_name is not None:
            pulumi.set(__self__, "forward_proxy_custom_scheme_header_name", forward_proxy_custom_scheme_header_name)
        if github_v2 is not None:
            pulumi.set(__self__, "github_v2", github_v2)
        if google_v2 is not None:
            pulumi.set(__self__, "google_v2", google_v2)
        if http_route_api_prefix is not None:
            pulumi.set(__self__, "http_route_api_prefix", http_route_api_prefix)
        if microsoft_v2 is not None:
            pulumi.set(__self__, "microsoft_v2", microsoft_v2)
        if require_authentication is not None:
            pulumi.set(__self__, "require_authentication", require_authentication)
        if require_https is not None:
            pulumi.set(__self__, "require_https", require_https)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if twitter_v2 is not None:
            pulumi.set(__self__, "twitter_v2", twitter_v2)
        if unauthenticated_action is not None:
            pulumi.set(__self__, "unauthenticated_action", unauthenticated_action)

    @property
    @pulumi.getter
    def login(self) -> 'outputs.WindowsWebAppAuthSettingsV2Login':
        """
        A `login` block as defined below.
        """
        return pulumi.get(self, "login")

    @property
    @pulumi.getter(name="activeDirectoryV2")
    def active_directory_v2(self) -> Optional['outputs.WindowsWebAppAuthSettingsV2ActiveDirectoryV2']:
        """
        An `active_directory_v2` block as defined below.
        """
        return pulumi.get(self, "active_directory_v2")

    @property
    @pulumi.getter(name="appleV2")
    def apple_v2(self) -> Optional['outputs.WindowsWebAppAuthSettingsV2AppleV2']:
        """
        An `apple_v2` block as defined below.
        """
        return pulumi.get(self, "apple_v2")

    @property
    @pulumi.getter(name="authEnabled")
    def auth_enabled(self) -> Optional[bool]:
        """
        Should the AuthV2 Settings be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "auth_enabled")

    @property
    @pulumi.getter(name="azureStaticWebAppV2")
    def azure_static_web_app_v2(self) -> Optional['outputs.WindowsWebAppAuthSettingsV2AzureStaticWebAppV2']:
        """
        An `azure_static_web_app_v2` block as defined below.
        """
        return pulumi.get(self, "azure_static_web_app_v2")

    @property
    @pulumi.getter(name="configFilePath")
    def config_file_path(self) -> Optional[str]:
        """
        The path to the App Auth settings.

        * > **Note:** Relative Paths are evaluated from the Site Root directory.
        """
        return pulumi.get(self, "config_file_path")

    @property
    @pulumi.getter(name="customOidcV2s")
    def custom_oidc_v2s(self) -> Optional[Sequence['outputs.WindowsWebAppAuthSettingsV2CustomOidcV2']]:
        """
        Zero or more `custom_oidc_v2` blocks as defined below.
        """
        return pulumi.get(self, "custom_oidc_v2s")

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[str]:
        """
        The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.

        > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        """
        return pulumi.get(self, "default_provider")

    @property
    @pulumi.getter(name="excludedPaths")
    def excluded_paths(self) -> Optional[Sequence[str]]:
        """
        The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.

        > **NOTE:** This list should be used instead of setting `WEBSITE_WARMUP_PATH` in `app_settings` as it takes priority.
        """
        return pulumi.get(self, "excluded_paths")

    @property
    @pulumi.getter(name="facebookV2")
    def facebook_v2(self) -> Optional['outputs.WindowsWebAppAuthSettingsV2FacebookV2']:
        """
        A `facebook_v2` block as defined below.
        """
        return pulumi.get(self, "facebook_v2")

    @property
    @pulumi.getter(name="forwardProxyConvention")
    def forward_proxy_convention(self) -> Optional[str]:
        """
        The convention used to determine the url of the request made. Possible values include `NoProxy`, `Standard`, `Custom`. Defaults to `NoProxy`.
        """
        return pulumi.get(self, "forward_proxy_convention")

    @property
    @pulumi.getter(name="forwardProxyCustomHostHeaderName")
    def forward_proxy_custom_host_header_name(self) -> Optional[str]:
        """
        The name of the custom header containing the host of the request.
        """
        return pulumi.get(self, "forward_proxy_custom_host_header_name")

    @property
    @pulumi.getter(name="forwardProxyCustomSchemeHeaderName")
    def forward_proxy_custom_scheme_header_name(self) -> Optional[str]:
        """
        The name of the custom header containing the scheme of the request.
        """
        return pulumi.get(self, "forward_proxy_custom_scheme_header_name")

    @property
    @pulumi.getter(name="githubV2")
    def github_v2(self) -> Optional['outputs.WindowsWebAppAuthSettingsV2GithubV2']:
        """
        A `github_v2` block as defined below.
        """
        return pulumi.get(self, "github_v2")

    @property
    @pulumi.getter(name="googleV2")
    def google_v2(self) -> Optional['outputs.WindowsWebAppAuthSettingsV2GoogleV2']:
        """
        A `google_v2` block as defined below.
        """
        return pulumi.get(self, "google_v2")

    @property
    @pulumi.getter(name="httpRouteApiPrefix")
    def http_route_api_prefix(self) -> Optional[str]:
        """
        The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
        """
        return pulumi.get(self, "http_route_api_prefix")

    @property
    @pulumi.getter(name="microsoftV2")
    def microsoft_v2(self) -> Optional['outputs.WindowsWebAppAuthSettingsV2MicrosoftV2']:
        """
        A `microsoft_v2` block as defined below.
        """
        return pulumi.get(self, "microsoft_v2")

    @property
    @pulumi.getter(name="requireAuthentication")
    def require_authentication(self) -> Optional[bool]:
        """
        Should the authentication flow be used for all requests.
        """
        return pulumi.get(self, "require_authentication")

    @property
    @pulumi.getter(name="requireHttps")
    def require_https(self) -> Optional[bool]:
        """
        Should HTTPS be required on connections? Defaults to `true`.
        """
        return pulumi.get(self, "require_https")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[str]:
        """
        The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter(name="twitterV2")
    def twitter_v2(self) -> Optional['outputs.WindowsWebAppAuthSettingsV2TwitterV2']:
        """
        A `twitter_v2` block as defined below.
        """
        return pulumi.get(self, "twitter_v2")

    @property
    @pulumi.getter(name="unauthenticatedAction")
    def unauthenticated_action(self) -> Optional[str]:
        """
        The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
        """
        return pulumi.get(self, "unauthenticated_action")


@pulumi.output_type
class WindowsWebAppAuthSettingsV2ActiveDirectoryV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "tenantAuthEndpoint":
            suggest = "tenant_auth_endpoint"
        elif key == "allowedApplications":
            suggest = "allowed_applications"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "allowedGroups":
            suggest = "allowed_groups"
        elif key == "allowedIdentities":
            suggest = "allowed_identities"
        elif key == "clientSecretCertificateThumbprint":
            suggest = "client_secret_certificate_thumbprint"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "jwtAllowedClientApplications":
            suggest = "jwt_allowed_client_applications"
        elif key == "jwtAllowedGroups":
            suggest = "jwt_allowed_groups"
        elif key == "loginParameters":
            suggest = "login_parameters"
        elif key == "wwwAuthenticationDisabled":
            suggest = "www_authentication_disabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppAuthSettingsV2ActiveDirectoryV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppAuthSettingsV2ActiveDirectoryV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppAuthSettingsV2ActiveDirectoryV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 tenant_auth_endpoint: str,
                 allowed_applications: Optional[Sequence[str]] = None,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 allowed_groups: Optional[Sequence[str]] = None,
                 allowed_identities: Optional[Sequence[str]] = None,
                 client_secret_certificate_thumbprint: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 jwt_allowed_client_applications: Optional[Sequence[str]] = None,
                 jwt_allowed_groups: Optional[Sequence[str]] = None,
                 login_parameters: Optional[Mapping[str, str]] = None,
                 www_authentication_disabled: Optional[bool] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str tenant_auth_endpoint: The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`
        :param Sequence[str] allowed_applications: The list of allowed Applications for the Default Authorisation Policy.
        :param Sequence[str] allowed_audiences: Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
               
               > **Note:** The `client_id` value is always considered an allowed audience.
        :param Sequence[str] allowed_groups: The list of allowed Group Names for the Default Authorisation Policy.
        :param Sequence[str] allowed_identities: The list of allowed Identities for the Default Authorisation Policy.
        :param str client_secret_certificate_thumbprint: The thumbprint of the certificate used for signing purposes.
               
               > **NOTE:** One of `client_secret_setting_name` or `client_secret_certificate_thumbprint` must be specified.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param Sequence[str] jwt_allowed_client_applications: A list of Allowed Client Applications in the JWT Claim.
        :param Sequence[str] jwt_allowed_groups: A list of Allowed Groups in the JWT Claim.
        :param Mapping[str, str] login_parameters: A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
        :param bool www_authentication_disabled: Should the www-authenticate provider should be omitted from the request? Defaults to `false`
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "tenant_auth_endpoint", tenant_auth_endpoint)
        if allowed_applications is not None:
            pulumi.set(__self__, "allowed_applications", allowed_applications)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if allowed_groups is not None:
            pulumi.set(__self__, "allowed_groups", allowed_groups)
        if allowed_identities is not None:
            pulumi.set(__self__, "allowed_identities", allowed_identities)
        if client_secret_certificate_thumbprint is not None:
            pulumi.set(__self__, "client_secret_certificate_thumbprint", client_secret_certificate_thumbprint)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if jwt_allowed_client_applications is not None:
            pulumi.set(__self__, "jwt_allowed_client_applications", jwt_allowed_client_applications)
        if jwt_allowed_groups is not None:
            pulumi.set(__self__, "jwt_allowed_groups", jwt_allowed_groups)
        if login_parameters is not None:
            pulumi.set(__self__, "login_parameters", login_parameters)
        if www_authentication_disabled is not None:
            pulumi.set(__self__, "www_authentication_disabled", www_authentication_disabled)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="tenantAuthEndpoint")
    def tenant_auth_endpoint(self) -> str:
        """
        The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`
        """
        return pulumi.get(self, "tenant_auth_endpoint")

    @property
    @pulumi.getter(name="allowedApplications")
    def allowed_applications(self) -> Optional[Sequence[str]]:
        """
        The list of allowed Applications for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_applications")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **Note:** The `client_id` value is always considered an allowed audience.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="allowedGroups")
    def allowed_groups(self) -> Optional[Sequence[str]]:
        """
        The list of allowed Group Names for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_groups")

    @property
    @pulumi.getter(name="allowedIdentities")
    def allowed_identities(self) -> Optional[Sequence[str]]:
        """
        The list of allowed Identities for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_identities")

    @property
    @pulumi.getter(name="clientSecretCertificateThumbprint")
    def client_secret_certificate_thumbprint(self) -> Optional[str]:
        """
        The thumbprint of the certificate used for signing purposes.

        > **NOTE:** One of `client_secret_setting_name` or `client_secret_certificate_thumbprint` must be specified.
        """
        return pulumi.get(self, "client_secret_certificate_thumbprint")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="jwtAllowedClientApplications")
    def jwt_allowed_client_applications(self) -> Optional[Sequence[str]]:
        """
        A list of Allowed Client Applications in the JWT Claim.
        """
        return pulumi.get(self, "jwt_allowed_client_applications")

    @property
    @pulumi.getter(name="jwtAllowedGroups")
    def jwt_allowed_groups(self) -> Optional[Sequence[str]]:
        """
        A list of Allowed Groups in the JWT Claim.
        """
        return pulumi.get(self, "jwt_allowed_groups")

    @property
    @pulumi.getter(name="loginParameters")
    def login_parameters(self) -> Optional[Mapping[str, str]]:
        """
        A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
        """
        return pulumi.get(self, "login_parameters")

    @property
    @pulumi.getter(name="wwwAuthenticationDisabled")
    def www_authentication_disabled(self) -> Optional[bool]:
        """
        Should the www-authenticate provider should be omitted from the request? Defaults to `false`
        """
        return pulumi.get(self, "www_authentication_disabled")


@pulumi.output_type
class WindowsWebAppAuthSettingsV2AppleV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "loginScopes":
            suggest = "login_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppAuthSettingsV2AppleV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppAuthSettingsV2AppleV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppAuthSettingsV2AppleV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret_setting_name: str,
                 login_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param Sequence[str] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[Sequence[str]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class WindowsWebAppAuthSettingsV2AzureStaticWebAppV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppAuthSettingsV2AzureStaticWebAppV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppAuthSettingsV2AzureStaticWebAppV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppAuthSettingsV2AzureStaticWebAppV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        """
        pulumi.set(__self__, "client_id", client_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")


@pulumi.output_type
class WindowsWebAppAuthSettingsV2CustomOidcV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "openidConfigurationEndpoint":
            suggest = "openid_configuration_endpoint"
        elif key == "authorisationEndpoint":
            suggest = "authorisation_endpoint"
        elif key == "certificationUri":
            suggest = "certification_uri"
        elif key == "clientCredentialMethod":
            suggest = "client_credential_method"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "issuerEndpoint":
            suggest = "issuer_endpoint"
        elif key == "nameClaimType":
            suggest = "name_claim_type"
        elif key == "tokenEndpoint":
            suggest = "token_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppAuthSettingsV2CustomOidcV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppAuthSettingsV2CustomOidcV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppAuthSettingsV2CustomOidcV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 name: str,
                 openid_configuration_endpoint: str,
                 authorisation_endpoint: Optional[str] = None,
                 certification_uri: Optional[str] = None,
                 client_credential_method: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 issuer_endpoint: Optional[str] = None,
                 name_claim_type: Optional[str] = None,
                 scopes: Optional[Sequence[str]] = None,
                 token_endpoint: Optional[str] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str name: The name which should be used for this Windows Web App. Changing this forces a new Windows Web App to be created.
        :param str openid_configuration_endpoint: The app setting name that contains the `client_secret` value used for the Custom OIDC Login.
        :param str authorisation_endpoint: The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        :param str certification_uri: The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        :param str client_credential_method: The Client Credential Method used.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param str issuer_endpoint: The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        :param str name_claim_type: The name of the claim that contains the users name.
        :param Sequence[str] scopes: The list of the scopes that should be requested while authenticating.
        :param str token_endpoint: The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "openid_configuration_endpoint", openid_configuration_endpoint)
        if authorisation_endpoint is not None:
            pulumi.set(__self__, "authorisation_endpoint", authorisation_endpoint)
        if certification_uri is not None:
            pulumi.set(__self__, "certification_uri", certification_uri)
        if client_credential_method is not None:
            pulumi.set(__self__, "client_credential_method", client_credential_method)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if issuer_endpoint is not None:
            pulumi.set(__self__, "issuer_endpoint", issuer_endpoint)
        if name_claim_type is not None:
            pulumi.set(__self__, "name_claim_type", name_claim_type)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Windows Web App. Changing this forces a new Windows Web App to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="openidConfigurationEndpoint")
    def openid_configuration_endpoint(self) -> str:
        """
        The app setting name that contains the `client_secret` value used for the Custom OIDC Login.
        """
        return pulumi.get(self, "openid_configuration_endpoint")

    @property
    @pulumi.getter(name="authorisationEndpoint")
    def authorisation_endpoint(self) -> Optional[str]:
        """
        The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "authorisation_endpoint")

    @property
    @pulumi.getter(name="certificationUri")
    def certification_uri(self) -> Optional[str]:
        """
        The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "certification_uri")

    @property
    @pulumi.getter(name="clientCredentialMethod")
    def client_credential_method(self) -> Optional[str]:
        """
        The Client Credential Method used.
        """
        return pulumi.get(self, "client_credential_method")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="issuerEndpoint")
    def issuer_endpoint(self) -> Optional[str]:
        """
        The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "issuer_endpoint")

    @property
    @pulumi.getter(name="nameClaimType")
    def name_claim_type(self) -> Optional[str]:
        """
        The name of the claim that contains the users name.
        """
        return pulumi.get(self, "name_claim_type")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[str]]:
        """
        The list of the scopes that should be requested while authenticating.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[str]:
        """
        The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "token_endpoint")


@pulumi.output_type
class WindowsWebAppAuthSettingsV2FacebookV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "appSecretSettingName":
            suggest = "app_secret_setting_name"
        elif key == "graphApiVersion":
            suggest = "graph_api_version"
        elif key == "loginScopes":
            suggest = "login_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppAuthSettingsV2FacebookV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppAuthSettingsV2FacebookV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppAuthSettingsV2FacebookV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: str,
                 app_secret_setting_name: str,
                 graph_api_version: Optional[str] = None,
                 login_scopes: Optional[Sequence[str]] = None):
        """
        :param str app_id: The App ID of the Facebook app used for login.
        :param str app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook Login.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param str graph_api_version: The version of the Facebook API to be used while logging in.
        :param Sequence[str] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        if graph_api_version is not None:
            pulumi.set(__self__, "graph_api_version", graph_api_version)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> str:
        """
        The app setting name that contains the `app_secret` value used for Facebook Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @property
    @pulumi.getter(name="graphApiVersion")
    def graph_api_version(self) -> Optional[str]:
        """
        The version of the Facebook API to be used while logging in.
        """
        return pulumi.get(self, "graph_api_version")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[Sequence[str]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class WindowsWebAppAuthSettingsV2GithubV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "loginScopes":
            suggest = "login_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppAuthSettingsV2GithubV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppAuthSettingsV2GithubV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppAuthSettingsV2GithubV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret_setting_name: str,
                 login_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param Sequence[str] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[Sequence[str]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class WindowsWebAppAuthSettingsV2GoogleV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "loginScopes":
            suggest = "login_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppAuthSettingsV2GoogleV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppAuthSettingsV2GoogleV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppAuthSettingsV2GoogleV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret_setting_name: str,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 login_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param Sequence[str] allowed_audiences: Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
               
               > **Note:** The `client_id` value is always considered an allowed audience.
        :param Sequence[str] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **Note:** The `client_id` value is always considered an allowed audience.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[Sequence[str]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class WindowsWebAppAuthSettingsV2Login(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedExternalRedirectUrls":
            suggest = "allowed_external_redirect_urls"
        elif key == "cookieExpirationConvention":
            suggest = "cookie_expiration_convention"
        elif key == "cookieExpirationTime":
            suggest = "cookie_expiration_time"
        elif key == "logoutEndpoint":
            suggest = "logout_endpoint"
        elif key == "nonceExpirationTime":
            suggest = "nonce_expiration_time"
        elif key == "preserveUrlFragmentsForLogins":
            suggest = "preserve_url_fragments_for_logins"
        elif key == "tokenRefreshExtensionTime":
            suggest = "token_refresh_extension_time"
        elif key == "tokenStoreEnabled":
            suggest = "token_store_enabled"
        elif key == "tokenStorePath":
            suggest = "token_store_path"
        elif key == "tokenStoreSasSettingName":
            suggest = "token_store_sas_setting_name"
        elif key == "validateNonce":
            suggest = "validate_nonce"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppAuthSettingsV2Login. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppAuthSettingsV2Login.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppAuthSettingsV2Login.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_external_redirect_urls: Optional[Sequence[str]] = None,
                 cookie_expiration_convention: Optional[str] = None,
                 cookie_expiration_time: Optional[str] = None,
                 logout_endpoint: Optional[str] = None,
                 nonce_expiration_time: Optional[str] = None,
                 preserve_url_fragments_for_logins: Optional[bool] = None,
                 token_refresh_extension_time: Optional[float] = None,
                 token_store_enabled: Optional[bool] = None,
                 token_store_path: Optional[str] = None,
                 token_store_sas_setting_name: Optional[str] = None,
                 validate_nonce: Optional[bool] = None):
        """
        :param Sequence[str] allowed_external_redirect_urls: External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends.
               
               > **Note:** URLs within the current domain are always implicitly allowed.
        :param str cookie_expiration_convention: The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
        :param str cookie_expiration_time: The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
        :param str logout_endpoint: The endpoint to which logout requests should be made.
        :param str nonce_expiration_time: The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
        :param bool preserve_url_fragments_for_logins: Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
        :param float token_refresh_extension_time: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        :param bool token_store_enabled: Should the Token Store configuration Enabled. Defaults to `false`
        :param str token_store_path: The directory path in the App Filesystem in which the tokens will be stored.
        :param str token_store_sas_setting_name: The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        :param bool validate_nonce: Should the nonce be validated while completing the login flow. Defaults to `true`.
        """
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if cookie_expiration_convention is not None:
            pulumi.set(__self__, "cookie_expiration_convention", cookie_expiration_convention)
        if cookie_expiration_time is not None:
            pulumi.set(__self__, "cookie_expiration_time", cookie_expiration_time)
        if logout_endpoint is not None:
            pulumi.set(__self__, "logout_endpoint", logout_endpoint)
        if nonce_expiration_time is not None:
            pulumi.set(__self__, "nonce_expiration_time", nonce_expiration_time)
        if preserve_url_fragments_for_logins is not None:
            pulumi.set(__self__, "preserve_url_fragments_for_logins", preserve_url_fragments_for_logins)
        if token_refresh_extension_time is not None:
            pulumi.set(__self__, "token_refresh_extension_time", token_refresh_extension_time)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if token_store_path is not None:
            pulumi.set(__self__, "token_store_path", token_store_path)
        if token_store_sas_setting_name is not None:
            pulumi.set(__self__, "token_store_sas_setting_name", token_store_sas_setting_name)
        if validate_nonce is not None:
            pulumi.set(__self__, "validate_nonce", validate_nonce)

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[Sequence[str]]:
        """
        External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends.

        > **Note:** URLs within the current domain are always implicitly allowed.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @property
    @pulumi.getter(name="cookieExpirationConvention")
    def cookie_expiration_convention(self) -> Optional[str]:
        """
        The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
        """
        return pulumi.get(self, "cookie_expiration_convention")

    @property
    @pulumi.getter(name="cookieExpirationTime")
    def cookie_expiration_time(self) -> Optional[str]:
        """
        The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
        """
        return pulumi.get(self, "cookie_expiration_time")

    @property
    @pulumi.getter(name="logoutEndpoint")
    def logout_endpoint(self) -> Optional[str]:
        """
        The endpoint to which logout requests should be made.
        """
        return pulumi.get(self, "logout_endpoint")

    @property
    @pulumi.getter(name="nonceExpirationTime")
    def nonce_expiration_time(self) -> Optional[str]:
        """
        The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
        """
        return pulumi.get(self, "nonce_expiration_time")

    @property
    @pulumi.getter(name="preserveUrlFragmentsForLogins")
    def preserve_url_fragments_for_logins(self) -> Optional[bool]:
        """
        Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
        """
        return pulumi.get(self, "preserve_url_fragments_for_logins")

    @property
    @pulumi.getter(name="tokenRefreshExtensionTime")
    def token_refresh_extension_time(self) -> Optional[float]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        return pulumi.get(self, "token_refresh_extension_time")

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[bool]:
        """
        Should the Token Store configuration Enabled. Defaults to `false`
        """
        return pulumi.get(self, "token_store_enabled")

    @property
    @pulumi.getter(name="tokenStorePath")
    def token_store_path(self) -> Optional[str]:
        """
        The directory path in the App Filesystem in which the tokens will be stored.
        """
        return pulumi.get(self, "token_store_path")

    @property
    @pulumi.getter(name="tokenStoreSasSettingName")
    def token_store_sas_setting_name(self) -> Optional[str]:
        """
        The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        """
        return pulumi.get(self, "token_store_sas_setting_name")

    @property
    @pulumi.getter(name="validateNonce")
    def validate_nonce(self) -> Optional[bool]:
        """
        Should the nonce be validated while completing the login flow. Defaults to `true`.
        """
        return pulumi.get(self, "validate_nonce")


@pulumi.output_type
class WindowsWebAppAuthSettingsV2MicrosoftV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "loginScopes":
            suggest = "login_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppAuthSettingsV2MicrosoftV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppAuthSettingsV2MicrosoftV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppAuthSettingsV2MicrosoftV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret_setting_name: str,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 login_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param Sequence[str] allowed_audiences: Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
               
               > **Note:** The `client_id` value is always considered an allowed audience.
        :param Sequence[str] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **Note:** The `client_id` value is always considered an allowed audience.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[Sequence[str]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class WindowsWebAppAuthSettingsV2TwitterV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerKey":
            suggest = "consumer_key"
        elif key == "consumerSecretSettingName":
            suggest = "consumer_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppAuthSettingsV2TwitterV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppAuthSettingsV2TwitterV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppAuthSettingsV2TwitterV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_key: str,
                 consumer_secret_setting_name: str):
        """
        :param str consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param str consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> str:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> str:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "consumer_secret_setting_name")


@pulumi.output_type
class WindowsWebAppBackup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageAccountUrl":
            suggest = "storage_account_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppBackup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppBackup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppBackup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 schedule: 'outputs.WindowsWebAppBackupSchedule',
                 storage_account_url: str,
                 enabled: Optional[bool] = None):
        """
        :param str name: The name which should be used for this Backup.
        :param 'WindowsWebAppBackupScheduleArgs' schedule: A `schedule` block as defined below.
        :param str storage_account_url: The SAS URL to the container.
        :param bool enabled: Should this backup job be enabled? Defaults to `true`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "storage_account_url", storage_account_url)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Backup.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def schedule(self) -> 'outputs.WindowsWebAppBackupSchedule':
        """
        A `schedule` block as defined below.
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter(name="storageAccountUrl")
    def storage_account_url(self) -> str:
        """
        The SAS URL to the container.
        """
        return pulumi.get(self, "storage_account_url")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Should this backup job be enabled? Defaults to `true`.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class WindowsWebAppBackupSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "frequencyUnit":
            suggest = "frequency_unit"
        elif key == "keepAtLeastOneBackup":
            suggest = "keep_at_least_one_backup"
        elif key == "lastExecutionTime":
            suggest = "last_execution_time"
        elif key == "retentionPeriodDays":
            suggest = "retention_period_days"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppBackupSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppBackupSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppBackupSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_unit: str,
                 keep_at_least_one_backup: Optional[bool] = None,
                 last_execution_time: Optional[str] = None,
                 retention_period_days: Optional[int] = None,
                 start_time: Optional[str] = None):
        """
        :param int frequency_interval: How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).
               
               > **NOTE:** Not all intervals are supported on all Windows Web App SKUs. Please refer to the official documentation for appropriate values.
        :param str frequency_unit: The unit of time for how often the backup should take place. Possible values include: `Day`, `Hour`
        :param bool keep_at_least_one_backup: Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
        :param int retention_period_days: After how many days backups should be deleted. Defaults to `30`.
        :param str start_time: When the schedule should start working in RFC-3339 format.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_unit", frequency_unit)
        if keep_at_least_one_backup is not None:
            pulumi.set(__self__, "keep_at_least_one_backup", keep_at_least_one_backup)
        if last_execution_time is not None:
            pulumi.set(__self__, "last_execution_time", last_execution_time)
        if retention_period_days is not None:
            pulumi.set(__self__, "retention_period_days", retention_period_days)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).

        > **NOTE:** Not all intervals are supported on all Windows Web App SKUs. Please refer to the official documentation for appropriate values.
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyUnit")
    def frequency_unit(self) -> str:
        """
        The unit of time for how often the backup should take place. Possible values include: `Day`, `Hour`
        """
        return pulumi.get(self, "frequency_unit")

    @property
    @pulumi.getter(name="keepAtLeastOneBackup")
    def keep_at_least_one_backup(self) -> Optional[bool]:
        """
        Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
        """
        return pulumi.get(self, "keep_at_least_one_backup")

    @property
    @pulumi.getter(name="lastExecutionTime")
    def last_execution_time(self) -> Optional[str]:
        return pulumi.get(self, "last_execution_time")

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> Optional[int]:
        """
        After how many days backups should be deleted. Defaults to `30`.
        """
        return pulumi.get(self, "retention_period_days")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        """
        When the schedule should start working in RFC-3339 format.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class WindowsWebAppConnectionString(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: The name of the Connection String.
        :param str type: Type of database. Possible values include: `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
        :param str value: The connection string value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Connection String.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of database. Possible values include: `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The connection string value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class WindowsWebAppIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 identity_ids: Optional[Sequence[str]] = None,
                 principal_id: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str type: Specifies the type of Managed Service Identity that should be configured on this Windows Web App. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        :param Sequence[str] identity_ids: A list of User Assigned Managed Identity IDs to be assigned to this Windows Web App.
               
               > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        :param str principal_id: The Principal ID associated with this Managed Service Identity.
        :param str tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the type of Managed Service Identity that should be configured on this Windows Web App. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[str]]:
        """
        A list of User Assigned Managed Identity IDs to be assigned to this Windows Web App.

        > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class WindowsWebAppLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationLogs":
            suggest = "application_logs"
        elif key == "detailedErrorMessages":
            suggest = "detailed_error_messages"
        elif key == "failedRequestTracing":
            suggest = "failed_request_tracing"
        elif key == "httpLogs":
            suggest = "http_logs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_logs: Optional['outputs.WindowsWebAppLogsApplicationLogs'] = None,
                 detailed_error_messages: Optional[bool] = None,
                 failed_request_tracing: Optional[bool] = None,
                 http_logs: Optional['outputs.WindowsWebAppLogsHttpLogs'] = None):
        """
        :param 'WindowsWebAppLogsApplicationLogsArgs' application_logs: A `application_logs` block as defined above.
        :param bool detailed_error_messages: Should detailed error messages be enabled.
        :param bool failed_request_tracing: Should tracing be enabled for failed requests.
        :param 'WindowsWebAppLogsHttpLogsArgs' http_logs: A `http_logs` block as defined above.
        """
        if application_logs is not None:
            pulumi.set(__self__, "application_logs", application_logs)
        if detailed_error_messages is not None:
            pulumi.set(__self__, "detailed_error_messages", detailed_error_messages)
        if failed_request_tracing is not None:
            pulumi.set(__self__, "failed_request_tracing", failed_request_tracing)
        if http_logs is not None:
            pulumi.set(__self__, "http_logs", http_logs)

    @property
    @pulumi.getter(name="applicationLogs")
    def application_logs(self) -> Optional['outputs.WindowsWebAppLogsApplicationLogs']:
        """
        A `application_logs` block as defined above.
        """
        return pulumi.get(self, "application_logs")

    @property
    @pulumi.getter(name="detailedErrorMessages")
    def detailed_error_messages(self) -> Optional[bool]:
        """
        Should detailed error messages be enabled.
        """
        return pulumi.get(self, "detailed_error_messages")

    @property
    @pulumi.getter(name="failedRequestTracing")
    def failed_request_tracing(self) -> Optional[bool]:
        """
        Should tracing be enabled for failed requests.
        """
        return pulumi.get(self, "failed_request_tracing")

    @property
    @pulumi.getter(name="httpLogs")
    def http_logs(self) -> Optional['outputs.WindowsWebAppLogsHttpLogs']:
        """
        A `http_logs` block as defined above.
        """
        return pulumi.get(self, "http_logs")


@pulumi.output_type
class WindowsWebAppLogsApplicationLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileSystemLevel":
            suggest = "file_system_level"
        elif key == "azureBlobStorage":
            suggest = "azure_blob_storage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppLogsApplicationLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppLogsApplicationLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppLogsApplicationLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_system_level: str,
                 azure_blob_storage: Optional['outputs.WindowsWebAppLogsApplicationLogsAzureBlobStorage'] = None):
        """
        :param str file_system_level: Log level. Possible values include: `Verbose`, `Information`, `Warning`, and `Error`.
        :param 'WindowsWebAppLogsApplicationLogsAzureBlobStorageArgs' azure_blob_storage: An `azure_blob_storage` block as defined below.
        """
        pulumi.set(__self__, "file_system_level", file_system_level)
        if azure_blob_storage is not None:
            pulumi.set(__self__, "azure_blob_storage", azure_blob_storage)

    @property
    @pulumi.getter(name="fileSystemLevel")
    def file_system_level(self) -> str:
        """
        Log level. Possible values include: `Verbose`, `Information`, `Warning`, and `Error`.
        """
        return pulumi.get(self, "file_system_level")

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional['outputs.WindowsWebAppLogsApplicationLogsAzureBlobStorage']:
        """
        An `azure_blob_storage` block as defined below.
        """
        return pulumi.get(self, "azure_blob_storage")


@pulumi.output_type
class WindowsWebAppLogsApplicationLogsAzureBlobStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retentionInDays":
            suggest = "retention_in_days"
        elif key == "sasUrl":
            suggest = "sas_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppLogsApplicationLogsAzureBlobStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppLogsApplicationLogsAzureBlobStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppLogsApplicationLogsAzureBlobStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 level: str,
                 retention_in_days: int,
                 sas_url: str):
        """
        :param str level: The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        :param int retention_in_days: The time in days after which to remove blobs. A value of `0` means no retention.
        :param str sas_url: SAS url to an Azure blob container with read/write/list/delete permissions.
        """
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "sas_url", sas_url)

    @property
    @pulumi.getter
    def level(self) -> str:
        """
        The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        """
        return pulumi.get(self, "level")

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> int:
        """
        The time in days after which to remove blobs. A value of `0` means no retention.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> str:
        """
        SAS url to an Azure blob container with read/write/list/delete permissions.
        """
        return pulumi.get(self, "sas_url")


@pulumi.output_type
class WindowsWebAppLogsHttpLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureBlobStorage":
            suggest = "azure_blob_storage"
        elif key == "fileSystem":
            suggest = "file_system"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppLogsHttpLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppLogsHttpLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppLogsHttpLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_blob_storage: Optional['outputs.WindowsWebAppLogsHttpLogsAzureBlobStorage'] = None,
                 file_system: Optional['outputs.WindowsWebAppLogsHttpLogsFileSystem'] = None):
        """
        :param 'WindowsWebAppLogsHttpLogsAzureBlobStorageArgs' azure_blob_storage: A `azure_blob_storage_http` block as defined above.
        :param 'WindowsWebAppLogsHttpLogsFileSystemArgs' file_system: A `file_system` block as defined above.
        """
        if azure_blob_storage is not None:
            pulumi.set(__self__, "azure_blob_storage", azure_blob_storage)
        if file_system is not None:
            pulumi.set(__self__, "file_system", file_system)

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional['outputs.WindowsWebAppLogsHttpLogsAzureBlobStorage']:
        """
        A `azure_blob_storage_http` block as defined above.
        """
        return pulumi.get(self, "azure_blob_storage")

    @property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional['outputs.WindowsWebAppLogsHttpLogsFileSystem']:
        """
        A `file_system` block as defined above.
        """
        return pulumi.get(self, "file_system")


@pulumi.output_type
class WindowsWebAppLogsHttpLogsAzureBlobStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sasUrl":
            suggest = "sas_url"
        elif key == "retentionInDays":
            suggest = "retention_in_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppLogsHttpLogsAzureBlobStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppLogsHttpLogsAzureBlobStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppLogsHttpLogsAzureBlobStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sas_url: str,
                 retention_in_days: Optional[int] = None):
        """
        :param str sas_url: SAS url to an Azure blob container with read/write/list/delete permissions.
        :param int retention_in_days: The time in days after which to remove blobs. A value of `0` means no retention.
        """
        pulumi.set(__self__, "sas_url", sas_url)
        if retention_in_days is not None:
            pulumi.set(__self__, "retention_in_days", retention_in_days)

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> str:
        """
        SAS url to an Azure blob container with read/write/list/delete permissions.
        """
        return pulumi.get(self, "sas_url")

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> Optional[int]:
        """
        The time in days after which to remove blobs. A value of `0` means no retention.
        """
        return pulumi.get(self, "retention_in_days")


@pulumi.output_type
class WindowsWebAppLogsHttpLogsFileSystem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retentionInDays":
            suggest = "retention_in_days"
        elif key == "retentionInMb":
            suggest = "retention_in_mb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppLogsHttpLogsFileSystem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppLogsHttpLogsFileSystem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppLogsHttpLogsFileSystem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 retention_in_days: int,
                 retention_in_mb: int):
        """
        :param int retention_in_days: The retention period in days. A values of `0` means no retention.
        :param int retention_in_mb: The maximum size in megabytes that log files can use.
        """
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "retention_in_mb", retention_in_mb)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> int:
        """
        The retention period in days. A values of `0` means no retention.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="retentionInMb")
    def retention_in_mb(self) -> int:
        """
        The maximum size in megabytes that log files can use.
        """
        return pulumi.get(self, "retention_in_mb")


@pulumi.output_type
class WindowsWebAppSiteConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alwaysOn":
            suggest = "always_on"
        elif key == "apiDefinitionUrl":
            suggest = "api_definition_url"
        elif key == "apiManagementApiId":
            suggest = "api_management_api_id"
        elif key == "appCommandLine":
            suggest = "app_command_line"
        elif key == "applicationStack":
            suggest = "application_stack"
        elif key == "autoHealEnabled":
            suggest = "auto_heal_enabled"
        elif key == "autoHealSetting":
            suggest = "auto_heal_setting"
        elif key == "containerRegistryManagedIdentityClientId":
            suggest = "container_registry_managed_identity_client_id"
        elif key == "containerRegistryUseManagedIdentity":
            suggest = "container_registry_use_managed_identity"
        elif key == "defaultDocuments":
            suggest = "default_documents"
        elif key == "detailedErrorLoggingEnabled":
            suggest = "detailed_error_logging_enabled"
        elif key == "ftpsState":
            suggest = "ftps_state"
        elif key == "healthCheckEvictionTimeInMin":
            suggest = "health_check_eviction_time_in_min"
        elif key == "healthCheckPath":
            suggest = "health_check_path"
        elif key == "http2Enabled":
            suggest = "http2_enabled"
        elif key == "ipRestrictions":
            suggest = "ip_restrictions"
        elif key == "linuxFxVersion":
            suggest = "linux_fx_version"
        elif key == "loadBalancingMode":
            suggest = "load_balancing_mode"
        elif key == "localMysqlEnabled":
            suggest = "local_mysql_enabled"
        elif key == "managedPipelineMode":
            suggest = "managed_pipeline_mode"
        elif key == "minimumTlsVersion":
            suggest = "minimum_tls_version"
        elif key == "remoteDebuggingEnabled":
            suggest = "remote_debugging_enabled"
        elif key == "remoteDebuggingVersion":
            suggest = "remote_debugging_version"
        elif key == "scmIpRestrictions":
            suggest = "scm_ip_restrictions"
        elif key == "scmMinimumTlsVersion":
            suggest = "scm_minimum_tls_version"
        elif key == "scmType":
            suggest = "scm_type"
        elif key == "scmUseMainIpRestriction":
            suggest = "scm_use_main_ip_restriction"
        elif key == "use32BitWorker":
            suggest = "use32_bit_worker"
        elif key == "virtualApplications":
            suggest = "virtual_applications"
        elif key == "vnetRouteAllEnabled":
            suggest = "vnet_route_all_enabled"
        elif key == "websocketsEnabled":
            suggest = "websockets_enabled"
        elif key == "windowsFxVersion":
            suggest = "windows_fx_version"
        elif key == "workerCount":
            suggest = "worker_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSiteConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSiteConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSiteConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 always_on: Optional[bool] = None,
                 api_definition_url: Optional[str] = None,
                 api_management_api_id: Optional[str] = None,
                 app_command_line: Optional[str] = None,
                 application_stack: Optional['outputs.WindowsWebAppSiteConfigApplicationStack'] = None,
                 auto_heal_enabled: Optional[bool] = None,
                 auto_heal_setting: Optional['outputs.WindowsWebAppSiteConfigAutoHealSetting'] = None,
                 container_registry_managed_identity_client_id: Optional[str] = None,
                 container_registry_use_managed_identity: Optional[bool] = None,
                 cors: Optional['outputs.WindowsWebAppSiteConfigCors'] = None,
                 default_documents: Optional[Sequence[str]] = None,
                 detailed_error_logging_enabled: Optional[bool] = None,
                 ftps_state: Optional[str] = None,
                 health_check_eviction_time_in_min: Optional[int] = None,
                 health_check_path: Optional[str] = None,
                 http2_enabled: Optional[bool] = None,
                 ip_restrictions: Optional[Sequence['outputs.WindowsWebAppSiteConfigIpRestriction']] = None,
                 linux_fx_version: Optional[str] = None,
                 load_balancing_mode: Optional[str] = None,
                 local_mysql_enabled: Optional[bool] = None,
                 managed_pipeline_mode: Optional[str] = None,
                 minimum_tls_version: Optional[str] = None,
                 remote_debugging_enabled: Optional[bool] = None,
                 remote_debugging_version: Optional[str] = None,
                 scm_ip_restrictions: Optional[Sequence['outputs.WindowsWebAppSiteConfigScmIpRestriction']] = None,
                 scm_minimum_tls_version: Optional[str] = None,
                 scm_type: Optional[str] = None,
                 scm_use_main_ip_restriction: Optional[bool] = None,
                 use32_bit_worker: Optional[bool] = None,
                 virtual_applications: Optional[Sequence['outputs.WindowsWebAppSiteConfigVirtualApplication']] = None,
                 vnet_route_all_enabled: Optional[bool] = None,
                 websockets_enabled: Optional[bool] = None,
                 windows_fx_version: Optional[str] = None,
                 worker_count: Optional[int] = None):
        """
        :param bool always_on: If this Windows Web App is Always On enabled. Defaults to `true`.
               
               > **NOTE:** `always_on` must be explicitly set to `false` when using `Free`, `F1`, `D1`, or `Shared` Service Plans.
        :param str api_definition_url: The URL to the API Definition for this Windows Web App.
        :param str api_management_api_id: The API Management API ID this Windows Web App Slot is associated with.
        :param str app_command_line: The App command line to launch.
        :param 'WindowsWebAppSiteConfigApplicationStackArgs' application_stack: A `application_stack` block as defined above.
        :param bool auto_heal_enabled: Should Auto heal rules be enabled. Required with `auto_heal_setting`.
        :param 'WindowsWebAppSiteConfigAutoHealSettingArgs' auto_heal_setting: A `auto_heal_setting` block as defined above. Required with `auto_heal`.
        :param str container_registry_managed_identity_client_id: The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
        :param bool container_registry_use_managed_identity: Should connections for Azure Container Registry use Managed Identity.
        :param 'WindowsWebAppSiteConfigCorsArgs' cors: A `cors` block as defined above.
        :param Sequence[str] default_documents: Specifies a list of Default Documents for the Windows Web App.
        :param int health_check_eviction_time_in_min: The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        :param str health_check_path: The path to the Health Check.
        :param bool http2_enabled: Should the HTTP2 be enabled?
        :param Sequence['WindowsWebAppSiteConfigIpRestrictionArgs'] ip_restrictions: One or more `ip_restriction` blocks as defined above.
        :param str load_balancing_mode: The Site load balancing. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        :param bool local_mysql_enabled: Use Local MySQL. Defaults to `false`.
        :param str managed_pipeline_mode: Managed pipeline mode. Possible values include: `Integrated`, `Classic`.
        :param str minimum_tls_version: The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        :param bool remote_debugging_enabled: Should Remote Debugging be enabled. Defaults to `false`.
        :param str remote_debugging_version: The Remote Debugging Version. Possible values include `VS2017` and `VS2019`
        :param Sequence['WindowsWebAppSiteConfigScmIpRestrictionArgs'] scm_ip_restrictions: One or more `scm_ip_restriction` blocks as defined above.
        :param str scm_minimum_tls_version: The configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        :param bool scm_use_main_ip_restriction: Should the Windows Web App `ip_restriction` configuration be used for the SCM also.
        :param bool use32_bit_worker: Should the Windows Web App use a 32-bit worker. Defaults to `true`.
        :param Sequence['WindowsWebAppSiteConfigVirtualApplicationArgs'] virtual_applications: One or more `virtual_application` blocks as defined below.
        :param bool vnet_route_all_enabled: Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        :param bool websockets_enabled: Should Web Sockets be enabled. Defaults to `false`.
        :param int worker_count: The number of Workers for this Windows App Service.
        """
        if always_on is not None:
            pulumi.set(__self__, "always_on", always_on)
        if api_definition_url is not None:
            pulumi.set(__self__, "api_definition_url", api_definition_url)
        if api_management_api_id is not None:
            pulumi.set(__self__, "api_management_api_id", api_management_api_id)
        if app_command_line is not None:
            pulumi.set(__self__, "app_command_line", app_command_line)
        if application_stack is not None:
            pulumi.set(__self__, "application_stack", application_stack)
        if auto_heal_enabled is not None:
            pulumi.set(__self__, "auto_heal_enabled", auto_heal_enabled)
        if auto_heal_setting is not None:
            pulumi.set(__self__, "auto_heal_setting", auto_heal_setting)
        if container_registry_managed_identity_client_id is not None:
            pulumi.set(__self__, "container_registry_managed_identity_client_id", container_registry_managed_identity_client_id)
        if container_registry_use_managed_identity is not None:
            pulumi.set(__self__, "container_registry_use_managed_identity", container_registry_use_managed_identity)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if default_documents is not None:
            pulumi.set(__self__, "default_documents", default_documents)
        if detailed_error_logging_enabled is not None:
            pulumi.set(__self__, "detailed_error_logging_enabled", detailed_error_logging_enabled)
        if ftps_state is not None:
            pulumi.set(__self__, "ftps_state", ftps_state)
        if health_check_eviction_time_in_min is not None:
            pulumi.set(__self__, "health_check_eviction_time_in_min", health_check_eviction_time_in_min)
        if health_check_path is not None:
            pulumi.set(__self__, "health_check_path", health_check_path)
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if ip_restrictions is not None:
            pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        if linux_fx_version is not None:
            pulumi.set(__self__, "linux_fx_version", linux_fx_version)
        if load_balancing_mode is not None:
            pulumi.set(__self__, "load_balancing_mode", load_balancing_mode)
        if local_mysql_enabled is not None:
            pulumi.set(__self__, "local_mysql_enabled", local_mysql_enabled)
        if managed_pipeline_mode is not None:
            pulumi.set(__self__, "managed_pipeline_mode", managed_pipeline_mode)
        if minimum_tls_version is not None:
            pulumi.set(__self__, "minimum_tls_version", minimum_tls_version)
        if remote_debugging_enabled is not None:
            pulumi.set(__self__, "remote_debugging_enabled", remote_debugging_enabled)
        if remote_debugging_version is not None:
            pulumi.set(__self__, "remote_debugging_version", remote_debugging_version)
        if scm_ip_restrictions is not None:
            pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        if scm_minimum_tls_version is not None:
            pulumi.set(__self__, "scm_minimum_tls_version", scm_minimum_tls_version)
        if scm_type is not None:
            pulumi.set(__self__, "scm_type", scm_type)
        if scm_use_main_ip_restriction is not None:
            pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        if use32_bit_worker is not None:
            pulumi.set(__self__, "use32_bit_worker", use32_bit_worker)
        if virtual_applications is not None:
            pulumi.set(__self__, "virtual_applications", virtual_applications)
        if vnet_route_all_enabled is not None:
            pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        if websockets_enabled is not None:
            pulumi.set(__self__, "websockets_enabled", websockets_enabled)
        if windows_fx_version is not None:
            pulumi.set(__self__, "windows_fx_version", windows_fx_version)
        if worker_count is not None:
            pulumi.set(__self__, "worker_count", worker_count)

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> Optional[bool]:
        """
        If this Windows Web App is Always On enabled. Defaults to `true`.

        > **NOTE:** `always_on` must be explicitly set to `false` when using `Free`, `F1`, `D1`, or `Shared` Service Plans.
        """
        return pulumi.get(self, "always_on")

    @property
    @pulumi.getter(name="apiDefinitionUrl")
    def api_definition_url(self) -> Optional[str]:
        """
        The URL to the API Definition for this Windows Web App.
        """
        return pulumi.get(self, "api_definition_url")

    @property
    @pulumi.getter(name="apiManagementApiId")
    def api_management_api_id(self) -> Optional[str]:
        """
        The API Management API ID this Windows Web App Slot is associated with.
        """
        return pulumi.get(self, "api_management_api_id")

    @property
    @pulumi.getter(name="appCommandLine")
    def app_command_line(self) -> Optional[str]:
        """
        The App command line to launch.
        """
        return pulumi.get(self, "app_command_line")

    @property
    @pulumi.getter(name="applicationStack")
    def application_stack(self) -> Optional['outputs.WindowsWebAppSiteConfigApplicationStack']:
        """
        A `application_stack` block as defined above.
        """
        return pulumi.get(self, "application_stack")

    @property
    @pulumi.getter(name="autoHealEnabled")
    def auto_heal_enabled(self) -> Optional[bool]:
        """
        Should Auto heal rules be enabled. Required with `auto_heal_setting`.
        """
        return pulumi.get(self, "auto_heal_enabled")

    @property
    @pulumi.getter(name="autoHealSetting")
    def auto_heal_setting(self) -> Optional['outputs.WindowsWebAppSiteConfigAutoHealSetting']:
        """
        A `auto_heal_setting` block as defined above. Required with `auto_heal`.
        """
        return pulumi.get(self, "auto_heal_setting")

    @property
    @pulumi.getter(name="containerRegistryManagedIdentityClientId")
    def container_registry_managed_identity_client_id(self) -> Optional[str]:
        """
        The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
        """
        return pulumi.get(self, "container_registry_managed_identity_client_id")

    @property
    @pulumi.getter(name="containerRegistryUseManagedIdentity")
    def container_registry_use_managed_identity(self) -> Optional[bool]:
        """
        Should connections for Azure Container Registry use Managed Identity.
        """
        return pulumi.get(self, "container_registry_use_managed_identity")

    @property
    @pulumi.getter
    def cors(self) -> Optional['outputs.WindowsWebAppSiteConfigCors']:
        """
        A `cors` block as defined above.
        """
        return pulumi.get(self, "cors")

    @property
    @pulumi.getter(name="defaultDocuments")
    def default_documents(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Default Documents for the Windows Web App.
        """
        return pulumi.get(self, "default_documents")

    @property
    @pulumi.getter(name="detailedErrorLoggingEnabled")
    def detailed_error_logging_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "detailed_error_logging_enabled")

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> Optional[str]:
        return pulumi.get(self, "ftps_state")

    @property
    @pulumi.getter(name="healthCheckEvictionTimeInMin")
    def health_check_eviction_time_in_min(self) -> Optional[int]:
        """
        The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        """
        return pulumi.get(self, "health_check_eviction_time_in_min")

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> Optional[str]:
        """
        The path to the Health Check.
        """
        return pulumi.get(self, "health_check_path")

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[bool]:
        """
        Should the HTTP2 be enabled?
        """
        return pulumi.get(self, "http2_enabled")

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Optional[Sequence['outputs.WindowsWebAppSiteConfigIpRestriction']]:
        """
        One or more `ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "ip_restrictions")

    @property
    @pulumi.getter(name="linuxFxVersion")
    def linux_fx_version(self) -> Optional[str]:
        return pulumi.get(self, "linux_fx_version")

    @property
    @pulumi.getter(name="loadBalancingMode")
    def load_balancing_mode(self) -> Optional[str]:
        """
        The Site load balancing. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        """
        return pulumi.get(self, "load_balancing_mode")

    @property
    @pulumi.getter(name="localMysqlEnabled")
    def local_mysql_enabled(self) -> Optional[bool]:
        """
        Use Local MySQL. Defaults to `false`.
        """
        return pulumi.get(self, "local_mysql_enabled")

    @property
    @pulumi.getter(name="managedPipelineMode")
    def managed_pipeline_mode(self) -> Optional[str]:
        """
        Managed pipeline mode. Possible values include: `Integrated`, `Classic`.
        """
        return pulumi.get(self, "managed_pipeline_mode")

    @property
    @pulumi.getter(name="minimumTlsVersion")
    def minimum_tls_version(self) -> Optional[str]:
        """
        The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        """
        return pulumi.get(self, "minimum_tls_version")

    @property
    @pulumi.getter(name="remoteDebuggingEnabled")
    def remote_debugging_enabled(self) -> Optional[bool]:
        """
        Should Remote Debugging be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "remote_debugging_enabled")

    @property
    @pulumi.getter(name="remoteDebuggingVersion")
    def remote_debugging_version(self) -> Optional[str]:
        """
        The Remote Debugging Version. Possible values include `VS2017` and `VS2019`
        """
        return pulumi.get(self, "remote_debugging_version")

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Optional[Sequence['outputs.WindowsWebAppSiteConfigScmIpRestriction']]:
        """
        One or more `scm_ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "scm_ip_restrictions")

    @property
    @pulumi.getter(name="scmMinimumTlsVersion")
    def scm_minimum_tls_version(self) -> Optional[str]:
        """
        The configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        """
        return pulumi.get(self, "scm_minimum_tls_version")

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> Optional[str]:
        return pulumi.get(self, "scm_type")

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> Optional[bool]:
        """
        Should the Windows Web App `ip_restriction` configuration be used for the SCM also.
        """
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @property
    @pulumi.getter(name="use32BitWorker")
    def use32_bit_worker(self) -> Optional[bool]:
        """
        Should the Windows Web App use a 32-bit worker. Defaults to `true`.
        """
        return pulumi.get(self, "use32_bit_worker")

    @property
    @pulumi.getter(name="virtualApplications")
    def virtual_applications(self) -> Optional[Sequence['outputs.WindowsWebAppSiteConfigVirtualApplication']]:
        """
        One or more `virtual_application` blocks as defined below.
        """
        return pulumi.get(self, "virtual_applications")

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> Optional[bool]:
        """
        Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        """
        return pulumi.get(self, "vnet_route_all_enabled")

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> Optional[bool]:
        """
        Should Web Sockets be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "websockets_enabled")

    @property
    @pulumi.getter(name="windowsFxVersion")
    def windows_fx_version(self) -> Optional[str]:
        return pulumi.get(self, "windows_fx_version")

    @property
    @pulumi.getter(name="workerCount")
    def worker_count(self) -> Optional[int]:
        """
        The number of Workers for this Windows App Service.
        """
        return pulumi.get(self, "worker_count")


@pulumi.output_type
class WindowsWebAppSiteConfigApplicationStack(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "currentStack":
            suggest = "current_stack"
        elif key == "dockerContainerName":
            suggest = "docker_container_name"
        elif key == "dockerContainerRegistry":
            suggest = "docker_container_registry"
        elif key == "dockerContainerTag":
            suggest = "docker_container_tag"
        elif key == "dockerImageName":
            suggest = "docker_image_name"
        elif key == "dockerRegistryPassword":
            suggest = "docker_registry_password"
        elif key == "dockerRegistryUrl":
            suggest = "docker_registry_url"
        elif key == "dockerRegistryUsername":
            suggest = "docker_registry_username"
        elif key == "dotnetCoreVersion":
            suggest = "dotnet_core_version"
        elif key == "dotnetVersion":
            suggest = "dotnet_version"
        elif key == "javaContainer":
            suggest = "java_container"
        elif key == "javaContainerVersion":
            suggest = "java_container_version"
        elif key == "javaEmbeddedServerEnabled":
            suggest = "java_embedded_server_enabled"
        elif key == "javaVersion":
            suggest = "java_version"
        elif key == "nodeVersion":
            suggest = "node_version"
        elif key == "phpVersion":
            suggest = "php_version"
        elif key == "pythonVersion":
            suggest = "python_version"
        elif key == "tomcatVersion":
            suggest = "tomcat_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSiteConfigApplicationStack. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSiteConfigApplicationStack.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSiteConfigApplicationStack.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 current_stack: Optional[str] = None,
                 docker_container_name: Optional[str] = None,
                 docker_container_registry: Optional[str] = None,
                 docker_container_tag: Optional[str] = None,
                 docker_image_name: Optional[str] = None,
                 docker_registry_password: Optional[str] = None,
                 docker_registry_url: Optional[str] = None,
                 docker_registry_username: Optional[str] = None,
                 dotnet_core_version: Optional[str] = None,
                 dotnet_version: Optional[str] = None,
                 java_container: Optional[str] = None,
                 java_container_version: Optional[str] = None,
                 java_embedded_server_enabled: Optional[bool] = None,
                 java_version: Optional[str] = None,
                 node_version: Optional[str] = None,
                 php_version: Optional[str] = None,
                 python: Optional[bool] = None,
                 python_version: Optional[str] = None,
                 tomcat_version: Optional[str] = None):
        """
        :param str current_stack: The Application Stack for the Windows Web App. Possible values include `dotnet`, `dotnetcore`, `node`, `python`, `php`, and `java`.
               
               > **NOTE:** Whilst this property is Optional omitting it can cause unexpected behaviour, in particular for display of settings in the Azure Portal.
        :param str docker_image_name: The docker image, including tag, to be used. e.g. `azure-app-service/windows/parkingpage:latest`.
        :param str docker_registry_password: The User Name to use for authentication against the registry to pull the image.
               
               > **NOTE:** `docker_registry_url`, `docker_registry_username`, and `docker_registry_password` replace the use of the `app_settings` values of `DOCKER_REGISTRY_SERVER_URL`, `DOCKER_REGISTRY_SERVER_USERNAME` and `DOCKER_REGISTRY_SERVER_PASSWORD` respectively, these values will be managed by the provider and should not be specified in the `app_settings` map.
        :param str docker_registry_url: The URL of the container registry where the `docker_image_name` is located. e.g. `https://index.docker.io` or `https://mcr.microsoft.com`. This value is required with `docker_image_name`.
        :param str docker_registry_username: The User Name to use for authentication against the registry to pull the image.
        :param str dotnet_core_version: The version of .NET to use when `current_stack` is set to `dotnetcore`. Possible values include `v4.0`.
        :param str dotnet_version: The version of .NET to use when `current_stack` is set to `dotnet`. Possible values include `v2.0`,`v3.0`, `v4.0`, `v5.0`, `v6.0` and `v7.0`.
               
               > **NOTE:** The Portal displayed values and the actual underlying API values differ for this setting, as follows:
               Portal Value | API value
               :--|--:
               ASP.NET V3.5 | v2.0
               ASP.NET V4.8 | v4.0
               .NET 6 (LTS) | v6.0
               .NET 7 (STS) | v7.0
        :param bool java_embedded_server_enabled: Should the Java Embedded Server (Java SE) be used to run the app.
        :param str java_version: The version of Java to use when `current_stack` is set to `java`. 
               
               > **NOTE:** For currently supported versions, please see the official documentation. Some example values include: `1.8`, `1.8.0_322`,  `11`, `11.0.14`, `17` and `17.0.2`
        :param str node_version: The version of node to use when `current_stack` is set to `node`. Possible values are `~12`, `~14`, `~16`, and `~18`.
               
               > **NOTE:** This property conflicts with `java_version`.
        :param str php_version: The version of PHP to use when `current_stack` is set to `php`. Possible values are `7.1`, `7.4` and `Off`.
               
               > **NOTE:** The value `Off` is used to signify latest supported by the service.
        :param bool python: Specifies whether this is a Python app. Defaults to `false`.
        :param str tomcat_version: The version of Tomcat the Java App should use. Conflicts with `java_embedded_server_enabled`
               
               > **NOTE:** See the official documentation for current supported versions.  Some example valuess include: `10.0`, `10.0.20`.
        """
        if current_stack is not None:
            pulumi.set(__self__, "current_stack", current_stack)
        if docker_container_name is not None:
            pulumi.set(__self__, "docker_container_name", docker_container_name)
        if docker_container_registry is not None:
            pulumi.set(__self__, "docker_container_registry", docker_container_registry)
        if docker_container_tag is not None:
            pulumi.set(__self__, "docker_container_tag", docker_container_tag)
        if docker_image_name is not None:
            pulumi.set(__self__, "docker_image_name", docker_image_name)
        if docker_registry_password is not None:
            pulumi.set(__self__, "docker_registry_password", docker_registry_password)
        if docker_registry_url is not None:
            pulumi.set(__self__, "docker_registry_url", docker_registry_url)
        if docker_registry_username is not None:
            pulumi.set(__self__, "docker_registry_username", docker_registry_username)
        if dotnet_core_version is not None:
            pulumi.set(__self__, "dotnet_core_version", dotnet_core_version)
        if dotnet_version is not None:
            pulumi.set(__self__, "dotnet_version", dotnet_version)
        if java_container is not None:
            pulumi.set(__self__, "java_container", java_container)
        if java_container_version is not None:
            pulumi.set(__self__, "java_container_version", java_container_version)
        if java_embedded_server_enabled is not None:
            pulumi.set(__self__, "java_embedded_server_enabled", java_embedded_server_enabled)
        if java_version is not None:
            pulumi.set(__self__, "java_version", java_version)
        if node_version is not None:
            pulumi.set(__self__, "node_version", node_version)
        if php_version is not None:
            pulumi.set(__self__, "php_version", php_version)
        if python is not None:
            pulumi.set(__self__, "python", python)
        if python_version is not None:
            pulumi.set(__self__, "python_version", python_version)
        if tomcat_version is not None:
            pulumi.set(__self__, "tomcat_version", tomcat_version)

    @property
    @pulumi.getter(name="currentStack")
    def current_stack(self) -> Optional[str]:
        """
        The Application Stack for the Windows Web App. Possible values include `dotnet`, `dotnetcore`, `node`, `python`, `php`, and `java`.

        > **NOTE:** Whilst this property is Optional omitting it can cause unexpected behaviour, in particular for display of settings in the Azure Portal.
        """
        return pulumi.get(self, "current_stack")

    @property
    @pulumi.getter(name="dockerContainerName")
    def docker_container_name(self) -> Optional[str]:
        return pulumi.get(self, "docker_container_name")

    @property
    @pulumi.getter(name="dockerContainerRegistry")
    def docker_container_registry(self) -> Optional[str]:
        warnings.warn("""This property has been deprecated and will be removed in a future release of the provider.""", DeprecationWarning)
        pulumi.log.warn("""docker_container_registry is deprecated: This property has been deprecated and will be removed in a future release of the provider.""")

        return pulumi.get(self, "docker_container_registry")

    @property
    @pulumi.getter(name="dockerContainerTag")
    def docker_container_tag(self) -> Optional[str]:
        return pulumi.get(self, "docker_container_tag")

    @property
    @pulumi.getter(name="dockerImageName")
    def docker_image_name(self) -> Optional[str]:
        """
        The docker image, including tag, to be used. e.g. `azure-app-service/windows/parkingpage:latest`.
        """
        return pulumi.get(self, "docker_image_name")

    @property
    @pulumi.getter(name="dockerRegistryPassword")
    def docker_registry_password(self) -> Optional[str]:
        """
        The User Name to use for authentication against the registry to pull the image.

        > **NOTE:** `docker_registry_url`, `docker_registry_username`, and `docker_registry_password` replace the use of the `app_settings` values of `DOCKER_REGISTRY_SERVER_URL`, `DOCKER_REGISTRY_SERVER_USERNAME` and `DOCKER_REGISTRY_SERVER_PASSWORD` respectively, these values will be managed by the provider and should not be specified in the `app_settings` map.
        """
        return pulumi.get(self, "docker_registry_password")

    @property
    @pulumi.getter(name="dockerRegistryUrl")
    def docker_registry_url(self) -> Optional[str]:
        """
        The URL of the container registry where the `docker_image_name` is located. e.g. `https://index.docker.io` or `https://mcr.microsoft.com`. This value is required with `docker_image_name`.
        """
        return pulumi.get(self, "docker_registry_url")

    @property
    @pulumi.getter(name="dockerRegistryUsername")
    def docker_registry_username(self) -> Optional[str]:
        """
        The User Name to use for authentication against the registry to pull the image.
        """
        return pulumi.get(self, "docker_registry_username")

    @property
    @pulumi.getter(name="dotnetCoreVersion")
    def dotnet_core_version(self) -> Optional[str]:
        """
        The version of .NET to use when `current_stack` is set to `dotnetcore`. Possible values include `v4.0`.
        """
        return pulumi.get(self, "dotnet_core_version")

    @property
    @pulumi.getter(name="dotnetVersion")
    def dotnet_version(self) -> Optional[str]:
        """
        The version of .NET to use when `current_stack` is set to `dotnet`. Possible values include `v2.0`,`v3.0`, `v4.0`, `v5.0`, `v6.0` and `v7.0`.

        > **NOTE:** The Portal displayed values and the actual underlying API values differ for this setting, as follows:
        Portal Value | API value
        :--|--:
        ASP.NET V3.5 | v2.0
        ASP.NET V4.8 | v4.0
        .NET 6 (LTS) | v6.0
        .NET 7 (STS) | v7.0
        """
        return pulumi.get(self, "dotnet_version")

    @property
    @pulumi.getter(name="javaContainer")
    def java_container(self) -> Optional[str]:
        warnings.warn("""this property has been deprecated in favour of `tomcat_version` and `java_embedded_server_enabled`""", DeprecationWarning)
        pulumi.log.warn("""java_container is deprecated: this property has been deprecated in favour of `tomcat_version` and `java_embedded_server_enabled`""")

        return pulumi.get(self, "java_container")

    @property
    @pulumi.getter(name="javaContainerVersion")
    def java_container_version(self) -> Optional[str]:
        warnings.warn("""This property has been deprecated in favour of `tomcat_version` and `java_embedded_server_enabled`""", DeprecationWarning)
        pulumi.log.warn("""java_container_version is deprecated: This property has been deprecated in favour of `tomcat_version` and `java_embedded_server_enabled`""")

        return pulumi.get(self, "java_container_version")

    @property
    @pulumi.getter(name="javaEmbeddedServerEnabled")
    def java_embedded_server_enabled(self) -> Optional[bool]:
        """
        Should the Java Embedded Server (Java SE) be used to run the app.
        """
        return pulumi.get(self, "java_embedded_server_enabled")

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> Optional[str]:
        """
        The version of Java to use when `current_stack` is set to `java`. 

        > **NOTE:** For currently supported versions, please see the official documentation. Some example values include: `1.8`, `1.8.0_322`,  `11`, `11.0.14`, `17` and `17.0.2`
        """
        return pulumi.get(self, "java_version")

    @property
    @pulumi.getter(name="nodeVersion")
    def node_version(self) -> Optional[str]:
        """
        The version of node to use when `current_stack` is set to `node`. Possible values are `~12`, `~14`, `~16`, and `~18`.

        > **NOTE:** This property conflicts with `java_version`.
        """
        return pulumi.get(self, "node_version")

    @property
    @pulumi.getter(name="phpVersion")
    def php_version(self) -> Optional[str]:
        """
        The version of PHP to use when `current_stack` is set to `php`. Possible values are `7.1`, `7.4` and `Off`.

        > **NOTE:** The value `Off` is used to signify latest supported by the service.
        """
        return pulumi.get(self, "php_version")

    @property
    @pulumi.getter
    def python(self) -> Optional[bool]:
        """
        Specifies whether this is a Python app. Defaults to `false`.
        """
        return pulumi.get(self, "python")

    @property
    @pulumi.getter(name="pythonVersion")
    def python_version(self) -> Optional[str]:
        warnings.warn("""This property is deprecated. Values set are not used by the service.""", DeprecationWarning)
        pulumi.log.warn("""python_version is deprecated: This property is deprecated. Values set are not used by the service.""")

        return pulumi.get(self, "python_version")

    @property
    @pulumi.getter(name="tomcatVersion")
    def tomcat_version(self) -> Optional[str]:
        """
        The version of Tomcat the Java App should use. Conflicts with `java_embedded_server_enabled`

        > **NOTE:** See the official documentation for current supported versions.  Some example valuess include: `10.0`, `10.0.20`.
        """
        return pulumi.get(self, "tomcat_version")


@pulumi.output_type
class WindowsWebAppSiteConfigAutoHealSetting(dict):
    def __init__(__self__, *,
                 action: 'outputs.WindowsWebAppSiteConfigAutoHealSettingAction',
                 trigger: 'outputs.WindowsWebAppSiteConfigAutoHealSettingTrigger'):
        """
        :param 'WindowsWebAppSiteConfigAutoHealSettingActionArgs' action: An `action` block as defined above.
        :param 'WindowsWebAppSiteConfigAutoHealSettingTriggerArgs' trigger: A `trigger` block as defined below.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "trigger", trigger)

    @property
    @pulumi.getter
    def action(self) -> 'outputs.WindowsWebAppSiteConfigAutoHealSettingAction':
        """
        An `action` block as defined above.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def trigger(self) -> 'outputs.WindowsWebAppSiteConfigAutoHealSettingTrigger':
        """
        A `trigger` block as defined below.
        """
        return pulumi.get(self, "trigger")


@pulumi.output_type
class WindowsWebAppSiteConfigAutoHealSettingAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionType":
            suggest = "action_type"
        elif key == "customAction":
            suggest = "custom_action"
        elif key == "minimumProcessExecutionTime":
            suggest = "minimum_process_execution_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSiteConfigAutoHealSettingAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSiteConfigAutoHealSettingAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSiteConfigAutoHealSettingAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_type: str,
                 custom_action: Optional['outputs.WindowsWebAppSiteConfigAutoHealSettingActionCustomAction'] = None,
                 minimum_process_execution_time: Optional[str] = None):
        """
        :param str action_type: Predefined action to be taken to an Auto Heal trigger. Possible values include: `Recycle`, `LogEvent`, and `CustomAction`.
        :param 'WindowsWebAppSiteConfigAutoHealSettingActionCustomActionArgs' custom_action: A `custom_action` block as defined below.
        :param str minimum_process_execution_time: The minimum amount of time in `hh:mm:ss` the Windows Web App must have been running before the defined action will be run in the event of a trigger.
        """
        pulumi.set(__self__, "action_type", action_type)
        if custom_action is not None:
            pulumi.set(__self__, "custom_action", custom_action)
        if minimum_process_execution_time is not None:
            pulumi.set(__self__, "minimum_process_execution_time", minimum_process_execution_time)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> str:
        """
        Predefined action to be taken to an Auto Heal trigger. Possible values include: `Recycle`, `LogEvent`, and `CustomAction`.
        """
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter(name="customAction")
    def custom_action(self) -> Optional['outputs.WindowsWebAppSiteConfigAutoHealSettingActionCustomAction']:
        """
        A `custom_action` block as defined below.
        """
        return pulumi.get(self, "custom_action")

    @property
    @pulumi.getter(name="minimumProcessExecutionTime")
    def minimum_process_execution_time(self) -> Optional[str]:
        """
        The minimum amount of time in `hh:mm:ss` the Windows Web App must have been running before the defined action will be run in the event of a trigger.
        """
        return pulumi.get(self, "minimum_process_execution_time")


@pulumi.output_type
class WindowsWebAppSiteConfigAutoHealSettingActionCustomAction(dict):
    def __init__(__self__, *,
                 executable: str,
                 parameters: Optional[str] = None):
        """
        :param str executable: The executable to run for the `custom_action`.
        :param str parameters: The parameters to pass to the specified `executable`.
        """
        pulumi.set(__self__, "executable", executable)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def executable(self) -> str:
        """
        The executable to run for the `custom_action`.
        """
        return pulumi.get(self, "executable")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[str]:
        """
        The parameters to pass to the specified `executable`.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class WindowsWebAppSiteConfigAutoHealSettingTrigger(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateMemoryKb":
            suggest = "private_memory_kb"
        elif key == "slowRequests":
            suggest = "slow_requests"
        elif key == "statusCodes":
            suggest = "status_codes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSiteConfigAutoHealSettingTrigger. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSiteConfigAutoHealSettingTrigger.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSiteConfigAutoHealSettingTrigger.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_memory_kb: Optional[int] = None,
                 requests: Optional['outputs.WindowsWebAppSiteConfigAutoHealSettingTriggerRequests'] = None,
                 slow_requests: Optional[Sequence['outputs.WindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequest']] = None,
                 status_codes: Optional[Sequence['outputs.WindowsWebAppSiteConfigAutoHealSettingTriggerStatusCode']] = None):
        """
        :param int private_memory_kb: The amount of Private Memory to be consumed for this rule to trigger. Possible values are between `102400` and `13631488`.
        :param 'WindowsWebAppSiteConfigAutoHealSettingTriggerRequestsArgs' requests: A `requests` block as defined above.
        :param Sequence['WindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequestArgs'] slow_requests: One or more `slow_request` blocks as defined above.
        :param Sequence['WindowsWebAppSiteConfigAutoHealSettingTriggerStatusCodeArgs'] status_codes: One or more `status_code` blocks as defined above.
        """
        if private_memory_kb is not None:
            pulumi.set(__self__, "private_memory_kb", private_memory_kb)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if slow_requests is not None:
            pulumi.set(__self__, "slow_requests", slow_requests)
        if status_codes is not None:
            pulumi.set(__self__, "status_codes", status_codes)

    @property
    @pulumi.getter(name="privateMemoryKb")
    def private_memory_kb(self) -> Optional[int]:
        """
        The amount of Private Memory to be consumed for this rule to trigger. Possible values are between `102400` and `13631488`.
        """
        return pulumi.get(self, "private_memory_kb")

    @property
    @pulumi.getter
    def requests(self) -> Optional['outputs.WindowsWebAppSiteConfigAutoHealSettingTriggerRequests']:
        """
        A `requests` block as defined above.
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="slowRequests")
    def slow_requests(self) -> Optional[Sequence['outputs.WindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequest']]:
        """
        One or more `slow_request` blocks as defined above.
        """
        return pulumi.get(self, "slow_requests")

    @property
    @pulumi.getter(name="statusCodes")
    def status_codes(self) -> Optional[Sequence['outputs.WindowsWebAppSiteConfigAutoHealSettingTriggerStatusCode']]:
        """
        One or more `status_code` blocks as defined above.
        """
        return pulumi.get(self, "status_codes")


@pulumi.output_type
class WindowsWebAppSiteConfigAutoHealSettingTriggerRequests(dict):
    def __init__(__self__, *,
                 count: int,
                 interval: str):
        """
        :param int count: The number of requests in the specified `interval` to trigger this rule.
        :param str interval: The interval in `hh:mm:ss`.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of requests in the specified `interval` to trigger this rule.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        The interval in `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class WindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeTaken":
            suggest = "time_taken"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: int,
                 interval: str,
                 time_taken: str,
                 path: Optional[str] = None):
        """
        :param int count: The number of Slow Requests in the time `interval` to trigger this rule.
        :param str interval: The time interval in the form `hh:mm:ss`.
        :param str time_taken: The threshold of time passed to qualify as a Slow Request in `hh:mm:ss`.
        :param str path: The path for which this slow request rule applies.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "time_taken", time_taken)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of Slow Requests in the time `interval` to trigger this rule.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        The time interval in the form `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="timeTaken")
    def time_taken(self) -> str:
        """
        The threshold of time passed to qualify as a Slow Request in `hh:mm:ss`.
        """
        return pulumi.get(self, "time_taken")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path for which this slow request rule applies.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class WindowsWebAppSiteConfigAutoHealSettingTriggerStatusCode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusCodeRange":
            suggest = "status_code_range"
        elif key == "subStatus":
            suggest = "sub_status"
        elif key == "win32StatusCode":
            suggest = "win32_status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSiteConfigAutoHealSettingTriggerStatusCode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSiteConfigAutoHealSettingTriggerStatusCode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSiteConfigAutoHealSettingTriggerStatusCode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: int,
                 interval: str,
                 status_code_range: str,
                 path: Optional[str] = None,
                 sub_status: Optional[int] = None,
                 win32_status_code: Optional[int] = None):
        """
        :param int count: The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        :param str interval: The time interval in the form `hh:mm:ss`.
        :param str status_code_range: The status code for this rule, accepts single status codes and status code ranges. e.g. `500` or `400-499`. Possible values are integers between `101` and `599`
        :param str path: The path to which this rule status code applies.
        :param int sub_status: The Request Sub Status of the Status Code.
        :param int win32_status_code: The Win32 Status Code of the Request.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "status_code_range", status_code_range)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if sub_status is not None:
            pulumi.set(__self__, "sub_status", sub_status)
        if win32_status_code is not None:
            pulumi.set(__self__, "win32_status_code", win32_status_code)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        The time interval in the form `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="statusCodeRange")
    def status_code_range(self) -> str:
        """
        The status code for this rule, accepts single status codes and status code ranges. e.g. `500` or `400-499`. Possible values are integers between `101` and `599`
        """
        return pulumi.get(self, "status_code_range")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path to which this rule status code applies.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="subStatus")
    def sub_status(self) -> Optional[int]:
        """
        The Request Sub Status of the Status Code.
        """
        return pulumi.get(self, "sub_status")

    @property
    @pulumi.getter(name="win32StatusCode")
    def win32_status_code(self) -> Optional[int]:
        """
        The Win32 Status Code of the Request.
        """
        return pulumi.get(self, "win32_status_code")


@pulumi.output_type
class WindowsWebAppSiteConfigCors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedOrigins":
            suggest = "allowed_origins"
        elif key == "supportCredentials":
            suggest = "support_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSiteConfigCors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSiteConfigCors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSiteConfigCors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_origins: Optional[Sequence[str]] = None,
                 support_credentials: Optional[bool] = None):
        """
        :param Sequence[str] allowed_origins: Specifies a list of origins that should be allowed to make cross-origin calls.
        :param bool support_credentials: Whether CORS requests with credentials are allowed. Defaults to `false`
        """
        if allowed_origins is not None:
            pulumi.set(__self__, "allowed_origins", allowed_origins)
        if support_credentials is not None:
            pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of origins that should be allowed to make cross-origin calls.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> Optional[bool]:
        """
        Whether CORS requests with credentials are allowed. Defaults to `false`
        """
        return pulumi.get(self, "support_credentials")


@pulumi.output_type
class WindowsWebAppSiteConfigIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSiteConfigIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSiteConfigIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSiteConfigIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.WindowsWebAppSiteConfigIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: The action to take. Possible values are `Allow` or `Deny`.
        :param 'WindowsWebAppSiteConfigIpRestrictionHeadersArgs' headers: A `headers` block as defined above.
        :param str ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param str name: The name which should be used for this `ip_restriction`.
        :param int priority: The priority value of this `ip_restriction`. Defaults to `65000`.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
               
               > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        The action to take. Possible values are `Allow` or `Deny`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.WindowsWebAppSiteConfigIpRestrictionHeaders']:
        """
        A `headers` block as defined above.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class WindowsWebAppSiteConfigIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSiteConfigIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param str x_fd_health_probe: Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        :param Sequence[str] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param Sequence[str] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class WindowsWebAppSiteConfigScmIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSiteConfigScmIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSiteConfigScmIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSiteConfigScmIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.WindowsWebAppSiteConfigScmIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: The action to take. Possible values are `Allow` or `Deny`.
        :param 'WindowsWebAppSiteConfigScmIpRestrictionHeadersArgs' headers: A `headers` block as defined above.
        :param str ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param str name: The name which should be used for this `ip_restriction`.
        :param int priority: The priority value of this `ip_restriction`. Defaults to `65000`.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
               
               > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        The action to take. Possible values are `Allow` or `Deny`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.WindowsWebAppSiteConfigScmIpRestrictionHeaders']:
        """
        A `headers` block as defined above.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class WindowsWebAppSiteConfigScmIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSiteConfigScmIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param str x_fd_health_probe: Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        :param Sequence[str] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param Sequence[str] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class WindowsWebAppSiteConfigVirtualApplication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "physicalPath":
            suggest = "physical_path"
        elif key == "virtualPath":
            suggest = "virtual_path"
        elif key == "virtualDirectories":
            suggest = "virtual_directories"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSiteConfigVirtualApplication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSiteConfigVirtualApplication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSiteConfigVirtualApplication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 physical_path: str,
                 preload: bool,
                 virtual_path: str,
                 virtual_directories: Optional[Sequence['outputs.WindowsWebAppSiteConfigVirtualApplicationVirtualDirectory']] = None):
        """
        :param str physical_path: The physical path for the Virtual Application.
        :param bool preload: Should pre-loading be enabled.
        :param str virtual_path: The Virtual Path for the Virtual Application.
        :param Sequence['WindowsWebAppSiteConfigVirtualApplicationVirtualDirectoryArgs'] virtual_directories: One or more `virtual_directory` blocks as defined below.
        """
        pulumi.set(__self__, "physical_path", physical_path)
        pulumi.set(__self__, "preload", preload)
        pulumi.set(__self__, "virtual_path", virtual_path)
        if virtual_directories is not None:
            pulumi.set(__self__, "virtual_directories", virtual_directories)

    @property
    @pulumi.getter(name="physicalPath")
    def physical_path(self) -> str:
        """
        The physical path for the Virtual Application.
        """
        return pulumi.get(self, "physical_path")

    @property
    @pulumi.getter
    def preload(self) -> bool:
        """
        Should pre-loading be enabled.
        """
        return pulumi.get(self, "preload")

    @property
    @pulumi.getter(name="virtualPath")
    def virtual_path(self) -> str:
        """
        The Virtual Path for the Virtual Application.
        """
        return pulumi.get(self, "virtual_path")

    @property
    @pulumi.getter(name="virtualDirectories")
    def virtual_directories(self) -> Optional[Sequence['outputs.WindowsWebAppSiteConfigVirtualApplicationVirtualDirectory']]:
        """
        One or more `virtual_directory` blocks as defined below.
        """
        return pulumi.get(self, "virtual_directories")


@pulumi.output_type
class WindowsWebAppSiteConfigVirtualApplicationVirtualDirectory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "physicalPath":
            suggest = "physical_path"
        elif key == "virtualPath":
            suggest = "virtual_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSiteConfigVirtualApplicationVirtualDirectory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSiteConfigVirtualApplicationVirtualDirectory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSiteConfigVirtualApplicationVirtualDirectory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 physical_path: Optional[str] = None,
                 virtual_path: Optional[str] = None):
        """
        :param str physical_path: The physical path for the Virtual Application.
        :param str virtual_path: The Virtual Path for the Virtual Application.
        """
        if physical_path is not None:
            pulumi.set(__self__, "physical_path", physical_path)
        if virtual_path is not None:
            pulumi.set(__self__, "virtual_path", virtual_path)

    @property
    @pulumi.getter(name="physicalPath")
    def physical_path(self) -> Optional[str]:
        """
        The physical path for the Virtual Application.
        """
        return pulumi.get(self, "physical_path")

    @property
    @pulumi.getter(name="virtualPath")
    def virtual_path(self) -> Optional[str]:
        """
        The Virtual Path for the Virtual Application.
        """
        return pulumi.get(self, "virtual_path")


@pulumi.output_type
class WindowsWebAppSiteCredential(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 password: Optional[str] = None):
        """
        :param str name: The name which should be used for this Windows Web App. Changing this forces a new Windows Web App to be created.
        :param str password: The Site Credentials Password used for publishing.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name which should be used for this Windows Web App. Changing this forces a new Windows Web App to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The Site Credentials Password used for publishing.
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class WindowsWebAppSlotAuthSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeDirectory":
            suggest = "active_directory"
        elif key == "additionalLoginParameters":
            suggest = "additional_login_parameters"
        elif key == "allowedExternalRedirectUrls":
            suggest = "allowed_external_redirect_urls"
        elif key == "defaultProvider":
            suggest = "default_provider"
        elif key == "runtimeVersion":
            suggest = "runtime_version"
        elif key == "tokenRefreshExtensionHours":
            suggest = "token_refresh_extension_hours"
        elif key == "tokenStoreEnabled":
            suggest = "token_store_enabled"
        elif key == "unauthenticatedClientAction":
            suggest = "unauthenticated_client_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotAuthSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotAuthSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotAuthSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 active_directory: Optional['outputs.WindowsWebAppSlotAuthSettingsActiveDirectory'] = None,
                 additional_login_parameters: Optional[Mapping[str, str]] = None,
                 allowed_external_redirect_urls: Optional[Sequence[str]] = None,
                 default_provider: Optional[str] = None,
                 facebook: Optional['outputs.WindowsWebAppSlotAuthSettingsFacebook'] = None,
                 github: Optional['outputs.WindowsWebAppSlotAuthSettingsGithub'] = None,
                 google: Optional['outputs.WindowsWebAppSlotAuthSettingsGoogle'] = None,
                 issuer: Optional[str] = None,
                 microsoft: Optional['outputs.WindowsWebAppSlotAuthSettingsMicrosoft'] = None,
                 runtime_version: Optional[str] = None,
                 token_refresh_extension_hours: Optional[float] = None,
                 token_store_enabled: Optional[bool] = None,
                 twitter: Optional['outputs.WindowsWebAppSlotAuthSettingsTwitter'] = None,
                 unauthenticated_client_action: Optional[str] = None):
        """
        :param bool enabled: Should the Authentication / Authorization feature be enabled for the Windows Web App?
        :param 'WindowsWebAppSlotAuthSettingsActiveDirectoryArgs' active_directory: An `active_directory` block as defined above.
        :param Mapping[str, str] additional_login_parameters: Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        :param Sequence[str] allowed_external_redirect_urls: Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Windows Web App Slot.
        :param str default_provider: The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.
               
               > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        :param 'WindowsWebAppSlotAuthSettingsFacebookArgs' facebook: A `facebook` block as defined below.
        :param 'WindowsWebAppSlotAuthSettingsGithubArgs' github: A `github` block as defined below.
        :param 'WindowsWebAppSlotAuthSettingsGoogleArgs' google: A `google` block as defined below.
        :param str issuer: The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Windows Web App Slot.
               
               > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        :param 'WindowsWebAppSlotAuthSettingsMicrosoftArgs' microsoft: A `microsoft` block as defined below.
        :param str runtime_version: The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        :param float token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        :param bool token_store_enabled: Should the Windows Web App Slot durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        :param 'WindowsWebAppSlotAuthSettingsTwitterArgs' twitter: A `twitter` block as defined below.
        :param str unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if active_directory is not None:
            pulumi.set(__self__, "active_directory", active_directory)
        if additional_login_parameters is not None:
            pulumi.set(__self__, "additional_login_parameters", additional_login_parameters)
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if facebook is not None:
            pulumi.set(__self__, "facebook", facebook)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if google is not None:
            pulumi.set(__self__, "google", google)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if microsoft is not None:
            pulumi.set(__self__, "microsoft", microsoft)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if token_refresh_extension_hours is not None:
            pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if twitter is not None:
            pulumi.set(__self__, "twitter", twitter)
        if unauthenticated_client_action is not None:
            pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Should the Authentication / Authorization feature be enabled for the Windows Web App?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="activeDirectory")
    def active_directory(self) -> Optional['outputs.WindowsWebAppSlotAuthSettingsActiveDirectory']:
        """
        An `active_directory` block as defined above.
        """
        return pulumi.get(self, "active_directory")

    @property
    @pulumi.getter(name="additionalLoginParameters")
    def additional_login_parameters(self) -> Optional[Mapping[str, str]]:
        """
        Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        """
        return pulumi.get(self, "additional_login_parameters")

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Windows Web App Slot.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[str]:
        """
        The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.

        > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        """
        return pulumi.get(self, "default_provider")

    @property
    @pulumi.getter
    def facebook(self) -> Optional['outputs.WindowsWebAppSlotAuthSettingsFacebook']:
        """
        A `facebook` block as defined below.
        """
        return pulumi.get(self, "facebook")

    @property
    @pulumi.getter
    def github(self) -> Optional['outputs.WindowsWebAppSlotAuthSettingsGithub']:
        """
        A `github` block as defined below.
        """
        return pulumi.get(self, "github")

    @property
    @pulumi.getter
    def google(self) -> Optional['outputs.WindowsWebAppSlotAuthSettingsGoogle']:
        """
        A `google` block as defined below.
        """
        return pulumi.get(self, "google")

    @property
    @pulumi.getter
    def issuer(self) -> Optional[str]:
        """
        The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Windows Web App Slot.

        > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def microsoft(self) -> Optional['outputs.WindowsWebAppSlotAuthSettingsMicrosoft']:
        """
        A `microsoft` block as defined below.
        """
        return pulumi.get(self, "microsoft")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[str]:
        """
        The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> Optional[float]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        return pulumi.get(self, "token_refresh_extension_hours")

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[bool]:
        """
        Should the Windows Web App Slot durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        """
        return pulumi.get(self, "token_store_enabled")

    @property
    @pulumi.getter
    def twitter(self) -> Optional['outputs.WindowsWebAppSlotAuthSettingsTwitter']:
        """
        A `twitter` block as defined below.
        """
        return pulumi.get(self, "twitter")

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> Optional[str]:
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        return pulumi.get(self, "unauthenticated_client_action")


@pulumi.output_type
class WindowsWebAppSlotAuthSettingsActiveDirectory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotAuthSettingsActiveDirectory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotAuthSettingsActiveDirectory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotAuthSettingsActiveDirectory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param Sequence[str] allowed_audiences: Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
               
               > **Note:** The `client_id` value is always considered an allowed audience, so should not be included.
        :param str client_secret: The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        pulumi.set(__self__, "client_id", client_id)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **Note:** The `client_id` value is always considered an allowed audience, so should not be included.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")


@pulumi.output_type
class WindowsWebAppSlotAuthSettingsFacebook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "appSecret":
            suggest = "app_secret"
        elif key == "appSecretSettingName":
            suggest = "app_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotAuthSettingsFacebook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotAuthSettingsFacebook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotAuthSettingsFacebook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: str,
                 app_secret: Optional[str] = None,
                 app_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str app_id: The App ID of the Facebook app used for login.
        :param str app_secret: The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        :param str app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        if app_secret is not None:
            pulumi.set(__self__, "app_secret", app_secret)
        if app_secret_setting_name is not None:
            pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appSecret")
    def app_secret(self) -> Optional[str]:
        """
        The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        """
        return pulumi.get(self, "app_secret")

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class WindowsWebAppSlotAuthSettingsGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotAuthSettingsGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotAuthSettingsGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotAuthSettingsGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the GitHub app used for login.
        :param str client_secret: The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the GitHub app used for login.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class WindowsWebAppSlotAuthSettingsGoogle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotAuthSettingsGoogle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotAuthSettingsGoogle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotAuthSettingsGoogle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OpenID Connect Client ID for the Google web application.
        :param str client_secret: The client secret associated with the Google web application. Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OpenID Connect Client ID for the Google web application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The client secret associated with the Google web application. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class WindowsWebAppSlotAuthSettingsMicrosoft(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotAuthSettingsMicrosoft. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotAuthSettingsMicrosoft.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotAuthSettingsMicrosoft.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret: The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, "wl.basic" is used as the default scope.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, "wl.basic" is used as the default scope.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class WindowsWebAppSlotAuthSettingsTwitter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerKey":
            suggest = "consumer_key"
        elif key == "consumerSecret":
            suggest = "consumer_secret"
        elif key == "consumerSecretSettingName":
            suggest = "consumer_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotAuthSettingsTwitter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotAuthSettingsTwitter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotAuthSettingsTwitter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_key: str,
                 consumer_secret: Optional[str] = None,
                 consumer_secret_setting_name: Optional[str] = None):
        """
        :param str consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param str consumer_secret: The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        :param str consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        if consumer_secret is not None:
            pulumi.set(__self__, "consumer_secret", consumer_secret)
        if consumer_secret_setting_name is not None:
            pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> str:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> Optional[str]:
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        """
        return pulumi.get(self, "consumer_secret")

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        return pulumi.get(self, "consumer_secret_setting_name")


@pulumi.output_type
class WindowsWebAppSlotAuthSettingsV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeDirectoryV2":
            suggest = "active_directory_v2"
        elif key == "appleV2":
            suggest = "apple_v2"
        elif key == "authEnabled":
            suggest = "auth_enabled"
        elif key == "azureStaticWebAppV2":
            suggest = "azure_static_web_app_v2"
        elif key == "configFilePath":
            suggest = "config_file_path"
        elif key == "customOidcV2s":
            suggest = "custom_oidc_v2s"
        elif key == "defaultProvider":
            suggest = "default_provider"
        elif key == "excludedPaths":
            suggest = "excluded_paths"
        elif key == "facebookV2":
            suggest = "facebook_v2"
        elif key == "forwardProxyConvention":
            suggest = "forward_proxy_convention"
        elif key == "forwardProxyCustomHostHeaderName":
            suggest = "forward_proxy_custom_host_header_name"
        elif key == "forwardProxyCustomSchemeHeaderName":
            suggest = "forward_proxy_custom_scheme_header_name"
        elif key == "githubV2":
            suggest = "github_v2"
        elif key == "googleV2":
            suggest = "google_v2"
        elif key == "httpRouteApiPrefix":
            suggest = "http_route_api_prefix"
        elif key == "microsoftV2":
            suggest = "microsoft_v2"
        elif key == "requireAuthentication":
            suggest = "require_authentication"
        elif key == "requireHttps":
            suggest = "require_https"
        elif key == "runtimeVersion":
            suggest = "runtime_version"
        elif key == "twitterV2":
            suggest = "twitter_v2"
        elif key == "unauthenticatedAction":
            suggest = "unauthenticated_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotAuthSettingsV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotAuthSettingsV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotAuthSettingsV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 login: 'outputs.WindowsWebAppSlotAuthSettingsV2Login',
                 active_directory_v2: Optional['outputs.WindowsWebAppSlotAuthSettingsV2ActiveDirectoryV2'] = None,
                 apple_v2: Optional['outputs.WindowsWebAppSlotAuthSettingsV2AppleV2'] = None,
                 auth_enabled: Optional[bool] = None,
                 azure_static_web_app_v2: Optional['outputs.WindowsWebAppSlotAuthSettingsV2AzureStaticWebAppV2'] = None,
                 config_file_path: Optional[str] = None,
                 custom_oidc_v2s: Optional[Sequence['outputs.WindowsWebAppSlotAuthSettingsV2CustomOidcV2']] = None,
                 default_provider: Optional[str] = None,
                 excluded_paths: Optional[Sequence[str]] = None,
                 facebook_v2: Optional['outputs.WindowsWebAppSlotAuthSettingsV2FacebookV2'] = None,
                 forward_proxy_convention: Optional[str] = None,
                 forward_proxy_custom_host_header_name: Optional[str] = None,
                 forward_proxy_custom_scheme_header_name: Optional[str] = None,
                 github_v2: Optional['outputs.WindowsWebAppSlotAuthSettingsV2GithubV2'] = None,
                 google_v2: Optional['outputs.WindowsWebAppSlotAuthSettingsV2GoogleV2'] = None,
                 http_route_api_prefix: Optional[str] = None,
                 microsoft_v2: Optional['outputs.WindowsWebAppSlotAuthSettingsV2MicrosoftV2'] = None,
                 require_authentication: Optional[bool] = None,
                 require_https: Optional[bool] = None,
                 runtime_version: Optional[str] = None,
                 twitter_v2: Optional['outputs.WindowsWebAppSlotAuthSettingsV2TwitterV2'] = None,
                 unauthenticated_action: Optional[str] = None):
        """
        :param 'WindowsWebAppSlotAuthSettingsV2LoginArgs' login: A `login` block as defined below.
        :param 'WindowsWebAppSlotAuthSettingsV2ActiveDirectoryV2Args' active_directory_v2: An `active_directory_v2` block as defined below.
        :param 'WindowsWebAppSlotAuthSettingsV2AppleV2Args' apple_v2: An `apple_v2` block as defined below.
        :param bool auth_enabled: Should the AuthV2 Settings be enabled. Defaults to `false`.
        :param 'WindowsWebAppSlotAuthSettingsV2AzureStaticWebAppV2Args' azure_static_web_app_v2: An `azure_static_web_app_v2` block as defined below.
        :param str config_file_path: The path to the App Auth settings.
               
               * > **Note:** Relative Paths are evaluated from the Site Root directory.
        :param Sequence['WindowsWebAppSlotAuthSettingsV2CustomOidcV2Args'] custom_oidc_v2s: Zero or more `custom_oidc_v2` blocks as defined below.
        :param str default_provider: The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.
               
               > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        :param Sequence[str] excluded_paths: The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.
               
               > **NOTE:** This list should be used instead of setting `WEBSITE_WARMUP_PATH` in `app_settings` as it takes priority.
        :param 'WindowsWebAppSlotAuthSettingsV2FacebookV2Args' facebook_v2: A `facebook_v2` block as defined below.
        :param str forward_proxy_convention: The convention used to determine the url of the request made. Possible values include `NoProxy`, `Standard`, `Custom`. Defaults to `NoProxy`.
        :param str forward_proxy_custom_host_header_name: The name of the custom header containing the host of the request.
        :param str forward_proxy_custom_scheme_header_name: The name of the custom header containing the scheme of the request.
        :param 'WindowsWebAppSlotAuthSettingsV2GithubV2Args' github_v2: A `github_v2` block as defined below.
        :param 'WindowsWebAppSlotAuthSettingsV2GoogleV2Args' google_v2: A `google_v2` block as defined below.
        :param str http_route_api_prefix: The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
        :param 'WindowsWebAppSlotAuthSettingsV2MicrosoftV2Args' microsoft_v2: A `microsoft_v2` block as defined below.
        :param bool require_authentication: Should the authentication flow be used for all requests.
        :param bool require_https: Should HTTPS be required on connections? Defaults to `true`.
        :param str runtime_version: The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        :param 'WindowsWebAppSlotAuthSettingsV2TwitterV2Args' twitter_v2: A `twitter_v2` block as defined below.
        :param str unauthenticated_action: The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
        """
        pulumi.set(__self__, "login", login)
        if active_directory_v2 is not None:
            pulumi.set(__self__, "active_directory_v2", active_directory_v2)
        if apple_v2 is not None:
            pulumi.set(__self__, "apple_v2", apple_v2)
        if auth_enabled is not None:
            pulumi.set(__self__, "auth_enabled", auth_enabled)
        if azure_static_web_app_v2 is not None:
            pulumi.set(__self__, "azure_static_web_app_v2", azure_static_web_app_v2)
        if config_file_path is not None:
            pulumi.set(__self__, "config_file_path", config_file_path)
        if custom_oidc_v2s is not None:
            pulumi.set(__self__, "custom_oidc_v2s", custom_oidc_v2s)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if excluded_paths is not None:
            pulumi.set(__self__, "excluded_paths", excluded_paths)
        if facebook_v2 is not None:
            pulumi.set(__self__, "facebook_v2", facebook_v2)
        if forward_proxy_convention is not None:
            pulumi.set(__self__, "forward_proxy_convention", forward_proxy_convention)
        if forward_proxy_custom_host_header_name is not None:
            pulumi.set(__self__, "forward_proxy_custom_host_header_name", forward_proxy_custom_host_header_name)
        if forward_proxy_custom_scheme_header_name is not None:
            pulumi.set(__self__, "forward_proxy_custom_scheme_header_name", forward_proxy_custom_scheme_header_name)
        if github_v2 is not None:
            pulumi.set(__self__, "github_v2", github_v2)
        if google_v2 is not None:
            pulumi.set(__self__, "google_v2", google_v2)
        if http_route_api_prefix is not None:
            pulumi.set(__self__, "http_route_api_prefix", http_route_api_prefix)
        if microsoft_v2 is not None:
            pulumi.set(__self__, "microsoft_v2", microsoft_v2)
        if require_authentication is not None:
            pulumi.set(__self__, "require_authentication", require_authentication)
        if require_https is not None:
            pulumi.set(__self__, "require_https", require_https)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if twitter_v2 is not None:
            pulumi.set(__self__, "twitter_v2", twitter_v2)
        if unauthenticated_action is not None:
            pulumi.set(__self__, "unauthenticated_action", unauthenticated_action)

    @property
    @pulumi.getter
    def login(self) -> 'outputs.WindowsWebAppSlotAuthSettingsV2Login':
        """
        A `login` block as defined below.
        """
        return pulumi.get(self, "login")

    @property
    @pulumi.getter(name="activeDirectoryV2")
    def active_directory_v2(self) -> Optional['outputs.WindowsWebAppSlotAuthSettingsV2ActiveDirectoryV2']:
        """
        An `active_directory_v2` block as defined below.
        """
        return pulumi.get(self, "active_directory_v2")

    @property
    @pulumi.getter(name="appleV2")
    def apple_v2(self) -> Optional['outputs.WindowsWebAppSlotAuthSettingsV2AppleV2']:
        """
        An `apple_v2` block as defined below.
        """
        return pulumi.get(self, "apple_v2")

    @property
    @pulumi.getter(name="authEnabled")
    def auth_enabled(self) -> Optional[bool]:
        """
        Should the AuthV2 Settings be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "auth_enabled")

    @property
    @pulumi.getter(name="azureStaticWebAppV2")
    def azure_static_web_app_v2(self) -> Optional['outputs.WindowsWebAppSlotAuthSettingsV2AzureStaticWebAppV2']:
        """
        An `azure_static_web_app_v2` block as defined below.
        """
        return pulumi.get(self, "azure_static_web_app_v2")

    @property
    @pulumi.getter(name="configFilePath")
    def config_file_path(self) -> Optional[str]:
        """
        The path to the App Auth settings.

        * > **Note:** Relative Paths are evaluated from the Site Root directory.
        """
        return pulumi.get(self, "config_file_path")

    @property
    @pulumi.getter(name="customOidcV2s")
    def custom_oidc_v2s(self) -> Optional[Sequence['outputs.WindowsWebAppSlotAuthSettingsV2CustomOidcV2']]:
        """
        Zero or more `custom_oidc_v2` blocks as defined below.
        """
        return pulumi.get(self, "custom_oidc_v2s")

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[str]:
        """
        The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.

        > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        """
        return pulumi.get(self, "default_provider")

    @property
    @pulumi.getter(name="excludedPaths")
    def excluded_paths(self) -> Optional[Sequence[str]]:
        """
        The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.

        > **NOTE:** This list should be used instead of setting `WEBSITE_WARMUP_PATH` in `app_settings` as it takes priority.
        """
        return pulumi.get(self, "excluded_paths")

    @property
    @pulumi.getter(name="facebookV2")
    def facebook_v2(self) -> Optional['outputs.WindowsWebAppSlotAuthSettingsV2FacebookV2']:
        """
        A `facebook_v2` block as defined below.
        """
        return pulumi.get(self, "facebook_v2")

    @property
    @pulumi.getter(name="forwardProxyConvention")
    def forward_proxy_convention(self) -> Optional[str]:
        """
        The convention used to determine the url of the request made. Possible values include `NoProxy`, `Standard`, `Custom`. Defaults to `NoProxy`.
        """
        return pulumi.get(self, "forward_proxy_convention")

    @property
    @pulumi.getter(name="forwardProxyCustomHostHeaderName")
    def forward_proxy_custom_host_header_name(self) -> Optional[str]:
        """
        The name of the custom header containing the host of the request.
        """
        return pulumi.get(self, "forward_proxy_custom_host_header_name")

    @property
    @pulumi.getter(name="forwardProxyCustomSchemeHeaderName")
    def forward_proxy_custom_scheme_header_name(self) -> Optional[str]:
        """
        The name of the custom header containing the scheme of the request.
        """
        return pulumi.get(self, "forward_proxy_custom_scheme_header_name")

    @property
    @pulumi.getter(name="githubV2")
    def github_v2(self) -> Optional['outputs.WindowsWebAppSlotAuthSettingsV2GithubV2']:
        """
        A `github_v2` block as defined below.
        """
        return pulumi.get(self, "github_v2")

    @property
    @pulumi.getter(name="googleV2")
    def google_v2(self) -> Optional['outputs.WindowsWebAppSlotAuthSettingsV2GoogleV2']:
        """
        A `google_v2` block as defined below.
        """
        return pulumi.get(self, "google_v2")

    @property
    @pulumi.getter(name="httpRouteApiPrefix")
    def http_route_api_prefix(self) -> Optional[str]:
        """
        The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
        """
        return pulumi.get(self, "http_route_api_prefix")

    @property
    @pulumi.getter(name="microsoftV2")
    def microsoft_v2(self) -> Optional['outputs.WindowsWebAppSlotAuthSettingsV2MicrosoftV2']:
        """
        A `microsoft_v2` block as defined below.
        """
        return pulumi.get(self, "microsoft_v2")

    @property
    @pulumi.getter(name="requireAuthentication")
    def require_authentication(self) -> Optional[bool]:
        """
        Should the authentication flow be used for all requests.
        """
        return pulumi.get(self, "require_authentication")

    @property
    @pulumi.getter(name="requireHttps")
    def require_https(self) -> Optional[bool]:
        """
        Should HTTPS be required on connections? Defaults to `true`.
        """
        return pulumi.get(self, "require_https")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[str]:
        """
        The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter(name="twitterV2")
    def twitter_v2(self) -> Optional['outputs.WindowsWebAppSlotAuthSettingsV2TwitterV2']:
        """
        A `twitter_v2` block as defined below.
        """
        return pulumi.get(self, "twitter_v2")

    @property
    @pulumi.getter(name="unauthenticatedAction")
    def unauthenticated_action(self) -> Optional[str]:
        """
        The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
        """
        return pulumi.get(self, "unauthenticated_action")


@pulumi.output_type
class WindowsWebAppSlotAuthSettingsV2ActiveDirectoryV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "tenantAuthEndpoint":
            suggest = "tenant_auth_endpoint"
        elif key == "allowedApplications":
            suggest = "allowed_applications"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "allowedGroups":
            suggest = "allowed_groups"
        elif key == "allowedIdentities":
            suggest = "allowed_identities"
        elif key == "clientSecretCertificateThumbprint":
            suggest = "client_secret_certificate_thumbprint"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "jwtAllowedClientApplications":
            suggest = "jwt_allowed_client_applications"
        elif key == "jwtAllowedGroups":
            suggest = "jwt_allowed_groups"
        elif key == "loginParameters":
            suggest = "login_parameters"
        elif key == "wwwAuthenticationDisabled":
            suggest = "www_authentication_disabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotAuthSettingsV2ActiveDirectoryV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotAuthSettingsV2ActiveDirectoryV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotAuthSettingsV2ActiveDirectoryV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 tenant_auth_endpoint: str,
                 allowed_applications: Optional[Sequence[str]] = None,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 allowed_groups: Optional[Sequence[str]] = None,
                 allowed_identities: Optional[Sequence[str]] = None,
                 client_secret_certificate_thumbprint: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 jwt_allowed_client_applications: Optional[Sequence[str]] = None,
                 jwt_allowed_groups: Optional[Sequence[str]] = None,
                 login_parameters: Optional[Mapping[str, str]] = None,
                 www_authentication_disabled: Optional[bool] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str tenant_auth_endpoint: The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`
        :param Sequence[str] allowed_applications: The list of allowed Applications for the Default Authorisation Policy.
        :param Sequence[str] allowed_audiences: Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
               
               > **Note:** The `client_id` value is always considered an allowed audience, so should not be included.
        :param Sequence[str] allowed_groups: The list of allowed Group Names for the Default Authorisation Policy.
        :param Sequence[str] allowed_identities: The list of allowed Identities for the Default Authorisation Policy.
        :param str client_secret_certificate_thumbprint: The thumbprint of the certificate used for signing purposes.
               
               > **NOTE:** One of `client_secret_setting_name` or `client_secret_certificate_thumbprint` must be specified.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param Sequence[str] jwt_allowed_client_applications: A list of Allowed Client Applications in the JWT Claim.
        :param Sequence[str] jwt_allowed_groups: A list of Allowed Groups in the JWT Claim.
        :param Mapping[str, str] login_parameters: A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
        :param bool www_authentication_disabled: Should the www-authenticate provider should be omitted from the request? Defaults to `false`
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "tenant_auth_endpoint", tenant_auth_endpoint)
        if allowed_applications is not None:
            pulumi.set(__self__, "allowed_applications", allowed_applications)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if allowed_groups is not None:
            pulumi.set(__self__, "allowed_groups", allowed_groups)
        if allowed_identities is not None:
            pulumi.set(__self__, "allowed_identities", allowed_identities)
        if client_secret_certificate_thumbprint is not None:
            pulumi.set(__self__, "client_secret_certificate_thumbprint", client_secret_certificate_thumbprint)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if jwt_allowed_client_applications is not None:
            pulumi.set(__self__, "jwt_allowed_client_applications", jwt_allowed_client_applications)
        if jwt_allowed_groups is not None:
            pulumi.set(__self__, "jwt_allowed_groups", jwt_allowed_groups)
        if login_parameters is not None:
            pulumi.set(__self__, "login_parameters", login_parameters)
        if www_authentication_disabled is not None:
            pulumi.set(__self__, "www_authentication_disabled", www_authentication_disabled)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="tenantAuthEndpoint")
    def tenant_auth_endpoint(self) -> str:
        """
        The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`
        """
        return pulumi.get(self, "tenant_auth_endpoint")

    @property
    @pulumi.getter(name="allowedApplications")
    def allowed_applications(self) -> Optional[Sequence[str]]:
        """
        The list of allowed Applications for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_applications")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **Note:** The `client_id` value is always considered an allowed audience, so should not be included.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="allowedGroups")
    def allowed_groups(self) -> Optional[Sequence[str]]:
        """
        The list of allowed Group Names for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_groups")

    @property
    @pulumi.getter(name="allowedIdentities")
    def allowed_identities(self) -> Optional[Sequence[str]]:
        """
        The list of allowed Identities for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_identities")

    @property
    @pulumi.getter(name="clientSecretCertificateThumbprint")
    def client_secret_certificate_thumbprint(self) -> Optional[str]:
        """
        The thumbprint of the certificate used for signing purposes.

        > **NOTE:** One of `client_secret_setting_name` or `client_secret_certificate_thumbprint` must be specified.
        """
        return pulumi.get(self, "client_secret_certificate_thumbprint")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="jwtAllowedClientApplications")
    def jwt_allowed_client_applications(self) -> Optional[Sequence[str]]:
        """
        A list of Allowed Client Applications in the JWT Claim.
        """
        return pulumi.get(self, "jwt_allowed_client_applications")

    @property
    @pulumi.getter(name="jwtAllowedGroups")
    def jwt_allowed_groups(self) -> Optional[Sequence[str]]:
        """
        A list of Allowed Groups in the JWT Claim.
        """
        return pulumi.get(self, "jwt_allowed_groups")

    @property
    @pulumi.getter(name="loginParameters")
    def login_parameters(self) -> Optional[Mapping[str, str]]:
        """
        A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
        """
        return pulumi.get(self, "login_parameters")

    @property
    @pulumi.getter(name="wwwAuthenticationDisabled")
    def www_authentication_disabled(self) -> Optional[bool]:
        """
        Should the www-authenticate provider should be omitted from the request? Defaults to `false`
        """
        return pulumi.get(self, "www_authentication_disabled")


@pulumi.output_type
class WindowsWebAppSlotAuthSettingsV2AppleV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "loginScopes":
            suggest = "login_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotAuthSettingsV2AppleV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotAuthSettingsV2AppleV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotAuthSettingsV2AppleV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret_setting_name: str,
                 login_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param Sequence[str] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[Sequence[str]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class WindowsWebAppSlotAuthSettingsV2AzureStaticWebAppV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotAuthSettingsV2AzureStaticWebAppV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotAuthSettingsV2AzureStaticWebAppV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotAuthSettingsV2AzureStaticWebAppV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        """
        pulumi.set(__self__, "client_id", client_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")


@pulumi.output_type
class WindowsWebAppSlotAuthSettingsV2CustomOidcV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "openidConfigurationEndpoint":
            suggest = "openid_configuration_endpoint"
        elif key == "authorisationEndpoint":
            suggest = "authorisation_endpoint"
        elif key == "certificationUri":
            suggest = "certification_uri"
        elif key == "clientCredentialMethod":
            suggest = "client_credential_method"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "issuerEndpoint":
            suggest = "issuer_endpoint"
        elif key == "nameClaimType":
            suggest = "name_claim_type"
        elif key == "tokenEndpoint":
            suggest = "token_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotAuthSettingsV2CustomOidcV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotAuthSettingsV2CustomOidcV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotAuthSettingsV2CustomOidcV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 name: str,
                 openid_configuration_endpoint: str,
                 authorisation_endpoint: Optional[str] = None,
                 certification_uri: Optional[str] = None,
                 client_credential_method: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 issuer_endpoint: Optional[str] = None,
                 name_claim_type: Optional[str] = None,
                 scopes: Optional[Sequence[str]] = None,
                 token_endpoint: Optional[str] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str openid_configuration_endpoint: The app setting name that contains the `client_secret` value used for the Custom OIDC Login.
        :param str authorisation_endpoint: The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        :param str certification_uri: The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        :param str client_credential_method: The Client Credential Method used.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param str issuer_endpoint: The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        :param str name_claim_type: The name of the claim that contains the users name.
        :param Sequence[str] scopes: The list of the scopes that should be requested while authenticating.
        :param str token_endpoint: The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "openid_configuration_endpoint", openid_configuration_endpoint)
        if authorisation_endpoint is not None:
            pulumi.set(__self__, "authorisation_endpoint", authorisation_endpoint)
        if certification_uri is not None:
            pulumi.set(__self__, "certification_uri", certification_uri)
        if client_credential_method is not None:
            pulumi.set(__self__, "client_credential_method", client_credential_method)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if issuer_endpoint is not None:
            pulumi.set(__self__, "issuer_endpoint", issuer_endpoint)
        if name_claim_type is not None:
            pulumi.set(__self__, "name_claim_type", name_claim_type)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="openidConfigurationEndpoint")
    def openid_configuration_endpoint(self) -> str:
        """
        The app setting name that contains the `client_secret` value used for the Custom OIDC Login.
        """
        return pulumi.get(self, "openid_configuration_endpoint")

    @property
    @pulumi.getter(name="authorisationEndpoint")
    def authorisation_endpoint(self) -> Optional[str]:
        """
        The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "authorisation_endpoint")

    @property
    @pulumi.getter(name="certificationUri")
    def certification_uri(self) -> Optional[str]:
        """
        The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "certification_uri")

    @property
    @pulumi.getter(name="clientCredentialMethod")
    def client_credential_method(self) -> Optional[str]:
        """
        The Client Credential Method used.
        """
        return pulumi.get(self, "client_credential_method")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="issuerEndpoint")
    def issuer_endpoint(self) -> Optional[str]:
        """
        The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "issuer_endpoint")

    @property
    @pulumi.getter(name="nameClaimType")
    def name_claim_type(self) -> Optional[str]:
        """
        The name of the claim that contains the users name.
        """
        return pulumi.get(self, "name_claim_type")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[str]]:
        """
        The list of the scopes that should be requested while authenticating.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[str]:
        """
        The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "token_endpoint")


@pulumi.output_type
class WindowsWebAppSlotAuthSettingsV2FacebookV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "appSecretSettingName":
            suggest = "app_secret_setting_name"
        elif key == "graphApiVersion":
            suggest = "graph_api_version"
        elif key == "loginScopes":
            suggest = "login_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotAuthSettingsV2FacebookV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotAuthSettingsV2FacebookV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotAuthSettingsV2FacebookV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: str,
                 app_secret_setting_name: str,
                 graph_api_version: Optional[str] = None,
                 login_scopes: Optional[Sequence[str]] = None):
        """
        :param str app_id: The App ID of the Facebook app used for login.
        :param str app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook Login.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param str graph_api_version: The version of the Facebook API to be used while logging in.
        :param Sequence[str] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        if graph_api_version is not None:
            pulumi.set(__self__, "graph_api_version", graph_api_version)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> str:
        """
        The app setting name that contains the `app_secret` value used for Facebook Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @property
    @pulumi.getter(name="graphApiVersion")
    def graph_api_version(self) -> Optional[str]:
        """
        The version of the Facebook API to be used while logging in.
        """
        return pulumi.get(self, "graph_api_version")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[Sequence[str]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class WindowsWebAppSlotAuthSettingsV2GithubV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "loginScopes":
            suggest = "login_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotAuthSettingsV2GithubV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotAuthSettingsV2GithubV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotAuthSettingsV2GithubV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret_setting_name: str,
                 login_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param Sequence[str] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[Sequence[str]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class WindowsWebAppSlotAuthSettingsV2GoogleV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "loginScopes":
            suggest = "login_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotAuthSettingsV2GoogleV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotAuthSettingsV2GoogleV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotAuthSettingsV2GoogleV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret_setting_name: str,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 login_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param Sequence[str] allowed_audiences: Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
               
               > **Note:** The `client_id` value is always considered an allowed audience, so should not be included.
        :param Sequence[str] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **Note:** The `client_id` value is always considered an allowed audience, so should not be included.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[Sequence[str]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class WindowsWebAppSlotAuthSettingsV2Login(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedExternalRedirectUrls":
            suggest = "allowed_external_redirect_urls"
        elif key == "cookieExpirationConvention":
            suggest = "cookie_expiration_convention"
        elif key == "cookieExpirationTime":
            suggest = "cookie_expiration_time"
        elif key == "logoutEndpoint":
            suggest = "logout_endpoint"
        elif key == "nonceExpirationTime":
            suggest = "nonce_expiration_time"
        elif key == "preserveUrlFragmentsForLogins":
            suggest = "preserve_url_fragments_for_logins"
        elif key == "tokenRefreshExtensionTime":
            suggest = "token_refresh_extension_time"
        elif key == "tokenStoreEnabled":
            suggest = "token_store_enabled"
        elif key == "tokenStorePath":
            suggest = "token_store_path"
        elif key == "tokenStoreSasSettingName":
            suggest = "token_store_sas_setting_name"
        elif key == "validateNonce":
            suggest = "validate_nonce"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotAuthSettingsV2Login. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotAuthSettingsV2Login.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotAuthSettingsV2Login.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_external_redirect_urls: Optional[Sequence[str]] = None,
                 cookie_expiration_convention: Optional[str] = None,
                 cookie_expiration_time: Optional[str] = None,
                 logout_endpoint: Optional[str] = None,
                 nonce_expiration_time: Optional[str] = None,
                 preserve_url_fragments_for_logins: Optional[bool] = None,
                 token_refresh_extension_time: Optional[float] = None,
                 token_store_enabled: Optional[bool] = None,
                 token_store_path: Optional[str] = None,
                 token_store_sas_setting_name: Optional[str] = None,
                 validate_nonce: Optional[bool] = None):
        """
        :param Sequence[str] allowed_external_redirect_urls: External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends.
               
               * > **Note:** URLs within the current domain are always implicitly allowed.
        :param str cookie_expiration_convention: The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
        :param str cookie_expiration_time: The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
        :param str logout_endpoint: The endpoint to which logout requests should be made.
        :param str nonce_expiration_time: The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
        :param bool preserve_url_fragments_for_logins: Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
        :param float token_refresh_extension_time: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        :param bool token_store_enabled: Should the Token Store configuration Enabled. Defaults to `false`
        :param str token_store_path: The directory path in the App Filesystem in which the tokens will be stored.
        :param str token_store_sas_setting_name: The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        :param bool validate_nonce: Should the nonce be validated while completing the login flow. Defaults to `true`.
        """
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if cookie_expiration_convention is not None:
            pulumi.set(__self__, "cookie_expiration_convention", cookie_expiration_convention)
        if cookie_expiration_time is not None:
            pulumi.set(__self__, "cookie_expiration_time", cookie_expiration_time)
        if logout_endpoint is not None:
            pulumi.set(__self__, "logout_endpoint", logout_endpoint)
        if nonce_expiration_time is not None:
            pulumi.set(__self__, "nonce_expiration_time", nonce_expiration_time)
        if preserve_url_fragments_for_logins is not None:
            pulumi.set(__self__, "preserve_url_fragments_for_logins", preserve_url_fragments_for_logins)
        if token_refresh_extension_time is not None:
            pulumi.set(__self__, "token_refresh_extension_time", token_refresh_extension_time)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if token_store_path is not None:
            pulumi.set(__self__, "token_store_path", token_store_path)
        if token_store_sas_setting_name is not None:
            pulumi.set(__self__, "token_store_sas_setting_name", token_store_sas_setting_name)
        if validate_nonce is not None:
            pulumi.set(__self__, "validate_nonce", validate_nonce)

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[Sequence[str]]:
        """
        External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends.

        * > **Note:** URLs within the current domain are always implicitly allowed.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @property
    @pulumi.getter(name="cookieExpirationConvention")
    def cookie_expiration_convention(self) -> Optional[str]:
        """
        The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
        """
        return pulumi.get(self, "cookie_expiration_convention")

    @property
    @pulumi.getter(name="cookieExpirationTime")
    def cookie_expiration_time(self) -> Optional[str]:
        """
        The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
        """
        return pulumi.get(self, "cookie_expiration_time")

    @property
    @pulumi.getter(name="logoutEndpoint")
    def logout_endpoint(self) -> Optional[str]:
        """
        The endpoint to which logout requests should be made.
        """
        return pulumi.get(self, "logout_endpoint")

    @property
    @pulumi.getter(name="nonceExpirationTime")
    def nonce_expiration_time(self) -> Optional[str]:
        """
        The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
        """
        return pulumi.get(self, "nonce_expiration_time")

    @property
    @pulumi.getter(name="preserveUrlFragmentsForLogins")
    def preserve_url_fragments_for_logins(self) -> Optional[bool]:
        """
        Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
        """
        return pulumi.get(self, "preserve_url_fragments_for_logins")

    @property
    @pulumi.getter(name="tokenRefreshExtensionTime")
    def token_refresh_extension_time(self) -> Optional[float]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        return pulumi.get(self, "token_refresh_extension_time")

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[bool]:
        """
        Should the Token Store configuration Enabled. Defaults to `false`
        """
        return pulumi.get(self, "token_store_enabled")

    @property
    @pulumi.getter(name="tokenStorePath")
    def token_store_path(self) -> Optional[str]:
        """
        The directory path in the App Filesystem in which the tokens will be stored.
        """
        return pulumi.get(self, "token_store_path")

    @property
    @pulumi.getter(name="tokenStoreSasSettingName")
    def token_store_sas_setting_name(self) -> Optional[str]:
        """
        The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        """
        return pulumi.get(self, "token_store_sas_setting_name")

    @property
    @pulumi.getter(name="validateNonce")
    def validate_nonce(self) -> Optional[bool]:
        """
        Should the nonce be validated while completing the login flow. Defaults to `true`.
        """
        return pulumi.get(self, "validate_nonce")


@pulumi.output_type
class WindowsWebAppSlotAuthSettingsV2MicrosoftV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "loginScopes":
            suggest = "login_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotAuthSettingsV2MicrosoftV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotAuthSettingsV2MicrosoftV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotAuthSettingsV2MicrosoftV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret_setting_name: str,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 login_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        :param Sequence[str] allowed_audiences: Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
               
               > **Note:** The `client_id` value is always considered an allowed audience, so should not be included.
        :param Sequence[str] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **Note:** The `client_id` value is always considered an allowed audience, so should not be included.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[Sequence[str]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class WindowsWebAppSlotAuthSettingsV2TwitterV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerKey":
            suggest = "consumer_key"
        elif key == "consumerSecretSettingName":
            suggest = "consumer_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotAuthSettingsV2TwitterV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotAuthSettingsV2TwitterV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotAuthSettingsV2TwitterV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_key: str,
                 consumer_secret_setting_name: str):
        """
        :param str consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param str consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> str:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> str:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "consumer_secret_setting_name")


@pulumi.output_type
class WindowsWebAppSlotBackup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageAccountUrl":
            suggest = "storage_account_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotBackup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotBackup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotBackup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 schedule: 'outputs.WindowsWebAppSlotBackupSchedule',
                 storage_account_url: str,
                 enabled: Optional[bool] = None):
        """
        :param str name: The name which should be used for this Backup.
        :param 'WindowsWebAppSlotBackupScheduleArgs' schedule: A `schedule` block as defined below.
        :param str storage_account_url: The SAS URL to the container.
        :param bool enabled: Should this backup job be enabled? Defaults to `true`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "storage_account_url", storage_account_url)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Backup.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def schedule(self) -> 'outputs.WindowsWebAppSlotBackupSchedule':
        """
        A `schedule` block as defined below.
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter(name="storageAccountUrl")
    def storage_account_url(self) -> str:
        """
        The SAS URL to the container.
        """
        return pulumi.get(self, "storage_account_url")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Should this backup job be enabled? Defaults to `true`.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class WindowsWebAppSlotBackupSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "frequencyUnit":
            suggest = "frequency_unit"
        elif key == "keepAtLeastOneBackup":
            suggest = "keep_at_least_one_backup"
        elif key == "lastExecutionTime":
            suggest = "last_execution_time"
        elif key == "retentionPeriodDays":
            suggest = "retention_period_days"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotBackupSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotBackupSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotBackupSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_unit: str,
                 keep_at_least_one_backup: Optional[bool] = None,
                 last_execution_time: Optional[str] = None,
                 retention_period_days: Optional[int] = None,
                 start_time: Optional[str] = None):
        """
        :param int frequency_interval: How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).
               
               > **NOTE:** Not all intervals are supported on all Windows Web App SKUs. Please refer to the official documentation for appropriate values.
        :param str frequency_unit: The unit of time for how often the backup should take place. Possible values include: `Day`, `Hour`
        :param bool keep_at_least_one_backup: Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
        :param int retention_period_days: After how many days backups should be deleted. Defaults to `30`.
        :param str start_time: When the schedule should start working in RFC-3339 format.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_unit", frequency_unit)
        if keep_at_least_one_backup is not None:
            pulumi.set(__self__, "keep_at_least_one_backup", keep_at_least_one_backup)
        if last_execution_time is not None:
            pulumi.set(__self__, "last_execution_time", last_execution_time)
        if retention_period_days is not None:
            pulumi.set(__self__, "retention_period_days", retention_period_days)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).

        > **NOTE:** Not all intervals are supported on all Windows Web App SKUs. Please refer to the official documentation for appropriate values.
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyUnit")
    def frequency_unit(self) -> str:
        """
        The unit of time for how often the backup should take place. Possible values include: `Day`, `Hour`
        """
        return pulumi.get(self, "frequency_unit")

    @property
    @pulumi.getter(name="keepAtLeastOneBackup")
    def keep_at_least_one_backup(self) -> Optional[bool]:
        """
        Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
        """
        return pulumi.get(self, "keep_at_least_one_backup")

    @property
    @pulumi.getter(name="lastExecutionTime")
    def last_execution_time(self) -> Optional[str]:
        return pulumi.get(self, "last_execution_time")

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> Optional[int]:
        """
        After how many days backups should be deleted. Defaults to `30`.
        """
        return pulumi.get(self, "retention_period_days")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        """
        When the schedule should start working in RFC-3339 format.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class WindowsWebAppSlotConnectionString(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: The name of the connection String.
        :param str type: Type of database. Possible values include: `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
        :param str value: The connection string value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the connection String.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of database. Possible values include: `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The connection string value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class WindowsWebAppSlotIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 identity_ids: Optional[Sequence[str]] = None,
                 principal_id: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str type: Specifies the type of Managed Service Identity that should be configured on this Windows Web App Slot. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        :param Sequence[str] identity_ids: A list of User Assigned Managed Identity IDs to be assigned to this Windows Web App Slot.
               
               > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        :param str principal_id: The Principal ID associated with this Managed Service Identity.
        :param str tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the type of Managed Service Identity that should be configured on this Windows Web App Slot. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[str]]:
        """
        A list of User Assigned Managed Identity IDs to be assigned to this Windows Web App Slot.

        > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class WindowsWebAppSlotLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationLogs":
            suggest = "application_logs"
        elif key == "detailedErrorMessages":
            suggest = "detailed_error_messages"
        elif key == "failedRequestTracing":
            suggest = "failed_request_tracing"
        elif key == "httpLogs":
            suggest = "http_logs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_logs: Optional['outputs.WindowsWebAppSlotLogsApplicationLogs'] = None,
                 detailed_error_messages: Optional[bool] = None,
                 failed_request_tracing: Optional[bool] = None,
                 http_logs: Optional['outputs.WindowsWebAppSlotLogsHttpLogs'] = None):
        """
        :param 'WindowsWebAppSlotLogsApplicationLogsArgs' application_logs: A `application_logs` block as defined above.
        :param bool detailed_error_messages: Should detailed error messages be enabled.
        :param bool failed_request_tracing: Should failed request tracing be enabled.
        :param 'WindowsWebAppSlotLogsHttpLogsArgs' http_logs: An `http_logs` block as defined above.
        """
        if application_logs is not None:
            pulumi.set(__self__, "application_logs", application_logs)
        if detailed_error_messages is not None:
            pulumi.set(__self__, "detailed_error_messages", detailed_error_messages)
        if failed_request_tracing is not None:
            pulumi.set(__self__, "failed_request_tracing", failed_request_tracing)
        if http_logs is not None:
            pulumi.set(__self__, "http_logs", http_logs)

    @property
    @pulumi.getter(name="applicationLogs")
    def application_logs(self) -> Optional['outputs.WindowsWebAppSlotLogsApplicationLogs']:
        """
        A `application_logs` block as defined above.
        """
        return pulumi.get(self, "application_logs")

    @property
    @pulumi.getter(name="detailedErrorMessages")
    def detailed_error_messages(self) -> Optional[bool]:
        """
        Should detailed error messages be enabled.
        """
        return pulumi.get(self, "detailed_error_messages")

    @property
    @pulumi.getter(name="failedRequestTracing")
    def failed_request_tracing(self) -> Optional[bool]:
        """
        Should failed request tracing be enabled.
        """
        return pulumi.get(self, "failed_request_tracing")

    @property
    @pulumi.getter(name="httpLogs")
    def http_logs(self) -> Optional['outputs.WindowsWebAppSlotLogsHttpLogs']:
        """
        An `http_logs` block as defined above.
        """
        return pulumi.get(self, "http_logs")


@pulumi.output_type
class WindowsWebAppSlotLogsApplicationLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileSystemLevel":
            suggest = "file_system_level"
        elif key == "azureBlobStorage":
            suggest = "azure_blob_storage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotLogsApplicationLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotLogsApplicationLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotLogsApplicationLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_system_level: str,
                 azure_blob_storage: Optional['outputs.WindowsWebAppSlotLogsApplicationLogsAzureBlobStorage'] = None):
        """
        :param str file_system_level: Log level. Possible values include: `Verbose`, `Information`, `Warning`, and `Error`.
        :param 'WindowsWebAppSlotLogsApplicationLogsAzureBlobStorageArgs' azure_blob_storage: An `azure_blob_storage` block as defined below.
        """
        pulumi.set(__self__, "file_system_level", file_system_level)
        if azure_blob_storage is not None:
            pulumi.set(__self__, "azure_blob_storage", azure_blob_storage)

    @property
    @pulumi.getter(name="fileSystemLevel")
    def file_system_level(self) -> str:
        """
        Log level. Possible values include: `Verbose`, `Information`, `Warning`, and `Error`.
        """
        return pulumi.get(self, "file_system_level")

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional['outputs.WindowsWebAppSlotLogsApplicationLogsAzureBlobStorage']:
        """
        An `azure_blob_storage` block as defined below.
        """
        return pulumi.get(self, "azure_blob_storage")


@pulumi.output_type
class WindowsWebAppSlotLogsApplicationLogsAzureBlobStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retentionInDays":
            suggest = "retention_in_days"
        elif key == "sasUrl":
            suggest = "sas_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotLogsApplicationLogsAzureBlobStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotLogsApplicationLogsAzureBlobStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotLogsApplicationLogsAzureBlobStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 level: str,
                 retention_in_days: int,
                 sas_url: str):
        """
        :param str level: The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        :param int retention_in_days: The time in days after which to remove blobs. A value of `0` means no retention.
        :param str sas_url: SAS url to an Azure blob container with read/write/list/delete permissions.
        """
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "sas_url", sas_url)

    @property
    @pulumi.getter
    def level(self) -> str:
        """
        The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        """
        return pulumi.get(self, "level")

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> int:
        """
        The time in days after which to remove blobs. A value of `0` means no retention.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> str:
        """
        SAS url to an Azure blob container with read/write/list/delete permissions.
        """
        return pulumi.get(self, "sas_url")


@pulumi.output_type
class WindowsWebAppSlotLogsHttpLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureBlobStorage":
            suggest = "azure_blob_storage"
        elif key == "fileSystem":
            suggest = "file_system"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotLogsHttpLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotLogsHttpLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotLogsHttpLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_blob_storage: Optional['outputs.WindowsWebAppSlotLogsHttpLogsAzureBlobStorage'] = None,
                 file_system: Optional['outputs.WindowsWebAppSlotLogsHttpLogsFileSystem'] = None):
        """
        :param 'WindowsWebAppSlotLogsHttpLogsAzureBlobStorageArgs' azure_blob_storage: A `azure_blob_storage_http` block as defined above.
        :param 'WindowsWebAppSlotLogsHttpLogsFileSystemArgs' file_system: A `file_system` block as defined above.
        """
        if azure_blob_storage is not None:
            pulumi.set(__self__, "azure_blob_storage", azure_blob_storage)
        if file_system is not None:
            pulumi.set(__self__, "file_system", file_system)

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional['outputs.WindowsWebAppSlotLogsHttpLogsAzureBlobStorage']:
        """
        A `azure_blob_storage_http` block as defined above.
        """
        return pulumi.get(self, "azure_blob_storage")

    @property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional['outputs.WindowsWebAppSlotLogsHttpLogsFileSystem']:
        """
        A `file_system` block as defined above.
        """
        return pulumi.get(self, "file_system")


@pulumi.output_type
class WindowsWebAppSlotLogsHttpLogsAzureBlobStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sasUrl":
            suggest = "sas_url"
        elif key == "retentionInDays":
            suggest = "retention_in_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotLogsHttpLogsAzureBlobStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotLogsHttpLogsAzureBlobStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotLogsHttpLogsAzureBlobStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sas_url: str,
                 retention_in_days: Optional[int] = None):
        """
        :param str sas_url: SAS url to an Azure blob container with read/write/list/delete permissions.
        :param int retention_in_days: The time in days after which to remove blobs. A value of `0` means no retention.
        """
        pulumi.set(__self__, "sas_url", sas_url)
        if retention_in_days is not None:
            pulumi.set(__self__, "retention_in_days", retention_in_days)

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> str:
        """
        SAS url to an Azure blob container with read/write/list/delete permissions.
        """
        return pulumi.get(self, "sas_url")

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> Optional[int]:
        """
        The time in days after which to remove blobs. A value of `0` means no retention.
        """
        return pulumi.get(self, "retention_in_days")


@pulumi.output_type
class WindowsWebAppSlotLogsHttpLogsFileSystem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retentionInDays":
            suggest = "retention_in_days"
        elif key == "retentionInMb":
            suggest = "retention_in_mb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotLogsHttpLogsFileSystem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotLogsHttpLogsFileSystem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotLogsHttpLogsFileSystem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 retention_in_days: int,
                 retention_in_mb: int):
        """
        :param int retention_in_days: The retention period in days. A values of `0` means no retention.
        :param int retention_in_mb: The maximum size in megabytes that log files can use.
        """
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "retention_in_mb", retention_in_mb)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> int:
        """
        The retention period in days. A values of `0` means no retention.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="retentionInMb")
    def retention_in_mb(self) -> int:
        """
        The maximum size in megabytes that log files can use.
        """
        return pulumi.get(self, "retention_in_mb")


@pulumi.output_type
class WindowsWebAppSlotSiteConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alwaysOn":
            suggest = "always_on"
        elif key == "apiDefinitionUrl":
            suggest = "api_definition_url"
        elif key == "apiManagementApiId":
            suggest = "api_management_api_id"
        elif key == "appCommandLine":
            suggest = "app_command_line"
        elif key == "applicationStack":
            suggest = "application_stack"
        elif key == "autoHealEnabled":
            suggest = "auto_heal_enabled"
        elif key == "autoHealSetting":
            suggest = "auto_heal_setting"
        elif key == "autoSwapSlotName":
            suggest = "auto_swap_slot_name"
        elif key == "containerRegistryManagedIdentityClientId":
            suggest = "container_registry_managed_identity_client_id"
        elif key == "containerRegistryUseManagedIdentity":
            suggest = "container_registry_use_managed_identity"
        elif key == "defaultDocuments":
            suggest = "default_documents"
        elif key == "detailedErrorLoggingEnabled":
            suggest = "detailed_error_logging_enabled"
        elif key == "ftpsState":
            suggest = "ftps_state"
        elif key == "healthCheckEvictionTimeInMin":
            suggest = "health_check_eviction_time_in_min"
        elif key == "healthCheckPath":
            suggest = "health_check_path"
        elif key == "http2Enabled":
            suggest = "http2_enabled"
        elif key == "ipRestrictions":
            suggest = "ip_restrictions"
        elif key == "loadBalancingMode":
            suggest = "load_balancing_mode"
        elif key == "localMysqlEnabled":
            suggest = "local_mysql_enabled"
        elif key == "managedPipelineMode":
            suggest = "managed_pipeline_mode"
        elif key == "minimumTlsVersion":
            suggest = "minimum_tls_version"
        elif key == "remoteDebuggingEnabled":
            suggest = "remote_debugging_enabled"
        elif key == "remoteDebuggingVersion":
            suggest = "remote_debugging_version"
        elif key == "scmIpRestrictions":
            suggest = "scm_ip_restrictions"
        elif key == "scmMinimumTlsVersion":
            suggest = "scm_minimum_tls_version"
        elif key == "scmType":
            suggest = "scm_type"
        elif key == "scmUseMainIpRestriction":
            suggest = "scm_use_main_ip_restriction"
        elif key == "use32BitWorker":
            suggest = "use32_bit_worker"
        elif key == "virtualApplications":
            suggest = "virtual_applications"
        elif key == "vnetRouteAllEnabled":
            suggest = "vnet_route_all_enabled"
        elif key == "websocketsEnabled":
            suggest = "websockets_enabled"
        elif key == "windowsFxVersion":
            suggest = "windows_fx_version"
        elif key == "workerCount":
            suggest = "worker_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotSiteConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotSiteConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotSiteConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 always_on: Optional[bool] = None,
                 api_definition_url: Optional[str] = None,
                 api_management_api_id: Optional[str] = None,
                 app_command_line: Optional[str] = None,
                 application_stack: Optional['outputs.WindowsWebAppSlotSiteConfigApplicationStack'] = None,
                 auto_heal_enabled: Optional[bool] = None,
                 auto_heal_setting: Optional['outputs.WindowsWebAppSlotSiteConfigAutoHealSetting'] = None,
                 auto_swap_slot_name: Optional[str] = None,
                 container_registry_managed_identity_client_id: Optional[str] = None,
                 container_registry_use_managed_identity: Optional[bool] = None,
                 cors: Optional['outputs.WindowsWebAppSlotSiteConfigCors'] = None,
                 default_documents: Optional[Sequence[str]] = None,
                 detailed_error_logging_enabled: Optional[bool] = None,
                 ftps_state: Optional[str] = None,
                 health_check_eviction_time_in_min: Optional[int] = None,
                 health_check_path: Optional[str] = None,
                 http2_enabled: Optional[bool] = None,
                 ip_restrictions: Optional[Sequence['outputs.WindowsWebAppSlotSiteConfigIpRestriction']] = None,
                 load_balancing_mode: Optional[str] = None,
                 local_mysql_enabled: Optional[bool] = None,
                 managed_pipeline_mode: Optional[str] = None,
                 minimum_tls_version: Optional[str] = None,
                 remote_debugging_enabled: Optional[bool] = None,
                 remote_debugging_version: Optional[str] = None,
                 scm_ip_restrictions: Optional[Sequence['outputs.WindowsWebAppSlotSiteConfigScmIpRestriction']] = None,
                 scm_minimum_tls_version: Optional[str] = None,
                 scm_type: Optional[str] = None,
                 scm_use_main_ip_restriction: Optional[bool] = None,
                 use32_bit_worker: Optional[bool] = None,
                 virtual_applications: Optional[Sequence['outputs.WindowsWebAppSlotSiteConfigVirtualApplication']] = None,
                 vnet_route_all_enabled: Optional[bool] = None,
                 websockets_enabled: Optional[bool] = None,
                 windows_fx_version: Optional[str] = None,
                 worker_count: Optional[int] = None):
        """
        :param bool always_on: If this Windows Web App Slot is Always On enabled. Defaults to `true`.
        :param str api_definition_url: The URL to the API Definition for this Windows Web App Slot.
        :param str api_management_api_id: The API Management API ID this Windows Web App Slot os associated with.
        :param str app_command_line: The App command line to launch.
        :param 'WindowsWebAppSlotSiteConfigApplicationStackArgs' application_stack: A `application_stack` block as defined above.
        :param bool auto_heal_enabled: Should Auto heal rules be enabled. Required with `auto_heal_setting`.
        :param 'WindowsWebAppSlotSiteConfigAutoHealSettingArgs' auto_heal_setting: A `auto_heal_setting` block as defined above. Required with `auto_heal`.
        :param str auto_swap_slot_name: The Windows Web App Slot Name to automatically swap to when deployment to that slot is successfully completed.
               
               > **Note:** This must be a valid slot name on the target Windows Web App Slot.
        :param str container_registry_managed_identity_client_id: The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
        :param bool container_registry_use_managed_identity: Should connections for Azure Container Registry use Managed Identity.
        :param 'WindowsWebAppSlotSiteConfigCorsArgs' cors: A `cors` block as defined above.
        :param Sequence[str] default_documents: Specifies a list of Default Documents for the Windows Web App Slot.
        :param int health_check_eviction_time_in_min: The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        :param str health_check_path: The path to the Health Check.
        :param bool http2_enabled: Should the HTTP2 be enabled?
        :param Sequence['WindowsWebAppSlotSiteConfigIpRestrictionArgs'] ip_restrictions: One or more `ip_restriction` blocks as defined above.
        :param str load_balancing_mode: The Site load balancing. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        :param bool local_mysql_enabled: Use Local MySQL. Defaults to `false`.
        :param str managed_pipeline_mode: Managed pipeline mode. Possible values include: `Integrated`, `Classic`.
        :param str minimum_tls_version: The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        :param bool remote_debugging_enabled: Should Remote Debugging be enabled. Defaults to `false`.
        :param str remote_debugging_version: The Remote Debugging Version. Possible values include `VS2017` and `VS2019`
        :param Sequence['WindowsWebAppSlotSiteConfigScmIpRestrictionArgs'] scm_ip_restrictions: One or more `scm_ip_restriction` blocks as defined above.
        :param str scm_minimum_tls_version: The configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        :param bool scm_use_main_ip_restriction: Should the Windows Web App Slot `ip_restriction` configuration be used for the SCM also.
        :param bool use32_bit_worker: Should the Windows Web App Slotuse a 32-bit worker. Defaults to `true`.
        :param Sequence['WindowsWebAppSlotSiteConfigVirtualApplicationArgs'] virtual_applications: One or more `virtual_application` blocks as defined below.
        :param bool vnet_route_all_enabled: Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        :param bool websockets_enabled: Should Web Sockets be enabled. Defaults to `false`.
        :param int worker_count: The number of Workers for this Windows App Service Slot.
        """
        if always_on is not None:
            pulumi.set(__self__, "always_on", always_on)
        if api_definition_url is not None:
            pulumi.set(__self__, "api_definition_url", api_definition_url)
        if api_management_api_id is not None:
            pulumi.set(__self__, "api_management_api_id", api_management_api_id)
        if app_command_line is not None:
            pulumi.set(__self__, "app_command_line", app_command_line)
        if application_stack is not None:
            pulumi.set(__self__, "application_stack", application_stack)
        if auto_heal_enabled is not None:
            pulumi.set(__self__, "auto_heal_enabled", auto_heal_enabled)
        if auto_heal_setting is not None:
            pulumi.set(__self__, "auto_heal_setting", auto_heal_setting)
        if auto_swap_slot_name is not None:
            pulumi.set(__self__, "auto_swap_slot_name", auto_swap_slot_name)
        if container_registry_managed_identity_client_id is not None:
            pulumi.set(__self__, "container_registry_managed_identity_client_id", container_registry_managed_identity_client_id)
        if container_registry_use_managed_identity is not None:
            pulumi.set(__self__, "container_registry_use_managed_identity", container_registry_use_managed_identity)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if default_documents is not None:
            pulumi.set(__self__, "default_documents", default_documents)
        if detailed_error_logging_enabled is not None:
            pulumi.set(__self__, "detailed_error_logging_enabled", detailed_error_logging_enabled)
        if ftps_state is not None:
            pulumi.set(__self__, "ftps_state", ftps_state)
        if health_check_eviction_time_in_min is not None:
            pulumi.set(__self__, "health_check_eviction_time_in_min", health_check_eviction_time_in_min)
        if health_check_path is not None:
            pulumi.set(__self__, "health_check_path", health_check_path)
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if ip_restrictions is not None:
            pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        if load_balancing_mode is not None:
            pulumi.set(__self__, "load_balancing_mode", load_balancing_mode)
        if local_mysql_enabled is not None:
            pulumi.set(__self__, "local_mysql_enabled", local_mysql_enabled)
        if managed_pipeline_mode is not None:
            pulumi.set(__self__, "managed_pipeline_mode", managed_pipeline_mode)
        if minimum_tls_version is not None:
            pulumi.set(__self__, "minimum_tls_version", minimum_tls_version)
        if remote_debugging_enabled is not None:
            pulumi.set(__self__, "remote_debugging_enabled", remote_debugging_enabled)
        if remote_debugging_version is not None:
            pulumi.set(__self__, "remote_debugging_version", remote_debugging_version)
        if scm_ip_restrictions is not None:
            pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        if scm_minimum_tls_version is not None:
            pulumi.set(__self__, "scm_minimum_tls_version", scm_minimum_tls_version)
        if scm_type is not None:
            pulumi.set(__self__, "scm_type", scm_type)
        if scm_use_main_ip_restriction is not None:
            pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        if use32_bit_worker is not None:
            pulumi.set(__self__, "use32_bit_worker", use32_bit_worker)
        if virtual_applications is not None:
            pulumi.set(__self__, "virtual_applications", virtual_applications)
        if vnet_route_all_enabled is not None:
            pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        if websockets_enabled is not None:
            pulumi.set(__self__, "websockets_enabled", websockets_enabled)
        if windows_fx_version is not None:
            pulumi.set(__self__, "windows_fx_version", windows_fx_version)
        if worker_count is not None:
            pulumi.set(__self__, "worker_count", worker_count)

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> Optional[bool]:
        """
        If this Windows Web App Slot is Always On enabled. Defaults to `true`.
        """
        return pulumi.get(self, "always_on")

    @property
    @pulumi.getter(name="apiDefinitionUrl")
    def api_definition_url(self) -> Optional[str]:
        """
        The URL to the API Definition for this Windows Web App Slot.
        """
        return pulumi.get(self, "api_definition_url")

    @property
    @pulumi.getter(name="apiManagementApiId")
    def api_management_api_id(self) -> Optional[str]:
        """
        The API Management API ID this Windows Web App Slot os associated with.
        """
        return pulumi.get(self, "api_management_api_id")

    @property
    @pulumi.getter(name="appCommandLine")
    def app_command_line(self) -> Optional[str]:
        """
        The App command line to launch.
        """
        return pulumi.get(self, "app_command_line")

    @property
    @pulumi.getter(name="applicationStack")
    def application_stack(self) -> Optional['outputs.WindowsWebAppSlotSiteConfigApplicationStack']:
        """
        A `application_stack` block as defined above.
        """
        return pulumi.get(self, "application_stack")

    @property
    @pulumi.getter(name="autoHealEnabled")
    def auto_heal_enabled(self) -> Optional[bool]:
        """
        Should Auto heal rules be enabled. Required with `auto_heal_setting`.
        """
        return pulumi.get(self, "auto_heal_enabled")

    @property
    @pulumi.getter(name="autoHealSetting")
    def auto_heal_setting(self) -> Optional['outputs.WindowsWebAppSlotSiteConfigAutoHealSetting']:
        """
        A `auto_heal_setting` block as defined above. Required with `auto_heal`.
        """
        return pulumi.get(self, "auto_heal_setting")

    @property
    @pulumi.getter(name="autoSwapSlotName")
    def auto_swap_slot_name(self) -> Optional[str]:
        """
        The Windows Web App Slot Name to automatically swap to when deployment to that slot is successfully completed.

        > **Note:** This must be a valid slot name on the target Windows Web App Slot.
        """
        return pulumi.get(self, "auto_swap_slot_name")

    @property
    @pulumi.getter(name="containerRegistryManagedIdentityClientId")
    def container_registry_managed_identity_client_id(self) -> Optional[str]:
        """
        The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
        """
        return pulumi.get(self, "container_registry_managed_identity_client_id")

    @property
    @pulumi.getter(name="containerRegistryUseManagedIdentity")
    def container_registry_use_managed_identity(self) -> Optional[bool]:
        """
        Should connections for Azure Container Registry use Managed Identity.
        """
        return pulumi.get(self, "container_registry_use_managed_identity")

    @property
    @pulumi.getter
    def cors(self) -> Optional['outputs.WindowsWebAppSlotSiteConfigCors']:
        """
        A `cors` block as defined above.
        """
        return pulumi.get(self, "cors")

    @property
    @pulumi.getter(name="defaultDocuments")
    def default_documents(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Default Documents for the Windows Web App Slot.
        """
        return pulumi.get(self, "default_documents")

    @property
    @pulumi.getter(name="detailedErrorLoggingEnabled")
    def detailed_error_logging_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "detailed_error_logging_enabled")

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> Optional[str]:
        return pulumi.get(self, "ftps_state")

    @property
    @pulumi.getter(name="healthCheckEvictionTimeInMin")
    def health_check_eviction_time_in_min(self) -> Optional[int]:
        """
        The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        """
        return pulumi.get(self, "health_check_eviction_time_in_min")

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> Optional[str]:
        """
        The path to the Health Check.
        """
        return pulumi.get(self, "health_check_path")

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[bool]:
        """
        Should the HTTP2 be enabled?
        """
        return pulumi.get(self, "http2_enabled")

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Optional[Sequence['outputs.WindowsWebAppSlotSiteConfigIpRestriction']]:
        """
        One or more `ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "ip_restrictions")

    @property
    @pulumi.getter(name="loadBalancingMode")
    def load_balancing_mode(self) -> Optional[str]:
        """
        The Site load balancing. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        """
        return pulumi.get(self, "load_balancing_mode")

    @property
    @pulumi.getter(name="localMysqlEnabled")
    def local_mysql_enabled(self) -> Optional[bool]:
        """
        Use Local MySQL. Defaults to `false`.
        """
        return pulumi.get(self, "local_mysql_enabled")

    @property
    @pulumi.getter(name="managedPipelineMode")
    def managed_pipeline_mode(self) -> Optional[str]:
        """
        Managed pipeline mode. Possible values include: `Integrated`, `Classic`.
        """
        return pulumi.get(self, "managed_pipeline_mode")

    @property
    @pulumi.getter(name="minimumTlsVersion")
    def minimum_tls_version(self) -> Optional[str]:
        """
        The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        """
        return pulumi.get(self, "minimum_tls_version")

    @property
    @pulumi.getter(name="remoteDebuggingEnabled")
    def remote_debugging_enabled(self) -> Optional[bool]:
        """
        Should Remote Debugging be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "remote_debugging_enabled")

    @property
    @pulumi.getter(name="remoteDebuggingVersion")
    def remote_debugging_version(self) -> Optional[str]:
        """
        The Remote Debugging Version. Possible values include `VS2017` and `VS2019`
        """
        return pulumi.get(self, "remote_debugging_version")

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Optional[Sequence['outputs.WindowsWebAppSlotSiteConfigScmIpRestriction']]:
        """
        One or more `scm_ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "scm_ip_restrictions")

    @property
    @pulumi.getter(name="scmMinimumTlsVersion")
    def scm_minimum_tls_version(self) -> Optional[str]:
        """
        The configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        """
        return pulumi.get(self, "scm_minimum_tls_version")

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> Optional[str]:
        return pulumi.get(self, "scm_type")

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> Optional[bool]:
        """
        Should the Windows Web App Slot `ip_restriction` configuration be used for the SCM also.
        """
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @property
    @pulumi.getter(name="use32BitWorker")
    def use32_bit_worker(self) -> Optional[bool]:
        """
        Should the Windows Web App Slotuse a 32-bit worker. Defaults to `true`.
        """
        return pulumi.get(self, "use32_bit_worker")

    @property
    @pulumi.getter(name="virtualApplications")
    def virtual_applications(self) -> Optional[Sequence['outputs.WindowsWebAppSlotSiteConfigVirtualApplication']]:
        """
        One or more `virtual_application` blocks as defined below.
        """
        return pulumi.get(self, "virtual_applications")

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> Optional[bool]:
        """
        Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        """
        return pulumi.get(self, "vnet_route_all_enabled")

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> Optional[bool]:
        """
        Should Web Sockets be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "websockets_enabled")

    @property
    @pulumi.getter(name="windowsFxVersion")
    def windows_fx_version(self) -> Optional[str]:
        return pulumi.get(self, "windows_fx_version")

    @property
    @pulumi.getter(name="workerCount")
    def worker_count(self) -> Optional[int]:
        """
        The number of Workers for this Windows App Service Slot.
        """
        return pulumi.get(self, "worker_count")


@pulumi.output_type
class WindowsWebAppSlotSiteConfigApplicationStack(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "currentStack":
            suggest = "current_stack"
        elif key == "dockerContainerName":
            suggest = "docker_container_name"
        elif key == "dockerContainerRegistry":
            suggest = "docker_container_registry"
        elif key == "dockerContainerTag":
            suggest = "docker_container_tag"
        elif key == "dockerImageName":
            suggest = "docker_image_name"
        elif key == "dockerRegistryPassword":
            suggest = "docker_registry_password"
        elif key == "dockerRegistryUrl":
            suggest = "docker_registry_url"
        elif key == "dockerRegistryUsername":
            suggest = "docker_registry_username"
        elif key == "dotnetCoreVersion":
            suggest = "dotnet_core_version"
        elif key == "dotnetVersion":
            suggest = "dotnet_version"
        elif key == "javaContainer":
            suggest = "java_container"
        elif key == "javaContainerVersion":
            suggest = "java_container_version"
        elif key == "javaEmbeddedServerEnabled":
            suggest = "java_embedded_server_enabled"
        elif key == "javaVersion":
            suggest = "java_version"
        elif key == "nodeVersion":
            suggest = "node_version"
        elif key == "phpVersion":
            suggest = "php_version"
        elif key == "pythonVersion":
            suggest = "python_version"
        elif key == "tomcatVersion":
            suggest = "tomcat_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotSiteConfigApplicationStack. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotSiteConfigApplicationStack.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotSiteConfigApplicationStack.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 current_stack: Optional[str] = None,
                 docker_container_name: Optional[str] = None,
                 docker_container_registry: Optional[str] = None,
                 docker_container_tag: Optional[str] = None,
                 docker_image_name: Optional[str] = None,
                 docker_registry_password: Optional[str] = None,
                 docker_registry_url: Optional[str] = None,
                 docker_registry_username: Optional[str] = None,
                 dotnet_core_version: Optional[str] = None,
                 dotnet_version: Optional[str] = None,
                 java_container: Optional[str] = None,
                 java_container_version: Optional[str] = None,
                 java_embedded_server_enabled: Optional[bool] = None,
                 java_version: Optional[str] = None,
                 node_version: Optional[str] = None,
                 php_version: Optional[str] = None,
                 python: Optional[bool] = None,
                 python_version: Optional[str] = None,
                 tomcat_version: Optional[str] = None):
        """
        :param str current_stack: The Application Stack for the Windows Web App. Possible values include `dotnet`, `dotnetcore`, `node`, `python`, `php`, and `java`.
               
               > **NOTE:** Whilst this property is Optional omitting it can cause unexpected behaviour, in particular for display of settings in the Azure Portal.
        :param str docker_image_name: The docker image, including tag, to be used. e.g. `azure-app-service/windows/parkingpage:latest`.
        :param str docker_registry_password: The User Name to use for authentication against the registry to pull the image.
               
               > **NOTE:** `docker_registry_url`, `docker_registry_username`, and `docker_registry_password` replace the use of the `app_settings` values of `DOCKER_REGISTRY_SERVER_URL`, `DOCKER_REGISTRY_SERVER_USERNAME` and `DOCKER_REGISTRY_SERVER_PASSWORD` respectively, these values will be managed by the provider and should not be specified in the `app_settings` map.
        :param str docker_registry_url: The URL of the container registry where the `docker_image_name` is located. e.g. `https://index.docker.io` or `https://mcr.microsoft.com`. This value is required with `docker_image_name`.
        :param str docker_registry_username: The User Name to use for authentication against the registry to pull the image.
        :param str dotnet_core_version: The version of .NET to use when `current_stack` is set to `dotnetcore`. Possible values include `v4.0`.
        :param str dotnet_version: The version of .NET to use when `current_stack` is set to `dotnet`. Possible values include `v2.0`,`v3.0`, `v4.0`, `v5.0`, `v6.0` and `v7.0`.
        :param bool java_embedded_server_enabled: Should the Java Embedded Server (Java SE) be used to run the app.
        :param str java_version: The version of Java to use when `current_stack` is set to `java`. Possible values include `1.7`, `1.8`, `11` and `17`. Required with `java_container` and `java_container_version`.
               
               > **NOTE:** For compatible combinations of `java_version`, `java_container` and `java_container_version` users can use `az webapp list-runtimes` from command line.
        :param str node_version: The version of node to use when `current_stack` is set to `node`. Possible values include `~12`, `~14`, `~16`, and `~18`.
               
               > **NOTE:** This property conflicts with `java_version`.
        :param str php_version: The version of PHP to use when `current_stack` is set to `php`. Possible values are `7.1`, `7.4` and `Off`.
               
               > **NOTE:** The value `Off` is used to signify latest supported by the service.
        :param bool python: The app is a Python app. Defaults to `false`.
        :param str tomcat_version: The version of Tomcat the Java App should use.
               
               > **NOTE:** See the official documentation for current supported versions.
        """
        if current_stack is not None:
            pulumi.set(__self__, "current_stack", current_stack)
        if docker_container_name is not None:
            pulumi.set(__self__, "docker_container_name", docker_container_name)
        if docker_container_registry is not None:
            pulumi.set(__self__, "docker_container_registry", docker_container_registry)
        if docker_container_tag is not None:
            pulumi.set(__self__, "docker_container_tag", docker_container_tag)
        if docker_image_name is not None:
            pulumi.set(__self__, "docker_image_name", docker_image_name)
        if docker_registry_password is not None:
            pulumi.set(__self__, "docker_registry_password", docker_registry_password)
        if docker_registry_url is not None:
            pulumi.set(__self__, "docker_registry_url", docker_registry_url)
        if docker_registry_username is not None:
            pulumi.set(__self__, "docker_registry_username", docker_registry_username)
        if dotnet_core_version is not None:
            pulumi.set(__self__, "dotnet_core_version", dotnet_core_version)
        if dotnet_version is not None:
            pulumi.set(__self__, "dotnet_version", dotnet_version)
        if java_container is not None:
            pulumi.set(__self__, "java_container", java_container)
        if java_container_version is not None:
            pulumi.set(__self__, "java_container_version", java_container_version)
        if java_embedded_server_enabled is not None:
            pulumi.set(__self__, "java_embedded_server_enabled", java_embedded_server_enabled)
        if java_version is not None:
            pulumi.set(__self__, "java_version", java_version)
        if node_version is not None:
            pulumi.set(__self__, "node_version", node_version)
        if php_version is not None:
            pulumi.set(__self__, "php_version", php_version)
        if python is not None:
            pulumi.set(__self__, "python", python)
        if python_version is not None:
            pulumi.set(__self__, "python_version", python_version)
        if tomcat_version is not None:
            pulumi.set(__self__, "tomcat_version", tomcat_version)

    @property
    @pulumi.getter(name="currentStack")
    def current_stack(self) -> Optional[str]:
        """
        The Application Stack for the Windows Web App. Possible values include `dotnet`, `dotnetcore`, `node`, `python`, `php`, and `java`.

        > **NOTE:** Whilst this property is Optional omitting it can cause unexpected behaviour, in particular for display of settings in the Azure Portal.
        """
        return pulumi.get(self, "current_stack")

    @property
    @pulumi.getter(name="dockerContainerName")
    def docker_container_name(self) -> Optional[str]:
        return pulumi.get(self, "docker_container_name")

    @property
    @pulumi.getter(name="dockerContainerRegistry")
    def docker_container_registry(self) -> Optional[str]:
        warnings.warn("""This property has been deprecated and will be removed in a future release of the provider.""", DeprecationWarning)
        pulumi.log.warn("""docker_container_registry is deprecated: This property has been deprecated and will be removed in a future release of the provider.""")

        return pulumi.get(self, "docker_container_registry")

    @property
    @pulumi.getter(name="dockerContainerTag")
    def docker_container_tag(self) -> Optional[str]:
        return pulumi.get(self, "docker_container_tag")

    @property
    @pulumi.getter(name="dockerImageName")
    def docker_image_name(self) -> Optional[str]:
        """
        The docker image, including tag, to be used. e.g. `azure-app-service/windows/parkingpage:latest`.
        """
        return pulumi.get(self, "docker_image_name")

    @property
    @pulumi.getter(name="dockerRegistryPassword")
    def docker_registry_password(self) -> Optional[str]:
        """
        The User Name to use for authentication against the registry to pull the image.

        > **NOTE:** `docker_registry_url`, `docker_registry_username`, and `docker_registry_password` replace the use of the `app_settings` values of `DOCKER_REGISTRY_SERVER_URL`, `DOCKER_REGISTRY_SERVER_USERNAME` and `DOCKER_REGISTRY_SERVER_PASSWORD` respectively, these values will be managed by the provider and should not be specified in the `app_settings` map.
        """
        return pulumi.get(self, "docker_registry_password")

    @property
    @pulumi.getter(name="dockerRegistryUrl")
    def docker_registry_url(self) -> Optional[str]:
        """
        The URL of the container registry where the `docker_image_name` is located. e.g. `https://index.docker.io` or `https://mcr.microsoft.com`. This value is required with `docker_image_name`.
        """
        return pulumi.get(self, "docker_registry_url")

    @property
    @pulumi.getter(name="dockerRegistryUsername")
    def docker_registry_username(self) -> Optional[str]:
        """
        The User Name to use for authentication against the registry to pull the image.
        """
        return pulumi.get(self, "docker_registry_username")

    @property
    @pulumi.getter(name="dotnetCoreVersion")
    def dotnet_core_version(self) -> Optional[str]:
        """
        The version of .NET to use when `current_stack` is set to `dotnetcore`. Possible values include `v4.0`.
        """
        return pulumi.get(self, "dotnet_core_version")

    @property
    @pulumi.getter(name="dotnetVersion")
    def dotnet_version(self) -> Optional[str]:
        """
        The version of .NET to use when `current_stack` is set to `dotnet`. Possible values include `v2.0`,`v3.0`, `v4.0`, `v5.0`, `v6.0` and `v7.0`.
        """
        return pulumi.get(self, "dotnet_version")

    @property
    @pulumi.getter(name="javaContainer")
    def java_container(self) -> Optional[str]:
        warnings.warn("""this property has been deprecated in favour of `tomcat_version` and `java_embedded_server_enabled`""", DeprecationWarning)
        pulumi.log.warn("""java_container is deprecated: this property has been deprecated in favour of `tomcat_version` and `java_embedded_server_enabled`""")

        return pulumi.get(self, "java_container")

    @property
    @pulumi.getter(name="javaContainerVersion")
    def java_container_version(self) -> Optional[str]:
        warnings.warn("""This property has been deprecated in favour of `tomcat_version` and `java_embedded_server_enabled`""", DeprecationWarning)
        pulumi.log.warn("""java_container_version is deprecated: This property has been deprecated in favour of `tomcat_version` and `java_embedded_server_enabled`""")

        return pulumi.get(self, "java_container_version")

    @property
    @pulumi.getter(name="javaEmbeddedServerEnabled")
    def java_embedded_server_enabled(self) -> Optional[bool]:
        """
        Should the Java Embedded Server (Java SE) be used to run the app.
        """
        return pulumi.get(self, "java_embedded_server_enabled")

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> Optional[str]:
        """
        The version of Java to use when `current_stack` is set to `java`. Possible values include `1.7`, `1.8`, `11` and `17`. Required with `java_container` and `java_container_version`.

        > **NOTE:** For compatible combinations of `java_version`, `java_container` and `java_container_version` users can use `az webapp list-runtimes` from command line.
        """
        return pulumi.get(self, "java_version")

    @property
    @pulumi.getter(name="nodeVersion")
    def node_version(self) -> Optional[str]:
        """
        The version of node to use when `current_stack` is set to `node`. Possible values include `~12`, `~14`, `~16`, and `~18`.

        > **NOTE:** This property conflicts with `java_version`.
        """
        return pulumi.get(self, "node_version")

    @property
    @pulumi.getter(name="phpVersion")
    def php_version(self) -> Optional[str]:
        """
        The version of PHP to use when `current_stack` is set to `php`. Possible values are `7.1`, `7.4` and `Off`.

        > **NOTE:** The value `Off` is used to signify latest supported by the service.
        """
        return pulumi.get(self, "php_version")

    @property
    @pulumi.getter
    def python(self) -> Optional[bool]:
        """
        The app is a Python app. Defaults to `false`.
        """
        return pulumi.get(self, "python")

    @property
    @pulumi.getter(name="pythonVersion")
    def python_version(self) -> Optional[str]:
        warnings.warn("""This property is deprecated. Values set are not used by the service.""", DeprecationWarning)
        pulumi.log.warn("""python_version is deprecated: This property is deprecated. Values set are not used by the service.""")

        return pulumi.get(self, "python_version")

    @property
    @pulumi.getter(name="tomcatVersion")
    def tomcat_version(self) -> Optional[str]:
        """
        The version of Tomcat the Java App should use.

        > **NOTE:** See the official documentation for current supported versions.
        """
        return pulumi.get(self, "tomcat_version")


@pulumi.output_type
class WindowsWebAppSlotSiteConfigAutoHealSetting(dict):
    def __init__(__self__, *,
                 action: 'outputs.WindowsWebAppSlotSiteConfigAutoHealSettingAction',
                 trigger: 'outputs.WindowsWebAppSlotSiteConfigAutoHealSettingTrigger'):
        """
        :param 'WindowsWebAppSlotSiteConfigAutoHealSettingActionArgs' action: A `action` block as defined above.
        :param 'WindowsWebAppSlotSiteConfigAutoHealSettingTriggerArgs' trigger: A `trigger` block as defined below.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "trigger", trigger)

    @property
    @pulumi.getter
    def action(self) -> 'outputs.WindowsWebAppSlotSiteConfigAutoHealSettingAction':
        """
        A `action` block as defined above.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def trigger(self) -> 'outputs.WindowsWebAppSlotSiteConfigAutoHealSettingTrigger':
        """
        A `trigger` block as defined below.
        """
        return pulumi.get(self, "trigger")


@pulumi.output_type
class WindowsWebAppSlotSiteConfigAutoHealSettingAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionType":
            suggest = "action_type"
        elif key == "customAction":
            suggest = "custom_action"
        elif key == "minimumProcessExecutionTime":
            suggest = "minimum_process_execution_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotSiteConfigAutoHealSettingAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotSiteConfigAutoHealSettingAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotSiteConfigAutoHealSettingAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_type: str,
                 custom_action: Optional['outputs.WindowsWebAppSlotSiteConfigAutoHealSettingActionCustomAction'] = None,
                 minimum_process_execution_time: Optional[str] = None):
        """
        :param str action_type: Predefined action to be taken to an Auto Heal trigger. Possible values are `CustomAction`, `LogEvent` and `Recycle`.
        :param 'WindowsWebAppSlotSiteConfigAutoHealSettingActionCustomActionArgs' custom_action: A `custom_action` block as defined below.
        :param str minimum_process_execution_time: The minimum amount of time in `hh:mm:ss` the Windows Web App Slot must have been running before the defined action will be run in the event of a trigger.
        """
        pulumi.set(__self__, "action_type", action_type)
        if custom_action is not None:
            pulumi.set(__self__, "custom_action", custom_action)
        if minimum_process_execution_time is not None:
            pulumi.set(__self__, "minimum_process_execution_time", minimum_process_execution_time)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> str:
        """
        Predefined action to be taken to an Auto Heal trigger. Possible values are `CustomAction`, `LogEvent` and `Recycle`.
        """
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter(name="customAction")
    def custom_action(self) -> Optional['outputs.WindowsWebAppSlotSiteConfigAutoHealSettingActionCustomAction']:
        """
        A `custom_action` block as defined below.
        """
        return pulumi.get(self, "custom_action")

    @property
    @pulumi.getter(name="minimumProcessExecutionTime")
    def minimum_process_execution_time(self) -> Optional[str]:
        """
        The minimum amount of time in `hh:mm:ss` the Windows Web App Slot must have been running before the defined action will be run in the event of a trigger.
        """
        return pulumi.get(self, "minimum_process_execution_time")


@pulumi.output_type
class WindowsWebAppSlotSiteConfigAutoHealSettingActionCustomAction(dict):
    def __init__(__self__, *,
                 executable: str,
                 parameters: Optional[str] = None):
        """
        :param str executable: The executable to run for the `custom_action`.
        :param str parameters: The parameters to pass to the specified `executable`.
        """
        pulumi.set(__self__, "executable", executable)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def executable(self) -> str:
        """
        The executable to run for the `custom_action`.
        """
        return pulumi.get(self, "executable")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[str]:
        """
        The parameters to pass to the specified `executable`.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class WindowsWebAppSlotSiteConfigAutoHealSettingTrigger(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateMemoryKb":
            suggest = "private_memory_kb"
        elif key == "slowRequests":
            suggest = "slow_requests"
        elif key == "statusCodes":
            suggest = "status_codes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotSiteConfigAutoHealSettingTrigger. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotSiteConfigAutoHealSettingTrigger.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotSiteConfigAutoHealSettingTrigger.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_memory_kb: Optional[int] = None,
                 requests: Optional['outputs.WindowsWebAppSlotSiteConfigAutoHealSettingTriggerRequests'] = None,
                 slow_requests: Optional[Sequence['outputs.WindowsWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequest']] = None,
                 status_codes: Optional[Sequence['outputs.WindowsWebAppSlotSiteConfigAutoHealSettingTriggerStatusCode']] = None):
        """
        :param int private_memory_kb: The amount of Private Memory to be consumed for this rule to trigger. Possible values are between `102400` and `13631488`.
        :param 'WindowsWebAppSlotSiteConfigAutoHealSettingTriggerRequestsArgs' requests: A `requests` block as defined above.
        :param Sequence['WindowsWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestArgs'] slow_requests: One or more `slow_request` blocks as defined above.
        :param Sequence['WindowsWebAppSlotSiteConfigAutoHealSettingTriggerStatusCodeArgs'] status_codes: One or more `status_code` blocks as defined above.
        """
        if private_memory_kb is not None:
            pulumi.set(__self__, "private_memory_kb", private_memory_kb)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if slow_requests is not None:
            pulumi.set(__self__, "slow_requests", slow_requests)
        if status_codes is not None:
            pulumi.set(__self__, "status_codes", status_codes)

    @property
    @pulumi.getter(name="privateMemoryKb")
    def private_memory_kb(self) -> Optional[int]:
        """
        The amount of Private Memory to be consumed for this rule to trigger. Possible values are between `102400` and `13631488`.
        """
        return pulumi.get(self, "private_memory_kb")

    @property
    @pulumi.getter
    def requests(self) -> Optional['outputs.WindowsWebAppSlotSiteConfigAutoHealSettingTriggerRequests']:
        """
        A `requests` block as defined above.
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="slowRequests")
    def slow_requests(self) -> Optional[Sequence['outputs.WindowsWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequest']]:
        """
        One or more `slow_request` blocks as defined above.
        """
        return pulumi.get(self, "slow_requests")

    @property
    @pulumi.getter(name="statusCodes")
    def status_codes(self) -> Optional[Sequence['outputs.WindowsWebAppSlotSiteConfigAutoHealSettingTriggerStatusCode']]:
        """
        One or more `status_code` blocks as defined above.
        """
        return pulumi.get(self, "status_codes")


@pulumi.output_type
class WindowsWebAppSlotSiteConfigAutoHealSettingTriggerRequests(dict):
    def __init__(__self__, *,
                 count: int,
                 interval: str):
        """
        :param int count: The number of requests in the specified `interval` to trigger this rule.
        :param str interval: The interval in `hh:mm:ss`.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of requests in the specified `interval` to trigger this rule.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        The interval in `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class WindowsWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeTaken":
            suggest = "time_taken"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: int,
                 interval: str,
                 time_taken: str,
                 path: Optional[str] = None):
        """
        :param int count: The number of Slow Requests in the time `interval` to trigger this rule.
        :param str interval: The time interval in the form `hh:mm:ss`.
        :param str time_taken: The threshold of time passed to qualify as a Slow Request in `hh:mm:ss`.
        :param str path: The path for which this slow request rule applies.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "time_taken", time_taken)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of Slow Requests in the time `interval` to trigger this rule.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        The time interval in the form `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="timeTaken")
    def time_taken(self) -> str:
        """
        The threshold of time passed to qualify as a Slow Request in `hh:mm:ss`.
        """
        return pulumi.get(self, "time_taken")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path for which this slow request rule applies.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class WindowsWebAppSlotSiteConfigAutoHealSettingTriggerStatusCode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusCodeRange":
            suggest = "status_code_range"
        elif key == "subStatus":
            suggest = "sub_status"
        elif key == "win32StatusCode":
            suggest = "win32_status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotSiteConfigAutoHealSettingTriggerStatusCode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotSiteConfigAutoHealSettingTriggerStatusCode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotSiteConfigAutoHealSettingTriggerStatusCode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: int,
                 interval: str,
                 status_code_range: str,
                 path: Optional[str] = None,
                 sub_status: Optional[int] = None,
                 win32_status_code: Optional[int] = None):
        """
        :param int count: The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        :param str interval: The time interval in the form `hh:mm:ss`.
        :param str status_code_range: The status code for this rule, accepts single status codes and status code ranges. e.g. `500` or `400-499`. Possible values are integers between `101` and `599`
        :param str path: The path to which this rule status code applies.
        :param int sub_status: The Request Sub Status of the Status Code.
        :param int win32_status_code: The Win32 Status Code of the Request.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "status_code_range", status_code_range)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if sub_status is not None:
            pulumi.set(__self__, "sub_status", sub_status)
        if win32_status_code is not None:
            pulumi.set(__self__, "win32_status_code", win32_status_code)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        The time interval in the form `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="statusCodeRange")
    def status_code_range(self) -> str:
        """
        The status code for this rule, accepts single status codes and status code ranges. e.g. `500` or `400-499`. Possible values are integers between `101` and `599`
        """
        return pulumi.get(self, "status_code_range")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path to which this rule status code applies.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="subStatus")
    def sub_status(self) -> Optional[int]:
        """
        The Request Sub Status of the Status Code.
        """
        return pulumi.get(self, "sub_status")

    @property
    @pulumi.getter(name="win32StatusCode")
    def win32_status_code(self) -> Optional[int]:
        """
        The Win32 Status Code of the Request.
        """
        return pulumi.get(self, "win32_status_code")


@pulumi.output_type
class WindowsWebAppSlotSiteConfigCors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedOrigins":
            suggest = "allowed_origins"
        elif key == "supportCredentials":
            suggest = "support_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotSiteConfigCors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotSiteConfigCors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotSiteConfigCors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_origins: Optional[Sequence[str]] = None,
                 support_credentials: Optional[bool] = None):
        """
        :param Sequence[str] allowed_origins: Specifies a list of origins that should be allowed to make cross-origin calls.
        :param bool support_credentials: Whether CORS requests with credentials are allowed. Defaults to `false`
        """
        if allowed_origins is not None:
            pulumi.set(__self__, "allowed_origins", allowed_origins)
        if support_credentials is not None:
            pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of origins that should be allowed to make cross-origin calls.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> Optional[bool]:
        """
        Whether CORS requests with credentials are allowed. Defaults to `false`
        """
        return pulumi.get(self, "support_credentials")


@pulumi.output_type
class WindowsWebAppSlotSiteConfigIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotSiteConfigIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotSiteConfigIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotSiteConfigIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.WindowsWebAppSlotSiteConfigIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: The action to take. Possible values are `Allow` or `Deny`.
        :param 'WindowsWebAppSlotSiteConfigIpRestrictionHeadersArgs' headers: A `headers` block as defined above.
        :param str ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param str name: The name which should be used for this `ip_restriction`.
        :param int priority: The priority value of this `ip_restriction`. Defaults to `65000`.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
               
               > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        The action to take. Possible values are `Allow` or `Deny`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.WindowsWebAppSlotSiteConfigIpRestrictionHeaders']:
        """
        A `headers` block as defined above.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class WindowsWebAppSlotSiteConfigIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotSiteConfigIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param str x_fd_health_probe: Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        :param Sequence[str] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param Sequence[str] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class WindowsWebAppSlotSiteConfigScmIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotSiteConfigScmIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotSiteConfigScmIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotSiteConfigScmIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.WindowsWebAppSlotSiteConfigScmIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: The action to take. Possible values are `Allow` or `Deny`.
        :param 'WindowsWebAppSlotSiteConfigScmIpRestrictionHeadersArgs' headers: A `headers` block as defined above.
        :param str ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param str name: The name which should be used for this `ip_restriction`.
        :param int priority: The priority value of this `ip_restriction`. Defaults to `65000`.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
               
               > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        The action to take. Possible values are `Allow` or `Deny`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.WindowsWebAppSlotSiteConfigScmIpRestrictionHeaders']:
        """
        A `headers` block as defined above.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class WindowsWebAppSlotSiteConfigScmIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotSiteConfigScmIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param str x_fd_health_probe: Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        :param Sequence[str] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param Sequence[str] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class WindowsWebAppSlotSiteConfigVirtualApplication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "physicalPath":
            suggest = "physical_path"
        elif key == "virtualPath":
            suggest = "virtual_path"
        elif key == "virtualDirectories":
            suggest = "virtual_directories"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotSiteConfigVirtualApplication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotSiteConfigVirtualApplication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotSiteConfigVirtualApplication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 physical_path: str,
                 preload: bool,
                 virtual_path: str,
                 virtual_directories: Optional[Sequence['outputs.WindowsWebAppSlotSiteConfigVirtualApplicationVirtualDirectory']] = None):
        """
        :param str physical_path: The physical path for the Virtual Application.
        :param bool preload: Should pre-loading be enabled.
        :param str virtual_path: The Virtual Path for the Virtual Application.
        :param Sequence['WindowsWebAppSlotSiteConfigVirtualApplicationVirtualDirectoryArgs'] virtual_directories: One or more `virtual_directory` blocks as defined below.
        """
        pulumi.set(__self__, "physical_path", physical_path)
        pulumi.set(__self__, "preload", preload)
        pulumi.set(__self__, "virtual_path", virtual_path)
        if virtual_directories is not None:
            pulumi.set(__self__, "virtual_directories", virtual_directories)

    @property
    @pulumi.getter(name="physicalPath")
    def physical_path(self) -> str:
        """
        The physical path for the Virtual Application.
        """
        return pulumi.get(self, "physical_path")

    @property
    @pulumi.getter
    def preload(self) -> bool:
        """
        Should pre-loading be enabled.
        """
        return pulumi.get(self, "preload")

    @property
    @pulumi.getter(name="virtualPath")
    def virtual_path(self) -> str:
        """
        The Virtual Path for the Virtual Application.
        """
        return pulumi.get(self, "virtual_path")

    @property
    @pulumi.getter(name="virtualDirectories")
    def virtual_directories(self) -> Optional[Sequence['outputs.WindowsWebAppSlotSiteConfigVirtualApplicationVirtualDirectory']]:
        """
        One or more `virtual_directory` blocks as defined below.
        """
        return pulumi.get(self, "virtual_directories")


@pulumi.output_type
class WindowsWebAppSlotSiteConfigVirtualApplicationVirtualDirectory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "physicalPath":
            suggest = "physical_path"
        elif key == "virtualPath":
            suggest = "virtual_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotSiteConfigVirtualApplicationVirtualDirectory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotSiteConfigVirtualApplicationVirtualDirectory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotSiteConfigVirtualApplicationVirtualDirectory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 physical_path: Optional[str] = None,
                 virtual_path: Optional[str] = None):
        """
        :param str physical_path: The physical path for the Virtual Application.
        :param str virtual_path: The Virtual Path for the Virtual Application.
        """
        if physical_path is not None:
            pulumi.set(__self__, "physical_path", physical_path)
        if virtual_path is not None:
            pulumi.set(__self__, "virtual_path", virtual_path)

    @property
    @pulumi.getter(name="physicalPath")
    def physical_path(self) -> Optional[str]:
        """
        The physical path for the Virtual Application.
        """
        return pulumi.get(self, "physical_path")

    @property
    @pulumi.getter(name="virtualPath")
    def virtual_path(self) -> Optional[str]:
        """
        The Virtual Path for the Virtual Application.
        """
        return pulumi.get(self, "virtual_path")


@pulumi.output_type
class WindowsWebAppSlotSiteCredential(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 password: Optional[str] = None):
        """
        :param str password: The Site Credentials Password used for publishing.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The Site Credentials Password used for publishing.
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class WindowsWebAppSlotStorageAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "accountName":
            suggest = "account_name"
        elif key == "shareName":
            suggest = "share_name"
        elif key == "mountPath":
            suggest = "mount_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotStorageAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotStorageAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotStorageAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: str,
                 account_name: str,
                 name: str,
                 share_name: str,
                 type: str,
                 mount_path: Optional[str] = None):
        """
        :param str access_key: The Access key for the storage account.
        :param str account_name: The Name of the Storage Account.
        :param str name: The name which should be used for this Storage Account.
        :param str share_name: The Name of the File Share or Container Name for Blob storage.
        :param str type: The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`
        :param str mount_path: The path at which to mount the storage share.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "share_name", share_name)
        pulumi.set(__self__, "type", type)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> str:
        """
        The Access key for the storage account.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> str:
        """
        The Name of the Storage Account.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Storage Account.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> str:
        """
        The Name of the File Share or Container Name for Blob storage.
        """
        return pulumi.get(self, "share_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[str]:
        """
        The path at which to mount the storage share.
        """
        return pulumi.get(self, "mount_path")


@pulumi.output_type
class WindowsWebAppStickySettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appSettingNames":
            suggest = "app_setting_names"
        elif key == "connectionStringNames":
            suggest = "connection_string_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppStickySettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppStickySettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppStickySettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_setting_names: Optional[Sequence[str]] = None,
                 connection_string_names: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] app_setting_names: A list of `app_setting` names that the Windows Web App will not swap between Slots when a swap operation is triggered.
        :param Sequence[str] connection_string_names: A list of `connection_string` names that the Windows Web App will not swap between Slots when a swap operation is triggered.
        """
        if app_setting_names is not None:
            pulumi.set(__self__, "app_setting_names", app_setting_names)
        if connection_string_names is not None:
            pulumi.set(__self__, "connection_string_names", connection_string_names)

    @property
    @pulumi.getter(name="appSettingNames")
    def app_setting_names(self) -> Optional[Sequence[str]]:
        """
        A list of `app_setting` names that the Windows Web App will not swap between Slots when a swap operation is triggered.
        """
        return pulumi.get(self, "app_setting_names")

    @property
    @pulumi.getter(name="connectionStringNames")
    def connection_string_names(self) -> Optional[Sequence[str]]:
        """
        A list of `connection_string` names that the Windows Web App will not swap between Slots when a swap operation is triggered.
        """
        return pulumi.get(self, "connection_string_names")


@pulumi.output_type
class WindowsWebAppStorageAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "accountName":
            suggest = "account_name"
        elif key == "shareName":
            suggest = "share_name"
        elif key == "mountPath":
            suggest = "mount_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppStorageAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppStorageAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppStorageAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: str,
                 account_name: str,
                 name: str,
                 share_name: str,
                 type: str,
                 mount_path: Optional[str] = None):
        """
        :param str access_key: The Access key for the storage account.
        :param str account_name: The Name of the Storage Account.
        :param str name: The name which should be used for this TODO.
        :param str share_name: The Name of the File Share or Container Name for Blob storage.
        :param str type: The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`
        :param str mount_path: The path at which to mount the storage share.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "share_name", share_name)
        pulumi.set(__self__, "type", type)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> str:
        """
        The Access key for the storage account.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> str:
        """
        The Name of the Storage Account.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this TODO.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> str:
        """
        The Name of the File Share or Container Name for Blob storage.
        """
        return pulumi.get(self, "share_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[str]:
        """
        The path at which to mount the storage share.
        """
        return pulumi.get(self, "mount_path")


@pulumi.output_type
class GetAppServiceConnectionStringResult(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: The name of the App Service.
        :param str type: The type of the Connection String.
        :param str value: The value for the Connection String.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the App Service.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the Connection String.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the Connection String.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAppServiceEnvironmentClusterSettingResult(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: The name of this App Service Environment.
        :param str value: The value for the Cluster Setting.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this App Service Environment.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the Cluster Setting.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAppServicePlanSkuResult(dict):
    def __init__(__self__, *,
                 capacity: int,
                 size: str,
                 tier: str):
        """
        :param int capacity: Specifies the number of workers associated with this App Service Plan.
        :param str size: Specifies the plan's instance size.
        :param str tier: Specifies the plan's pricing tier.
        """
        pulumi.set(__self__, "capacity", capacity)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter
    def capacity(self) -> int:
        """
        Specifies the number of workers associated with this App Service Plan.
        """
        return pulumi.get(self, "capacity")

    @property
    @pulumi.getter
    def size(self) -> str:
        """
        Specifies the plan's instance size.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def tier(self) -> str:
        """
        Specifies the plan's pricing tier.
        """
        return pulumi.get(self, "tier")


@pulumi.output_type
class GetAppServiceSiteConfigResult(dict):
    def __init__(__self__, *,
                 acr_use_managed_identity_credentials: bool,
                 acr_user_managed_identity_client_id: str,
                 always_on: bool,
                 app_command_line: str,
                 cors: Sequence['outputs.GetAppServiceSiteConfigCorResult'],
                 default_documents: Sequence[str],
                 dotnet_framework_version: str,
                 ftps_state: str,
                 health_check_path: str,
                 http2_enabled: bool,
                 ip_restrictions: Sequence['outputs.GetAppServiceSiteConfigIpRestrictionResult'],
                 java_container: str,
                 java_container_version: str,
                 java_version: str,
                 linux_fx_version: str,
                 local_mysql_enabled: bool,
                 managed_pipeline_mode: str,
                 min_tls_version: str,
                 number_of_workers: int,
                 php_version: str,
                 python_version: str,
                 remote_debugging_enabled: bool,
                 remote_debugging_version: str,
                 scm_ip_restrictions: Sequence['outputs.GetAppServiceSiteConfigScmIpRestrictionResult'],
                 scm_type: str,
                 scm_use_main_ip_restriction: bool,
                 use32_bit_worker_process: bool,
                 vnet_route_all_enabled: bool,
                 websockets_enabled: bool,
                 windows_fx_version: str):
        """
        :param bool acr_use_managed_identity_credentials: Are Managed Identity Credentials used for Azure Container Registry pull.
        :param str acr_user_managed_identity_client_id: The User Managed Identity Client Id.
        :param bool always_on: Is the app loaded at all times?
        :param str app_command_line: App command line to launch.
        :param Sequence['GetAppServiceSiteConfigCorArgs'] cors: A `cors` block as defined above.
        :param Sequence[str] default_documents: The ordering of default documents to load, if an address isn't specified.
        :param str dotnet_framework_version: The version of the .NET framework's CLR used in this App Service.
        :param str ftps_state: State of FTP / FTPS service for this AppService.
        :param str health_check_path: The health check path to be pinged by App Service.
        :param bool http2_enabled: Is HTTP2 Enabled on this App Service?
        :param Sequence['GetAppServiceSiteConfigIpRestrictionArgs'] ip_restrictions: One or more `ip_restriction` blocks as defined above.
        :param str java_container: The Java Container in use.
        :param str java_container_version: The version of the Java Container in use.
        :param str java_version: The version of Java in use.
        :param str linux_fx_version: Linux App Framework and version for the AppService.
        :param bool local_mysql_enabled: Is "MySQL In App" Enabled? This runs a local MySQL instance with your app and shares resources from the App Service plan.
        :param str managed_pipeline_mode: The Managed Pipeline Mode used in this App Service.
        :param str min_tls_version: The minimum supported TLS version for this App Service.
        :param int number_of_workers: The scaled number of workers (for per site scaling) of this App Service.
        :param str php_version: The version of PHP used in this App Service.
        :param str python_version: The version of Python used in this App Service.
        :param bool remote_debugging_enabled: Is Remote Debugging Enabled in this App Service?
        :param str remote_debugging_version: Which version of Visual Studio is the Remote Debugger compatible with?
        :param Sequence['GetAppServiceSiteConfigScmIpRestrictionArgs'] scm_ip_restrictions: One or more `scm_ip_restriction` blocks as defined above.
        :param str scm_type: The type of Source Control enabled for this App Service.
        :param bool scm_use_main_ip_restriction: IP security restrictions for scm to use main.
        :param bool use32_bit_worker_process: Does the App Service run in 32 bit mode, rather than 64 bit mode?
        :param bool vnet_route_all_enabled: (Optional) Should all outbound traffic to have Virtual Network Security Groups and User Defined Routes applied?
        :param bool websockets_enabled: Are WebSockets enabled for this App Service?
        :param str windows_fx_version: Windows Container Docker Image for the AppService.
        """
        pulumi.set(__self__, "acr_use_managed_identity_credentials", acr_use_managed_identity_credentials)
        pulumi.set(__self__, "acr_user_managed_identity_client_id", acr_user_managed_identity_client_id)
        pulumi.set(__self__, "always_on", always_on)
        pulumi.set(__self__, "app_command_line", app_command_line)
        pulumi.set(__self__, "cors", cors)
        pulumi.set(__self__, "default_documents", default_documents)
        pulumi.set(__self__, "dotnet_framework_version", dotnet_framework_version)
        pulumi.set(__self__, "ftps_state", ftps_state)
        pulumi.set(__self__, "health_check_path", health_check_path)
        pulumi.set(__self__, "http2_enabled", http2_enabled)
        pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        pulumi.set(__self__, "java_container", java_container)
        pulumi.set(__self__, "java_container_version", java_container_version)
        pulumi.set(__self__, "java_version", java_version)
        pulumi.set(__self__, "linux_fx_version", linux_fx_version)
        pulumi.set(__self__, "local_mysql_enabled", local_mysql_enabled)
        pulumi.set(__self__, "managed_pipeline_mode", managed_pipeline_mode)
        pulumi.set(__self__, "min_tls_version", min_tls_version)
        pulumi.set(__self__, "number_of_workers", number_of_workers)
        pulumi.set(__self__, "php_version", php_version)
        pulumi.set(__self__, "python_version", python_version)
        pulumi.set(__self__, "remote_debugging_enabled", remote_debugging_enabled)
        pulumi.set(__self__, "remote_debugging_version", remote_debugging_version)
        pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        pulumi.set(__self__, "scm_type", scm_type)
        pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        pulumi.set(__self__, "use32_bit_worker_process", use32_bit_worker_process)
        pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        pulumi.set(__self__, "websockets_enabled", websockets_enabled)
        pulumi.set(__self__, "windows_fx_version", windows_fx_version)

    @property
    @pulumi.getter(name="acrUseManagedIdentityCredentials")
    def acr_use_managed_identity_credentials(self) -> bool:
        """
        Are Managed Identity Credentials used for Azure Container Registry pull.
        """
        return pulumi.get(self, "acr_use_managed_identity_credentials")

    @property
    @pulumi.getter(name="acrUserManagedIdentityClientId")
    def acr_user_managed_identity_client_id(self) -> str:
        """
        The User Managed Identity Client Id.
        """
        return pulumi.get(self, "acr_user_managed_identity_client_id")

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> bool:
        """
        Is the app loaded at all times?
        """
        return pulumi.get(self, "always_on")

    @property
    @pulumi.getter(name="appCommandLine")
    def app_command_line(self) -> str:
        """
        App command line to launch.
        """
        return pulumi.get(self, "app_command_line")

    @property
    @pulumi.getter
    def cors(self) -> Sequence['outputs.GetAppServiceSiteConfigCorResult']:
        """
        A `cors` block as defined above.
        """
        return pulumi.get(self, "cors")

    @property
    @pulumi.getter(name="defaultDocuments")
    def default_documents(self) -> Sequence[str]:
        """
        The ordering of default documents to load, if an address isn't specified.
        """
        return pulumi.get(self, "default_documents")

    @property
    @pulumi.getter(name="dotnetFrameworkVersion")
    def dotnet_framework_version(self) -> str:
        """
        The version of the .NET framework's CLR used in this App Service.
        """
        return pulumi.get(self, "dotnet_framework_version")

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> str:
        """
        State of FTP / FTPS service for this AppService.
        """
        return pulumi.get(self, "ftps_state")

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> str:
        """
        The health check path to be pinged by App Service.
        """
        return pulumi.get(self, "health_check_path")

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> bool:
        """
        Is HTTP2 Enabled on this App Service?
        """
        return pulumi.get(self, "http2_enabled")

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Sequence['outputs.GetAppServiceSiteConfigIpRestrictionResult']:
        """
        One or more `ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "ip_restrictions")

    @property
    @pulumi.getter(name="javaContainer")
    def java_container(self) -> str:
        """
        The Java Container in use.
        """
        return pulumi.get(self, "java_container")

    @property
    @pulumi.getter(name="javaContainerVersion")
    def java_container_version(self) -> str:
        """
        The version of the Java Container in use.
        """
        return pulumi.get(self, "java_container_version")

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> str:
        """
        The version of Java in use.
        """
        return pulumi.get(self, "java_version")

    @property
    @pulumi.getter(name="linuxFxVersion")
    def linux_fx_version(self) -> str:
        """
        Linux App Framework and version for the AppService.
        """
        return pulumi.get(self, "linux_fx_version")

    @property
    @pulumi.getter(name="localMysqlEnabled")
    def local_mysql_enabled(self) -> bool:
        """
        Is "MySQL In App" Enabled? This runs a local MySQL instance with your app and shares resources from the App Service plan.
        """
        return pulumi.get(self, "local_mysql_enabled")

    @property
    @pulumi.getter(name="managedPipelineMode")
    def managed_pipeline_mode(self) -> str:
        """
        The Managed Pipeline Mode used in this App Service.
        """
        return pulumi.get(self, "managed_pipeline_mode")

    @property
    @pulumi.getter(name="minTlsVersion")
    def min_tls_version(self) -> str:
        """
        The minimum supported TLS version for this App Service.
        """
        return pulumi.get(self, "min_tls_version")

    @property
    @pulumi.getter(name="numberOfWorkers")
    def number_of_workers(self) -> int:
        """
        The scaled number of workers (for per site scaling) of this App Service.
        """
        return pulumi.get(self, "number_of_workers")

    @property
    @pulumi.getter(name="phpVersion")
    def php_version(self) -> str:
        """
        The version of PHP used in this App Service.
        """
        return pulumi.get(self, "php_version")

    @property
    @pulumi.getter(name="pythonVersion")
    def python_version(self) -> str:
        """
        The version of Python used in this App Service.
        """
        return pulumi.get(self, "python_version")

    @property
    @pulumi.getter(name="remoteDebuggingEnabled")
    def remote_debugging_enabled(self) -> bool:
        """
        Is Remote Debugging Enabled in this App Service?
        """
        return pulumi.get(self, "remote_debugging_enabled")

    @property
    @pulumi.getter(name="remoteDebuggingVersion")
    def remote_debugging_version(self) -> str:
        """
        Which version of Visual Studio is the Remote Debugger compatible with?
        """
        return pulumi.get(self, "remote_debugging_version")

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Sequence['outputs.GetAppServiceSiteConfigScmIpRestrictionResult']:
        """
        One or more `scm_ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "scm_ip_restrictions")

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> str:
        """
        The type of Source Control enabled for this App Service.
        """
        return pulumi.get(self, "scm_type")

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> bool:
        """
        IP security restrictions for scm to use main.
        """
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @property
    @pulumi.getter(name="use32BitWorkerProcess")
    def use32_bit_worker_process(self) -> bool:
        """
        Does the App Service run in 32 bit mode, rather than 64 bit mode?
        """
        return pulumi.get(self, "use32_bit_worker_process")

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> bool:
        """
        (Optional) Should all outbound traffic to have Virtual Network Security Groups and User Defined Routes applied?
        """
        return pulumi.get(self, "vnet_route_all_enabled")

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> bool:
        """
        Are WebSockets enabled for this App Service?
        """
        return pulumi.get(self, "websockets_enabled")

    @property
    @pulumi.getter(name="windowsFxVersion")
    def windows_fx_version(self) -> str:
        """
        Windows Container Docker Image for the AppService.
        """
        return pulumi.get(self, "windows_fx_version")


@pulumi.output_type
class GetAppServiceSiteConfigCorResult(dict):
    def __init__(__self__, *,
                 allowed_origins: Sequence[str],
                 support_credentials: bool):
        """
        :param Sequence[str] allowed_origins: A list of origins which are able to make cross-origin calls.
        :param bool support_credentials: Are credentials supported?
        """
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Sequence[str]:
        """
        A list of origins which are able to make cross-origin calls.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> bool:
        """
        Are credentials supported?
        """
        return pulumi.get(self, "support_credentials")


@pulumi.output_type
class GetAppServiceSiteConfigIpRestrictionResult(dict):
    def __init__(__self__, *,
                 action: str,
                 headers: 'outputs.GetAppServiceSiteConfigIpRestrictionHeadersResult',
                 ip_address: str,
                 name: str,
                 priority: int,
                 service_tag: str,
                 virtual_network_subnet_id: str):
        """
        :param str action: Allow or Deny access for this IP range. Defaults to Allow.
        :param str ip_address: The IP Address used for this IP Restriction in CIDR notation.
        :param str name: The name of the App Service.
        :param int priority: The priority for this IP Restriction.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "service_tag", service_tag)
        pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Allow or Deny access for this IP range. Defaults to Allow.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> 'outputs.GetAppServiceSiteConfigIpRestrictionHeadersResult':
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The IP Address used for this IP Restriction in CIDR notation.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the App Service.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        The priority for this IP Restriction.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> str:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> str:
        """
        The Virtual Network Subnet ID used for this IP Restriction.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class GetAppServiceSiteConfigIpRestrictionHeadersResult(dict):
    def __init__(__self__, *,
                 x_azure_fdids: Sequence[str],
                 x_fd_health_probes: Sequence[str],
                 x_forwarded_fors: Sequence[str],
                 x_forwarded_hosts: Sequence[str]):
        pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        pulumi.set(__self__, "x_fd_health_probes", x_fd_health_probes)
        pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Sequence[str]:
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbes")
    def x_fd_health_probes(self) -> Sequence[str]:
        return pulumi.get(self, "x_fd_health_probes")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Sequence[str]:
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Sequence[str]:
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class GetAppServiceSiteConfigScmIpRestrictionResult(dict):
    def __init__(__self__, *,
                 action: str,
                 headers: 'outputs.GetAppServiceSiteConfigScmIpRestrictionHeadersResult',
                 ip_address: str,
                 name: str,
                 priority: int,
                 service_tag: str,
                 virtual_network_subnet_id: str):
        """
        :param str action: Allow or Deny access for this IP range. Defaults to Allow.
        :param str ip_address: The IP Address used for this IP Restriction in CIDR notation.
        :param str name: The name of the App Service.
        :param int priority: The priority for this IP Restriction.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "service_tag", service_tag)
        pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Allow or Deny access for this IP range. Defaults to Allow.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> 'outputs.GetAppServiceSiteConfigScmIpRestrictionHeadersResult':
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The IP Address used for this IP Restriction in CIDR notation.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the App Service.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        The priority for this IP Restriction.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> str:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> str:
        """
        The Virtual Network Subnet ID used for this IP Restriction.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class GetAppServiceSiteConfigScmIpRestrictionHeadersResult(dict):
    def __init__(__self__, *,
                 x_azure_fdids: Sequence[str],
                 x_fd_health_probes: Sequence[str],
                 x_forwarded_fors: Sequence[str],
                 x_forwarded_hosts: Sequence[str]):
        pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        pulumi.set(__self__, "x_fd_health_probes", x_fd_health_probes)
        pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Sequence[str]:
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbes")
    def x_fd_health_probes(self) -> Sequence[str]:
        return pulumi.get(self, "x_fd_health_probes")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Sequence[str]:
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Sequence[str]:
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class GetAppServiceSiteCredentialResult(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        return pulumi.get(self, "username")


@pulumi.output_type
class GetAppServiceSourceControlResult(dict):
    def __init__(__self__, *,
                 branch: str,
                 manual_integration: bool,
                 repo_url: str,
                 rollback_enabled: bool,
                 use_mercurial: bool):
        """
        :param str branch: The branch of the remote repository in use.
        :param bool manual_integration: Limits to manual integration.
        :param str repo_url: The URL of the source code repository.
        :param bool rollback_enabled: Is roll-back enabled for the repository.
        :param bool use_mercurial: Uses Mercurial if `true`, otherwise uses Git.
        """
        pulumi.set(__self__, "branch", branch)
        pulumi.set(__self__, "manual_integration", manual_integration)
        pulumi.set(__self__, "repo_url", repo_url)
        pulumi.set(__self__, "rollback_enabled", rollback_enabled)
        pulumi.set(__self__, "use_mercurial", use_mercurial)

    @property
    @pulumi.getter
    def branch(self) -> str:
        """
        The branch of the remote repository in use.
        """
        return pulumi.get(self, "branch")

    @property
    @pulumi.getter(name="manualIntegration")
    def manual_integration(self) -> bool:
        """
        Limits to manual integration.
        """
        return pulumi.get(self, "manual_integration")

    @property
    @pulumi.getter(name="repoUrl")
    def repo_url(self) -> str:
        """
        The URL of the source code repository.
        """
        return pulumi.get(self, "repo_url")

    @property
    @pulumi.getter(name="rollbackEnabled")
    def rollback_enabled(self) -> bool:
        """
        Is roll-back enabled for the repository.
        """
        return pulumi.get(self, "rollback_enabled")

    @property
    @pulumi.getter(name="useMercurial")
    def use_mercurial(self) -> bool:
        """
        Uses Mercurial if `true`, otherwise uses Git.
        """
        return pulumi.get(self, "use_mercurial")


@pulumi.output_type
class GetCertificateOrderCertificateResult(dict):
    def __init__(__self__, *,
                 certificate_name: str,
                 key_vault_id: str,
                 key_vault_secret_name: str,
                 provisioning_state: str):
        """
        :param str certificate_name: The name of the App Service Certificate.
        :param str key_vault_id: Key Vault resource Id.
        :param str key_vault_secret_name: Key Vault secret name.
        :param str provisioning_state: Status of the Key Vault secret.
        """
        pulumi.set(__self__, "certificate_name", certificate_name)
        pulumi.set(__self__, "key_vault_id", key_vault_id)
        pulumi.set(__self__, "key_vault_secret_name", key_vault_secret_name)
        pulumi.set(__self__, "provisioning_state", provisioning_state)

    @property
    @pulumi.getter(name="certificateName")
    def certificate_name(self) -> str:
        """
        The name of the App Service Certificate.
        """
        return pulumi.get(self, "certificate_name")

    @property
    @pulumi.getter(name="keyVaultId")
    def key_vault_id(self) -> str:
        """
        Key Vault resource Id.
        """
        return pulumi.get(self, "key_vault_id")

    @property
    @pulumi.getter(name="keyVaultSecretName")
    def key_vault_secret_name(self) -> str:
        """
        Key Vault secret name.
        """
        return pulumi.get(self, "key_vault_secret_name")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        Status of the Key Vault secret.
        """
        return pulumi.get(self, "provisioning_state")


@pulumi.output_type
class GetEnvironmentV3ClusterSettingResult(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: The name of this v3 App Service Environment.
        :param str value: The value for the Cluster Setting.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this v3 App Service Environment.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the Cluster Setting.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetEnvironmentV3InboundNetworkDependencyResult(dict):
    def __init__(__self__, *,
                 description: str,
                 ip_addresses: Sequence[str],
                 ports: Sequence[str]):
        """
        :param str description: A short description of the purpose of the network traffic.
        :param Sequence[str] ip_addresses: A list of IP addresses that network traffic will originate from in CIDR notation.
        :param Sequence[str] ports: The ports that network traffic will arrive to the App Service Environment V3 on.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "ip_addresses", ip_addresses)
        pulumi.set(__self__, "ports", ports)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        A short description of the purpose of the network traffic.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Sequence[str]:
        """
        A list of IP addresses that network traffic will originate from in CIDR notation.
        """
        return pulumi.get(self, "ip_addresses")

    @property
    @pulumi.getter
    def ports(self) -> Sequence[str]:
        """
        The ports that network traffic will arrive to the App Service Environment V3 on.
        """
        return pulumi.get(self, "ports")


@pulumi.output_type
class GetFunctionAppConnectionStringResult(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: The name of the Function App resource.
        :param str type: The identity type of the Managed Identity assigned to the Function App.
        :param str value: The value for the Connection String.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Function App resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The identity type of the Managed Identity assigned to the Function App.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the Connection String.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetFunctionAppIdentityResult(dict):
    def __init__(__self__, *,
                 identity_ids: Sequence[str],
                 principal_id: str,
                 tenant_id: str,
                 type: str):
        """
        :param Sequence[str] identity_ids: A list of User Assigned Identity IDs assigned to the Function App.
        :param str principal_id: The ID of the Managed Identity assigned to the Function App.
        :param str tenant_id: The ID of the Tenant where the Managed Identity assigned to the Function App is located.
        :param str type: The identity type of the Managed Identity assigned to the Function App.
        """
        pulumi.set(__self__, "identity_ids", identity_ids)
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Sequence[str]:
        """
        A list of User Assigned Identity IDs assigned to the Function App.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The ID of the Managed Identity assigned to the Function App.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The ID of the Tenant where the Managed Identity assigned to the Function App is located.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The identity type of the Managed Identity assigned to the Function App.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetFunctionAppSiteConfigResult(dict):
    def __init__(__self__, *,
                 always_on: bool,
                 app_scale_limit: int,
                 auto_swap_slot_name: str,
                 cors: 'outputs.GetFunctionAppSiteConfigCorsResult',
                 dotnet_framework_version: str,
                 elastic_instance_minimum: int,
                 ftps_state: str,
                 health_check_path: str,
                 http2_enabled: bool,
                 ip_restrictions: Sequence['outputs.GetFunctionAppSiteConfigIpRestrictionResult'],
                 java_version: str,
                 linux_fx_version: str,
                 min_tls_version: str,
                 pre_warmed_instance_count: int,
                 runtime_scale_monitoring_enabled: bool,
                 scm_ip_restrictions: Sequence['outputs.GetFunctionAppSiteConfigScmIpRestrictionResult'],
                 scm_type: str,
                 scm_use_main_ip_restriction: bool,
                 use32_bit_worker_process: bool,
                 vnet_route_all_enabled: bool,
                 websockets_enabled: bool):
        """
        :param bool always_on: Is the app loaded at all times?
        :param int app_scale_limit: The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
        :param 'GetFunctionAppSiteConfigCorsArgs' cors: A `cors` block as defined above.
        :param str dotnet_framework_version: The version of the .NET framework's CLR used in this App Service.
        :param int elastic_instance_minimum: The number of minimum instances for this function app. Only applicable to apps on the Premium plan.
        :param str ftps_state: State of FTP / FTPS service for this AppService.
        :param bool http2_enabled: Is HTTP2 Enabled on this App Service?
        :param Sequence['GetFunctionAppSiteConfigIpRestrictionArgs'] ip_restrictions: One or more `ip_restriction` blocks as defined above.
        :param str java_version: Java version hosted by the function app in Azure.
        :param str linux_fx_version: Linux App Framework and version for the AppService.
        :param str min_tls_version: The minimum supported TLS version for this App Service.
        :param int pre_warmed_instance_count: The number of pre-warmed instances for this function app. Only applicable to apps on the Premium plan.
        :param bool runtime_scale_monitoring_enabled: Is Runtime Scale Monitoring Enabled on this function app?
        :param Sequence['GetFunctionAppSiteConfigScmIpRestrictionArgs'] scm_ip_restrictions: One or more `scm_ip_restriction` blocks as defined above.
        :param str scm_type: The type of Source Control enabled for this App Service.
        :param bool scm_use_main_ip_restriction: IP security restrictions for scm to use main.
        :param bool use32_bit_worker_process: Does the App Service run in 32 bit mode, rather than 64 bit mode?
        :param bool vnet_route_all_enabled: (Optional) Should all outbound traffic to have Virtual Network Security Groups and User Defined Routes applied?
        :param bool websockets_enabled: Are WebSockets enabled for this App Service?
        """
        pulumi.set(__self__, "always_on", always_on)
        pulumi.set(__self__, "app_scale_limit", app_scale_limit)
        pulumi.set(__self__, "auto_swap_slot_name", auto_swap_slot_name)
        pulumi.set(__self__, "cors", cors)
        pulumi.set(__self__, "dotnet_framework_version", dotnet_framework_version)
        pulumi.set(__self__, "elastic_instance_minimum", elastic_instance_minimum)
        pulumi.set(__self__, "ftps_state", ftps_state)
        pulumi.set(__self__, "health_check_path", health_check_path)
        pulumi.set(__self__, "http2_enabled", http2_enabled)
        pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        pulumi.set(__self__, "java_version", java_version)
        pulumi.set(__self__, "linux_fx_version", linux_fx_version)
        pulumi.set(__self__, "min_tls_version", min_tls_version)
        pulumi.set(__self__, "pre_warmed_instance_count", pre_warmed_instance_count)
        pulumi.set(__self__, "runtime_scale_monitoring_enabled", runtime_scale_monitoring_enabled)
        pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        pulumi.set(__self__, "scm_type", scm_type)
        pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        pulumi.set(__self__, "use32_bit_worker_process", use32_bit_worker_process)
        pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        pulumi.set(__self__, "websockets_enabled", websockets_enabled)

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> bool:
        """
        Is the app loaded at all times?
        """
        return pulumi.get(self, "always_on")

    @property
    @pulumi.getter(name="appScaleLimit")
    def app_scale_limit(self) -> int:
        """
        The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
        """
        return pulumi.get(self, "app_scale_limit")

    @property
    @pulumi.getter(name="autoSwapSlotName")
    def auto_swap_slot_name(self) -> str:
        return pulumi.get(self, "auto_swap_slot_name")

    @property
    @pulumi.getter
    def cors(self) -> 'outputs.GetFunctionAppSiteConfigCorsResult':
        """
        A `cors` block as defined above.
        """
        return pulumi.get(self, "cors")

    @property
    @pulumi.getter(name="dotnetFrameworkVersion")
    def dotnet_framework_version(self) -> str:
        """
        The version of the .NET framework's CLR used in this App Service.
        """
        return pulumi.get(self, "dotnet_framework_version")

    @property
    @pulumi.getter(name="elasticInstanceMinimum")
    def elastic_instance_minimum(self) -> int:
        """
        The number of minimum instances for this function app. Only applicable to apps on the Premium plan.
        """
        return pulumi.get(self, "elastic_instance_minimum")

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> str:
        """
        State of FTP / FTPS service for this AppService.
        """
        return pulumi.get(self, "ftps_state")

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> str:
        return pulumi.get(self, "health_check_path")

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> bool:
        """
        Is HTTP2 Enabled on this App Service?
        """
        return pulumi.get(self, "http2_enabled")

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Sequence['outputs.GetFunctionAppSiteConfigIpRestrictionResult']:
        """
        One or more `ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "ip_restrictions")

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> str:
        """
        Java version hosted by the function app in Azure.
        """
        return pulumi.get(self, "java_version")

    @property
    @pulumi.getter(name="linuxFxVersion")
    def linux_fx_version(self) -> str:
        """
        Linux App Framework and version for the AppService.
        """
        return pulumi.get(self, "linux_fx_version")

    @property
    @pulumi.getter(name="minTlsVersion")
    def min_tls_version(self) -> str:
        """
        The minimum supported TLS version for this App Service.
        """
        return pulumi.get(self, "min_tls_version")

    @property
    @pulumi.getter(name="preWarmedInstanceCount")
    def pre_warmed_instance_count(self) -> int:
        """
        The number of pre-warmed instances for this function app. Only applicable to apps on the Premium plan.
        """
        return pulumi.get(self, "pre_warmed_instance_count")

    @property
    @pulumi.getter(name="runtimeScaleMonitoringEnabled")
    def runtime_scale_monitoring_enabled(self) -> bool:
        """
        Is Runtime Scale Monitoring Enabled on this function app?
        """
        return pulumi.get(self, "runtime_scale_monitoring_enabled")

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Sequence['outputs.GetFunctionAppSiteConfigScmIpRestrictionResult']:
        """
        One or more `scm_ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "scm_ip_restrictions")

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> str:
        """
        The type of Source Control enabled for this App Service.
        """
        return pulumi.get(self, "scm_type")

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> bool:
        """
        IP security restrictions for scm to use main.
        """
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @property
    @pulumi.getter(name="use32BitWorkerProcess")
    def use32_bit_worker_process(self) -> bool:
        """
        Does the App Service run in 32 bit mode, rather than 64 bit mode?
        """
        return pulumi.get(self, "use32_bit_worker_process")

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> bool:
        """
        (Optional) Should all outbound traffic to have Virtual Network Security Groups and User Defined Routes applied?
        """
        return pulumi.get(self, "vnet_route_all_enabled")

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> bool:
        """
        Are WebSockets enabled for this App Service?
        """
        return pulumi.get(self, "websockets_enabled")


@pulumi.output_type
class GetFunctionAppSiteConfigCorsResult(dict):
    def __init__(__self__, *,
                 allowed_origins: Sequence[str],
                 support_credentials: Optional[bool] = None):
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        if support_credentials is not None:
            pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Sequence[str]:
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> Optional[bool]:
        return pulumi.get(self, "support_credentials")


@pulumi.output_type
class GetFunctionAppSiteConfigIpRestrictionResult(dict):
    def __init__(__self__, *,
                 action: str,
                 headers: 'outputs.GetFunctionAppSiteConfigIpRestrictionHeadersResult',
                 ip_address: str,
                 name: str,
                 priority: int,
                 service_tag: str,
                 virtual_network_subnet_id: str):
        """
        :param str action: Allow or Deny access for this IP range. Defaults to Allow.
        :param str ip_address: The IP Address used for this IP Restriction in CIDR notation.
        :param str name: The name of the Function App resource.
        :param int priority: The priority for this IP Restriction.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "service_tag", service_tag)
        pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Allow or Deny access for this IP range. Defaults to Allow.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> 'outputs.GetFunctionAppSiteConfigIpRestrictionHeadersResult':
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The IP Address used for this IP Restriction in CIDR notation.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Function App resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        The priority for this IP Restriction.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> str:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> str:
        """
        The Virtual Network Subnet ID used for this IP Restriction.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class GetFunctionAppSiteConfigIpRestrictionHeadersResult(dict):
    def __init__(__self__, *,
                 x_azure_fdids: Sequence[str],
                 x_fd_health_probes: Sequence[str],
                 x_forwarded_fors: Sequence[str],
                 x_forwarded_hosts: Sequence[str]):
        pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        pulumi.set(__self__, "x_fd_health_probes", x_fd_health_probes)
        pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Sequence[str]:
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbes")
    def x_fd_health_probes(self) -> Sequence[str]:
        return pulumi.get(self, "x_fd_health_probes")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Sequence[str]:
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Sequence[str]:
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class GetFunctionAppSiteConfigScmIpRestrictionResult(dict):
    def __init__(__self__, *,
                 action: str,
                 headers: 'outputs.GetFunctionAppSiteConfigScmIpRestrictionHeadersResult',
                 ip_address: str,
                 name: str,
                 priority: int,
                 service_tag: str,
                 virtual_network_subnet_id: str):
        """
        :param str action: Allow or Deny access for this IP range. Defaults to Allow.
        :param str ip_address: The IP Address used for this IP Restriction in CIDR notation.
        :param str name: The name of the Function App resource.
        :param int priority: The priority for this IP Restriction.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "service_tag", service_tag)
        pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Allow or Deny access for this IP range. Defaults to Allow.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> 'outputs.GetFunctionAppSiteConfigScmIpRestrictionHeadersResult':
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The IP Address used for this IP Restriction in CIDR notation.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Function App resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        The priority for this IP Restriction.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> str:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> str:
        """
        The Virtual Network Subnet ID used for this IP Restriction.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class GetFunctionAppSiteConfigScmIpRestrictionHeadersResult(dict):
    def __init__(__self__, *,
                 x_azure_fdids: Sequence[str],
                 x_fd_health_probes: Sequence[str],
                 x_forwarded_fors: Sequence[str],
                 x_forwarded_hosts: Sequence[str]):
        pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        pulumi.set(__self__, "x_fd_health_probes", x_fd_health_probes)
        pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Sequence[str]:
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbes")
    def x_fd_health_probes(self) -> Sequence[str]:
        return pulumi.get(self, "x_fd_health_probes")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Sequence[str]:
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Sequence[str]:
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class GetFunctionAppSiteCredentialResult(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str):
        """
        :param str password: The password associated with the username, which can be used to publish to this App Service.
        :param str username: The username which can be used to publish to this App Service
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password associated with the username, which can be used to publish to this App Service.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username which can be used to publish to this App Service
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetFunctionAppSourceControlResult(dict):
    def __init__(__self__, *,
                 branch: str,
                 manual_integration: bool,
                 repo_url: str,
                 rollback_enabled: bool,
                 use_mercurial: bool):
        """
        :param str branch: The branch of the remote repository in use.
        :param bool manual_integration: Limits to manual integration.
        :param str repo_url: The URL of the source code repository.
        :param bool rollback_enabled: Is roll-back enabled for the repository.
        :param bool use_mercurial: Uses Mercurial if `true`, otherwise uses Git.
        """
        pulumi.set(__self__, "branch", branch)
        pulumi.set(__self__, "manual_integration", manual_integration)
        pulumi.set(__self__, "repo_url", repo_url)
        pulumi.set(__self__, "rollback_enabled", rollback_enabled)
        pulumi.set(__self__, "use_mercurial", use_mercurial)

    @property
    @pulumi.getter
    def branch(self) -> str:
        """
        The branch of the remote repository in use.
        """
        return pulumi.get(self, "branch")

    @property
    @pulumi.getter(name="manualIntegration")
    def manual_integration(self) -> bool:
        """
        Limits to manual integration.
        """
        return pulumi.get(self, "manual_integration")

    @property
    @pulumi.getter(name="repoUrl")
    def repo_url(self) -> str:
        """
        The URL of the source code repository.
        """
        return pulumi.get(self, "repo_url")

    @property
    @pulumi.getter(name="rollbackEnabled")
    def rollback_enabled(self) -> bool:
        """
        Is roll-back enabled for the repository.
        """
        return pulumi.get(self, "rollback_enabled")

    @property
    @pulumi.getter(name="useMercurial")
    def use_mercurial(self) -> bool:
        """
        Uses Mercurial if `true`, otherwise uses Git.
        """
        return pulumi.get(self, "use_mercurial")


@pulumi.output_type
class GetLinuxFunctionAppAuthSettingResult(dict):
    def __init__(__self__, *,
                 active_directories: Sequence['outputs.GetLinuxFunctionAppAuthSettingActiveDirectoryResult'],
                 additional_login_parameters: Mapping[str, str],
                 allowed_external_redirect_urls: Sequence[str],
                 default_provider: str,
                 enabled: bool,
                 facebooks: Sequence['outputs.GetLinuxFunctionAppAuthSettingFacebookResult'],
                 githubs: Sequence['outputs.GetLinuxFunctionAppAuthSettingGithubResult'],
                 googles: Sequence['outputs.GetLinuxFunctionAppAuthSettingGoogleResult'],
                 issuer: str,
                 microsofts: Sequence['outputs.GetLinuxFunctionAppAuthSettingMicrosoftResult'],
                 runtime_version: str,
                 token_refresh_extension_hours: float,
                 token_store_enabled: bool,
                 twitters: Sequence['outputs.GetLinuxFunctionAppAuthSettingTwitterResult'],
                 unauthenticated_client_action: str):
        """
        :param Sequence['GetLinuxFunctionAppAuthSettingActiveDirectoryArgs'] active_directories: An `active_directory` block as defined above.
        :param Mapping[str, str] additional_login_parameters: A map of login parameters sent to the OpenID Connect authorization endpoint when a user logs in.
        :param Sequence[str] allowed_external_redirect_urls: External URLs that can be redirected to as part of logging in or logging out of the app.
        :param str default_provider: The Default Authentication Provider used when more than one Authentication Provider is configured and the `unauthenticated_action` is set to `RedirectToLoginPage`.
        :param bool enabled: Is this backup job enabled?
        :param Sequence['GetLinuxFunctionAppAuthSettingFacebookArgs'] facebooks: A `facebook` block as defined below.
        :param Sequence['GetLinuxFunctionAppAuthSettingGithubArgs'] githubs: A `github` block as defined below.
        :param Sequence['GetLinuxFunctionAppAuthSettingGoogleArgs'] googles: A `google` block as defined below.
        :param str issuer: The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Linux Web App.
        :param Sequence['GetLinuxFunctionAppAuthSettingMicrosoftArgs'] microsofts: A `microsoft` block as defined below.
        :param str runtime_version: The Runtime Version of the Authentication and Authorisation feature of this App.
        :param float token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to call the token refresh API.
        :param bool token_store_enabled: Is the Token Store configuration Enabled.
        :param Sequence['GetLinuxFunctionAppAuthSettingTwitterArgs'] twitters: A `twitter` block as defined below.
        :param str unauthenticated_client_action: The action to taken when an unauthenticated client attempts to access the app.
        """
        pulumi.set(__self__, "active_directories", active_directories)
        pulumi.set(__self__, "additional_login_parameters", additional_login_parameters)
        pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        pulumi.set(__self__, "default_provider", default_provider)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "facebooks", facebooks)
        pulumi.set(__self__, "githubs", githubs)
        pulumi.set(__self__, "googles", googles)
        pulumi.set(__self__, "issuer", issuer)
        pulumi.set(__self__, "microsofts", microsofts)
        pulumi.set(__self__, "runtime_version", runtime_version)
        pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)
        pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        pulumi.set(__self__, "twitters", twitters)
        pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter(name="activeDirectories")
    def active_directories(self) -> Sequence['outputs.GetLinuxFunctionAppAuthSettingActiveDirectoryResult']:
        """
        An `active_directory` block as defined above.
        """
        return pulumi.get(self, "active_directories")

    @property
    @pulumi.getter(name="additionalLoginParameters")
    def additional_login_parameters(self) -> Mapping[str, str]:
        """
        A map of login parameters sent to the OpenID Connect authorization endpoint when a user logs in.
        """
        return pulumi.get(self, "additional_login_parameters")

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Sequence[str]:
        """
        External URLs that can be redirected to as part of logging in or logging out of the app.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> str:
        """
        The Default Authentication Provider used when more than one Authentication Provider is configured and the `unauthenticated_action` is set to `RedirectToLoginPage`.
        """
        return pulumi.get(self, "default_provider")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is this backup job enabled?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def facebooks(self) -> Sequence['outputs.GetLinuxFunctionAppAuthSettingFacebookResult']:
        """
        A `facebook` block as defined below.
        """
        return pulumi.get(self, "facebooks")

    @property
    @pulumi.getter
    def githubs(self) -> Sequence['outputs.GetLinuxFunctionAppAuthSettingGithubResult']:
        """
        A `github` block as defined below.
        """
        return pulumi.get(self, "githubs")

    @property
    @pulumi.getter
    def googles(self) -> Sequence['outputs.GetLinuxFunctionAppAuthSettingGoogleResult']:
        """
        A `google` block as defined below.
        """
        return pulumi.get(self, "googles")

    @property
    @pulumi.getter
    def issuer(self) -> str:
        """
        The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Linux Web App.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def microsofts(self) -> Sequence['outputs.GetLinuxFunctionAppAuthSettingMicrosoftResult']:
        """
        A `microsoft` block as defined below.
        """
        return pulumi.get(self, "microsofts")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> str:
        """
        The Runtime Version of the Authentication and Authorisation feature of this App.
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> float:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API.
        """
        return pulumi.get(self, "token_refresh_extension_hours")

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> bool:
        """
        Is the Token Store configuration Enabled.
        """
        return pulumi.get(self, "token_store_enabled")

    @property
    @pulumi.getter
    def twitters(self) -> Sequence['outputs.GetLinuxFunctionAppAuthSettingTwitterResult']:
        """
        A `twitter` block as defined below.
        """
        return pulumi.get(self, "twitters")

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> str:
        """
        The action to taken when an unauthenticated client attempts to access the app.
        """
        return pulumi.get(self, "unauthenticated_client_action")


@pulumi.output_type
class GetLinuxFunctionAppAuthSettingActiveDirectoryResult(dict):
    def __init__(__self__, *,
                 allowed_audiences: Sequence[str],
                 client_id: str,
                 client_secret: str,
                 client_secret_setting_name: str):
        """
        :param Sequence[str] allowed_audiences: The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret: The OAuth 2.0 client secret that was created for the app used for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        """
        pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Sequence[str]:
        """
        The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")


@pulumi.output_type
class GetLinuxFunctionAppAuthSettingFacebookResult(dict):
    def __init__(__self__, *,
                 app_id: str,
                 app_secret: str,
                 app_secret_setting_name: str,
                 oauth_scopes: Sequence[str]):
        """
        :param str app_id: The App ID of the Facebook app used for login.
        :param str app_secret: The App Secret of the Facebook app used for Facebook login.
        :param str app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook login.
        :param Sequence[str] oauth_scopes: A list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "app_secret", app_secret)
        pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appSecret")
    def app_secret(self) -> str:
        """
        The App Secret of the Facebook app used for Facebook login.
        """
        return pulumi.get(self, "app_secret")

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> str:
        """
        The app setting name that contains the `app_secret` value used for Facebook login.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Sequence[str]:
        """
        A list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class GetLinuxFunctionAppAuthSettingGithubResult(dict):
    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 client_secret_setting_name: str,
                 oauth_scopes: Sequence[str]):
        """
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret: The OAuth 2.0 client secret that was created for the app used for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        :param Sequence[str] oauth_scopes: A list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Sequence[str]:
        """
        A list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class GetLinuxFunctionAppAuthSettingGoogleResult(dict):
    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 client_secret_setting_name: str,
                 oauth_scopes: Sequence[str]):
        """
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret: The OAuth 2.0 client secret that was created for the app used for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        :param Sequence[str] oauth_scopes: A list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Sequence[str]:
        """
        A list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class GetLinuxFunctionAppAuthSettingMicrosoftResult(dict):
    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 client_secret_setting_name: str,
                 oauth_scopes: Sequence[str]):
        """
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret: The OAuth 2.0 client secret that was created for the app used for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        :param Sequence[str] oauth_scopes: A list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Sequence[str]:
        """
        A list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class GetLinuxFunctionAppAuthSettingTwitterResult(dict):
    def __init__(__self__, *,
                 consumer_key: str,
                 consumer_secret: str,
                 consumer_secret_setting_name: str):
        """
        :param str consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param str consumer_secret: The OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        :param str consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        pulumi.set(__self__, "consumer_secret", consumer_secret)
        pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> str:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> str:
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_secret")

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> str:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_secret_setting_name")


@pulumi.output_type
class GetLinuxFunctionAppAuthSettingsV2Result(dict):
    def __init__(__self__, *,
                 active_directory_v2s: Sequence['outputs.GetLinuxFunctionAppAuthSettingsV2ActiveDirectoryV2Result'],
                 apple_v2s: Sequence['outputs.GetLinuxFunctionAppAuthSettingsV2AppleV2Result'],
                 auth_enabled: bool,
                 azure_static_web_app_v2s: Sequence['outputs.GetLinuxFunctionAppAuthSettingsV2AzureStaticWebAppV2Result'],
                 config_file_path: str,
                 custom_oidc_v2s: Sequence['outputs.GetLinuxFunctionAppAuthSettingsV2CustomOidcV2Result'],
                 default_provider: str,
                 excluded_paths: Sequence[str],
                 facebook_v2s: Sequence['outputs.GetLinuxFunctionAppAuthSettingsV2FacebookV2Result'],
                 forward_proxy_convention: str,
                 forward_proxy_custom_host_header_name: str,
                 forward_proxy_custom_scheme_header_name: str,
                 github_v2s: Sequence['outputs.GetLinuxFunctionAppAuthSettingsV2GithubV2Result'],
                 google_v2s: Sequence['outputs.GetLinuxFunctionAppAuthSettingsV2GoogleV2Result'],
                 http_route_api_prefix: str,
                 logins: Sequence['outputs.GetLinuxFunctionAppAuthSettingsV2LoginResult'],
                 microsoft_v2s: Sequence['outputs.GetLinuxFunctionAppAuthSettingsV2MicrosoftV2Result'],
                 require_authentication: bool,
                 require_https: bool,
                 runtime_version: str,
                 twitter_v2s: Sequence['outputs.GetLinuxFunctionAppAuthSettingsV2TwitterV2Result'],
                 unauthenticated_action: str):
        """
        :param Sequence['GetLinuxFunctionAppAuthSettingsV2ActiveDirectoryV2Args'] active_directory_v2s: An `active_directory_v2` block as defined below.
        :param Sequence['GetLinuxFunctionAppAuthSettingsV2AppleV2Args'] apple_v2s: An `apple_v2` block as defined below.
        :param bool auth_enabled: Are the AuthV2 Settings enabled.
        :param Sequence['GetLinuxFunctionAppAuthSettingsV2AzureStaticWebAppV2Args'] azure_static_web_app_v2s: An `azure_static_web_app_v2` block as defined below.
        :param str config_file_path: The path to the App Auth settings.
        :param Sequence['GetLinuxFunctionAppAuthSettingsV2CustomOidcV2Args'] custom_oidc_v2s: Zero or more `custom_oidc_v2` blocks as defined below.
        :param str default_provider: The Default Authentication Provider used when more than one Authentication Provider is configured and the `unauthenticated_action` is set to `RedirectToLoginPage`.
        :param Sequence[str] excluded_paths: The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.
        :param Sequence['GetLinuxFunctionAppAuthSettingsV2FacebookV2Args'] facebook_v2s: A `facebook_v2` block as defined below.
        :param str forward_proxy_convention: The convention used to determine the url of the request made.
        :param str forward_proxy_custom_host_header_name: The name of the custom header containing the host of the request.
        :param str forward_proxy_custom_scheme_header_name: The name of the custom header containing the scheme of the request.
        :param Sequence['GetLinuxFunctionAppAuthSettingsV2GithubV2Args'] github_v2s: A `github_v2` block as defined below.
        :param Sequence['GetLinuxFunctionAppAuthSettingsV2GoogleV2Args'] google_v2s: A `google_v2` block as defined below.
        :param str http_route_api_prefix: The prefix that should precede all the authentication and authorisation paths.
        :param Sequence['GetLinuxFunctionAppAuthSettingsV2LoginArgs'] logins: A `login` block as defined below.
        :param Sequence['GetLinuxFunctionAppAuthSettingsV2MicrosoftV2Args'] microsoft_v2s: A `microsoft_v2` block as defined below.
        :param bool require_authentication: Is the authentication flow used for all requests.
        :param bool require_https: Is HTTPS required on connections?
        :param str runtime_version: The Runtime Version of the Authentication and Authorisation feature of this App.
        :param Sequence['GetLinuxFunctionAppAuthSettingsV2TwitterV2Args'] twitter_v2s: A `twitter_v2` block as defined below.
        :param str unauthenticated_action: The action to take for requests made without authentication.
        """
        pulumi.set(__self__, "active_directory_v2s", active_directory_v2s)
        pulumi.set(__self__, "apple_v2s", apple_v2s)
        pulumi.set(__self__, "auth_enabled", auth_enabled)
        pulumi.set(__self__, "azure_static_web_app_v2s", azure_static_web_app_v2s)
        pulumi.set(__self__, "config_file_path", config_file_path)
        pulumi.set(__self__, "custom_oidc_v2s", custom_oidc_v2s)
        pulumi.set(__self__, "default_provider", default_provider)
        pulumi.set(__self__, "excluded_paths", excluded_paths)
        pulumi.set(__self__, "facebook_v2s", facebook_v2s)
        pulumi.set(__self__, "forward_proxy_convention", forward_proxy_convention)
        pulumi.set(__self__, "forward_proxy_custom_host_header_name", forward_proxy_custom_host_header_name)
        pulumi.set(__self__, "forward_proxy_custom_scheme_header_name", forward_proxy_custom_scheme_header_name)
        pulumi.set(__self__, "github_v2s", github_v2s)
        pulumi.set(__self__, "google_v2s", google_v2s)
        pulumi.set(__self__, "http_route_api_prefix", http_route_api_prefix)
        pulumi.set(__self__, "logins", logins)
        pulumi.set(__self__, "microsoft_v2s", microsoft_v2s)
        pulumi.set(__self__, "require_authentication", require_authentication)
        pulumi.set(__self__, "require_https", require_https)
        pulumi.set(__self__, "runtime_version", runtime_version)
        pulumi.set(__self__, "twitter_v2s", twitter_v2s)
        pulumi.set(__self__, "unauthenticated_action", unauthenticated_action)

    @property
    @pulumi.getter(name="activeDirectoryV2s")
    def active_directory_v2s(self) -> Sequence['outputs.GetLinuxFunctionAppAuthSettingsV2ActiveDirectoryV2Result']:
        """
        An `active_directory_v2` block as defined below.
        """
        return pulumi.get(self, "active_directory_v2s")

    @property
    @pulumi.getter(name="appleV2s")
    def apple_v2s(self) -> Sequence['outputs.GetLinuxFunctionAppAuthSettingsV2AppleV2Result']:
        """
        An `apple_v2` block as defined below.
        """
        return pulumi.get(self, "apple_v2s")

    @property
    @pulumi.getter(name="authEnabled")
    def auth_enabled(self) -> bool:
        """
        Are the AuthV2 Settings enabled.
        """
        return pulumi.get(self, "auth_enabled")

    @property
    @pulumi.getter(name="azureStaticWebAppV2s")
    def azure_static_web_app_v2s(self) -> Sequence['outputs.GetLinuxFunctionAppAuthSettingsV2AzureStaticWebAppV2Result']:
        """
        An `azure_static_web_app_v2` block as defined below.
        """
        return pulumi.get(self, "azure_static_web_app_v2s")

    @property
    @pulumi.getter(name="configFilePath")
    def config_file_path(self) -> str:
        """
        The path to the App Auth settings.
        """
        return pulumi.get(self, "config_file_path")

    @property
    @pulumi.getter(name="customOidcV2s")
    def custom_oidc_v2s(self) -> Sequence['outputs.GetLinuxFunctionAppAuthSettingsV2CustomOidcV2Result']:
        """
        Zero or more `custom_oidc_v2` blocks as defined below.
        """
        return pulumi.get(self, "custom_oidc_v2s")

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> str:
        """
        The Default Authentication Provider used when more than one Authentication Provider is configured and the `unauthenticated_action` is set to `RedirectToLoginPage`.
        """
        return pulumi.get(self, "default_provider")

    @property
    @pulumi.getter(name="excludedPaths")
    def excluded_paths(self) -> Sequence[str]:
        """
        The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.
        """
        return pulumi.get(self, "excluded_paths")

    @property
    @pulumi.getter(name="facebookV2s")
    def facebook_v2s(self) -> Sequence['outputs.GetLinuxFunctionAppAuthSettingsV2FacebookV2Result']:
        """
        A `facebook_v2` block as defined below.
        """
        return pulumi.get(self, "facebook_v2s")

    @property
    @pulumi.getter(name="forwardProxyConvention")
    def forward_proxy_convention(self) -> str:
        """
        The convention used to determine the url of the request made.
        """
        return pulumi.get(self, "forward_proxy_convention")

    @property
    @pulumi.getter(name="forwardProxyCustomHostHeaderName")
    def forward_proxy_custom_host_header_name(self) -> str:
        """
        The name of the custom header containing the host of the request.
        """
        return pulumi.get(self, "forward_proxy_custom_host_header_name")

    @property
    @pulumi.getter(name="forwardProxyCustomSchemeHeaderName")
    def forward_proxy_custom_scheme_header_name(self) -> str:
        """
        The name of the custom header containing the scheme of the request.
        """
        return pulumi.get(self, "forward_proxy_custom_scheme_header_name")

    @property
    @pulumi.getter(name="githubV2s")
    def github_v2s(self) -> Sequence['outputs.GetLinuxFunctionAppAuthSettingsV2GithubV2Result']:
        """
        A `github_v2` block as defined below.
        """
        return pulumi.get(self, "github_v2s")

    @property
    @pulumi.getter(name="googleV2s")
    def google_v2s(self) -> Sequence['outputs.GetLinuxFunctionAppAuthSettingsV2GoogleV2Result']:
        """
        A `google_v2` block as defined below.
        """
        return pulumi.get(self, "google_v2s")

    @property
    @pulumi.getter(name="httpRouteApiPrefix")
    def http_route_api_prefix(self) -> str:
        """
        The prefix that should precede all the authentication and authorisation paths.
        """
        return pulumi.get(self, "http_route_api_prefix")

    @property
    @pulumi.getter
    def logins(self) -> Sequence['outputs.GetLinuxFunctionAppAuthSettingsV2LoginResult']:
        """
        A `login` block as defined below.
        """
        return pulumi.get(self, "logins")

    @property
    @pulumi.getter(name="microsoftV2s")
    def microsoft_v2s(self) -> Sequence['outputs.GetLinuxFunctionAppAuthSettingsV2MicrosoftV2Result']:
        """
        A `microsoft_v2` block as defined below.
        """
        return pulumi.get(self, "microsoft_v2s")

    @property
    @pulumi.getter(name="requireAuthentication")
    def require_authentication(self) -> bool:
        """
        Is the authentication flow used for all requests.
        """
        return pulumi.get(self, "require_authentication")

    @property
    @pulumi.getter(name="requireHttps")
    def require_https(self) -> bool:
        """
        Is HTTPS required on connections?
        """
        return pulumi.get(self, "require_https")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> str:
        """
        The Runtime Version of the Authentication and Authorisation feature of this App.
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter(name="twitterV2s")
    def twitter_v2s(self) -> Sequence['outputs.GetLinuxFunctionAppAuthSettingsV2TwitterV2Result']:
        """
        A `twitter_v2` block as defined below.
        """
        return pulumi.get(self, "twitter_v2s")

    @property
    @pulumi.getter(name="unauthenticatedAction")
    def unauthenticated_action(self) -> str:
        """
        The action to take for requests made without authentication.
        """
        return pulumi.get(self, "unauthenticated_action")


@pulumi.output_type
class GetLinuxFunctionAppAuthSettingsV2ActiveDirectoryV2Result(dict):
    def __init__(__self__, *,
                 allowed_applications: Sequence[str],
                 allowed_audiences: Sequence[str],
                 allowed_groups: Sequence[str],
                 allowed_identities: Sequence[str],
                 client_id: str,
                 client_secret_certificate_thumbprint: str,
                 client_secret_setting_name: str,
                 jwt_allowed_client_applications: Sequence[str],
                 jwt_allowed_groups: Sequence[str],
                 login_parameters: Mapping[str, str],
                 tenant_auth_endpoint: str,
                 www_authentication_disabled: bool):
        """
        :param Sequence[str] allowed_applications: The list of allowed Applications for the Default Authorisation Policy.
        :param Sequence[str] allowed_audiences: The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
        :param Sequence[str] allowed_groups: The list of allowed Group Names for the Default Authorisation Policy.
        :param Sequence[str] allowed_identities: The list of allowed Identities for the Default Authorisation Policy.
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret_certificate_thumbprint: The thumbprint of the certificate used for signing purposes.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        :param Sequence[str] jwt_allowed_client_applications: The list of Allowed Client Applications in the JWT Claim.
        :param Sequence[str] jwt_allowed_groups: The list of Allowed Groups in the JWT Claim.
        :param Mapping[str, str] login_parameters: A map of key-value pairs sent to the Authorisation Endpoint when a user logs in.
        :param str tenant_auth_endpoint: The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`
        :param bool www_authentication_disabled: Is the www-authenticate provider omitted from the request?
        """
        pulumi.set(__self__, "allowed_applications", allowed_applications)
        pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        pulumi.set(__self__, "allowed_groups", allowed_groups)
        pulumi.set(__self__, "allowed_identities", allowed_identities)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_certificate_thumbprint", client_secret_certificate_thumbprint)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "jwt_allowed_client_applications", jwt_allowed_client_applications)
        pulumi.set(__self__, "jwt_allowed_groups", jwt_allowed_groups)
        pulumi.set(__self__, "login_parameters", login_parameters)
        pulumi.set(__self__, "tenant_auth_endpoint", tenant_auth_endpoint)
        pulumi.set(__self__, "www_authentication_disabled", www_authentication_disabled)

    @property
    @pulumi.getter(name="allowedApplications")
    def allowed_applications(self) -> Sequence[str]:
        """
        The list of allowed Applications for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_applications")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Sequence[str]:
        """
        The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="allowedGroups")
    def allowed_groups(self) -> Sequence[str]:
        """
        The list of allowed Group Names for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_groups")

    @property
    @pulumi.getter(name="allowedIdentities")
    def allowed_identities(self) -> Sequence[str]:
        """
        The list of allowed Identities for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_identities")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretCertificateThumbprint")
    def client_secret_certificate_thumbprint(self) -> str:
        """
        The thumbprint of the certificate used for signing purposes.
        """
        return pulumi.get(self, "client_secret_certificate_thumbprint")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="jwtAllowedClientApplications")
    def jwt_allowed_client_applications(self) -> Sequence[str]:
        """
        The list of Allowed Client Applications in the JWT Claim.
        """
        return pulumi.get(self, "jwt_allowed_client_applications")

    @property
    @pulumi.getter(name="jwtAllowedGroups")
    def jwt_allowed_groups(self) -> Sequence[str]:
        """
        The list of Allowed Groups in the JWT Claim.
        """
        return pulumi.get(self, "jwt_allowed_groups")

    @property
    @pulumi.getter(name="loginParameters")
    def login_parameters(self) -> Mapping[str, str]:
        """
        A map of key-value pairs sent to the Authorisation Endpoint when a user logs in.
        """
        return pulumi.get(self, "login_parameters")

    @property
    @pulumi.getter(name="tenantAuthEndpoint")
    def tenant_auth_endpoint(self) -> str:
        """
        The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`
        """
        return pulumi.get(self, "tenant_auth_endpoint")

    @property
    @pulumi.getter(name="wwwAuthenticationDisabled")
    def www_authentication_disabled(self) -> bool:
        """
        Is the www-authenticate provider omitted from the request?
        """
        return pulumi.get(self, "www_authentication_disabled")


@pulumi.output_type
class GetLinuxFunctionAppAuthSettingsV2AppleV2Result(dict):
    def __init__(__self__, *,
                 client_id: str,
                 client_secret_setting_name: str,
                 login_scopes: Sequence[str]):
        """
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        :param Sequence[str] login_scopes: The list of Login scopes that are requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Sequence[str]:
        """
        The list of Login scopes that are requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class GetLinuxFunctionAppAuthSettingsV2AzureStaticWebAppV2Result(dict):
    def __init__(__self__, *,
                 client_id: str):
        """
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        pulumi.set(__self__, "client_id", client_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")


@pulumi.output_type
class GetLinuxFunctionAppAuthSettingsV2CustomOidcV2Result(dict):
    def __init__(__self__, *,
                 authorisation_endpoint: str,
                 certification_uri: str,
                 client_credential_method: str,
                 client_id: str,
                 client_secret_setting_name: str,
                 issuer_endpoint: str,
                 name: str,
                 name_claim_type: str,
                 openid_configuration_endpoint: str,
                 scopes: Sequence[str],
                 token_endpoint: str):
        """
        :param str authorisation_endpoint: The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        :param str certification_uri: The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        :param str client_credential_method: The Client Credential Method used.
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        :param str issuer_endpoint: The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        :param str name: The name which should be used for this Linux Function App.
        :param str name_claim_type: The name of the claim that contains the users name.
        :param str openid_configuration_endpoint: The app setting name that contains the `client_secret` value used for the Custom OIDC Login.
        :param Sequence[str] scopes: The list of the scopes that are requested while authenticating.
        :param str token_endpoint: The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
        pulumi.set(__self__, "authorisation_endpoint", authorisation_endpoint)
        pulumi.set(__self__, "certification_uri", certification_uri)
        pulumi.set(__self__, "client_credential_method", client_credential_method)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "issuer_endpoint", issuer_endpoint)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "name_claim_type", name_claim_type)
        pulumi.set(__self__, "openid_configuration_endpoint", openid_configuration_endpoint)
        pulumi.set(__self__, "scopes", scopes)
        pulumi.set(__self__, "token_endpoint", token_endpoint)

    @property
    @pulumi.getter(name="authorisationEndpoint")
    def authorisation_endpoint(self) -> str:
        """
        The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "authorisation_endpoint")

    @property
    @pulumi.getter(name="certificationUri")
    def certification_uri(self) -> str:
        """
        The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "certification_uri")

    @property
    @pulumi.getter(name="clientCredentialMethod")
    def client_credential_method(self) -> str:
        """
        The Client Credential Method used.
        """
        return pulumi.get(self, "client_credential_method")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="issuerEndpoint")
    def issuer_endpoint(self) -> str:
        """
        The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "issuer_endpoint")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Linux Function App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nameClaimType")
    def name_claim_type(self) -> str:
        """
        The name of the claim that contains the users name.
        """
        return pulumi.get(self, "name_claim_type")

    @property
    @pulumi.getter(name="openidConfigurationEndpoint")
    def openid_configuration_endpoint(self) -> str:
        """
        The app setting name that contains the `client_secret` value used for the Custom OIDC Login.
        """
        return pulumi.get(self, "openid_configuration_endpoint")

    @property
    @pulumi.getter
    def scopes(self) -> Sequence[str]:
        """
        The list of the scopes that are requested while authenticating.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> str:
        """
        The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "token_endpoint")


@pulumi.output_type
class GetLinuxFunctionAppAuthSettingsV2FacebookV2Result(dict):
    def __init__(__self__, *,
                 app_id: str,
                 app_secret_setting_name: str,
                 graph_api_version: str,
                 login_scopes: Sequence[str]):
        """
        :param str app_id: The App ID of the Facebook app used for login.
        :param str app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook login.
        :param str graph_api_version: The version of the Facebook API to be used while logging in.
        :param Sequence[str] login_scopes: The list of Login scopes that are requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        pulumi.set(__self__, "graph_api_version", graph_api_version)
        pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> str:
        """
        The app setting name that contains the `app_secret` value used for Facebook login.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @property
    @pulumi.getter(name="graphApiVersion")
    def graph_api_version(self) -> str:
        """
        The version of the Facebook API to be used while logging in.
        """
        return pulumi.get(self, "graph_api_version")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Sequence[str]:
        """
        The list of Login scopes that are requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class GetLinuxFunctionAppAuthSettingsV2GithubV2Result(dict):
    def __init__(__self__, *,
                 client_id: str,
                 client_secret_setting_name: str,
                 login_scopes: Sequence[str]):
        """
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        :param Sequence[str] login_scopes: The list of Login scopes that are requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Sequence[str]:
        """
        The list of Login scopes that are requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class GetLinuxFunctionAppAuthSettingsV2GoogleV2Result(dict):
    def __init__(__self__, *,
                 allowed_audiences: Sequence[str],
                 client_id: str,
                 client_secret_setting_name: str,
                 login_scopes: Sequence[str]):
        """
        :param Sequence[str] allowed_audiences: The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        :param Sequence[str] login_scopes: The list of Login scopes that are requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Sequence[str]:
        """
        The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Sequence[str]:
        """
        The list of Login scopes that are requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class GetLinuxFunctionAppAuthSettingsV2LoginResult(dict):
    def __init__(__self__, *,
                 allowed_external_redirect_urls: Sequence[str],
                 cookie_expiration_convention: str,
                 cookie_expiration_time: str,
                 logout_endpoint: str,
                 nonce_expiration_time: str,
                 preserve_url_fragments_for_logins: bool,
                 token_refresh_extension_time: float,
                 token_store_enabled: bool,
                 token_store_path: str,
                 token_store_sas_setting_name: str,
                 validate_nonce: bool):
        """
        :param Sequence[str] allowed_external_redirect_urls: External URLs that can be redirected to as part of logging in or logging out of the app.
        :param str cookie_expiration_convention: The method by which cookies expire.
        :param str cookie_expiration_time: The time after the request is made when the session cookie should expire.
        :param str logout_endpoint: The endpoint to which logout requests are made.
        :param str nonce_expiration_time: The time after the request is made when the nonce should expire.
        :param bool preserve_url_fragments_for_logins: Are the fragments from the request preserved after the login request is made.
        :param float token_refresh_extension_time: The number of hours after session token expiration that a session token can be used to call the token refresh API.
        :param bool token_store_enabled: Is the Token Store configuration Enabled.
        :param str token_store_path: The directory path in the App Filesystem in which the tokens are stored.
        :param str token_store_sas_setting_name: The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        :param bool validate_nonce: Is the nonce validated while completing the login flow.
        """
        pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        pulumi.set(__self__, "cookie_expiration_convention", cookie_expiration_convention)
        pulumi.set(__self__, "cookie_expiration_time", cookie_expiration_time)
        pulumi.set(__self__, "logout_endpoint", logout_endpoint)
        pulumi.set(__self__, "nonce_expiration_time", nonce_expiration_time)
        pulumi.set(__self__, "preserve_url_fragments_for_logins", preserve_url_fragments_for_logins)
        pulumi.set(__self__, "token_refresh_extension_time", token_refresh_extension_time)
        pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        pulumi.set(__self__, "token_store_path", token_store_path)
        pulumi.set(__self__, "token_store_sas_setting_name", token_store_sas_setting_name)
        pulumi.set(__self__, "validate_nonce", validate_nonce)

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Sequence[str]:
        """
        External URLs that can be redirected to as part of logging in or logging out of the app.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @property
    @pulumi.getter(name="cookieExpirationConvention")
    def cookie_expiration_convention(self) -> str:
        """
        The method by which cookies expire.
        """
        return pulumi.get(self, "cookie_expiration_convention")

    @property
    @pulumi.getter(name="cookieExpirationTime")
    def cookie_expiration_time(self) -> str:
        """
        The time after the request is made when the session cookie should expire.
        """
        return pulumi.get(self, "cookie_expiration_time")

    @property
    @pulumi.getter(name="logoutEndpoint")
    def logout_endpoint(self) -> str:
        """
        The endpoint to which logout requests are made.
        """
        return pulumi.get(self, "logout_endpoint")

    @property
    @pulumi.getter(name="nonceExpirationTime")
    def nonce_expiration_time(self) -> str:
        """
        The time after the request is made when the nonce should expire.
        """
        return pulumi.get(self, "nonce_expiration_time")

    @property
    @pulumi.getter(name="preserveUrlFragmentsForLogins")
    def preserve_url_fragments_for_logins(self) -> bool:
        """
        Are the fragments from the request preserved after the login request is made.
        """
        return pulumi.get(self, "preserve_url_fragments_for_logins")

    @property
    @pulumi.getter(name="tokenRefreshExtensionTime")
    def token_refresh_extension_time(self) -> float:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API.
        """
        return pulumi.get(self, "token_refresh_extension_time")

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> bool:
        """
        Is the Token Store configuration Enabled.
        """
        return pulumi.get(self, "token_store_enabled")

    @property
    @pulumi.getter(name="tokenStorePath")
    def token_store_path(self) -> str:
        """
        The directory path in the App Filesystem in which the tokens are stored.
        """
        return pulumi.get(self, "token_store_path")

    @property
    @pulumi.getter(name="tokenStoreSasSettingName")
    def token_store_sas_setting_name(self) -> str:
        """
        The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        """
        return pulumi.get(self, "token_store_sas_setting_name")

    @property
    @pulumi.getter(name="validateNonce")
    def validate_nonce(self) -> bool:
        """
        Is the nonce validated while completing the login flow.
        """
        return pulumi.get(self, "validate_nonce")


@pulumi.output_type
class GetLinuxFunctionAppAuthSettingsV2MicrosoftV2Result(dict):
    def __init__(__self__, *,
                 allowed_audiences: Sequence[str],
                 client_id: str,
                 client_secret_setting_name: str,
                 login_scopes: Sequence[str]):
        """
        :param Sequence[str] allowed_audiences: The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        :param Sequence[str] login_scopes: The list of Login scopes that are requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Sequence[str]:
        """
        The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Sequence[str]:
        """
        The list of Login scopes that are requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class GetLinuxFunctionAppAuthSettingsV2TwitterV2Result(dict):
    def __init__(__self__, *,
                 consumer_key: str,
                 consumer_secret_setting_name: str):
        """
        :param str consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param str consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> str:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> str:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_secret_setting_name")


@pulumi.output_type
class GetLinuxFunctionAppBackupResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 name: str,
                 schedules: Sequence['outputs.GetLinuxFunctionAppBackupScheduleResult'],
                 storage_account_url: str):
        """
        :param bool enabled: Is this backup job enabled?
        :param str name: The name which should be used for this Linux Function App.
        :param Sequence['GetLinuxFunctionAppBackupScheduleArgs'] schedules: A `schedule` block as defined below.
        :param str storage_account_url: The SAS URL to the container.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schedules", schedules)
        pulumi.set(__self__, "storage_account_url", storage_account_url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is this backup job enabled?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Linux Function App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def schedules(self) -> Sequence['outputs.GetLinuxFunctionAppBackupScheduleResult']:
        """
        A `schedule` block as defined below.
        """
        return pulumi.get(self, "schedules")

    @property
    @pulumi.getter(name="storageAccountUrl")
    def storage_account_url(self) -> str:
        """
        The SAS URL to the container.
        """
        return pulumi.get(self, "storage_account_url")


@pulumi.output_type
class GetLinuxFunctionAppBackupScheduleResult(dict):
    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_unit: str,
                 keep_at_least_one_backup: bool,
                 last_execution_time: str,
                 retention_period_days: int,
                 start_time: str):
        """
        :param int frequency_interval: How often the backup is executed.
        :param str frequency_unit: The unit of time for how often the backup takes place.
        :param bool keep_at_least_one_backup: Does the service keep at least one backup, regardless of age of backup?
        :param int retention_period_days: After how many days backups are deleted.
        :param str start_time: When the schedule starts working in RFC-3339 format.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_unit", frequency_unit)
        pulumi.set(__self__, "keep_at_least_one_backup", keep_at_least_one_backup)
        pulumi.set(__self__, "last_execution_time", last_execution_time)
        pulumi.set(__self__, "retention_period_days", retention_period_days)
        pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        How often the backup is executed.
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyUnit")
    def frequency_unit(self) -> str:
        """
        The unit of time for how often the backup takes place.
        """
        return pulumi.get(self, "frequency_unit")

    @property
    @pulumi.getter(name="keepAtLeastOneBackup")
    def keep_at_least_one_backup(self) -> bool:
        """
        Does the service keep at least one backup, regardless of age of backup?
        """
        return pulumi.get(self, "keep_at_least_one_backup")

    @property
    @pulumi.getter(name="lastExecutionTime")
    def last_execution_time(self) -> str:
        return pulumi.get(self, "last_execution_time")

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> int:
        """
        After how many days backups are deleted.
        """
        return pulumi.get(self, "retention_period_days")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        """
        When the schedule starts working in RFC-3339 format.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class GetLinuxFunctionAppConnectionStringResult(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: The name which should be used for this Linux Function App.
        :param str type: The type of Managed Service Identity that is configured on this Linux Function App.
        :param str value: The connection string value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Linux Function App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of Managed Service Identity that is configured on this Linux Function App.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The connection string value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetLinuxFunctionAppIdentityResult(dict):
    def __init__(__self__, *,
                 identity_ids: Sequence[str],
                 principal_id: str,
                 tenant_id: str,
                 type: str):
        """
        :param Sequence[str] identity_ids: The list of User Assigned Managed Identity IDs assigned to this Linux Function App.
        :param str principal_id: The Principal ID of the System Assigned Managed Service Identity that is configured on this Linux Function App.
        :param str tenant_id: The Tenant ID of the System Assigned Managed Service Identity that is configured on this Linux Function App.
        :param str type: The type of Managed Service Identity that is configured on this Linux Function App.
        """
        pulumi.set(__self__, "identity_ids", identity_ids)
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Sequence[str]:
        """
        The list of User Assigned Managed Identity IDs assigned to this Linux Function App.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The Principal ID of the System Assigned Managed Service Identity that is configured on this Linux Function App.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The Tenant ID of the System Assigned Managed Service Identity that is configured on this Linux Function App.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of Managed Service Identity that is configured on this Linux Function App.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetLinuxFunctionAppSiteConfigResult(dict):
    def __init__(__self__, *,
                 always_on: bool,
                 api_definition_url: str,
                 api_management_api_id: str,
                 app_command_line: str,
                 app_scale_limit: int,
                 app_service_logs: Sequence['outputs.GetLinuxFunctionAppSiteConfigAppServiceLogResult'],
                 application_insights_connection_string: str,
                 application_insights_key: str,
                 application_stacks: Sequence['outputs.GetLinuxFunctionAppSiteConfigApplicationStackResult'],
                 container_registry_managed_identity_client_id: str,
                 container_registry_use_managed_identity: bool,
                 cors: Sequence['outputs.GetLinuxFunctionAppSiteConfigCorResult'],
                 default_documents: Sequence[str],
                 detailed_error_logging_enabled: bool,
                 elastic_instance_minimum: int,
                 ftps_state: str,
                 health_check_eviction_time_in_min: int,
                 health_check_path: str,
                 http2_enabled: bool,
                 ip_restrictions: Sequence['outputs.GetLinuxFunctionAppSiteConfigIpRestrictionResult'],
                 linux_fx_version: str,
                 load_balancing_mode: str,
                 managed_pipeline_mode: str,
                 minimum_tls_version: str,
                 pre_warmed_instance_count: int,
                 remote_debugging_enabled: bool,
                 remote_debugging_version: str,
                 runtime_scale_monitoring_enabled: bool,
                 scm_ip_restrictions: Sequence['outputs.GetLinuxFunctionAppSiteConfigScmIpRestrictionResult'],
                 scm_minimum_tls_version: str,
                 scm_type: str,
                 scm_use_main_ip_restriction: bool,
                 use32_bit_worker: bool,
                 vnet_route_all_enabled: bool,
                 websockets_enabled: bool,
                 worker_count: int):
        """
        :param bool always_on: If this Linux Web App is Always On enabled.
        :param str api_definition_url: The URL of the API definition that describes this Linux Function App.
        :param str api_management_api_id: The ID of the API Management API for this Linux Function App.
        :param str app_command_line: The App command line that is launched.
        :param int app_scale_limit: The number of workers this function app can scale out to.
        :param Sequence['GetLinuxFunctionAppSiteConfigAppServiceLogArgs'] app_service_logs: An `app_service_logs` block as defined above.
        :param str application_insights_connection_string: The Connection String that links the Linux Function App to Application Insights.
        :param str application_insights_key: The Instrumentation Key that connects the Linux Function App to Application Insights.
        :param Sequence['GetLinuxFunctionAppSiteConfigApplicationStackArgs'] application_stacks: An `application_stack` block as defined above.
        :param str container_registry_managed_identity_client_id: The Client ID of the Managed Service Identity that is used for connections to the Azure Container Registry.
        :param bool container_registry_use_managed_identity: Do connections for Azure Container Registry use Managed Identity?
        :param Sequence['GetLinuxFunctionAppSiteConfigCorArgs'] cors: A `cors` block as defined above.
        :param Sequence[str] default_documents: A list of Default Documents for the Linux Web App.
        :param int elastic_instance_minimum: The number of minimum instances for this Linux Function App.
        :param str ftps_state: State of FTP / FTPS service for this function app.
        :param int health_check_eviction_time_in_min: The amount of time in minutes that a node can be unhealthy before being removed from the load balancer.
        :param str health_check_path: The path that is checked for this function app health.
        :param bool http2_enabled: Is the HTTP2 protocol enabled?
        :param Sequence['GetLinuxFunctionAppSiteConfigIpRestrictionArgs'] ip_restrictions: One or more `ip_restriction` blocks as defined above.
        :param str load_balancing_mode: The Site load balancing mode.
        :param str managed_pipeline_mode: Managed pipeline mode.
        :param str minimum_tls_version: The minimum version of TLS required for SSL requests.
        :param int pre_warmed_instance_count: The number of pre-warmed instances for this function app.
        :param bool remote_debugging_enabled: Is Remote Debugging enabled?
        :param str remote_debugging_version: The Remote Debugging Version.
        :param bool runtime_scale_monitoring_enabled: Is Scale Monitoring of the Functions Runtime enabled?
        :param Sequence['GetLinuxFunctionAppSiteConfigScmIpRestrictionArgs'] scm_ip_restrictions: One or more `scm_ip_restriction` blocks as defined above.
        :param str scm_minimum_tls_version: The minimum version of TLS for SSL requests to the SCM site.
        :param bool scm_use_main_ip_restriction: Is the Linux Function App `ip_restriction` configuration used for the SCM also?
        :param bool use32_bit_worker: Does the Linux Web App use a 32-bit worker process?
        :param bool vnet_route_all_enabled: Are all outbound traffic to NAT Gateways, Network Security Groups and User Defined Routes applied?
        :param bool websockets_enabled: Are Web Sockets enabled?
        :param int worker_count: The number of Workers for this Linux Function App.
        """
        pulumi.set(__self__, "always_on", always_on)
        pulumi.set(__self__, "api_definition_url", api_definition_url)
        pulumi.set(__self__, "api_management_api_id", api_management_api_id)
        pulumi.set(__self__, "app_command_line", app_command_line)
        pulumi.set(__self__, "app_scale_limit", app_scale_limit)
        pulumi.set(__self__, "app_service_logs", app_service_logs)
        pulumi.set(__self__, "application_insights_connection_string", application_insights_connection_string)
        pulumi.set(__self__, "application_insights_key", application_insights_key)
        pulumi.set(__self__, "application_stacks", application_stacks)
        pulumi.set(__self__, "container_registry_managed_identity_client_id", container_registry_managed_identity_client_id)
        pulumi.set(__self__, "container_registry_use_managed_identity", container_registry_use_managed_identity)
        pulumi.set(__self__, "cors", cors)
        pulumi.set(__self__, "default_documents", default_documents)
        pulumi.set(__self__, "detailed_error_logging_enabled", detailed_error_logging_enabled)
        pulumi.set(__self__, "elastic_instance_minimum", elastic_instance_minimum)
        pulumi.set(__self__, "ftps_state", ftps_state)
        pulumi.set(__self__, "health_check_eviction_time_in_min", health_check_eviction_time_in_min)
        pulumi.set(__self__, "health_check_path", health_check_path)
        pulumi.set(__self__, "http2_enabled", http2_enabled)
        pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        pulumi.set(__self__, "linux_fx_version", linux_fx_version)
        pulumi.set(__self__, "load_balancing_mode", load_balancing_mode)
        pulumi.set(__self__, "managed_pipeline_mode", managed_pipeline_mode)
        pulumi.set(__self__, "minimum_tls_version", minimum_tls_version)
        pulumi.set(__self__, "pre_warmed_instance_count", pre_warmed_instance_count)
        pulumi.set(__self__, "remote_debugging_enabled", remote_debugging_enabled)
        pulumi.set(__self__, "remote_debugging_version", remote_debugging_version)
        pulumi.set(__self__, "runtime_scale_monitoring_enabled", runtime_scale_monitoring_enabled)
        pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        pulumi.set(__self__, "scm_minimum_tls_version", scm_minimum_tls_version)
        pulumi.set(__self__, "scm_type", scm_type)
        pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        pulumi.set(__self__, "use32_bit_worker", use32_bit_worker)
        pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        pulumi.set(__self__, "websockets_enabled", websockets_enabled)
        pulumi.set(__self__, "worker_count", worker_count)

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> bool:
        """
        If this Linux Web App is Always On enabled.
        """
        return pulumi.get(self, "always_on")

    @property
    @pulumi.getter(name="apiDefinitionUrl")
    def api_definition_url(self) -> str:
        """
        The URL of the API definition that describes this Linux Function App.
        """
        return pulumi.get(self, "api_definition_url")

    @property
    @pulumi.getter(name="apiManagementApiId")
    def api_management_api_id(self) -> str:
        """
        The ID of the API Management API for this Linux Function App.
        """
        return pulumi.get(self, "api_management_api_id")

    @property
    @pulumi.getter(name="appCommandLine")
    def app_command_line(self) -> str:
        """
        The App command line that is launched.
        """
        return pulumi.get(self, "app_command_line")

    @property
    @pulumi.getter(name="appScaleLimit")
    def app_scale_limit(self) -> int:
        """
        The number of workers this function app can scale out to.
        """
        return pulumi.get(self, "app_scale_limit")

    @property
    @pulumi.getter(name="appServiceLogs")
    def app_service_logs(self) -> Sequence['outputs.GetLinuxFunctionAppSiteConfigAppServiceLogResult']:
        """
        An `app_service_logs` block as defined above.
        """
        return pulumi.get(self, "app_service_logs")

    @property
    @pulumi.getter(name="applicationInsightsConnectionString")
    def application_insights_connection_string(self) -> str:
        """
        The Connection String that links the Linux Function App to Application Insights.
        """
        return pulumi.get(self, "application_insights_connection_string")

    @property
    @pulumi.getter(name="applicationInsightsKey")
    def application_insights_key(self) -> str:
        """
        The Instrumentation Key that connects the Linux Function App to Application Insights.
        """
        return pulumi.get(self, "application_insights_key")

    @property
    @pulumi.getter(name="applicationStacks")
    def application_stacks(self) -> Sequence['outputs.GetLinuxFunctionAppSiteConfigApplicationStackResult']:
        """
        An `application_stack` block as defined above.
        """
        return pulumi.get(self, "application_stacks")

    @property
    @pulumi.getter(name="containerRegistryManagedIdentityClientId")
    def container_registry_managed_identity_client_id(self) -> str:
        """
        The Client ID of the Managed Service Identity that is used for connections to the Azure Container Registry.
        """
        return pulumi.get(self, "container_registry_managed_identity_client_id")

    @property
    @pulumi.getter(name="containerRegistryUseManagedIdentity")
    def container_registry_use_managed_identity(self) -> bool:
        """
        Do connections for Azure Container Registry use Managed Identity?
        """
        return pulumi.get(self, "container_registry_use_managed_identity")

    @property
    @pulumi.getter
    def cors(self) -> Sequence['outputs.GetLinuxFunctionAppSiteConfigCorResult']:
        """
        A `cors` block as defined above.
        """
        return pulumi.get(self, "cors")

    @property
    @pulumi.getter(name="defaultDocuments")
    def default_documents(self) -> Sequence[str]:
        """
        A list of Default Documents for the Linux Web App.
        """
        return pulumi.get(self, "default_documents")

    @property
    @pulumi.getter(name="detailedErrorLoggingEnabled")
    def detailed_error_logging_enabled(self) -> bool:
        return pulumi.get(self, "detailed_error_logging_enabled")

    @property
    @pulumi.getter(name="elasticInstanceMinimum")
    def elastic_instance_minimum(self) -> int:
        """
        The number of minimum instances for this Linux Function App.
        """
        return pulumi.get(self, "elastic_instance_minimum")

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> str:
        """
        State of FTP / FTPS service for this function app.
        """
        return pulumi.get(self, "ftps_state")

    @property
    @pulumi.getter(name="healthCheckEvictionTimeInMin")
    def health_check_eviction_time_in_min(self) -> int:
        """
        The amount of time in minutes that a node can be unhealthy before being removed from the load balancer.
        """
        return pulumi.get(self, "health_check_eviction_time_in_min")

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> str:
        """
        The path that is checked for this function app health.
        """
        return pulumi.get(self, "health_check_path")

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> bool:
        """
        Is the HTTP2 protocol enabled?
        """
        return pulumi.get(self, "http2_enabled")

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Sequence['outputs.GetLinuxFunctionAppSiteConfigIpRestrictionResult']:
        """
        One or more `ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "ip_restrictions")

    @property
    @pulumi.getter(name="linuxFxVersion")
    def linux_fx_version(self) -> str:
        return pulumi.get(self, "linux_fx_version")

    @property
    @pulumi.getter(name="loadBalancingMode")
    def load_balancing_mode(self) -> str:
        """
        The Site load balancing mode.
        """
        return pulumi.get(self, "load_balancing_mode")

    @property
    @pulumi.getter(name="managedPipelineMode")
    def managed_pipeline_mode(self) -> str:
        """
        Managed pipeline mode.
        """
        return pulumi.get(self, "managed_pipeline_mode")

    @property
    @pulumi.getter(name="minimumTlsVersion")
    def minimum_tls_version(self) -> str:
        """
        The minimum version of TLS required for SSL requests.
        """
        return pulumi.get(self, "minimum_tls_version")

    @property
    @pulumi.getter(name="preWarmedInstanceCount")
    def pre_warmed_instance_count(self) -> int:
        """
        The number of pre-warmed instances for this function app.
        """
        return pulumi.get(self, "pre_warmed_instance_count")

    @property
    @pulumi.getter(name="remoteDebuggingEnabled")
    def remote_debugging_enabled(self) -> bool:
        """
        Is Remote Debugging enabled?
        """
        return pulumi.get(self, "remote_debugging_enabled")

    @property
    @pulumi.getter(name="remoteDebuggingVersion")
    def remote_debugging_version(self) -> str:
        """
        The Remote Debugging Version.
        """
        return pulumi.get(self, "remote_debugging_version")

    @property
    @pulumi.getter(name="runtimeScaleMonitoringEnabled")
    def runtime_scale_monitoring_enabled(self) -> bool:
        """
        Is Scale Monitoring of the Functions Runtime enabled?
        """
        return pulumi.get(self, "runtime_scale_monitoring_enabled")

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Sequence['outputs.GetLinuxFunctionAppSiteConfigScmIpRestrictionResult']:
        """
        One or more `scm_ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "scm_ip_restrictions")

    @property
    @pulumi.getter(name="scmMinimumTlsVersion")
    def scm_minimum_tls_version(self) -> str:
        """
        The minimum version of TLS for SSL requests to the SCM site.
        """
        return pulumi.get(self, "scm_minimum_tls_version")

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> str:
        return pulumi.get(self, "scm_type")

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> bool:
        """
        Is the Linux Function App `ip_restriction` configuration used for the SCM also?
        """
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @property
    @pulumi.getter(name="use32BitWorker")
    def use32_bit_worker(self) -> bool:
        """
        Does the Linux Web App use a 32-bit worker process?
        """
        return pulumi.get(self, "use32_bit_worker")

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> bool:
        """
        Are all outbound traffic to NAT Gateways, Network Security Groups and User Defined Routes applied?
        """
        return pulumi.get(self, "vnet_route_all_enabled")

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> bool:
        """
        Are Web Sockets enabled?
        """
        return pulumi.get(self, "websockets_enabled")

    @property
    @pulumi.getter(name="workerCount")
    def worker_count(self) -> int:
        """
        The number of Workers for this Linux Function App.
        """
        return pulumi.get(self, "worker_count")


@pulumi.output_type
class GetLinuxFunctionAppSiteConfigAppServiceLogResult(dict):
    def __init__(__self__, *,
                 disk_quota_mb: int,
                 retention_period_days: int):
        """
        :param int disk_quota_mb: The amount of disk space used for logs.
        :param int retention_period_days: After how many days backups are deleted.
        """
        pulumi.set(__self__, "disk_quota_mb", disk_quota_mb)
        pulumi.set(__self__, "retention_period_days", retention_period_days)

    @property
    @pulumi.getter(name="diskQuotaMb")
    def disk_quota_mb(self) -> int:
        """
        The amount of disk space used for logs.
        """
        return pulumi.get(self, "disk_quota_mb")

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> int:
        """
        After how many days backups are deleted.
        """
        return pulumi.get(self, "retention_period_days")


@pulumi.output_type
class GetLinuxFunctionAppSiteConfigApplicationStackResult(dict):
    def __init__(__self__, *,
                 dockers: Sequence['outputs.GetLinuxFunctionAppSiteConfigApplicationStackDockerResult'],
                 dotnet_version: str,
                 java_version: str,
                 node_version: str,
                 powershell_core_version: str,
                 python_version: str,
                 use_custom_runtime: bool,
                 use_dotnet_isolated_runtime: bool):
        """
        :param Sequence['GetLinuxFunctionAppSiteConfigApplicationStackDockerArgs'] dockers: One or more `docker` blocks as defined below.
        :param str dotnet_version: The version of .NET used.
        :param str java_version: The Version of Java used.
        :param str node_version: The version of Node used.
        :param str powershell_core_version: The version of PowerShell Core used.
        :param str python_version: The version of Python used.
        :param bool use_custom_runtime: Does the Linux Function App use a custom runtime?
        """
        pulumi.set(__self__, "dockers", dockers)
        pulumi.set(__self__, "dotnet_version", dotnet_version)
        pulumi.set(__self__, "java_version", java_version)
        pulumi.set(__self__, "node_version", node_version)
        pulumi.set(__self__, "powershell_core_version", powershell_core_version)
        pulumi.set(__self__, "python_version", python_version)
        pulumi.set(__self__, "use_custom_runtime", use_custom_runtime)
        pulumi.set(__self__, "use_dotnet_isolated_runtime", use_dotnet_isolated_runtime)

    @property
    @pulumi.getter
    def dockers(self) -> Sequence['outputs.GetLinuxFunctionAppSiteConfigApplicationStackDockerResult']:
        """
        One or more `docker` blocks as defined below.
        """
        return pulumi.get(self, "dockers")

    @property
    @pulumi.getter(name="dotnetVersion")
    def dotnet_version(self) -> str:
        """
        The version of .NET used.
        """
        return pulumi.get(self, "dotnet_version")

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> str:
        """
        The Version of Java used.
        """
        return pulumi.get(self, "java_version")

    @property
    @pulumi.getter(name="nodeVersion")
    def node_version(self) -> str:
        """
        The version of Node used.
        """
        return pulumi.get(self, "node_version")

    @property
    @pulumi.getter(name="powershellCoreVersion")
    def powershell_core_version(self) -> str:
        """
        The version of PowerShell Core used.
        """
        return pulumi.get(self, "powershell_core_version")

    @property
    @pulumi.getter(name="pythonVersion")
    def python_version(self) -> str:
        """
        The version of Python used.
        """
        return pulumi.get(self, "python_version")

    @property
    @pulumi.getter(name="useCustomRuntime")
    def use_custom_runtime(self) -> bool:
        """
        Does the Linux Function App use a custom runtime?
        """
        return pulumi.get(self, "use_custom_runtime")

    @property
    @pulumi.getter(name="useDotnetIsolatedRuntime")
    def use_dotnet_isolated_runtime(self) -> bool:
        return pulumi.get(self, "use_dotnet_isolated_runtime")


@pulumi.output_type
class GetLinuxFunctionAppSiteConfigApplicationStackDockerResult(dict):
    def __init__(__self__, *,
                 image_name: str,
                 image_tag: str,
                 registry_password: str,
                 registry_url: str,
                 registry_username: str):
        """
        :param str image_name: The name of the Docker image used.
        :param str image_tag: The image tag of the image used.
        :param str registry_password: The password for the account to use to connect to the registry.
        :param str registry_url: The URL of the docker registry.
        :param str registry_username: The username used for connections to the registry.
        """
        pulumi.set(__self__, "image_name", image_name)
        pulumi.set(__self__, "image_tag", image_tag)
        pulumi.set(__self__, "registry_password", registry_password)
        pulumi.set(__self__, "registry_url", registry_url)
        pulumi.set(__self__, "registry_username", registry_username)

    @property
    @pulumi.getter(name="imageName")
    def image_name(self) -> str:
        """
        The name of the Docker image used.
        """
        return pulumi.get(self, "image_name")

    @property
    @pulumi.getter(name="imageTag")
    def image_tag(self) -> str:
        """
        The image tag of the image used.
        """
        return pulumi.get(self, "image_tag")

    @property
    @pulumi.getter(name="registryPassword")
    def registry_password(self) -> str:
        """
        The password for the account to use to connect to the registry.
        """
        return pulumi.get(self, "registry_password")

    @property
    @pulumi.getter(name="registryUrl")
    def registry_url(self) -> str:
        """
        The URL of the docker registry.
        """
        return pulumi.get(self, "registry_url")

    @property
    @pulumi.getter(name="registryUsername")
    def registry_username(self) -> str:
        """
        The username used for connections to the registry.
        """
        return pulumi.get(self, "registry_username")


@pulumi.output_type
class GetLinuxFunctionAppSiteConfigCorResult(dict):
    def __init__(__self__, *,
                 allowed_origins: Sequence[str],
                 support_credentials: bool):
        """
        :param Sequence[str] allowed_origins: A list of origins that are allowed to make cross-origin calls.
        :param bool support_credentials: Are credentials allowed in CORS requests?
        """
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Sequence[str]:
        """
        A list of origins that are allowed to make cross-origin calls.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> bool:
        """
        Are credentials allowed in CORS requests?
        """
        return pulumi.get(self, "support_credentials")


@pulumi.output_type
class GetLinuxFunctionAppSiteConfigIpRestrictionResult(dict):
    def __init__(__self__, *,
                 action: str,
                 headers: Sequence['outputs.GetLinuxFunctionAppSiteConfigIpRestrictionHeaderResult'],
                 ip_address: str,
                 name: str,
                 priority: int,
                 service_tag: str,
                 virtual_network_subnet_id: str):
        """
        :param str action: The action taken.
        :param Sequence['GetLinuxFunctionAppSiteConfigIpRestrictionHeaderArgs'] headers: A `headers` block as defined above.
        :param str ip_address: The CIDR notation of the IP or IP Range matched.
        :param str name: The name which should be used for this Linux Function App.
        :param int priority: The priority value of this `ip_restriction`.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "service_tag", service_tag)
        pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action taken.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.GetLinuxFunctionAppSiteConfigIpRestrictionHeaderResult']:
        """
        A `headers` block as defined above.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The CIDR notation of the IP or IP Range matched.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Linux Function App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        The priority value of this `ip_restriction`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> str:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> str:
        """
        The Virtual Network Subnet ID used for this IP Restriction.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class GetLinuxFunctionAppSiteConfigIpRestrictionHeaderResult(dict):
    def __init__(__self__, *,
                 x_azure_fdids: Sequence[str],
                 x_fd_health_probes: Sequence[str],
                 x_forwarded_fors: Sequence[str],
                 x_forwarded_hosts: Sequence[str]):
        """
        :param Sequence[str] x_azure_fdids: A list of Azure Front Door IDs.
        :param Sequence[str] x_fd_health_probes: Should a Front Door Health Probe be expected?
        :param Sequence[str] x_forwarded_fors: A list of addresses for which matching is applied.
        :param Sequence[str] x_forwarded_hosts: A list of Hosts for which matching is applied.
        """
        pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        pulumi.set(__self__, "x_fd_health_probes", x_fd_health_probes)
        pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Sequence[str]:
        """
        A list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbes")
    def x_fd_health_probes(self) -> Sequence[str]:
        """
        Should a Front Door Health Probe be expected?
        """
        return pulumi.get(self, "x_fd_health_probes")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Sequence[str]:
        """
        A list of addresses for which matching is applied.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Sequence[str]:
        """
        A list of Hosts for which matching is applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class GetLinuxFunctionAppSiteConfigScmIpRestrictionResult(dict):
    def __init__(__self__, *,
                 action: str,
                 headers: Sequence['outputs.GetLinuxFunctionAppSiteConfigScmIpRestrictionHeaderResult'],
                 ip_address: str,
                 name: str,
                 priority: int,
                 service_tag: str,
                 virtual_network_subnet_id: str):
        """
        :param str action: The action taken.
        :param Sequence['GetLinuxFunctionAppSiteConfigScmIpRestrictionHeaderArgs'] headers: A `headers` block as defined above.
        :param str ip_address: The CIDR notation of the IP or IP Range matched.
        :param str name: The name which should be used for this Linux Function App.
        :param int priority: The priority value of this `ip_restriction`.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "service_tag", service_tag)
        pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action taken.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.GetLinuxFunctionAppSiteConfigScmIpRestrictionHeaderResult']:
        """
        A `headers` block as defined above.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The CIDR notation of the IP or IP Range matched.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Linux Function App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        The priority value of this `ip_restriction`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> str:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> str:
        """
        The Virtual Network Subnet ID used for this IP Restriction.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class GetLinuxFunctionAppSiteConfigScmIpRestrictionHeaderResult(dict):
    def __init__(__self__, *,
                 x_azure_fdids: Sequence[str],
                 x_fd_health_probes: Sequence[str],
                 x_forwarded_fors: Sequence[str],
                 x_forwarded_hosts: Sequence[str]):
        """
        :param Sequence[str] x_azure_fdids: A list of Azure Front Door IDs.
        :param Sequence[str] x_fd_health_probes: Should a Front Door Health Probe be expected?
        :param Sequence[str] x_forwarded_fors: A list of addresses for which matching is applied.
        :param Sequence[str] x_forwarded_hosts: A list of Hosts for which matching is applied.
        """
        pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        pulumi.set(__self__, "x_fd_health_probes", x_fd_health_probes)
        pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Sequence[str]:
        """
        A list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbes")
    def x_fd_health_probes(self) -> Sequence[str]:
        """
        Should a Front Door Health Probe be expected?
        """
        return pulumi.get(self, "x_fd_health_probes")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Sequence[str]:
        """
        A list of addresses for which matching is applied.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Sequence[str]:
        """
        A list of Hosts for which matching is applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class GetLinuxFunctionAppSiteCredentialResult(dict):
    def __init__(__self__, *,
                 name: str,
                 password: str):
        """
        :param str name: The name which should be used for this Linux Function App.
        :param str password: The Site Credentials Password used for publishing.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Linux Function App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The Site Credentials Password used for publishing.
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class GetLinuxFunctionAppStickySettingResult(dict):
    def __init__(__self__, *,
                 app_setting_names: Sequence[str],
                 connection_string_names: Sequence[str]):
        """
        :param Sequence[str] app_setting_names: A list of `app_setting` names that the Linux Function App will not swap between Slots when a swap operation is triggered.
        :param Sequence[str] connection_string_names: A list of `connection_string` names that the Linux Function App will not swap between Slots when a swap operation is triggered.
        """
        pulumi.set(__self__, "app_setting_names", app_setting_names)
        pulumi.set(__self__, "connection_string_names", connection_string_names)

    @property
    @pulumi.getter(name="appSettingNames")
    def app_setting_names(self) -> Sequence[str]:
        """
        A list of `app_setting` names that the Linux Function App will not swap between Slots when a swap operation is triggered.
        """
        return pulumi.get(self, "app_setting_names")

    @property
    @pulumi.getter(name="connectionStringNames")
    def connection_string_names(self) -> Sequence[str]:
        """
        A list of `connection_string` names that the Linux Function App will not swap between Slots when a swap operation is triggered.
        """
        return pulumi.get(self, "connection_string_names")


@pulumi.output_type
class GetLinuxWebAppAuthSettingResult(dict):
    def __init__(__self__, *,
                 active_directories: Sequence['outputs.GetLinuxWebAppAuthSettingActiveDirectoryResult'],
                 additional_login_parameters: Mapping[str, str],
                 allowed_external_redirect_urls: Sequence[str],
                 default_provider: str,
                 enabled: bool,
                 facebooks: Sequence['outputs.GetLinuxWebAppAuthSettingFacebookResult'],
                 githubs: Sequence['outputs.GetLinuxWebAppAuthSettingGithubResult'],
                 googles: Sequence['outputs.GetLinuxWebAppAuthSettingGoogleResult'],
                 issuer: str,
                 microsofts: Sequence['outputs.GetLinuxWebAppAuthSettingMicrosoftResult'],
                 runtime_version: str,
                 token_refresh_extension_hours: float,
                 token_store_enabled: bool,
                 twitters: Sequence['outputs.GetLinuxWebAppAuthSettingTwitterResult'],
                 unauthenticated_client_action: str):
        """
        :param Sequence['GetLinuxWebAppAuthSettingActiveDirectoryArgs'] active_directories: A `active_directory` block as defined above.
        :param Mapping[str, str] additional_login_parameters: A `additional_login_parameters` block as defined above.
        :param Sequence[str] allowed_external_redirect_urls: External URLs that can be redirected to as part of logging in or logging out of the app.
        :param str default_provider: The Default Authentication Provider used when more than one Authentication Provider is configured and the `unauthenticated_action` is set to `RedirectToLoginPage`.
        :param bool enabled: Is the Backup enabled?
        :param Sequence['GetLinuxWebAppAuthSettingFacebookArgs'] facebooks: A `facebook` block as defined below.
        :param Sequence['GetLinuxWebAppAuthSettingGithubArgs'] githubs: A `github` block as defined below.
        :param Sequence['GetLinuxWebAppAuthSettingGoogleArgs'] googles: A `google` block as defined below.
        :param str issuer: The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Linux Web App.
        :param Sequence['GetLinuxWebAppAuthSettingMicrosoftArgs'] microsofts: A `microsoft` block as defined below.
        :param str runtime_version: The Runtime Version of the Authentication and Authorisation feature of this App.
        :param float token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to call the token refresh API.
        :param bool token_store_enabled: Is the Token Store configuration Enabled.
        :param Sequence['GetLinuxWebAppAuthSettingTwitterArgs'] twitters: A `twitter` block as defined below.
        :param str unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app.
        """
        pulumi.set(__self__, "active_directories", active_directories)
        pulumi.set(__self__, "additional_login_parameters", additional_login_parameters)
        pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        pulumi.set(__self__, "default_provider", default_provider)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "facebooks", facebooks)
        pulumi.set(__self__, "githubs", githubs)
        pulumi.set(__self__, "googles", googles)
        pulumi.set(__self__, "issuer", issuer)
        pulumi.set(__self__, "microsofts", microsofts)
        pulumi.set(__self__, "runtime_version", runtime_version)
        pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)
        pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        pulumi.set(__self__, "twitters", twitters)
        pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter(name="activeDirectories")
    def active_directories(self) -> Sequence['outputs.GetLinuxWebAppAuthSettingActiveDirectoryResult']:
        """
        A `active_directory` block as defined above.
        """
        return pulumi.get(self, "active_directories")

    @property
    @pulumi.getter(name="additionalLoginParameters")
    def additional_login_parameters(self) -> Mapping[str, str]:
        """
        A `additional_login_parameters` block as defined above.
        """
        return pulumi.get(self, "additional_login_parameters")

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Sequence[str]:
        """
        External URLs that can be redirected to as part of logging in or logging out of the app.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> str:
        """
        The Default Authentication Provider used when more than one Authentication Provider is configured and the `unauthenticated_action` is set to `RedirectToLoginPage`.
        """
        return pulumi.get(self, "default_provider")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is the Backup enabled?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def facebooks(self) -> Sequence['outputs.GetLinuxWebAppAuthSettingFacebookResult']:
        """
        A `facebook` block as defined below.
        """
        return pulumi.get(self, "facebooks")

    @property
    @pulumi.getter
    def githubs(self) -> Sequence['outputs.GetLinuxWebAppAuthSettingGithubResult']:
        """
        A `github` block as defined below.
        """
        return pulumi.get(self, "githubs")

    @property
    @pulumi.getter
    def googles(self) -> Sequence['outputs.GetLinuxWebAppAuthSettingGoogleResult']:
        """
        A `google` block as defined below.
        """
        return pulumi.get(self, "googles")

    @property
    @pulumi.getter
    def issuer(self) -> str:
        """
        The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Linux Web App.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def microsofts(self) -> Sequence['outputs.GetLinuxWebAppAuthSettingMicrosoftResult']:
        """
        A `microsoft` block as defined below.
        """
        return pulumi.get(self, "microsofts")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> str:
        """
        The Runtime Version of the Authentication and Authorisation feature of this App.
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> float:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API.
        """
        return pulumi.get(self, "token_refresh_extension_hours")

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> bool:
        """
        Is the Token Store configuration Enabled.
        """
        return pulumi.get(self, "token_store_enabled")

    @property
    @pulumi.getter
    def twitters(self) -> Sequence['outputs.GetLinuxWebAppAuthSettingTwitterResult']:
        """
        A `twitter` block as defined below.
        """
        return pulumi.get(self, "twitters")

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> str:
        """
        The action to take when an unauthenticated client attempts to access the app.
        """
        return pulumi.get(self, "unauthenticated_client_action")


@pulumi.output_type
class GetLinuxWebAppAuthSettingActiveDirectoryResult(dict):
    def __init__(__self__, *,
                 allowed_audiences: Sequence[str],
                 client_id: str,
                 client_secret: str,
                 client_secret_setting_name: str):
        """
        :param Sequence[str] allowed_audiences: The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
        :param str client_id: The OAuth 2.0 client ID used by the app for authentication.
        :param str client_secret: The OAuth 2.0 client secret used by the app for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        """
        pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Sequence[str]:
        """
        The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID used by the app for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The OAuth 2.0 client secret used by the app for authentication.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")


@pulumi.output_type
class GetLinuxWebAppAuthSettingFacebookResult(dict):
    def __init__(__self__, *,
                 app_id: str,
                 app_secret: str,
                 app_secret_setting_name: str,
                 oauth_scopes: Sequence[str]):
        """
        :param str app_id: The App ID of the Facebook app used for login.
        :param str app_secret: The App Secret of the Facebook app used for Facebook login.
        :param str app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook login.
        :param Sequence[str] oauth_scopes: A list of OAuth 2.0 scopes requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "app_secret", app_secret)
        pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appSecret")
    def app_secret(self) -> str:
        """
        The App Secret of the Facebook app used for Facebook login.
        """
        return pulumi.get(self, "app_secret")

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> str:
        """
        The app setting name that contains the `app_secret` value used for Facebook login.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Sequence[str]:
        """
        A list of OAuth 2.0 scopes requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class GetLinuxWebAppAuthSettingGithubResult(dict):
    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 client_secret_setting_name: str,
                 oauth_scopes: Sequence[str]):
        """
        :param str client_id: The OAuth 2.0 client ID used by the app for authentication.
        :param str client_secret: The OAuth 2.0 client secret used by the app for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        :param Sequence[str] oauth_scopes: A list of OAuth 2.0 scopes requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID used by the app for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The OAuth 2.0 client secret used by the app for authentication.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Sequence[str]:
        """
        A list of OAuth 2.0 scopes requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class GetLinuxWebAppAuthSettingGoogleResult(dict):
    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 client_secret_setting_name: str,
                 oauth_scopes: Sequence[str]):
        """
        :param str client_id: The OAuth 2.0 client ID used by the app for authentication.
        :param str client_secret: The OAuth 2.0 client secret used by the app for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        :param Sequence[str] oauth_scopes: A list of OAuth 2.0 scopes requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID used by the app for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The OAuth 2.0 client secret used by the app for authentication.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Sequence[str]:
        """
        A list of OAuth 2.0 scopes requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class GetLinuxWebAppAuthSettingMicrosoftResult(dict):
    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 client_secret_setting_name: str,
                 oauth_scopes: Sequence[str]):
        """
        :param str client_id: The OAuth 2.0 client ID used by the app for authentication.
        :param str client_secret: The OAuth 2.0 client secret used by the app for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        :param Sequence[str] oauth_scopes: A list of OAuth 2.0 scopes requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID used by the app for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The OAuth 2.0 client secret used by the app for authentication.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Sequence[str]:
        """
        A list of OAuth 2.0 scopes requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class GetLinuxWebAppAuthSettingTwitterResult(dict):
    def __init__(__self__, *,
                 consumer_key: str,
                 consumer_secret: str,
                 consumer_secret_setting_name: str):
        """
        :param str consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param str consumer_secret: The OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        :param str consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        pulumi.set(__self__, "consumer_secret", consumer_secret)
        pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> str:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> str:
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_secret")

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> str:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_secret_setting_name")


@pulumi.output_type
class GetLinuxWebAppAuthSettingsV2Result(dict):
    def __init__(__self__, *,
                 active_directory_v2s: Sequence['outputs.GetLinuxWebAppAuthSettingsV2ActiveDirectoryV2Result'],
                 apple_v2s: Sequence['outputs.GetLinuxWebAppAuthSettingsV2AppleV2Result'],
                 auth_enabled: bool,
                 azure_static_web_app_v2s: Sequence['outputs.GetLinuxWebAppAuthSettingsV2AzureStaticWebAppV2Result'],
                 config_file_path: str,
                 custom_oidc_v2s: Sequence['outputs.GetLinuxWebAppAuthSettingsV2CustomOidcV2Result'],
                 default_provider: str,
                 excluded_paths: Sequence[str],
                 facebook_v2s: Sequence['outputs.GetLinuxWebAppAuthSettingsV2FacebookV2Result'],
                 forward_proxy_convention: str,
                 forward_proxy_custom_host_header_name: str,
                 forward_proxy_custom_scheme_header_name: str,
                 github_v2s: Sequence['outputs.GetLinuxWebAppAuthSettingsV2GithubV2Result'],
                 google_v2s: Sequence['outputs.GetLinuxWebAppAuthSettingsV2GoogleV2Result'],
                 http_route_api_prefix: str,
                 logins: Sequence['outputs.GetLinuxWebAppAuthSettingsV2LoginResult'],
                 microsoft_v2s: Sequence['outputs.GetLinuxWebAppAuthSettingsV2MicrosoftV2Result'],
                 require_authentication: bool,
                 require_https: bool,
                 runtime_version: str,
                 twitter_v2s: Sequence['outputs.GetLinuxWebAppAuthSettingsV2TwitterV2Result'],
                 unauthenticated_action: str):
        """
        :param Sequence['GetLinuxWebAppAuthSettingsV2ActiveDirectoryV2Args'] active_directory_v2s: An `active_directory_v2` block as defined below.
        :param Sequence['GetLinuxWebAppAuthSettingsV2AppleV2Args'] apple_v2s: An `apple_v2` block as defined below.
        :param bool auth_enabled: Are the AuthV2 Settings enabled.
        :param Sequence['GetLinuxWebAppAuthSettingsV2AzureStaticWebAppV2Args'] azure_static_web_app_v2s: An `azure_static_web_app_v2` block as defined below.
        :param str config_file_path: The path to the App Auth settings.
        :param Sequence['GetLinuxWebAppAuthSettingsV2CustomOidcV2Args'] custom_oidc_v2s: Zero or more `custom_oidc_v2` blocks as defined below.
        :param str default_provider: The Default Authentication Provider used when more than one Authentication Provider is configured and the `unauthenticated_action` is set to `RedirectToLoginPage`.
        :param Sequence[str] excluded_paths: The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.
        :param Sequence['GetLinuxWebAppAuthSettingsV2FacebookV2Args'] facebook_v2s: A `facebook_v2` block as defined below.
        :param str forward_proxy_convention: The convention used to determine the url of the request made.
        :param str forward_proxy_custom_host_header_name: The name of the custom header containing the host of the request.
        :param str forward_proxy_custom_scheme_header_name: The name of the custom header containing the scheme of the request.
        :param Sequence['GetLinuxWebAppAuthSettingsV2GithubV2Args'] github_v2s: A `github_v2` block as defined below.
        :param Sequence['GetLinuxWebAppAuthSettingsV2GoogleV2Args'] google_v2s: A `google_v2` block as defined below.
        :param str http_route_api_prefix: The prefix that should precede all the authentication and authorisation paths.
        :param Sequence['GetLinuxWebAppAuthSettingsV2LoginArgs'] logins: A `login` block as defined below.
        :param Sequence['GetLinuxWebAppAuthSettingsV2MicrosoftV2Args'] microsoft_v2s: A `microsoft_v2` block as defined below.
        :param bool require_authentication: Is the authentication flow used for all requests.
        :param bool require_https: Is HTTPS required on connections?
        :param str runtime_version: The Runtime Version of the Authentication and Authorisation feature of this App.
        :param Sequence['GetLinuxWebAppAuthSettingsV2TwitterV2Args'] twitter_v2s: A `twitter_v2` block as defined below.
        :param str unauthenticated_action: The action to take for requests made without authentication.
        """
        pulumi.set(__self__, "active_directory_v2s", active_directory_v2s)
        pulumi.set(__self__, "apple_v2s", apple_v2s)
        pulumi.set(__self__, "auth_enabled", auth_enabled)
        pulumi.set(__self__, "azure_static_web_app_v2s", azure_static_web_app_v2s)
        pulumi.set(__self__, "config_file_path", config_file_path)
        pulumi.set(__self__, "custom_oidc_v2s", custom_oidc_v2s)
        pulumi.set(__self__, "default_provider", default_provider)
        pulumi.set(__self__, "excluded_paths", excluded_paths)
        pulumi.set(__self__, "facebook_v2s", facebook_v2s)
        pulumi.set(__self__, "forward_proxy_convention", forward_proxy_convention)
        pulumi.set(__self__, "forward_proxy_custom_host_header_name", forward_proxy_custom_host_header_name)
        pulumi.set(__self__, "forward_proxy_custom_scheme_header_name", forward_proxy_custom_scheme_header_name)
        pulumi.set(__self__, "github_v2s", github_v2s)
        pulumi.set(__self__, "google_v2s", google_v2s)
        pulumi.set(__self__, "http_route_api_prefix", http_route_api_prefix)
        pulumi.set(__self__, "logins", logins)
        pulumi.set(__self__, "microsoft_v2s", microsoft_v2s)
        pulumi.set(__self__, "require_authentication", require_authentication)
        pulumi.set(__self__, "require_https", require_https)
        pulumi.set(__self__, "runtime_version", runtime_version)
        pulumi.set(__self__, "twitter_v2s", twitter_v2s)
        pulumi.set(__self__, "unauthenticated_action", unauthenticated_action)

    @property
    @pulumi.getter(name="activeDirectoryV2s")
    def active_directory_v2s(self) -> Sequence['outputs.GetLinuxWebAppAuthSettingsV2ActiveDirectoryV2Result']:
        """
        An `active_directory_v2` block as defined below.
        """
        return pulumi.get(self, "active_directory_v2s")

    @property
    @pulumi.getter(name="appleV2s")
    def apple_v2s(self) -> Sequence['outputs.GetLinuxWebAppAuthSettingsV2AppleV2Result']:
        """
        An `apple_v2` block as defined below.
        """
        return pulumi.get(self, "apple_v2s")

    @property
    @pulumi.getter(name="authEnabled")
    def auth_enabled(self) -> bool:
        """
        Are the AuthV2 Settings enabled.
        """
        return pulumi.get(self, "auth_enabled")

    @property
    @pulumi.getter(name="azureStaticWebAppV2s")
    def azure_static_web_app_v2s(self) -> Sequence['outputs.GetLinuxWebAppAuthSettingsV2AzureStaticWebAppV2Result']:
        """
        An `azure_static_web_app_v2` block as defined below.
        """
        return pulumi.get(self, "azure_static_web_app_v2s")

    @property
    @pulumi.getter(name="configFilePath")
    def config_file_path(self) -> str:
        """
        The path to the App Auth settings.
        """
        return pulumi.get(self, "config_file_path")

    @property
    @pulumi.getter(name="customOidcV2s")
    def custom_oidc_v2s(self) -> Sequence['outputs.GetLinuxWebAppAuthSettingsV2CustomOidcV2Result']:
        """
        Zero or more `custom_oidc_v2` blocks as defined below.
        """
        return pulumi.get(self, "custom_oidc_v2s")

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> str:
        """
        The Default Authentication Provider used when more than one Authentication Provider is configured and the `unauthenticated_action` is set to `RedirectToLoginPage`.
        """
        return pulumi.get(self, "default_provider")

    @property
    @pulumi.getter(name="excludedPaths")
    def excluded_paths(self) -> Sequence[str]:
        """
        The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.
        """
        return pulumi.get(self, "excluded_paths")

    @property
    @pulumi.getter(name="facebookV2s")
    def facebook_v2s(self) -> Sequence['outputs.GetLinuxWebAppAuthSettingsV2FacebookV2Result']:
        """
        A `facebook_v2` block as defined below.
        """
        return pulumi.get(self, "facebook_v2s")

    @property
    @pulumi.getter(name="forwardProxyConvention")
    def forward_proxy_convention(self) -> str:
        """
        The convention used to determine the url of the request made.
        """
        return pulumi.get(self, "forward_proxy_convention")

    @property
    @pulumi.getter(name="forwardProxyCustomHostHeaderName")
    def forward_proxy_custom_host_header_name(self) -> str:
        """
        The name of the custom header containing the host of the request.
        """
        return pulumi.get(self, "forward_proxy_custom_host_header_name")

    @property
    @pulumi.getter(name="forwardProxyCustomSchemeHeaderName")
    def forward_proxy_custom_scheme_header_name(self) -> str:
        """
        The name of the custom header containing the scheme of the request.
        """
        return pulumi.get(self, "forward_proxy_custom_scheme_header_name")

    @property
    @pulumi.getter(name="githubV2s")
    def github_v2s(self) -> Sequence['outputs.GetLinuxWebAppAuthSettingsV2GithubV2Result']:
        """
        A `github_v2` block as defined below.
        """
        return pulumi.get(self, "github_v2s")

    @property
    @pulumi.getter(name="googleV2s")
    def google_v2s(self) -> Sequence['outputs.GetLinuxWebAppAuthSettingsV2GoogleV2Result']:
        """
        A `google_v2` block as defined below.
        """
        return pulumi.get(self, "google_v2s")

    @property
    @pulumi.getter(name="httpRouteApiPrefix")
    def http_route_api_prefix(self) -> str:
        """
        The prefix that should precede all the authentication and authorisation paths.
        """
        return pulumi.get(self, "http_route_api_prefix")

    @property
    @pulumi.getter
    def logins(self) -> Sequence['outputs.GetLinuxWebAppAuthSettingsV2LoginResult']:
        """
        A `login` block as defined below.
        """
        return pulumi.get(self, "logins")

    @property
    @pulumi.getter(name="microsoftV2s")
    def microsoft_v2s(self) -> Sequence['outputs.GetLinuxWebAppAuthSettingsV2MicrosoftV2Result']:
        """
        A `microsoft_v2` block as defined below.
        """
        return pulumi.get(self, "microsoft_v2s")

    @property
    @pulumi.getter(name="requireAuthentication")
    def require_authentication(self) -> bool:
        """
        Is the authentication flow used for all requests.
        """
        return pulumi.get(self, "require_authentication")

    @property
    @pulumi.getter(name="requireHttps")
    def require_https(self) -> bool:
        """
        Is HTTPS required on connections?
        """
        return pulumi.get(self, "require_https")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> str:
        """
        The Runtime Version of the Authentication and Authorisation feature of this App.
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter(name="twitterV2s")
    def twitter_v2s(self) -> Sequence['outputs.GetLinuxWebAppAuthSettingsV2TwitterV2Result']:
        """
        A `twitter_v2` block as defined below.
        """
        return pulumi.get(self, "twitter_v2s")

    @property
    @pulumi.getter(name="unauthenticatedAction")
    def unauthenticated_action(self) -> str:
        """
        The action to take for requests made without authentication.
        """
        return pulumi.get(self, "unauthenticated_action")


@pulumi.output_type
class GetLinuxWebAppAuthSettingsV2ActiveDirectoryV2Result(dict):
    def __init__(__self__, *,
                 allowed_applications: Sequence[str],
                 allowed_audiences: Sequence[str],
                 allowed_groups: Sequence[str],
                 allowed_identities: Sequence[str],
                 client_id: str,
                 client_secret_certificate_thumbprint: str,
                 client_secret_setting_name: str,
                 jwt_allowed_client_applications: Sequence[str],
                 jwt_allowed_groups: Sequence[str],
                 login_parameters: Mapping[str, str],
                 tenant_auth_endpoint: str,
                 www_authentication_disabled: bool):
        """
        :param Sequence[str] allowed_applications: The list of allowed Applications for the Default Authorisation Policy.
        :param Sequence[str] allowed_audiences: The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
        :param Sequence[str] allowed_groups: The list of allowed Group Names for the Default Authorisation Policy.
        :param Sequence[str] allowed_identities: The list of allowed Identities for the Default Authorisation Policy.
        :param str client_id: The OAuth 2.0 client ID used by the app for authentication.
        :param str client_secret_certificate_thumbprint: The thumbprint of the certificate used for signing purposes.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        :param Sequence[str] jwt_allowed_client_applications: The list of Allowed Client Applications in the JWT Claim.
        :param Sequence[str] jwt_allowed_groups: The list of Allowed Groups in the JWT Claim.
        :param Mapping[str, str] login_parameters: A map of key-value pairs sent to the Authorisation Endpoint when a user logs in.
        :param str tenant_auth_endpoint: The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`
        :param bool www_authentication_disabled: Is the www-authenticate provider omitted from the request?
        """
        pulumi.set(__self__, "allowed_applications", allowed_applications)
        pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        pulumi.set(__self__, "allowed_groups", allowed_groups)
        pulumi.set(__self__, "allowed_identities", allowed_identities)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_certificate_thumbprint", client_secret_certificate_thumbprint)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "jwt_allowed_client_applications", jwt_allowed_client_applications)
        pulumi.set(__self__, "jwt_allowed_groups", jwt_allowed_groups)
        pulumi.set(__self__, "login_parameters", login_parameters)
        pulumi.set(__self__, "tenant_auth_endpoint", tenant_auth_endpoint)
        pulumi.set(__self__, "www_authentication_disabled", www_authentication_disabled)

    @property
    @pulumi.getter(name="allowedApplications")
    def allowed_applications(self) -> Sequence[str]:
        """
        The list of allowed Applications for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_applications")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Sequence[str]:
        """
        The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="allowedGroups")
    def allowed_groups(self) -> Sequence[str]:
        """
        The list of allowed Group Names for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_groups")

    @property
    @pulumi.getter(name="allowedIdentities")
    def allowed_identities(self) -> Sequence[str]:
        """
        The list of allowed Identities for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_identities")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID used by the app for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretCertificateThumbprint")
    def client_secret_certificate_thumbprint(self) -> str:
        """
        The thumbprint of the certificate used for signing purposes.
        """
        return pulumi.get(self, "client_secret_certificate_thumbprint")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="jwtAllowedClientApplications")
    def jwt_allowed_client_applications(self) -> Sequence[str]:
        """
        The list of Allowed Client Applications in the JWT Claim.
        """
        return pulumi.get(self, "jwt_allowed_client_applications")

    @property
    @pulumi.getter(name="jwtAllowedGroups")
    def jwt_allowed_groups(self) -> Sequence[str]:
        """
        The list of Allowed Groups in the JWT Claim.
        """
        return pulumi.get(self, "jwt_allowed_groups")

    @property
    @pulumi.getter(name="loginParameters")
    def login_parameters(self) -> Mapping[str, str]:
        """
        A map of key-value pairs sent to the Authorisation Endpoint when a user logs in.
        """
        return pulumi.get(self, "login_parameters")

    @property
    @pulumi.getter(name="tenantAuthEndpoint")
    def tenant_auth_endpoint(self) -> str:
        """
        The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`
        """
        return pulumi.get(self, "tenant_auth_endpoint")

    @property
    @pulumi.getter(name="wwwAuthenticationDisabled")
    def www_authentication_disabled(self) -> bool:
        """
        Is the www-authenticate provider omitted from the request?
        """
        return pulumi.get(self, "www_authentication_disabled")


@pulumi.output_type
class GetLinuxWebAppAuthSettingsV2AppleV2Result(dict):
    def __init__(__self__, *,
                 client_id: str,
                 client_secret_setting_name: str,
                 login_scopes: Sequence[str]):
        """
        :param str client_id: The OAuth 2.0 client ID used by the app for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        :param Sequence[str] login_scopes: The list of Login scopes that are requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID used by the app for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Sequence[str]:
        """
        The list of Login scopes that are requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class GetLinuxWebAppAuthSettingsV2AzureStaticWebAppV2Result(dict):
    def __init__(__self__, *,
                 client_id: str):
        """
        :param str client_id: The OAuth 2.0 client ID used by the app for authentication.
        """
        pulumi.set(__self__, "client_id", client_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID used by the app for authentication.
        """
        return pulumi.get(self, "client_id")


@pulumi.output_type
class GetLinuxWebAppAuthSettingsV2CustomOidcV2Result(dict):
    def __init__(__self__, *,
                 authorisation_endpoint: str,
                 certification_uri: str,
                 client_credential_method: str,
                 client_id: str,
                 client_secret_setting_name: str,
                 issuer_endpoint: str,
                 name: str,
                 name_claim_type: str,
                 openid_configuration_endpoint: str,
                 scopes: Sequence[str],
                 token_endpoint: str):
        """
        :param str authorisation_endpoint: The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        :param str certification_uri: The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        :param str client_credential_method: The Client Credential Method used.
        :param str client_id: The OAuth 2.0 client ID used by the app for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        :param str issuer_endpoint: The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        :param str name: The name of this Linux Web App.
        :param str name_claim_type: The name of the claim that contains the users name.
        :param str openid_configuration_endpoint: The app setting name that contains the `client_secret` value used for the Custom OIDC Login.
        :param Sequence[str] scopes: The list of the scopes that are requested while authenticating.
        :param str token_endpoint: The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
        pulumi.set(__self__, "authorisation_endpoint", authorisation_endpoint)
        pulumi.set(__self__, "certification_uri", certification_uri)
        pulumi.set(__self__, "client_credential_method", client_credential_method)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "issuer_endpoint", issuer_endpoint)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "name_claim_type", name_claim_type)
        pulumi.set(__self__, "openid_configuration_endpoint", openid_configuration_endpoint)
        pulumi.set(__self__, "scopes", scopes)
        pulumi.set(__self__, "token_endpoint", token_endpoint)

    @property
    @pulumi.getter(name="authorisationEndpoint")
    def authorisation_endpoint(self) -> str:
        """
        The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "authorisation_endpoint")

    @property
    @pulumi.getter(name="certificationUri")
    def certification_uri(self) -> str:
        """
        The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "certification_uri")

    @property
    @pulumi.getter(name="clientCredentialMethod")
    def client_credential_method(self) -> str:
        """
        The Client Credential Method used.
        """
        return pulumi.get(self, "client_credential_method")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID used by the app for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="issuerEndpoint")
    def issuer_endpoint(self) -> str:
        """
        The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "issuer_endpoint")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this Linux Web App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nameClaimType")
    def name_claim_type(self) -> str:
        """
        The name of the claim that contains the users name.
        """
        return pulumi.get(self, "name_claim_type")

    @property
    @pulumi.getter(name="openidConfigurationEndpoint")
    def openid_configuration_endpoint(self) -> str:
        """
        The app setting name that contains the `client_secret` value used for the Custom OIDC Login.
        """
        return pulumi.get(self, "openid_configuration_endpoint")

    @property
    @pulumi.getter
    def scopes(self) -> Sequence[str]:
        """
        The list of the scopes that are requested while authenticating.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> str:
        """
        The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "token_endpoint")


@pulumi.output_type
class GetLinuxWebAppAuthSettingsV2FacebookV2Result(dict):
    def __init__(__self__, *,
                 app_id: str,
                 app_secret_setting_name: str,
                 graph_api_version: str,
                 login_scopes: Sequence[str]):
        """
        :param str app_id: The App ID of the Facebook app used for login.
        :param str app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook login.
        :param str graph_api_version: The version of the Facebook API to be used while logging in.
        :param Sequence[str] login_scopes: The list of Login scopes that are requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        pulumi.set(__self__, "graph_api_version", graph_api_version)
        pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> str:
        """
        The app setting name that contains the `app_secret` value used for Facebook login.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @property
    @pulumi.getter(name="graphApiVersion")
    def graph_api_version(self) -> str:
        """
        The version of the Facebook API to be used while logging in.
        """
        return pulumi.get(self, "graph_api_version")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Sequence[str]:
        """
        The list of Login scopes that are requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class GetLinuxWebAppAuthSettingsV2GithubV2Result(dict):
    def __init__(__self__, *,
                 client_id: str,
                 client_secret_setting_name: str,
                 login_scopes: Sequence[str]):
        """
        :param str client_id: The OAuth 2.0 client ID used by the app for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        :param Sequence[str] login_scopes: The list of Login scopes that are requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID used by the app for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Sequence[str]:
        """
        The list of Login scopes that are requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class GetLinuxWebAppAuthSettingsV2GoogleV2Result(dict):
    def __init__(__self__, *,
                 allowed_audiences: Sequence[str],
                 client_id: str,
                 client_secret_setting_name: str,
                 login_scopes: Sequence[str]):
        """
        :param Sequence[str] allowed_audiences: The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
        :param str client_id: The OAuth 2.0 client ID used by the app for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        :param Sequence[str] login_scopes: The list of Login scopes that are requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Sequence[str]:
        """
        The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID used by the app for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Sequence[str]:
        """
        The list of Login scopes that are requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class GetLinuxWebAppAuthSettingsV2LoginResult(dict):
    def __init__(__self__, *,
                 allowed_external_redirect_urls: Sequence[str],
                 cookie_expiration_convention: str,
                 cookie_expiration_time: str,
                 logout_endpoint: str,
                 nonce_expiration_time: str,
                 preserve_url_fragments_for_logins: bool,
                 token_refresh_extension_time: float,
                 token_store_enabled: bool,
                 token_store_path: str,
                 token_store_sas_setting_name: str,
                 validate_nonce: bool):
        """
        :param Sequence[str] allowed_external_redirect_urls: External URLs that can be redirected to as part of logging in or logging out of the app.
        :param str cookie_expiration_convention: The method by which cookies expire.
        :param str cookie_expiration_time: The time after the request is made when the session cookie should expire.
        :param str logout_endpoint: The endpoint to which logout requests are made.
        :param str nonce_expiration_time: The time after the request is made when the nonce should expire.
        :param bool preserve_url_fragments_for_logins: Are the fragments from the request preserved after the login request is made.
        :param float token_refresh_extension_time: The number of hours after session token expiration that a session token can be used to call the token refresh API.
        :param bool token_store_enabled: Is the Token Store configuration Enabled.
        :param str token_store_path: The directory path in the App Filesystem in which the tokens are stored.
        :param str token_store_sas_setting_name: The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        :param bool validate_nonce: Is the nonce validated while completing the login flow.
        """
        pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        pulumi.set(__self__, "cookie_expiration_convention", cookie_expiration_convention)
        pulumi.set(__self__, "cookie_expiration_time", cookie_expiration_time)
        pulumi.set(__self__, "logout_endpoint", logout_endpoint)
        pulumi.set(__self__, "nonce_expiration_time", nonce_expiration_time)
        pulumi.set(__self__, "preserve_url_fragments_for_logins", preserve_url_fragments_for_logins)
        pulumi.set(__self__, "token_refresh_extension_time", token_refresh_extension_time)
        pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        pulumi.set(__self__, "token_store_path", token_store_path)
        pulumi.set(__self__, "token_store_sas_setting_name", token_store_sas_setting_name)
        pulumi.set(__self__, "validate_nonce", validate_nonce)

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Sequence[str]:
        """
        External URLs that can be redirected to as part of logging in or logging out of the app.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @property
    @pulumi.getter(name="cookieExpirationConvention")
    def cookie_expiration_convention(self) -> str:
        """
        The method by which cookies expire.
        """
        return pulumi.get(self, "cookie_expiration_convention")

    @property
    @pulumi.getter(name="cookieExpirationTime")
    def cookie_expiration_time(self) -> str:
        """
        The time after the request is made when the session cookie should expire.
        """
        return pulumi.get(self, "cookie_expiration_time")

    @property
    @pulumi.getter(name="logoutEndpoint")
    def logout_endpoint(self) -> str:
        """
        The endpoint to which logout requests are made.
        """
        return pulumi.get(self, "logout_endpoint")

    @property
    @pulumi.getter(name="nonceExpirationTime")
    def nonce_expiration_time(self) -> str:
        """
        The time after the request is made when the nonce should expire.
        """
        return pulumi.get(self, "nonce_expiration_time")

    @property
    @pulumi.getter(name="preserveUrlFragmentsForLogins")
    def preserve_url_fragments_for_logins(self) -> bool:
        """
        Are the fragments from the request preserved after the login request is made.
        """
        return pulumi.get(self, "preserve_url_fragments_for_logins")

    @property
    @pulumi.getter(name="tokenRefreshExtensionTime")
    def token_refresh_extension_time(self) -> float:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API.
        """
        return pulumi.get(self, "token_refresh_extension_time")

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> bool:
        """
        Is the Token Store configuration Enabled.
        """
        return pulumi.get(self, "token_store_enabled")

    @property
    @pulumi.getter(name="tokenStorePath")
    def token_store_path(self) -> str:
        """
        The directory path in the App Filesystem in which the tokens are stored.
        """
        return pulumi.get(self, "token_store_path")

    @property
    @pulumi.getter(name="tokenStoreSasSettingName")
    def token_store_sas_setting_name(self) -> str:
        """
        The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        """
        return pulumi.get(self, "token_store_sas_setting_name")

    @property
    @pulumi.getter(name="validateNonce")
    def validate_nonce(self) -> bool:
        """
        Is the nonce validated while completing the login flow.
        """
        return pulumi.get(self, "validate_nonce")


@pulumi.output_type
class GetLinuxWebAppAuthSettingsV2MicrosoftV2Result(dict):
    def __init__(__self__, *,
                 allowed_audiences: Sequence[str],
                 client_id: str,
                 client_secret_setting_name: str,
                 login_scopes: Sequence[str]):
        """
        :param Sequence[str] allowed_audiences: The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
        :param str client_id: The OAuth 2.0 client ID used by the app for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        :param Sequence[str] login_scopes: The list of Login scopes that are requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Sequence[str]:
        """
        The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID used by the app for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Sequence[str]:
        """
        The list of Login scopes that are requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class GetLinuxWebAppAuthSettingsV2TwitterV2Result(dict):
    def __init__(__self__, *,
                 consumer_key: str,
                 consumer_secret_setting_name: str):
        """
        :param str consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param str consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> str:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> str:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_secret_setting_name")


@pulumi.output_type
class GetLinuxWebAppBackupResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 name: str,
                 schedules: Sequence['outputs.GetLinuxWebAppBackupScheduleResult'],
                 storage_account_url: str):
        """
        :param bool enabled: Is the Backup enabled?
        :param str name: The name of this Linux Web App.
        :param Sequence['GetLinuxWebAppBackupScheduleArgs'] schedules: A `schedule` block as defined below.
        :param str storage_account_url: The SAS URL to the container.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schedules", schedules)
        pulumi.set(__self__, "storage_account_url", storage_account_url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is the Backup enabled?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this Linux Web App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def schedules(self) -> Sequence['outputs.GetLinuxWebAppBackupScheduleResult']:
        """
        A `schedule` block as defined below.
        """
        return pulumi.get(self, "schedules")

    @property
    @pulumi.getter(name="storageAccountUrl")
    def storage_account_url(self) -> str:
        """
        The SAS URL to the container.
        """
        return pulumi.get(self, "storage_account_url")


@pulumi.output_type
class GetLinuxWebAppBackupScheduleResult(dict):
    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_unit: str,
                 keep_at_least_one_backup: bool,
                 last_execution_time: str,
                 retention_period_days: int,
                 start_time: str):
        """
        :param int frequency_interval: How often the backup will be executed.
        :param str frequency_unit: The unit of time for how often the backup should take place.
        :param bool keep_at_least_one_backup: Will the service keep at least one backup, regardless of age of backup.
        :param str last_execution_time: The time of the last backup attempt.
        :param int retention_period_days: After how many days backups should be deleted.
        :param str start_time: When the schedule should start in RFC-3339 format.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_unit", frequency_unit)
        pulumi.set(__self__, "keep_at_least_one_backup", keep_at_least_one_backup)
        pulumi.set(__self__, "last_execution_time", last_execution_time)
        pulumi.set(__self__, "retention_period_days", retention_period_days)
        pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        How often the backup will be executed.
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyUnit")
    def frequency_unit(self) -> str:
        """
        The unit of time for how often the backup should take place.
        """
        return pulumi.get(self, "frequency_unit")

    @property
    @pulumi.getter(name="keepAtLeastOneBackup")
    def keep_at_least_one_backup(self) -> bool:
        """
        Will the service keep at least one backup, regardless of age of backup.
        """
        return pulumi.get(self, "keep_at_least_one_backup")

    @property
    @pulumi.getter(name="lastExecutionTime")
    def last_execution_time(self) -> str:
        """
        The time of the last backup attempt.
        """
        return pulumi.get(self, "last_execution_time")

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> int:
        """
        After how many days backups should be deleted.
        """
        return pulumi.get(self, "retention_period_days")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        """
        When the schedule should start in RFC-3339 format.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class GetLinuxWebAppConnectionStringResult(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: The name of this Linux Web App.
        :param str type: The Azure Storage Type.
        :param str value: The Connection String value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this Linux Web App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The Azure Storage Type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The Connection String value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetLinuxWebAppIdentityResult(dict):
    def __init__(__self__, *,
                 identity_ids: Sequence[str],
                 principal_id: str,
                 tenant_id: str,
                 type: str):
        """
        :param Sequence[str] identity_ids: The list of User Assigned Managed Identity IDs assigned to this Linux Web App.
        :param str principal_id: The Principal ID of the System Assigned Managed Service Identity that is configured on this Linux Web App.
        :param str tenant_id: The Tenant ID of the System Assigned Managed Service Identity that is configured on this Linux Web App.
        :param str type: The Azure Storage Type.
        """
        pulumi.set(__self__, "identity_ids", identity_ids)
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Sequence[str]:
        """
        The list of User Assigned Managed Identity IDs assigned to this Linux Web App.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The Principal ID of the System Assigned Managed Service Identity that is configured on this Linux Web App.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The Tenant ID of the System Assigned Managed Service Identity that is configured on this Linux Web App.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The Azure Storage Type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetLinuxWebAppLogResult(dict):
    def __init__(__self__, *,
                 application_logs: Sequence['outputs.GetLinuxWebAppLogApplicationLogResult'],
                 detailed_error_messages: bool,
                 failed_request_tracing: bool,
                 http_logs: Sequence['outputs.GetLinuxWebAppLogHttpLogResult']):
        """
        :param Sequence['GetLinuxWebAppLogApplicationLogArgs'] application_logs: A `application_logs` block as defined above.
        :param bool detailed_error_messages: Is Detailed Error Messaging enabled.
        :param bool failed_request_tracing: Is Failed Request Tracing enabled.
        :param Sequence['GetLinuxWebAppLogHttpLogArgs'] http_logs: An `http_logs` block as defined above.
        """
        pulumi.set(__self__, "application_logs", application_logs)
        pulumi.set(__self__, "detailed_error_messages", detailed_error_messages)
        pulumi.set(__self__, "failed_request_tracing", failed_request_tracing)
        pulumi.set(__self__, "http_logs", http_logs)

    @property
    @pulumi.getter(name="applicationLogs")
    def application_logs(self) -> Sequence['outputs.GetLinuxWebAppLogApplicationLogResult']:
        """
        A `application_logs` block as defined above.
        """
        return pulumi.get(self, "application_logs")

    @property
    @pulumi.getter(name="detailedErrorMessages")
    def detailed_error_messages(self) -> bool:
        """
        Is Detailed Error Messaging enabled.
        """
        return pulumi.get(self, "detailed_error_messages")

    @property
    @pulumi.getter(name="failedRequestTracing")
    def failed_request_tracing(self) -> bool:
        """
        Is Failed Request Tracing enabled.
        """
        return pulumi.get(self, "failed_request_tracing")

    @property
    @pulumi.getter(name="httpLogs")
    def http_logs(self) -> Sequence['outputs.GetLinuxWebAppLogHttpLogResult']:
        """
        An `http_logs` block as defined above.
        """
        return pulumi.get(self, "http_logs")


@pulumi.output_type
class GetLinuxWebAppLogApplicationLogResult(dict):
    def __init__(__self__, *,
                 azure_blob_storages: Sequence['outputs.GetLinuxWebAppLogApplicationLogAzureBlobStorageResult'],
                 file_system_level: str):
        """
        :param Sequence['GetLinuxWebAppLogApplicationLogAzureBlobStorageArgs'] azure_blob_storages: A `azure_blob_storage` block as defined above.
        :param str file_system_level: The logging level.
        """
        pulumi.set(__self__, "azure_blob_storages", azure_blob_storages)
        pulumi.set(__self__, "file_system_level", file_system_level)

    @property
    @pulumi.getter(name="azureBlobStorages")
    def azure_blob_storages(self) -> Sequence['outputs.GetLinuxWebAppLogApplicationLogAzureBlobStorageResult']:
        """
        A `azure_blob_storage` block as defined above.
        """
        return pulumi.get(self, "azure_blob_storages")

    @property
    @pulumi.getter(name="fileSystemLevel")
    def file_system_level(self) -> str:
        """
        The logging level.
        """
        return pulumi.get(self, "file_system_level")


@pulumi.output_type
class GetLinuxWebAppLogApplicationLogAzureBlobStorageResult(dict):
    def __init__(__self__, *,
                 level: str,
                 retention_in_days: int,
                 sas_url: str):
        """
        :param str level: The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        :param int retention_in_days: The retention period in days.
        :param str sas_url: The SAS url to an Azure blob container.
        """
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "sas_url", sas_url)

    @property
    @pulumi.getter
    def level(self) -> str:
        """
        The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        """
        return pulumi.get(self, "level")

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> int:
        """
        The retention period in days.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> str:
        """
        The SAS url to an Azure blob container.
        """
        return pulumi.get(self, "sas_url")


@pulumi.output_type
class GetLinuxWebAppLogHttpLogResult(dict):
    def __init__(__self__, *,
                 azure_blob_storages: Sequence['outputs.GetLinuxWebAppLogHttpLogAzureBlobStorageResult'],
                 file_systems: Sequence['outputs.GetLinuxWebAppLogHttpLogFileSystemResult']):
        """
        :param Sequence['GetLinuxWebAppLogHttpLogAzureBlobStorageArgs'] azure_blob_storages: A `azure_blob_storage` block as defined above.
        :param Sequence['GetLinuxWebAppLogHttpLogFileSystemArgs'] file_systems: A `file_system` block as defined above.
        """
        pulumi.set(__self__, "azure_blob_storages", azure_blob_storages)
        pulumi.set(__self__, "file_systems", file_systems)

    @property
    @pulumi.getter(name="azureBlobStorages")
    def azure_blob_storages(self) -> Sequence['outputs.GetLinuxWebAppLogHttpLogAzureBlobStorageResult']:
        """
        A `azure_blob_storage` block as defined above.
        """
        return pulumi.get(self, "azure_blob_storages")

    @property
    @pulumi.getter(name="fileSystems")
    def file_systems(self) -> Sequence['outputs.GetLinuxWebAppLogHttpLogFileSystemResult']:
        """
        A `file_system` block as defined above.
        """
        return pulumi.get(self, "file_systems")


@pulumi.output_type
class GetLinuxWebAppLogHttpLogAzureBlobStorageResult(dict):
    def __init__(__self__, *,
                 retention_in_days: int,
                 sas_url: str):
        """
        :param int retention_in_days: The retention period in days.
        :param str sas_url: The SAS url to an Azure blob container.
        """
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "sas_url", sas_url)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> int:
        """
        The retention period in days.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> str:
        """
        The SAS url to an Azure blob container.
        """
        return pulumi.get(self, "sas_url")


@pulumi.output_type
class GetLinuxWebAppLogHttpLogFileSystemResult(dict):
    def __init__(__self__, *,
                 retention_in_days: int,
                 retention_in_mb: int):
        """
        :param int retention_in_days: The retention period in days.
        :param int retention_in_mb: The maximum size in megabytes that log files can use.
        """
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "retention_in_mb", retention_in_mb)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> int:
        """
        The retention period in days.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="retentionInMb")
    def retention_in_mb(self) -> int:
        """
        The maximum size in megabytes that log files can use.
        """
        return pulumi.get(self, "retention_in_mb")


@pulumi.output_type
class GetLinuxWebAppSiteConfigResult(dict):
    def __init__(__self__, *,
                 always_on: bool,
                 api_definition_url: str,
                 api_management_api_id: str,
                 app_command_line: str,
                 application_stacks: Sequence['outputs.GetLinuxWebAppSiteConfigApplicationStackResult'],
                 auto_heal_enabled: bool,
                 auto_heal_settings: Sequence['outputs.GetLinuxWebAppSiteConfigAutoHealSettingResult'],
                 container_registry_managed_identity_client_id: str,
                 container_registry_use_managed_identity: bool,
                 cors: Sequence['outputs.GetLinuxWebAppSiteConfigCorResult'],
                 default_documents: Sequence[str],
                 detailed_error_logging_enabled: bool,
                 ftps_state: str,
                 health_check_eviction_time_in_min: int,
                 health_check_path: str,
                 http2_enabled: bool,
                 ip_restrictions: Sequence['outputs.GetLinuxWebAppSiteConfigIpRestrictionResult'],
                 linux_fx_version: str,
                 load_balancing_mode: str,
                 local_mysql_enabled: bool,
                 managed_pipeline_mode: str,
                 minimum_tls_version: str,
                 remote_debugging_enabled: bool,
                 remote_debugging_version: str,
                 scm_ip_restrictions: Sequence['outputs.GetLinuxWebAppSiteConfigScmIpRestrictionResult'],
                 scm_minimum_tls_version: str,
                 scm_type: str,
                 scm_use_main_ip_restriction: bool,
                 use32_bit_worker: bool,
                 vnet_route_all_enabled: bool,
                 websockets_enabled: bool,
                 worker_count: int):
        """
        :param bool always_on: Is this Linux Web App is Always On enabled.
        :param str api_definition_url: The ID of the APIM configuration for this Linux Web App.
        :param str api_management_api_id: The ID of the API Management API for this Linux Web App.
        :param str app_command_line: The command line used to launch this app.
        :param Sequence['GetLinuxWebAppSiteConfigApplicationStackArgs'] application_stacks: A `application_stack` block as defined above.
        :param bool auto_heal_enabled: Are Auto heal rules be enabled.
        :param Sequence['GetLinuxWebAppSiteConfigAutoHealSettingArgs'] auto_heal_settings: A `auto_heal_setting` block as defined above.
        :param str container_registry_managed_identity_client_id: The Client ID of the Managed Service Identity used for connections to the Azure Container Registry.
        :param bool container_registry_use_managed_identity: Do connections for Azure Container Registry use Managed Identity.
        :param Sequence['GetLinuxWebAppSiteConfigCorArgs'] cors: A `cors` block as defined above.
        :param Sequence[str] default_documents: The list of Default Documents for the Linux Web App.
        :param bool detailed_error_logging_enabled: Is Detailed Error Logging enabled.
        :param str ftps_state: The State of FTP / FTPS service.
        :param int health_check_eviction_time_in_min: (Optional) The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        :param str health_check_path: The path to the Health Check endpoint.
        :param bool http2_enabled: Is HTTP2.0 enabled.
        :param Sequence['GetLinuxWebAppSiteConfigIpRestrictionArgs'] ip_restrictions: A `ip_restriction` block as defined above.
        :param str linux_fx_version: The `LinuxFXVersion` string.
        :param str load_balancing_mode: The site Load Balancing Mode.
        :param bool local_mysql_enabled: Is the Local MySQL enabled.
        :param str managed_pipeline_mode: The Managed Pipeline Mode.
        :param str minimum_tls_version: The Minimum version of TLS for requests.
        :param bool remote_debugging_enabled: Is Remote Debugging enabled.
        :param str remote_debugging_version: The Remote Debugging Version.
        :param Sequence['GetLinuxWebAppSiteConfigScmIpRestrictionArgs'] scm_ip_restrictions: A `scm_ip_restriction` block as defined above.
        :param str scm_minimum_tls_version: The Minimum version of TLS for requests to SCM.
        :param str scm_type: The Source Control Management Type in use.
        :param bool scm_use_main_ip_restriction: Is the Linux Web App `ip_restriction` configuration used for the SCM also.
        :param bool use32_bit_worker: Does the Linux Web App use a 32-bit worker.
        :param bool vnet_route_all_enabled: Are all outbound traffic to NAT Gateways, Network Security Groups and User Defined Routes applied?
        :param bool websockets_enabled: Are Web Sockets enabled?
        :param int worker_count: The number of Workers for this Linux App Service.
        """
        pulumi.set(__self__, "always_on", always_on)
        pulumi.set(__self__, "api_definition_url", api_definition_url)
        pulumi.set(__self__, "api_management_api_id", api_management_api_id)
        pulumi.set(__self__, "app_command_line", app_command_line)
        pulumi.set(__self__, "application_stacks", application_stacks)
        pulumi.set(__self__, "auto_heal_enabled", auto_heal_enabled)
        pulumi.set(__self__, "auto_heal_settings", auto_heal_settings)
        pulumi.set(__self__, "container_registry_managed_identity_client_id", container_registry_managed_identity_client_id)
        pulumi.set(__self__, "container_registry_use_managed_identity", container_registry_use_managed_identity)
        pulumi.set(__self__, "cors", cors)
        pulumi.set(__self__, "default_documents", default_documents)
        pulumi.set(__self__, "detailed_error_logging_enabled", detailed_error_logging_enabled)
        pulumi.set(__self__, "ftps_state", ftps_state)
        pulumi.set(__self__, "health_check_eviction_time_in_min", health_check_eviction_time_in_min)
        pulumi.set(__self__, "health_check_path", health_check_path)
        pulumi.set(__self__, "http2_enabled", http2_enabled)
        pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        pulumi.set(__self__, "linux_fx_version", linux_fx_version)
        pulumi.set(__self__, "load_balancing_mode", load_balancing_mode)
        pulumi.set(__self__, "local_mysql_enabled", local_mysql_enabled)
        pulumi.set(__self__, "managed_pipeline_mode", managed_pipeline_mode)
        pulumi.set(__self__, "minimum_tls_version", minimum_tls_version)
        pulumi.set(__self__, "remote_debugging_enabled", remote_debugging_enabled)
        pulumi.set(__self__, "remote_debugging_version", remote_debugging_version)
        pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        pulumi.set(__self__, "scm_minimum_tls_version", scm_minimum_tls_version)
        pulumi.set(__self__, "scm_type", scm_type)
        pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        pulumi.set(__self__, "use32_bit_worker", use32_bit_worker)
        pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        pulumi.set(__self__, "websockets_enabled", websockets_enabled)
        pulumi.set(__self__, "worker_count", worker_count)

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> bool:
        """
        Is this Linux Web App is Always On enabled.
        """
        return pulumi.get(self, "always_on")

    @property
    @pulumi.getter(name="apiDefinitionUrl")
    def api_definition_url(self) -> str:
        """
        The ID of the APIM configuration for this Linux Web App.
        """
        return pulumi.get(self, "api_definition_url")

    @property
    @pulumi.getter(name="apiManagementApiId")
    def api_management_api_id(self) -> str:
        """
        The ID of the API Management API for this Linux Web App.
        """
        return pulumi.get(self, "api_management_api_id")

    @property
    @pulumi.getter(name="appCommandLine")
    def app_command_line(self) -> str:
        """
        The command line used to launch this app.
        """
        return pulumi.get(self, "app_command_line")

    @property
    @pulumi.getter(name="applicationStacks")
    def application_stacks(self) -> Sequence['outputs.GetLinuxWebAppSiteConfigApplicationStackResult']:
        """
        A `application_stack` block as defined above.
        """
        return pulumi.get(self, "application_stacks")

    @property
    @pulumi.getter(name="autoHealEnabled")
    def auto_heal_enabled(self) -> bool:
        """
        Are Auto heal rules be enabled.
        """
        return pulumi.get(self, "auto_heal_enabled")

    @property
    @pulumi.getter(name="autoHealSettings")
    def auto_heal_settings(self) -> Sequence['outputs.GetLinuxWebAppSiteConfigAutoHealSettingResult']:
        """
        A `auto_heal_setting` block as defined above.
        """
        return pulumi.get(self, "auto_heal_settings")

    @property
    @pulumi.getter(name="containerRegistryManagedIdentityClientId")
    def container_registry_managed_identity_client_id(self) -> str:
        """
        The Client ID of the Managed Service Identity used for connections to the Azure Container Registry.
        """
        return pulumi.get(self, "container_registry_managed_identity_client_id")

    @property
    @pulumi.getter(name="containerRegistryUseManagedIdentity")
    def container_registry_use_managed_identity(self) -> bool:
        """
        Do connections for Azure Container Registry use Managed Identity.
        """
        return pulumi.get(self, "container_registry_use_managed_identity")

    @property
    @pulumi.getter
    def cors(self) -> Sequence['outputs.GetLinuxWebAppSiteConfigCorResult']:
        """
        A `cors` block as defined above.
        """
        return pulumi.get(self, "cors")

    @property
    @pulumi.getter(name="defaultDocuments")
    def default_documents(self) -> Sequence[str]:
        """
        The list of Default Documents for the Linux Web App.
        """
        return pulumi.get(self, "default_documents")

    @property
    @pulumi.getter(name="detailedErrorLoggingEnabled")
    def detailed_error_logging_enabled(self) -> bool:
        """
        Is Detailed Error Logging enabled.
        """
        return pulumi.get(self, "detailed_error_logging_enabled")

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> str:
        """
        The State of FTP / FTPS service.
        """
        return pulumi.get(self, "ftps_state")

    @property
    @pulumi.getter(name="healthCheckEvictionTimeInMin")
    def health_check_eviction_time_in_min(self) -> int:
        """
        (Optional) The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        """
        return pulumi.get(self, "health_check_eviction_time_in_min")

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> str:
        """
        The path to the Health Check endpoint.
        """
        return pulumi.get(self, "health_check_path")

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> bool:
        """
        Is HTTP2.0 enabled.
        """
        return pulumi.get(self, "http2_enabled")

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Sequence['outputs.GetLinuxWebAppSiteConfigIpRestrictionResult']:
        """
        A `ip_restriction` block as defined above.
        """
        return pulumi.get(self, "ip_restrictions")

    @property
    @pulumi.getter(name="linuxFxVersion")
    def linux_fx_version(self) -> str:
        """
        The `LinuxFXVersion` string.
        """
        return pulumi.get(self, "linux_fx_version")

    @property
    @pulumi.getter(name="loadBalancingMode")
    def load_balancing_mode(self) -> str:
        """
        The site Load Balancing Mode.
        """
        return pulumi.get(self, "load_balancing_mode")

    @property
    @pulumi.getter(name="localMysqlEnabled")
    def local_mysql_enabled(self) -> bool:
        """
        Is the Local MySQL enabled.
        """
        return pulumi.get(self, "local_mysql_enabled")

    @property
    @pulumi.getter(name="managedPipelineMode")
    def managed_pipeline_mode(self) -> str:
        """
        The Managed Pipeline Mode.
        """
        return pulumi.get(self, "managed_pipeline_mode")

    @property
    @pulumi.getter(name="minimumTlsVersion")
    def minimum_tls_version(self) -> str:
        """
        The Minimum version of TLS for requests.
        """
        return pulumi.get(self, "minimum_tls_version")

    @property
    @pulumi.getter(name="remoteDebuggingEnabled")
    def remote_debugging_enabled(self) -> bool:
        """
        Is Remote Debugging enabled.
        """
        return pulumi.get(self, "remote_debugging_enabled")

    @property
    @pulumi.getter(name="remoteDebuggingVersion")
    def remote_debugging_version(self) -> str:
        """
        The Remote Debugging Version.
        """
        return pulumi.get(self, "remote_debugging_version")

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Sequence['outputs.GetLinuxWebAppSiteConfigScmIpRestrictionResult']:
        """
        A `scm_ip_restriction` block as defined above.
        """
        return pulumi.get(self, "scm_ip_restrictions")

    @property
    @pulumi.getter(name="scmMinimumTlsVersion")
    def scm_minimum_tls_version(self) -> str:
        """
        The Minimum version of TLS for requests to SCM.
        """
        return pulumi.get(self, "scm_minimum_tls_version")

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> str:
        """
        The Source Control Management Type in use.
        """
        return pulumi.get(self, "scm_type")

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> bool:
        """
        Is the Linux Web App `ip_restriction` configuration used for the SCM also.
        """
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @property
    @pulumi.getter(name="use32BitWorker")
    def use32_bit_worker(self) -> bool:
        """
        Does the Linux Web App use a 32-bit worker.
        """
        return pulumi.get(self, "use32_bit_worker")

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> bool:
        """
        Are all outbound traffic to NAT Gateways, Network Security Groups and User Defined Routes applied?
        """
        return pulumi.get(self, "vnet_route_all_enabled")

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> bool:
        """
        Are Web Sockets enabled?
        """
        return pulumi.get(self, "websockets_enabled")

    @property
    @pulumi.getter(name="workerCount")
    def worker_count(self) -> int:
        """
        The number of Workers for this Linux App Service.
        """
        return pulumi.get(self, "worker_count")


@pulumi.output_type
class GetLinuxWebAppSiteConfigApplicationStackResult(dict):
    def __init__(__self__, *,
                 docker_image: str,
                 docker_image_name: str,
                 docker_image_tag: str,
                 docker_registry_password: str,
                 docker_registry_url: str,
                 docker_registry_username: str,
                 dotnet_version: str,
                 go_version: str,
                 java_server: str,
                 java_server_version: str,
                 java_version: str,
                 node_version: str,
                 php_version: str,
                 python_version: str,
                 ruby_version: str):
        """
        :param str docker_image_name: The docker image, including tag, used by this Linux Web App.
        :param str docker_registry_password: The User Name to use for authentication against the registry to pull the image.
        :param str docker_registry_url: The URL of the container registry where the `docker_image_name` is located.
        :param str docker_registry_username: The User Name to use for authentication against the registry to pull the image.
        :param str dotnet_version: The version of .NET in use.
        :param str java_server: The Java server type.
        :param str java_server_version: The Version of the `java_server` in use.
        :param str java_version: The Version of Java in use.
        :param str node_version: The version of Node in use.
        :param str php_version: The version of PHP in use.
        :param str python_version: The version of Python in use.
        :param str ruby_version: The version of Ruby in use.
        """
        pulumi.set(__self__, "docker_image", docker_image)
        pulumi.set(__self__, "docker_image_name", docker_image_name)
        pulumi.set(__self__, "docker_image_tag", docker_image_tag)
        pulumi.set(__self__, "docker_registry_password", docker_registry_password)
        pulumi.set(__self__, "docker_registry_url", docker_registry_url)
        pulumi.set(__self__, "docker_registry_username", docker_registry_username)
        pulumi.set(__self__, "dotnet_version", dotnet_version)
        pulumi.set(__self__, "go_version", go_version)
        pulumi.set(__self__, "java_server", java_server)
        pulumi.set(__self__, "java_server_version", java_server_version)
        pulumi.set(__self__, "java_version", java_version)
        pulumi.set(__self__, "node_version", node_version)
        pulumi.set(__self__, "php_version", php_version)
        pulumi.set(__self__, "python_version", python_version)
        pulumi.set(__self__, "ruby_version", ruby_version)

    @property
    @pulumi.getter(name="dockerImage")
    def docker_image(self) -> str:
        return pulumi.get(self, "docker_image")

    @property
    @pulumi.getter(name="dockerImageName")
    def docker_image_name(self) -> str:
        """
        The docker image, including tag, used by this Linux Web App.
        """
        return pulumi.get(self, "docker_image_name")

    @property
    @pulumi.getter(name="dockerImageTag")
    def docker_image_tag(self) -> str:
        return pulumi.get(self, "docker_image_tag")

    @property
    @pulumi.getter(name="dockerRegistryPassword")
    def docker_registry_password(self) -> str:
        """
        The User Name to use for authentication against the registry to pull the image.
        """
        return pulumi.get(self, "docker_registry_password")

    @property
    @pulumi.getter(name="dockerRegistryUrl")
    def docker_registry_url(self) -> str:
        """
        The URL of the container registry where the `docker_image_name` is located.
        """
        return pulumi.get(self, "docker_registry_url")

    @property
    @pulumi.getter(name="dockerRegistryUsername")
    def docker_registry_username(self) -> str:
        """
        The User Name to use for authentication against the registry to pull the image.
        """
        return pulumi.get(self, "docker_registry_username")

    @property
    @pulumi.getter(name="dotnetVersion")
    def dotnet_version(self) -> str:
        """
        The version of .NET in use.
        """
        return pulumi.get(self, "dotnet_version")

    @property
    @pulumi.getter(name="goVersion")
    def go_version(self) -> str:
        return pulumi.get(self, "go_version")

    @property
    @pulumi.getter(name="javaServer")
    def java_server(self) -> str:
        """
        The Java server type.
        """
        return pulumi.get(self, "java_server")

    @property
    @pulumi.getter(name="javaServerVersion")
    def java_server_version(self) -> str:
        """
        The Version of the `java_server` in use.
        """
        return pulumi.get(self, "java_server_version")

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> str:
        """
        The Version of Java in use.
        """
        return pulumi.get(self, "java_version")

    @property
    @pulumi.getter(name="nodeVersion")
    def node_version(self) -> str:
        """
        The version of Node in use.
        """
        return pulumi.get(self, "node_version")

    @property
    @pulumi.getter(name="phpVersion")
    def php_version(self) -> str:
        """
        The version of PHP in use.
        """
        return pulumi.get(self, "php_version")

    @property
    @pulumi.getter(name="pythonVersion")
    def python_version(self) -> str:
        """
        The version of Python in use.
        """
        return pulumi.get(self, "python_version")

    @property
    @pulumi.getter(name="rubyVersion")
    def ruby_version(self) -> str:
        """
        The version of Ruby in use.
        """
        return pulumi.get(self, "ruby_version")


@pulumi.output_type
class GetLinuxWebAppSiteConfigAutoHealSettingResult(dict):
    def __init__(__self__, *,
                 actions: Sequence['outputs.GetLinuxWebAppSiteConfigAutoHealSettingActionResult'],
                 triggers: Sequence['outputs.GetLinuxWebAppSiteConfigAutoHealSettingTriggerResult']):
        """
        :param Sequence['GetLinuxWebAppSiteConfigAutoHealSettingActionArgs'] actions: A `action` block as defined above.
        :param Sequence['GetLinuxWebAppSiteConfigAutoHealSettingTriggerArgs'] triggers: A `trigger` block as defined below.
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "triggers", triggers)

    @property
    @pulumi.getter
    def actions(self) -> Sequence['outputs.GetLinuxWebAppSiteConfigAutoHealSettingActionResult']:
        """
        A `action` block as defined above.
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter
    def triggers(self) -> Sequence['outputs.GetLinuxWebAppSiteConfigAutoHealSettingTriggerResult']:
        """
        A `trigger` block as defined below.
        """
        return pulumi.get(self, "triggers")


@pulumi.output_type
class GetLinuxWebAppSiteConfigAutoHealSettingActionResult(dict):
    def __init__(__self__, *,
                 action_type: str,
                 minimum_process_execution_time: str):
        """
        :param str action_type: The predefined action to be taken to an Auto Heal trigger.
        :param str minimum_process_execution_time: The minimum amount of time in `hh:mm:ss` the Linux Web App must have been running before the defined action will be run in the event of a trigger.
        """
        pulumi.set(__self__, "action_type", action_type)
        pulumi.set(__self__, "minimum_process_execution_time", minimum_process_execution_time)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> str:
        """
        The predefined action to be taken to an Auto Heal trigger.
        """
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter(name="minimumProcessExecutionTime")
    def minimum_process_execution_time(self) -> str:
        """
        The minimum amount of time in `hh:mm:ss` the Linux Web App must have been running before the defined action will be run in the event of a trigger.
        """
        return pulumi.get(self, "minimum_process_execution_time")


@pulumi.output_type
class GetLinuxWebAppSiteConfigAutoHealSettingTriggerResult(dict):
    def __init__(__self__, *,
                 requests: Sequence['outputs.GetLinuxWebAppSiteConfigAutoHealSettingTriggerRequestResult'],
                 status_codes: Sequence['outputs.GetLinuxWebAppSiteConfigAutoHealSettingTriggerStatusCodeResult'],
                 slow_requests: Optional[Sequence['outputs.GetLinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequestResult']] = None):
        """
        :param Sequence['GetLinuxWebAppSiteConfigAutoHealSettingTriggerRequestArgs'] requests: A `requests` block as defined above.
        :param Sequence['GetLinuxWebAppSiteConfigAutoHealSettingTriggerStatusCodeArgs'] status_codes: A `status_code` block as defined above.
        :param Sequence['GetLinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequestArgs'] slow_requests: A `slow_request` block as defined above.
        """
        pulumi.set(__self__, "requests", requests)
        pulumi.set(__self__, "status_codes", status_codes)
        if slow_requests is not None:
            pulumi.set(__self__, "slow_requests", slow_requests)

    @property
    @pulumi.getter
    def requests(self) -> Sequence['outputs.GetLinuxWebAppSiteConfigAutoHealSettingTriggerRequestResult']:
        """
        A `requests` block as defined above.
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="statusCodes")
    def status_codes(self) -> Sequence['outputs.GetLinuxWebAppSiteConfigAutoHealSettingTriggerStatusCodeResult']:
        """
        A `status_code` block as defined above.
        """
        return pulumi.get(self, "status_codes")

    @property
    @pulumi.getter(name="slowRequests")
    def slow_requests(self) -> Optional[Sequence['outputs.GetLinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequestResult']]:
        """
        A `slow_request` block as defined above.
        """
        return pulumi.get(self, "slow_requests")


@pulumi.output_type
class GetLinuxWebAppSiteConfigAutoHealSettingTriggerRequestResult(dict):
    def __init__(__self__, *,
                 count: int,
                 interval: str):
        """
        :param int count: The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        :param str interval: The time interval in the form `hh:mm:ss`.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        The time interval in the form `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class GetLinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequestResult(dict):
    def __init__(__self__, *,
                 count: int,
                 interval: str,
                 path: str,
                 time_taken: str):
        """
        :param int count: The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        :param str interval: The time interval in the form `hh:mm:ss`.
        :param str path: The path to which this rule status code applies.
        :param str time_taken: The amount of time that qualifies as slow for this rule.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "time_taken", time_taken)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        The time interval in the form `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The path to which this rule status code applies.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="timeTaken")
    def time_taken(self) -> str:
        """
        The amount of time that qualifies as slow for this rule.
        """
        return pulumi.get(self, "time_taken")


@pulumi.output_type
class GetLinuxWebAppSiteConfigAutoHealSettingTriggerStatusCodeResult(dict):
    def __init__(__self__, *,
                 count: int,
                 interval: str,
                 path: str,
                 status_code_range: str,
                 sub_status: int,
                 win32_status_code: int):
        """
        :param int count: The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        :param str interval: The time interval in the form `hh:mm:ss`.
        :param str path: The path to which this rule status code applies.
        :param str status_code_range: The status code or range for this rule.
        :param int sub_status: The Request Sub Status of the Status Code.
        :param int win32_status_code: The Win32 Status Code of the Request.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "status_code_range", status_code_range)
        pulumi.set(__self__, "sub_status", sub_status)
        pulumi.set(__self__, "win32_status_code", win32_status_code)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        The time interval in the form `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The path to which this rule status code applies.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="statusCodeRange")
    def status_code_range(self) -> str:
        """
        The status code or range for this rule.
        """
        return pulumi.get(self, "status_code_range")

    @property
    @pulumi.getter(name="subStatus")
    def sub_status(self) -> int:
        """
        The Request Sub Status of the Status Code.
        """
        return pulumi.get(self, "sub_status")

    @property
    @pulumi.getter(name="win32StatusCode")
    def win32_status_code(self) -> int:
        """
        The Win32 Status Code of the Request.
        """
        return pulumi.get(self, "win32_status_code")


@pulumi.output_type
class GetLinuxWebAppSiteConfigCorResult(dict):
    def __init__(__self__, *,
                 allowed_origins: Sequence[str],
                 support_credentials: bool):
        """
        :param Sequence[str] allowed_origins: A list of origins that should be allowed to make cross-origin calls.
        :param bool support_credentials: Whether CORS requests with credentials are allowed.
        """
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Sequence[str]:
        """
        A list of origins that should be allowed to make cross-origin calls.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> bool:
        """
        Whether CORS requests with credentials are allowed.
        """
        return pulumi.get(self, "support_credentials")


@pulumi.output_type
class GetLinuxWebAppSiteConfigIpRestrictionResult(dict):
    def __init__(__self__, *,
                 action: str,
                 headers: Sequence['outputs.GetLinuxWebAppSiteConfigIpRestrictionHeaderResult'],
                 ip_address: str,
                 name: str,
                 priority: int,
                 service_tag: str,
                 virtual_network_subnet_id: str):
        """
        :param str action: A `action` block as defined above.
        :param str name: The name of this Linux Web App.
        :param str virtual_network_subnet_id: The subnet id which the Linux Web App is vNet Integrated with.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "service_tag", service_tag)
        pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        A `action` block as defined above.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.GetLinuxWebAppSiteConfigIpRestrictionHeaderResult']:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this Linux Web App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> str:
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> str:
        """
        The subnet id which the Linux Web App is vNet Integrated with.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class GetLinuxWebAppSiteConfigIpRestrictionHeaderResult(dict):
    def __init__(__self__, *,
                 x_azure_fdids: Sequence[str],
                 x_fd_health_probes: Sequence[str],
                 x_forwarded_fors: Sequence[str],
                 x_forwarded_hosts: Sequence[str]):
        pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        pulumi.set(__self__, "x_fd_health_probes", x_fd_health_probes)
        pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Sequence[str]:
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbes")
    def x_fd_health_probes(self) -> Sequence[str]:
        return pulumi.get(self, "x_fd_health_probes")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Sequence[str]:
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Sequence[str]:
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class GetLinuxWebAppSiteConfigScmIpRestrictionResult(dict):
    def __init__(__self__, *,
                 action: str,
                 headers: Sequence['outputs.GetLinuxWebAppSiteConfigScmIpRestrictionHeaderResult'],
                 ip_address: str,
                 name: str,
                 priority: int,
                 service_tag: str,
                 virtual_network_subnet_id: str):
        """
        :param str action: A `action` block as defined above.
        :param str name: The name of this Linux Web App.
        :param str virtual_network_subnet_id: The subnet id which the Linux Web App is vNet Integrated with.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "service_tag", service_tag)
        pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        A `action` block as defined above.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.GetLinuxWebAppSiteConfigScmIpRestrictionHeaderResult']:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this Linux Web App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> str:
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> str:
        """
        The subnet id which the Linux Web App is vNet Integrated with.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class GetLinuxWebAppSiteConfigScmIpRestrictionHeaderResult(dict):
    def __init__(__self__, *,
                 x_azure_fdids: Sequence[str],
                 x_fd_health_probes: Sequence[str],
                 x_forwarded_fors: Sequence[str],
                 x_forwarded_hosts: Sequence[str]):
        pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        pulumi.set(__self__, "x_fd_health_probes", x_fd_health_probes)
        pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Sequence[str]:
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbes")
    def x_fd_health_probes(self) -> Sequence[str]:
        return pulumi.get(self, "x_fd_health_probes")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Sequence[str]:
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Sequence[str]:
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class GetLinuxWebAppSiteCredentialResult(dict):
    def __init__(__self__, *,
                 name: str,
                 password: str):
        """
        :param str name: The name of this Linux Web App.
        :param str password: The Site Credentials Password used for publishing.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this Linux Web App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The Site Credentials Password used for publishing.
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class GetLinuxWebAppStickySettingResult(dict):
    def __init__(__self__, *,
                 app_setting_names: Sequence[str],
                 connection_string_names: Sequence[str]):
        """
        :param Sequence[str] app_setting_names: A list of `app_setting` names that the Linux Web App will not swap between Slots when a swap operation is triggered.
        :param Sequence[str] connection_string_names: A list of `connection_string` names that the Linux Web App will not swap between Slots when a swap operation is triggered.
        """
        pulumi.set(__self__, "app_setting_names", app_setting_names)
        pulumi.set(__self__, "connection_string_names", connection_string_names)

    @property
    @pulumi.getter(name="appSettingNames")
    def app_setting_names(self) -> Sequence[str]:
        """
        A list of `app_setting` names that the Linux Web App will not swap between Slots when a swap operation is triggered.
        """
        return pulumi.get(self, "app_setting_names")

    @property
    @pulumi.getter(name="connectionStringNames")
    def connection_string_names(self) -> Sequence[str]:
        """
        A list of `connection_string` names that the Linux Web App will not swap between Slots when a swap operation is triggered.
        """
        return pulumi.get(self, "connection_string_names")


@pulumi.output_type
class GetLinuxWebAppStorageAccountResult(dict):
    def __init__(__self__, *,
                 access_key: str,
                 account_name: str,
                 mount_path: str,
                 name: str,
                 share_name: str,
                 type: str):
        """
        :param str access_key: The Access key for the storage account.
        :param str account_name: The Name of the Storage Account.
        :param str mount_path: The path at which to mount the Storage Share.
        :param str name: The name of this Linux Web App.
        :param str share_name: The Name of the File Share or Container Name for Blob storage.
        :param str type: The Azure Storage Type.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "mount_path", mount_path)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "share_name", share_name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> str:
        """
        The Access key for the storage account.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> str:
        """
        The Name of the Storage Account.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> str:
        """
        The path at which to mount the Storage Share.
        """
        return pulumi.get(self, "mount_path")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this Linux Web App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> str:
        """
        The Name of the File Share or Container Name for Blob storage.
        """
        return pulumi.get(self, "share_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The Azure Storage Type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetWindowsFunctionAppAuthSettingResult(dict):
    def __init__(__self__, *,
                 active_directories: Sequence['outputs.GetWindowsFunctionAppAuthSettingActiveDirectoryResult'],
                 additional_login_parameters: Mapping[str, str],
                 allowed_external_redirect_urls: Sequence[str],
                 default_provider: str,
                 enabled: bool,
                 facebooks: Sequence['outputs.GetWindowsFunctionAppAuthSettingFacebookResult'],
                 githubs: Sequence['outputs.GetWindowsFunctionAppAuthSettingGithubResult'],
                 googles: Sequence['outputs.GetWindowsFunctionAppAuthSettingGoogleResult'],
                 issuer: str,
                 microsofts: Sequence['outputs.GetWindowsFunctionAppAuthSettingMicrosoftResult'],
                 runtime_version: str,
                 token_refresh_extension_hours: float,
                 token_store_enabled: bool,
                 twitters: Sequence['outputs.GetWindowsFunctionAppAuthSettingTwitterResult'],
                 unauthenticated_client_action: str):
        """
        :param Sequence['GetWindowsFunctionAppAuthSettingActiveDirectoryArgs'] active_directories: A `active_directory` block as defined above.
        :param Mapping[str, str] additional_login_parameters: A map of Login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        :param Sequence[str] allowed_external_redirect_urls: External URLs that can be redirected to as part of logging in or logging out of the app.
        :param str default_provider: The Default Authentication Provider used when more than one Authentication Provider is configured and the `unauthenticated_action` is set to `RedirectToLoginPage`.
        :param bool enabled: Is the Backup Job enabled?
        :param Sequence['GetWindowsFunctionAppAuthSettingFacebookArgs'] facebooks: A `facebook` block as defined below.
        :param Sequence['GetWindowsFunctionAppAuthSettingGithubArgs'] githubs: A `github` block as defined below.
        :param Sequence['GetWindowsFunctionAppAuthSettingGoogleArgs'] googles: A `google` block as defined below.
        :param str issuer: The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Windows Function App.
        :param Sequence['GetWindowsFunctionAppAuthSettingMicrosoftArgs'] microsofts: A `microsoft` block as defined below.
        :param str runtime_version: The Runtime Version of the Authentication and Authorisation feature of this App.
        :param float token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to call the token refresh API.
        :param bool token_store_enabled: Is the Token Store configuration Enabled.
        :param Sequence['GetWindowsFunctionAppAuthSettingTwitterArgs'] twitters: A `twitter` block as defined below.
        :param str unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app.
        """
        pulumi.set(__self__, "active_directories", active_directories)
        pulumi.set(__self__, "additional_login_parameters", additional_login_parameters)
        pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        pulumi.set(__self__, "default_provider", default_provider)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "facebooks", facebooks)
        pulumi.set(__self__, "githubs", githubs)
        pulumi.set(__self__, "googles", googles)
        pulumi.set(__self__, "issuer", issuer)
        pulumi.set(__self__, "microsofts", microsofts)
        pulumi.set(__self__, "runtime_version", runtime_version)
        pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)
        pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        pulumi.set(__self__, "twitters", twitters)
        pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter(name="activeDirectories")
    def active_directories(self) -> Sequence['outputs.GetWindowsFunctionAppAuthSettingActiveDirectoryResult']:
        """
        A `active_directory` block as defined above.
        """
        return pulumi.get(self, "active_directories")

    @property
    @pulumi.getter(name="additionalLoginParameters")
    def additional_login_parameters(self) -> Mapping[str, str]:
        """
        A map of Login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        """
        return pulumi.get(self, "additional_login_parameters")

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Sequence[str]:
        """
        External URLs that can be redirected to as part of logging in or logging out of the app.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> str:
        """
        The Default Authentication Provider used when more than one Authentication Provider is configured and the `unauthenticated_action` is set to `RedirectToLoginPage`.
        """
        return pulumi.get(self, "default_provider")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is the Backup Job enabled?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def facebooks(self) -> Sequence['outputs.GetWindowsFunctionAppAuthSettingFacebookResult']:
        """
        A `facebook` block as defined below.
        """
        return pulumi.get(self, "facebooks")

    @property
    @pulumi.getter
    def githubs(self) -> Sequence['outputs.GetWindowsFunctionAppAuthSettingGithubResult']:
        """
        A `github` block as defined below.
        """
        return pulumi.get(self, "githubs")

    @property
    @pulumi.getter
    def googles(self) -> Sequence['outputs.GetWindowsFunctionAppAuthSettingGoogleResult']:
        """
        A `google` block as defined below.
        """
        return pulumi.get(self, "googles")

    @property
    @pulumi.getter
    def issuer(self) -> str:
        """
        The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Windows Function App.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def microsofts(self) -> Sequence['outputs.GetWindowsFunctionAppAuthSettingMicrosoftResult']:
        """
        A `microsoft` block as defined below.
        """
        return pulumi.get(self, "microsofts")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> str:
        """
        The Runtime Version of the Authentication and Authorisation feature of this App.
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> float:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API.
        """
        return pulumi.get(self, "token_refresh_extension_hours")

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> bool:
        """
        Is the Token Store configuration Enabled.
        """
        return pulumi.get(self, "token_store_enabled")

    @property
    @pulumi.getter
    def twitters(self) -> Sequence['outputs.GetWindowsFunctionAppAuthSettingTwitterResult']:
        """
        A `twitter` block as defined below.
        """
        return pulumi.get(self, "twitters")

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> str:
        """
        The action to take when an unauthenticated client attempts to access the app.
        """
        return pulumi.get(self, "unauthenticated_client_action")


@pulumi.output_type
class GetWindowsFunctionAppAuthSettingActiveDirectoryResult(dict):
    def __init__(__self__, *,
                 allowed_audiences: Sequence[str],
                 client_id: str,
                 client_secret: str,
                 client_secret_setting_name: str):
        """
        :param Sequence[str] allowed_audiences: The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret: The OAuth 2.0 client secret that was created for the app used for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        """
        pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Sequence[str]:
        """
        The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")


@pulumi.output_type
class GetWindowsFunctionAppAuthSettingFacebookResult(dict):
    def __init__(__self__, *,
                 app_id: str,
                 app_secret: str,
                 app_secret_setting_name: str,
                 oauth_scopes: Sequence[str]):
        """
        :param str app_id: The App ID of the Facebook app used for login.
        :param str app_secret: The App Secret of the Facebook app used for Facebook Login.
        :param str app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook Login.
        :param Sequence[str] oauth_scopes: A list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "app_secret", app_secret)
        pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appSecret")
    def app_secret(self) -> str:
        """
        The App Secret of the Facebook app used for Facebook Login.
        """
        return pulumi.get(self, "app_secret")

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> str:
        """
        The app setting name that contains the `app_secret` value used for Facebook Login.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Sequence[str]:
        """
        A list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class GetWindowsFunctionAppAuthSettingGithubResult(dict):
    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 client_secret_setting_name: str,
                 oauth_scopes: Sequence[str]):
        """
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret: The OAuth 2.0 client secret that was created for the app used for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        :param Sequence[str] oauth_scopes: A list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Sequence[str]:
        """
        A list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class GetWindowsFunctionAppAuthSettingGoogleResult(dict):
    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 client_secret_setting_name: str,
                 oauth_scopes: Sequence[str]):
        """
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret: The OAuth 2.0 client secret that was created for the app used for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        :param Sequence[str] oauth_scopes: A list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Sequence[str]:
        """
        A list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class GetWindowsFunctionAppAuthSettingMicrosoftResult(dict):
    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 client_secret_setting_name: str,
                 oauth_scopes: Sequence[str]):
        """
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret: The OAuth 2.0 client secret that was created for the app used for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        :param Sequence[str] oauth_scopes: A list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Sequence[str]:
        """
        A list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class GetWindowsFunctionAppAuthSettingTwitterResult(dict):
    def __init__(__self__, *,
                 consumer_key: str,
                 consumer_secret: str,
                 consumer_secret_setting_name: str):
        """
        :param str consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param str consumer_secret: The OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        :param str consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        pulumi.set(__self__, "consumer_secret", consumer_secret)
        pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> str:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> str:
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_secret")

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> str:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_secret_setting_name")


@pulumi.output_type
class GetWindowsFunctionAppAuthSettingsV2Result(dict):
    def __init__(__self__, *,
                 active_directory_v2s: Sequence['outputs.GetWindowsFunctionAppAuthSettingsV2ActiveDirectoryV2Result'],
                 apple_v2s: Sequence['outputs.GetWindowsFunctionAppAuthSettingsV2AppleV2Result'],
                 auth_enabled: bool,
                 azure_static_web_app_v2s: Sequence['outputs.GetWindowsFunctionAppAuthSettingsV2AzureStaticWebAppV2Result'],
                 config_file_path: str,
                 custom_oidc_v2s: Sequence['outputs.GetWindowsFunctionAppAuthSettingsV2CustomOidcV2Result'],
                 default_provider: str,
                 excluded_paths: Sequence[str],
                 facebook_v2s: Sequence['outputs.GetWindowsFunctionAppAuthSettingsV2FacebookV2Result'],
                 forward_proxy_convention: str,
                 forward_proxy_custom_host_header_name: str,
                 forward_proxy_custom_scheme_header_name: str,
                 github_v2s: Sequence['outputs.GetWindowsFunctionAppAuthSettingsV2GithubV2Result'],
                 google_v2s: Sequence['outputs.GetWindowsFunctionAppAuthSettingsV2GoogleV2Result'],
                 http_route_api_prefix: str,
                 logins: Sequence['outputs.GetWindowsFunctionAppAuthSettingsV2LoginResult'],
                 microsoft_v2s: Sequence['outputs.GetWindowsFunctionAppAuthSettingsV2MicrosoftV2Result'],
                 require_authentication: bool,
                 require_https: bool,
                 runtime_version: str,
                 twitter_v2s: Sequence['outputs.GetWindowsFunctionAppAuthSettingsV2TwitterV2Result'],
                 unauthenticated_action: str):
        """
        :param Sequence['GetWindowsFunctionAppAuthSettingsV2ActiveDirectoryV2Args'] active_directory_v2s: An `active_directory_v2` block as defined below.
        :param Sequence['GetWindowsFunctionAppAuthSettingsV2AppleV2Args'] apple_v2s: An `apple_v2` block as defined below.
        :param bool auth_enabled: Are the AuthV2 Settings enabled.
        :param Sequence['GetWindowsFunctionAppAuthSettingsV2AzureStaticWebAppV2Args'] azure_static_web_app_v2s: An `azure_static_web_app_v2` block as defined below.
        :param str config_file_path: The path to the App Auth settings.
        :param Sequence['GetWindowsFunctionAppAuthSettingsV2CustomOidcV2Args'] custom_oidc_v2s: Zero or more `custom_oidc_v2` blocks as defined below.
        :param str default_provider: The Default Authentication Provider used when more than one Authentication Provider is configured and the `unauthenticated_action` is set to `RedirectToLoginPage`.
        :param Sequence[str] excluded_paths: The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.
        :param Sequence['GetWindowsFunctionAppAuthSettingsV2FacebookV2Args'] facebook_v2s: A `facebook_v2` block as defined below.
        :param str forward_proxy_convention: The convention used to determine the url of the request made.
        :param str forward_proxy_custom_host_header_name: The name of the custom header containing the host of the request.
        :param str forward_proxy_custom_scheme_header_name: The name of the custom header containing the scheme of the request.
        :param Sequence['GetWindowsFunctionAppAuthSettingsV2GithubV2Args'] github_v2s: A `github_v2` block as defined below.
        :param Sequence['GetWindowsFunctionAppAuthSettingsV2GoogleV2Args'] google_v2s: A `google_v2` block as defined below.
        :param str http_route_api_prefix: The prefix that should precede all the authentication and authorisation paths.
        :param Sequence['GetWindowsFunctionAppAuthSettingsV2LoginArgs'] logins: A `login` block as defined below.
        :param Sequence['GetWindowsFunctionAppAuthSettingsV2MicrosoftV2Args'] microsoft_v2s: A `microsoft_v2` block as defined below.
        :param bool require_authentication: Is the authentication flow used for all requests.
        :param bool require_https: Is HTTPS required on connections?
        :param str runtime_version: The Runtime Version of the Authentication and Authorisation feature of this App.
        :param Sequence['GetWindowsFunctionAppAuthSettingsV2TwitterV2Args'] twitter_v2s: A `twitter_v2` block as defined below.
        :param str unauthenticated_action: The action to take for requests made without authentication.
        """
        pulumi.set(__self__, "active_directory_v2s", active_directory_v2s)
        pulumi.set(__self__, "apple_v2s", apple_v2s)
        pulumi.set(__self__, "auth_enabled", auth_enabled)
        pulumi.set(__self__, "azure_static_web_app_v2s", azure_static_web_app_v2s)
        pulumi.set(__self__, "config_file_path", config_file_path)
        pulumi.set(__self__, "custom_oidc_v2s", custom_oidc_v2s)
        pulumi.set(__self__, "default_provider", default_provider)
        pulumi.set(__self__, "excluded_paths", excluded_paths)
        pulumi.set(__self__, "facebook_v2s", facebook_v2s)
        pulumi.set(__self__, "forward_proxy_convention", forward_proxy_convention)
        pulumi.set(__self__, "forward_proxy_custom_host_header_name", forward_proxy_custom_host_header_name)
        pulumi.set(__self__, "forward_proxy_custom_scheme_header_name", forward_proxy_custom_scheme_header_name)
        pulumi.set(__self__, "github_v2s", github_v2s)
        pulumi.set(__self__, "google_v2s", google_v2s)
        pulumi.set(__self__, "http_route_api_prefix", http_route_api_prefix)
        pulumi.set(__self__, "logins", logins)
        pulumi.set(__self__, "microsoft_v2s", microsoft_v2s)
        pulumi.set(__self__, "require_authentication", require_authentication)
        pulumi.set(__self__, "require_https", require_https)
        pulumi.set(__self__, "runtime_version", runtime_version)
        pulumi.set(__self__, "twitter_v2s", twitter_v2s)
        pulumi.set(__self__, "unauthenticated_action", unauthenticated_action)

    @property
    @pulumi.getter(name="activeDirectoryV2s")
    def active_directory_v2s(self) -> Sequence['outputs.GetWindowsFunctionAppAuthSettingsV2ActiveDirectoryV2Result']:
        """
        An `active_directory_v2` block as defined below.
        """
        return pulumi.get(self, "active_directory_v2s")

    @property
    @pulumi.getter(name="appleV2s")
    def apple_v2s(self) -> Sequence['outputs.GetWindowsFunctionAppAuthSettingsV2AppleV2Result']:
        """
        An `apple_v2` block as defined below.
        """
        return pulumi.get(self, "apple_v2s")

    @property
    @pulumi.getter(name="authEnabled")
    def auth_enabled(self) -> bool:
        """
        Are the AuthV2 Settings enabled.
        """
        return pulumi.get(self, "auth_enabled")

    @property
    @pulumi.getter(name="azureStaticWebAppV2s")
    def azure_static_web_app_v2s(self) -> Sequence['outputs.GetWindowsFunctionAppAuthSettingsV2AzureStaticWebAppV2Result']:
        """
        An `azure_static_web_app_v2` block as defined below.
        """
        return pulumi.get(self, "azure_static_web_app_v2s")

    @property
    @pulumi.getter(name="configFilePath")
    def config_file_path(self) -> str:
        """
        The path to the App Auth settings.
        """
        return pulumi.get(self, "config_file_path")

    @property
    @pulumi.getter(name="customOidcV2s")
    def custom_oidc_v2s(self) -> Sequence['outputs.GetWindowsFunctionAppAuthSettingsV2CustomOidcV2Result']:
        """
        Zero or more `custom_oidc_v2` blocks as defined below.
        """
        return pulumi.get(self, "custom_oidc_v2s")

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> str:
        """
        The Default Authentication Provider used when more than one Authentication Provider is configured and the `unauthenticated_action` is set to `RedirectToLoginPage`.
        """
        return pulumi.get(self, "default_provider")

    @property
    @pulumi.getter(name="excludedPaths")
    def excluded_paths(self) -> Sequence[str]:
        """
        The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.
        """
        return pulumi.get(self, "excluded_paths")

    @property
    @pulumi.getter(name="facebookV2s")
    def facebook_v2s(self) -> Sequence['outputs.GetWindowsFunctionAppAuthSettingsV2FacebookV2Result']:
        """
        A `facebook_v2` block as defined below.
        """
        return pulumi.get(self, "facebook_v2s")

    @property
    @pulumi.getter(name="forwardProxyConvention")
    def forward_proxy_convention(self) -> str:
        """
        The convention used to determine the url of the request made.
        """
        return pulumi.get(self, "forward_proxy_convention")

    @property
    @pulumi.getter(name="forwardProxyCustomHostHeaderName")
    def forward_proxy_custom_host_header_name(self) -> str:
        """
        The name of the custom header containing the host of the request.
        """
        return pulumi.get(self, "forward_proxy_custom_host_header_name")

    @property
    @pulumi.getter(name="forwardProxyCustomSchemeHeaderName")
    def forward_proxy_custom_scheme_header_name(self) -> str:
        """
        The name of the custom header containing the scheme of the request.
        """
        return pulumi.get(self, "forward_proxy_custom_scheme_header_name")

    @property
    @pulumi.getter(name="githubV2s")
    def github_v2s(self) -> Sequence['outputs.GetWindowsFunctionAppAuthSettingsV2GithubV2Result']:
        """
        A `github_v2` block as defined below.
        """
        return pulumi.get(self, "github_v2s")

    @property
    @pulumi.getter(name="googleV2s")
    def google_v2s(self) -> Sequence['outputs.GetWindowsFunctionAppAuthSettingsV2GoogleV2Result']:
        """
        A `google_v2` block as defined below.
        """
        return pulumi.get(self, "google_v2s")

    @property
    @pulumi.getter(name="httpRouteApiPrefix")
    def http_route_api_prefix(self) -> str:
        """
        The prefix that should precede all the authentication and authorisation paths.
        """
        return pulumi.get(self, "http_route_api_prefix")

    @property
    @pulumi.getter
    def logins(self) -> Sequence['outputs.GetWindowsFunctionAppAuthSettingsV2LoginResult']:
        """
        A `login` block as defined below.
        """
        return pulumi.get(self, "logins")

    @property
    @pulumi.getter(name="microsoftV2s")
    def microsoft_v2s(self) -> Sequence['outputs.GetWindowsFunctionAppAuthSettingsV2MicrosoftV2Result']:
        """
        A `microsoft_v2` block as defined below.
        """
        return pulumi.get(self, "microsoft_v2s")

    @property
    @pulumi.getter(name="requireAuthentication")
    def require_authentication(self) -> bool:
        """
        Is the authentication flow used for all requests.
        """
        return pulumi.get(self, "require_authentication")

    @property
    @pulumi.getter(name="requireHttps")
    def require_https(self) -> bool:
        """
        Is HTTPS required on connections?
        """
        return pulumi.get(self, "require_https")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> str:
        """
        The Runtime Version of the Authentication and Authorisation feature of this App.
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter(name="twitterV2s")
    def twitter_v2s(self) -> Sequence['outputs.GetWindowsFunctionAppAuthSettingsV2TwitterV2Result']:
        """
        A `twitter_v2` block as defined below.
        """
        return pulumi.get(self, "twitter_v2s")

    @property
    @pulumi.getter(name="unauthenticatedAction")
    def unauthenticated_action(self) -> str:
        """
        The action to take for requests made without authentication.
        """
        return pulumi.get(self, "unauthenticated_action")


@pulumi.output_type
class GetWindowsFunctionAppAuthSettingsV2ActiveDirectoryV2Result(dict):
    def __init__(__self__, *,
                 allowed_applications: Sequence[str],
                 allowed_audiences: Sequence[str],
                 allowed_groups: Sequence[str],
                 allowed_identities: Sequence[str],
                 client_id: str,
                 client_secret_certificate_thumbprint: str,
                 client_secret_setting_name: str,
                 jwt_allowed_client_applications: Sequence[str],
                 jwt_allowed_groups: Sequence[str],
                 login_parameters: Mapping[str, str],
                 tenant_auth_endpoint: str,
                 www_authentication_disabled: bool):
        """
        :param Sequence[str] allowed_applications: The list of allowed Applications for the Default Authorisation Policy.
        :param Sequence[str] allowed_audiences: The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
        :param Sequence[str] allowed_groups: The list of allowed Group Names for the Default Authorisation Policy.
        :param Sequence[str] allowed_identities: The list of allowed Identities for the Default Authorisation Policy.
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret_certificate_thumbprint: The thumbprint of the certificate used for signing purposes.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        :param Sequence[str] jwt_allowed_client_applications: The list of Allowed Client Applications in the JWT Claim.
        :param Sequence[str] jwt_allowed_groups: The list of Allowed Groups in the JWT Claim.
        :param Mapping[str, str] login_parameters: A map of key-value pairs sent to the Authorisation Endpoint when a user logs in.
        :param str tenant_auth_endpoint: The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`
        :param bool www_authentication_disabled: Is the www-authenticate provider omitted from the request?
        """
        pulumi.set(__self__, "allowed_applications", allowed_applications)
        pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        pulumi.set(__self__, "allowed_groups", allowed_groups)
        pulumi.set(__self__, "allowed_identities", allowed_identities)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_certificate_thumbprint", client_secret_certificate_thumbprint)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "jwt_allowed_client_applications", jwt_allowed_client_applications)
        pulumi.set(__self__, "jwt_allowed_groups", jwt_allowed_groups)
        pulumi.set(__self__, "login_parameters", login_parameters)
        pulumi.set(__self__, "tenant_auth_endpoint", tenant_auth_endpoint)
        pulumi.set(__self__, "www_authentication_disabled", www_authentication_disabled)

    @property
    @pulumi.getter(name="allowedApplications")
    def allowed_applications(self) -> Sequence[str]:
        """
        The list of allowed Applications for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_applications")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Sequence[str]:
        """
        The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="allowedGroups")
    def allowed_groups(self) -> Sequence[str]:
        """
        The list of allowed Group Names for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_groups")

    @property
    @pulumi.getter(name="allowedIdentities")
    def allowed_identities(self) -> Sequence[str]:
        """
        The list of allowed Identities for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_identities")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretCertificateThumbprint")
    def client_secret_certificate_thumbprint(self) -> str:
        """
        The thumbprint of the certificate used for signing purposes.
        """
        return pulumi.get(self, "client_secret_certificate_thumbprint")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="jwtAllowedClientApplications")
    def jwt_allowed_client_applications(self) -> Sequence[str]:
        """
        The list of Allowed Client Applications in the JWT Claim.
        """
        return pulumi.get(self, "jwt_allowed_client_applications")

    @property
    @pulumi.getter(name="jwtAllowedGroups")
    def jwt_allowed_groups(self) -> Sequence[str]:
        """
        The list of Allowed Groups in the JWT Claim.
        """
        return pulumi.get(self, "jwt_allowed_groups")

    @property
    @pulumi.getter(name="loginParameters")
    def login_parameters(self) -> Mapping[str, str]:
        """
        A map of key-value pairs sent to the Authorisation Endpoint when a user logs in.
        """
        return pulumi.get(self, "login_parameters")

    @property
    @pulumi.getter(name="tenantAuthEndpoint")
    def tenant_auth_endpoint(self) -> str:
        """
        The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`
        """
        return pulumi.get(self, "tenant_auth_endpoint")

    @property
    @pulumi.getter(name="wwwAuthenticationDisabled")
    def www_authentication_disabled(self) -> bool:
        """
        Is the www-authenticate provider omitted from the request?
        """
        return pulumi.get(self, "www_authentication_disabled")


@pulumi.output_type
class GetWindowsFunctionAppAuthSettingsV2AppleV2Result(dict):
    def __init__(__self__, *,
                 client_id: str,
                 client_secret_setting_name: str,
                 login_scopes: Sequence[str]):
        """
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        :param Sequence[str] login_scopes: The list of Login scopes that are requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Sequence[str]:
        """
        The list of Login scopes that are requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class GetWindowsFunctionAppAuthSettingsV2AzureStaticWebAppV2Result(dict):
    def __init__(__self__, *,
                 client_id: str):
        """
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        pulumi.set(__self__, "client_id", client_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")


@pulumi.output_type
class GetWindowsFunctionAppAuthSettingsV2CustomOidcV2Result(dict):
    def __init__(__self__, *,
                 authorisation_endpoint: str,
                 certification_uri: str,
                 client_credential_method: str,
                 client_id: str,
                 client_secret_setting_name: str,
                 issuer_endpoint: str,
                 name: str,
                 name_claim_type: str,
                 openid_configuration_endpoint: str,
                 scopes: Sequence[str],
                 token_endpoint: str):
        """
        :param str authorisation_endpoint: The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        :param str certification_uri: The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        :param str client_credential_method: The Client Credential Method used.
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        :param str issuer_endpoint: The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        :param str name: The name of this Windows Function App.
        :param str name_claim_type: The name of the claim that contains the users name.
        :param str openid_configuration_endpoint: The app setting name that contains the `client_secret` value used for the Custom OIDC Login.
        :param Sequence[str] scopes: The list of the scopes that are requested while authenticating.
        :param str token_endpoint: The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
        pulumi.set(__self__, "authorisation_endpoint", authorisation_endpoint)
        pulumi.set(__self__, "certification_uri", certification_uri)
        pulumi.set(__self__, "client_credential_method", client_credential_method)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "issuer_endpoint", issuer_endpoint)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "name_claim_type", name_claim_type)
        pulumi.set(__self__, "openid_configuration_endpoint", openid_configuration_endpoint)
        pulumi.set(__self__, "scopes", scopes)
        pulumi.set(__self__, "token_endpoint", token_endpoint)

    @property
    @pulumi.getter(name="authorisationEndpoint")
    def authorisation_endpoint(self) -> str:
        """
        The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "authorisation_endpoint")

    @property
    @pulumi.getter(name="certificationUri")
    def certification_uri(self) -> str:
        """
        The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "certification_uri")

    @property
    @pulumi.getter(name="clientCredentialMethod")
    def client_credential_method(self) -> str:
        """
        The Client Credential Method used.
        """
        return pulumi.get(self, "client_credential_method")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="issuerEndpoint")
    def issuer_endpoint(self) -> str:
        """
        The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "issuer_endpoint")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this Windows Function App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nameClaimType")
    def name_claim_type(self) -> str:
        """
        The name of the claim that contains the users name.
        """
        return pulumi.get(self, "name_claim_type")

    @property
    @pulumi.getter(name="openidConfigurationEndpoint")
    def openid_configuration_endpoint(self) -> str:
        """
        The app setting name that contains the `client_secret` value used for the Custom OIDC Login.
        """
        return pulumi.get(self, "openid_configuration_endpoint")

    @property
    @pulumi.getter
    def scopes(self) -> Sequence[str]:
        """
        The list of the scopes that are requested while authenticating.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> str:
        """
        The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "token_endpoint")


@pulumi.output_type
class GetWindowsFunctionAppAuthSettingsV2FacebookV2Result(dict):
    def __init__(__self__, *,
                 app_id: str,
                 app_secret_setting_name: str,
                 graph_api_version: str,
                 login_scopes: Sequence[str]):
        """
        :param str app_id: The App ID of the Facebook app used for login.
        :param str app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook Login.
        :param str graph_api_version: The version of the Facebook API to be used while logging in.
        :param Sequence[str] login_scopes: The list of Login scopes that are requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        pulumi.set(__self__, "graph_api_version", graph_api_version)
        pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> str:
        """
        The app setting name that contains the `app_secret` value used for Facebook Login.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @property
    @pulumi.getter(name="graphApiVersion")
    def graph_api_version(self) -> str:
        """
        The version of the Facebook API to be used while logging in.
        """
        return pulumi.get(self, "graph_api_version")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Sequence[str]:
        """
        The list of Login scopes that are requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class GetWindowsFunctionAppAuthSettingsV2GithubV2Result(dict):
    def __init__(__self__, *,
                 client_id: str,
                 client_secret_setting_name: str,
                 login_scopes: Sequence[str]):
        """
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        :param Sequence[str] login_scopes: The list of Login scopes that are requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Sequence[str]:
        """
        The list of Login scopes that are requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class GetWindowsFunctionAppAuthSettingsV2GoogleV2Result(dict):
    def __init__(__self__, *,
                 allowed_audiences: Sequence[str],
                 client_id: str,
                 client_secret_setting_name: str,
                 login_scopes: Sequence[str]):
        """
        :param Sequence[str] allowed_audiences: The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        :param Sequence[str] login_scopes: The list of Login scopes that are requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Sequence[str]:
        """
        The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Sequence[str]:
        """
        The list of Login scopes that are requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class GetWindowsFunctionAppAuthSettingsV2LoginResult(dict):
    def __init__(__self__, *,
                 allowed_external_redirect_urls: Sequence[str],
                 cookie_expiration_convention: str,
                 cookie_expiration_time: str,
                 logout_endpoint: str,
                 nonce_expiration_time: str,
                 preserve_url_fragments_for_logins: bool,
                 token_refresh_extension_time: float,
                 token_store_enabled: bool,
                 token_store_path: str,
                 token_store_sas_setting_name: str,
                 validate_nonce: bool):
        """
        :param Sequence[str] allowed_external_redirect_urls: External URLs that can be redirected to as part of logging in or logging out of the app.
        :param str cookie_expiration_convention: The method by which cookies expire.
        :param str cookie_expiration_time: The time after the request is made when the session cookie should expire.
        :param str logout_endpoint: The endpoint to which logout requests are made.
        :param str nonce_expiration_time: The time after the request is made when the nonce should expire.
        :param bool preserve_url_fragments_for_logins: Are the fragments from the request preserved after the login request is made.
        :param float token_refresh_extension_time: The number of hours after session token expiration that a session token can be used to call the token refresh API.
        :param bool token_store_enabled: Is the Token Store configuration Enabled.
        :param str token_store_path: The directory path in the App Filesystem in which the tokens are stored.
        :param str token_store_sas_setting_name: The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        :param bool validate_nonce: Is the nonce validated while completing the login flow.
        """
        pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        pulumi.set(__self__, "cookie_expiration_convention", cookie_expiration_convention)
        pulumi.set(__self__, "cookie_expiration_time", cookie_expiration_time)
        pulumi.set(__self__, "logout_endpoint", logout_endpoint)
        pulumi.set(__self__, "nonce_expiration_time", nonce_expiration_time)
        pulumi.set(__self__, "preserve_url_fragments_for_logins", preserve_url_fragments_for_logins)
        pulumi.set(__self__, "token_refresh_extension_time", token_refresh_extension_time)
        pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        pulumi.set(__self__, "token_store_path", token_store_path)
        pulumi.set(__self__, "token_store_sas_setting_name", token_store_sas_setting_name)
        pulumi.set(__self__, "validate_nonce", validate_nonce)

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Sequence[str]:
        """
        External URLs that can be redirected to as part of logging in or logging out of the app.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @property
    @pulumi.getter(name="cookieExpirationConvention")
    def cookie_expiration_convention(self) -> str:
        """
        The method by which cookies expire.
        """
        return pulumi.get(self, "cookie_expiration_convention")

    @property
    @pulumi.getter(name="cookieExpirationTime")
    def cookie_expiration_time(self) -> str:
        """
        The time after the request is made when the session cookie should expire.
        """
        return pulumi.get(self, "cookie_expiration_time")

    @property
    @pulumi.getter(name="logoutEndpoint")
    def logout_endpoint(self) -> str:
        """
        The endpoint to which logout requests are made.
        """
        return pulumi.get(self, "logout_endpoint")

    @property
    @pulumi.getter(name="nonceExpirationTime")
    def nonce_expiration_time(self) -> str:
        """
        The time after the request is made when the nonce should expire.
        """
        return pulumi.get(self, "nonce_expiration_time")

    @property
    @pulumi.getter(name="preserveUrlFragmentsForLogins")
    def preserve_url_fragments_for_logins(self) -> bool:
        """
        Are the fragments from the request preserved after the login request is made.
        """
        return pulumi.get(self, "preserve_url_fragments_for_logins")

    @property
    @pulumi.getter(name="tokenRefreshExtensionTime")
    def token_refresh_extension_time(self) -> float:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API.
        """
        return pulumi.get(self, "token_refresh_extension_time")

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> bool:
        """
        Is the Token Store configuration Enabled.
        """
        return pulumi.get(self, "token_store_enabled")

    @property
    @pulumi.getter(name="tokenStorePath")
    def token_store_path(self) -> str:
        """
        The directory path in the App Filesystem in which the tokens are stored.
        """
        return pulumi.get(self, "token_store_path")

    @property
    @pulumi.getter(name="tokenStoreSasSettingName")
    def token_store_sas_setting_name(self) -> str:
        """
        The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        """
        return pulumi.get(self, "token_store_sas_setting_name")

    @property
    @pulumi.getter(name="validateNonce")
    def validate_nonce(self) -> bool:
        """
        Is the nonce validated while completing the login flow.
        """
        return pulumi.get(self, "validate_nonce")


@pulumi.output_type
class GetWindowsFunctionAppAuthSettingsV2MicrosoftV2Result(dict):
    def __init__(__self__, *,
                 allowed_audiences: Sequence[str],
                 client_id: str,
                 client_secret_setting_name: str,
                 login_scopes: Sequence[str]):
        """
        :param Sequence[str] allowed_audiences: The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        :param Sequence[str] login_scopes: The list of Login scopes that are requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Sequence[str]:
        """
        The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Sequence[str]:
        """
        The list of Login scopes that are requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class GetWindowsFunctionAppAuthSettingsV2TwitterV2Result(dict):
    def __init__(__self__, *,
                 consumer_key: str,
                 consumer_secret_setting_name: str):
        """
        :param str consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param str consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> str:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> str:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_secret_setting_name")


@pulumi.output_type
class GetWindowsFunctionAppBackupResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 name: str,
                 schedules: Sequence['outputs.GetWindowsFunctionAppBackupScheduleResult'],
                 storage_account_url: str):
        """
        :param bool enabled: Is the Backup Job enabled?
        :param str name: The name of this Windows Function App.
        :param Sequence['GetWindowsFunctionAppBackupScheduleArgs'] schedules: A `schedule` block as defined below.
        :param str storage_account_url: The SAS URL to the container.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schedules", schedules)
        pulumi.set(__self__, "storage_account_url", storage_account_url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is the Backup Job enabled?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this Windows Function App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def schedules(self) -> Sequence['outputs.GetWindowsFunctionAppBackupScheduleResult']:
        """
        A `schedule` block as defined below.
        """
        return pulumi.get(self, "schedules")

    @property
    @pulumi.getter(name="storageAccountUrl")
    def storage_account_url(self) -> str:
        """
        The SAS URL to the container.
        """
        return pulumi.get(self, "storage_account_url")


@pulumi.output_type
class GetWindowsFunctionAppBackupScheduleResult(dict):
    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_unit: str,
                 keep_at_least_one_backup: bool,
                 last_execution_time: str,
                 retention_period_days: int,
                 start_time: str):
        """
        :param int frequency_interval: How often the backup is executed.
        :param str frequency_unit: The unit of time the backup should take place.
        :param bool keep_at_least_one_backup: Should the service keep at least one backup.
        :param int retention_period_days: After how many days backups is deleted.
        :param str start_time: When the schedule should start working in RFC-3339 format.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_unit", frequency_unit)
        pulumi.set(__self__, "keep_at_least_one_backup", keep_at_least_one_backup)
        pulumi.set(__self__, "last_execution_time", last_execution_time)
        pulumi.set(__self__, "retention_period_days", retention_period_days)
        pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        How often the backup is executed.
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyUnit")
    def frequency_unit(self) -> str:
        """
        The unit of time the backup should take place.
        """
        return pulumi.get(self, "frequency_unit")

    @property
    @pulumi.getter(name="keepAtLeastOneBackup")
    def keep_at_least_one_backup(self) -> bool:
        """
        Should the service keep at least one backup.
        """
        return pulumi.get(self, "keep_at_least_one_backup")

    @property
    @pulumi.getter(name="lastExecutionTime")
    def last_execution_time(self) -> str:
        return pulumi.get(self, "last_execution_time")

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> int:
        """
        After how many days backups is deleted.
        """
        return pulumi.get(self, "retention_period_days")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        """
        When the schedule should start working in RFC-3339 format.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class GetWindowsFunctionAppConnectionStringResult(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: The name of this Windows Function App.
        :param str type: The type of Managed Service Identity that is configured on this Windows Function App.
        :param str value: The connection string value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this Windows Function App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of Managed Service Identity that is configured on this Windows Function App.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The connection string value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetWindowsFunctionAppIdentityResult(dict):
    def __init__(__self__, *,
                 identity_ids: Sequence[str],
                 principal_id: str,
                 tenant_id: str,
                 type: str):
        """
        :param Sequence[str] identity_ids: The list of User Assigned Managed Identity IDs assigned to this Windows Function App.
        :param str principal_id: The Principal ID of the System Assigned Managed Service Identity that is configured on this Windows Function App.
        :param str tenant_id: The Tenant ID of the System Assigned Managed Service Identity that is configured on this Windows Function App.
        :param str type: The type of Managed Service Identity that is configured on this Windows Function App.
        """
        pulumi.set(__self__, "identity_ids", identity_ids)
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Sequence[str]:
        """
        The list of User Assigned Managed Identity IDs assigned to this Windows Function App.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The Principal ID of the System Assigned Managed Service Identity that is configured on this Windows Function App.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The Tenant ID of the System Assigned Managed Service Identity that is configured on this Windows Function App.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of Managed Service Identity that is configured on this Windows Function App.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetWindowsFunctionAppSiteConfigResult(dict):
    def __init__(__self__, *,
                 always_on: bool,
                 api_definition_url: str,
                 api_management_api_id: str,
                 app_command_line: str,
                 app_scale_limit: int,
                 app_service_logs: Sequence['outputs.GetWindowsFunctionAppSiteConfigAppServiceLogResult'],
                 application_insights_connection_string: str,
                 application_insights_key: str,
                 application_stacks: Sequence['outputs.GetWindowsFunctionAppSiteConfigApplicationStackResult'],
                 cors: Sequence['outputs.GetWindowsFunctionAppSiteConfigCorResult'],
                 default_documents: Sequence[str],
                 detailed_error_logging_enabled: bool,
                 elastic_instance_minimum: int,
                 ftps_state: str,
                 health_check_eviction_time_in_min: int,
                 health_check_path: str,
                 http2_enabled: bool,
                 ip_restrictions: Sequence['outputs.GetWindowsFunctionAppSiteConfigIpRestrictionResult'],
                 load_balancing_mode: str,
                 managed_pipeline_mode: str,
                 minimum_tls_version: str,
                 pre_warmed_instance_count: int,
                 remote_debugging_enabled: bool,
                 remote_debugging_version: str,
                 runtime_scale_monitoring_enabled: bool,
                 scm_ip_restrictions: Sequence['outputs.GetWindowsFunctionAppSiteConfigScmIpRestrictionResult'],
                 scm_minimum_tls_version: str,
                 scm_type: str,
                 scm_use_main_ip_restriction: bool,
                 use32_bit_worker: bool,
                 vnet_route_all_enabled: bool,
                 websockets_enabled: bool,
                 windows_fx_version: str,
                 worker_count: int):
        """
        :param bool always_on: Is this Windows Function App Always On?.
        :param str api_definition_url: The URL of the API definition that describes this Windows Function App.
        :param str api_management_api_id: The ID of the API Management API for this Windows Function App.
        :param str app_command_line: The App command line to launch.
        :param int app_scale_limit: The number of workers this function app can scale out to.
        :param Sequence['GetWindowsFunctionAppSiteConfigAppServiceLogArgs'] app_service_logs: A `app_service_logs` block as defined above.
        :param str application_insights_connection_string: The Connection String for linking the Windows Function App to Application Insights.
        :param str application_insights_key: The Instrumentation Key for connecting the Windows Function App to Application Insights.
        :param Sequence['GetWindowsFunctionAppSiteConfigApplicationStackArgs'] application_stacks: A `application_stack` block as defined above.
        :param Sequence['GetWindowsFunctionAppSiteConfigCorArgs'] cors: A `cors` block as defined above.
        :param Sequence[str] default_documents: A list of Default Documents for the Windows Web App.
        :param bool detailed_error_logging_enabled: Is detailed error logging enabled?
        :param int elastic_instance_minimum: The number of minimum instances for this Windows Function App.
        :param str ftps_state: State of FTP / FTPS service for this Windows Function App.
        :param int health_check_eviction_time_in_min: The amount of time in minutes that a node can be unhealthy before being removed from the load balancer.
        :param str health_check_path: The path to be checked for this Windows Function App health.
        :param bool http2_enabled: Is the HTTP2 protocol enabled?
        :param Sequence['GetWindowsFunctionAppSiteConfigIpRestrictionArgs'] ip_restrictions: One or more `ip_restriction` blocks as defined above.
        :param str load_balancing_mode: The Site load balancing mode.
        :param str managed_pipeline_mode: The Managed pipeline mode.
        :param str minimum_tls_version: The minimum version of TLS required for SSL requests.
        :param int pre_warmed_instance_count: The number of pre-warmed instances for this Windows Function App.
        :param bool remote_debugging_enabled: Is Remote Debugging enabled?
        :param str remote_debugging_version: The Remote Debugging Version.
        :param bool runtime_scale_monitoring_enabled: Is Scale Monitoring of the Functions Runtime enabled?
        :param Sequence['GetWindowsFunctionAppSiteConfigScmIpRestrictionArgs'] scm_ip_restrictions: One or more `scm_ip_restriction` blocks as defined above.
        :param str scm_minimum_tls_version: The minimum version of TLS required for SSL requests to the SCM site.
        :param str scm_type: The SCM type.
        :param bool scm_use_main_ip_restriction: Is the `ip_restriction` configuration used for the SCM?.
        :param bool use32_bit_worker: Is the Windows Function App using a 32-bit worker process?
        :param bool vnet_route_all_enabled: Are all outbound traffic to NAT Gateways, Network Security Groups and User Defined Routes applied?
        :param bool websockets_enabled: Are Web Sockets enabled?
        :param str windows_fx_version: The Windows FX version.
        :param int worker_count: The number of Workers for this Windows Function App.
        """
        pulumi.set(__self__, "always_on", always_on)
        pulumi.set(__self__, "api_definition_url", api_definition_url)
        pulumi.set(__self__, "api_management_api_id", api_management_api_id)
        pulumi.set(__self__, "app_command_line", app_command_line)
        pulumi.set(__self__, "app_scale_limit", app_scale_limit)
        pulumi.set(__self__, "app_service_logs", app_service_logs)
        pulumi.set(__self__, "application_insights_connection_string", application_insights_connection_string)
        pulumi.set(__self__, "application_insights_key", application_insights_key)
        pulumi.set(__self__, "application_stacks", application_stacks)
        pulumi.set(__self__, "cors", cors)
        pulumi.set(__self__, "default_documents", default_documents)
        pulumi.set(__self__, "detailed_error_logging_enabled", detailed_error_logging_enabled)
        pulumi.set(__self__, "elastic_instance_minimum", elastic_instance_minimum)
        pulumi.set(__self__, "ftps_state", ftps_state)
        pulumi.set(__self__, "health_check_eviction_time_in_min", health_check_eviction_time_in_min)
        pulumi.set(__self__, "health_check_path", health_check_path)
        pulumi.set(__self__, "http2_enabled", http2_enabled)
        pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        pulumi.set(__self__, "load_balancing_mode", load_balancing_mode)
        pulumi.set(__self__, "managed_pipeline_mode", managed_pipeline_mode)
        pulumi.set(__self__, "minimum_tls_version", minimum_tls_version)
        pulumi.set(__self__, "pre_warmed_instance_count", pre_warmed_instance_count)
        pulumi.set(__self__, "remote_debugging_enabled", remote_debugging_enabled)
        pulumi.set(__self__, "remote_debugging_version", remote_debugging_version)
        pulumi.set(__self__, "runtime_scale_monitoring_enabled", runtime_scale_monitoring_enabled)
        pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        pulumi.set(__self__, "scm_minimum_tls_version", scm_minimum_tls_version)
        pulumi.set(__self__, "scm_type", scm_type)
        pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        pulumi.set(__self__, "use32_bit_worker", use32_bit_worker)
        pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        pulumi.set(__self__, "websockets_enabled", websockets_enabled)
        pulumi.set(__self__, "windows_fx_version", windows_fx_version)
        pulumi.set(__self__, "worker_count", worker_count)

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> bool:
        """
        Is this Windows Function App Always On?.
        """
        return pulumi.get(self, "always_on")

    @property
    @pulumi.getter(name="apiDefinitionUrl")
    def api_definition_url(self) -> str:
        """
        The URL of the API definition that describes this Windows Function App.
        """
        return pulumi.get(self, "api_definition_url")

    @property
    @pulumi.getter(name="apiManagementApiId")
    def api_management_api_id(self) -> str:
        """
        The ID of the API Management API for this Windows Function App.
        """
        return pulumi.get(self, "api_management_api_id")

    @property
    @pulumi.getter(name="appCommandLine")
    def app_command_line(self) -> str:
        """
        The App command line to launch.
        """
        return pulumi.get(self, "app_command_line")

    @property
    @pulumi.getter(name="appScaleLimit")
    def app_scale_limit(self) -> int:
        """
        The number of workers this function app can scale out to.
        """
        return pulumi.get(self, "app_scale_limit")

    @property
    @pulumi.getter(name="appServiceLogs")
    def app_service_logs(self) -> Sequence['outputs.GetWindowsFunctionAppSiteConfigAppServiceLogResult']:
        """
        A `app_service_logs` block as defined above.
        """
        return pulumi.get(self, "app_service_logs")

    @property
    @pulumi.getter(name="applicationInsightsConnectionString")
    def application_insights_connection_string(self) -> str:
        """
        The Connection String for linking the Windows Function App to Application Insights.
        """
        return pulumi.get(self, "application_insights_connection_string")

    @property
    @pulumi.getter(name="applicationInsightsKey")
    def application_insights_key(self) -> str:
        """
        The Instrumentation Key for connecting the Windows Function App to Application Insights.
        """
        return pulumi.get(self, "application_insights_key")

    @property
    @pulumi.getter(name="applicationStacks")
    def application_stacks(self) -> Sequence['outputs.GetWindowsFunctionAppSiteConfigApplicationStackResult']:
        """
        A `application_stack` block as defined above.
        """
        return pulumi.get(self, "application_stacks")

    @property
    @pulumi.getter
    def cors(self) -> Sequence['outputs.GetWindowsFunctionAppSiteConfigCorResult']:
        """
        A `cors` block as defined above.
        """
        return pulumi.get(self, "cors")

    @property
    @pulumi.getter(name="defaultDocuments")
    def default_documents(self) -> Sequence[str]:
        """
        A list of Default Documents for the Windows Web App.
        """
        return pulumi.get(self, "default_documents")

    @property
    @pulumi.getter(name="detailedErrorLoggingEnabled")
    def detailed_error_logging_enabled(self) -> bool:
        """
        Is detailed error logging enabled?
        """
        return pulumi.get(self, "detailed_error_logging_enabled")

    @property
    @pulumi.getter(name="elasticInstanceMinimum")
    def elastic_instance_minimum(self) -> int:
        """
        The number of minimum instances for this Windows Function App.
        """
        return pulumi.get(self, "elastic_instance_minimum")

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> str:
        """
        State of FTP / FTPS service for this Windows Function App.
        """
        return pulumi.get(self, "ftps_state")

    @property
    @pulumi.getter(name="healthCheckEvictionTimeInMin")
    def health_check_eviction_time_in_min(self) -> int:
        """
        The amount of time in minutes that a node can be unhealthy before being removed from the load balancer.
        """
        return pulumi.get(self, "health_check_eviction_time_in_min")

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> str:
        """
        The path to be checked for this Windows Function App health.
        """
        return pulumi.get(self, "health_check_path")

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> bool:
        """
        Is the HTTP2 protocol enabled?
        """
        return pulumi.get(self, "http2_enabled")

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Sequence['outputs.GetWindowsFunctionAppSiteConfigIpRestrictionResult']:
        """
        One or more `ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "ip_restrictions")

    @property
    @pulumi.getter(name="loadBalancingMode")
    def load_balancing_mode(self) -> str:
        """
        The Site load balancing mode.
        """
        return pulumi.get(self, "load_balancing_mode")

    @property
    @pulumi.getter(name="managedPipelineMode")
    def managed_pipeline_mode(self) -> str:
        """
        The Managed pipeline mode.
        """
        return pulumi.get(self, "managed_pipeline_mode")

    @property
    @pulumi.getter(name="minimumTlsVersion")
    def minimum_tls_version(self) -> str:
        """
        The minimum version of TLS required for SSL requests.
        """
        return pulumi.get(self, "minimum_tls_version")

    @property
    @pulumi.getter(name="preWarmedInstanceCount")
    def pre_warmed_instance_count(self) -> int:
        """
        The number of pre-warmed instances for this Windows Function App.
        """
        return pulumi.get(self, "pre_warmed_instance_count")

    @property
    @pulumi.getter(name="remoteDebuggingEnabled")
    def remote_debugging_enabled(self) -> bool:
        """
        Is Remote Debugging enabled?
        """
        return pulumi.get(self, "remote_debugging_enabled")

    @property
    @pulumi.getter(name="remoteDebuggingVersion")
    def remote_debugging_version(self) -> str:
        """
        The Remote Debugging Version.
        """
        return pulumi.get(self, "remote_debugging_version")

    @property
    @pulumi.getter(name="runtimeScaleMonitoringEnabled")
    def runtime_scale_monitoring_enabled(self) -> bool:
        """
        Is Scale Monitoring of the Functions Runtime enabled?
        """
        return pulumi.get(self, "runtime_scale_monitoring_enabled")

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Sequence['outputs.GetWindowsFunctionAppSiteConfigScmIpRestrictionResult']:
        """
        One or more `scm_ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "scm_ip_restrictions")

    @property
    @pulumi.getter(name="scmMinimumTlsVersion")
    def scm_minimum_tls_version(self) -> str:
        """
        The minimum version of TLS required for SSL requests to the SCM site.
        """
        return pulumi.get(self, "scm_minimum_tls_version")

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> str:
        """
        The SCM type.
        """
        return pulumi.get(self, "scm_type")

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> bool:
        """
        Is the `ip_restriction` configuration used for the SCM?.
        """
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @property
    @pulumi.getter(name="use32BitWorker")
    def use32_bit_worker(self) -> bool:
        """
        Is the Windows Function App using a 32-bit worker process?
        """
        return pulumi.get(self, "use32_bit_worker")

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> bool:
        """
        Are all outbound traffic to NAT Gateways, Network Security Groups and User Defined Routes applied?
        """
        return pulumi.get(self, "vnet_route_all_enabled")

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> bool:
        """
        Are Web Sockets enabled?
        """
        return pulumi.get(self, "websockets_enabled")

    @property
    @pulumi.getter(name="windowsFxVersion")
    def windows_fx_version(self) -> str:
        """
        The Windows FX version.
        """
        return pulumi.get(self, "windows_fx_version")

    @property
    @pulumi.getter(name="workerCount")
    def worker_count(self) -> int:
        """
        The number of Workers for this Windows Function App.
        """
        return pulumi.get(self, "worker_count")


@pulumi.output_type
class GetWindowsFunctionAppSiteConfigAppServiceLogResult(dict):
    def __init__(__self__, *,
                 disk_quota_mb: int,
                 retention_period_days: int):
        """
        :param int disk_quota_mb: The amount of disk space to use for logs.
        :param int retention_period_days: After how many days backups is deleted.
        """
        pulumi.set(__self__, "disk_quota_mb", disk_quota_mb)
        pulumi.set(__self__, "retention_period_days", retention_period_days)

    @property
    @pulumi.getter(name="diskQuotaMb")
    def disk_quota_mb(self) -> int:
        """
        The amount of disk space to use for logs.
        """
        return pulumi.get(self, "disk_quota_mb")

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> int:
        """
        After how many days backups is deleted.
        """
        return pulumi.get(self, "retention_period_days")


@pulumi.output_type
class GetWindowsFunctionAppSiteConfigApplicationStackResult(dict):
    def __init__(__self__, *,
                 dotnet_version: str,
                 java_version: str,
                 node_version: str,
                 powershell_core_version: str,
                 use_custom_runtime: bool,
                 use_dotnet_isolated_runtime: bool):
        """
        :param str dotnet_version: The version of .Net to use.
        :param str java_version: The version of Java to use.
        :param str node_version: The version of Node to use.
        :param str powershell_core_version: The version of PowerShell Core to use.
        :param bool use_custom_runtime: Is the Windows Function App using a custom runtime?.
        """
        pulumi.set(__self__, "dotnet_version", dotnet_version)
        pulumi.set(__self__, "java_version", java_version)
        pulumi.set(__self__, "node_version", node_version)
        pulumi.set(__self__, "powershell_core_version", powershell_core_version)
        pulumi.set(__self__, "use_custom_runtime", use_custom_runtime)
        pulumi.set(__self__, "use_dotnet_isolated_runtime", use_dotnet_isolated_runtime)

    @property
    @pulumi.getter(name="dotnetVersion")
    def dotnet_version(self) -> str:
        """
        The version of .Net to use.
        """
        return pulumi.get(self, "dotnet_version")

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> str:
        """
        The version of Java to use.
        """
        return pulumi.get(self, "java_version")

    @property
    @pulumi.getter(name="nodeVersion")
    def node_version(self) -> str:
        """
        The version of Node to use.
        """
        return pulumi.get(self, "node_version")

    @property
    @pulumi.getter(name="powershellCoreVersion")
    def powershell_core_version(self) -> str:
        """
        The version of PowerShell Core to use.
        """
        return pulumi.get(self, "powershell_core_version")

    @property
    @pulumi.getter(name="useCustomRuntime")
    def use_custom_runtime(self) -> bool:
        """
        Is the Windows Function App using a custom runtime?.
        """
        return pulumi.get(self, "use_custom_runtime")

    @property
    @pulumi.getter(name="useDotnetIsolatedRuntime")
    def use_dotnet_isolated_runtime(self) -> bool:
        return pulumi.get(self, "use_dotnet_isolated_runtime")


@pulumi.output_type
class GetWindowsFunctionAppSiteConfigCorResult(dict):
    def __init__(__self__, *,
                 allowed_origins: Sequence[str],
                 support_credentials: bool):
        """
        :param Sequence[str] allowed_origins: A list of origins that should be allowed to make cross-origin calls.
        :param bool support_credentials: Are credentials allows in CORS requests?.
        """
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Sequence[str]:
        """
        A list of origins that should be allowed to make cross-origin calls.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> bool:
        """
        Are credentials allows in CORS requests?.
        """
        return pulumi.get(self, "support_credentials")


@pulumi.output_type
class GetWindowsFunctionAppSiteConfigIpRestrictionResult(dict):
    def __init__(__self__, *,
                 action: str,
                 headers: Sequence['outputs.GetWindowsFunctionAppSiteConfigIpRestrictionHeaderResult'],
                 ip_address: str,
                 name: str,
                 priority: int,
                 service_tag: str,
                 virtual_network_subnet_id: str):
        """
        :param str name: The name of this Windows Function App.
        :param str virtual_network_subnet_id: The subnet id which the Windows Function App is vNet Integrated with.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "service_tag", service_tag)
        pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> str:
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.GetWindowsFunctionAppSiteConfigIpRestrictionHeaderResult']:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this Windows Function App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> str:
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> str:
        """
        The subnet id which the Windows Function App is vNet Integrated with.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class GetWindowsFunctionAppSiteConfigIpRestrictionHeaderResult(dict):
    def __init__(__self__, *,
                 x_azure_fdids: Sequence[str],
                 x_fd_health_probes: Sequence[str],
                 x_forwarded_fors: Sequence[str],
                 x_forwarded_hosts: Sequence[str]):
        pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        pulumi.set(__self__, "x_fd_health_probes", x_fd_health_probes)
        pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Sequence[str]:
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbes")
    def x_fd_health_probes(self) -> Sequence[str]:
        return pulumi.get(self, "x_fd_health_probes")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Sequence[str]:
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Sequence[str]:
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class GetWindowsFunctionAppSiteConfigScmIpRestrictionResult(dict):
    def __init__(__self__, *,
                 action: str,
                 headers: Sequence['outputs.GetWindowsFunctionAppSiteConfigScmIpRestrictionHeaderResult'],
                 ip_address: str,
                 name: str,
                 priority: int,
                 service_tag: str,
                 virtual_network_subnet_id: str):
        """
        :param str name: The name of this Windows Function App.
        :param str virtual_network_subnet_id: The subnet id which the Windows Function App is vNet Integrated with.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "service_tag", service_tag)
        pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> str:
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.GetWindowsFunctionAppSiteConfigScmIpRestrictionHeaderResult']:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this Windows Function App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> str:
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> str:
        """
        The subnet id which the Windows Function App is vNet Integrated with.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class GetWindowsFunctionAppSiteConfigScmIpRestrictionHeaderResult(dict):
    def __init__(__self__, *,
                 x_azure_fdids: Sequence[str],
                 x_fd_health_probes: Sequence[str],
                 x_forwarded_fors: Sequence[str],
                 x_forwarded_hosts: Sequence[str]):
        pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        pulumi.set(__self__, "x_fd_health_probes", x_fd_health_probes)
        pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Sequence[str]:
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbes")
    def x_fd_health_probes(self) -> Sequence[str]:
        return pulumi.get(self, "x_fd_health_probes")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Sequence[str]:
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Sequence[str]:
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class GetWindowsFunctionAppSiteCredentialResult(dict):
    def __init__(__self__, *,
                 name: str,
                 password: str):
        """
        :param str name: The name of this Windows Function App.
        :param str password: The Site Credentials Password used for publishing.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this Windows Function App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The Site Credentials Password used for publishing.
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class GetWindowsFunctionAppStickySettingResult(dict):
    def __init__(__self__, *,
                 app_setting_names: Sequence[str],
                 connection_string_names: Sequence[str]):
        """
        :param Sequence[str] app_setting_names: A list of `app_setting` names that the Windows Function App will not swap between Slots when a swap operation is triggered.
        :param Sequence[str] connection_string_names: A list of `connection_string` names that the Windows Function App will not swap between Slots when a swap operation is triggered.
        """
        pulumi.set(__self__, "app_setting_names", app_setting_names)
        pulumi.set(__self__, "connection_string_names", connection_string_names)

    @property
    @pulumi.getter(name="appSettingNames")
    def app_setting_names(self) -> Sequence[str]:
        """
        A list of `app_setting` names that the Windows Function App will not swap between Slots when a swap operation is triggered.
        """
        return pulumi.get(self, "app_setting_names")

    @property
    @pulumi.getter(name="connectionStringNames")
    def connection_string_names(self) -> Sequence[str]:
        """
        A list of `connection_string` names that the Windows Function App will not swap between Slots when a swap operation is triggered.
        """
        return pulumi.get(self, "connection_string_names")


@pulumi.output_type
class GetWindowsWebAppAuthSettingResult(dict):
    def __init__(__self__, *,
                 active_directories: Sequence['outputs.GetWindowsWebAppAuthSettingActiveDirectoryResult'],
                 additional_login_parameters: Mapping[str, str],
                 allowed_external_redirect_urls: Sequence[str],
                 default_provider: str,
                 enabled: bool,
                 facebooks: Sequence['outputs.GetWindowsWebAppAuthSettingFacebookResult'],
                 githubs: Sequence['outputs.GetWindowsWebAppAuthSettingGithubResult'],
                 googles: Sequence['outputs.GetWindowsWebAppAuthSettingGoogleResult'],
                 issuer: str,
                 microsofts: Sequence['outputs.GetWindowsWebAppAuthSettingMicrosoftResult'],
                 runtime_version: str,
                 token_refresh_extension_hours: float,
                 token_store_enabled: bool,
                 twitters: Sequence['outputs.GetWindowsWebAppAuthSettingTwitterResult'],
                 unauthenticated_client_action: str):
        """
        :param Sequence['GetWindowsWebAppAuthSettingActiveDirectoryArgs'] active_directories: A `active_directory` block as defined above.
        :param Mapping[str, str] additional_login_parameters: A `additional_login_parameters` block as defined above.
        :param Sequence[str] allowed_external_redirect_urls: External URLs that can be redirected to as part of logging in or logging out of the app.
        :param str default_provider: The Default Authentication Provider used when more than one Authentication Provider is configured and the `unauthenticated_action` is set to `RedirectToLoginPage`.
        :param bool enabled: Is the Backup enabled?
        :param Sequence['GetWindowsWebAppAuthSettingFacebookArgs'] facebooks: A `facebook` block as defined below.
        :param Sequence['GetWindowsWebAppAuthSettingGithubArgs'] githubs: A `github` block as defined below.
        :param Sequence['GetWindowsWebAppAuthSettingGoogleArgs'] googles: A `google` block as defined below.
        :param str issuer: The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Windows Web App.
        :param Sequence['GetWindowsWebAppAuthSettingMicrosoftArgs'] microsofts: A `microsoft` block as defined below.
        :param str runtime_version: The Runtime Version of the Authentication and Authorisation feature of this App.
        :param float token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to call the token refresh API.
        :param bool token_store_enabled: Is the Token Store configuration Enabled.
        :param Sequence['GetWindowsWebAppAuthSettingTwitterArgs'] twitters: A `twitter` block as defined below.
        :param str unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app.
        """
        pulumi.set(__self__, "active_directories", active_directories)
        pulumi.set(__self__, "additional_login_parameters", additional_login_parameters)
        pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        pulumi.set(__self__, "default_provider", default_provider)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "facebooks", facebooks)
        pulumi.set(__self__, "githubs", githubs)
        pulumi.set(__self__, "googles", googles)
        pulumi.set(__self__, "issuer", issuer)
        pulumi.set(__self__, "microsofts", microsofts)
        pulumi.set(__self__, "runtime_version", runtime_version)
        pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)
        pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        pulumi.set(__self__, "twitters", twitters)
        pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter(name="activeDirectories")
    def active_directories(self) -> Sequence['outputs.GetWindowsWebAppAuthSettingActiveDirectoryResult']:
        """
        A `active_directory` block as defined above.
        """
        return pulumi.get(self, "active_directories")

    @property
    @pulumi.getter(name="additionalLoginParameters")
    def additional_login_parameters(self) -> Mapping[str, str]:
        """
        A `additional_login_parameters` block as defined above.
        """
        return pulumi.get(self, "additional_login_parameters")

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Sequence[str]:
        """
        External URLs that can be redirected to as part of logging in or logging out of the app.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> str:
        """
        The Default Authentication Provider used when more than one Authentication Provider is configured and the `unauthenticated_action` is set to `RedirectToLoginPage`.
        """
        return pulumi.get(self, "default_provider")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is the Backup enabled?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def facebooks(self) -> Sequence['outputs.GetWindowsWebAppAuthSettingFacebookResult']:
        """
        A `facebook` block as defined below.
        """
        return pulumi.get(self, "facebooks")

    @property
    @pulumi.getter
    def githubs(self) -> Sequence['outputs.GetWindowsWebAppAuthSettingGithubResult']:
        """
        A `github` block as defined below.
        """
        return pulumi.get(self, "githubs")

    @property
    @pulumi.getter
    def googles(self) -> Sequence['outputs.GetWindowsWebAppAuthSettingGoogleResult']:
        """
        A `google` block as defined below.
        """
        return pulumi.get(self, "googles")

    @property
    @pulumi.getter
    def issuer(self) -> str:
        """
        The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Windows Web App.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def microsofts(self) -> Sequence['outputs.GetWindowsWebAppAuthSettingMicrosoftResult']:
        """
        A `microsoft` block as defined below.
        """
        return pulumi.get(self, "microsofts")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> str:
        """
        The Runtime Version of the Authentication and Authorisation feature of this App.
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> float:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API.
        """
        return pulumi.get(self, "token_refresh_extension_hours")

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> bool:
        """
        Is the Token Store configuration Enabled.
        """
        return pulumi.get(self, "token_store_enabled")

    @property
    @pulumi.getter
    def twitters(self) -> Sequence['outputs.GetWindowsWebAppAuthSettingTwitterResult']:
        """
        A `twitter` block as defined below.
        """
        return pulumi.get(self, "twitters")

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> str:
        """
        The action to take when an unauthenticated client attempts to access the app.
        """
        return pulumi.get(self, "unauthenticated_client_action")


@pulumi.output_type
class GetWindowsWebAppAuthSettingActiveDirectoryResult(dict):
    def __init__(__self__, *,
                 allowed_audiences: Sequence[str],
                 client_id: str,
                 client_secret: str,
                 client_secret_setting_name: str):
        """
        :param Sequence[str] allowed_audiences: The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
        :param str client_id: The OAuth 2.0 client ID used by the app for authentication.
        :param str client_secret: The OAuth 2.0 client secret used by the app for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        """
        pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Sequence[str]:
        """
        The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID used by the app for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The OAuth 2.0 client secret used by the app for authentication.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")


@pulumi.output_type
class GetWindowsWebAppAuthSettingFacebookResult(dict):
    def __init__(__self__, *,
                 app_id: str,
                 app_secret: str,
                 app_secret_setting_name: str,
                 oauth_scopes: Sequence[str]):
        """
        :param str app_id: The App ID of the Facebook app used for login.
        :param str app_secret: The App Secret of the Facebook app used for Facebook login.
        :param str app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook login.
        :param Sequence[str] oauth_scopes: A list of OAuth 2.0 scopes requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "app_secret", app_secret)
        pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appSecret")
    def app_secret(self) -> str:
        """
        The App Secret of the Facebook app used for Facebook login.
        """
        return pulumi.get(self, "app_secret")

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> str:
        """
        The app setting name that contains the `app_secret` value used for Facebook login.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Sequence[str]:
        """
        A list of OAuth 2.0 scopes requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class GetWindowsWebAppAuthSettingGithubResult(dict):
    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 client_secret_setting_name: str,
                 oauth_scopes: Sequence[str]):
        """
        :param str client_id: The OAuth 2.0 client ID used by the app for authentication.
        :param str client_secret: The OAuth 2.0 client secret used by the app for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        :param Sequence[str] oauth_scopes: A list of OAuth 2.0 scopes requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID used by the app for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The OAuth 2.0 client secret used by the app for authentication.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Sequence[str]:
        """
        A list of OAuth 2.0 scopes requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class GetWindowsWebAppAuthSettingGoogleResult(dict):
    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 client_secret_setting_name: str,
                 oauth_scopes: Sequence[str]):
        """
        :param str client_id: The OAuth 2.0 client ID used by the app for authentication.
        :param str client_secret: The OAuth 2.0 client secret used by the app for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        :param Sequence[str] oauth_scopes: A list of OAuth 2.0 scopes requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID used by the app for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The OAuth 2.0 client secret used by the app for authentication.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Sequence[str]:
        """
        A list of OAuth 2.0 scopes requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class GetWindowsWebAppAuthSettingMicrosoftResult(dict):
    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 client_secret_setting_name: str,
                 oauth_scopes: Sequence[str]):
        """
        :param str client_id: The OAuth 2.0 client ID used by the app for authentication.
        :param str client_secret: The OAuth 2.0 client secret used by the app for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        :param Sequence[str] oauth_scopes: A list of OAuth 2.0 scopes requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID used by the app for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The OAuth 2.0 client secret used by the app for authentication.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Sequence[str]:
        """
        A list of OAuth 2.0 scopes requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class GetWindowsWebAppAuthSettingTwitterResult(dict):
    def __init__(__self__, *,
                 consumer_key: str,
                 consumer_secret: str,
                 consumer_secret_setting_name: str):
        """
        :param str consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param str consumer_secret: The OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        :param str consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        pulumi.set(__self__, "consumer_secret", consumer_secret)
        pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> str:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> str:
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_secret")

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> str:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_secret_setting_name")


@pulumi.output_type
class GetWindowsWebAppAuthSettingsV2Result(dict):
    def __init__(__self__, *,
                 active_directory_v2s: Sequence['outputs.GetWindowsWebAppAuthSettingsV2ActiveDirectoryV2Result'],
                 apple_v2s: Sequence['outputs.GetWindowsWebAppAuthSettingsV2AppleV2Result'],
                 auth_enabled: bool,
                 azure_static_web_app_v2s: Sequence['outputs.GetWindowsWebAppAuthSettingsV2AzureStaticWebAppV2Result'],
                 config_file_path: str,
                 custom_oidc_v2s: Sequence['outputs.GetWindowsWebAppAuthSettingsV2CustomOidcV2Result'],
                 default_provider: str,
                 excluded_paths: Sequence[str],
                 facebook_v2s: Sequence['outputs.GetWindowsWebAppAuthSettingsV2FacebookV2Result'],
                 forward_proxy_convention: str,
                 forward_proxy_custom_host_header_name: str,
                 forward_proxy_custom_scheme_header_name: str,
                 github_v2s: Sequence['outputs.GetWindowsWebAppAuthSettingsV2GithubV2Result'],
                 google_v2s: Sequence['outputs.GetWindowsWebAppAuthSettingsV2GoogleV2Result'],
                 http_route_api_prefix: str,
                 logins: Sequence['outputs.GetWindowsWebAppAuthSettingsV2LoginResult'],
                 microsoft_v2s: Sequence['outputs.GetWindowsWebAppAuthSettingsV2MicrosoftV2Result'],
                 require_authentication: bool,
                 require_https: bool,
                 runtime_version: str,
                 twitter_v2s: Sequence['outputs.GetWindowsWebAppAuthSettingsV2TwitterV2Result'],
                 unauthenticated_action: str):
        """
        :param Sequence['GetWindowsWebAppAuthSettingsV2ActiveDirectoryV2Args'] active_directory_v2s: An `active_directory_v2` block as defined below.
        :param Sequence['GetWindowsWebAppAuthSettingsV2AppleV2Args'] apple_v2s: An `apple_v2` block as defined below.
        :param bool auth_enabled: Are the AuthV2 Settings enabled.
        :param Sequence['GetWindowsWebAppAuthSettingsV2AzureStaticWebAppV2Args'] azure_static_web_app_v2s: An `azure_static_web_app_v2` block as defined below.
        :param str config_file_path: The path to the App Auth settings.
        :param Sequence['GetWindowsWebAppAuthSettingsV2CustomOidcV2Args'] custom_oidc_v2s: Zero or more `custom_oidc_v2` blocks as defined below.
        :param str default_provider: The Default Authentication Provider used when more than one Authentication Provider is configured and the `unauthenticated_action` is set to `RedirectToLoginPage`.
        :param Sequence[str] excluded_paths: The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.
        :param Sequence['GetWindowsWebAppAuthSettingsV2FacebookV2Args'] facebook_v2s: A `facebook_v2` block as defined below.
        :param str forward_proxy_convention: The convention used to determine the url of the request made.
        :param str forward_proxy_custom_host_header_name: The name of the custom header containing the host of the request.
        :param str forward_proxy_custom_scheme_header_name: The name of the custom header containing the scheme of the request.
        :param Sequence['GetWindowsWebAppAuthSettingsV2GithubV2Args'] github_v2s: A `github_v2` block as defined below.
        :param Sequence['GetWindowsWebAppAuthSettingsV2GoogleV2Args'] google_v2s: A `google_v2` block as defined below.
        :param str http_route_api_prefix: The prefix that should precede all the authentication and authorisation paths.
        :param Sequence['GetWindowsWebAppAuthSettingsV2LoginArgs'] logins: A `login` block as defined below.
        :param Sequence['GetWindowsWebAppAuthSettingsV2MicrosoftV2Args'] microsoft_v2s: A `microsoft_v2` block as defined below.
        :param bool require_authentication: Is the authentication flow used for all requests.
        :param bool require_https: Is HTTPS required on connections?
        :param str runtime_version: The Runtime Version of the Authentication and Authorisation feature of this App.
        :param Sequence['GetWindowsWebAppAuthSettingsV2TwitterV2Args'] twitter_v2s: A `twitter_v2` block as defined below.
        :param str unauthenticated_action: The action to take for requests made without authentication.
        """
        pulumi.set(__self__, "active_directory_v2s", active_directory_v2s)
        pulumi.set(__self__, "apple_v2s", apple_v2s)
        pulumi.set(__self__, "auth_enabled", auth_enabled)
        pulumi.set(__self__, "azure_static_web_app_v2s", azure_static_web_app_v2s)
        pulumi.set(__self__, "config_file_path", config_file_path)
        pulumi.set(__self__, "custom_oidc_v2s", custom_oidc_v2s)
        pulumi.set(__self__, "default_provider", default_provider)
        pulumi.set(__self__, "excluded_paths", excluded_paths)
        pulumi.set(__self__, "facebook_v2s", facebook_v2s)
        pulumi.set(__self__, "forward_proxy_convention", forward_proxy_convention)
        pulumi.set(__self__, "forward_proxy_custom_host_header_name", forward_proxy_custom_host_header_name)
        pulumi.set(__self__, "forward_proxy_custom_scheme_header_name", forward_proxy_custom_scheme_header_name)
        pulumi.set(__self__, "github_v2s", github_v2s)
        pulumi.set(__self__, "google_v2s", google_v2s)
        pulumi.set(__self__, "http_route_api_prefix", http_route_api_prefix)
        pulumi.set(__self__, "logins", logins)
        pulumi.set(__self__, "microsoft_v2s", microsoft_v2s)
        pulumi.set(__self__, "require_authentication", require_authentication)
        pulumi.set(__self__, "require_https", require_https)
        pulumi.set(__self__, "runtime_version", runtime_version)
        pulumi.set(__self__, "twitter_v2s", twitter_v2s)
        pulumi.set(__self__, "unauthenticated_action", unauthenticated_action)

    @property
    @pulumi.getter(name="activeDirectoryV2s")
    def active_directory_v2s(self) -> Sequence['outputs.GetWindowsWebAppAuthSettingsV2ActiveDirectoryV2Result']:
        """
        An `active_directory_v2` block as defined below.
        """
        return pulumi.get(self, "active_directory_v2s")

    @property
    @pulumi.getter(name="appleV2s")
    def apple_v2s(self) -> Sequence['outputs.GetWindowsWebAppAuthSettingsV2AppleV2Result']:
        """
        An `apple_v2` block as defined below.
        """
        return pulumi.get(self, "apple_v2s")

    @property
    @pulumi.getter(name="authEnabled")
    def auth_enabled(self) -> bool:
        """
        Are the AuthV2 Settings enabled.
        """
        return pulumi.get(self, "auth_enabled")

    @property
    @pulumi.getter(name="azureStaticWebAppV2s")
    def azure_static_web_app_v2s(self) -> Sequence['outputs.GetWindowsWebAppAuthSettingsV2AzureStaticWebAppV2Result']:
        """
        An `azure_static_web_app_v2` block as defined below.
        """
        return pulumi.get(self, "azure_static_web_app_v2s")

    @property
    @pulumi.getter(name="configFilePath")
    def config_file_path(self) -> str:
        """
        The path to the App Auth settings.
        """
        return pulumi.get(self, "config_file_path")

    @property
    @pulumi.getter(name="customOidcV2s")
    def custom_oidc_v2s(self) -> Sequence['outputs.GetWindowsWebAppAuthSettingsV2CustomOidcV2Result']:
        """
        Zero or more `custom_oidc_v2` blocks as defined below.
        """
        return pulumi.get(self, "custom_oidc_v2s")

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> str:
        """
        The Default Authentication Provider used when more than one Authentication Provider is configured and the `unauthenticated_action` is set to `RedirectToLoginPage`.
        """
        return pulumi.get(self, "default_provider")

    @property
    @pulumi.getter(name="excludedPaths")
    def excluded_paths(self) -> Sequence[str]:
        """
        The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.
        """
        return pulumi.get(self, "excluded_paths")

    @property
    @pulumi.getter(name="facebookV2s")
    def facebook_v2s(self) -> Sequence['outputs.GetWindowsWebAppAuthSettingsV2FacebookV2Result']:
        """
        A `facebook_v2` block as defined below.
        """
        return pulumi.get(self, "facebook_v2s")

    @property
    @pulumi.getter(name="forwardProxyConvention")
    def forward_proxy_convention(self) -> str:
        """
        The convention used to determine the url of the request made.
        """
        return pulumi.get(self, "forward_proxy_convention")

    @property
    @pulumi.getter(name="forwardProxyCustomHostHeaderName")
    def forward_proxy_custom_host_header_name(self) -> str:
        """
        The name of the custom header containing the host of the request.
        """
        return pulumi.get(self, "forward_proxy_custom_host_header_name")

    @property
    @pulumi.getter(name="forwardProxyCustomSchemeHeaderName")
    def forward_proxy_custom_scheme_header_name(self) -> str:
        """
        The name of the custom header containing the scheme of the request.
        """
        return pulumi.get(self, "forward_proxy_custom_scheme_header_name")

    @property
    @pulumi.getter(name="githubV2s")
    def github_v2s(self) -> Sequence['outputs.GetWindowsWebAppAuthSettingsV2GithubV2Result']:
        """
        A `github_v2` block as defined below.
        """
        return pulumi.get(self, "github_v2s")

    @property
    @pulumi.getter(name="googleV2s")
    def google_v2s(self) -> Sequence['outputs.GetWindowsWebAppAuthSettingsV2GoogleV2Result']:
        """
        A `google_v2` block as defined below.
        """
        return pulumi.get(self, "google_v2s")

    @property
    @pulumi.getter(name="httpRouteApiPrefix")
    def http_route_api_prefix(self) -> str:
        """
        The prefix that should precede all the authentication and authorisation paths.
        """
        return pulumi.get(self, "http_route_api_prefix")

    @property
    @pulumi.getter
    def logins(self) -> Sequence['outputs.GetWindowsWebAppAuthSettingsV2LoginResult']:
        """
        A `login` block as defined below.
        """
        return pulumi.get(self, "logins")

    @property
    @pulumi.getter(name="microsoftV2s")
    def microsoft_v2s(self) -> Sequence['outputs.GetWindowsWebAppAuthSettingsV2MicrosoftV2Result']:
        """
        A `microsoft_v2` block as defined below.
        """
        return pulumi.get(self, "microsoft_v2s")

    @property
    @pulumi.getter(name="requireAuthentication")
    def require_authentication(self) -> bool:
        """
        Is the authentication flow used for all requests.
        """
        return pulumi.get(self, "require_authentication")

    @property
    @pulumi.getter(name="requireHttps")
    def require_https(self) -> bool:
        """
        Is HTTPS required on connections?
        """
        return pulumi.get(self, "require_https")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> str:
        """
        The Runtime Version of the Authentication and Authorisation feature of this App.
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter(name="twitterV2s")
    def twitter_v2s(self) -> Sequence['outputs.GetWindowsWebAppAuthSettingsV2TwitterV2Result']:
        """
        A `twitter_v2` block as defined below.
        """
        return pulumi.get(self, "twitter_v2s")

    @property
    @pulumi.getter(name="unauthenticatedAction")
    def unauthenticated_action(self) -> str:
        """
        The action to take for requests made without authentication.
        """
        return pulumi.get(self, "unauthenticated_action")


@pulumi.output_type
class GetWindowsWebAppAuthSettingsV2ActiveDirectoryV2Result(dict):
    def __init__(__self__, *,
                 allowed_applications: Sequence[str],
                 allowed_audiences: Sequence[str],
                 allowed_groups: Sequence[str],
                 allowed_identities: Sequence[str],
                 client_id: str,
                 client_secret_certificate_thumbprint: str,
                 client_secret_setting_name: str,
                 jwt_allowed_client_applications: Sequence[str],
                 jwt_allowed_groups: Sequence[str],
                 login_parameters: Mapping[str, str],
                 tenant_auth_endpoint: str,
                 www_authentication_disabled: bool):
        """
        :param Sequence[str] allowed_applications: The list of allowed Applications for the Default Authorisation Policy.
        :param Sequence[str] allowed_audiences: The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
        :param Sequence[str] allowed_groups: The list of allowed Group Names for the Default Authorisation Policy.
        :param Sequence[str] allowed_identities: The list of allowed Identities for the Default Authorisation Policy.
        :param str client_id: The OAuth 2.0 client ID used by the app for authentication.
        :param str client_secret_certificate_thumbprint: The thumbprint of the certificate used for signing purposes.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        :param Sequence[str] jwt_allowed_client_applications: The list of Allowed Client Applications in the JWT Claim.
        :param Sequence[str] jwt_allowed_groups: The list of Allowed Groups in the JWT Claim.
        :param Mapping[str, str] login_parameters: A map of key-value pairs sent to the Authorisation Endpoint when a user logs in.
        :param str tenant_auth_endpoint: The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`
        :param bool www_authentication_disabled: Is the www-authenticate provider omitted from the request?
        """
        pulumi.set(__self__, "allowed_applications", allowed_applications)
        pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        pulumi.set(__self__, "allowed_groups", allowed_groups)
        pulumi.set(__self__, "allowed_identities", allowed_identities)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_certificate_thumbprint", client_secret_certificate_thumbprint)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "jwt_allowed_client_applications", jwt_allowed_client_applications)
        pulumi.set(__self__, "jwt_allowed_groups", jwt_allowed_groups)
        pulumi.set(__self__, "login_parameters", login_parameters)
        pulumi.set(__self__, "tenant_auth_endpoint", tenant_auth_endpoint)
        pulumi.set(__self__, "www_authentication_disabled", www_authentication_disabled)

    @property
    @pulumi.getter(name="allowedApplications")
    def allowed_applications(self) -> Sequence[str]:
        """
        The list of allowed Applications for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_applications")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Sequence[str]:
        """
        The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="allowedGroups")
    def allowed_groups(self) -> Sequence[str]:
        """
        The list of allowed Group Names for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_groups")

    @property
    @pulumi.getter(name="allowedIdentities")
    def allowed_identities(self) -> Sequence[str]:
        """
        The list of allowed Identities for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_identities")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID used by the app for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretCertificateThumbprint")
    def client_secret_certificate_thumbprint(self) -> str:
        """
        The thumbprint of the certificate used for signing purposes.
        """
        return pulumi.get(self, "client_secret_certificate_thumbprint")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="jwtAllowedClientApplications")
    def jwt_allowed_client_applications(self) -> Sequence[str]:
        """
        The list of Allowed Client Applications in the JWT Claim.
        """
        return pulumi.get(self, "jwt_allowed_client_applications")

    @property
    @pulumi.getter(name="jwtAllowedGroups")
    def jwt_allowed_groups(self) -> Sequence[str]:
        """
        The list of Allowed Groups in the JWT Claim.
        """
        return pulumi.get(self, "jwt_allowed_groups")

    @property
    @pulumi.getter(name="loginParameters")
    def login_parameters(self) -> Mapping[str, str]:
        """
        A map of key-value pairs sent to the Authorisation Endpoint when a user logs in.
        """
        return pulumi.get(self, "login_parameters")

    @property
    @pulumi.getter(name="tenantAuthEndpoint")
    def tenant_auth_endpoint(self) -> str:
        """
        The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`
        """
        return pulumi.get(self, "tenant_auth_endpoint")

    @property
    @pulumi.getter(name="wwwAuthenticationDisabled")
    def www_authentication_disabled(self) -> bool:
        """
        Is the www-authenticate provider omitted from the request?
        """
        return pulumi.get(self, "www_authentication_disabled")


@pulumi.output_type
class GetWindowsWebAppAuthSettingsV2AppleV2Result(dict):
    def __init__(__self__, *,
                 client_id: str,
                 client_secret_setting_name: str,
                 login_scopes: Sequence[str]):
        """
        :param str client_id: The OAuth 2.0 client ID used by the app for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        :param Sequence[str] login_scopes: The list of Login scopes that are requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID used by the app for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Sequence[str]:
        """
        The list of Login scopes that are requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class GetWindowsWebAppAuthSettingsV2AzureStaticWebAppV2Result(dict):
    def __init__(__self__, *,
                 client_id: str):
        """
        :param str client_id: The OAuth 2.0 client ID used by the app for authentication.
        """
        pulumi.set(__self__, "client_id", client_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID used by the app for authentication.
        """
        return pulumi.get(self, "client_id")


@pulumi.output_type
class GetWindowsWebAppAuthSettingsV2CustomOidcV2Result(dict):
    def __init__(__self__, *,
                 authorisation_endpoint: str,
                 certification_uri: str,
                 client_credential_method: str,
                 client_id: str,
                 client_secret_setting_name: str,
                 issuer_endpoint: str,
                 name: str,
                 name_claim_type: str,
                 openid_configuration_endpoint: str,
                 scopes: Sequence[str],
                 token_endpoint: str):
        """
        :param str authorisation_endpoint: The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        :param str certification_uri: The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        :param str client_credential_method: The Client Credential Method used.
        :param str client_id: The OAuth 2.0 client ID used by the app for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        :param str issuer_endpoint: The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        :param str name: The name of this Windows Web App.
        :param str name_claim_type: The name of the claim that contains the users name.
        :param str openid_configuration_endpoint: The app setting name that contains the `client_secret` value used for the Custom OIDC Login.
        :param Sequence[str] scopes: The list of the scopes that are requested while authenticating.
        :param str token_endpoint: The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
        pulumi.set(__self__, "authorisation_endpoint", authorisation_endpoint)
        pulumi.set(__self__, "certification_uri", certification_uri)
        pulumi.set(__self__, "client_credential_method", client_credential_method)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "issuer_endpoint", issuer_endpoint)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "name_claim_type", name_claim_type)
        pulumi.set(__self__, "openid_configuration_endpoint", openid_configuration_endpoint)
        pulumi.set(__self__, "scopes", scopes)
        pulumi.set(__self__, "token_endpoint", token_endpoint)

    @property
    @pulumi.getter(name="authorisationEndpoint")
    def authorisation_endpoint(self) -> str:
        """
        The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "authorisation_endpoint")

    @property
    @pulumi.getter(name="certificationUri")
    def certification_uri(self) -> str:
        """
        The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "certification_uri")

    @property
    @pulumi.getter(name="clientCredentialMethod")
    def client_credential_method(self) -> str:
        """
        The Client Credential Method used.
        """
        return pulumi.get(self, "client_credential_method")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID used by the app for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="issuerEndpoint")
    def issuer_endpoint(self) -> str:
        """
        The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "issuer_endpoint")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this Windows Web App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nameClaimType")
    def name_claim_type(self) -> str:
        """
        The name of the claim that contains the users name.
        """
        return pulumi.get(self, "name_claim_type")

    @property
    @pulumi.getter(name="openidConfigurationEndpoint")
    def openid_configuration_endpoint(self) -> str:
        """
        The app setting name that contains the `client_secret` value used for the Custom OIDC Login.
        """
        return pulumi.get(self, "openid_configuration_endpoint")

    @property
    @pulumi.getter
    def scopes(self) -> Sequence[str]:
        """
        The list of the scopes that are requested while authenticating.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> str:
        """
        The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "token_endpoint")


@pulumi.output_type
class GetWindowsWebAppAuthSettingsV2FacebookV2Result(dict):
    def __init__(__self__, *,
                 app_id: str,
                 app_secret_setting_name: str,
                 graph_api_version: str,
                 login_scopes: Sequence[str]):
        """
        :param str app_id: The App ID of the Facebook app used for login.
        :param str app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook login.
        :param str graph_api_version: The version of the Facebook API to be used while logging in.
        :param Sequence[str] login_scopes: The list of Login scopes that are requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        pulumi.set(__self__, "graph_api_version", graph_api_version)
        pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> str:
        """
        The app setting name that contains the `app_secret` value used for Facebook login.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @property
    @pulumi.getter(name="graphApiVersion")
    def graph_api_version(self) -> str:
        """
        The version of the Facebook API to be used while logging in.
        """
        return pulumi.get(self, "graph_api_version")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Sequence[str]:
        """
        The list of Login scopes that are requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class GetWindowsWebAppAuthSettingsV2GithubV2Result(dict):
    def __init__(__self__, *,
                 client_id: str,
                 client_secret_setting_name: str,
                 login_scopes: Sequence[str]):
        """
        :param str client_id: The OAuth 2.0 client ID used by the app for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        :param Sequence[str] login_scopes: The list of Login scopes that are requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID used by the app for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Sequence[str]:
        """
        The list of Login scopes that are requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class GetWindowsWebAppAuthSettingsV2GoogleV2Result(dict):
    def __init__(__self__, *,
                 allowed_audiences: Sequence[str],
                 client_id: str,
                 client_secret_setting_name: str,
                 login_scopes: Sequence[str]):
        """
        :param Sequence[str] allowed_audiences: The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
        :param str client_id: The OAuth 2.0 client ID used by the app for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        :param Sequence[str] login_scopes: The list of Login scopes that are requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Sequence[str]:
        """
        The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID used by the app for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Sequence[str]:
        """
        The list of Login scopes that are requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class GetWindowsWebAppAuthSettingsV2LoginResult(dict):
    def __init__(__self__, *,
                 allowed_external_redirect_urls: Sequence[str],
                 cookie_expiration_convention: str,
                 cookie_expiration_time: str,
                 logout_endpoint: str,
                 nonce_expiration_time: str,
                 preserve_url_fragments_for_logins: bool,
                 token_refresh_extension_time: float,
                 token_store_enabled: bool,
                 token_store_path: str,
                 token_store_sas_setting_name: str,
                 validate_nonce: bool):
        """
        :param Sequence[str] allowed_external_redirect_urls: External URLs that can be redirected to as part of logging in or logging out of the app.
        :param str cookie_expiration_convention: The method by which cookies expire.
        :param str cookie_expiration_time: The time after the request is made when the session cookie should expire.
        :param str logout_endpoint: The endpoint to which logout requests are made.
        :param str nonce_expiration_time: The time after the request is made when the nonce should expire.
        :param bool preserve_url_fragments_for_logins: Are the fragments from the request preserved after the login request is made.
        :param float token_refresh_extension_time: The number of hours after session token expiration that a session token can be used to call the token refresh API.
        :param bool token_store_enabled: Is the Token Store configuration Enabled.
        :param str token_store_path: The directory path in the App Filesystem in which the tokens are stored.
        :param str token_store_sas_setting_name: The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        :param bool validate_nonce: Is the nonce validated while completing the login flow.
        """
        pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        pulumi.set(__self__, "cookie_expiration_convention", cookie_expiration_convention)
        pulumi.set(__self__, "cookie_expiration_time", cookie_expiration_time)
        pulumi.set(__self__, "logout_endpoint", logout_endpoint)
        pulumi.set(__self__, "nonce_expiration_time", nonce_expiration_time)
        pulumi.set(__self__, "preserve_url_fragments_for_logins", preserve_url_fragments_for_logins)
        pulumi.set(__self__, "token_refresh_extension_time", token_refresh_extension_time)
        pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        pulumi.set(__self__, "token_store_path", token_store_path)
        pulumi.set(__self__, "token_store_sas_setting_name", token_store_sas_setting_name)
        pulumi.set(__self__, "validate_nonce", validate_nonce)

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Sequence[str]:
        """
        External URLs that can be redirected to as part of logging in or logging out of the app.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @property
    @pulumi.getter(name="cookieExpirationConvention")
    def cookie_expiration_convention(self) -> str:
        """
        The method by which cookies expire.
        """
        return pulumi.get(self, "cookie_expiration_convention")

    @property
    @pulumi.getter(name="cookieExpirationTime")
    def cookie_expiration_time(self) -> str:
        """
        The time after the request is made when the session cookie should expire.
        """
        return pulumi.get(self, "cookie_expiration_time")

    @property
    @pulumi.getter(name="logoutEndpoint")
    def logout_endpoint(self) -> str:
        """
        The endpoint to which logout requests are made.
        """
        return pulumi.get(self, "logout_endpoint")

    @property
    @pulumi.getter(name="nonceExpirationTime")
    def nonce_expiration_time(self) -> str:
        """
        The time after the request is made when the nonce should expire.
        """
        return pulumi.get(self, "nonce_expiration_time")

    @property
    @pulumi.getter(name="preserveUrlFragmentsForLogins")
    def preserve_url_fragments_for_logins(self) -> bool:
        """
        Are the fragments from the request preserved after the login request is made.
        """
        return pulumi.get(self, "preserve_url_fragments_for_logins")

    @property
    @pulumi.getter(name="tokenRefreshExtensionTime")
    def token_refresh_extension_time(self) -> float:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API.
        """
        return pulumi.get(self, "token_refresh_extension_time")

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> bool:
        """
        Is the Token Store configuration Enabled.
        """
        return pulumi.get(self, "token_store_enabled")

    @property
    @pulumi.getter(name="tokenStorePath")
    def token_store_path(self) -> str:
        """
        The directory path in the App Filesystem in which the tokens are stored.
        """
        return pulumi.get(self, "token_store_path")

    @property
    @pulumi.getter(name="tokenStoreSasSettingName")
    def token_store_sas_setting_name(self) -> str:
        """
        The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        """
        return pulumi.get(self, "token_store_sas_setting_name")

    @property
    @pulumi.getter(name="validateNonce")
    def validate_nonce(self) -> bool:
        """
        Is the nonce validated while completing the login flow.
        """
        return pulumi.get(self, "validate_nonce")


@pulumi.output_type
class GetWindowsWebAppAuthSettingsV2MicrosoftV2Result(dict):
    def __init__(__self__, *,
                 allowed_audiences: Sequence[str],
                 client_id: str,
                 client_secret_setting_name: str,
                 login_scopes: Sequence[str]):
        """
        :param Sequence[str] allowed_audiences: The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
        :param str client_id: The OAuth 2.0 client ID used by the app for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        :param Sequence[str] login_scopes: The list of Login scopes that are requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Sequence[str]:
        """
        The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID used by the app for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Sequence[str]:
        """
        The list of Login scopes that are requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")


@pulumi.output_type
class GetWindowsWebAppAuthSettingsV2TwitterV2Result(dict):
    def __init__(__self__, *,
                 consumer_key: str,
                 consumer_secret_setting_name: str):
        """
        :param str consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param str consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> str:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> str:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_secret_setting_name")


@pulumi.output_type
class GetWindowsWebAppBackupResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 name: str,
                 schedules: Sequence['outputs.GetWindowsWebAppBackupScheduleResult'],
                 storage_account_url: str):
        """
        :param bool enabled: Is the Backup enabled?
        :param str name: The name of this Windows Web App.
        :param Sequence['GetWindowsWebAppBackupScheduleArgs'] schedules: A `schedule` block as defined below.
        :param str storage_account_url: The SAS URL to the container.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schedules", schedules)
        pulumi.set(__self__, "storage_account_url", storage_account_url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is the Backup enabled?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this Windows Web App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def schedules(self) -> Sequence['outputs.GetWindowsWebAppBackupScheduleResult']:
        """
        A `schedule` block as defined below.
        """
        return pulumi.get(self, "schedules")

    @property
    @pulumi.getter(name="storageAccountUrl")
    def storage_account_url(self) -> str:
        """
        The SAS URL to the container.
        """
        return pulumi.get(self, "storage_account_url")


@pulumi.output_type
class GetWindowsWebAppBackupScheduleResult(dict):
    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_unit: str,
                 keep_at_least_one_backup: bool,
                 last_execution_time: str,
                 retention_period_days: int,
                 start_time: str):
        """
        :param int frequency_interval: How often the backup will be executed.
        :param str frequency_unit: The unit of time for how often the backup should take place.
        :param bool keep_at_least_one_backup: Will the service keep at least one backup, regardless of age of backup.
        :param str last_execution_time: The time of the last backup attempt.
        :param int retention_period_days: After how many days backups should be deleted.
        :param str start_time: When the schedule should start in RFC-3339 format.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_unit", frequency_unit)
        pulumi.set(__self__, "keep_at_least_one_backup", keep_at_least_one_backup)
        pulumi.set(__self__, "last_execution_time", last_execution_time)
        pulumi.set(__self__, "retention_period_days", retention_period_days)
        pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        How often the backup will be executed.
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyUnit")
    def frequency_unit(self) -> str:
        """
        The unit of time for how often the backup should take place.
        """
        return pulumi.get(self, "frequency_unit")

    @property
    @pulumi.getter(name="keepAtLeastOneBackup")
    def keep_at_least_one_backup(self) -> bool:
        """
        Will the service keep at least one backup, regardless of age of backup.
        """
        return pulumi.get(self, "keep_at_least_one_backup")

    @property
    @pulumi.getter(name="lastExecutionTime")
    def last_execution_time(self) -> str:
        """
        The time of the last backup attempt.
        """
        return pulumi.get(self, "last_execution_time")

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> int:
        """
        After how many days backups should be deleted.
        """
        return pulumi.get(self, "retention_period_days")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        """
        When the schedule should start in RFC-3339 format.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class GetWindowsWebAppConnectionStringResult(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: The name of this Windows Web App.
        :param str type: The Azure Storage Type.
        :param str value: The Connection String value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this Windows Web App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The Azure Storage Type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The Connection String value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetWindowsWebAppIdentityResult(dict):
    def __init__(__self__, *,
                 identity_ids: Sequence[str],
                 principal_id: str,
                 tenant_id: str,
                 type: str):
        """
        :param Sequence[str] identity_ids: A `identity_ids` block as defined below.
        :param str principal_id: The Principal ID Managed Service Identity.
        :param str tenant_id: The Tenant ID of the Managed Service Identity.
        :param str type: The Azure Storage Type.
        """
        pulumi.set(__self__, "identity_ids", identity_ids)
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Sequence[str]:
        """
        A `identity_ids` block as defined below.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The Principal ID Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The Tenant ID of the Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The Azure Storage Type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetWindowsWebAppLogResult(dict):
    def __init__(__self__, *,
                 application_logs: Sequence['outputs.GetWindowsWebAppLogApplicationLogResult'],
                 detailed_error_messages: bool,
                 failed_request_tracing: bool,
                 http_logs: Sequence['outputs.GetWindowsWebAppLogHttpLogResult']):
        """
        :param Sequence['GetWindowsWebAppLogApplicationLogArgs'] application_logs: A `application_logs` block as defined above.
        :param bool detailed_error_messages: Is Detailed Error Messaging enabled.
        :param bool failed_request_tracing: Is Failed Request Tracing enabled.
        :param Sequence['GetWindowsWebAppLogHttpLogArgs'] http_logs: An `http_logs` block as defined above.
        """
        pulumi.set(__self__, "application_logs", application_logs)
        pulumi.set(__self__, "detailed_error_messages", detailed_error_messages)
        pulumi.set(__self__, "failed_request_tracing", failed_request_tracing)
        pulumi.set(__self__, "http_logs", http_logs)

    @property
    @pulumi.getter(name="applicationLogs")
    def application_logs(self) -> Sequence['outputs.GetWindowsWebAppLogApplicationLogResult']:
        """
        A `application_logs` block as defined above.
        """
        return pulumi.get(self, "application_logs")

    @property
    @pulumi.getter(name="detailedErrorMessages")
    def detailed_error_messages(self) -> bool:
        """
        Is Detailed Error Messaging enabled.
        """
        return pulumi.get(self, "detailed_error_messages")

    @property
    @pulumi.getter(name="failedRequestTracing")
    def failed_request_tracing(self) -> bool:
        """
        Is Failed Request Tracing enabled.
        """
        return pulumi.get(self, "failed_request_tracing")

    @property
    @pulumi.getter(name="httpLogs")
    def http_logs(self) -> Sequence['outputs.GetWindowsWebAppLogHttpLogResult']:
        """
        An `http_logs` block as defined above.
        """
        return pulumi.get(self, "http_logs")


@pulumi.output_type
class GetWindowsWebAppLogApplicationLogResult(dict):
    def __init__(__self__, *,
                 azure_blob_storages: Sequence['outputs.GetWindowsWebAppLogApplicationLogAzureBlobStorageResult'],
                 file_system_level: str):
        """
        :param Sequence['GetWindowsWebAppLogApplicationLogAzureBlobStorageArgs'] azure_blob_storages: A `azure_blob_storage` block as defined above.
        :param str file_system_level: The logging level.
        """
        pulumi.set(__self__, "azure_blob_storages", azure_blob_storages)
        pulumi.set(__self__, "file_system_level", file_system_level)

    @property
    @pulumi.getter(name="azureBlobStorages")
    def azure_blob_storages(self) -> Sequence['outputs.GetWindowsWebAppLogApplicationLogAzureBlobStorageResult']:
        """
        A `azure_blob_storage` block as defined above.
        """
        return pulumi.get(self, "azure_blob_storages")

    @property
    @pulumi.getter(name="fileSystemLevel")
    def file_system_level(self) -> str:
        """
        The logging level.
        """
        return pulumi.get(self, "file_system_level")


@pulumi.output_type
class GetWindowsWebAppLogApplicationLogAzureBlobStorageResult(dict):
    def __init__(__self__, *,
                 level: str,
                 retention_in_days: int,
                 sas_url: str):
        """
        :param str level: The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        :param int retention_in_days: The retention period in days.
        :param str sas_url: The SAS url to the Azure Blob container.
        """
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "sas_url", sas_url)

    @property
    @pulumi.getter
    def level(self) -> str:
        """
        The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        """
        return pulumi.get(self, "level")

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> int:
        """
        The retention period in days.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> str:
        """
        The SAS url to the Azure Blob container.
        """
        return pulumi.get(self, "sas_url")


@pulumi.output_type
class GetWindowsWebAppLogHttpLogResult(dict):
    def __init__(__self__, *,
                 azure_blob_storages: Sequence['outputs.GetWindowsWebAppLogHttpLogAzureBlobStorageResult'],
                 file_systems: Sequence['outputs.GetWindowsWebAppLogHttpLogFileSystemResult']):
        """
        :param Sequence['GetWindowsWebAppLogHttpLogAzureBlobStorageArgs'] azure_blob_storages: A `azure_blob_storage` block as defined above.
        :param Sequence['GetWindowsWebAppLogHttpLogFileSystemArgs'] file_systems: A `file_system` block as defined above.
        """
        pulumi.set(__self__, "azure_blob_storages", azure_blob_storages)
        pulumi.set(__self__, "file_systems", file_systems)

    @property
    @pulumi.getter(name="azureBlobStorages")
    def azure_blob_storages(self) -> Sequence['outputs.GetWindowsWebAppLogHttpLogAzureBlobStorageResult']:
        """
        A `azure_blob_storage` block as defined above.
        """
        return pulumi.get(self, "azure_blob_storages")

    @property
    @pulumi.getter(name="fileSystems")
    def file_systems(self) -> Sequence['outputs.GetWindowsWebAppLogHttpLogFileSystemResult']:
        """
        A `file_system` block as defined above.
        """
        return pulumi.get(self, "file_systems")


@pulumi.output_type
class GetWindowsWebAppLogHttpLogAzureBlobStorageResult(dict):
    def __init__(__self__, *,
                 retention_in_days: int,
                 sas_url: str):
        """
        :param int retention_in_days: The retention period in days.
        :param str sas_url: The SAS url to the Azure Blob container.
        """
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "sas_url", sas_url)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> int:
        """
        The retention period in days.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> str:
        """
        The SAS url to the Azure Blob container.
        """
        return pulumi.get(self, "sas_url")


@pulumi.output_type
class GetWindowsWebAppLogHttpLogFileSystemResult(dict):
    def __init__(__self__, *,
                 retention_in_days: int,
                 retention_in_mb: int):
        """
        :param int retention_in_days: The retention period in days.
        :param int retention_in_mb: The maximum size in megabytes that log files can use.
        """
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "retention_in_mb", retention_in_mb)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> int:
        """
        The retention period in days.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="retentionInMb")
    def retention_in_mb(self) -> int:
        """
        The maximum size in megabytes that log files can use.
        """
        return pulumi.get(self, "retention_in_mb")


@pulumi.output_type
class GetWindowsWebAppSiteConfigResult(dict):
    def __init__(__self__, *,
                 always_on: bool,
                 api_definition_url: str,
                 api_management_api_id: str,
                 app_command_line: str,
                 application_stacks: Sequence['outputs.GetWindowsWebAppSiteConfigApplicationStackResult'],
                 auto_heal_enabled: bool,
                 auto_heal_settings: Sequence['outputs.GetWindowsWebAppSiteConfigAutoHealSettingResult'],
                 container_registry_managed_identity_client_id: str,
                 container_registry_use_managed_identity: bool,
                 cors: Sequence['outputs.GetWindowsWebAppSiteConfigCorResult'],
                 default_documents: Sequence[str],
                 detailed_error_logging_enabled: bool,
                 ftps_state: str,
                 health_check_eviction_time_in_min: int,
                 health_check_path: str,
                 http2_enabled: bool,
                 ip_restrictions: Sequence['outputs.GetWindowsWebAppSiteConfigIpRestrictionResult'],
                 load_balancing_mode: str,
                 local_mysql_enabled: bool,
                 managed_pipeline_mode: str,
                 minimum_tls_version: str,
                 remote_debugging_enabled: bool,
                 remote_debugging_version: str,
                 scm_ip_restrictions: Sequence['outputs.GetWindowsWebAppSiteConfigScmIpRestrictionResult'],
                 scm_minimum_tls_version: str,
                 scm_type: str,
                 scm_use_main_ip_restriction: bool,
                 use32_bit_worker: bool,
                 virtual_applications: Sequence['outputs.GetWindowsWebAppSiteConfigVirtualApplicationResult'],
                 vnet_route_all_enabled: bool,
                 websockets_enabled: bool,
                 windows_fx_version: str,
                 worker_count: int):
        """
        :param bool always_on: Is this Windows Web App is Always On enabled.
        :param str api_definition_url: The ID of the APIM configuration for this Windows Web App.
        :param str api_management_api_id: The ID of the API Management setting linked to the Windows Web App.
        :param str app_command_line: The command line used to launch this app.
        :param Sequence['GetWindowsWebAppSiteConfigApplicationStackArgs'] application_stacks: A `application_stack` block as defined above.
        :param bool auto_heal_enabled: Are Auto heal rules to be enabled.
        :param Sequence['GetWindowsWebAppSiteConfigAutoHealSettingArgs'] auto_heal_settings: A `auto_heal_setting` block as defined above.
        :param str container_registry_managed_identity_client_id: The Client ID of the Managed Service Identity used for connections to the Azure Container Registry.
        :param bool container_registry_use_managed_identity: Do connections for Azure Container Registry use Managed Identity.
        :param Sequence['GetWindowsWebAppSiteConfigCorArgs'] cors: A `cors` block as defined above.
        :param Sequence[str] default_documents: The list of Default Documents for the Windows Web App.
        :param bool detailed_error_logging_enabled: Is Detailed Error Logging enabled.
        :param str ftps_state: The State of FTP / FTPS service.
        :param int health_check_eviction_time_in_min: (Optional) The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        :param str health_check_path: The path to the Health Check endpoint.
        :param bool http2_enabled: Is HTTP2.0 enabled.
        :param Sequence['GetWindowsWebAppSiteConfigIpRestrictionArgs'] ip_restrictions: A `ip_restriction` block as defined above.
        :param str load_balancing_mode: The site Load Balancing Mode.
        :param bool local_mysql_enabled: Is the Local MySQL enabled.
        :param str managed_pipeline_mode: The Managed Pipeline Mode.
        :param str minimum_tls_version: The Minimum version of TLS for requests.
        :param str remote_debugging_version: The Remote Debugging Version.
        :param Sequence['GetWindowsWebAppSiteConfigScmIpRestrictionArgs'] scm_ip_restrictions: A `scm_ip_restriction` block as defined above.
        :param str scm_minimum_tls_version: The Minimum version of TLS for requests to SCM.
        :param str scm_type: The Source Control Management Type in use.
        :param bool scm_use_main_ip_restriction: Is the Windows Web App `ip_restriction` configuration used for the SCM also.
        :param bool use32_bit_worker: Does the Windows Web App use a 32-bit worker.
        :param Sequence['GetWindowsWebAppSiteConfigVirtualApplicationArgs'] virtual_applications: A `virtual_application` block as defined below.
        :param bool vnet_route_all_enabled: Are all outbound traffic to NAT Gateways, Network Security Groups and User Defined Routes applied?
        :param bool websockets_enabled: Are Web Sockets enabled?
        :param str windows_fx_version: The string representation of the Windows FX Version.
        :param int worker_count: The number of Workers for this Windows App Service.
        """
        pulumi.set(__self__, "always_on", always_on)
        pulumi.set(__self__, "api_definition_url", api_definition_url)
        pulumi.set(__self__, "api_management_api_id", api_management_api_id)
        pulumi.set(__self__, "app_command_line", app_command_line)
        pulumi.set(__self__, "application_stacks", application_stacks)
        pulumi.set(__self__, "auto_heal_enabled", auto_heal_enabled)
        pulumi.set(__self__, "auto_heal_settings", auto_heal_settings)
        pulumi.set(__self__, "container_registry_managed_identity_client_id", container_registry_managed_identity_client_id)
        pulumi.set(__self__, "container_registry_use_managed_identity", container_registry_use_managed_identity)
        pulumi.set(__self__, "cors", cors)
        pulumi.set(__self__, "default_documents", default_documents)
        pulumi.set(__self__, "detailed_error_logging_enabled", detailed_error_logging_enabled)
        pulumi.set(__self__, "ftps_state", ftps_state)
        pulumi.set(__self__, "health_check_eviction_time_in_min", health_check_eviction_time_in_min)
        pulumi.set(__self__, "health_check_path", health_check_path)
        pulumi.set(__self__, "http2_enabled", http2_enabled)
        pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        pulumi.set(__self__, "load_balancing_mode", load_balancing_mode)
        pulumi.set(__self__, "local_mysql_enabled", local_mysql_enabled)
        pulumi.set(__self__, "managed_pipeline_mode", managed_pipeline_mode)
        pulumi.set(__self__, "minimum_tls_version", minimum_tls_version)
        pulumi.set(__self__, "remote_debugging_enabled", remote_debugging_enabled)
        pulumi.set(__self__, "remote_debugging_version", remote_debugging_version)
        pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        pulumi.set(__self__, "scm_minimum_tls_version", scm_minimum_tls_version)
        pulumi.set(__self__, "scm_type", scm_type)
        pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        pulumi.set(__self__, "use32_bit_worker", use32_bit_worker)
        pulumi.set(__self__, "virtual_applications", virtual_applications)
        pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        pulumi.set(__self__, "websockets_enabled", websockets_enabled)
        pulumi.set(__self__, "windows_fx_version", windows_fx_version)
        pulumi.set(__self__, "worker_count", worker_count)

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> bool:
        """
        Is this Windows Web App is Always On enabled.
        """
        return pulumi.get(self, "always_on")

    @property
    @pulumi.getter(name="apiDefinitionUrl")
    def api_definition_url(self) -> str:
        """
        The ID of the APIM configuration for this Windows Web App.
        """
        return pulumi.get(self, "api_definition_url")

    @property
    @pulumi.getter(name="apiManagementApiId")
    def api_management_api_id(self) -> str:
        """
        The ID of the API Management setting linked to the Windows Web App.
        """
        return pulumi.get(self, "api_management_api_id")

    @property
    @pulumi.getter(name="appCommandLine")
    def app_command_line(self) -> str:
        """
        The command line used to launch this app.
        """
        return pulumi.get(self, "app_command_line")

    @property
    @pulumi.getter(name="applicationStacks")
    def application_stacks(self) -> Sequence['outputs.GetWindowsWebAppSiteConfigApplicationStackResult']:
        """
        A `application_stack` block as defined above.
        """
        return pulumi.get(self, "application_stacks")

    @property
    @pulumi.getter(name="autoHealEnabled")
    def auto_heal_enabled(self) -> bool:
        """
        Are Auto heal rules to be enabled.
        """
        return pulumi.get(self, "auto_heal_enabled")

    @property
    @pulumi.getter(name="autoHealSettings")
    def auto_heal_settings(self) -> Sequence['outputs.GetWindowsWebAppSiteConfigAutoHealSettingResult']:
        """
        A `auto_heal_setting` block as defined above.
        """
        return pulumi.get(self, "auto_heal_settings")

    @property
    @pulumi.getter(name="containerRegistryManagedIdentityClientId")
    def container_registry_managed_identity_client_id(self) -> str:
        """
        The Client ID of the Managed Service Identity used for connections to the Azure Container Registry.
        """
        return pulumi.get(self, "container_registry_managed_identity_client_id")

    @property
    @pulumi.getter(name="containerRegistryUseManagedIdentity")
    def container_registry_use_managed_identity(self) -> bool:
        """
        Do connections for Azure Container Registry use Managed Identity.
        """
        return pulumi.get(self, "container_registry_use_managed_identity")

    @property
    @pulumi.getter
    def cors(self) -> Sequence['outputs.GetWindowsWebAppSiteConfigCorResult']:
        """
        A `cors` block as defined above.
        """
        return pulumi.get(self, "cors")

    @property
    @pulumi.getter(name="defaultDocuments")
    def default_documents(self) -> Sequence[str]:
        """
        The list of Default Documents for the Windows Web App.
        """
        return pulumi.get(self, "default_documents")

    @property
    @pulumi.getter(name="detailedErrorLoggingEnabled")
    def detailed_error_logging_enabled(self) -> bool:
        """
        Is Detailed Error Logging enabled.
        """
        return pulumi.get(self, "detailed_error_logging_enabled")

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> str:
        """
        The State of FTP / FTPS service.
        """
        return pulumi.get(self, "ftps_state")

    @property
    @pulumi.getter(name="healthCheckEvictionTimeInMin")
    def health_check_eviction_time_in_min(self) -> int:
        """
        (Optional) The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        """
        return pulumi.get(self, "health_check_eviction_time_in_min")

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> str:
        """
        The path to the Health Check endpoint.
        """
        return pulumi.get(self, "health_check_path")

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> bool:
        """
        Is HTTP2.0 enabled.
        """
        return pulumi.get(self, "http2_enabled")

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Sequence['outputs.GetWindowsWebAppSiteConfigIpRestrictionResult']:
        """
        A `ip_restriction` block as defined above.
        """
        return pulumi.get(self, "ip_restrictions")

    @property
    @pulumi.getter(name="loadBalancingMode")
    def load_balancing_mode(self) -> str:
        """
        The site Load Balancing Mode.
        """
        return pulumi.get(self, "load_balancing_mode")

    @property
    @pulumi.getter(name="localMysqlEnabled")
    def local_mysql_enabled(self) -> bool:
        """
        Is the Local MySQL enabled.
        """
        return pulumi.get(self, "local_mysql_enabled")

    @property
    @pulumi.getter(name="managedPipelineMode")
    def managed_pipeline_mode(self) -> str:
        """
        The Managed Pipeline Mode.
        """
        return pulumi.get(self, "managed_pipeline_mode")

    @property
    @pulumi.getter(name="minimumTlsVersion")
    def minimum_tls_version(self) -> str:
        """
        The Minimum version of TLS for requests.
        """
        return pulumi.get(self, "minimum_tls_version")

    @property
    @pulumi.getter(name="remoteDebuggingEnabled")
    def remote_debugging_enabled(self) -> bool:
        return pulumi.get(self, "remote_debugging_enabled")

    @property
    @pulumi.getter(name="remoteDebuggingVersion")
    def remote_debugging_version(self) -> str:
        """
        The Remote Debugging Version.
        """
        return pulumi.get(self, "remote_debugging_version")

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Sequence['outputs.GetWindowsWebAppSiteConfigScmIpRestrictionResult']:
        """
        A `scm_ip_restriction` block as defined above.
        """
        return pulumi.get(self, "scm_ip_restrictions")

    @property
    @pulumi.getter(name="scmMinimumTlsVersion")
    def scm_minimum_tls_version(self) -> str:
        """
        The Minimum version of TLS for requests to SCM.
        """
        return pulumi.get(self, "scm_minimum_tls_version")

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> str:
        """
        The Source Control Management Type in use.
        """
        return pulumi.get(self, "scm_type")

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> bool:
        """
        Is the Windows Web App `ip_restriction` configuration used for the SCM also.
        """
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @property
    @pulumi.getter(name="use32BitWorker")
    def use32_bit_worker(self) -> bool:
        """
        Does the Windows Web App use a 32-bit worker.
        """
        return pulumi.get(self, "use32_bit_worker")

    @property
    @pulumi.getter(name="virtualApplications")
    def virtual_applications(self) -> Sequence['outputs.GetWindowsWebAppSiteConfigVirtualApplicationResult']:
        """
        A `virtual_application` block as defined below.
        """
        return pulumi.get(self, "virtual_applications")

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> bool:
        """
        Are all outbound traffic to NAT Gateways, Network Security Groups and User Defined Routes applied?
        """
        return pulumi.get(self, "vnet_route_all_enabled")

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> bool:
        """
        Are Web Sockets enabled?
        """
        return pulumi.get(self, "websockets_enabled")

    @property
    @pulumi.getter(name="windowsFxVersion")
    def windows_fx_version(self) -> str:
        """
        The string representation of the Windows FX Version.
        """
        return pulumi.get(self, "windows_fx_version")

    @property
    @pulumi.getter(name="workerCount")
    def worker_count(self) -> int:
        """
        The number of Workers for this Windows App Service.
        """
        return pulumi.get(self, "worker_count")


@pulumi.output_type
class GetWindowsWebAppSiteConfigApplicationStackResult(dict):
    def __init__(__self__, *,
                 current_stack: str,
                 docker_container_name: str,
                 docker_container_registry: str,
                 docker_container_tag: str,
                 docker_image_name: str,
                 docker_registry_password: str,
                 docker_registry_url: str,
                 docker_registry_username: str,
                 dotnet_core_version: str,
                 dotnet_version: str,
                 java_container: str,
                 java_container_version: str,
                 java_embedded_server_enabled: bool,
                 java_version: str,
                 node_version: str,
                 php_version: str,
                 python: bool,
                 python_version: str,
                 tomcat_version: str):
        """
        :param str current_stack: The Current Stack value of the Windows Web App.
        :param str docker_image_name: The docker image, including tag, used by this Windows Web App.
        :param str docker_registry_password: The User Name to use for authentication against the registry to pull the image.
        :param str docker_registry_url: The URL of the container registry where the `docker_image_name` is located.
        :param str docker_registry_username: The User Name to use for authentication against the registry to pull the image.
        :param str dotnet_version: The version of .NET in use.
        :param str java_container: The Java Container in use.
        :param str java_container_version: The Version of the Java Container in use.
        :param str java_version: The Version of Java in use.
        :param str node_version: The Version of Node in use.
        :param str php_version: The Version of the PHP in use.
        :param str python_version: The Version of Python in use.
        """
        pulumi.set(__self__, "current_stack", current_stack)
        pulumi.set(__self__, "docker_container_name", docker_container_name)
        pulumi.set(__self__, "docker_container_registry", docker_container_registry)
        pulumi.set(__self__, "docker_container_tag", docker_container_tag)
        pulumi.set(__self__, "docker_image_name", docker_image_name)
        pulumi.set(__self__, "docker_registry_password", docker_registry_password)
        pulumi.set(__self__, "docker_registry_url", docker_registry_url)
        pulumi.set(__self__, "docker_registry_username", docker_registry_username)
        pulumi.set(__self__, "dotnet_core_version", dotnet_core_version)
        pulumi.set(__self__, "dotnet_version", dotnet_version)
        pulumi.set(__self__, "java_container", java_container)
        pulumi.set(__self__, "java_container_version", java_container_version)
        pulumi.set(__self__, "java_embedded_server_enabled", java_embedded_server_enabled)
        pulumi.set(__self__, "java_version", java_version)
        pulumi.set(__self__, "node_version", node_version)
        pulumi.set(__self__, "php_version", php_version)
        pulumi.set(__self__, "python", python)
        pulumi.set(__self__, "python_version", python_version)
        pulumi.set(__self__, "tomcat_version", tomcat_version)

    @property
    @pulumi.getter(name="currentStack")
    def current_stack(self) -> str:
        """
        The Current Stack value of the Windows Web App.
        """
        return pulumi.get(self, "current_stack")

    @property
    @pulumi.getter(name="dockerContainerName")
    def docker_container_name(self) -> str:
        return pulumi.get(self, "docker_container_name")

    @property
    @pulumi.getter(name="dockerContainerRegistry")
    def docker_container_registry(self) -> str:
        return pulumi.get(self, "docker_container_registry")

    @property
    @pulumi.getter(name="dockerContainerTag")
    def docker_container_tag(self) -> str:
        return pulumi.get(self, "docker_container_tag")

    @property
    @pulumi.getter(name="dockerImageName")
    def docker_image_name(self) -> str:
        """
        The docker image, including tag, used by this Windows Web App.
        """
        return pulumi.get(self, "docker_image_name")

    @property
    @pulumi.getter(name="dockerRegistryPassword")
    def docker_registry_password(self) -> str:
        """
        The User Name to use for authentication against the registry to pull the image.
        """
        return pulumi.get(self, "docker_registry_password")

    @property
    @pulumi.getter(name="dockerRegistryUrl")
    def docker_registry_url(self) -> str:
        """
        The URL of the container registry where the `docker_image_name` is located.
        """
        return pulumi.get(self, "docker_registry_url")

    @property
    @pulumi.getter(name="dockerRegistryUsername")
    def docker_registry_username(self) -> str:
        """
        The User Name to use for authentication against the registry to pull the image.
        """
        return pulumi.get(self, "docker_registry_username")

    @property
    @pulumi.getter(name="dotnetCoreVersion")
    def dotnet_core_version(self) -> str:
        return pulumi.get(self, "dotnet_core_version")

    @property
    @pulumi.getter(name="dotnetVersion")
    def dotnet_version(self) -> str:
        """
        The version of .NET in use.
        """
        return pulumi.get(self, "dotnet_version")

    @property
    @pulumi.getter(name="javaContainer")
    def java_container(self) -> str:
        """
        The Java Container in use.
        """
        return pulumi.get(self, "java_container")

    @property
    @pulumi.getter(name="javaContainerVersion")
    def java_container_version(self) -> str:
        """
        The Version of the Java Container in use.
        """
        return pulumi.get(self, "java_container_version")

    @property
    @pulumi.getter(name="javaEmbeddedServerEnabled")
    def java_embedded_server_enabled(self) -> bool:
        return pulumi.get(self, "java_embedded_server_enabled")

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> str:
        """
        The Version of Java in use.
        """
        return pulumi.get(self, "java_version")

    @property
    @pulumi.getter(name="nodeVersion")
    def node_version(self) -> str:
        """
        The Version of Node in use.
        """
        return pulumi.get(self, "node_version")

    @property
    @pulumi.getter(name="phpVersion")
    def php_version(self) -> str:
        """
        The Version of the PHP in use.
        """
        return pulumi.get(self, "php_version")

    @property
    @pulumi.getter
    def python(self) -> bool:
        return pulumi.get(self, "python")

    @property
    @pulumi.getter(name="pythonVersion")
    def python_version(self) -> str:
        """
        The Version of Python in use.
        """
        return pulumi.get(self, "python_version")

    @property
    @pulumi.getter(name="tomcatVersion")
    def tomcat_version(self) -> str:
        return pulumi.get(self, "tomcat_version")


@pulumi.output_type
class GetWindowsWebAppSiteConfigAutoHealSettingResult(dict):
    def __init__(__self__, *,
                 actions: Sequence['outputs.GetWindowsWebAppSiteConfigAutoHealSettingActionResult'],
                 triggers: Sequence['outputs.GetWindowsWebAppSiteConfigAutoHealSettingTriggerResult']):
        """
        :param Sequence['GetWindowsWebAppSiteConfigAutoHealSettingActionArgs'] actions: A `action` block as defined above.
        :param Sequence['GetWindowsWebAppSiteConfigAutoHealSettingTriggerArgs'] triggers: A `trigger` block as defined below.
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "triggers", triggers)

    @property
    @pulumi.getter
    def actions(self) -> Sequence['outputs.GetWindowsWebAppSiteConfigAutoHealSettingActionResult']:
        """
        A `action` block as defined above.
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter
    def triggers(self) -> Sequence['outputs.GetWindowsWebAppSiteConfigAutoHealSettingTriggerResult']:
        """
        A `trigger` block as defined below.
        """
        return pulumi.get(self, "triggers")


@pulumi.output_type
class GetWindowsWebAppSiteConfigAutoHealSettingActionResult(dict):
    def __init__(__self__, *,
                 action_type: str,
                 custom_actions: Sequence['outputs.GetWindowsWebAppSiteConfigAutoHealSettingActionCustomActionResult'],
                 minimum_process_execution_time: str):
        """
        :param str action_type: The predefined action to be taken to an Auto Heal trigger.
        :param Sequence['GetWindowsWebAppSiteConfigAutoHealSettingActionCustomActionArgs'] custom_actions: A `custom_action` block as defined below.
        :param str minimum_process_execution_time: The minimum amount of time in `hh:mm:ss` the Windows Web App must have been running before the defined action will be run in the event of a trigger.
        """
        pulumi.set(__self__, "action_type", action_type)
        pulumi.set(__self__, "custom_actions", custom_actions)
        pulumi.set(__self__, "minimum_process_execution_time", minimum_process_execution_time)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> str:
        """
        The predefined action to be taken to an Auto Heal trigger.
        """
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter(name="customActions")
    def custom_actions(self) -> Sequence['outputs.GetWindowsWebAppSiteConfigAutoHealSettingActionCustomActionResult']:
        """
        A `custom_action` block as defined below.
        """
        return pulumi.get(self, "custom_actions")

    @property
    @pulumi.getter(name="minimumProcessExecutionTime")
    def minimum_process_execution_time(self) -> str:
        """
        The minimum amount of time in `hh:mm:ss` the Windows Web App must have been running before the defined action will be run in the event of a trigger.
        """
        return pulumi.get(self, "minimum_process_execution_time")


@pulumi.output_type
class GetWindowsWebAppSiteConfigAutoHealSettingActionCustomActionResult(dict):
    def __init__(__self__, *,
                 executable: str,
                 parameters: str):
        """
        :param str executable: The command run when this `auto_heal` action is triggered.
        :param str parameters: The parameters passed to the `executable`.
        """
        pulumi.set(__self__, "executable", executable)
        pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def executable(self) -> str:
        """
        The command run when this `auto_heal` action is triggered.
        """
        return pulumi.get(self, "executable")

    @property
    @pulumi.getter
    def parameters(self) -> str:
        """
        The parameters passed to the `executable`.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class GetWindowsWebAppSiteConfigAutoHealSettingTriggerResult(dict):
    def __init__(__self__, *,
                 private_memory_kb: int,
                 requests: Sequence['outputs.GetWindowsWebAppSiteConfigAutoHealSettingTriggerRequestResult'],
                 slow_requests: Sequence['outputs.GetWindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequestResult'],
                 status_codes: Sequence['outputs.GetWindowsWebAppSiteConfigAutoHealSettingTriggerStatusCodeResult']):
        """
        :param int private_memory_kb: The amount of Private Memory used.
        :param Sequence['GetWindowsWebAppSiteConfigAutoHealSettingTriggerRequestArgs'] requests: A `requests` block as defined above.
        :param Sequence['GetWindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequestArgs'] slow_requests: A `slow_request` block as defined above.
        :param Sequence['GetWindowsWebAppSiteConfigAutoHealSettingTriggerStatusCodeArgs'] status_codes: A `status_code` block as defined above.
        """
        pulumi.set(__self__, "private_memory_kb", private_memory_kb)
        pulumi.set(__self__, "requests", requests)
        pulumi.set(__self__, "slow_requests", slow_requests)
        pulumi.set(__self__, "status_codes", status_codes)

    @property
    @pulumi.getter(name="privateMemoryKb")
    def private_memory_kb(self) -> int:
        """
        The amount of Private Memory used.
        """
        return pulumi.get(self, "private_memory_kb")

    @property
    @pulumi.getter
    def requests(self) -> Sequence['outputs.GetWindowsWebAppSiteConfigAutoHealSettingTriggerRequestResult']:
        """
        A `requests` block as defined above.
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="slowRequests")
    def slow_requests(self) -> Sequence['outputs.GetWindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequestResult']:
        """
        A `slow_request` block as defined above.
        """
        return pulumi.get(self, "slow_requests")

    @property
    @pulumi.getter(name="statusCodes")
    def status_codes(self) -> Sequence['outputs.GetWindowsWebAppSiteConfigAutoHealSettingTriggerStatusCodeResult']:
        """
        A `status_code` block as defined above.
        """
        return pulumi.get(self, "status_codes")


@pulumi.output_type
class GetWindowsWebAppSiteConfigAutoHealSettingTriggerRequestResult(dict):
    def __init__(__self__, *,
                 count: int,
                 interval: str):
        """
        :param int count: The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        :param str interval: The time interval in the form `hh:mm:ss`.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        The time interval in the form `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class GetWindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequestResult(dict):
    def __init__(__self__, *,
                 count: int,
                 interval: str,
                 path: str,
                 time_taken: str):
        """
        :param int count: The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        :param str interval: The time interval in the form `hh:mm:ss`.
        :param str path: The path to which this rule status code applies.
        :param str time_taken: The amount of time that qualifies as slow for this rule.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "time_taken", time_taken)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        The time interval in the form `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The path to which this rule status code applies.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="timeTaken")
    def time_taken(self) -> str:
        """
        The amount of time that qualifies as slow for this rule.
        """
        return pulumi.get(self, "time_taken")


@pulumi.output_type
class GetWindowsWebAppSiteConfigAutoHealSettingTriggerStatusCodeResult(dict):
    def __init__(__self__, *,
                 count: int,
                 interval: str,
                 path: str,
                 status_code_range: str,
                 sub_status: int,
                 win32_status_code: int):
        """
        :param int count: The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        :param str interval: The time interval in the form `hh:mm:ss`.
        :param str path: The path to which this rule status code applies.
        :param str status_code_range: The status code or range for this rule.
        :param int sub_status: The Request Sub Status of the Status Code.
        :param int win32_status_code: The Win32 Status Code of the Request.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "status_code_range", status_code_range)
        pulumi.set(__self__, "sub_status", sub_status)
        pulumi.set(__self__, "win32_status_code", win32_status_code)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        The time interval in the form `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The path to which this rule status code applies.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="statusCodeRange")
    def status_code_range(self) -> str:
        """
        The status code or range for this rule.
        """
        return pulumi.get(self, "status_code_range")

    @property
    @pulumi.getter(name="subStatus")
    def sub_status(self) -> int:
        """
        The Request Sub Status of the Status Code.
        """
        return pulumi.get(self, "sub_status")

    @property
    @pulumi.getter(name="win32StatusCode")
    def win32_status_code(self) -> int:
        """
        The Win32 Status Code of the Request.
        """
        return pulumi.get(self, "win32_status_code")


@pulumi.output_type
class GetWindowsWebAppSiteConfigCorResult(dict):
    def __init__(__self__, *,
                 allowed_origins: Sequence[str],
                 support_credentials: bool):
        """
        :param Sequence[str] allowed_origins: A `allowed_origins` block as defined above.
        :param bool support_credentials: Whether CORS requests with credentials are allowed.
        """
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Sequence[str]:
        """
        A `allowed_origins` block as defined above.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> bool:
        """
        Whether CORS requests with credentials are allowed.
        """
        return pulumi.get(self, "support_credentials")


@pulumi.output_type
class GetWindowsWebAppSiteConfigIpRestrictionResult(dict):
    def __init__(__self__, *,
                 action: str,
                 headers: Sequence['outputs.GetWindowsWebAppSiteConfigIpRestrictionHeaderResult'],
                 ip_address: str,
                 name: str,
                 priority: int,
                 service_tag: str,
                 virtual_network_subnet_id: str):
        """
        :param str action: A `action` block as defined above.
        :param str name: The name of this Windows Web App.
        :param str virtual_network_subnet_id: The subnet id which the Windows Web App is vNet Integrated with.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "service_tag", service_tag)
        pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        A `action` block as defined above.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.GetWindowsWebAppSiteConfigIpRestrictionHeaderResult']:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this Windows Web App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> str:
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> str:
        """
        The subnet id which the Windows Web App is vNet Integrated with.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class GetWindowsWebAppSiteConfigIpRestrictionHeaderResult(dict):
    def __init__(__self__, *,
                 x_azure_fdids: Sequence[str],
                 x_fd_health_probes: Sequence[str],
                 x_forwarded_fors: Sequence[str],
                 x_forwarded_hosts: Sequence[str]):
        pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        pulumi.set(__self__, "x_fd_health_probes", x_fd_health_probes)
        pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Sequence[str]:
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbes")
    def x_fd_health_probes(self) -> Sequence[str]:
        return pulumi.get(self, "x_fd_health_probes")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Sequence[str]:
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Sequence[str]:
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class GetWindowsWebAppSiteConfigScmIpRestrictionResult(dict):
    def __init__(__self__, *,
                 action: str,
                 headers: Sequence['outputs.GetWindowsWebAppSiteConfigScmIpRestrictionHeaderResult'],
                 ip_address: str,
                 name: str,
                 priority: int,
                 service_tag: str,
                 virtual_network_subnet_id: str):
        """
        :param str action: A `action` block as defined above.
        :param str name: The name of this Windows Web App.
        :param str virtual_network_subnet_id: The subnet id which the Windows Web App is vNet Integrated with.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "service_tag", service_tag)
        pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        A `action` block as defined above.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.GetWindowsWebAppSiteConfigScmIpRestrictionHeaderResult']:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this Windows Web App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> str:
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> str:
        """
        The subnet id which the Windows Web App is vNet Integrated with.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class GetWindowsWebAppSiteConfigScmIpRestrictionHeaderResult(dict):
    def __init__(__self__, *,
                 x_azure_fdids: Sequence[str],
                 x_fd_health_probes: Sequence[str],
                 x_forwarded_fors: Sequence[str],
                 x_forwarded_hosts: Sequence[str]):
        pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        pulumi.set(__self__, "x_fd_health_probes", x_fd_health_probes)
        pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Sequence[str]:
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbes")
    def x_fd_health_probes(self) -> Sequence[str]:
        return pulumi.get(self, "x_fd_health_probes")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Sequence[str]:
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Sequence[str]:
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class GetWindowsWebAppSiteConfigVirtualApplicationResult(dict):
    def __init__(__self__, *,
                 physical_path: str,
                 preload: bool,
                 virtual_directories: Sequence['outputs.GetWindowsWebAppSiteConfigVirtualApplicationVirtualDirectoryResult'],
                 virtual_path: str):
        """
        :param str physical_path: The path on disk to the Virtual Directory
        :param bool preload: Is this Application Pre-loaded at startup.
        :param Sequence['GetWindowsWebAppSiteConfigVirtualApplicationVirtualDirectoryArgs'] virtual_directories: A `virtual_directory` block as defined below.
        :param str virtual_path: The Virtual Path of the Virtual Directory.
        """
        pulumi.set(__self__, "physical_path", physical_path)
        pulumi.set(__self__, "preload", preload)
        pulumi.set(__self__, "virtual_directories", virtual_directories)
        pulumi.set(__self__, "virtual_path", virtual_path)

    @property
    @pulumi.getter(name="physicalPath")
    def physical_path(self) -> str:
        """
        The path on disk to the Virtual Directory
        """
        return pulumi.get(self, "physical_path")

    @property
    @pulumi.getter
    def preload(self) -> bool:
        """
        Is this Application Pre-loaded at startup.
        """
        return pulumi.get(self, "preload")

    @property
    @pulumi.getter(name="virtualDirectories")
    def virtual_directories(self) -> Sequence['outputs.GetWindowsWebAppSiteConfigVirtualApplicationVirtualDirectoryResult']:
        """
        A `virtual_directory` block as defined below.
        """
        return pulumi.get(self, "virtual_directories")

    @property
    @pulumi.getter(name="virtualPath")
    def virtual_path(self) -> str:
        """
        The Virtual Path of the Virtual Directory.
        """
        return pulumi.get(self, "virtual_path")


@pulumi.output_type
class GetWindowsWebAppSiteConfigVirtualApplicationVirtualDirectoryResult(dict):
    def __init__(__self__, *,
                 physical_path: str,
                 virtual_path: str):
        """
        :param str physical_path: The path on disk to the Virtual Directory
        :param str virtual_path: The Virtual Path of the Virtual Directory.
        """
        pulumi.set(__self__, "physical_path", physical_path)
        pulumi.set(__self__, "virtual_path", virtual_path)

    @property
    @pulumi.getter(name="physicalPath")
    def physical_path(self) -> str:
        """
        The path on disk to the Virtual Directory
        """
        return pulumi.get(self, "physical_path")

    @property
    @pulumi.getter(name="virtualPath")
    def virtual_path(self) -> str:
        """
        The Virtual Path of the Virtual Directory.
        """
        return pulumi.get(self, "virtual_path")


@pulumi.output_type
class GetWindowsWebAppSiteCredentialResult(dict):
    def __init__(__self__, *,
                 name: str,
                 password: str):
        """
        :param str name: The name of this Windows Web App.
        :param str password: The Site Credentials Password used for publishing.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this Windows Web App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The Site Credentials Password used for publishing.
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class GetWindowsWebAppStickySettingResult(dict):
    def __init__(__self__, *,
                 app_setting_names: Sequence[str],
                 connection_string_names: Sequence[str]):
        """
        :param Sequence[str] app_setting_names: A list of `app_setting` names that the Windows Web App will not swap between Slots when a swap operation is triggered.
        :param Sequence[str] connection_string_names: A list of `connection_string` names that the Windows Web App will not swap between Slots when a swap operation is triggered.
        """
        pulumi.set(__self__, "app_setting_names", app_setting_names)
        pulumi.set(__self__, "connection_string_names", connection_string_names)

    @property
    @pulumi.getter(name="appSettingNames")
    def app_setting_names(self) -> Sequence[str]:
        """
        A list of `app_setting` names that the Windows Web App will not swap between Slots when a swap operation is triggered.
        """
        return pulumi.get(self, "app_setting_names")

    @property
    @pulumi.getter(name="connectionStringNames")
    def connection_string_names(self) -> Sequence[str]:
        """
        A list of `connection_string` names that the Windows Web App will not swap between Slots when a swap operation is triggered.
        """
        return pulumi.get(self, "connection_string_names")


@pulumi.output_type
class GetWindowsWebAppStorageAccountResult(dict):
    def __init__(__self__, *,
                 access_key: str,
                 account_name: str,
                 mount_path: str,
                 name: str,
                 share_name: str,
                 type: str):
        """
        :param str access_key: The Access key for the storage account.
        :param str account_name: The Name of the Storage Account.
        :param str mount_path: The path at which to mount the Storage Share.
        :param str name: The name of this Windows Web App.
        :param str share_name: The Name of the File Share.
        :param str type: The Azure Storage Type.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "mount_path", mount_path)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "share_name", share_name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> str:
        """
        The Access key for the storage account.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> str:
        """
        The Name of the Storage Account.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> str:
        """
        The path at which to mount the Storage Share.
        """
        return pulumi.get(self, "mount_path")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this Windows Web App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> str:
        """
        The Name of the File Share.
        """
        return pulumi.get(self, "share_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The Azure Storage Type.
        """
        return pulumi.get(self, "type")


