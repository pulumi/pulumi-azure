# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'AppServiceAuthSettings',
    'AppServiceAuthSettingsActiveDirectory',
    'AppServiceAuthSettingsFacebook',
    'AppServiceAuthSettingsGoogle',
    'AppServiceAuthSettingsMicrosoft',
    'AppServiceAuthSettingsTwitter',
    'AppServiceBackup',
    'AppServiceBackupSchedule',
    'AppServiceConnectionString',
    'AppServiceIdentity',
    'AppServiceLogs',
    'AppServiceLogsApplicationLogs',
    'AppServiceLogsApplicationLogsAzureBlobStorage',
    'AppServiceLogsHttpLogs',
    'AppServiceLogsHttpLogsAzureBlobStorage',
    'AppServiceLogsHttpLogsFileSystem',
    'AppServiceSiteConfig',
    'AppServiceSiteConfigCors',
    'AppServiceSiteConfigIpRestriction',
    'AppServiceSiteConfigIpRestrictionHeaders',
    'AppServiceSiteConfigScmIpRestriction',
    'AppServiceSiteConfigScmIpRestrictionHeaders',
    'AppServiceSiteCredential',
    'AppServiceSourceControl',
    'AppServiceStorageAccount',
    'CertificateOrderCertificate',
    'ConnectionAuthentication',
    'EnvironmentClusterSetting',
    'EnvironmentV3ClusterSetting',
    'EnvironmentV3InboundNetworkDependency',
    'FunctionAppAuthSettings',
    'FunctionAppAuthSettingsActiveDirectory',
    'FunctionAppAuthSettingsFacebook',
    'FunctionAppAuthSettingsGoogle',
    'FunctionAppAuthSettingsMicrosoft',
    'FunctionAppAuthSettingsTwitter',
    'FunctionAppConnectionString',
    'FunctionAppFunctionFile',
    'FunctionAppIdentity',
    'FunctionAppSiteConfig',
    'FunctionAppSiteConfigCors',
    'FunctionAppSiteConfigIpRestriction',
    'FunctionAppSiteConfigIpRestrictionHeaders',
    'FunctionAppSiteConfigScmIpRestriction',
    'FunctionAppSiteConfigScmIpRestrictionHeaders',
    'FunctionAppSiteCredential',
    'FunctionAppSlotAuthSettings',
    'FunctionAppSlotAuthSettingsActiveDirectory',
    'FunctionAppSlotAuthSettingsFacebook',
    'FunctionAppSlotAuthSettingsGoogle',
    'FunctionAppSlotAuthSettingsMicrosoft',
    'FunctionAppSlotAuthSettingsTwitter',
    'FunctionAppSlotConnectionString',
    'FunctionAppSlotIdentity',
    'FunctionAppSlotSiteConfig',
    'FunctionAppSlotSiteConfigCors',
    'FunctionAppSlotSiteConfigIpRestriction',
    'FunctionAppSlotSiteConfigIpRestrictionHeaders',
    'FunctionAppSlotSiteConfigScmIpRestriction',
    'FunctionAppSlotSiteConfigScmIpRestrictionHeaders',
    'FunctionAppSlotSiteCredential',
    'FunctionAppSourceControl',
    'LinuxFunctionAppAuthSettings',
    'LinuxFunctionAppAuthSettingsActiveDirectory',
    'LinuxFunctionAppAuthSettingsFacebook',
    'LinuxFunctionAppAuthSettingsGithub',
    'LinuxFunctionAppAuthSettingsGoogle',
    'LinuxFunctionAppAuthSettingsMicrosoft',
    'LinuxFunctionAppAuthSettingsTwitter',
    'LinuxFunctionAppBackup',
    'LinuxFunctionAppBackupSchedule',
    'LinuxFunctionAppConnectionString',
    'LinuxFunctionAppIdentity',
    'LinuxFunctionAppSiteConfig',
    'LinuxFunctionAppSiteConfigAppServiceLogs',
    'LinuxFunctionAppSiteConfigApplicationStack',
    'LinuxFunctionAppSiteConfigApplicationStackDocker',
    'LinuxFunctionAppSiteConfigCors',
    'LinuxFunctionAppSiteConfigIpRestriction',
    'LinuxFunctionAppSiteConfigIpRestrictionHeaders',
    'LinuxFunctionAppSiteConfigScmIpRestriction',
    'LinuxFunctionAppSiteConfigScmIpRestrictionHeaders',
    'LinuxFunctionAppSiteCredential',
    'LinuxFunctionAppSlotAuthSettings',
    'LinuxFunctionAppSlotAuthSettingsActiveDirectory',
    'LinuxFunctionAppSlotAuthSettingsFacebook',
    'LinuxFunctionAppSlotAuthSettingsGithub',
    'LinuxFunctionAppSlotAuthSettingsGoogle',
    'LinuxFunctionAppSlotAuthSettingsMicrosoft',
    'LinuxFunctionAppSlotAuthSettingsTwitter',
    'LinuxFunctionAppSlotBackup',
    'LinuxFunctionAppSlotBackupSchedule',
    'LinuxFunctionAppSlotConnectionString',
    'LinuxFunctionAppSlotIdentity',
    'LinuxFunctionAppSlotSiteConfig',
    'LinuxFunctionAppSlotSiteConfigAppServiceLogs',
    'LinuxFunctionAppSlotSiteConfigApplicationStack',
    'LinuxFunctionAppSlotSiteConfigApplicationStackDocker',
    'LinuxFunctionAppSlotSiteConfigCors',
    'LinuxFunctionAppSlotSiteConfigIpRestriction',
    'LinuxFunctionAppSlotSiteConfigIpRestrictionHeaders',
    'LinuxFunctionAppSlotSiteConfigScmIpRestriction',
    'LinuxFunctionAppSlotSiteConfigScmIpRestrictionHeaders',
    'LinuxFunctionAppSlotSiteCredential',
    'LinuxFunctionAppSlotStorageAccount',
    'LinuxFunctionAppStickySettings',
    'LinuxFunctionAppStorageAccount',
    'LinuxWebAppAuthSettings',
    'LinuxWebAppAuthSettingsActiveDirectory',
    'LinuxWebAppAuthSettingsFacebook',
    'LinuxWebAppAuthSettingsGithub',
    'LinuxWebAppAuthSettingsGoogle',
    'LinuxWebAppAuthSettingsMicrosoft',
    'LinuxWebAppAuthSettingsTwitter',
    'LinuxWebAppBackup',
    'LinuxWebAppBackupSchedule',
    'LinuxWebAppConnectionString',
    'LinuxWebAppIdentity',
    'LinuxWebAppLogs',
    'LinuxWebAppLogsApplicationLogs',
    'LinuxWebAppLogsApplicationLogsAzureBlobStorage',
    'LinuxWebAppLogsHttpLogs',
    'LinuxWebAppLogsHttpLogsAzureBlobStorage',
    'LinuxWebAppLogsHttpLogsFileSystem',
    'LinuxWebAppSiteConfig',
    'LinuxWebAppSiteConfigApplicationStack',
    'LinuxWebAppSiteConfigAutoHealSetting',
    'LinuxWebAppSiteConfigAutoHealSettingAction',
    'LinuxWebAppSiteConfigAutoHealSettingTrigger',
    'LinuxWebAppSiteConfigAutoHealSettingTriggerRequests',
    'LinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequest',
    'LinuxWebAppSiteConfigAutoHealSettingTriggerStatusCode',
    'LinuxWebAppSiteConfigCors',
    'LinuxWebAppSiteConfigIpRestriction',
    'LinuxWebAppSiteConfigIpRestrictionHeaders',
    'LinuxWebAppSiteConfigScmIpRestriction',
    'LinuxWebAppSiteConfigScmIpRestrictionHeaders',
    'LinuxWebAppSiteCredential',
    'LinuxWebAppSlotAuthSettings',
    'LinuxWebAppSlotAuthSettingsActiveDirectory',
    'LinuxWebAppSlotAuthSettingsFacebook',
    'LinuxWebAppSlotAuthSettingsGithub',
    'LinuxWebAppSlotAuthSettingsGoogle',
    'LinuxWebAppSlotAuthSettingsMicrosoft',
    'LinuxWebAppSlotAuthSettingsTwitter',
    'LinuxWebAppSlotBackup',
    'LinuxWebAppSlotBackupSchedule',
    'LinuxWebAppSlotConnectionString',
    'LinuxWebAppSlotIdentity',
    'LinuxWebAppSlotLogs',
    'LinuxWebAppSlotLogsApplicationLogs',
    'LinuxWebAppSlotLogsApplicationLogsAzureBlobStorage',
    'LinuxWebAppSlotLogsHttpLogs',
    'LinuxWebAppSlotLogsHttpLogsAzureBlobStorage',
    'LinuxWebAppSlotLogsHttpLogsFileSystem',
    'LinuxWebAppSlotSiteConfig',
    'LinuxWebAppSlotSiteConfigApplicationStack',
    'LinuxWebAppSlotSiteConfigAutoHealSetting',
    'LinuxWebAppSlotSiteConfigAutoHealSettingAction',
    'LinuxWebAppSlotSiteConfigAutoHealSettingTrigger',
    'LinuxWebAppSlotSiteConfigAutoHealSettingTriggerRequests',
    'LinuxWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequest',
    'LinuxWebAppSlotSiteConfigAutoHealSettingTriggerStatusCode',
    'LinuxWebAppSlotSiteConfigCors',
    'LinuxWebAppSlotSiteConfigIpRestriction',
    'LinuxWebAppSlotSiteConfigIpRestrictionHeaders',
    'LinuxWebAppSlotSiteConfigScmIpRestriction',
    'LinuxWebAppSlotSiteConfigScmIpRestrictionHeaders',
    'LinuxWebAppSlotSiteCredential',
    'LinuxWebAppSlotStorageAccount',
    'LinuxWebAppStickySettings',
    'LinuxWebAppStorageAccount',
    'PlanSku',
    'SlotAuthSettings',
    'SlotAuthSettingsActiveDirectory',
    'SlotAuthSettingsFacebook',
    'SlotAuthSettingsGoogle',
    'SlotAuthSettingsMicrosoft',
    'SlotAuthSettingsTwitter',
    'SlotConnectionString',
    'SlotIdentity',
    'SlotLogs',
    'SlotLogsApplicationLogs',
    'SlotLogsApplicationLogsAzureBlobStorage',
    'SlotLogsHttpLogs',
    'SlotLogsHttpLogsAzureBlobStorage',
    'SlotLogsHttpLogsFileSystem',
    'SlotSiteConfig',
    'SlotSiteConfigCors',
    'SlotSiteConfigIpRestriction',
    'SlotSiteConfigIpRestrictionHeaders',
    'SlotSiteConfigScmIpRestriction',
    'SlotSiteConfigScmIpRestrictionHeaders',
    'SlotSiteCredential',
    'SlotStorageAccount',
    'SourceControlGithubActionConfiguration',
    'SourceControlGithubActionConfigurationCodeConfiguration',
    'SourceControlGithubActionConfigurationContainerConfiguration',
    'SourceControlSlotGithubActionConfiguration',
    'SourceControlSlotGithubActionConfigurationCodeConfiguration',
    'SourceControlSlotGithubActionConfigurationContainerConfiguration',
    'StaticSiteIdentity',
    'WindowsFunctionAppAuthSettings',
    'WindowsFunctionAppAuthSettingsActiveDirectory',
    'WindowsFunctionAppAuthSettingsFacebook',
    'WindowsFunctionAppAuthSettingsGithub',
    'WindowsFunctionAppAuthSettingsGoogle',
    'WindowsFunctionAppAuthSettingsMicrosoft',
    'WindowsFunctionAppAuthSettingsTwitter',
    'WindowsFunctionAppBackup',
    'WindowsFunctionAppBackupSchedule',
    'WindowsFunctionAppConnectionString',
    'WindowsFunctionAppIdentity',
    'WindowsFunctionAppSiteConfig',
    'WindowsFunctionAppSiteConfigAppServiceLogs',
    'WindowsFunctionAppSiteConfigApplicationStack',
    'WindowsFunctionAppSiteConfigCors',
    'WindowsFunctionAppSiteConfigIpRestriction',
    'WindowsFunctionAppSiteConfigIpRestrictionHeaders',
    'WindowsFunctionAppSiteConfigScmIpRestriction',
    'WindowsFunctionAppSiteConfigScmIpRestrictionHeaders',
    'WindowsFunctionAppSiteCredential',
    'WindowsFunctionAppSlotAuthSettings',
    'WindowsFunctionAppSlotAuthSettingsActiveDirectory',
    'WindowsFunctionAppSlotAuthSettingsFacebook',
    'WindowsFunctionAppSlotAuthSettingsGithub',
    'WindowsFunctionAppSlotAuthSettingsGoogle',
    'WindowsFunctionAppSlotAuthSettingsMicrosoft',
    'WindowsFunctionAppSlotAuthSettingsTwitter',
    'WindowsFunctionAppSlotBackup',
    'WindowsFunctionAppSlotBackupSchedule',
    'WindowsFunctionAppSlotConnectionString',
    'WindowsFunctionAppSlotIdentity',
    'WindowsFunctionAppSlotSiteConfig',
    'WindowsFunctionAppSlotSiteConfigAppServiceLogs',
    'WindowsFunctionAppSlotSiteConfigApplicationStack',
    'WindowsFunctionAppSlotSiteConfigCors',
    'WindowsFunctionAppSlotSiteConfigIpRestriction',
    'WindowsFunctionAppSlotSiteConfigIpRestrictionHeaders',
    'WindowsFunctionAppSlotSiteConfigScmIpRestriction',
    'WindowsFunctionAppSlotSiteConfigScmIpRestrictionHeaders',
    'WindowsFunctionAppSlotSiteCredential',
    'WindowsFunctionAppSlotStorageAccount',
    'WindowsFunctionAppStickySettings',
    'WindowsFunctionAppStorageAccount',
    'WindowsWebAppAuthSettings',
    'WindowsWebAppAuthSettingsActiveDirectory',
    'WindowsWebAppAuthSettingsFacebook',
    'WindowsWebAppAuthSettingsGithub',
    'WindowsWebAppAuthSettingsGoogle',
    'WindowsWebAppAuthSettingsMicrosoft',
    'WindowsWebAppAuthSettingsTwitter',
    'WindowsWebAppBackup',
    'WindowsWebAppBackupSchedule',
    'WindowsWebAppConnectionString',
    'WindowsWebAppIdentity',
    'WindowsWebAppLogs',
    'WindowsWebAppLogsApplicationLogs',
    'WindowsWebAppLogsApplicationLogsAzureBlobStorage',
    'WindowsWebAppLogsHttpLogs',
    'WindowsWebAppLogsHttpLogsAzureBlobStorage',
    'WindowsWebAppLogsHttpLogsFileSystem',
    'WindowsWebAppSiteConfig',
    'WindowsWebAppSiteConfigApplicationStack',
    'WindowsWebAppSiteConfigAutoHealSetting',
    'WindowsWebAppSiteConfigAutoHealSettingAction',
    'WindowsWebAppSiteConfigAutoHealSettingActionCustomAction',
    'WindowsWebAppSiteConfigAutoHealSettingTrigger',
    'WindowsWebAppSiteConfigAutoHealSettingTriggerRequests',
    'WindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequest',
    'WindowsWebAppSiteConfigAutoHealSettingTriggerStatusCode',
    'WindowsWebAppSiteConfigCors',
    'WindowsWebAppSiteConfigIpRestriction',
    'WindowsWebAppSiteConfigIpRestrictionHeaders',
    'WindowsWebAppSiteConfigScmIpRestriction',
    'WindowsWebAppSiteConfigScmIpRestrictionHeaders',
    'WindowsWebAppSiteConfigVirtualApplication',
    'WindowsWebAppSiteConfigVirtualApplicationVirtualDirectory',
    'WindowsWebAppSiteCredential',
    'WindowsWebAppSlotAuthSettings',
    'WindowsWebAppSlotAuthSettingsActiveDirectory',
    'WindowsWebAppSlotAuthSettingsFacebook',
    'WindowsWebAppSlotAuthSettingsGithub',
    'WindowsWebAppSlotAuthSettingsGoogle',
    'WindowsWebAppSlotAuthSettingsMicrosoft',
    'WindowsWebAppSlotAuthSettingsTwitter',
    'WindowsWebAppSlotBackup',
    'WindowsWebAppSlotBackupSchedule',
    'WindowsWebAppSlotConnectionString',
    'WindowsWebAppSlotIdentity',
    'WindowsWebAppSlotLogs',
    'WindowsWebAppSlotLogsApplicationLogs',
    'WindowsWebAppSlotLogsApplicationLogsAzureBlobStorage',
    'WindowsWebAppSlotLogsHttpLogs',
    'WindowsWebAppSlotLogsHttpLogsAzureBlobStorage',
    'WindowsWebAppSlotLogsHttpLogsFileSystem',
    'WindowsWebAppSlotSiteConfig',
    'WindowsWebAppSlotSiteConfigApplicationStack',
    'WindowsWebAppSlotSiteConfigAutoHealSetting',
    'WindowsWebAppSlotSiteConfigAutoHealSettingAction',
    'WindowsWebAppSlotSiteConfigAutoHealSettingActionCustomAction',
    'WindowsWebAppSlotSiteConfigAutoHealSettingTrigger',
    'WindowsWebAppSlotSiteConfigAutoHealSettingTriggerRequests',
    'WindowsWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequest',
    'WindowsWebAppSlotSiteConfigAutoHealSettingTriggerStatusCode',
    'WindowsWebAppSlotSiteConfigCors',
    'WindowsWebAppSlotSiteConfigIpRestriction',
    'WindowsWebAppSlotSiteConfigIpRestrictionHeaders',
    'WindowsWebAppSlotSiteConfigScmIpRestriction',
    'WindowsWebAppSlotSiteConfigScmIpRestrictionHeaders',
    'WindowsWebAppSlotSiteConfigVirtualApplication',
    'WindowsWebAppSlotSiteConfigVirtualApplicationVirtualDirectory',
    'WindowsWebAppSlotSiteCredential',
    'WindowsWebAppSlotStorageAccount',
    'WindowsWebAppStickySettings',
    'WindowsWebAppStorageAccount',
    'GetAppServiceConnectionStringResult',
    'GetAppServiceEnvironmentClusterSettingResult',
    'GetAppServicePlanSkuResult',
    'GetAppServiceSiteConfigResult',
    'GetAppServiceSiteConfigCorResult',
    'GetAppServiceSiteConfigIpRestrictionResult',
    'GetAppServiceSiteConfigIpRestrictionHeadersResult',
    'GetAppServiceSiteConfigScmIpRestrictionResult',
    'GetAppServiceSiteConfigScmIpRestrictionHeadersResult',
    'GetAppServiceSiteCredentialResult',
    'GetAppServiceSourceControlResult',
    'GetCertificateOrderCertificateResult',
    'GetEnvironmentV3ClusterSettingResult',
    'GetEnvironmentV3InboundNetworkDependencyResult',
    'GetFunctionAppConnectionStringResult',
    'GetFunctionAppIdentityResult',
    'GetFunctionAppSiteConfigResult',
    'GetFunctionAppSiteConfigCorsResult',
    'GetFunctionAppSiteConfigIpRestrictionResult',
    'GetFunctionAppSiteConfigIpRestrictionHeadersResult',
    'GetFunctionAppSiteConfigScmIpRestrictionResult',
    'GetFunctionAppSiteConfigScmIpRestrictionHeadersResult',
    'GetFunctionAppSiteCredentialResult',
    'GetFunctionAppSourceControlResult',
    'GetLinuxFunctionAppAuthSettingResult',
    'GetLinuxFunctionAppAuthSettingActiveDirectoryResult',
    'GetLinuxFunctionAppAuthSettingFacebookResult',
    'GetLinuxFunctionAppAuthSettingGithubResult',
    'GetLinuxFunctionAppAuthSettingGoogleResult',
    'GetLinuxFunctionAppAuthSettingMicrosoftResult',
    'GetLinuxFunctionAppAuthSettingTwitterResult',
    'GetLinuxFunctionAppBackupResult',
    'GetLinuxFunctionAppBackupScheduleResult',
    'GetLinuxFunctionAppConnectionStringResult',
    'GetLinuxFunctionAppIdentityResult',
    'GetLinuxFunctionAppSiteConfigResult',
    'GetLinuxFunctionAppSiteConfigAppServiceLogResult',
    'GetLinuxFunctionAppSiteConfigApplicationStackResult',
    'GetLinuxFunctionAppSiteConfigApplicationStackDockerResult',
    'GetLinuxFunctionAppSiteConfigCorResult',
    'GetLinuxFunctionAppSiteConfigIpRestrictionResult',
    'GetLinuxFunctionAppSiteConfigIpRestrictionHeaderResult',
    'GetLinuxFunctionAppSiteConfigScmIpRestrictionResult',
    'GetLinuxFunctionAppSiteConfigScmIpRestrictionHeaderResult',
    'GetLinuxFunctionAppSiteCredentialResult',
    'GetLinuxFunctionAppStickySettingResult',
    'GetLinuxWebAppAuthSettingResult',
    'GetLinuxWebAppAuthSettingActiveDirectoryResult',
    'GetLinuxWebAppAuthSettingFacebookResult',
    'GetLinuxWebAppAuthSettingGithubResult',
    'GetLinuxWebAppAuthSettingGoogleResult',
    'GetLinuxWebAppAuthSettingMicrosoftResult',
    'GetLinuxWebAppAuthSettingTwitterResult',
    'GetLinuxWebAppBackupResult',
    'GetLinuxWebAppBackupScheduleResult',
    'GetLinuxWebAppConnectionStringResult',
    'GetLinuxWebAppIdentityResult',
    'GetLinuxWebAppLogResult',
    'GetLinuxWebAppLogApplicationLogResult',
    'GetLinuxWebAppLogApplicationLogAzureBlobStorageResult',
    'GetLinuxWebAppLogHttpLogResult',
    'GetLinuxWebAppLogHttpLogAzureBlobStorageResult',
    'GetLinuxWebAppLogHttpLogFileSystemResult',
    'GetLinuxWebAppSiteConfigResult',
    'GetLinuxWebAppSiteConfigApplicationStackResult',
    'GetLinuxWebAppSiteConfigAutoHealSettingResult',
    'GetLinuxWebAppSiteConfigAutoHealSettingActionResult',
    'GetLinuxWebAppSiteConfigAutoHealSettingTriggerResult',
    'GetLinuxWebAppSiteConfigAutoHealSettingTriggerRequestResult',
    'GetLinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequestResult',
    'GetLinuxWebAppSiteConfigAutoHealSettingTriggerStatusCodeResult',
    'GetLinuxWebAppSiteConfigCorResult',
    'GetLinuxWebAppSiteConfigIpRestrictionResult',
    'GetLinuxWebAppSiteConfigIpRestrictionHeaderResult',
    'GetLinuxWebAppSiteConfigScmIpRestrictionResult',
    'GetLinuxWebAppSiteConfigScmIpRestrictionHeaderResult',
    'GetLinuxWebAppSiteCredentialResult',
    'GetLinuxWebAppStickySettingResult',
    'GetLinuxWebAppStorageAccountResult',
    'GetWindowsFunctionAppAuthSettingResult',
    'GetWindowsFunctionAppAuthSettingActiveDirectoryResult',
    'GetWindowsFunctionAppAuthSettingFacebookResult',
    'GetWindowsFunctionAppAuthSettingGithubResult',
    'GetWindowsFunctionAppAuthSettingGoogleResult',
    'GetWindowsFunctionAppAuthSettingMicrosoftResult',
    'GetWindowsFunctionAppAuthSettingTwitterResult',
    'GetWindowsFunctionAppBackupResult',
    'GetWindowsFunctionAppBackupScheduleResult',
    'GetWindowsFunctionAppConnectionStringResult',
    'GetWindowsFunctionAppIdentityResult',
    'GetWindowsFunctionAppSiteConfigResult',
    'GetWindowsFunctionAppSiteConfigAppServiceLogResult',
    'GetWindowsFunctionAppSiteConfigApplicationStackResult',
    'GetWindowsFunctionAppSiteConfigCorResult',
    'GetWindowsFunctionAppSiteConfigIpRestrictionResult',
    'GetWindowsFunctionAppSiteConfigIpRestrictionHeaderResult',
    'GetWindowsFunctionAppSiteConfigScmIpRestrictionResult',
    'GetWindowsFunctionAppSiteConfigScmIpRestrictionHeaderResult',
    'GetWindowsFunctionAppSiteCredentialResult',
    'GetWindowsFunctionAppStickySettingResult',
    'GetWindowsWebAppAuthSettingResult',
    'GetWindowsWebAppAuthSettingActiveDirectoryResult',
    'GetWindowsWebAppAuthSettingFacebookResult',
    'GetWindowsWebAppAuthSettingGithubResult',
    'GetWindowsWebAppAuthSettingGoogleResult',
    'GetWindowsWebAppAuthSettingMicrosoftResult',
    'GetWindowsWebAppAuthSettingTwitterResult',
    'GetWindowsWebAppBackupResult',
    'GetWindowsWebAppBackupScheduleResult',
    'GetWindowsWebAppConnectionStringResult',
    'GetWindowsWebAppIdentityResult',
    'GetWindowsWebAppLogResult',
    'GetWindowsWebAppLogApplicationLogResult',
    'GetWindowsWebAppLogApplicationLogAzureBlobStorageResult',
    'GetWindowsWebAppLogHttpLogResult',
    'GetWindowsWebAppLogHttpLogAzureBlobStorageResult',
    'GetWindowsWebAppLogHttpLogFileSystemResult',
    'GetWindowsWebAppSiteConfigResult',
    'GetWindowsWebAppSiteConfigApplicationStackResult',
    'GetWindowsWebAppSiteConfigAutoHealSettingResult',
    'GetWindowsWebAppSiteConfigAutoHealSettingActionResult',
    'GetWindowsWebAppSiteConfigAutoHealSettingActionCustomActionResult',
    'GetWindowsWebAppSiteConfigAutoHealSettingTriggerResult',
    'GetWindowsWebAppSiteConfigAutoHealSettingTriggerRequestResult',
    'GetWindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequestResult',
    'GetWindowsWebAppSiteConfigAutoHealSettingTriggerStatusCodeResult',
    'GetWindowsWebAppSiteConfigCorResult',
    'GetWindowsWebAppSiteConfigIpRestrictionResult',
    'GetWindowsWebAppSiteConfigIpRestrictionHeaderResult',
    'GetWindowsWebAppSiteConfigScmIpRestrictionResult',
    'GetWindowsWebAppSiteConfigScmIpRestrictionHeaderResult',
    'GetWindowsWebAppSiteConfigVirtualApplicationResult',
    'GetWindowsWebAppSiteConfigVirtualApplicationVirtualDirectoryResult',
    'GetWindowsWebAppSiteCredentialResult',
    'GetWindowsWebAppStickySettingResult',
    'GetWindowsWebAppStorageAccountResult',
]

@pulumi.output_type
class AppServiceAuthSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeDirectory":
            suggest = "active_directory"
        elif key == "additionalLoginParams":
            suggest = "additional_login_params"
        elif key == "allowedExternalRedirectUrls":
            suggest = "allowed_external_redirect_urls"
        elif key == "defaultProvider":
            suggest = "default_provider"
        elif key == "runtimeVersion":
            suggest = "runtime_version"
        elif key == "tokenRefreshExtensionHours":
            suggest = "token_refresh_extension_hours"
        elif key == "tokenStoreEnabled":
            suggest = "token_store_enabled"
        elif key == "unauthenticatedClientAction":
            suggest = "unauthenticated_client_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceAuthSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceAuthSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceAuthSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 active_directory: Optional['outputs.AppServiceAuthSettingsActiveDirectory'] = None,
                 additional_login_params: Optional[Mapping[str, str]] = None,
                 allowed_external_redirect_urls: Optional[Sequence[str]] = None,
                 default_provider: Optional[str] = None,
                 facebook: Optional['outputs.AppServiceAuthSettingsFacebook'] = None,
                 google: Optional['outputs.AppServiceAuthSettingsGoogle'] = None,
                 issuer: Optional[str] = None,
                 microsoft: Optional['outputs.AppServiceAuthSettingsMicrosoft'] = None,
                 runtime_version: Optional[str] = None,
                 token_refresh_extension_hours: Optional[float] = None,
                 token_store_enabled: Optional[bool] = None,
                 twitter: Optional['outputs.AppServiceAuthSettingsTwitter'] = None,
                 unauthenticated_client_action: Optional[str] = None):
        """
        :param bool enabled: Is Authentication enabled?
        :param 'AppServiceAuthSettingsActiveDirectoryArgs' active_directory: A `active_directory` block as defined below.
        :param Mapping[str, str] additional_login_params: Login parameters to send to the OpenID Connect authorization endpoint when a user logs in. Each parameter must be in the form "key=value".
        :param Sequence[str] allowed_external_redirect_urls: External URLs that can be redirected to as part of logging in or logging out of the app.
        :param str default_provider: The default provider to use when multiple providers have been set up. Possible values are `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount` and `Twitter`.
        :param 'AppServiceAuthSettingsFacebookArgs' facebook: A `facebook` block as defined below.
        :param 'AppServiceAuthSettingsGoogleArgs' google: A `google` block as defined below.
        :param str issuer: Issuer URI. When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        :param 'AppServiceAuthSettingsMicrosoftArgs' microsoft: A `microsoft` block as defined below.
        :param str runtime_version: The runtime version of the Authentication/Authorization module.
        :param float token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to 72.
        :param bool token_store_enabled: If enabled the module will durably store platform-specific security tokens that are obtained during login flows. Defaults to false.
        :param 'AppServiceAuthSettingsTwitterArgs' twitter: A `twitter` block as defined below.
        :param str unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app. Possible values are `AllowAnonymous` and `RedirectToLoginPage`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if active_directory is not None:
            pulumi.set(__self__, "active_directory", active_directory)
        if additional_login_params is not None:
            pulumi.set(__self__, "additional_login_params", additional_login_params)
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if facebook is not None:
            pulumi.set(__self__, "facebook", facebook)
        if google is not None:
            pulumi.set(__self__, "google", google)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if microsoft is not None:
            pulumi.set(__self__, "microsoft", microsoft)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if token_refresh_extension_hours is not None:
            pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if twitter is not None:
            pulumi.set(__self__, "twitter", twitter)
        if unauthenticated_client_action is not None:
            pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is Authentication enabled?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="activeDirectory")
    def active_directory(self) -> Optional['outputs.AppServiceAuthSettingsActiveDirectory']:
        """
        A `active_directory` block as defined below.
        """
        return pulumi.get(self, "active_directory")

    @property
    @pulumi.getter(name="additionalLoginParams")
    def additional_login_params(self) -> Optional[Mapping[str, str]]:
        """
        Login parameters to send to the OpenID Connect authorization endpoint when a user logs in. Each parameter must be in the form "key=value".
        """
        return pulumi.get(self, "additional_login_params")

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[Sequence[str]]:
        """
        External URLs that can be redirected to as part of logging in or logging out of the app.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[str]:
        """
        The default provider to use when multiple providers have been set up. Possible values are `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount` and `Twitter`.
        """
        return pulumi.get(self, "default_provider")

    @property
    @pulumi.getter
    def facebook(self) -> Optional['outputs.AppServiceAuthSettingsFacebook']:
        """
        A `facebook` block as defined below.
        """
        return pulumi.get(self, "facebook")

    @property
    @pulumi.getter
    def google(self) -> Optional['outputs.AppServiceAuthSettingsGoogle']:
        """
        A `google` block as defined below.
        """
        return pulumi.get(self, "google")

    @property
    @pulumi.getter
    def issuer(self) -> Optional[str]:
        """
        Issuer URI. When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def microsoft(self) -> Optional['outputs.AppServiceAuthSettingsMicrosoft']:
        """
        A `microsoft` block as defined below.
        """
        return pulumi.get(self, "microsoft")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[str]:
        """
        The runtime version of the Authentication/Authorization module.
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> Optional[float]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to 72.
        """
        return pulumi.get(self, "token_refresh_extension_hours")

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[bool]:
        """
        If enabled the module will durably store platform-specific security tokens that are obtained during login flows. Defaults to false.
        """
        return pulumi.get(self, "token_store_enabled")

    @property
    @pulumi.getter
    def twitter(self) -> Optional['outputs.AppServiceAuthSettingsTwitter']:
        """
        A `twitter` block as defined below.
        """
        return pulumi.get(self, "twitter")

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> Optional[str]:
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values are `AllowAnonymous` and `RedirectToLoginPage`.
        """
        return pulumi.get(self, "unauthenticated_client_action")


@pulumi.output_type
class AppServiceAuthSettingsActiveDirectory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "clientSecret":
            suggest = "client_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceAuthSettingsActiveDirectory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceAuthSettingsActiveDirectory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceAuthSettingsActiveDirectory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 client_secret: Optional[str] = None):
        """
        :param str client_id: The Client ID of this relying party application. Enables OpenIDConnection authentication with Azure Active Directory.
        :param Sequence[str] allowed_audiences: Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
        :param str client_secret: The Client Secret of this relying party application. If no secret is provided, implicit flow will be used.
        """
        pulumi.set(__self__, "client_id", client_id)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The Client ID of this relying party application. Enables OpenIDConnection authentication with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret of this relying party application. If no secret is provided, implicit flow will be used.
        """
        return pulumi.get(self, "client_secret")


@pulumi.output_type
class AppServiceAuthSettingsFacebook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "appSecret":
            suggest = "app_secret"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceAuthSettingsFacebook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceAuthSettingsFacebook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceAuthSettingsFacebook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: str,
                 app_secret: str,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str app_id: The App ID of the Facebook app used for login
        :param str app_secret: The App Secret of the Facebook app used for Facebook login.
        :param Sequence[str] oauth_scopes: The OAuth 2.0 scopes that will be requested as part of Facebook login authentication. <https://developers.facebook.com/docs/facebook-login>
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "app_secret", app_secret)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        The App ID of the Facebook app used for login
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appSecret")
    def app_secret(self) -> str:
        """
        The App Secret of the Facebook app used for Facebook login.
        """
        return pulumi.get(self, "app_secret")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        The OAuth 2.0 scopes that will be requested as part of Facebook login authentication. <https://developers.facebook.com/docs/facebook-login>
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class AppServiceAuthSettingsGoogle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceAuthSettingsGoogle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceAuthSettingsGoogle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceAuthSettingsGoogle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OpenID Connect Client ID for the Google web application.
        :param str client_secret: The client secret associated with the Google web application.
        :param Sequence[str] oauth_scopes: The OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. <https://developers.google.com/identity/sign-in/web/>
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OpenID Connect Client ID for the Google web application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The client secret associated with the Google web application.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        The OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. <https://developers.google.com/identity/sign-in/web/>
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class AppServiceAuthSettingsMicrosoft(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceAuthSettingsMicrosoft. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceAuthSettingsMicrosoft.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceAuthSettingsMicrosoft.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret: The OAuth 2.0 client secret that was created for the app used for authentication.
        :param Sequence[str] oauth_scopes: The OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. <https://msdn.microsoft.com/en-us/library/dn631845.aspx>
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        The OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. <https://msdn.microsoft.com/en-us/library/dn631845.aspx>
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class AppServiceAuthSettingsTwitter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerKey":
            suggest = "consumer_key"
        elif key == "consumerSecret":
            suggest = "consumer_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceAuthSettingsTwitter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceAuthSettingsTwitter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceAuthSettingsTwitter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_key: str,
                 consumer_secret: str):
        pulumi.set(__self__, "consumer_key", consumer_key)
        pulumi.set(__self__, "consumer_secret", consumer_secret)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> str:
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> str:
        return pulumi.get(self, "consumer_secret")


@pulumi.output_type
class AppServiceBackup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageAccountUrl":
            suggest = "storage_account_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceBackup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceBackup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceBackup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 schedule: 'outputs.AppServiceBackupSchedule',
                 storage_account_url: str,
                 enabled: Optional[bool] = None):
        """
        :param str name: Specifies the name for this Backup.
        :param 'AppServiceBackupScheduleArgs' schedule: A `schedule` block as defined below.
        :param str storage_account_url: The SAS URL to a Storage Container where Backups should be saved.
        :param bool enabled: Is this Backup enabled?
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "storage_account_url", storage_account_url)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name for this Backup.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def schedule(self) -> 'outputs.AppServiceBackupSchedule':
        """
        A `schedule` block as defined below.
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter(name="storageAccountUrl")
    def storage_account_url(self) -> str:
        """
        The SAS URL to a Storage Container where Backups should be saved.
        """
        return pulumi.get(self, "storage_account_url")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Is this Backup enabled?
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class AppServiceBackupSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "frequencyUnit":
            suggest = "frequency_unit"
        elif key == "keepAtLeastOneBackup":
            suggest = "keep_at_least_one_backup"
        elif key == "retentionPeriodInDays":
            suggest = "retention_period_in_days"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceBackupSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceBackupSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceBackupSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_unit: str,
                 keep_at_least_one_backup: Optional[bool] = None,
                 retention_period_in_days: Optional[int] = None,
                 start_time: Optional[str] = None):
        """
        :param int frequency_interval: Sets how often the backup should be executed.
        :param str frequency_unit: Sets the unit of time for how often the backup should be executed. Possible values are `Day` or `Hour`.
        :param bool keep_at_least_one_backup: Should at least one backup always be kept in the Storage Account by the Retention Policy, regardless of how old it is?
        :param int retention_period_in_days: Specifies the number of days after which Backups should be deleted.
        :param str start_time: Sets when the schedule should start working.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_unit", frequency_unit)
        if keep_at_least_one_backup is not None:
            pulumi.set(__self__, "keep_at_least_one_backup", keep_at_least_one_backup)
        if retention_period_in_days is not None:
            pulumi.set(__self__, "retention_period_in_days", retention_period_in_days)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Sets how often the backup should be executed.
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyUnit")
    def frequency_unit(self) -> str:
        """
        Sets the unit of time for how often the backup should be executed. Possible values are `Day` or `Hour`.
        """
        return pulumi.get(self, "frequency_unit")

    @property
    @pulumi.getter(name="keepAtLeastOneBackup")
    def keep_at_least_one_backup(self) -> Optional[bool]:
        """
        Should at least one backup always be kept in the Storage Account by the Retention Policy, regardless of how old it is?
        """
        return pulumi.get(self, "keep_at_least_one_backup")

    @property
    @pulumi.getter(name="retentionPeriodInDays")
    def retention_period_in_days(self) -> Optional[int]:
        """
        Specifies the number of days after which Backups should be deleted.
        """
        return pulumi.get(self, "retention_period_in_days")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        """
        Sets when the schedule should start working.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class AppServiceConnectionString(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: The name of the Connection String.
        :param str type: The type of the Connection String. Possible values are `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure` and  `SQLServer`.
        :param str value: The value for the Connection String.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Connection String.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the Connection String. Possible values are `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure` and  `SQLServer`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the Connection String.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AppServiceIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 identity_ids: Optional[Sequence[str]] = None,
                 principal_id: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str type: Specifies the identity type of the App Service. Possible values are `SystemAssigned` (where Azure will generate a Service Principal for you), `UserAssigned` where you can specify the Service Principal IDs in the `identity_ids` field, and `SystemAssigned, UserAssigned` which assigns both a system managed identity as well as the specified user assigned identities.
        :param Sequence[str] identity_ids: Specifies a list of user managed identity ids to be assigned. Required if `type` is `UserAssigned`.
        :param str principal_id: The Principal ID for the Service Principal associated with the Managed Service Identity of this App Service.
        :param str tenant_id: The Tenant ID for the Service Principal associated with the Managed Service Identity of this App Service.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the identity type of the App Service. Possible values are `SystemAssigned` (where Azure will generate a Service Principal for you), `UserAssigned` where you can specify the Service Principal IDs in the `identity_ids` field, and `SystemAssigned, UserAssigned` which assigns both a system managed identity as well as the specified user assigned identities.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of user managed identity ids to be assigned. Required if `type` is `UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        """
        The Principal ID for the Service Principal associated with the Managed Service Identity of this App Service.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The Tenant ID for the Service Principal associated with the Managed Service Identity of this App Service.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class AppServiceLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationLogs":
            suggest = "application_logs"
        elif key == "detailedErrorMessagesEnabled":
            suggest = "detailed_error_messages_enabled"
        elif key == "failedRequestTracingEnabled":
            suggest = "failed_request_tracing_enabled"
        elif key == "httpLogs":
            suggest = "http_logs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_logs: Optional['outputs.AppServiceLogsApplicationLogs'] = None,
                 detailed_error_messages_enabled: Optional[bool] = None,
                 failed_request_tracing_enabled: Optional[bool] = None,
                 http_logs: Optional['outputs.AppServiceLogsHttpLogs'] = None):
        """
        :param 'AppServiceLogsApplicationLogsArgs' application_logs: An `application_logs` block as defined below.
        :param bool detailed_error_messages_enabled: Should `Detailed error messages` be enabled on this App Service? Defaults to `false`.
        :param bool failed_request_tracing_enabled: Should `Failed request tracing` be enabled on this App Service? Defaults to `false`.
        :param 'AppServiceLogsHttpLogsArgs' http_logs: An `http_logs` block as defined below.
        """
        if application_logs is not None:
            pulumi.set(__self__, "application_logs", application_logs)
        if detailed_error_messages_enabled is not None:
            pulumi.set(__self__, "detailed_error_messages_enabled", detailed_error_messages_enabled)
        if failed_request_tracing_enabled is not None:
            pulumi.set(__self__, "failed_request_tracing_enabled", failed_request_tracing_enabled)
        if http_logs is not None:
            pulumi.set(__self__, "http_logs", http_logs)

    @property
    @pulumi.getter(name="applicationLogs")
    def application_logs(self) -> Optional['outputs.AppServiceLogsApplicationLogs']:
        """
        An `application_logs` block as defined below.
        """
        return pulumi.get(self, "application_logs")

    @property
    @pulumi.getter(name="detailedErrorMessagesEnabled")
    def detailed_error_messages_enabled(self) -> Optional[bool]:
        """
        Should `Detailed error messages` be enabled on this App Service? Defaults to `false`.
        """
        return pulumi.get(self, "detailed_error_messages_enabled")

    @property
    @pulumi.getter(name="failedRequestTracingEnabled")
    def failed_request_tracing_enabled(self) -> Optional[bool]:
        """
        Should `Failed request tracing` be enabled on this App Service? Defaults to `false`.
        """
        return pulumi.get(self, "failed_request_tracing_enabled")

    @property
    @pulumi.getter(name="httpLogs")
    def http_logs(self) -> Optional['outputs.AppServiceLogsHttpLogs']:
        """
        An `http_logs` block as defined below.
        """
        return pulumi.get(self, "http_logs")


@pulumi.output_type
class AppServiceLogsApplicationLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureBlobStorage":
            suggest = "azure_blob_storage"
        elif key == "fileSystemLevel":
            suggest = "file_system_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceLogsApplicationLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceLogsApplicationLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceLogsApplicationLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_blob_storage: Optional['outputs.AppServiceLogsApplicationLogsAzureBlobStorage'] = None,
                 file_system_level: Optional[str] = None):
        """
        :param 'AppServiceLogsApplicationLogsAzureBlobStorageArgs' azure_blob_storage: An `azure_blob_storage` block as defined below.
        :param str file_system_level: Log level for filesystem based logging. Supported values are `Error`, `Information`, `Verbose`, `Warning` and `Off`. Defaults to `Off`.
        """
        if azure_blob_storage is not None:
            pulumi.set(__self__, "azure_blob_storage", azure_blob_storage)
        if file_system_level is not None:
            pulumi.set(__self__, "file_system_level", file_system_level)

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional['outputs.AppServiceLogsApplicationLogsAzureBlobStorage']:
        """
        An `azure_blob_storage` block as defined below.
        """
        return pulumi.get(self, "azure_blob_storage")

    @property
    @pulumi.getter(name="fileSystemLevel")
    def file_system_level(self) -> Optional[str]:
        """
        Log level for filesystem based logging. Supported values are `Error`, `Information`, `Verbose`, `Warning` and `Off`. Defaults to `Off`.
        """
        return pulumi.get(self, "file_system_level")


@pulumi.output_type
class AppServiceLogsApplicationLogsAzureBlobStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retentionInDays":
            suggest = "retention_in_days"
        elif key == "sasUrl":
            suggest = "sas_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceLogsApplicationLogsAzureBlobStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceLogsApplicationLogsAzureBlobStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceLogsApplicationLogsAzureBlobStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 level: str,
                 retention_in_days: int,
                 sas_url: str):
        """
        :param str level: The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        :param int retention_in_days: The number of days to retain logs for.
        :param str sas_url: The URL to the storage container with a shared access signature token appended.
        """
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "sas_url", sas_url)

    @property
    @pulumi.getter
    def level(self) -> str:
        """
        The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        """
        return pulumi.get(self, "level")

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> int:
        """
        The number of days to retain logs for.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> str:
        """
        The URL to the storage container with a shared access signature token appended.
        """
        return pulumi.get(self, "sas_url")


@pulumi.output_type
class AppServiceLogsHttpLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureBlobStorage":
            suggest = "azure_blob_storage"
        elif key == "fileSystem":
            suggest = "file_system"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceLogsHttpLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceLogsHttpLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceLogsHttpLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_blob_storage: Optional['outputs.AppServiceLogsHttpLogsAzureBlobStorage'] = None,
                 file_system: Optional['outputs.AppServiceLogsHttpLogsFileSystem'] = None):
        """
        :param 'AppServiceLogsHttpLogsAzureBlobStorageArgs' azure_blob_storage: An `azure_blob_storage` block as defined below.
        :param 'AppServiceLogsHttpLogsFileSystemArgs' file_system: A `file_system` block as defined below.
        """
        if azure_blob_storage is not None:
            pulumi.set(__self__, "azure_blob_storage", azure_blob_storage)
        if file_system is not None:
            pulumi.set(__self__, "file_system", file_system)

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional['outputs.AppServiceLogsHttpLogsAzureBlobStorage']:
        """
        An `azure_blob_storage` block as defined below.
        """
        return pulumi.get(self, "azure_blob_storage")

    @property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional['outputs.AppServiceLogsHttpLogsFileSystem']:
        """
        A `file_system` block as defined below.
        """
        return pulumi.get(self, "file_system")


@pulumi.output_type
class AppServiceLogsHttpLogsAzureBlobStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retentionInDays":
            suggest = "retention_in_days"
        elif key == "sasUrl":
            suggest = "sas_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceLogsHttpLogsAzureBlobStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceLogsHttpLogsAzureBlobStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceLogsHttpLogsAzureBlobStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 retention_in_days: int,
                 sas_url: str):
        """
        :param int retention_in_days: The number of days to retain logs for.
        :param str sas_url: The URL to the storage container with a shared access signature token appended.
        """
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "sas_url", sas_url)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> int:
        """
        The number of days to retain logs for.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> str:
        """
        The URL to the storage container with a shared access signature token appended.
        """
        return pulumi.get(self, "sas_url")


@pulumi.output_type
class AppServiceLogsHttpLogsFileSystem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retentionInDays":
            suggest = "retention_in_days"
        elif key == "retentionInMb":
            suggest = "retention_in_mb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceLogsHttpLogsFileSystem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceLogsHttpLogsFileSystem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceLogsHttpLogsFileSystem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 retention_in_days: int,
                 retention_in_mb: int):
        """
        :param int retention_in_days: The number of days to retain logs for.
        :param int retention_in_mb: The maximum size in megabytes that HTTP log files can use before being removed.
        """
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "retention_in_mb", retention_in_mb)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> int:
        """
        The number of days to retain logs for.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="retentionInMb")
    def retention_in_mb(self) -> int:
        """
        The maximum size in megabytes that HTTP log files can use before being removed.
        """
        return pulumi.get(self, "retention_in_mb")


@pulumi.output_type
class AppServiceSiteConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acrUseManagedIdentityCredentials":
            suggest = "acr_use_managed_identity_credentials"
        elif key == "acrUserManagedIdentityClientId":
            suggest = "acr_user_managed_identity_client_id"
        elif key == "alwaysOn":
            suggest = "always_on"
        elif key == "appCommandLine":
            suggest = "app_command_line"
        elif key == "autoSwapSlotName":
            suggest = "auto_swap_slot_name"
        elif key == "defaultDocuments":
            suggest = "default_documents"
        elif key == "dotnetFrameworkVersion":
            suggest = "dotnet_framework_version"
        elif key == "ftpsState":
            suggest = "ftps_state"
        elif key == "healthCheckPath":
            suggest = "health_check_path"
        elif key == "http2Enabled":
            suggest = "http2_enabled"
        elif key == "ipRestrictions":
            suggest = "ip_restrictions"
        elif key == "javaContainer":
            suggest = "java_container"
        elif key == "javaContainerVersion":
            suggest = "java_container_version"
        elif key == "javaVersion":
            suggest = "java_version"
        elif key == "linuxFxVersion":
            suggest = "linux_fx_version"
        elif key == "localMysqlEnabled":
            suggest = "local_mysql_enabled"
        elif key == "managedPipelineMode":
            suggest = "managed_pipeline_mode"
        elif key == "minTlsVersion":
            suggest = "min_tls_version"
        elif key == "numberOfWorkers":
            suggest = "number_of_workers"
        elif key == "phpVersion":
            suggest = "php_version"
        elif key == "pythonVersion":
            suggest = "python_version"
        elif key == "remoteDebuggingEnabled":
            suggest = "remote_debugging_enabled"
        elif key == "remoteDebuggingVersion":
            suggest = "remote_debugging_version"
        elif key == "scmIpRestrictions":
            suggest = "scm_ip_restrictions"
        elif key == "scmType":
            suggest = "scm_type"
        elif key == "scmUseMainIpRestriction":
            suggest = "scm_use_main_ip_restriction"
        elif key == "use32BitWorkerProcess":
            suggest = "use32_bit_worker_process"
        elif key == "vnetRouteAllEnabled":
            suggest = "vnet_route_all_enabled"
        elif key == "websocketsEnabled":
            suggest = "websockets_enabled"
        elif key == "windowsFxVersion":
            suggest = "windows_fx_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceSiteConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceSiteConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceSiteConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acr_use_managed_identity_credentials: Optional[bool] = None,
                 acr_user_managed_identity_client_id: Optional[str] = None,
                 always_on: Optional[bool] = None,
                 app_command_line: Optional[str] = None,
                 auto_swap_slot_name: Optional[str] = None,
                 cors: Optional['outputs.AppServiceSiteConfigCors'] = None,
                 default_documents: Optional[Sequence[str]] = None,
                 dotnet_framework_version: Optional[str] = None,
                 ftps_state: Optional[str] = None,
                 health_check_path: Optional[str] = None,
                 http2_enabled: Optional[bool] = None,
                 ip_restrictions: Optional[Sequence['outputs.AppServiceSiteConfigIpRestriction']] = None,
                 java_container: Optional[str] = None,
                 java_container_version: Optional[str] = None,
                 java_version: Optional[str] = None,
                 linux_fx_version: Optional[str] = None,
                 local_mysql_enabled: Optional[bool] = None,
                 managed_pipeline_mode: Optional[str] = None,
                 min_tls_version: Optional[str] = None,
                 number_of_workers: Optional[int] = None,
                 php_version: Optional[str] = None,
                 python_version: Optional[str] = None,
                 remote_debugging_enabled: Optional[bool] = None,
                 remote_debugging_version: Optional[str] = None,
                 scm_ip_restrictions: Optional[Sequence['outputs.AppServiceSiteConfigScmIpRestriction']] = None,
                 scm_type: Optional[str] = None,
                 scm_use_main_ip_restriction: Optional[bool] = None,
                 use32_bit_worker_process: Optional[bool] = None,
                 vnet_route_all_enabled: Optional[bool] = None,
                 websockets_enabled: Optional[bool] = None,
                 windows_fx_version: Optional[str] = None):
        """
        :param bool acr_use_managed_identity_credentials: Are Managed Identity Credentials used for Azure Container Registry pull
        :param str acr_user_managed_identity_client_id: If using User Managed Identity, the User Managed Identity Client Id
        :param bool always_on: Should the app be loaded at all times? Defaults to `false`.
        :param str app_command_line: App command line to launch, e.g. `/sbin/myserver -b 0.0.0.0`.
        :param 'AppServiceSiteConfigCorsArgs' cors: A `cors` block as defined below.
        :param Sequence[str] default_documents: The ordering of default documents to load, if an address isn't specified.
        :param str dotnet_framework_version: The version of the .NET framework's CLR used in this App Service. Possible values are `v2.0` (which will use the latest version of the .NET framework for the .NET CLR v2 - currently `.net 3.5`), `v4.0` (which corresponds to the latest version of the .NET CLR v4 - which at the time of writing is `.net 4.7.1`), `v5.0` and `v6.0`. [For more information on which .NET CLR version to use based on the .NET framework you're targeting - please see this table](https://en.wikipedia.org/wiki/.NET_Framework_version_history#Overview). Defaults to `v4.0`.
        :param str ftps_state: State of FTP / FTPS service for this App Service. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`.
        :param str health_check_path: The health check path to be pinged by App Service. [For more information - please see App Service health check announcement](https://azure.github.io/AppService/2020/08/24/healthcheck-on-app-service.html).
        :param bool http2_enabled: Is HTTP2 Enabled on this App Service? Defaults to `false`.
        :param Sequence['AppServiceSiteConfigIpRestrictionArgs'] ip_restrictions: A list of objects representing ip restrictions as defined below.
        :param str java_container: The Java Container to use. If specified `java_version` and `java_container_version` must also be specified. Possible values are `JAVA`, `JETTY`, and `TOMCAT`.
        :param str java_container_version: The version of the Java Container to use. If specified `java_version` and `java_container` must also be specified.
        :param str java_version: The version of Java to use. If specified `java_container` and `java_container_version` must also be specified. Possible values are `1.7`, `1.8` and `11` and their specific versions - except for Java 11 (e.g. `1.7.0_80`, `1.8.0_181`, `11`)
        :param str linux_fx_version: Linux App Framework and version for the App Service. Possible options are a Docker container (`DOCKER|<user/image:tag>`), a base-64 encoded Docker Compose file (`COMPOSE|${filebase64("compose.yml")}`) or a base-64 encoded Kubernetes Manifest (`KUBE|${filebase64("kubernetes.yml")}`).
        :param bool local_mysql_enabled: Is "MySQL In App" Enabled? This runs a local MySQL instance with your app and shares resources from the App Service plan.
        :param str managed_pipeline_mode: The Managed Pipeline Mode. Possible values are `Integrated` and `Classic`. Defaults to `Integrated`.
        :param str min_tls_version: The minimum supported TLS version for the app service. Possible values are `1.0`, `1.1`, and `1.2`. Defaults to `1.2` for new app services.
        :param int number_of_workers: The scaled number of workers (for per site scaling) of this App Service. Requires that `per_site_scaling` is enabled on the `appservice.Plan`. [For more information - please see Microsoft documentation on high-density hosting](https://docs.microsoft.com/azure/app-service/manage-scale-per-app).
        :param str php_version: The version of PHP to use in this App Service. Possible values are `5.5`, `5.6`, `7.0`, `7.1`, `7.2`, `7.3` and `7.4`.
        :param str python_version: The version of Python to use in this App Service. Possible values are `2.7` and `3.4`.
        :param bool remote_debugging_enabled: Is Remote Debugging Enabled? Defaults to `false`.
        :param str remote_debugging_version: Which version of Visual Studio should the Remote Debugger be compatible with? Possible values are `VS2017` and `VS2019`.
        :param Sequence['AppServiceSiteConfigScmIpRestrictionArgs'] scm_ip_restrictions: A [List of objects](https://www.terraform.io/docs/configuration/attr-as-blocks.html) representing IP restrictions as defined below.
        :param str scm_type: The type of Source Control enabled for this App Service. Defaults to `None`. Possible values are: `BitbucketGit`, `BitbucketHg`, `CodePlexGit`, `CodePlexHg`, `Dropbox`, `ExternalGit`, `ExternalHg`, `GitHub`, `LocalGit`, `None`, `OneDrive`, `Tfs`, `VSO`, and `VSTSRM`
        :param bool scm_use_main_ip_restriction: IP security restrictions for scm to use main. Defaults to false.
        :param bool use32_bit_worker_process: Should the App Service run in 32 bit mode, rather than 64 bit mode?
        :param bool vnet_route_all_enabled: Should all outbound traffic to have Virtual Network Security Groups and User Defined Routes applied? Defaults to `false`.
        :param bool websockets_enabled: Should WebSockets be enabled?
        :param str windows_fx_version: The Windows Docker container image (`DOCKER|<user/image:tag>`)
        """
        if acr_use_managed_identity_credentials is not None:
            pulumi.set(__self__, "acr_use_managed_identity_credentials", acr_use_managed_identity_credentials)
        if acr_user_managed_identity_client_id is not None:
            pulumi.set(__self__, "acr_user_managed_identity_client_id", acr_user_managed_identity_client_id)
        if always_on is not None:
            pulumi.set(__self__, "always_on", always_on)
        if app_command_line is not None:
            pulumi.set(__self__, "app_command_line", app_command_line)
        if auto_swap_slot_name is not None:
            pulumi.set(__self__, "auto_swap_slot_name", auto_swap_slot_name)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if default_documents is not None:
            pulumi.set(__self__, "default_documents", default_documents)
        if dotnet_framework_version is not None:
            pulumi.set(__self__, "dotnet_framework_version", dotnet_framework_version)
        if ftps_state is not None:
            pulumi.set(__self__, "ftps_state", ftps_state)
        if health_check_path is not None:
            pulumi.set(__self__, "health_check_path", health_check_path)
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if ip_restrictions is not None:
            pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        if java_container is not None:
            pulumi.set(__self__, "java_container", java_container)
        if java_container_version is not None:
            pulumi.set(__self__, "java_container_version", java_container_version)
        if java_version is not None:
            pulumi.set(__self__, "java_version", java_version)
        if linux_fx_version is not None:
            pulumi.set(__self__, "linux_fx_version", linux_fx_version)
        if local_mysql_enabled is not None:
            pulumi.set(__self__, "local_mysql_enabled", local_mysql_enabled)
        if managed_pipeline_mode is not None:
            pulumi.set(__self__, "managed_pipeline_mode", managed_pipeline_mode)
        if min_tls_version is not None:
            pulumi.set(__self__, "min_tls_version", min_tls_version)
        if number_of_workers is not None:
            pulumi.set(__self__, "number_of_workers", number_of_workers)
        if php_version is not None:
            pulumi.set(__self__, "php_version", php_version)
        if python_version is not None:
            pulumi.set(__self__, "python_version", python_version)
        if remote_debugging_enabled is not None:
            pulumi.set(__self__, "remote_debugging_enabled", remote_debugging_enabled)
        if remote_debugging_version is not None:
            pulumi.set(__self__, "remote_debugging_version", remote_debugging_version)
        if scm_ip_restrictions is not None:
            pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        if scm_type is not None:
            pulumi.set(__self__, "scm_type", scm_type)
        if scm_use_main_ip_restriction is not None:
            pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        if use32_bit_worker_process is not None:
            pulumi.set(__self__, "use32_bit_worker_process", use32_bit_worker_process)
        if vnet_route_all_enabled is not None:
            pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        if websockets_enabled is not None:
            pulumi.set(__self__, "websockets_enabled", websockets_enabled)
        if windows_fx_version is not None:
            pulumi.set(__self__, "windows_fx_version", windows_fx_version)

    @property
    @pulumi.getter(name="acrUseManagedIdentityCredentials")
    def acr_use_managed_identity_credentials(self) -> Optional[bool]:
        """
        Are Managed Identity Credentials used for Azure Container Registry pull
        """
        return pulumi.get(self, "acr_use_managed_identity_credentials")

    @property
    @pulumi.getter(name="acrUserManagedIdentityClientId")
    def acr_user_managed_identity_client_id(self) -> Optional[str]:
        """
        If using User Managed Identity, the User Managed Identity Client Id
        """
        return pulumi.get(self, "acr_user_managed_identity_client_id")

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> Optional[bool]:
        """
        Should the app be loaded at all times? Defaults to `false`.
        """
        return pulumi.get(self, "always_on")

    @property
    @pulumi.getter(name="appCommandLine")
    def app_command_line(self) -> Optional[str]:
        """
        App command line to launch, e.g. `/sbin/myserver -b 0.0.0.0`.
        """
        return pulumi.get(self, "app_command_line")

    @property
    @pulumi.getter(name="autoSwapSlotName")
    def auto_swap_slot_name(self) -> Optional[str]:
        return pulumi.get(self, "auto_swap_slot_name")

    @property
    @pulumi.getter
    def cors(self) -> Optional['outputs.AppServiceSiteConfigCors']:
        """
        A `cors` block as defined below.
        """
        return pulumi.get(self, "cors")

    @property
    @pulumi.getter(name="defaultDocuments")
    def default_documents(self) -> Optional[Sequence[str]]:
        """
        The ordering of default documents to load, if an address isn't specified.
        """
        return pulumi.get(self, "default_documents")

    @property
    @pulumi.getter(name="dotnetFrameworkVersion")
    def dotnet_framework_version(self) -> Optional[str]:
        """
        The version of the .NET framework's CLR used in this App Service. Possible values are `v2.0` (which will use the latest version of the .NET framework for the .NET CLR v2 - currently `.net 3.5`), `v4.0` (which corresponds to the latest version of the .NET CLR v4 - which at the time of writing is `.net 4.7.1`), `v5.0` and `v6.0`. [For more information on which .NET CLR version to use based on the .NET framework you're targeting - please see this table](https://en.wikipedia.org/wiki/.NET_Framework_version_history#Overview). Defaults to `v4.0`.
        """
        return pulumi.get(self, "dotnet_framework_version")

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> Optional[str]:
        """
        State of FTP / FTPS service for this App Service. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`.
        """
        return pulumi.get(self, "ftps_state")

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> Optional[str]:
        """
        The health check path to be pinged by App Service. [For more information - please see App Service health check announcement](https://azure.github.io/AppService/2020/08/24/healthcheck-on-app-service.html).
        """
        return pulumi.get(self, "health_check_path")

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[bool]:
        """
        Is HTTP2 Enabled on this App Service? Defaults to `false`.
        """
        return pulumi.get(self, "http2_enabled")

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Optional[Sequence['outputs.AppServiceSiteConfigIpRestriction']]:
        """
        A list of objects representing ip restrictions as defined below.
        """
        return pulumi.get(self, "ip_restrictions")

    @property
    @pulumi.getter(name="javaContainer")
    def java_container(self) -> Optional[str]:
        """
        The Java Container to use. If specified `java_version` and `java_container_version` must also be specified. Possible values are `JAVA`, `JETTY`, and `TOMCAT`.
        """
        return pulumi.get(self, "java_container")

    @property
    @pulumi.getter(name="javaContainerVersion")
    def java_container_version(self) -> Optional[str]:
        """
        The version of the Java Container to use. If specified `java_version` and `java_container` must also be specified.
        """
        return pulumi.get(self, "java_container_version")

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> Optional[str]:
        """
        The version of Java to use. If specified `java_container` and `java_container_version` must also be specified. Possible values are `1.7`, `1.8` and `11` and their specific versions - except for Java 11 (e.g. `1.7.0_80`, `1.8.0_181`, `11`)
        """
        return pulumi.get(self, "java_version")

    @property
    @pulumi.getter(name="linuxFxVersion")
    def linux_fx_version(self) -> Optional[str]:
        """
        Linux App Framework and version for the App Service. Possible options are a Docker container (`DOCKER|<user/image:tag>`), a base-64 encoded Docker Compose file (`COMPOSE|${filebase64("compose.yml")}`) or a base-64 encoded Kubernetes Manifest (`KUBE|${filebase64("kubernetes.yml")}`).
        """
        return pulumi.get(self, "linux_fx_version")

    @property
    @pulumi.getter(name="localMysqlEnabled")
    def local_mysql_enabled(self) -> Optional[bool]:
        """
        Is "MySQL In App" Enabled? This runs a local MySQL instance with your app and shares resources from the App Service plan.
        """
        return pulumi.get(self, "local_mysql_enabled")

    @property
    @pulumi.getter(name="managedPipelineMode")
    def managed_pipeline_mode(self) -> Optional[str]:
        """
        The Managed Pipeline Mode. Possible values are `Integrated` and `Classic`. Defaults to `Integrated`.
        """
        return pulumi.get(self, "managed_pipeline_mode")

    @property
    @pulumi.getter(name="minTlsVersion")
    def min_tls_version(self) -> Optional[str]:
        """
        The minimum supported TLS version for the app service. Possible values are `1.0`, `1.1`, and `1.2`. Defaults to `1.2` for new app services.
        """
        return pulumi.get(self, "min_tls_version")

    @property
    @pulumi.getter(name="numberOfWorkers")
    def number_of_workers(self) -> Optional[int]:
        """
        The scaled number of workers (for per site scaling) of this App Service. Requires that `per_site_scaling` is enabled on the `appservice.Plan`. [For more information - please see Microsoft documentation on high-density hosting](https://docs.microsoft.com/azure/app-service/manage-scale-per-app).
        """
        return pulumi.get(self, "number_of_workers")

    @property
    @pulumi.getter(name="phpVersion")
    def php_version(self) -> Optional[str]:
        """
        The version of PHP to use in this App Service. Possible values are `5.5`, `5.6`, `7.0`, `7.1`, `7.2`, `7.3` and `7.4`.
        """
        return pulumi.get(self, "php_version")

    @property
    @pulumi.getter(name="pythonVersion")
    def python_version(self) -> Optional[str]:
        """
        The version of Python to use in this App Service. Possible values are `2.7` and `3.4`.
        """
        return pulumi.get(self, "python_version")

    @property
    @pulumi.getter(name="remoteDebuggingEnabled")
    def remote_debugging_enabled(self) -> Optional[bool]:
        """
        Is Remote Debugging Enabled? Defaults to `false`.
        """
        return pulumi.get(self, "remote_debugging_enabled")

    @property
    @pulumi.getter(name="remoteDebuggingVersion")
    def remote_debugging_version(self) -> Optional[str]:
        """
        Which version of Visual Studio should the Remote Debugger be compatible with? Possible values are `VS2017` and `VS2019`.
        """
        return pulumi.get(self, "remote_debugging_version")

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Optional[Sequence['outputs.AppServiceSiteConfigScmIpRestriction']]:
        """
        A [List of objects](https://www.terraform.io/docs/configuration/attr-as-blocks.html) representing IP restrictions as defined below.
        """
        return pulumi.get(self, "scm_ip_restrictions")

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> Optional[str]:
        """
        The type of Source Control enabled for this App Service. Defaults to `None`. Possible values are: `BitbucketGit`, `BitbucketHg`, `CodePlexGit`, `CodePlexHg`, `Dropbox`, `ExternalGit`, `ExternalHg`, `GitHub`, `LocalGit`, `None`, `OneDrive`, `Tfs`, `VSO`, and `VSTSRM`
        """
        return pulumi.get(self, "scm_type")

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> Optional[bool]:
        """
        IP security restrictions for scm to use main. Defaults to false.
        """
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @property
    @pulumi.getter(name="use32BitWorkerProcess")
    def use32_bit_worker_process(self) -> Optional[bool]:
        """
        Should the App Service run in 32 bit mode, rather than 64 bit mode?
        """
        return pulumi.get(self, "use32_bit_worker_process")

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> Optional[bool]:
        """
        Should all outbound traffic to have Virtual Network Security Groups and User Defined Routes applied? Defaults to `false`.
        """
        return pulumi.get(self, "vnet_route_all_enabled")

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> Optional[bool]:
        """
        Should WebSockets be enabled?
        """
        return pulumi.get(self, "websockets_enabled")

    @property
    @pulumi.getter(name="windowsFxVersion")
    def windows_fx_version(self) -> Optional[str]:
        """
        The Windows Docker container image (`DOCKER|<user/image:tag>`)
        """
        return pulumi.get(self, "windows_fx_version")


@pulumi.output_type
class AppServiceSiteConfigCors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedOrigins":
            suggest = "allowed_origins"
        elif key == "supportCredentials":
            suggest = "support_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceSiteConfigCors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceSiteConfigCors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceSiteConfigCors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_origins: Sequence[str],
                 support_credentials: Optional[bool] = None):
        """
        :param Sequence[str] allowed_origins: A list of origins which should be able to make cross-origin calls. `*` can be used to allow all calls.
        :param bool support_credentials: Are credentials supported?
        """
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        if support_credentials is not None:
            pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Sequence[str]:
        """
        A list of origins which should be able to make cross-origin calls. `*` can be used to allow all calls.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> Optional[bool]:
        """
        Are credentials supported?
        """
        return pulumi.get(self, "support_credentials")


@pulumi.output_type
class AppServiceSiteConfigIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceSiteConfigIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceSiteConfigIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceSiteConfigIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.AppServiceSiteConfigIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: Does this restriction `Allow` or `Deny` access for this IP range. Defaults to `Allow`.
        :param 'AppServiceSiteConfigIpRestrictionHeadersArgs' headers: The headers for this specific `ip_restriction` as defined below.
        :param str ip_address: The IP Address used for this IP Restriction in CIDR notation.
        :param str name: The name for this IP Restriction.
        :param int priority: The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        Does this restriction `Allow` or `Deny` access for this IP range. Defaults to `Allow`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.AppServiceSiteConfigIpRestrictionHeaders']:
        """
        The headers for this specific `ip_restriction` as defined below.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The IP Address used for this IP Restriction in CIDR notation.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name for this IP Restriction.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class AppServiceSiteConfigIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceSiteConfigIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        :param str x_fd_health_probe: A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        :param Sequence[str] x_forwarded_fors: A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        :param Sequence[str] x_forwarded_hosts: A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class AppServiceSiteConfigScmIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceSiteConfigScmIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceSiteConfigScmIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceSiteConfigScmIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.AppServiceSiteConfigScmIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: Allow or Deny access for this IP range. Defaults to Allow.
        :param 'AppServiceSiteConfigScmIpRestrictionHeadersArgs' headers: The headers for this specific `scm_ip_restriction` as defined below.
        :param str ip_address: The IP Address used for this IP Restriction in CIDR notation.
        :param str name: The name for this IP Restriction.
        :param int priority: The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        Allow or Deny access for this IP range. Defaults to Allow.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.AppServiceSiteConfigScmIpRestrictionHeaders']:
        """
        The headers for this specific `scm_ip_restriction` as defined below.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The IP Address used for this IP Restriction in CIDR notation.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name for this IP Restriction.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class AppServiceSiteConfigScmIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceSiteConfigScmIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        :param str x_fd_health_probe: A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        :param Sequence[str] x_forwarded_fors: A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        :param Sequence[str] x_forwarded_hosts: A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class AppServiceSiteCredential(dict):
    def __init__(__self__, *,
                 password: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str password: The password associated with the username, which can be used to publish to this App Service.
        :param str username: The username which can be used to publish to this App Service
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password associated with the username, which can be used to publish to this App Service.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username which can be used to publish to this App Service
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class AppServiceSourceControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "manualIntegration":
            suggest = "manual_integration"
        elif key == "repoUrl":
            suggest = "repo_url"
        elif key == "rollbackEnabled":
            suggest = "rollback_enabled"
        elif key == "useMercurial":
            suggest = "use_mercurial"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceSourceControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceSourceControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceSourceControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch: Optional[str] = None,
                 manual_integration: Optional[bool] = None,
                 repo_url: Optional[str] = None,
                 rollback_enabled: Optional[bool] = None,
                 use_mercurial: Optional[bool] = None):
        """
        :param str branch: The branch of the remote repository to use. Defaults to 'master'.
        :param bool manual_integration: Limits to manual integration. Defaults to `false` if not specified.
        :param str repo_url: The URL of the source code repository.
        :param bool rollback_enabled: Enable roll-back for the repository. Defaults to `false` if not specified.
        :param bool use_mercurial: Use Mercurial if `true`, otherwise uses Git.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if manual_integration is not None:
            pulumi.set(__self__, "manual_integration", manual_integration)
        if repo_url is not None:
            pulumi.set(__self__, "repo_url", repo_url)
        if rollback_enabled is not None:
            pulumi.set(__self__, "rollback_enabled", rollback_enabled)
        if use_mercurial is not None:
            pulumi.set(__self__, "use_mercurial", use_mercurial)

    @property
    @pulumi.getter
    def branch(self) -> Optional[str]:
        """
        The branch of the remote repository to use. Defaults to 'master'.
        """
        return pulumi.get(self, "branch")

    @property
    @pulumi.getter(name="manualIntegration")
    def manual_integration(self) -> Optional[bool]:
        """
        Limits to manual integration. Defaults to `false` if not specified.
        """
        return pulumi.get(self, "manual_integration")

    @property
    @pulumi.getter(name="repoUrl")
    def repo_url(self) -> Optional[str]:
        """
        The URL of the source code repository.
        """
        return pulumi.get(self, "repo_url")

    @property
    @pulumi.getter(name="rollbackEnabled")
    def rollback_enabled(self) -> Optional[bool]:
        """
        Enable roll-back for the repository. Defaults to `false` if not specified.
        """
        return pulumi.get(self, "rollback_enabled")

    @property
    @pulumi.getter(name="useMercurial")
    def use_mercurial(self) -> Optional[bool]:
        """
        Use Mercurial if `true`, otherwise uses Git.
        """
        return pulumi.get(self, "use_mercurial")


@pulumi.output_type
class AppServiceStorageAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "accountName":
            suggest = "account_name"
        elif key == "shareName":
            suggest = "share_name"
        elif key == "mountPath":
            suggest = "mount_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppServiceStorageAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppServiceStorageAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppServiceStorageAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: str,
                 account_name: str,
                 name: str,
                 share_name: str,
                 type: str,
                 mount_path: Optional[str] = None):
        """
        :param str access_key: The access key for the storage account.
        :param str account_name: The name of the storage account.
        :param str name: The name of the storage account identifier.
        :param str share_name: The name of the file share (container name, for Blob storage).
        :param str type: The type of storage. Possible values are `AzureBlob` and `AzureFiles`.
        :param str mount_path: The path to mount the storage within the site's runtime environment.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "share_name", share_name)
        pulumi.set(__self__, "type", type)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> str:
        """
        The access key for the storage account.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> str:
        """
        The name of the storage account.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the storage account identifier.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> str:
        """
        The name of the file share (container name, for Blob storage).
        """
        return pulumi.get(self, "share_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of storage. Possible values are `AzureBlob` and `AzureFiles`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[str]:
        """
        The path to mount the storage within the site's runtime environment.
        """
        return pulumi.get(self, "mount_path")


@pulumi.output_type
class CertificateOrderCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateName":
            suggest = "certificate_name"
        elif key == "keyVaultId":
            suggest = "key_vault_id"
        elif key == "keyVaultSecretName":
            suggest = "key_vault_secret_name"
        elif key == "provisioningState":
            suggest = "provisioning_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CertificateOrderCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CertificateOrderCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CertificateOrderCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_name: Optional[str] = None,
                 key_vault_id: Optional[str] = None,
                 key_vault_secret_name: Optional[str] = None,
                 provisioning_state: Optional[str] = None):
        """
        :param str certificate_name: The name of the App Service Certificate.
        :param str key_vault_id: Key Vault resource Id.
        :param str key_vault_secret_name: Key Vault secret name.
        :param str provisioning_state: Status of the Key Vault secret.
        """
        if certificate_name is not None:
            pulumi.set(__self__, "certificate_name", certificate_name)
        if key_vault_id is not None:
            pulumi.set(__self__, "key_vault_id", key_vault_id)
        if key_vault_secret_name is not None:
            pulumi.set(__self__, "key_vault_secret_name", key_vault_secret_name)
        if provisioning_state is not None:
            pulumi.set(__self__, "provisioning_state", provisioning_state)

    @property
    @pulumi.getter(name="certificateName")
    def certificate_name(self) -> Optional[str]:
        """
        The name of the App Service Certificate.
        """
        return pulumi.get(self, "certificate_name")

    @property
    @pulumi.getter(name="keyVaultId")
    def key_vault_id(self) -> Optional[str]:
        """
        Key Vault resource Id.
        """
        return pulumi.get(self, "key_vault_id")

    @property
    @pulumi.getter(name="keyVaultSecretName")
    def key_vault_secret_name(self) -> Optional[str]:
        """
        Key Vault secret name.
        """
        return pulumi.get(self, "key_vault_secret_name")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> Optional[str]:
        """
        Status of the Key Vault secret.
        """
        return pulumi.get(self, "provisioning_state")


@pulumi.output_type
class ConnectionAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "subscriptionId":
            suggest = "subscription_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 certificate: Optional[str] = None,
                 client_id: Optional[str] = None,
                 name: Optional[str] = None,
                 principal_id: Optional[str] = None,
                 secret: Optional[str] = None,
                 subscription_id: Optional[str] = None):
        """
        :param str type: The authentication type. Possible values are `systemAssignedIdentity`, `userAssignedIdentity`, `servicePrincipalSecret`, `servicePrincipalCertificate`, `secret`.
        :param str certificate: Service principal certificate for `servicePrincipal` auth. Should be specified when `type` is set to `servicePrincipalCertificate`.
        :param str client_id: Client ID for `userAssignedIdentity` or `servicePrincipal` auth. Should be specified when `type` is set to `servicePrincipalSecret` or `servicePrincipalCertificate`. When `type` is set to `userAssignedIdentity`, `client_id` and `subscription_id` should be either both specified or both not specified.
        :param str name: Username or account name for secret auth. `name` and `secret` should be either both specified or both not specified when `type` is set to `secret`.
        :param str principal_id: Principal ID for `servicePrincipal` auth. Should be specified when `type` is set to `servicePrincipalSecret` or `servicePrincipalCertificate`.
        :param str secret: Password or account key for secret auth. `secret` and `name` should be either both specified or both not specified when `type` is set to `secret`.
        :param str subscription_id: Subscription ID for `userAssignedIdentity`. `subscription_id` and `client_id` should be either both specified or both not specified.
        """
        pulumi.set(__self__, "type", type)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The authentication type. Possible values are `systemAssignedIdentity`, `userAssignedIdentity`, `servicePrincipalSecret`, `servicePrincipalCertificate`, `secret`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[str]:
        """
        Service principal certificate for `servicePrincipal` auth. Should be specified when `type` is set to `servicePrincipalCertificate`.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        Client ID for `userAssignedIdentity` or `servicePrincipal` auth. Should be specified when `type` is set to `servicePrincipalSecret` or `servicePrincipalCertificate`. When `type` is set to `userAssignedIdentity`, `client_id` and `subscription_id` should be either both specified or both not specified.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Username or account name for secret auth. `name` and `secret` should be either both specified or both not specified when `type` is set to `secret`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        """
        Principal ID for `servicePrincipal` auth. Should be specified when `type` is set to `servicePrincipalSecret` or `servicePrincipalCertificate`.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter
    def secret(self) -> Optional[str]:
        """
        Password or account key for secret auth. `secret` and `name` should be either both specified or both not specified when `type` is set to `secret`.
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[str]:
        """
        Subscription ID for `userAssignedIdentity`. `subscription_id` and `client_id` should be either both specified or both not specified.
        """
        return pulumi.get(self, "subscription_id")


@pulumi.output_type
class EnvironmentClusterSetting(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: The name of the Cluster Setting.
        :param str value: The value for the Cluster Setting.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Cluster Setting.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the Cluster Setting.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EnvironmentV3ClusterSetting(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: The name of the Cluster Setting.
        :param str value: The value for the Cluster Setting.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Cluster Setting.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the Cluster Setting.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EnvironmentV3InboundNetworkDependency(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddresses":
            suggest = "ip_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EnvironmentV3InboundNetworkDependency. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EnvironmentV3InboundNetworkDependency.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EnvironmentV3InboundNetworkDependency.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[str] = None,
                 ip_addresses: Optional[Sequence[str]] = None,
                 ports: Optional[Sequence[str]] = None):
        """
        :param str description: A short description of the purpose of the network traffic.
        :param Sequence[str] ip_addresses: A list of IP addresses that network traffic will originate from in CIDR notation.
        :param Sequence[str] ports: The ports that network traffic will arrive to the App Service Environment V3 on.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A short description of the purpose of the network traffic.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[Sequence[str]]:
        """
        A list of IP addresses that network traffic will originate from in CIDR notation.
        """
        return pulumi.get(self, "ip_addresses")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[str]]:
        """
        The ports that network traffic will arrive to the App Service Environment V3 on.
        """
        return pulumi.get(self, "ports")


@pulumi.output_type
class FunctionAppAuthSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeDirectory":
            suggest = "active_directory"
        elif key == "additionalLoginParams":
            suggest = "additional_login_params"
        elif key == "allowedExternalRedirectUrls":
            suggest = "allowed_external_redirect_urls"
        elif key == "defaultProvider":
            suggest = "default_provider"
        elif key == "runtimeVersion":
            suggest = "runtime_version"
        elif key == "tokenRefreshExtensionHours":
            suggest = "token_refresh_extension_hours"
        elif key == "tokenStoreEnabled":
            suggest = "token_store_enabled"
        elif key == "unauthenticatedClientAction":
            suggest = "unauthenticated_client_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppAuthSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppAuthSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppAuthSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 active_directory: Optional['outputs.FunctionAppAuthSettingsActiveDirectory'] = None,
                 additional_login_params: Optional[Mapping[str, str]] = None,
                 allowed_external_redirect_urls: Optional[Sequence[str]] = None,
                 default_provider: Optional[str] = None,
                 facebook: Optional['outputs.FunctionAppAuthSettingsFacebook'] = None,
                 google: Optional['outputs.FunctionAppAuthSettingsGoogle'] = None,
                 issuer: Optional[str] = None,
                 microsoft: Optional['outputs.FunctionAppAuthSettingsMicrosoft'] = None,
                 runtime_version: Optional[str] = None,
                 token_refresh_extension_hours: Optional[float] = None,
                 token_store_enabled: Optional[bool] = None,
                 twitter: Optional['outputs.FunctionAppAuthSettingsTwitter'] = None,
                 unauthenticated_client_action: Optional[str] = None):
        """
        :param bool enabled: Is Authentication enabled?
        :param 'FunctionAppAuthSettingsActiveDirectoryArgs' active_directory: A `active_directory` block as defined below.
        :param Mapping[str, str] additional_login_params: Login parameters to send to the OpenID Connect authorization endpoint when a user logs in. Each parameter must be in the form "key=value".
        :param Sequence[str] allowed_external_redirect_urls: External URLs that can be redirected to as part of logging in or logging out of the app.
        :param str default_provider: The default provider to use when multiple providers have been set up. Possible values are `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount` and `Twitter`.
        :param 'FunctionAppAuthSettingsFacebookArgs' facebook: A `facebook` block as defined below.
        :param 'FunctionAppAuthSettingsGoogleArgs' google: A `google` block as defined below.
        :param str issuer: Issuer URI. When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        :param 'FunctionAppAuthSettingsMicrosoftArgs' microsoft: A `microsoft` block as defined below.
        :param str runtime_version: The runtime version of the Authentication/Authorization module.
        :param float token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to 72.
        :param bool token_store_enabled: If enabled the module will durably store platform-specific security tokens that are obtained during login flows. Defaults to false.
        :param 'FunctionAppAuthSettingsTwitterArgs' twitter: A `twitter` block as defined below.
        :param str unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app. Possible values are `AllowAnonymous` and `RedirectToLoginPage`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if active_directory is not None:
            pulumi.set(__self__, "active_directory", active_directory)
        if additional_login_params is not None:
            pulumi.set(__self__, "additional_login_params", additional_login_params)
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if facebook is not None:
            pulumi.set(__self__, "facebook", facebook)
        if google is not None:
            pulumi.set(__self__, "google", google)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if microsoft is not None:
            pulumi.set(__self__, "microsoft", microsoft)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if token_refresh_extension_hours is not None:
            pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if twitter is not None:
            pulumi.set(__self__, "twitter", twitter)
        if unauthenticated_client_action is not None:
            pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is Authentication enabled?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="activeDirectory")
    def active_directory(self) -> Optional['outputs.FunctionAppAuthSettingsActiveDirectory']:
        """
        A `active_directory` block as defined below.
        """
        return pulumi.get(self, "active_directory")

    @property
    @pulumi.getter(name="additionalLoginParams")
    def additional_login_params(self) -> Optional[Mapping[str, str]]:
        """
        Login parameters to send to the OpenID Connect authorization endpoint when a user logs in. Each parameter must be in the form "key=value".
        """
        return pulumi.get(self, "additional_login_params")

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[Sequence[str]]:
        """
        External URLs that can be redirected to as part of logging in or logging out of the app.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[str]:
        """
        The default provider to use when multiple providers have been set up. Possible values are `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount` and `Twitter`.
        """
        return pulumi.get(self, "default_provider")

    @property
    @pulumi.getter
    def facebook(self) -> Optional['outputs.FunctionAppAuthSettingsFacebook']:
        """
        A `facebook` block as defined below.
        """
        return pulumi.get(self, "facebook")

    @property
    @pulumi.getter
    def google(self) -> Optional['outputs.FunctionAppAuthSettingsGoogle']:
        """
        A `google` block as defined below.
        """
        return pulumi.get(self, "google")

    @property
    @pulumi.getter
    def issuer(self) -> Optional[str]:
        """
        Issuer URI. When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def microsoft(self) -> Optional['outputs.FunctionAppAuthSettingsMicrosoft']:
        """
        A `microsoft` block as defined below.
        """
        return pulumi.get(self, "microsoft")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[str]:
        """
        The runtime version of the Authentication/Authorization module.
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> Optional[float]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to 72.
        """
        return pulumi.get(self, "token_refresh_extension_hours")

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[bool]:
        """
        If enabled the module will durably store platform-specific security tokens that are obtained during login flows. Defaults to false.
        """
        return pulumi.get(self, "token_store_enabled")

    @property
    @pulumi.getter
    def twitter(self) -> Optional['outputs.FunctionAppAuthSettingsTwitter']:
        """
        A `twitter` block as defined below.
        """
        return pulumi.get(self, "twitter")

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> Optional[str]:
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values are `AllowAnonymous` and `RedirectToLoginPage`.
        """
        return pulumi.get(self, "unauthenticated_client_action")


@pulumi.output_type
class FunctionAppAuthSettingsActiveDirectory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "clientSecret":
            suggest = "client_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppAuthSettingsActiveDirectory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppAuthSettingsActiveDirectory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppAuthSettingsActiveDirectory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 client_secret: Optional[str] = None):
        """
        :param str client_id: The Client ID of this relying party application. Enables OpenIDConnection authentication with Azure Active Directory.
        :param Sequence[str] allowed_audiences: Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
        :param str client_secret: The Client Secret of this relying party application. If no secret is provided, implicit flow will be used.
        """
        pulumi.set(__self__, "client_id", client_id)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The Client ID of this relying party application. Enables OpenIDConnection authentication with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret of this relying party application. If no secret is provided, implicit flow will be used.
        """
        return pulumi.get(self, "client_secret")


@pulumi.output_type
class FunctionAppAuthSettingsFacebook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "appSecret":
            suggest = "app_secret"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppAuthSettingsFacebook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppAuthSettingsFacebook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppAuthSettingsFacebook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: str,
                 app_secret: str,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str app_id: The App ID of the Facebook app used for login
        :param str app_secret: The App Secret of the Facebook app used for Facebook login.
        :param Sequence[str] oauth_scopes: The OAuth 2.0 scopes that will be requested as part of Facebook login authentication. <https://developers.facebook.com/docs/facebook-login>
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "app_secret", app_secret)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        The App ID of the Facebook app used for login
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appSecret")
    def app_secret(self) -> str:
        """
        The App Secret of the Facebook app used for Facebook login.
        """
        return pulumi.get(self, "app_secret")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        The OAuth 2.0 scopes that will be requested as part of Facebook login authentication. <https://developers.facebook.com/docs/facebook-login>
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class FunctionAppAuthSettingsGoogle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppAuthSettingsGoogle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppAuthSettingsGoogle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppAuthSettingsGoogle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OpenID Connect Client ID for the Google web application.
        :param str client_secret: The client secret associated with the Google web application.
        :param Sequence[str] oauth_scopes: The OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. <https://developers.google.com/identity/sign-in/web/>
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OpenID Connect Client ID for the Google web application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The client secret associated with the Google web application.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        The OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. <https://developers.google.com/identity/sign-in/web/>
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class FunctionAppAuthSettingsMicrosoft(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppAuthSettingsMicrosoft. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppAuthSettingsMicrosoft.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppAuthSettingsMicrosoft.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret: The OAuth 2.0 client secret that was created for the app used for authentication.
        :param Sequence[str] oauth_scopes: The OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. <https://msdn.microsoft.com/en-us/library/dn631845.aspx>
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        The OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. <https://msdn.microsoft.com/en-us/library/dn631845.aspx>
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class FunctionAppAuthSettingsTwitter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerKey":
            suggest = "consumer_key"
        elif key == "consumerSecret":
            suggest = "consumer_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppAuthSettingsTwitter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppAuthSettingsTwitter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppAuthSettingsTwitter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_key: str,
                 consumer_secret: str):
        """
        :param str consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param str consumer_secret: The OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        pulumi.set(__self__, "consumer_secret", consumer_secret)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> str:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> str:
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_secret")


@pulumi.output_type
class FunctionAppConnectionString(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: The name of the Connection String. Changing this forces a new resource to be created.
        :param str type: The type of the Connection String. Possible values are `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure` and  `SQLServer`.
        :param str value: The value for the Connection String.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Connection String. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the Connection String. Possible values are `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure` and  `SQLServer`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the Connection String.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class FunctionAppFunctionFile(dict):
    def __init__(__self__, *,
                 content: str,
                 name: str):
        """
        :param str content: The content of the file. Changing this forces a new resource to be created.
        :param str name: The filename of the file to be uploaded. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def content(self) -> str:
        """
        The content of the file. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The filename of the file to be uploaded. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class FunctionAppIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 identity_ids: Optional[Sequence[str]] = None,
                 principal_id: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str type: Specifies the identity type of the Function App. Possible values are `SystemAssigned` (where Azure will generate a Service Principal for you), `UserAssigned` where you can specify the Service Principal IDs in the `identity_ids` field, and `SystemAssigned, UserAssigned` which assigns both a system managed identity as well as the specified user assigned identities.
        :param Sequence[str] identity_ids: Specifies a list of user managed identity ids to be assigned. Required if `type` is `UserAssigned`.
        :param str principal_id: The Principal ID for the Service Principal associated with the Managed Service Identity of this App Service.
        :param str tenant_id: The Tenant ID for the Service Principal associated with the Managed Service Identity of this App Service.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the identity type of the Function App. Possible values are `SystemAssigned` (where Azure will generate a Service Principal for you), `UserAssigned` where you can specify the Service Principal IDs in the `identity_ids` field, and `SystemAssigned, UserAssigned` which assigns both a system managed identity as well as the specified user assigned identities.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of user managed identity ids to be assigned. Required if `type` is `UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        """
        The Principal ID for the Service Principal associated with the Managed Service Identity of this App Service.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The Tenant ID for the Service Principal associated with the Managed Service Identity of this App Service.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class FunctionAppSiteConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alwaysOn":
            suggest = "always_on"
        elif key == "appScaleLimit":
            suggest = "app_scale_limit"
        elif key == "autoSwapSlotName":
            suggest = "auto_swap_slot_name"
        elif key == "dotnetFrameworkVersion":
            suggest = "dotnet_framework_version"
        elif key == "elasticInstanceMinimum":
            suggest = "elastic_instance_minimum"
        elif key == "ftpsState":
            suggest = "ftps_state"
        elif key == "healthCheckPath":
            suggest = "health_check_path"
        elif key == "http2Enabled":
            suggest = "http2_enabled"
        elif key == "ipRestrictions":
            suggest = "ip_restrictions"
        elif key == "javaVersion":
            suggest = "java_version"
        elif key == "linuxFxVersion":
            suggest = "linux_fx_version"
        elif key == "minTlsVersion":
            suggest = "min_tls_version"
        elif key == "preWarmedInstanceCount":
            suggest = "pre_warmed_instance_count"
        elif key == "runtimeScaleMonitoringEnabled":
            suggest = "runtime_scale_monitoring_enabled"
        elif key == "scmIpRestrictions":
            suggest = "scm_ip_restrictions"
        elif key == "scmType":
            suggest = "scm_type"
        elif key == "scmUseMainIpRestriction":
            suggest = "scm_use_main_ip_restriction"
        elif key == "use32BitWorkerProcess":
            suggest = "use32_bit_worker_process"
        elif key == "vnetRouteAllEnabled":
            suggest = "vnet_route_all_enabled"
        elif key == "websocketsEnabled":
            suggest = "websockets_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppSiteConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppSiteConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppSiteConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 always_on: Optional[bool] = None,
                 app_scale_limit: Optional[int] = None,
                 auto_swap_slot_name: Optional[str] = None,
                 cors: Optional['outputs.FunctionAppSiteConfigCors'] = None,
                 dotnet_framework_version: Optional[str] = None,
                 elastic_instance_minimum: Optional[int] = None,
                 ftps_state: Optional[str] = None,
                 health_check_path: Optional[str] = None,
                 http2_enabled: Optional[bool] = None,
                 ip_restrictions: Optional[Sequence['outputs.FunctionAppSiteConfigIpRestriction']] = None,
                 java_version: Optional[str] = None,
                 linux_fx_version: Optional[str] = None,
                 min_tls_version: Optional[str] = None,
                 pre_warmed_instance_count: Optional[int] = None,
                 runtime_scale_monitoring_enabled: Optional[bool] = None,
                 scm_ip_restrictions: Optional[Sequence['outputs.FunctionAppSiteConfigScmIpRestriction']] = None,
                 scm_type: Optional[str] = None,
                 scm_use_main_ip_restriction: Optional[bool] = None,
                 use32_bit_worker_process: Optional[bool] = None,
                 vnet_route_all_enabled: Optional[bool] = None,
                 websockets_enabled: Optional[bool] = None):
        """
        :param bool always_on: Should the Function App be loaded at all times? Defaults to `false`.
        :param int app_scale_limit: The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
        :param 'FunctionAppSiteConfigCorsArgs' cors: A `cors` block as defined below.
        :param str dotnet_framework_version: The version of the .NET framework's CLR used in this function app. Possible values are `v4.0` (including .NET Core 2.1 and 3.1), `v5.0` and `v6.0`. [For more information on which .NET Framework version to use based on the runtime version you're targeting - please see this table](https://docs.microsoft.com/azure/azure-functions/functions-dotnet-class-library#supported-versions). Defaults to `v4.0`.
        :param int elastic_instance_minimum: The number of minimum instances for this function app. Only affects apps on the Premium plan.
        :param str ftps_state: State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`. Defaults to `AllAllowed`.
        :param str health_check_path: Path which will be checked for this function app health.
        :param bool http2_enabled: Specifies whether or not the HTTP2 protocol should be enabled. Defaults to `false`.
        :param Sequence['FunctionAppSiteConfigIpRestrictionArgs'] ip_restrictions: A [List of objects](https://www.terraform.io/docs/configuration/attr-as-blocks.html) representing IP restrictions as defined below.
        :param str java_version: Java version hosted by the function app in Azure. Possible values are `1.8`, `11` & `17` (In-Preview).
        :param str linux_fx_version: Linux App Framework and version for the AppService, e.g. `DOCKER|(golang:latest)`.
        :param str min_tls_version: The minimum supported TLS version for the function app. Possible values are `1.0`, `1.1`, and `1.2`. Defaults to `1.2` for new function apps.
        :param int pre_warmed_instance_count: The number of pre-warmed instances for this function app. Only affects apps on the Premium plan.
        :param bool runtime_scale_monitoring_enabled: Should Runtime Scale Monitoring be enabled?. Only applicable to apps on the Premium plan. Defaults to `false`.
        :param Sequence['FunctionAppSiteConfigScmIpRestrictionArgs'] scm_ip_restrictions: A [List of objects](https://www.terraform.io/docs/configuration/attr-as-blocks.html) representing IP restrictions as defined below.
        :param str scm_type: The type of Source Control used by the Function App. Valid values include: `BitBucketGit`, `BitBucketHg`, `CodePlexGit`, `CodePlexHg`, `Dropbox`, `ExternalGit`, `ExternalHg`, `GitHub`, `LocalGit`, `None` (default), `OneDrive`, `Tfs`, `VSO`, and `VSTSRM`
        :param bool scm_use_main_ip_restriction: IP security restrictions for scm to use main. Defaults to false.
        :param bool use32_bit_worker_process: Should the Function App run in 32 bit mode, rather than 64 bit mode? Defaults to `true`.
        :param bool vnet_route_all_enabled: Should all outbound traffic to have Virtual Network Security Groups and User Defined Routes applied? Defaults to `false`.
        :param bool websockets_enabled: Should WebSockets be enabled?
        """
        if always_on is not None:
            pulumi.set(__self__, "always_on", always_on)
        if app_scale_limit is not None:
            pulumi.set(__self__, "app_scale_limit", app_scale_limit)
        if auto_swap_slot_name is not None:
            pulumi.set(__self__, "auto_swap_slot_name", auto_swap_slot_name)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if dotnet_framework_version is not None:
            pulumi.set(__self__, "dotnet_framework_version", dotnet_framework_version)
        if elastic_instance_minimum is not None:
            pulumi.set(__self__, "elastic_instance_minimum", elastic_instance_minimum)
        if ftps_state is not None:
            pulumi.set(__self__, "ftps_state", ftps_state)
        if health_check_path is not None:
            pulumi.set(__self__, "health_check_path", health_check_path)
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if ip_restrictions is not None:
            pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        if java_version is not None:
            pulumi.set(__self__, "java_version", java_version)
        if linux_fx_version is not None:
            pulumi.set(__self__, "linux_fx_version", linux_fx_version)
        if min_tls_version is not None:
            pulumi.set(__self__, "min_tls_version", min_tls_version)
        if pre_warmed_instance_count is not None:
            pulumi.set(__self__, "pre_warmed_instance_count", pre_warmed_instance_count)
        if runtime_scale_monitoring_enabled is not None:
            pulumi.set(__self__, "runtime_scale_monitoring_enabled", runtime_scale_monitoring_enabled)
        if scm_ip_restrictions is not None:
            pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        if scm_type is not None:
            pulumi.set(__self__, "scm_type", scm_type)
        if scm_use_main_ip_restriction is not None:
            pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        if use32_bit_worker_process is not None:
            pulumi.set(__self__, "use32_bit_worker_process", use32_bit_worker_process)
        if vnet_route_all_enabled is not None:
            pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        if websockets_enabled is not None:
            pulumi.set(__self__, "websockets_enabled", websockets_enabled)

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> Optional[bool]:
        """
        Should the Function App be loaded at all times? Defaults to `false`.
        """
        return pulumi.get(self, "always_on")

    @property
    @pulumi.getter(name="appScaleLimit")
    def app_scale_limit(self) -> Optional[int]:
        """
        The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
        """
        return pulumi.get(self, "app_scale_limit")

    @property
    @pulumi.getter(name="autoSwapSlotName")
    def auto_swap_slot_name(self) -> Optional[str]:
        return pulumi.get(self, "auto_swap_slot_name")

    @property
    @pulumi.getter
    def cors(self) -> Optional['outputs.FunctionAppSiteConfigCors']:
        """
        A `cors` block as defined below.
        """
        return pulumi.get(self, "cors")

    @property
    @pulumi.getter(name="dotnetFrameworkVersion")
    def dotnet_framework_version(self) -> Optional[str]:
        """
        The version of the .NET framework's CLR used in this function app. Possible values are `v4.0` (including .NET Core 2.1 and 3.1), `v5.0` and `v6.0`. [For more information on which .NET Framework version to use based on the runtime version you're targeting - please see this table](https://docs.microsoft.com/azure/azure-functions/functions-dotnet-class-library#supported-versions). Defaults to `v4.0`.
        """
        return pulumi.get(self, "dotnet_framework_version")

    @property
    @pulumi.getter(name="elasticInstanceMinimum")
    def elastic_instance_minimum(self) -> Optional[int]:
        """
        The number of minimum instances for this function app. Only affects apps on the Premium plan.
        """
        return pulumi.get(self, "elastic_instance_minimum")

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> Optional[str]:
        """
        State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`. Defaults to `AllAllowed`.
        """
        return pulumi.get(self, "ftps_state")

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> Optional[str]:
        """
        Path which will be checked for this function app health.
        """
        return pulumi.get(self, "health_check_path")

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[bool]:
        """
        Specifies whether or not the HTTP2 protocol should be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "http2_enabled")

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Optional[Sequence['outputs.FunctionAppSiteConfigIpRestriction']]:
        """
        A [List of objects](https://www.terraform.io/docs/configuration/attr-as-blocks.html) representing IP restrictions as defined below.
        """
        return pulumi.get(self, "ip_restrictions")

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> Optional[str]:
        """
        Java version hosted by the function app in Azure. Possible values are `1.8`, `11` & `17` (In-Preview).
        """
        return pulumi.get(self, "java_version")

    @property
    @pulumi.getter(name="linuxFxVersion")
    def linux_fx_version(self) -> Optional[str]:
        """
        Linux App Framework and version for the AppService, e.g. `DOCKER|(golang:latest)`.
        """
        return pulumi.get(self, "linux_fx_version")

    @property
    @pulumi.getter(name="minTlsVersion")
    def min_tls_version(self) -> Optional[str]:
        """
        The minimum supported TLS version for the function app. Possible values are `1.0`, `1.1`, and `1.2`. Defaults to `1.2` for new function apps.
        """
        return pulumi.get(self, "min_tls_version")

    @property
    @pulumi.getter(name="preWarmedInstanceCount")
    def pre_warmed_instance_count(self) -> Optional[int]:
        """
        The number of pre-warmed instances for this function app. Only affects apps on the Premium plan.
        """
        return pulumi.get(self, "pre_warmed_instance_count")

    @property
    @pulumi.getter(name="runtimeScaleMonitoringEnabled")
    def runtime_scale_monitoring_enabled(self) -> Optional[bool]:
        """
        Should Runtime Scale Monitoring be enabled?. Only applicable to apps on the Premium plan. Defaults to `false`.
        """
        return pulumi.get(self, "runtime_scale_monitoring_enabled")

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Optional[Sequence['outputs.FunctionAppSiteConfigScmIpRestriction']]:
        """
        A [List of objects](https://www.terraform.io/docs/configuration/attr-as-blocks.html) representing IP restrictions as defined below.
        """
        return pulumi.get(self, "scm_ip_restrictions")

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> Optional[str]:
        """
        The type of Source Control used by the Function App. Valid values include: `BitBucketGit`, `BitBucketHg`, `CodePlexGit`, `CodePlexHg`, `Dropbox`, `ExternalGit`, `ExternalHg`, `GitHub`, `LocalGit`, `None` (default), `OneDrive`, `Tfs`, `VSO`, and `VSTSRM`
        """
        return pulumi.get(self, "scm_type")

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> Optional[bool]:
        """
        IP security restrictions for scm to use main. Defaults to false.
        """
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @property
    @pulumi.getter(name="use32BitWorkerProcess")
    def use32_bit_worker_process(self) -> Optional[bool]:
        """
        Should the Function App run in 32 bit mode, rather than 64 bit mode? Defaults to `true`.
        """
        return pulumi.get(self, "use32_bit_worker_process")

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> Optional[bool]:
        """
        Should all outbound traffic to have Virtual Network Security Groups and User Defined Routes applied? Defaults to `false`.
        """
        return pulumi.get(self, "vnet_route_all_enabled")

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> Optional[bool]:
        """
        Should WebSockets be enabled?
        """
        return pulumi.get(self, "websockets_enabled")


@pulumi.output_type
class FunctionAppSiteConfigCors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedOrigins":
            suggest = "allowed_origins"
        elif key == "supportCredentials":
            suggest = "support_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppSiteConfigCors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppSiteConfigCors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppSiteConfigCors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_origins: Sequence[str],
                 support_credentials: Optional[bool] = None):
        """
        :param Sequence[str] allowed_origins: A list of origins which should be able to make cross-origin calls. `*` can be used to allow all calls.
        :param bool support_credentials: Are credentials supported?
        """
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        if support_credentials is not None:
            pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Sequence[str]:
        """
        A list of origins which should be able to make cross-origin calls. `*` can be used to allow all calls.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> Optional[bool]:
        """
        Are credentials supported?
        """
        return pulumi.get(self, "support_credentials")


@pulumi.output_type
class FunctionAppSiteConfigIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppSiteConfigIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppSiteConfigIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppSiteConfigIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.FunctionAppSiteConfigIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: Does this restriction `Allow` or `Deny` access for this IP range. Defaults to `Allow`.
        :param 'FunctionAppSiteConfigIpRestrictionHeadersArgs' headers: The headers for this specific `ip_restriction` as defined below.
        :param str ip_address: The IP Address used for this IP Restriction in CIDR notation.
        :param str name: The name for this IP Restriction.
        :param int priority: The priority for this IP Restriction. Restrictions are enforced in priority order. By default, the priority is set to 65000 if not specified.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        Does this restriction `Allow` or `Deny` access for this IP range. Defaults to `Allow`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.FunctionAppSiteConfigIpRestrictionHeaders']:
        """
        The headers for this specific `ip_restriction` as defined below.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The IP Address used for this IP Restriction in CIDR notation.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name for this IP Restriction.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority for this IP Restriction. Restrictions are enforced in priority order. By default, the priority is set to 65000 if not specified.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class FunctionAppSiteConfigIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppSiteConfigIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        :param str x_fd_health_probe: A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        :param Sequence[str] x_forwarded_fors: A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        :param Sequence[str] x_forwarded_hosts: A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class FunctionAppSiteConfigScmIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppSiteConfigScmIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppSiteConfigScmIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppSiteConfigScmIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.FunctionAppSiteConfigScmIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: Allow or Deny access for this IP range. Defaults to Allow.
        :param 'FunctionAppSiteConfigScmIpRestrictionHeadersArgs' headers: The headers for this specific `scm_ip_restriction` as defined below.
        :param str ip_address: The IP Address used for this IP Restriction in CIDR notation.
        :param str name: The name for this IP Restriction.
        :param int priority: The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        Allow or Deny access for this IP range. Defaults to Allow.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.FunctionAppSiteConfigScmIpRestrictionHeaders']:
        """
        The headers for this specific `scm_ip_restriction` as defined below.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The IP Address used for this IP Restriction in CIDR notation.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name for this IP Restriction.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class FunctionAppSiteConfigScmIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppSiteConfigScmIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        :param str x_fd_health_probe: A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        :param Sequence[str] x_forwarded_fors: A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        :param Sequence[str] x_forwarded_hosts: A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class FunctionAppSiteCredential(dict):
    def __init__(__self__, *,
                 password: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str password: The password associated with the username, which can be used to publish to this App Service.
        :param str username: The username which can be used to publish to this App Service
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password associated with the username, which can be used to publish to this App Service.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username which can be used to publish to this App Service
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class FunctionAppSlotAuthSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeDirectory":
            suggest = "active_directory"
        elif key == "additionalLoginParams":
            suggest = "additional_login_params"
        elif key == "allowedExternalRedirectUrls":
            suggest = "allowed_external_redirect_urls"
        elif key == "defaultProvider":
            suggest = "default_provider"
        elif key == "runtimeVersion":
            suggest = "runtime_version"
        elif key == "tokenRefreshExtensionHours":
            suggest = "token_refresh_extension_hours"
        elif key == "tokenStoreEnabled":
            suggest = "token_store_enabled"
        elif key == "unauthenticatedClientAction":
            suggest = "unauthenticated_client_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppSlotAuthSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppSlotAuthSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppSlotAuthSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 active_directory: Optional['outputs.FunctionAppSlotAuthSettingsActiveDirectory'] = None,
                 additional_login_params: Optional[Mapping[str, str]] = None,
                 allowed_external_redirect_urls: Optional[Sequence[str]] = None,
                 default_provider: Optional[str] = None,
                 facebook: Optional['outputs.FunctionAppSlotAuthSettingsFacebook'] = None,
                 google: Optional['outputs.FunctionAppSlotAuthSettingsGoogle'] = None,
                 issuer: Optional[str] = None,
                 microsoft: Optional['outputs.FunctionAppSlotAuthSettingsMicrosoft'] = None,
                 runtime_version: Optional[str] = None,
                 token_refresh_extension_hours: Optional[float] = None,
                 token_store_enabled: Optional[bool] = None,
                 twitter: Optional['outputs.FunctionAppSlotAuthSettingsTwitter'] = None,
                 unauthenticated_client_action: Optional[str] = None):
        """
        :param bool enabled: Is Authentication enabled?
        :param 'FunctionAppSlotAuthSettingsActiveDirectoryArgs' active_directory: An `active_directory` block as defined below.
        :param Mapping[str, str] additional_login_params: login parameters to send to the OpenID Connect authorization endpoint when a user logs in. Each parameter must be in the form "key=value".
        :param Sequence[str] allowed_external_redirect_urls: External URLs that can be redirected to as part of logging in or logging out of the app.
        :param str default_provider: The default provider to use when multiple providers have been set up. Possible values are `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount` and `Twitter`.
        :param 'FunctionAppSlotAuthSettingsFacebookArgs' facebook: A `facebook` block as defined below.
        :param 'FunctionAppSlotAuthSettingsGoogleArgs' google: A `google` block as defined below.
        :param str issuer: Issuer URI. When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        :param 'FunctionAppSlotAuthSettingsMicrosoftArgs' microsoft: A `microsoft` block as defined below.
        :param str runtime_version: The runtime version of the Authentication/Authorization module.
        :param float token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to 72.
        :param bool token_store_enabled: If enabled the module will durably store platform-specific security tokens that are obtained during login flows. Defaults to false.
        :param 'FunctionAppSlotAuthSettingsTwitterArgs' twitter: A `twitter` block as defined below.
        :param str unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app. Possible values are `AllowAnonymous` and `RedirectToLoginPage`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if active_directory is not None:
            pulumi.set(__self__, "active_directory", active_directory)
        if additional_login_params is not None:
            pulumi.set(__self__, "additional_login_params", additional_login_params)
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if facebook is not None:
            pulumi.set(__self__, "facebook", facebook)
        if google is not None:
            pulumi.set(__self__, "google", google)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if microsoft is not None:
            pulumi.set(__self__, "microsoft", microsoft)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if token_refresh_extension_hours is not None:
            pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if twitter is not None:
            pulumi.set(__self__, "twitter", twitter)
        if unauthenticated_client_action is not None:
            pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is Authentication enabled?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="activeDirectory")
    def active_directory(self) -> Optional['outputs.FunctionAppSlotAuthSettingsActiveDirectory']:
        """
        An `active_directory` block as defined below.
        """
        return pulumi.get(self, "active_directory")

    @property
    @pulumi.getter(name="additionalLoginParams")
    def additional_login_params(self) -> Optional[Mapping[str, str]]:
        """
        login parameters to send to the OpenID Connect authorization endpoint when a user logs in. Each parameter must be in the form "key=value".
        """
        return pulumi.get(self, "additional_login_params")

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[Sequence[str]]:
        """
        External URLs that can be redirected to as part of logging in or logging out of the app.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[str]:
        """
        The default provider to use when multiple providers have been set up. Possible values are `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount` and `Twitter`.
        """
        return pulumi.get(self, "default_provider")

    @property
    @pulumi.getter
    def facebook(self) -> Optional['outputs.FunctionAppSlotAuthSettingsFacebook']:
        """
        A `facebook` block as defined below.
        """
        return pulumi.get(self, "facebook")

    @property
    @pulumi.getter
    def google(self) -> Optional['outputs.FunctionAppSlotAuthSettingsGoogle']:
        """
        A `google` block as defined below.
        """
        return pulumi.get(self, "google")

    @property
    @pulumi.getter
    def issuer(self) -> Optional[str]:
        """
        Issuer URI. When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def microsoft(self) -> Optional['outputs.FunctionAppSlotAuthSettingsMicrosoft']:
        """
        A `microsoft` block as defined below.
        """
        return pulumi.get(self, "microsoft")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[str]:
        """
        The runtime version of the Authentication/Authorization module.
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> Optional[float]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to 72.
        """
        return pulumi.get(self, "token_refresh_extension_hours")

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[bool]:
        """
        If enabled the module will durably store platform-specific security tokens that are obtained during login flows. Defaults to false.
        """
        return pulumi.get(self, "token_store_enabled")

    @property
    @pulumi.getter
    def twitter(self) -> Optional['outputs.FunctionAppSlotAuthSettingsTwitter']:
        """
        A `twitter` block as defined below.
        """
        return pulumi.get(self, "twitter")

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> Optional[str]:
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values are `AllowAnonymous` and `RedirectToLoginPage`.
        """
        return pulumi.get(self, "unauthenticated_client_action")


@pulumi.output_type
class FunctionAppSlotAuthSettingsActiveDirectory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "clientSecret":
            suggest = "client_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppSlotAuthSettingsActiveDirectory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppSlotAuthSettingsActiveDirectory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppSlotAuthSettingsActiveDirectory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 client_secret: Optional[str] = None):
        """
        :param str client_id: The Client ID of this relying party application. Enables OpenIDConnection authentication with Azure Active Directory.
        :param Sequence[str] allowed_audiences: Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
        :param str client_secret: The Client Secret of this relying party application. If no secret is provided, implicit flow will be used.
        """
        pulumi.set(__self__, "client_id", client_id)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The Client ID of this relying party application. Enables OpenIDConnection authentication with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret of this relying party application. If no secret is provided, implicit flow will be used.
        """
        return pulumi.get(self, "client_secret")


@pulumi.output_type
class FunctionAppSlotAuthSettingsFacebook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "appSecret":
            suggest = "app_secret"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppSlotAuthSettingsFacebook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppSlotAuthSettingsFacebook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppSlotAuthSettingsFacebook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: str,
                 app_secret: str,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str app_id: The App ID of the Facebook app used for login
        :param str app_secret: The App Secret of the Facebook app used for Facebook login.
        :param Sequence[str] oauth_scopes: The OAuth 2.0 scopes that will be requested as part of Facebook login authentication. <https://developers.facebook.com/docs/facebook-login>
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "app_secret", app_secret)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        The App ID of the Facebook app used for login
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appSecret")
    def app_secret(self) -> str:
        """
        The App Secret of the Facebook app used for Facebook login.
        """
        return pulumi.get(self, "app_secret")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        The OAuth 2.0 scopes that will be requested as part of Facebook login authentication. <https://developers.facebook.com/docs/facebook-login>
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class FunctionAppSlotAuthSettingsGoogle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppSlotAuthSettingsGoogle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppSlotAuthSettingsGoogle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppSlotAuthSettingsGoogle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OpenID Connect Client ID for the Google web application.
        :param str client_secret: The client secret associated with the Google web application.
        :param Sequence[str] oauth_scopes: The OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. <https://developers.google.com/identity/sign-in/web/>
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OpenID Connect Client ID for the Google web application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The client secret associated with the Google web application.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        The OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. <https://developers.google.com/identity/sign-in/web/>
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class FunctionAppSlotAuthSettingsMicrosoft(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppSlotAuthSettingsMicrosoft. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppSlotAuthSettingsMicrosoft.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppSlotAuthSettingsMicrosoft.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret: The OAuth 2.0 client secret that was created for the app used for authentication.
        :param Sequence[str] oauth_scopes: The OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. <https://msdn.microsoft.com/en-us/library/dn631845.aspx>
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        The OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. <https://msdn.microsoft.com/en-us/library/dn631845.aspx>
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class FunctionAppSlotAuthSettingsTwitter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerKey":
            suggest = "consumer_key"
        elif key == "consumerSecret":
            suggest = "consumer_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppSlotAuthSettingsTwitter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppSlotAuthSettingsTwitter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppSlotAuthSettingsTwitter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_key: str,
                 consumer_secret: str):
        """
        :param str consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param str consumer_secret: The OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        pulumi.set(__self__, "consumer_secret", consumer_secret)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> str:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> str:
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_secret")


@pulumi.output_type
class FunctionAppSlotConnectionString(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: The name of the Connection String. Changing this forces a new resource to be created.
        :param str type: The type of the Connection String. Possible values are `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure` and  `SQLServer`.
        :param str value: The value for the Connection String.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Connection String. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the Connection String. Possible values are `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure` and  `SQLServer`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the Connection String.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class FunctionAppSlotIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppSlotIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppSlotIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppSlotIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 identity_ids: Optional[Sequence[str]] = None,
                 principal_id: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str type: Specifies the identity type of the Function App. Possible values are `SystemAssigned` (where Azure will generate a Service Principal for you), `UserAssigned` where you can specify the Service Principal IDs in the `identity_ids` field, and `SystemAssigned, UserAssigned` which assigns both a system managed identity as well as the specified user assigned identities.
        :param Sequence[str] identity_ids: Specifies a list of user managed identity ids to be assigned. Required if `type` is `UserAssigned`.
        :param str principal_id: The Principal ID for the Service Principal associated with the Managed Service Identity of this App Service.
        :param str tenant_id: The Tenant ID for the Service Principal associated with the Managed Service Identity of this App Service.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the identity type of the Function App. Possible values are `SystemAssigned` (where Azure will generate a Service Principal for you), `UserAssigned` where you can specify the Service Principal IDs in the `identity_ids` field, and `SystemAssigned, UserAssigned` which assigns both a system managed identity as well as the specified user assigned identities.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of user managed identity ids to be assigned. Required if `type` is `UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        """
        The Principal ID for the Service Principal associated with the Managed Service Identity of this App Service.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The Tenant ID for the Service Principal associated with the Managed Service Identity of this App Service.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class FunctionAppSlotSiteConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alwaysOn":
            suggest = "always_on"
        elif key == "appScaleLimit":
            suggest = "app_scale_limit"
        elif key == "autoSwapSlotName":
            suggest = "auto_swap_slot_name"
        elif key == "dotnetFrameworkVersion":
            suggest = "dotnet_framework_version"
        elif key == "elasticInstanceMinimum":
            suggest = "elastic_instance_minimum"
        elif key == "ftpsState":
            suggest = "ftps_state"
        elif key == "healthCheckPath":
            suggest = "health_check_path"
        elif key == "http2Enabled":
            suggest = "http2_enabled"
        elif key == "ipRestrictions":
            suggest = "ip_restrictions"
        elif key == "javaVersion":
            suggest = "java_version"
        elif key == "linuxFxVersion":
            suggest = "linux_fx_version"
        elif key == "minTlsVersion":
            suggest = "min_tls_version"
        elif key == "preWarmedInstanceCount":
            suggest = "pre_warmed_instance_count"
        elif key == "runtimeScaleMonitoringEnabled":
            suggest = "runtime_scale_monitoring_enabled"
        elif key == "scmIpRestrictions":
            suggest = "scm_ip_restrictions"
        elif key == "scmType":
            suggest = "scm_type"
        elif key == "scmUseMainIpRestriction":
            suggest = "scm_use_main_ip_restriction"
        elif key == "use32BitWorkerProcess":
            suggest = "use32_bit_worker_process"
        elif key == "vnetRouteAllEnabled":
            suggest = "vnet_route_all_enabled"
        elif key == "websocketsEnabled":
            suggest = "websockets_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppSlotSiteConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppSlotSiteConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppSlotSiteConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 always_on: Optional[bool] = None,
                 app_scale_limit: Optional[int] = None,
                 auto_swap_slot_name: Optional[str] = None,
                 cors: Optional['outputs.FunctionAppSlotSiteConfigCors'] = None,
                 dotnet_framework_version: Optional[str] = None,
                 elastic_instance_minimum: Optional[int] = None,
                 ftps_state: Optional[str] = None,
                 health_check_path: Optional[str] = None,
                 http2_enabled: Optional[bool] = None,
                 ip_restrictions: Optional[Sequence['outputs.FunctionAppSlotSiteConfigIpRestriction']] = None,
                 java_version: Optional[str] = None,
                 linux_fx_version: Optional[str] = None,
                 min_tls_version: Optional[str] = None,
                 pre_warmed_instance_count: Optional[int] = None,
                 runtime_scale_monitoring_enabled: Optional[bool] = None,
                 scm_ip_restrictions: Optional[Sequence['outputs.FunctionAppSlotSiteConfigScmIpRestriction']] = None,
                 scm_type: Optional[str] = None,
                 scm_use_main_ip_restriction: Optional[bool] = None,
                 use32_bit_worker_process: Optional[bool] = None,
                 vnet_route_all_enabled: Optional[bool] = None,
                 websockets_enabled: Optional[bool] = None):
        """
        :param bool always_on: Should the Function App be loaded at all times? Defaults to `false`.
        :param int app_scale_limit: The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
        :param str auto_swap_slot_name: The name of the slot to automatically swap to during deployment
        :param 'FunctionAppSlotSiteConfigCorsArgs' cors: A `cors` block as defined below.
        :param str dotnet_framework_version: The version of the .NET framework's CLR used in this function app. Possible values are `v4.0` (including .NET Core 2.1 and 3.1), `v5.0` and `v6.0`. [For more information on which .NET Framework version to use based on the runtime version you're targeting - please see this table](https://docs.microsoft.com/azure/azure-functions/functions-dotnet-class-library#supported-versions). Defaults to `v4.0`.
        :param int elastic_instance_minimum: The number of minimum instances for this function app. Only applicable to apps on the Premium plan.
        :param str ftps_state: State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`.
        :param bool http2_enabled: Specifies whether or not the HTTP2 protocol should be enabled. Defaults to `false`.
        :param Sequence['FunctionAppSlotSiteConfigIpRestrictionArgs'] ip_restrictions: A [List of objects](https://www.terraform.io/docs/configuration/attr-as-blocks.html) representing IP restrictions as defined below.
        :param str linux_fx_version: Linux App Framework and version for the AppService, e.g. `DOCKER|(golang:latest)`.
        :param str min_tls_version: The minimum supported TLS version for the function app. Possible values are `1.0`, `1.1`, and `1.2`. Defaults to `1.2` for new function apps.
        :param int pre_warmed_instance_count: The number of pre-warmed instances for this function app. Only affects apps on the Premium plan.
        :param bool runtime_scale_monitoring_enabled: Should Runtime Scale Monitoring be enabled?. Only applicable to apps on the Premium plan. Defaults to `false`.
        :param bool use32_bit_worker_process: Should the Function App run in 32 bit mode, rather than 64 bit mode? Defaults to `true`.
        :param bool websockets_enabled: Should WebSockets be enabled?
        """
        if always_on is not None:
            pulumi.set(__self__, "always_on", always_on)
        if app_scale_limit is not None:
            pulumi.set(__self__, "app_scale_limit", app_scale_limit)
        if auto_swap_slot_name is not None:
            pulumi.set(__self__, "auto_swap_slot_name", auto_swap_slot_name)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if dotnet_framework_version is not None:
            pulumi.set(__self__, "dotnet_framework_version", dotnet_framework_version)
        if elastic_instance_minimum is not None:
            pulumi.set(__self__, "elastic_instance_minimum", elastic_instance_minimum)
        if ftps_state is not None:
            pulumi.set(__self__, "ftps_state", ftps_state)
        if health_check_path is not None:
            pulumi.set(__self__, "health_check_path", health_check_path)
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if ip_restrictions is not None:
            pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        if java_version is not None:
            pulumi.set(__self__, "java_version", java_version)
        if linux_fx_version is not None:
            pulumi.set(__self__, "linux_fx_version", linux_fx_version)
        if min_tls_version is not None:
            pulumi.set(__self__, "min_tls_version", min_tls_version)
        if pre_warmed_instance_count is not None:
            pulumi.set(__self__, "pre_warmed_instance_count", pre_warmed_instance_count)
        if runtime_scale_monitoring_enabled is not None:
            pulumi.set(__self__, "runtime_scale_monitoring_enabled", runtime_scale_monitoring_enabled)
        if scm_ip_restrictions is not None:
            pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        if scm_type is not None:
            pulumi.set(__self__, "scm_type", scm_type)
        if scm_use_main_ip_restriction is not None:
            pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        if use32_bit_worker_process is not None:
            pulumi.set(__self__, "use32_bit_worker_process", use32_bit_worker_process)
        if vnet_route_all_enabled is not None:
            pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        if websockets_enabled is not None:
            pulumi.set(__self__, "websockets_enabled", websockets_enabled)

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> Optional[bool]:
        """
        Should the Function App be loaded at all times? Defaults to `false`.
        """
        return pulumi.get(self, "always_on")

    @property
    @pulumi.getter(name="appScaleLimit")
    def app_scale_limit(self) -> Optional[int]:
        """
        The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
        """
        return pulumi.get(self, "app_scale_limit")

    @property
    @pulumi.getter(name="autoSwapSlotName")
    def auto_swap_slot_name(self) -> Optional[str]:
        """
        The name of the slot to automatically swap to during deployment
        """
        return pulumi.get(self, "auto_swap_slot_name")

    @property
    @pulumi.getter
    def cors(self) -> Optional['outputs.FunctionAppSlotSiteConfigCors']:
        """
        A `cors` block as defined below.
        """
        return pulumi.get(self, "cors")

    @property
    @pulumi.getter(name="dotnetFrameworkVersion")
    def dotnet_framework_version(self) -> Optional[str]:
        """
        The version of the .NET framework's CLR used in this function app. Possible values are `v4.0` (including .NET Core 2.1 and 3.1), `v5.0` and `v6.0`. [For more information on which .NET Framework version to use based on the runtime version you're targeting - please see this table](https://docs.microsoft.com/azure/azure-functions/functions-dotnet-class-library#supported-versions). Defaults to `v4.0`.
        """
        return pulumi.get(self, "dotnet_framework_version")

    @property
    @pulumi.getter(name="elasticInstanceMinimum")
    def elastic_instance_minimum(self) -> Optional[int]:
        """
        The number of minimum instances for this function app. Only applicable to apps on the Premium plan.
        """
        return pulumi.get(self, "elastic_instance_minimum")

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> Optional[str]:
        """
        State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`.
        """
        return pulumi.get(self, "ftps_state")

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> Optional[str]:
        return pulumi.get(self, "health_check_path")

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[bool]:
        """
        Specifies whether or not the HTTP2 protocol should be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "http2_enabled")

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Optional[Sequence['outputs.FunctionAppSlotSiteConfigIpRestriction']]:
        """
        A [List of objects](https://www.terraform.io/docs/configuration/attr-as-blocks.html) representing IP restrictions as defined below.
        """
        return pulumi.get(self, "ip_restrictions")

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> Optional[str]:
        return pulumi.get(self, "java_version")

    @property
    @pulumi.getter(name="linuxFxVersion")
    def linux_fx_version(self) -> Optional[str]:
        """
        Linux App Framework and version for the AppService, e.g. `DOCKER|(golang:latest)`.
        """
        return pulumi.get(self, "linux_fx_version")

    @property
    @pulumi.getter(name="minTlsVersion")
    def min_tls_version(self) -> Optional[str]:
        """
        The minimum supported TLS version for the function app. Possible values are `1.0`, `1.1`, and `1.2`. Defaults to `1.2` for new function apps.
        """
        return pulumi.get(self, "min_tls_version")

    @property
    @pulumi.getter(name="preWarmedInstanceCount")
    def pre_warmed_instance_count(self) -> Optional[int]:
        """
        The number of pre-warmed instances for this function app. Only affects apps on the Premium plan.
        """
        return pulumi.get(self, "pre_warmed_instance_count")

    @property
    @pulumi.getter(name="runtimeScaleMonitoringEnabled")
    def runtime_scale_monitoring_enabled(self) -> Optional[bool]:
        """
        Should Runtime Scale Monitoring be enabled?. Only applicable to apps on the Premium plan. Defaults to `false`.
        """
        return pulumi.get(self, "runtime_scale_monitoring_enabled")

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Optional[Sequence['outputs.FunctionAppSlotSiteConfigScmIpRestriction']]:
        return pulumi.get(self, "scm_ip_restrictions")

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> Optional[str]:
        return pulumi.get(self, "scm_type")

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> Optional[bool]:
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @property
    @pulumi.getter(name="use32BitWorkerProcess")
    def use32_bit_worker_process(self) -> Optional[bool]:
        """
        Should the Function App run in 32 bit mode, rather than 64 bit mode? Defaults to `true`.
        """
        return pulumi.get(self, "use32_bit_worker_process")

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "vnet_route_all_enabled")

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> Optional[bool]:
        """
        Should WebSockets be enabled?
        """
        return pulumi.get(self, "websockets_enabled")


@pulumi.output_type
class FunctionAppSlotSiteConfigCors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedOrigins":
            suggest = "allowed_origins"
        elif key == "supportCredentials":
            suggest = "support_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppSlotSiteConfigCors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppSlotSiteConfigCors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppSlotSiteConfigCors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_origins: Sequence[str],
                 support_credentials: Optional[bool] = None):
        """
        :param Sequence[str] allowed_origins: A list of origins which should be able to make cross-origin calls. `*` can be used to allow all calls.
        :param bool support_credentials: Are credentials supported?
        """
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        if support_credentials is not None:
            pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Sequence[str]:
        """
        A list of origins which should be able to make cross-origin calls. `*` can be used to allow all calls.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> Optional[bool]:
        """
        Are credentials supported?
        """
        return pulumi.get(self, "support_credentials")


@pulumi.output_type
class FunctionAppSlotSiteConfigIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppSlotSiteConfigIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppSlotSiteConfigIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppSlotSiteConfigIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.FunctionAppSlotSiteConfigIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: Does this restriction `Allow` or `Deny` access for this IP range. Defaults to `Allow`.
        :param 'FunctionAppSlotSiteConfigIpRestrictionHeadersArgs' headers: The headers for this specific `ip_restriction` as defined below.
        :param str ip_address: The IP Address used for this IP Restriction in CIDR notation.
        :param str name: The name for this IP Restriction.
        :param int priority: The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        Does this restriction `Allow` or `Deny` access for this IP range. Defaults to `Allow`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.FunctionAppSlotSiteConfigIpRestrictionHeaders']:
        """
        The headers for this specific `ip_restriction` as defined below.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The IP Address used for this IP Restriction in CIDR notation.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name for this IP Restriction.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class FunctionAppSlotSiteConfigIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppSlotSiteConfigIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppSlotSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppSlotSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        :param str x_fd_health_probe: A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        :param Sequence[str] x_forwarded_fors: A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        :param Sequence[str] x_forwarded_hosts: A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class FunctionAppSlotSiteConfigScmIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppSlotSiteConfigScmIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppSlotSiteConfigScmIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppSlotSiteConfigScmIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.FunctionAppSlotSiteConfigScmIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: Does this restriction `Allow` or `Deny` access for this IP range. Defaults to `Allow`.
        :param 'FunctionAppSlotSiteConfigScmIpRestrictionHeadersArgs' headers: The headers for this specific `ip_restriction` as defined below.
        :param str ip_address: The IP Address used for this IP Restriction in CIDR notation.
        :param str name: Specifies the name of the Function App. Changing this forces a new resource to be created.
        :param int priority: The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        Does this restriction `Allow` or `Deny` access for this IP range. Defaults to `Allow`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.FunctionAppSlotSiteConfigScmIpRestrictionHeaders']:
        """
        The headers for this specific `ip_restriction` as defined below.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The IP Address used for this IP Restriction in CIDR notation.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Specifies the name of the Function App. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class FunctionAppSlotSiteConfigScmIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppSlotSiteConfigScmIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppSlotSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppSlotSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        :param str x_fd_health_probe: A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        :param Sequence[str] x_forwarded_fors: A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        :param Sequence[str] x_forwarded_hosts: A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class FunctionAppSlotSiteCredential(dict):
    def __init__(__self__, *,
                 password: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str password: The password associated with the username, which can be used to publish to this App Service.
        :param str username: The username which can be used to publish to this App Service
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password associated with the username, which can be used to publish to this App Service.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username which can be used to publish to this App Service
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class FunctionAppSourceControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "manualIntegration":
            suggest = "manual_integration"
        elif key == "repoUrl":
            suggest = "repo_url"
        elif key == "rollbackEnabled":
            suggest = "rollback_enabled"
        elif key == "useMercurial":
            suggest = "use_mercurial"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppSourceControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppSourceControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppSourceControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch: Optional[str] = None,
                 manual_integration: Optional[bool] = None,
                 repo_url: Optional[str] = None,
                 rollback_enabled: Optional[bool] = None,
                 use_mercurial: Optional[bool] = None):
        """
        :param str branch: The branch of the remote repository to use. Defaults to 'master'.
        :param bool manual_integration: Limits to manual integration. Defaults to `false` if not specified.
        :param str repo_url: The URL of the source code repository.
        :param bool rollback_enabled: Enable roll-back for the repository. Defaults to `false` if not specified.
        :param bool use_mercurial: Use Mercurial if `true`, otherwise uses Git.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if manual_integration is not None:
            pulumi.set(__self__, "manual_integration", manual_integration)
        if repo_url is not None:
            pulumi.set(__self__, "repo_url", repo_url)
        if rollback_enabled is not None:
            pulumi.set(__self__, "rollback_enabled", rollback_enabled)
        if use_mercurial is not None:
            pulumi.set(__self__, "use_mercurial", use_mercurial)

    @property
    @pulumi.getter
    def branch(self) -> Optional[str]:
        """
        The branch of the remote repository to use. Defaults to 'master'.
        """
        return pulumi.get(self, "branch")

    @property
    @pulumi.getter(name="manualIntegration")
    def manual_integration(self) -> Optional[bool]:
        """
        Limits to manual integration. Defaults to `false` if not specified.
        """
        return pulumi.get(self, "manual_integration")

    @property
    @pulumi.getter(name="repoUrl")
    def repo_url(self) -> Optional[str]:
        """
        The URL of the source code repository.
        """
        return pulumi.get(self, "repo_url")

    @property
    @pulumi.getter(name="rollbackEnabled")
    def rollback_enabled(self) -> Optional[bool]:
        """
        Enable roll-back for the repository. Defaults to `false` if not specified.
        """
        return pulumi.get(self, "rollback_enabled")

    @property
    @pulumi.getter(name="useMercurial")
    def use_mercurial(self) -> Optional[bool]:
        """
        Use Mercurial if `true`, otherwise uses Git.
        """
        return pulumi.get(self, "use_mercurial")


@pulumi.output_type
class LinuxFunctionAppAuthSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeDirectory":
            suggest = "active_directory"
        elif key == "additionalLoginParameters":
            suggest = "additional_login_parameters"
        elif key == "allowedExternalRedirectUrls":
            suggest = "allowed_external_redirect_urls"
        elif key == "defaultProvider":
            suggest = "default_provider"
        elif key == "runtimeVersion":
            suggest = "runtime_version"
        elif key == "tokenRefreshExtensionHours":
            suggest = "token_refresh_extension_hours"
        elif key == "tokenStoreEnabled":
            suggest = "token_store_enabled"
        elif key == "unauthenticatedClientAction":
            suggest = "unauthenticated_client_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppAuthSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppAuthSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppAuthSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 active_directory: Optional['outputs.LinuxFunctionAppAuthSettingsActiveDirectory'] = None,
                 additional_login_parameters: Optional[Mapping[str, str]] = None,
                 allowed_external_redirect_urls: Optional[Sequence[str]] = None,
                 default_provider: Optional[str] = None,
                 facebook: Optional['outputs.LinuxFunctionAppAuthSettingsFacebook'] = None,
                 github: Optional['outputs.LinuxFunctionAppAuthSettingsGithub'] = None,
                 google: Optional['outputs.LinuxFunctionAppAuthSettingsGoogle'] = None,
                 issuer: Optional[str] = None,
                 microsoft: Optional['outputs.LinuxFunctionAppAuthSettingsMicrosoft'] = None,
                 runtime_version: Optional[str] = None,
                 token_refresh_extension_hours: Optional[float] = None,
                 token_store_enabled: Optional[bool] = None,
                 twitter: Optional['outputs.LinuxFunctionAppAuthSettingsTwitter'] = None,
                 unauthenticated_client_action: Optional[str] = None):
        """
        :param bool enabled: Should the Authentication / Authorization feature be enabled for the Linux Web App?
        :param 'LinuxFunctionAppAuthSettingsActiveDirectoryArgs' active_directory: An `active_directory` block as defined above.
        :param Mapping[str, str] additional_login_parameters: Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        :param Sequence[str] allowed_external_redirect_urls: Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Linux Web App.
        :param str default_provider: The default authentication provider to use when multiple providers are configured. Possible values include: `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount`, `Twitter`, `Github`
        :param 'LinuxFunctionAppAuthSettingsFacebookArgs' facebook: A `facebook` block as defined below.
        :param 'LinuxFunctionAppAuthSettingsGithubArgs' github: A `github` block as defined below.
        :param 'LinuxFunctionAppAuthSettingsGoogleArgs' google: A `google` block as defined below.
        :param str issuer: The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Linux Web App.
        :param 'LinuxFunctionAppAuthSettingsMicrosoftArgs' microsoft: A `microsoft` block as defined below.
        :param str runtime_version: The RuntimeVersion of the Authentication / Authorization feature in use for the Linux Web App.
        :param float token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        :param bool token_store_enabled: Should the Linux Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        :param 'LinuxFunctionAppAuthSettingsTwitterArgs' twitter: A `twitter` block as defined below.
        :param str unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if active_directory is not None:
            pulumi.set(__self__, "active_directory", active_directory)
        if additional_login_parameters is not None:
            pulumi.set(__self__, "additional_login_parameters", additional_login_parameters)
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if facebook is not None:
            pulumi.set(__self__, "facebook", facebook)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if google is not None:
            pulumi.set(__self__, "google", google)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if microsoft is not None:
            pulumi.set(__self__, "microsoft", microsoft)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if token_refresh_extension_hours is not None:
            pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if twitter is not None:
            pulumi.set(__self__, "twitter", twitter)
        if unauthenticated_client_action is not None:
            pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Should the Authentication / Authorization feature be enabled for the Linux Web App?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="activeDirectory")
    def active_directory(self) -> Optional['outputs.LinuxFunctionAppAuthSettingsActiveDirectory']:
        """
        An `active_directory` block as defined above.
        """
        return pulumi.get(self, "active_directory")

    @property
    @pulumi.getter(name="additionalLoginParameters")
    def additional_login_parameters(self) -> Optional[Mapping[str, str]]:
        """
        Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        """
        return pulumi.get(self, "additional_login_parameters")

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Linux Web App.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[str]:
        """
        The default authentication provider to use when multiple providers are configured. Possible values include: `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount`, `Twitter`, `Github`
        """
        return pulumi.get(self, "default_provider")

    @property
    @pulumi.getter
    def facebook(self) -> Optional['outputs.LinuxFunctionAppAuthSettingsFacebook']:
        """
        A `facebook` block as defined below.
        """
        return pulumi.get(self, "facebook")

    @property
    @pulumi.getter
    def github(self) -> Optional['outputs.LinuxFunctionAppAuthSettingsGithub']:
        """
        A `github` block as defined below.
        """
        return pulumi.get(self, "github")

    @property
    @pulumi.getter
    def google(self) -> Optional['outputs.LinuxFunctionAppAuthSettingsGoogle']:
        """
        A `google` block as defined below.
        """
        return pulumi.get(self, "google")

    @property
    @pulumi.getter
    def issuer(self) -> Optional[str]:
        """
        The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Linux Web App.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def microsoft(self) -> Optional['outputs.LinuxFunctionAppAuthSettingsMicrosoft']:
        """
        A `microsoft` block as defined below.
        """
        return pulumi.get(self, "microsoft")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[str]:
        """
        The RuntimeVersion of the Authentication / Authorization feature in use for the Linux Web App.
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> Optional[float]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        return pulumi.get(self, "token_refresh_extension_hours")

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[bool]:
        """
        Should the Linux Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        """
        return pulumi.get(self, "token_store_enabled")

    @property
    @pulumi.getter
    def twitter(self) -> Optional['outputs.LinuxFunctionAppAuthSettingsTwitter']:
        """
        A `twitter` block as defined below.
        """
        return pulumi.get(self, "twitter")

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> Optional[str]:
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        return pulumi.get(self, "unauthenticated_client_action")


@pulumi.output_type
class LinuxFunctionAppAuthSettingsActiveDirectory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppAuthSettingsActiveDirectory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppAuthSettingsActiveDirectory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppAuthSettingsActiveDirectory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param Sequence[str] allowed_audiences: Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
        :param str client_secret: The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        pulumi.set(__self__, "client_id", client_id)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")


@pulumi.output_type
class LinuxFunctionAppAuthSettingsFacebook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "appSecret":
            suggest = "app_secret"
        elif key == "appSecretSettingName":
            suggest = "app_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppAuthSettingsFacebook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppAuthSettingsFacebook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppAuthSettingsFacebook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: str,
                 app_secret: Optional[str] = None,
                 app_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str app_id: The App ID of the Facebook app used for login.
        :param str app_secret: The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        :param str app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        if app_secret is not None:
            pulumi.set(__self__, "app_secret", app_secret)
        if app_secret_setting_name is not None:
            pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appSecret")
    def app_secret(self) -> Optional[str]:
        """
        The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        """
        return pulumi.get(self, "app_secret")

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class LinuxFunctionAppAuthSettingsGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppAuthSettingsGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppAuthSettingsGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppAuthSettingsGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the GitHub app used for login.
        :param str client_secret: The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the GitHub app used for login.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class LinuxFunctionAppAuthSettingsGoogle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppAuthSettingsGoogle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppAuthSettingsGoogle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppAuthSettingsGoogle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OpenID Connect Client ID for the Google web application.
        :param str client_secret: The client secret associated with the Google web application.  Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OpenID Connect Client ID for the Google web application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The client secret associated with the Google web application.  Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class LinuxFunctionAppAuthSettingsMicrosoft(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppAuthSettingsMicrosoft. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppAuthSettingsMicrosoft.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppAuthSettingsMicrosoft.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret: The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, `wl.basic` is used as the default scope.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, `wl.basic` is used as the default scope.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class LinuxFunctionAppAuthSettingsTwitter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerKey":
            suggest = "consumer_key"
        elif key == "consumerSecret":
            suggest = "consumer_secret"
        elif key == "consumerSecretSettingName":
            suggest = "consumer_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppAuthSettingsTwitter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppAuthSettingsTwitter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppAuthSettingsTwitter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_key: str,
                 consumer_secret: Optional[str] = None,
                 consumer_secret_setting_name: Optional[str] = None):
        """
        :param str consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param str consumer_secret: The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        :param str consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        if consumer_secret is not None:
            pulumi.set(__self__, "consumer_secret", consumer_secret)
        if consumer_secret_setting_name is not None:
            pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> str:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> Optional[str]:
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        """
        return pulumi.get(self, "consumer_secret")

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        return pulumi.get(self, "consumer_secret_setting_name")


@pulumi.output_type
class LinuxFunctionAppBackup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageAccountUrl":
            suggest = "storage_account_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppBackup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppBackup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppBackup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 schedule: 'outputs.LinuxFunctionAppBackupSchedule',
                 storage_account_url: str,
                 enabled: Optional[bool] = None):
        """
        :param str name: The name which should be used for this Backup.
        :param 'LinuxFunctionAppBackupScheduleArgs' schedule: A `schedule` block as defined below.
        :param str storage_account_url: The SAS URL to the container.
        :param bool enabled: Should this backup job be enabled?
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "storage_account_url", storage_account_url)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Backup.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def schedule(self) -> 'outputs.LinuxFunctionAppBackupSchedule':
        """
        A `schedule` block as defined below.
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter(name="storageAccountUrl")
    def storage_account_url(self) -> str:
        """
        The SAS URL to the container.
        """
        return pulumi.get(self, "storage_account_url")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Should this backup job be enabled?
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class LinuxFunctionAppBackupSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "frequencyUnit":
            suggest = "frequency_unit"
        elif key == "keepAtLeastOneBackup":
            suggest = "keep_at_least_one_backup"
        elif key == "lastExecutionTime":
            suggest = "last_execution_time"
        elif key == "retentionPeriodDays":
            suggest = "retention_period_days"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppBackupSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppBackupSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppBackupSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_unit: str,
                 keep_at_least_one_backup: Optional[bool] = None,
                 last_execution_time: Optional[str] = None,
                 retention_period_days: Optional[int] = None,
                 start_time: Optional[str] = None):
        """
        :param int frequency_interval: How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).
        :param str frequency_unit: The unit of time for how often the backup should take place. Possible values include: `Day` and `Hour`.
        :param bool keep_at_least_one_backup: Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
        :param int retention_period_days: After how many days backups should be deleted.
        :param str start_time: When the schedule should start working in RFC-3339 format.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_unit", frequency_unit)
        if keep_at_least_one_backup is not None:
            pulumi.set(__self__, "keep_at_least_one_backup", keep_at_least_one_backup)
        if last_execution_time is not None:
            pulumi.set(__self__, "last_execution_time", last_execution_time)
        if retention_period_days is not None:
            pulumi.set(__self__, "retention_period_days", retention_period_days)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyUnit")
    def frequency_unit(self) -> str:
        """
        The unit of time for how often the backup should take place. Possible values include: `Day` and `Hour`.
        """
        return pulumi.get(self, "frequency_unit")

    @property
    @pulumi.getter(name="keepAtLeastOneBackup")
    def keep_at_least_one_backup(self) -> Optional[bool]:
        """
        Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
        """
        return pulumi.get(self, "keep_at_least_one_backup")

    @property
    @pulumi.getter(name="lastExecutionTime")
    def last_execution_time(self) -> Optional[str]:
        return pulumi.get(self, "last_execution_time")

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> Optional[int]:
        """
        After how many days backups should be deleted.
        """
        return pulumi.get(self, "retention_period_days")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        """
        When the schedule should start working in RFC-3339 format.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class LinuxFunctionAppConnectionString(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: The name which should be used for this Connection.
        :param str type: Type of database. Possible values include: `MySQL`, `SQLServer`, `SQLAzure`, `Custom`, `NotificationHub`, `ServiceBus`, `EventHub`, `APIHub`, `DocDb`, `RedisCache`, and `PostgreSQL`.
        :param str value: The connection string value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Connection.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of database. Possible values include: `MySQL`, `SQLServer`, `SQLAzure`, `Custom`, `NotificationHub`, `ServiceBus`, `EventHub`, `APIHub`, `DocDb`, `RedisCache`, and `PostgreSQL`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The connection string value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class LinuxFunctionAppIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 identity_ids: Optional[Sequence[str]] = None,
                 principal_id: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str type: Specifies the type of Managed Service Identity that should be configured on this Linux Function App. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        :param Sequence[str] identity_ids: A list of User Assigned Managed Identity IDs to be assigned to this Linux Function App.
        :param str principal_id: The Principal ID associated with this Managed Service Identity.
        :param str tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the type of Managed Service Identity that should be configured on this Linux Function App. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[str]]:
        """
        A list of User Assigned Managed Identity IDs to be assigned to this Linux Function App.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class LinuxFunctionAppSiteConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alwaysOn":
            suggest = "always_on"
        elif key == "apiDefinitionUrl":
            suggest = "api_definition_url"
        elif key == "apiManagementApiId":
            suggest = "api_management_api_id"
        elif key == "appCommandLine":
            suggest = "app_command_line"
        elif key == "appScaleLimit":
            suggest = "app_scale_limit"
        elif key == "appServiceLogs":
            suggest = "app_service_logs"
        elif key == "applicationInsightsConnectionString":
            suggest = "application_insights_connection_string"
        elif key == "applicationInsightsKey":
            suggest = "application_insights_key"
        elif key == "applicationStack":
            suggest = "application_stack"
        elif key == "containerRegistryManagedIdentityClientId":
            suggest = "container_registry_managed_identity_client_id"
        elif key == "containerRegistryUseManagedIdentity":
            suggest = "container_registry_use_managed_identity"
        elif key == "defaultDocuments":
            suggest = "default_documents"
        elif key == "detailedErrorLoggingEnabled":
            suggest = "detailed_error_logging_enabled"
        elif key == "elasticInstanceMinimum":
            suggest = "elastic_instance_minimum"
        elif key == "ftpsState":
            suggest = "ftps_state"
        elif key == "healthCheckEvictionTimeInMin":
            suggest = "health_check_eviction_time_in_min"
        elif key == "healthCheckPath":
            suggest = "health_check_path"
        elif key == "http2Enabled":
            suggest = "http2_enabled"
        elif key == "ipRestrictions":
            suggest = "ip_restrictions"
        elif key == "linuxFxVersion":
            suggest = "linux_fx_version"
        elif key == "loadBalancingMode":
            suggest = "load_balancing_mode"
        elif key == "managedPipelineMode":
            suggest = "managed_pipeline_mode"
        elif key == "minimumTlsVersion":
            suggest = "minimum_tls_version"
        elif key == "preWarmedInstanceCount":
            suggest = "pre_warmed_instance_count"
        elif key == "remoteDebuggingEnabled":
            suggest = "remote_debugging_enabled"
        elif key == "remoteDebuggingVersion":
            suggest = "remote_debugging_version"
        elif key == "runtimeScaleMonitoringEnabled":
            suggest = "runtime_scale_monitoring_enabled"
        elif key == "scmIpRestrictions":
            suggest = "scm_ip_restrictions"
        elif key == "scmMinimumTlsVersion":
            suggest = "scm_minimum_tls_version"
        elif key == "scmType":
            suggest = "scm_type"
        elif key == "scmUseMainIpRestriction":
            suggest = "scm_use_main_ip_restriction"
        elif key == "use32BitWorker":
            suggest = "use32_bit_worker"
        elif key == "vnetRouteAllEnabled":
            suggest = "vnet_route_all_enabled"
        elif key == "websocketsEnabled":
            suggest = "websockets_enabled"
        elif key == "workerCount":
            suggest = "worker_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSiteConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSiteConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSiteConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 always_on: Optional[bool] = None,
                 api_definition_url: Optional[str] = None,
                 api_management_api_id: Optional[str] = None,
                 app_command_line: Optional[str] = None,
                 app_scale_limit: Optional[int] = None,
                 app_service_logs: Optional['outputs.LinuxFunctionAppSiteConfigAppServiceLogs'] = None,
                 application_insights_connection_string: Optional[str] = None,
                 application_insights_key: Optional[str] = None,
                 application_stack: Optional['outputs.LinuxFunctionAppSiteConfigApplicationStack'] = None,
                 container_registry_managed_identity_client_id: Optional[str] = None,
                 container_registry_use_managed_identity: Optional[bool] = None,
                 cors: Optional['outputs.LinuxFunctionAppSiteConfigCors'] = None,
                 default_documents: Optional[Sequence[str]] = None,
                 detailed_error_logging_enabled: Optional[bool] = None,
                 elastic_instance_minimum: Optional[int] = None,
                 ftps_state: Optional[str] = None,
                 health_check_eviction_time_in_min: Optional[int] = None,
                 health_check_path: Optional[str] = None,
                 http2_enabled: Optional[bool] = None,
                 ip_restrictions: Optional[Sequence['outputs.LinuxFunctionAppSiteConfigIpRestriction']] = None,
                 linux_fx_version: Optional[str] = None,
                 load_balancing_mode: Optional[str] = None,
                 managed_pipeline_mode: Optional[str] = None,
                 minimum_tls_version: Optional[str] = None,
                 pre_warmed_instance_count: Optional[int] = None,
                 remote_debugging_enabled: Optional[bool] = None,
                 remote_debugging_version: Optional[str] = None,
                 runtime_scale_monitoring_enabled: Optional[bool] = None,
                 scm_ip_restrictions: Optional[Sequence['outputs.LinuxFunctionAppSiteConfigScmIpRestriction']] = None,
                 scm_minimum_tls_version: Optional[str] = None,
                 scm_type: Optional[str] = None,
                 scm_use_main_ip_restriction: Optional[bool] = None,
                 use32_bit_worker: Optional[bool] = None,
                 vnet_route_all_enabled: Optional[bool] = None,
                 websockets_enabled: Optional[bool] = None,
                 worker_count: Optional[int] = None):
        """
        :param bool always_on: If this Linux Web App is Always On enabled. Defaults to `false`.
        :param str api_definition_url: The URL of the API definition that describes this Linux Function App.
        :param str api_management_api_id: The ID of the API Management API for this Linux Function App.
        :param str app_command_line: The App command line to launch.
        :param int app_scale_limit: The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
        :param 'LinuxFunctionAppSiteConfigAppServiceLogsArgs' app_service_logs: An `app_service_logs` block as defined above.
        :param str application_insights_connection_string: The Connection String for linking the Linux Function App to Application Insights.
        :param str application_insights_key: The Instrumentation Key for connecting the Linux Function App to Application Insights.
        :param 'LinuxFunctionAppSiteConfigApplicationStackArgs' application_stack: An `application_stack` block as defined above.
        :param str container_registry_managed_identity_client_id: The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
        :param bool container_registry_use_managed_identity: Should connections for Azure Container Registry use Managed Identity.
        :param 'LinuxFunctionAppSiteConfigCorsArgs' cors: A `cors` block as defined above.
        :param Sequence[str] default_documents: Specifies a list of Default Documents for the Linux Web App.
        :param int elastic_instance_minimum: The number of minimum instances for this Linux Function App. Only affects apps on Elastic Premium plans.
        :param str ftps_state: State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`. Defaults to `Disabled`.
        :param int health_check_eviction_time_in_min: The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        :param str health_check_path: The path to be checked for this function app health.
        :param bool http2_enabled: Specifies if the HTTP2 protocol should be enabled. Defaults to `false`.
        :param Sequence['LinuxFunctionAppSiteConfigIpRestrictionArgs'] ip_restrictions: One or more `ip_restriction` blocks as defined above.
        :param str load_balancing_mode: The Site load balancing mode. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        :param str managed_pipeline_mode: Managed pipeline mode. Possible values include: `Integrated`, `Classic`. Defaults to `Integrated`.
        :param str minimum_tls_version: The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and  `1.2`. Defaults to `1.2`.
        :param int pre_warmed_instance_count: The number of pre-warmed instances for this function app. Only affects apps on an Elastic Premium plan.
        :param bool remote_debugging_enabled: Should Remote Debugging be enabled. Defaults to `false`.
        :param str remote_debugging_version: The Remote Debugging Version. Possible values include `VS2017`, `VS2019`, and `VS2022`.
        :param bool runtime_scale_monitoring_enabled: Should Scale Monitoring of the Functions Runtime be enabled?
        :param Sequence['LinuxFunctionAppSiteConfigScmIpRestrictionArgs'] scm_ip_restrictions: One or more `scm_ip_restriction` blocks as defined above.
        :param str scm_minimum_tls_version: Configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and  `1.2`. Defaults to `1.2`.
        :param bool scm_use_main_ip_restriction: Should the Linux Function App `ip_restriction` configuration be used for the SCM also.
        :param bool use32_bit_worker: Should the Linux Web App use a 32-bit worker process. Defaults to `true`.
        :param bool vnet_route_all_enabled: Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        :param bool websockets_enabled: Should Web Sockets be enabled. Defaults to `false`.
        :param int worker_count: The number of Workers for this Linux Function App.
        """
        if always_on is not None:
            pulumi.set(__self__, "always_on", always_on)
        if api_definition_url is not None:
            pulumi.set(__self__, "api_definition_url", api_definition_url)
        if api_management_api_id is not None:
            pulumi.set(__self__, "api_management_api_id", api_management_api_id)
        if app_command_line is not None:
            pulumi.set(__self__, "app_command_line", app_command_line)
        if app_scale_limit is not None:
            pulumi.set(__self__, "app_scale_limit", app_scale_limit)
        if app_service_logs is not None:
            pulumi.set(__self__, "app_service_logs", app_service_logs)
        if application_insights_connection_string is not None:
            pulumi.set(__self__, "application_insights_connection_string", application_insights_connection_string)
        if application_insights_key is not None:
            pulumi.set(__self__, "application_insights_key", application_insights_key)
        if application_stack is not None:
            pulumi.set(__self__, "application_stack", application_stack)
        if container_registry_managed_identity_client_id is not None:
            pulumi.set(__self__, "container_registry_managed_identity_client_id", container_registry_managed_identity_client_id)
        if container_registry_use_managed_identity is not None:
            pulumi.set(__self__, "container_registry_use_managed_identity", container_registry_use_managed_identity)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if default_documents is not None:
            pulumi.set(__self__, "default_documents", default_documents)
        if detailed_error_logging_enabled is not None:
            pulumi.set(__self__, "detailed_error_logging_enabled", detailed_error_logging_enabled)
        if elastic_instance_minimum is not None:
            pulumi.set(__self__, "elastic_instance_minimum", elastic_instance_minimum)
        if ftps_state is not None:
            pulumi.set(__self__, "ftps_state", ftps_state)
        if health_check_eviction_time_in_min is not None:
            pulumi.set(__self__, "health_check_eviction_time_in_min", health_check_eviction_time_in_min)
        if health_check_path is not None:
            pulumi.set(__self__, "health_check_path", health_check_path)
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if ip_restrictions is not None:
            pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        if linux_fx_version is not None:
            pulumi.set(__self__, "linux_fx_version", linux_fx_version)
        if load_balancing_mode is not None:
            pulumi.set(__self__, "load_balancing_mode", load_balancing_mode)
        if managed_pipeline_mode is not None:
            pulumi.set(__self__, "managed_pipeline_mode", managed_pipeline_mode)
        if minimum_tls_version is not None:
            pulumi.set(__self__, "minimum_tls_version", minimum_tls_version)
        if pre_warmed_instance_count is not None:
            pulumi.set(__self__, "pre_warmed_instance_count", pre_warmed_instance_count)
        if remote_debugging_enabled is not None:
            pulumi.set(__self__, "remote_debugging_enabled", remote_debugging_enabled)
        if remote_debugging_version is not None:
            pulumi.set(__self__, "remote_debugging_version", remote_debugging_version)
        if runtime_scale_monitoring_enabled is not None:
            pulumi.set(__self__, "runtime_scale_monitoring_enabled", runtime_scale_monitoring_enabled)
        if scm_ip_restrictions is not None:
            pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        if scm_minimum_tls_version is not None:
            pulumi.set(__self__, "scm_minimum_tls_version", scm_minimum_tls_version)
        if scm_type is not None:
            pulumi.set(__self__, "scm_type", scm_type)
        if scm_use_main_ip_restriction is not None:
            pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        if use32_bit_worker is not None:
            pulumi.set(__self__, "use32_bit_worker", use32_bit_worker)
        if vnet_route_all_enabled is not None:
            pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        if websockets_enabled is not None:
            pulumi.set(__self__, "websockets_enabled", websockets_enabled)
        if worker_count is not None:
            pulumi.set(__self__, "worker_count", worker_count)

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> Optional[bool]:
        """
        If this Linux Web App is Always On enabled. Defaults to `false`.
        """
        return pulumi.get(self, "always_on")

    @property
    @pulumi.getter(name="apiDefinitionUrl")
    def api_definition_url(self) -> Optional[str]:
        """
        The URL of the API definition that describes this Linux Function App.
        """
        return pulumi.get(self, "api_definition_url")

    @property
    @pulumi.getter(name="apiManagementApiId")
    def api_management_api_id(self) -> Optional[str]:
        """
        The ID of the API Management API for this Linux Function App.
        """
        return pulumi.get(self, "api_management_api_id")

    @property
    @pulumi.getter(name="appCommandLine")
    def app_command_line(self) -> Optional[str]:
        """
        The App command line to launch.
        """
        return pulumi.get(self, "app_command_line")

    @property
    @pulumi.getter(name="appScaleLimit")
    def app_scale_limit(self) -> Optional[int]:
        """
        The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
        """
        return pulumi.get(self, "app_scale_limit")

    @property
    @pulumi.getter(name="appServiceLogs")
    def app_service_logs(self) -> Optional['outputs.LinuxFunctionAppSiteConfigAppServiceLogs']:
        """
        An `app_service_logs` block as defined above.
        """
        return pulumi.get(self, "app_service_logs")

    @property
    @pulumi.getter(name="applicationInsightsConnectionString")
    def application_insights_connection_string(self) -> Optional[str]:
        """
        The Connection String for linking the Linux Function App to Application Insights.
        """
        return pulumi.get(self, "application_insights_connection_string")

    @property
    @pulumi.getter(name="applicationInsightsKey")
    def application_insights_key(self) -> Optional[str]:
        """
        The Instrumentation Key for connecting the Linux Function App to Application Insights.
        """
        return pulumi.get(self, "application_insights_key")

    @property
    @pulumi.getter(name="applicationStack")
    def application_stack(self) -> Optional['outputs.LinuxFunctionAppSiteConfigApplicationStack']:
        """
        An `application_stack` block as defined above.
        """
        return pulumi.get(self, "application_stack")

    @property
    @pulumi.getter(name="containerRegistryManagedIdentityClientId")
    def container_registry_managed_identity_client_id(self) -> Optional[str]:
        """
        The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
        """
        return pulumi.get(self, "container_registry_managed_identity_client_id")

    @property
    @pulumi.getter(name="containerRegistryUseManagedIdentity")
    def container_registry_use_managed_identity(self) -> Optional[bool]:
        """
        Should connections for Azure Container Registry use Managed Identity.
        """
        return pulumi.get(self, "container_registry_use_managed_identity")

    @property
    @pulumi.getter
    def cors(self) -> Optional['outputs.LinuxFunctionAppSiteConfigCors']:
        """
        A `cors` block as defined above.
        """
        return pulumi.get(self, "cors")

    @property
    @pulumi.getter(name="defaultDocuments")
    def default_documents(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Default Documents for the Linux Web App.
        """
        return pulumi.get(self, "default_documents")

    @property
    @pulumi.getter(name="detailedErrorLoggingEnabled")
    def detailed_error_logging_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "detailed_error_logging_enabled")

    @property
    @pulumi.getter(name="elasticInstanceMinimum")
    def elastic_instance_minimum(self) -> Optional[int]:
        """
        The number of minimum instances for this Linux Function App. Only affects apps on Elastic Premium plans.
        """
        return pulumi.get(self, "elastic_instance_minimum")

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> Optional[str]:
        """
        State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`. Defaults to `Disabled`.
        """
        return pulumi.get(self, "ftps_state")

    @property
    @pulumi.getter(name="healthCheckEvictionTimeInMin")
    def health_check_eviction_time_in_min(self) -> Optional[int]:
        """
        The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        """
        return pulumi.get(self, "health_check_eviction_time_in_min")

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> Optional[str]:
        """
        The path to be checked for this function app health.
        """
        return pulumi.get(self, "health_check_path")

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[bool]:
        """
        Specifies if the HTTP2 protocol should be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "http2_enabled")

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Optional[Sequence['outputs.LinuxFunctionAppSiteConfigIpRestriction']]:
        """
        One or more `ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "ip_restrictions")

    @property
    @pulumi.getter(name="linuxFxVersion")
    def linux_fx_version(self) -> Optional[str]:
        return pulumi.get(self, "linux_fx_version")

    @property
    @pulumi.getter(name="loadBalancingMode")
    def load_balancing_mode(self) -> Optional[str]:
        """
        The Site load balancing mode. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        """
        return pulumi.get(self, "load_balancing_mode")

    @property
    @pulumi.getter(name="managedPipelineMode")
    def managed_pipeline_mode(self) -> Optional[str]:
        """
        Managed pipeline mode. Possible values include: `Integrated`, `Classic`. Defaults to `Integrated`.
        """
        return pulumi.get(self, "managed_pipeline_mode")

    @property
    @pulumi.getter(name="minimumTlsVersion")
    def minimum_tls_version(self) -> Optional[str]:
        """
        The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and  `1.2`. Defaults to `1.2`.
        """
        return pulumi.get(self, "minimum_tls_version")

    @property
    @pulumi.getter(name="preWarmedInstanceCount")
    def pre_warmed_instance_count(self) -> Optional[int]:
        """
        The number of pre-warmed instances for this function app. Only affects apps on an Elastic Premium plan.
        """
        return pulumi.get(self, "pre_warmed_instance_count")

    @property
    @pulumi.getter(name="remoteDebuggingEnabled")
    def remote_debugging_enabled(self) -> Optional[bool]:
        """
        Should Remote Debugging be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "remote_debugging_enabled")

    @property
    @pulumi.getter(name="remoteDebuggingVersion")
    def remote_debugging_version(self) -> Optional[str]:
        """
        The Remote Debugging Version. Possible values include `VS2017`, `VS2019`, and `VS2022`.
        """
        return pulumi.get(self, "remote_debugging_version")

    @property
    @pulumi.getter(name="runtimeScaleMonitoringEnabled")
    def runtime_scale_monitoring_enabled(self) -> Optional[bool]:
        """
        Should Scale Monitoring of the Functions Runtime be enabled?
        """
        return pulumi.get(self, "runtime_scale_monitoring_enabled")

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Optional[Sequence['outputs.LinuxFunctionAppSiteConfigScmIpRestriction']]:
        """
        One or more `scm_ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "scm_ip_restrictions")

    @property
    @pulumi.getter(name="scmMinimumTlsVersion")
    def scm_minimum_tls_version(self) -> Optional[str]:
        """
        Configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and  `1.2`. Defaults to `1.2`.
        """
        return pulumi.get(self, "scm_minimum_tls_version")

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> Optional[str]:
        return pulumi.get(self, "scm_type")

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> Optional[bool]:
        """
        Should the Linux Function App `ip_restriction` configuration be used for the SCM also.
        """
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @property
    @pulumi.getter(name="use32BitWorker")
    def use32_bit_worker(self) -> Optional[bool]:
        """
        Should the Linux Web App use a 32-bit worker process. Defaults to `true`.
        """
        return pulumi.get(self, "use32_bit_worker")

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> Optional[bool]:
        """
        Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        """
        return pulumi.get(self, "vnet_route_all_enabled")

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> Optional[bool]:
        """
        Should Web Sockets be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "websockets_enabled")

    @property
    @pulumi.getter(name="workerCount")
    def worker_count(self) -> Optional[int]:
        """
        The number of Workers for this Linux Function App.
        """
        return pulumi.get(self, "worker_count")


@pulumi.output_type
class LinuxFunctionAppSiteConfigAppServiceLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskQuotaMb":
            suggest = "disk_quota_mb"
        elif key == "retentionPeriodDays":
            suggest = "retention_period_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSiteConfigAppServiceLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSiteConfigAppServiceLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSiteConfigAppServiceLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_quota_mb: Optional[int] = None,
                 retention_period_days: Optional[int] = None):
        """
        :param int disk_quota_mb: The amount of disk space to use for logs. Valid values are between `25` and `100`.
        :param int retention_period_days: The retention period for logs in days. Valid values are between `0` and `99999`. Defaults to `0` (never delete).
        """
        if disk_quota_mb is not None:
            pulumi.set(__self__, "disk_quota_mb", disk_quota_mb)
        if retention_period_days is not None:
            pulumi.set(__self__, "retention_period_days", retention_period_days)

    @property
    @pulumi.getter(name="diskQuotaMb")
    def disk_quota_mb(self) -> Optional[int]:
        """
        The amount of disk space to use for logs. Valid values are between `25` and `100`.
        """
        return pulumi.get(self, "disk_quota_mb")

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> Optional[int]:
        """
        The retention period for logs in days. Valid values are between `0` and `99999`. Defaults to `0` (never delete).
        """
        return pulumi.get(self, "retention_period_days")


@pulumi.output_type
class LinuxFunctionAppSiteConfigApplicationStack(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dotnetVersion":
            suggest = "dotnet_version"
        elif key == "javaVersion":
            suggest = "java_version"
        elif key == "nodeVersion":
            suggest = "node_version"
        elif key == "powershellCoreVersion":
            suggest = "powershell_core_version"
        elif key == "pythonVersion":
            suggest = "python_version"
        elif key == "useCustomRuntime":
            suggest = "use_custom_runtime"
        elif key == "useDotnetIsolatedRuntime":
            suggest = "use_dotnet_isolated_runtime"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSiteConfigApplicationStack. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSiteConfigApplicationStack.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSiteConfigApplicationStack.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dockers: Optional[Sequence['outputs.LinuxFunctionAppSiteConfigApplicationStackDocker']] = None,
                 dotnet_version: Optional[str] = None,
                 java_version: Optional[str] = None,
                 node_version: Optional[str] = None,
                 powershell_core_version: Optional[str] = None,
                 python_version: Optional[str] = None,
                 use_custom_runtime: Optional[bool] = None,
                 use_dotnet_isolated_runtime: Optional[bool] = None):
        """
        :param Sequence['LinuxFunctionAppSiteConfigApplicationStackDockerArgs'] dockers: One or more `docker` blocks as defined below.
        :param str dotnet_version: The version of .NET to use. Possible values include `3.1`, `6.0` and `7.0`.
        :param str java_version: The Version of Java to use. Supported versions include `8`, `11` & `17` (In-Preview).
        :param str node_version: The version of Node to run. Possible values include `12`, `14`, `16` and `18`.
        :param str powershell_core_version: The version of PowerShell Core to run. Possible values are `7`, and `7.2`.
        :param str python_version: The version of Python to run. Possible values include `3.6`, `3.7`, `3.8`, and `3.9`.
        :param bool use_custom_runtime: Should the Linux Function App use a custom runtime?
        :param bool use_dotnet_isolated_runtime: Should the DotNet process use an isolated runtime. Defaults to `false`.
        """
        if dockers is not None:
            pulumi.set(__self__, "dockers", dockers)
        if dotnet_version is not None:
            pulumi.set(__self__, "dotnet_version", dotnet_version)
        if java_version is not None:
            pulumi.set(__self__, "java_version", java_version)
        if node_version is not None:
            pulumi.set(__self__, "node_version", node_version)
        if powershell_core_version is not None:
            pulumi.set(__self__, "powershell_core_version", powershell_core_version)
        if python_version is not None:
            pulumi.set(__self__, "python_version", python_version)
        if use_custom_runtime is not None:
            pulumi.set(__self__, "use_custom_runtime", use_custom_runtime)
        if use_dotnet_isolated_runtime is not None:
            pulumi.set(__self__, "use_dotnet_isolated_runtime", use_dotnet_isolated_runtime)

    @property
    @pulumi.getter
    def dockers(self) -> Optional[Sequence['outputs.LinuxFunctionAppSiteConfigApplicationStackDocker']]:
        """
        One or more `docker` blocks as defined below.
        """
        return pulumi.get(self, "dockers")

    @property
    @pulumi.getter(name="dotnetVersion")
    def dotnet_version(self) -> Optional[str]:
        """
        The version of .NET to use. Possible values include `3.1`, `6.0` and `7.0`.
        """
        return pulumi.get(self, "dotnet_version")

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> Optional[str]:
        """
        The Version of Java to use. Supported versions include `8`, `11` & `17` (In-Preview).
        """
        return pulumi.get(self, "java_version")

    @property
    @pulumi.getter(name="nodeVersion")
    def node_version(self) -> Optional[str]:
        """
        The version of Node to run. Possible values include `12`, `14`, `16` and `18`.
        """
        return pulumi.get(self, "node_version")

    @property
    @pulumi.getter(name="powershellCoreVersion")
    def powershell_core_version(self) -> Optional[str]:
        """
        The version of PowerShell Core to run. Possible values are `7`, and `7.2`.
        """
        return pulumi.get(self, "powershell_core_version")

    @property
    @pulumi.getter(name="pythonVersion")
    def python_version(self) -> Optional[str]:
        """
        The version of Python to run. Possible values include `3.6`, `3.7`, `3.8`, and `3.9`.
        """
        return pulumi.get(self, "python_version")

    @property
    @pulumi.getter(name="useCustomRuntime")
    def use_custom_runtime(self) -> Optional[bool]:
        """
        Should the Linux Function App use a custom runtime?
        """
        return pulumi.get(self, "use_custom_runtime")

    @property
    @pulumi.getter(name="useDotnetIsolatedRuntime")
    def use_dotnet_isolated_runtime(self) -> Optional[bool]:
        """
        Should the DotNet process use an isolated runtime. Defaults to `false`.
        """
        return pulumi.get(self, "use_dotnet_isolated_runtime")


@pulumi.output_type
class LinuxFunctionAppSiteConfigApplicationStackDocker(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageName":
            suggest = "image_name"
        elif key == "imageTag":
            suggest = "image_tag"
        elif key == "registryUrl":
            suggest = "registry_url"
        elif key == "registryPassword":
            suggest = "registry_password"
        elif key == "registryUsername":
            suggest = "registry_username"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSiteConfigApplicationStackDocker. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSiteConfigApplicationStackDocker.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSiteConfigApplicationStackDocker.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_name: str,
                 image_tag: str,
                 registry_url: str,
                 registry_password: Optional[str] = None,
                 registry_username: Optional[str] = None):
        """
        :param str image_name: The name of the Docker image to use.
        :param str image_tag: The image tag of the image to use.
        :param str registry_url: The URL of the docker registry.
        :param str registry_password: The password for the account to use to connect to the registry.
        :param str registry_username: The username to use for connections to the registry.
        """
        pulumi.set(__self__, "image_name", image_name)
        pulumi.set(__self__, "image_tag", image_tag)
        pulumi.set(__self__, "registry_url", registry_url)
        if registry_password is not None:
            pulumi.set(__self__, "registry_password", registry_password)
        if registry_username is not None:
            pulumi.set(__self__, "registry_username", registry_username)

    @property
    @pulumi.getter(name="imageName")
    def image_name(self) -> str:
        """
        The name of the Docker image to use.
        """
        return pulumi.get(self, "image_name")

    @property
    @pulumi.getter(name="imageTag")
    def image_tag(self) -> str:
        """
        The image tag of the image to use.
        """
        return pulumi.get(self, "image_tag")

    @property
    @pulumi.getter(name="registryUrl")
    def registry_url(self) -> str:
        """
        The URL of the docker registry.
        """
        return pulumi.get(self, "registry_url")

    @property
    @pulumi.getter(name="registryPassword")
    def registry_password(self) -> Optional[str]:
        """
        The password for the account to use to connect to the registry.
        """
        return pulumi.get(self, "registry_password")

    @property
    @pulumi.getter(name="registryUsername")
    def registry_username(self) -> Optional[str]:
        """
        The username to use for connections to the registry.
        """
        return pulumi.get(self, "registry_username")


@pulumi.output_type
class LinuxFunctionAppSiteConfigCors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedOrigins":
            suggest = "allowed_origins"
        elif key == "supportCredentials":
            suggest = "support_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSiteConfigCors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSiteConfigCors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSiteConfigCors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_origins: Sequence[str],
                 support_credentials: Optional[bool] = None):
        """
        :param Sequence[str] allowed_origins: Specifies a list of origins that should be allowed to make cross-origin calls.
        :param bool support_credentials: Are credentials allowed in CORS requests? Defaults to `false`.
        """
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        if support_credentials is not None:
            pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Sequence[str]:
        """
        Specifies a list of origins that should be allowed to make cross-origin calls.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> Optional[bool]:
        """
        Are credentials allowed in CORS requests? Defaults to `false`.
        """
        return pulumi.get(self, "support_credentials")


@pulumi.output_type
class LinuxFunctionAppSiteConfigIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSiteConfigIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSiteConfigIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSiteConfigIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.LinuxFunctionAppSiteConfigIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: The action to take. Possible values are `Allow` or `Deny`.
        :param 'LinuxFunctionAppSiteConfigIpRestrictionHeadersArgs' headers: A `headers` block as defined above.
        :param str ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param str name: The name which should be used for this `ip_restriction`.
        :param int priority: The priority value of this `ip_restriction`.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        The action to take. Possible values are `Allow` or `Deny`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.LinuxFunctionAppSiteConfigIpRestrictionHeaders']:
        """
        A `headers` block as defined above.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority value of this `ip_restriction`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class LinuxFunctionAppSiteConfigIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSiteConfigIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param str x_fd_health_probe: Specifies if a Front Door Health Probe should be expected.
        :param Sequence[str] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param Sequence[str] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        Specifies if a Front Door Health Probe should be expected.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class LinuxFunctionAppSiteConfigScmIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSiteConfigScmIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSiteConfigScmIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSiteConfigScmIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.LinuxFunctionAppSiteConfigScmIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: The action to take. Possible values are `Allow` or `Deny`.
        :param 'LinuxFunctionAppSiteConfigScmIpRestrictionHeadersArgs' headers: A `headers` block as defined above.
        :param str ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param str name: The name which should be used for this `ip_restriction`.
        :param int priority: The priority value of this `ip_restriction`.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        The action to take. Possible values are `Allow` or `Deny`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.LinuxFunctionAppSiteConfigScmIpRestrictionHeaders']:
        """
        A `headers` block as defined above.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority value of this `ip_restriction`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class LinuxFunctionAppSiteConfigScmIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSiteConfigScmIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param str x_fd_health_probe: Specifies if a Front Door Health Probe should be expected.
        :param Sequence[str] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param Sequence[str] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        Specifies if a Front Door Health Probe should be expected.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class LinuxFunctionAppSiteCredential(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 password: Optional[str] = None):
        """
        :param str name: The name which should be used for this Linux Function App. Changing this forces a new Linux Function App to be created. Limit the function name to 32 characters to avoid naming collisions. For more information about [Function App naming rule](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/resource-name-rules#microsoftweb) and [Host ID Collisions](https://github.com/Azure/azure-functions-host/wiki/Host-IDs#host-id-collisions)
        :param str password: The Site Credentials Password used for publishing.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name which should be used for this Linux Function App. Changing this forces a new Linux Function App to be created. Limit the function name to 32 characters to avoid naming collisions. For more information about [Function App naming rule](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/resource-name-rules#microsoftweb) and [Host ID Collisions](https://github.com/Azure/azure-functions-host/wiki/Host-IDs#host-id-collisions)
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The Site Credentials Password used for publishing.
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class LinuxFunctionAppSlotAuthSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeDirectory":
            suggest = "active_directory"
        elif key == "additionalLoginParameters":
            suggest = "additional_login_parameters"
        elif key == "allowedExternalRedirectUrls":
            suggest = "allowed_external_redirect_urls"
        elif key == "defaultProvider":
            suggest = "default_provider"
        elif key == "runtimeVersion":
            suggest = "runtime_version"
        elif key == "tokenRefreshExtensionHours":
            suggest = "token_refresh_extension_hours"
        elif key == "tokenStoreEnabled":
            suggest = "token_store_enabled"
        elif key == "unauthenticatedClientAction":
            suggest = "unauthenticated_client_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotAuthSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotAuthSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotAuthSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 active_directory: Optional['outputs.LinuxFunctionAppSlotAuthSettingsActiveDirectory'] = None,
                 additional_login_parameters: Optional[Mapping[str, str]] = None,
                 allowed_external_redirect_urls: Optional[Sequence[str]] = None,
                 default_provider: Optional[str] = None,
                 facebook: Optional['outputs.LinuxFunctionAppSlotAuthSettingsFacebook'] = None,
                 github: Optional['outputs.LinuxFunctionAppSlotAuthSettingsGithub'] = None,
                 google: Optional['outputs.LinuxFunctionAppSlotAuthSettingsGoogle'] = None,
                 issuer: Optional[str] = None,
                 microsoft: Optional['outputs.LinuxFunctionAppSlotAuthSettingsMicrosoft'] = None,
                 runtime_version: Optional[str] = None,
                 token_refresh_extension_hours: Optional[float] = None,
                 token_store_enabled: Optional[bool] = None,
                 twitter: Optional['outputs.LinuxFunctionAppSlotAuthSettingsTwitter'] = None,
                 unauthenticated_client_action: Optional[str] = None):
        """
        :param bool enabled: Should the Authentication / Authorization feature be enabled?
        :param 'LinuxFunctionAppSlotAuthSettingsActiveDirectoryArgs' active_directory: an `active_directory` block as detailed below.
        :param Mapping[str, str] additional_login_parameters: Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        :param Sequence[str] allowed_external_redirect_urls: an `allowed_external_redirect_urls` block as detailed below.
        :param str default_provider: The default authentication provider to use when multiple providers are configured. Possible values include: `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount`, `Twitter`, `Github`.
        :param 'LinuxFunctionAppSlotAuthSettingsFacebookArgs' facebook: a `facebook` block as detailed below.
        :param 'LinuxFunctionAppSlotAuthSettingsGithubArgs' github: a `github` block as detailed below.
        :param 'LinuxFunctionAppSlotAuthSettingsGoogleArgs' google: a `google` block as detailed below.
        :param str issuer: The OpenID Connect Issuer URI that represents the entity which issues access tokens.
        :param 'LinuxFunctionAppSlotAuthSettingsMicrosoftArgs' microsoft: a `microsoft` block as detailed below.
        :param str runtime_version: The RuntimeVersion of the Authentication / Authorization feature in use.
        :param float token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        :param bool token_store_enabled: Should the Linux Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        :param 'LinuxFunctionAppSlotAuthSettingsTwitterArgs' twitter: a `twitter` block as detailed below.
        :param str unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if active_directory is not None:
            pulumi.set(__self__, "active_directory", active_directory)
        if additional_login_parameters is not None:
            pulumi.set(__self__, "additional_login_parameters", additional_login_parameters)
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if facebook is not None:
            pulumi.set(__self__, "facebook", facebook)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if google is not None:
            pulumi.set(__self__, "google", google)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if microsoft is not None:
            pulumi.set(__self__, "microsoft", microsoft)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if token_refresh_extension_hours is not None:
            pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if twitter is not None:
            pulumi.set(__self__, "twitter", twitter)
        if unauthenticated_client_action is not None:
            pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Should the Authentication / Authorization feature be enabled?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="activeDirectory")
    def active_directory(self) -> Optional['outputs.LinuxFunctionAppSlotAuthSettingsActiveDirectory']:
        """
        an `active_directory` block as detailed below.
        """
        return pulumi.get(self, "active_directory")

    @property
    @pulumi.getter(name="additionalLoginParameters")
    def additional_login_parameters(self) -> Optional[Mapping[str, str]]:
        """
        Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        """
        return pulumi.get(self, "additional_login_parameters")

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[Sequence[str]]:
        """
        an `allowed_external_redirect_urls` block as detailed below.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[str]:
        """
        The default authentication provider to use when multiple providers are configured. Possible values include: `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount`, `Twitter`, `Github`.
        """
        return pulumi.get(self, "default_provider")

    @property
    @pulumi.getter
    def facebook(self) -> Optional['outputs.LinuxFunctionAppSlotAuthSettingsFacebook']:
        """
        a `facebook` block as detailed below.
        """
        return pulumi.get(self, "facebook")

    @property
    @pulumi.getter
    def github(self) -> Optional['outputs.LinuxFunctionAppSlotAuthSettingsGithub']:
        """
        a `github` block as detailed below.
        """
        return pulumi.get(self, "github")

    @property
    @pulumi.getter
    def google(self) -> Optional['outputs.LinuxFunctionAppSlotAuthSettingsGoogle']:
        """
        a `google` block as detailed below.
        """
        return pulumi.get(self, "google")

    @property
    @pulumi.getter
    def issuer(self) -> Optional[str]:
        """
        The OpenID Connect Issuer URI that represents the entity which issues access tokens.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def microsoft(self) -> Optional['outputs.LinuxFunctionAppSlotAuthSettingsMicrosoft']:
        """
        a `microsoft` block as detailed below.
        """
        return pulumi.get(self, "microsoft")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[str]:
        """
        The RuntimeVersion of the Authentication / Authorization feature in use.
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> Optional[float]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        return pulumi.get(self, "token_refresh_extension_hours")

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[bool]:
        """
        Should the Linux Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        """
        return pulumi.get(self, "token_store_enabled")

    @property
    @pulumi.getter
    def twitter(self) -> Optional['outputs.LinuxFunctionAppSlotAuthSettingsTwitter']:
        """
        a `twitter` block as detailed below.
        """
        return pulumi.get(self, "twitter")

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> Optional[str]:
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        return pulumi.get(self, "unauthenticated_client_action")


@pulumi.output_type
class LinuxFunctionAppSlotAuthSettingsActiveDirectory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotAuthSettingsActiveDirectory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotAuthSettingsActiveDirectory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotAuthSettingsActiveDirectory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param Sequence[str] allowed_audiences: an `allowed_audiences` block as detailed below.
        :param str client_secret: The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        pulumi.set(__self__, "client_id", client_id)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        an `allowed_audiences` block as detailed below.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")


@pulumi.output_type
class LinuxFunctionAppSlotAuthSettingsFacebook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "appSecret":
            suggest = "app_secret"
        elif key == "appSecretSettingName":
            suggest = "app_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotAuthSettingsFacebook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotAuthSettingsFacebook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotAuthSettingsFacebook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: str,
                 app_secret: Optional[str] = None,
                 app_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str app_id: The App ID of the Facebook app used for login.
        :param str app_secret: The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        :param str app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        if app_secret is not None:
            pulumi.set(__self__, "app_secret", app_secret)
        if app_secret_setting_name is not None:
            pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appSecret")
    def app_secret(self) -> Optional[str]:
        """
        The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        """
        return pulumi.get(self, "app_secret")

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class LinuxFunctionAppSlotAuthSettingsGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotAuthSettingsGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotAuthSettingsGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotAuthSettingsGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the GitHub app used for login.
        :param str client_secret: The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the GitHub app used for login.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class LinuxFunctionAppSlotAuthSettingsGoogle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotAuthSettingsGoogle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotAuthSettingsGoogle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotAuthSettingsGoogle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OpenID Connect Client ID for the Google web application.
        :param str client_secret: The client secret associated with the Google web application.  Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OpenID Connect Client ID for the Google web application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The client secret associated with the Google web application.  Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class LinuxFunctionAppSlotAuthSettingsMicrosoft(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotAuthSettingsMicrosoft. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotAuthSettingsMicrosoft.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotAuthSettingsMicrosoft.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret: The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, `wl.basic` is used as the default scope.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, `wl.basic` is used as the default scope.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class LinuxFunctionAppSlotAuthSettingsTwitter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerKey":
            suggest = "consumer_key"
        elif key == "consumerSecret":
            suggest = "consumer_secret"
        elif key == "consumerSecretSettingName":
            suggest = "consumer_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotAuthSettingsTwitter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotAuthSettingsTwitter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotAuthSettingsTwitter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_key: str,
                 consumer_secret: Optional[str] = None,
                 consumer_secret_setting_name: Optional[str] = None):
        """
        :param str consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param str consumer_secret: The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        :param str consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        if consumer_secret is not None:
            pulumi.set(__self__, "consumer_secret", consumer_secret)
        if consumer_secret_setting_name is not None:
            pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> str:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> Optional[str]:
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        """
        return pulumi.get(self, "consumer_secret")

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        return pulumi.get(self, "consumer_secret_setting_name")


@pulumi.output_type
class LinuxFunctionAppSlotBackup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageAccountUrl":
            suggest = "storage_account_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotBackup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotBackup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotBackup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 schedule: 'outputs.LinuxFunctionAppSlotBackupSchedule',
                 storage_account_url: str,
                 enabled: Optional[bool] = None):
        """
        :param str name: The name which should be used for this Backup.
        :param 'LinuxFunctionAppSlotBackupScheduleArgs' schedule: a `schedule` block as detailed below.
        :param str storage_account_url: The SAS URL to the container.
        :param bool enabled: Should this backup job be enabled?
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "storage_account_url", storage_account_url)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Backup.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def schedule(self) -> 'outputs.LinuxFunctionAppSlotBackupSchedule':
        """
        a `schedule` block as detailed below.
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter(name="storageAccountUrl")
    def storage_account_url(self) -> str:
        """
        The SAS URL to the container.
        """
        return pulumi.get(self, "storage_account_url")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Should this backup job be enabled?
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class LinuxFunctionAppSlotBackupSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "frequencyUnit":
            suggest = "frequency_unit"
        elif key == "keepAtLeastOneBackup":
            suggest = "keep_at_least_one_backup"
        elif key == "lastExecutionTime":
            suggest = "last_execution_time"
        elif key == "retentionPeriodDays":
            suggest = "retention_period_days"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotBackupSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotBackupSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotBackupSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_unit: str,
                 keep_at_least_one_backup: Optional[bool] = None,
                 last_execution_time: Optional[str] = None,
                 retention_period_days: Optional[int] = None,
                 start_time: Optional[str] = None):
        """
        :param int frequency_interval: How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).
        :param str frequency_unit: The unit of time for how often the backup should take place. Possible values include: `Day` and `Hour`.
        :param bool keep_at_least_one_backup: Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
        :param str last_execution_time: The time the backup was last attempted.
        :param int retention_period_days: After how many days backups should be deleted.
        :param str start_time: When the schedule should start working in RFC-3339 format.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_unit", frequency_unit)
        if keep_at_least_one_backup is not None:
            pulumi.set(__self__, "keep_at_least_one_backup", keep_at_least_one_backup)
        if last_execution_time is not None:
            pulumi.set(__self__, "last_execution_time", last_execution_time)
        if retention_period_days is not None:
            pulumi.set(__self__, "retention_period_days", retention_period_days)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyUnit")
    def frequency_unit(self) -> str:
        """
        The unit of time for how often the backup should take place. Possible values include: `Day` and `Hour`.
        """
        return pulumi.get(self, "frequency_unit")

    @property
    @pulumi.getter(name="keepAtLeastOneBackup")
    def keep_at_least_one_backup(self) -> Optional[bool]:
        """
        Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
        """
        return pulumi.get(self, "keep_at_least_one_backup")

    @property
    @pulumi.getter(name="lastExecutionTime")
    def last_execution_time(self) -> Optional[str]:
        """
        The time the backup was last attempted.
        """
        return pulumi.get(self, "last_execution_time")

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> Optional[int]:
        """
        After how many days backups should be deleted.
        """
        return pulumi.get(self, "retention_period_days")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        """
        When the schedule should start working in RFC-3339 format.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class LinuxFunctionAppSlotConnectionString(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: The name which should be used for this Connection.
        :param str type: Type of database. Possible values include: `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
        :param str value: The connection string value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Connection.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of database. Possible values include: `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The connection string value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class LinuxFunctionAppSlotIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 identity_ids: Optional[Sequence[str]] = None,
                 principal_id: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str type: Specifies the type of Managed Service Identity that should be configured on this Linux Function App Slot. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        :param Sequence[str] identity_ids: A list of User Assigned Managed Identity IDs to be assigned to this Linux Function App Slot.
        :param str principal_id: The Principal ID associated with this Managed Service Identity.
        :param str tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the type of Managed Service Identity that should be configured on this Linux Function App Slot. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[str]]:
        """
        A list of User Assigned Managed Identity IDs to be assigned to this Linux Function App Slot.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class LinuxFunctionAppSlotSiteConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alwaysOn":
            suggest = "always_on"
        elif key == "apiDefinitionUrl":
            suggest = "api_definition_url"
        elif key == "apiManagementApiId":
            suggest = "api_management_api_id"
        elif key == "appCommandLine":
            suggest = "app_command_line"
        elif key == "appScaleLimit":
            suggest = "app_scale_limit"
        elif key == "appServiceLogs":
            suggest = "app_service_logs"
        elif key == "applicationInsightsConnectionString":
            suggest = "application_insights_connection_string"
        elif key == "applicationInsightsKey":
            suggest = "application_insights_key"
        elif key == "applicationStack":
            suggest = "application_stack"
        elif key == "autoSwapSlotName":
            suggest = "auto_swap_slot_name"
        elif key == "containerRegistryManagedIdentityClientId":
            suggest = "container_registry_managed_identity_client_id"
        elif key == "containerRegistryUseManagedIdentity":
            suggest = "container_registry_use_managed_identity"
        elif key == "defaultDocuments":
            suggest = "default_documents"
        elif key == "detailedErrorLoggingEnabled":
            suggest = "detailed_error_logging_enabled"
        elif key == "elasticInstanceMinimum":
            suggest = "elastic_instance_minimum"
        elif key == "ftpsState":
            suggest = "ftps_state"
        elif key == "healthCheckEvictionTimeInMin":
            suggest = "health_check_eviction_time_in_min"
        elif key == "healthCheckPath":
            suggest = "health_check_path"
        elif key == "http2Enabled":
            suggest = "http2_enabled"
        elif key == "ipRestrictions":
            suggest = "ip_restrictions"
        elif key == "linuxFxVersion":
            suggest = "linux_fx_version"
        elif key == "loadBalancingMode":
            suggest = "load_balancing_mode"
        elif key == "managedPipelineMode":
            suggest = "managed_pipeline_mode"
        elif key == "minimumTlsVersion":
            suggest = "minimum_tls_version"
        elif key == "preWarmedInstanceCount":
            suggest = "pre_warmed_instance_count"
        elif key == "remoteDebuggingEnabled":
            suggest = "remote_debugging_enabled"
        elif key == "remoteDebuggingVersion":
            suggest = "remote_debugging_version"
        elif key == "runtimeScaleMonitoringEnabled":
            suggest = "runtime_scale_monitoring_enabled"
        elif key == "scmIpRestrictions":
            suggest = "scm_ip_restrictions"
        elif key == "scmMinimumTlsVersion":
            suggest = "scm_minimum_tls_version"
        elif key == "scmType":
            suggest = "scm_type"
        elif key == "scmUseMainIpRestriction":
            suggest = "scm_use_main_ip_restriction"
        elif key == "use32BitWorker":
            suggest = "use32_bit_worker"
        elif key == "vnetRouteAllEnabled":
            suggest = "vnet_route_all_enabled"
        elif key == "websocketsEnabled":
            suggest = "websockets_enabled"
        elif key == "workerCount":
            suggest = "worker_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotSiteConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotSiteConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotSiteConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 always_on: Optional[bool] = None,
                 api_definition_url: Optional[str] = None,
                 api_management_api_id: Optional[str] = None,
                 app_command_line: Optional[str] = None,
                 app_scale_limit: Optional[int] = None,
                 app_service_logs: Optional['outputs.LinuxFunctionAppSlotSiteConfigAppServiceLogs'] = None,
                 application_insights_connection_string: Optional[str] = None,
                 application_insights_key: Optional[str] = None,
                 application_stack: Optional['outputs.LinuxFunctionAppSlotSiteConfigApplicationStack'] = None,
                 auto_swap_slot_name: Optional[str] = None,
                 container_registry_managed_identity_client_id: Optional[str] = None,
                 container_registry_use_managed_identity: Optional[bool] = None,
                 cors: Optional['outputs.LinuxFunctionAppSlotSiteConfigCors'] = None,
                 default_documents: Optional[Sequence[str]] = None,
                 detailed_error_logging_enabled: Optional[bool] = None,
                 elastic_instance_minimum: Optional[int] = None,
                 ftps_state: Optional[str] = None,
                 health_check_eviction_time_in_min: Optional[int] = None,
                 health_check_path: Optional[str] = None,
                 http2_enabled: Optional[bool] = None,
                 ip_restrictions: Optional[Sequence['outputs.LinuxFunctionAppSlotSiteConfigIpRestriction']] = None,
                 linux_fx_version: Optional[str] = None,
                 load_balancing_mode: Optional[str] = None,
                 managed_pipeline_mode: Optional[str] = None,
                 minimum_tls_version: Optional[str] = None,
                 pre_warmed_instance_count: Optional[int] = None,
                 remote_debugging_enabled: Optional[bool] = None,
                 remote_debugging_version: Optional[str] = None,
                 runtime_scale_monitoring_enabled: Optional[bool] = None,
                 scm_ip_restrictions: Optional[Sequence['outputs.LinuxFunctionAppSlotSiteConfigScmIpRestriction']] = None,
                 scm_minimum_tls_version: Optional[str] = None,
                 scm_type: Optional[str] = None,
                 scm_use_main_ip_restriction: Optional[bool] = None,
                 use32_bit_worker: Optional[bool] = None,
                 vnet_route_all_enabled: Optional[bool] = None,
                 websockets_enabled: Optional[bool] = None,
                 worker_count: Optional[int] = None):
        """
        :param bool always_on: If this Linux Web App is Always On enabled. Defaults to `false`.
        :param str api_definition_url: The URL of the API definition that describes this Linux Function App.
        :param str api_management_api_id: The ID of the API Management API for this Linux Function App.
        :param str app_command_line: The program and any arguments used to launch this app via the command line. (Example `node myapp.js`).
        :param int app_scale_limit: The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
        :param 'LinuxFunctionAppSlotSiteConfigAppServiceLogsArgs' app_service_logs: an `app_service_logs` block as detailed below.
        :param str application_insights_connection_string: The Connection String for linking the Linux Function App to Application Insights.
        :param str application_insights_key: The Instrumentation Key for connecting the Linux Function App to Application Insights.
        :param 'LinuxFunctionAppSlotSiteConfigApplicationStackArgs' application_stack: an `application_stack` block as detailed below.
        :param str auto_swap_slot_name: The name of the slot to automatically swap with when this slot is successfully deployed.
        :param str container_registry_managed_identity_client_id: The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
        :param bool container_registry_use_managed_identity: Should connections for Azure Container Registry use Managed Identity.
        :param 'LinuxFunctionAppSlotSiteConfigCorsArgs' cors: a `cors` block as detailed below.
        :param Sequence[str] default_documents: a `default_documents` block as detailed below.
        :param bool detailed_error_logging_enabled: Is detailed error logging enabled
        :param int elastic_instance_minimum: The number of minimum instances for this Linux Function App. Only affects apps on Elastic Premium plans.
        :param str ftps_state: State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`. Defaults to `Disabled`.
        :param int health_check_eviction_time_in_min: The amount of time in minutes that a node is unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Defaults to `10`. Only valid in conjunction with `health_check_path`
        :param str health_check_path: The path to be checked for this function app health.
        :param bool http2_enabled: Specifies if the HTTP2 protocol should be enabled. Defaults to `false`.
        :param Sequence['LinuxFunctionAppSlotSiteConfigIpRestrictionArgs'] ip_restrictions: an `ip_restriction` block as detailed below.
        :param str linux_fx_version: The Linux FX Version
        :param str load_balancing_mode: The Site load balancing mode. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        :param str managed_pipeline_mode: The Managed Pipeline mode. Possible values include: `Integrated`, `Classic`. Defaults to `Integrated`.
        :param str minimum_tls_version: The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and  `1.2`. Defaults to `1.2`.
        :param int pre_warmed_instance_count: The number of pre-warmed instances for this function app. Only affects apps on an Elastic Premium plan.
        :param bool remote_debugging_enabled: Should Remote Debugging be enabled. Defaults to `false`.
        :param str remote_debugging_version: The Remote Debugging Version. Possible values include `VS2017`, `VS2019`, and `VS2022`
        :param bool runtime_scale_monitoring_enabled: Should Functions Runtime Scale Monitoring be enabled.
        :param Sequence['LinuxFunctionAppSlotSiteConfigScmIpRestrictionArgs'] scm_ip_restrictions: a `scm_ip_restriction` block as detailed below.
        :param str scm_minimum_tls_version: Configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and  `1.2`. Defaults to `1.2`.
        :param str scm_type: The SCM Type in use by the Linux Function App.
        :param bool scm_use_main_ip_restriction: Should the Linux Function App `ip_restriction` configuration be used for the SCM also.
        :param bool use32_bit_worker: Should the Linux Web App use a 32-bit worker.
        :param bool vnet_route_all_enabled: Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        :param bool websockets_enabled: Should Web Sockets be enabled. Defaults to `false`.
        :param int worker_count: The number of Workers for this Linux Function App.
        """
        if always_on is not None:
            pulumi.set(__self__, "always_on", always_on)
        if api_definition_url is not None:
            pulumi.set(__self__, "api_definition_url", api_definition_url)
        if api_management_api_id is not None:
            pulumi.set(__self__, "api_management_api_id", api_management_api_id)
        if app_command_line is not None:
            pulumi.set(__self__, "app_command_line", app_command_line)
        if app_scale_limit is not None:
            pulumi.set(__self__, "app_scale_limit", app_scale_limit)
        if app_service_logs is not None:
            pulumi.set(__self__, "app_service_logs", app_service_logs)
        if application_insights_connection_string is not None:
            pulumi.set(__self__, "application_insights_connection_string", application_insights_connection_string)
        if application_insights_key is not None:
            pulumi.set(__self__, "application_insights_key", application_insights_key)
        if application_stack is not None:
            pulumi.set(__self__, "application_stack", application_stack)
        if auto_swap_slot_name is not None:
            pulumi.set(__self__, "auto_swap_slot_name", auto_swap_slot_name)
        if container_registry_managed_identity_client_id is not None:
            pulumi.set(__self__, "container_registry_managed_identity_client_id", container_registry_managed_identity_client_id)
        if container_registry_use_managed_identity is not None:
            pulumi.set(__self__, "container_registry_use_managed_identity", container_registry_use_managed_identity)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if default_documents is not None:
            pulumi.set(__self__, "default_documents", default_documents)
        if detailed_error_logging_enabled is not None:
            pulumi.set(__self__, "detailed_error_logging_enabled", detailed_error_logging_enabled)
        if elastic_instance_minimum is not None:
            pulumi.set(__self__, "elastic_instance_minimum", elastic_instance_minimum)
        if ftps_state is not None:
            pulumi.set(__self__, "ftps_state", ftps_state)
        if health_check_eviction_time_in_min is not None:
            pulumi.set(__self__, "health_check_eviction_time_in_min", health_check_eviction_time_in_min)
        if health_check_path is not None:
            pulumi.set(__self__, "health_check_path", health_check_path)
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if ip_restrictions is not None:
            pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        if linux_fx_version is not None:
            pulumi.set(__self__, "linux_fx_version", linux_fx_version)
        if load_balancing_mode is not None:
            pulumi.set(__self__, "load_balancing_mode", load_balancing_mode)
        if managed_pipeline_mode is not None:
            pulumi.set(__self__, "managed_pipeline_mode", managed_pipeline_mode)
        if minimum_tls_version is not None:
            pulumi.set(__self__, "minimum_tls_version", minimum_tls_version)
        if pre_warmed_instance_count is not None:
            pulumi.set(__self__, "pre_warmed_instance_count", pre_warmed_instance_count)
        if remote_debugging_enabled is not None:
            pulumi.set(__self__, "remote_debugging_enabled", remote_debugging_enabled)
        if remote_debugging_version is not None:
            pulumi.set(__self__, "remote_debugging_version", remote_debugging_version)
        if runtime_scale_monitoring_enabled is not None:
            pulumi.set(__self__, "runtime_scale_monitoring_enabled", runtime_scale_monitoring_enabled)
        if scm_ip_restrictions is not None:
            pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        if scm_minimum_tls_version is not None:
            pulumi.set(__self__, "scm_minimum_tls_version", scm_minimum_tls_version)
        if scm_type is not None:
            pulumi.set(__self__, "scm_type", scm_type)
        if scm_use_main_ip_restriction is not None:
            pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        if use32_bit_worker is not None:
            pulumi.set(__self__, "use32_bit_worker", use32_bit_worker)
        if vnet_route_all_enabled is not None:
            pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        if websockets_enabled is not None:
            pulumi.set(__self__, "websockets_enabled", websockets_enabled)
        if worker_count is not None:
            pulumi.set(__self__, "worker_count", worker_count)

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> Optional[bool]:
        """
        If this Linux Web App is Always On enabled. Defaults to `false`.
        """
        return pulumi.get(self, "always_on")

    @property
    @pulumi.getter(name="apiDefinitionUrl")
    def api_definition_url(self) -> Optional[str]:
        """
        The URL of the API definition that describes this Linux Function App.
        """
        return pulumi.get(self, "api_definition_url")

    @property
    @pulumi.getter(name="apiManagementApiId")
    def api_management_api_id(self) -> Optional[str]:
        """
        The ID of the API Management API for this Linux Function App.
        """
        return pulumi.get(self, "api_management_api_id")

    @property
    @pulumi.getter(name="appCommandLine")
    def app_command_line(self) -> Optional[str]:
        """
        The program and any arguments used to launch this app via the command line. (Example `node myapp.js`).
        """
        return pulumi.get(self, "app_command_line")

    @property
    @pulumi.getter(name="appScaleLimit")
    def app_scale_limit(self) -> Optional[int]:
        """
        The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
        """
        return pulumi.get(self, "app_scale_limit")

    @property
    @pulumi.getter(name="appServiceLogs")
    def app_service_logs(self) -> Optional['outputs.LinuxFunctionAppSlotSiteConfigAppServiceLogs']:
        """
        an `app_service_logs` block as detailed below.
        """
        return pulumi.get(self, "app_service_logs")

    @property
    @pulumi.getter(name="applicationInsightsConnectionString")
    def application_insights_connection_string(self) -> Optional[str]:
        """
        The Connection String for linking the Linux Function App to Application Insights.
        """
        return pulumi.get(self, "application_insights_connection_string")

    @property
    @pulumi.getter(name="applicationInsightsKey")
    def application_insights_key(self) -> Optional[str]:
        """
        The Instrumentation Key for connecting the Linux Function App to Application Insights.
        """
        return pulumi.get(self, "application_insights_key")

    @property
    @pulumi.getter(name="applicationStack")
    def application_stack(self) -> Optional['outputs.LinuxFunctionAppSlotSiteConfigApplicationStack']:
        """
        an `application_stack` block as detailed below.
        """
        return pulumi.get(self, "application_stack")

    @property
    @pulumi.getter(name="autoSwapSlotName")
    def auto_swap_slot_name(self) -> Optional[str]:
        """
        The name of the slot to automatically swap with when this slot is successfully deployed.
        """
        return pulumi.get(self, "auto_swap_slot_name")

    @property
    @pulumi.getter(name="containerRegistryManagedIdentityClientId")
    def container_registry_managed_identity_client_id(self) -> Optional[str]:
        """
        The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
        """
        return pulumi.get(self, "container_registry_managed_identity_client_id")

    @property
    @pulumi.getter(name="containerRegistryUseManagedIdentity")
    def container_registry_use_managed_identity(self) -> Optional[bool]:
        """
        Should connections for Azure Container Registry use Managed Identity.
        """
        return pulumi.get(self, "container_registry_use_managed_identity")

    @property
    @pulumi.getter
    def cors(self) -> Optional['outputs.LinuxFunctionAppSlotSiteConfigCors']:
        """
        a `cors` block as detailed below.
        """
        return pulumi.get(self, "cors")

    @property
    @pulumi.getter(name="defaultDocuments")
    def default_documents(self) -> Optional[Sequence[str]]:
        """
        a `default_documents` block as detailed below.
        """
        return pulumi.get(self, "default_documents")

    @property
    @pulumi.getter(name="detailedErrorLoggingEnabled")
    def detailed_error_logging_enabled(self) -> Optional[bool]:
        """
        Is detailed error logging enabled
        """
        return pulumi.get(self, "detailed_error_logging_enabled")

    @property
    @pulumi.getter(name="elasticInstanceMinimum")
    def elastic_instance_minimum(self) -> Optional[int]:
        """
        The number of minimum instances for this Linux Function App. Only affects apps on Elastic Premium plans.
        """
        return pulumi.get(self, "elastic_instance_minimum")

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> Optional[str]:
        """
        State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`. Defaults to `Disabled`.
        """
        return pulumi.get(self, "ftps_state")

    @property
    @pulumi.getter(name="healthCheckEvictionTimeInMin")
    def health_check_eviction_time_in_min(self) -> Optional[int]:
        """
        The amount of time in minutes that a node is unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Defaults to `10`. Only valid in conjunction with `health_check_path`
        """
        return pulumi.get(self, "health_check_eviction_time_in_min")

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> Optional[str]:
        """
        The path to be checked for this function app health.
        """
        return pulumi.get(self, "health_check_path")

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[bool]:
        """
        Specifies if the HTTP2 protocol should be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "http2_enabled")

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Optional[Sequence['outputs.LinuxFunctionAppSlotSiteConfigIpRestriction']]:
        """
        an `ip_restriction` block as detailed below.
        """
        return pulumi.get(self, "ip_restrictions")

    @property
    @pulumi.getter(name="linuxFxVersion")
    def linux_fx_version(self) -> Optional[str]:
        """
        The Linux FX Version
        """
        return pulumi.get(self, "linux_fx_version")

    @property
    @pulumi.getter(name="loadBalancingMode")
    def load_balancing_mode(self) -> Optional[str]:
        """
        The Site load balancing mode. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        """
        return pulumi.get(self, "load_balancing_mode")

    @property
    @pulumi.getter(name="managedPipelineMode")
    def managed_pipeline_mode(self) -> Optional[str]:
        """
        The Managed Pipeline mode. Possible values include: `Integrated`, `Classic`. Defaults to `Integrated`.
        """
        return pulumi.get(self, "managed_pipeline_mode")

    @property
    @pulumi.getter(name="minimumTlsVersion")
    def minimum_tls_version(self) -> Optional[str]:
        """
        The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and  `1.2`. Defaults to `1.2`.
        """
        return pulumi.get(self, "minimum_tls_version")

    @property
    @pulumi.getter(name="preWarmedInstanceCount")
    def pre_warmed_instance_count(self) -> Optional[int]:
        """
        The number of pre-warmed instances for this function app. Only affects apps on an Elastic Premium plan.
        """
        return pulumi.get(self, "pre_warmed_instance_count")

    @property
    @pulumi.getter(name="remoteDebuggingEnabled")
    def remote_debugging_enabled(self) -> Optional[bool]:
        """
        Should Remote Debugging be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "remote_debugging_enabled")

    @property
    @pulumi.getter(name="remoteDebuggingVersion")
    def remote_debugging_version(self) -> Optional[str]:
        """
        The Remote Debugging Version. Possible values include `VS2017`, `VS2019`, and `VS2022`
        """
        return pulumi.get(self, "remote_debugging_version")

    @property
    @pulumi.getter(name="runtimeScaleMonitoringEnabled")
    def runtime_scale_monitoring_enabled(self) -> Optional[bool]:
        """
        Should Functions Runtime Scale Monitoring be enabled.
        """
        return pulumi.get(self, "runtime_scale_monitoring_enabled")

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Optional[Sequence['outputs.LinuxFunctionAppSlotSiteConfigScmIpRestriction']]:
        """
        a `scm_ip_restriction` block as detailed below.
        """
        return pulumi.get(self, "scm_ip_restrictions")

    @property
    @pulumi.getter(name="scmMinimumTlsVersion")
    def scm_minimum_tls_version(self) -> Optional[str]:
        """
        Configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and  `1.2`. Defaults to `1.2`.
        """
        return pulumi.get(self, "scm_minimum_tls_version")

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> Optional[str]:
        """
        The SCM Type in use by the Linux Function App.
        """
        return pulumi.get(self, "scm_type")

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> Optional[bool]:
        """
        Should the Linux Function App `ip_restriction` configuration be used for the SCM also.
        """
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @property
    @pulumi.getter(name="use32BitWorker")
    def use32_bit_worker(self) -> Optional[bool]:
        """
        Should the Linux Web App use a 32-bit worker.
        """
        return pulumi.get(self, "use32_bit_worker")

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> Optional[bool]:
        """
        Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        """
        return pulumi.get(self, "vnet_route_all_enabled")

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> Optional[bool]:
        """
        Should Web Sockets be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "websockets_enabled")

    @property
    @pulumi.getter(name="workerCount")
    def worker_count(self) -> Optional[int]:
        """
        The number of Workers for this Linux Function App.
        """
        return pulumi.get(self, "worker_count")


@pulumi.output_type
class LinuxFunctionAppSlotSiteConfigAppServiceLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskQuotaMb":
            suggest = "disk_quota_mb"
        elif key == "retentionPeriodDays":
            suggest = "retention_period_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotSiteConfigAppServiceLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotSiteConfigAppServiceLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotSiteConfigAppServiceLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_quota_mb: Optional[int] = None,
                 retention_period_days: Optional[int] = None):
        """
        :param int disk_quota_mb: The amount of disk space to use for logs. Valid values are between `25` and `100`.
        :param int retention_period_days: The retention period for logs in days. Valid values are between `0` and `99999`. Defaults to `0` (never delete).
        """
        if disk_quota_mb is not None:
            pulumi.set(__self__, "disk_quota_mb", disk_quota_mb)
        if retention_period_days is not None:
            pulumi.set(__self__, "retention_period_days", retention_period_days)

    @property
    @pulumi.getter(name="diskQuotaMb")
    def disk_quota_mb(self) -> Optional[int]:
        """
        The amount of disk space to use for logs. Valid values are between `25` and `100`.
        """
        return pulumi.get(self, "disk_quota_mb")

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> Optional[int]:
        """
        The retention period for logs in days. Valid values are between `0` and `99999`. Defaults to `0` (never delete).
        """
        return pulumi.get(self, "retention_period_days")


@pulumi.output_type
class LinuxFunctionAppSlotSiteConfigApplicationStack(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dotnetVersion":
            suggest = "dotnet_version"
        elif key == "javaVersion":
            suggest = "java_version"
        elif key == "nodeVersion":
            suggest = "node_version"
        elif key == "powershellCoreVersion":
            suggest = "powershell_core_version"
        elif key == "pythonVersion":
            suggest = "python_version"
        elif key == "useCustomRuntime":
            suggest = "use_custom_runtime"
        elif key == "useDotnetIsolatedRuntime":
            suggest = "use_dotnet_isolated_runtime"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotSiteConfigApplicationStack. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotSiteConfigApplicationStack.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotSiteConfigApplicationStack.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dockers: Optional[Sequence['outputs.LinuxFunctionAppSlotSiteConfigApplicationStackDocker']] = None,
                 dotnet_version: Optional[str] = None,
                 java_version: Optional[str] = None,
                 node_version: Optional[str] = None,
                 powershell_core_version: Optional[str] = None,
                 python_version: Optional[str] = None,
                 use_custom_runtime: Optional[bool] = None,
                 use_dotnet_isolated_runtime: Optional[bool] = None):
        """
        :param Sequence['LinuxFunctionAppSlotSiteConfigApplicationStackDockerArgs'] dockers: a `docker` block as detailed below.
        :param str dotnet_version: The version of .Net. Possible values are `3.1`, `6.0` and `7.0`.
        :param str java_version: The version of Java to use. Possible values are `8`, `11` & `17` (In-Preview).
        :param str node_version: The version of Node to use. Possible values include `12`, `14`, `16` and `18`
        :param str powershell_core_version: The version of PowerShell Core to use. Possibles values are `7` , and `7.2`.
        :param str python_version: The version of Python to use. Possible values include `3.9`, `3.8`, and `3.7`.
        :param bool use_custom_runtime: Should the Linux Function App use a custom runtime?
        :param bool use_dotnet_isolated_runtime: Should the DotNet process use an isolated runtime. Defaults to `false`.
        """
        if dockers is not None:
            pulumi.set(__self__, "dockers", dockers)
        if dotnet_version is not None:
            pulumi.set(__self__, "dotnet_version", dotnet_version)
        if java_version is not None:
            pulumi.set(__self__, "java_version", java_version)
        if node_version is not None:
            pulumi.set(__self__, "node_version", node_version)
        if powershell_core_version is not None:
            pulumi.set(__self__, "powershell_core_version", powershell_core_version)
        if python_version is not None:
            pulumi.set(__self__, "python_version", python_version)
        if use_custom_runtime is not None:
            pulumi.set(__self__, "use_custom_runtime", use_custom_runtime)
        if use_dotnet_isolated_runtime is not None:
            pulumi.set(__self__, "use_dotnet_isolated_runtime", use_dotnet_isolated_runtime)

    @property
    @pulumi.getter
    def dockers(self) -> Optional[Sequence['outputs.LinuxFunctionAppSlotSiteConfigApplicationStackDocker']]:
        """
        a `docker` block as detailed below.
        """
        return pulumi.get(self, "dockers")

    @property
    @pulumi.getter(name="dotnetVersion")
    def dotnet_version(self) -> Optional[str]:
        """
        The version of .Net. Possible values are `3.1`, `6.0` and `7.0`.
        """
        return pulumi.get(self, "dotnet_version")

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> Optional[str]:
        """
        The version of Java to use. Possible values are `8`, `11` & `17` (In-Preview).
        """
        return pulumi.get(self, "java_version")

    @property
    @pulumi.getter(name="nodeVersion")
    def node_version(self) -> Optional[str]:
        """
        The version of Node to use. Possible values include `12`, `14`, `16` and `18`
        """
        return pulumi.get(self, "node_version")

    @property
    @pulumi.getter(name="powershellCoreVersion")
    def powershell_core_version(self) -> Optional[str]:
        """
        The version of PowerShell Core to use. Possibles values are `7` , and `7.2`.
        """
        return pulumi.get(self, "powershell_core_version")

    @property
    @pulumi.getter(name="pythonVersion")
    def python_version(self) -> Optional[str]:
        """
        The version of Python to use. Possible values include `3.9`, `3.8`, and `3.7`.
        """
        return pulumi.get(self, "python_version")

    @property
    @pulumi.getter(name="useCustomRuntime")
    def use_custom_runtime(self) -> Optional[bool]:
        """
        Should the Linux Function App use a custom runtime?
        """
        return pulumi.get(self, "use_custom_runtime")

    @property
    @pulumi.getter(name="useDotnetIsolatedRuntime")
    def use_dotnet_isolated_runtime(self) -> Optional[bool]:
        """
        Should the DotNet process use an isolated runtime. Defaults to `false`.
        """
        return pulumi.get(self, "use_dotnet_isolated_runtime")


@pulumi.output_type
class LinuxFunctionAppSlotSiteConfigApplicationStackDocker(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageName":
            suggest = "image_name"
        elif key == "imageTag":
            suggest = "image_tag"
        elif key == "registryUrl":
            suggest = "registry_url"
        elif key == "registryPassword":
            suggest = "registry_password"
        elif key == "registryUsername":
            suggest = "registry_username"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotSiteConfigApplicationStackDocker. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotSiteConfigApplicationStackDocker.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotSiteConfigApplicationStackDocker.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_name: str,
                 image_tag: str,
                 registry_url: str,
                 registry_password: Optional[str] = None,
                 registry_username: Optional[str] = None):
        """
        :param str image_name: The name of the Docker image to use.
        :param str image_tag: The image tag of the image to use.
        :param str registry_url: The URL of the docker registry.
        :param str registry_password: The password for the account to use to connect to the registry.
        :param str registry_username: The username to use for connections to the registry.
        """
        pulumi.set(__self__, "image_name", image_name)
        pulumi.set(__self__, "image_tag", image_tag)
        pulumi.set(__self__, "registry_url", registry_url)
        if registry_password is not None:
            pulumi.set(__self__, "registry_password", registry_password)
        if registry_username is not None:
            pulumi.set(__self__, "registry_username", registry_username)

    @property
    @pulumi.getter(name="imageName")
    def image_name(self) -> str:
        """
        The name of the Docker image to use.
        """
        return pulumi.get(self, "image_name")

    @property
    @pulumi.getter(name="imageTag")
    def image_tag(self) -> str:
        """
        The image tag of the image to use.
        """
        return pulumi.get(self, "image_tag")

    @property
    @pulumi.getter(name="registryUrl")
    def registry_url(self) -> str:
        """
        The URL of the docker registry.
        """
        return pulumi.get(self, "registry_url")

    @property
    @pulumi.getter(name="registryPassword")
    def registry_password(self) -> Optional[str]:
        """
        The password for the account to use to connect to the registry.
        """
        return pulumi.get(self, "registry_password")

    @property
    @pulumi.getter(name="registryUsername")
    def registry_username(self) -> Optional[str]:
        """
        The username to use for connections to the registry.
        """
        return pulumi.get(self, "registry_username")


@pulumi.output_type
class LinuxFunctionAppSlotSiteConfigCors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedOrigins":
            suggest = "allowed_origins"
        elif key == "supportCredentials":
            suggest = "support_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotSiteConfigCors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotSiteConfigCors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotSiteConfigCors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_origins: Sequence[str],
                 support_credentials: Optional[bool] = None):
        """
        :param Sequence[str] allowed_origins: an `allowed_origins` block as detailed below.
        :param bool support_credentials: Are credentials allowed in CORS requests? Defaults to `false`.
        """
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        if support_credentials is not None:
            pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Sequence[str]:
        """
        an `allowed_origins` block as detailed below.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> Optional[bool]:
        """
        Are credentials allowed in CORS requests? Defaults to `false`.
        """
        return pulumi.get(self, "support_credentials")


@pulumi.output_type
class LinuxFunctionAppSlotSiteConfigIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotSiteConfigIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotSiteConfigIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotSiteConfigIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.LinuxFunctionAppSlotSiteConfigIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: The action to take. Possible values are `Allow` or `Deny`.
        :param 'LinuxFunctionAppSlotSiteConfigIpRestrictionHeadersArgs' headers: a `headers` block as detailed below.
        :param str ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param str name: The name which should be used for this `ip_restriction`.
        :param int priority: The priority value of this `ip_restriction`.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        The action to take. Possible values are `Allow` or `Deny`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.LinuxFunctionAppSlotSiteConfigIpRestrictionHeaders']:
        """
        a `headers` block as detailed below.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority value of this `ip_restriction`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class LinuxFunctionAppSlotSiteConfigIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotSiteConfigIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param str x_fd_health_probe: Specifies if a Front Door Health Probe should be expected.
        :param Sequence[str] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param Sequence[str] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        Specifies if a Front Door Health Probe should be expected.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class LinuxFunctionAppSlotSiteConfigScmIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotSiteConfigScmIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotSiteConfigScmIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotSiteConfigScmIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.LinuxFunctionAppSlotSiteConfigScmIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: The action to take. Possible values are `Allow` or `Deny`.
        :param 'LinuxFunctionAppSlotSiteConfigScmIpRestrictionHeadersArgs' headers: a `headers` block as detailed below.
        :param str ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param str name: The name which should be used for this `ip_restriction`.
        :param int priority: The priority value of this `ip_restriction`.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.ENDEXPERIMENT
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        The action to take. Possible values are `Allow` or `Deny`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.LinuxFunctionAppSlotSiteConfigScmIpRestrictionHeaders']:
        """
        a `headers` block as detailed below.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority value of this `ip_restriction`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.ENDEXPERIMENT
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class LinuxFunctionAppSlotSiteConfigScmIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotSiteConfigScmIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param str x_fd_health_probe: Specifies if a Front Door Health Probe should be expected.
        :param Sequence[str] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param Sequence[str] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        Specifies if a Front Door Health Probe should be expected.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class LinuxFunctionAppSlotSiteCredential(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 password: Optional[str] = None):
        """
        :param str name: The Site Credentials Username used for publishing.
        :param str password: The Site Credentials Password used for publishing.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The Site Credentials Username used for publishing.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The Site Credentials Password used for publishing.
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class LinuxFunctionAppSlotStorageAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "accountName":
            suggest = "account_name"
        elif key == "shareName":
            suggest = "share_name"
        elif key == "mountPath":
            suggest = "mount_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppSlotStorageAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppSlotStorageAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppSlotStorageAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: str,
                 account_name: str,
                 name: str,
                 share_name: str,
                 type: str,
                 mount_path: Optional[str] = None):
        """
        :param str access_key: The Access key for the storage account.
        :param str account_name: The Name of the Storage Account.
        :param str name: The name which should be used for this Storage Account.
        :param str share_name: The Name of the File Share or Container Name for Blob storage.
        :param str type: The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`.
        :param str mount_path: The path at which to mount the storage share.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "share_name", share_name)
        pulumi.set(__self__, "type", type)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> str:
        """
        The Access key for the storage account.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> str:
        """
        The Name of the Storage Account.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Storage Account.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> str:
        """
        The Name of the File Share or Container Name for Blob storage.
        """
        return pulumi.get(self, "share_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[str]:
        """
        The path at which to mount the storage share.
        """
        return pulumi.get(self, "mount_path")


@pulumi.output_type
class LinuxFunctionAppStickySettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appSettingNames":
            suggest = "app_setting_names"
        elif key == "connectionStringNames":
            suggest = "connection_string_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppStickySettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppStickySettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppStickySettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_setting_names: Optional[Sequence[str]] = None,
                 connection_string_names: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] app_setting_names: A list of `app_setting` names that the Linux Function App will not swap between Slots when a swap operation is triggered.
        :param Sequence[str] connection_string_names: A list of `connection_string` names that the Linux Function App will not swap between Slots when a swap operation is triggered.
        """
        if app_setting_names is not None:
            pulumi.set(__self__, "app_setting_names", app_setting_names)
        if connection_string_names is not None:
            pulumi.set(__self__, "connection_string_names", connection_string_names)

    @property
    @pulumi.getter(name="appSettingNames")
    def app_setting_names(self) -> Optional[Sequence[str]]:
        """
        A list of `app_setting` names that the Linux Function App will not swap between Slots when a swap operation is triggered.
        """
        return pulumi.get(self, "app_setting_names")

    @property
    @pulumi.getter(name="connectionStringNames")
    def connection_string_names(self) -> Optional[Sequence[str]]:
        """
        A list of `connection_string` names that the Linux Function App will not swap between Slots when a swap operation is triggered.
        """
        return pulumi.get(self, "connection_string_names")


@pulumi.output_type
class LinuxFunctionAppStorageAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "accountName":
            suggest = "account_name"
        elif key == "shareName":
            suggest = "share_name"
        elif key == "mountPath":
            suggest = "mount_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxFunctionAppStorageAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxFunctionAppStorageAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxFunctionAppStorageAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: str,
                 account_name: str,
                 name: str,
                 share_name: str,
                 type: str,
                 mount_path: Optional[str] = None):
        """
        :param str access_key: The Access key for the storage account.
        :param str account_name: The Name of the Storage Account.
        :param str name: The name which should be used for this Storage Account.
        :param str share_name: The Name of the File Share or Container Name for Blob storage.
        :param str type: The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`.
        :param str mount_path: The path at which to mount the storage share.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "share_name", share_name)
        pulumi.set(__self__, "type", type)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> str:
        """
        The Access key for the storage account.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> str:
        """
        The Name of the Storage Account.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Storage Account.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> str:
        """
        The Name of the File Share or Container Name for Blob storage.
        """
        return pulumi.get(self, "share_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[str]:
        """
        The path at which to mount the storage share.
        """
        return pulumi.get(self, "mount_path")


@pulumi.output_type
class LinuxWebAppAuthSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeDirectory":
            suggest = "active_directory"
        elif key == "additionalLoginParameters":
            suggest = "additional_login_parameters"
        elif key == "allowedExternalRedirectUrls":
            suggest = "allowed_external_redirect_urls"
        elif key == "defaultProvider":
            suggest = "default_provider"
        elif key == "runtimeVersion":
            suggest = "runtime_version"
        elif key == "tokenRefreshExtensionHours":
            suggest = "token_refresh_extension_hours"
        elif key == "tokenStoreEnabled":
            suggest = "token_store_enabled"
        elif key == "unauthenticatedClientAction":
            suggest = "unauthenticated_client_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppAuthSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppAuthSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppAuthSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 active_directory: Optional['outputs.LinuxWebAppAuthSettingsActiveDirectory'] = None,
                 additional_login_parameters: Optional[Mapping[str, str]] = None,
                 allowed_external_redirect_urls: Optional[Sequence[str]] = None,
                 default_provider: Optional[str] = None,
                 facebook: Optional['outputs.LinuxWebAppAuthSettingsFacebook'] = None,
                 github: Optional['outputs.LinuxWebAppAuthSettingsGithub'] = None,
                 google: Optional['outputs.LinuxWebAppAuthSettingsGoogle'] = None,
                 issuer: Optional[str] = None,
                 microsoft: Optional['outputs.LinuxWebAppAuthSettingsMicrosoft'] = None,
                 runtime_version: Optional[str] = None,
                 token_refresh_extension_hours: Optional[float] = None,
                 token_store_enabled: Optional[bool] = None,
                 twitter: Optional['outputs.LinuxWebAppAuthSettingsTwitter'] = None,
                 unauthenticated_client_action: Optional[str] = None):
        """
        :param bool enabled: Should the Authentication / Authorization feature be enabled for the Linux Web App?
        :param 'LinuxWebAppAuthSettingsActiveDirectoryArgs' active_directory: An `active_directory` block as defined above.
        :param Mapping[str, str] additional_login_parameters: Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        :param Sequence[str] allowed_external_redirect_urls: Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Linux Web App.
        :param str default_provider: The default authentication provider to use when multiple providers are configured. Possible values include: `BuiltInAuthenticationProviderAzureActiveDirectory`, `BuiltInAuthenticationProviderFacebook`, `BuiltInAuthenticationProviderGoogle`, `BuiltInAuthenticationProviderMicrosoftAccount`, `BuiltInAuthenticationProviderTwitter`, `BuiltInAuthenticationProviderGithub`
        :param 'LinuxWebAppAuthSettingsFacebookArgs' facebook: A `facebook` block as defined below.
        :param 'LinuxWebAppAuthSettingsGithubArgs' github: A `github` block as defined below.
        :param 'LinuxWebAppAuthSettingsGoogleArgs' google: A `google` block as defined below.
        :param str issuer: The OpenID Connect Issuer URI that represents the entity that issues access tokens for this Linux Web App.
        :param 'LinuxWebAppAuthSettingsMicrosoftArgs' microsoft: A `microsoft` block as defined below.
        :param str runtime_version: The RuntimeVersion of the Authentication / Authorization feature in use for the Linux Web App.
        :param float token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        :param bool token_store_enabled: Should the Linux Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        :param 'LinuxWebAppAuthSettingsTwitterArgs' twitter: A `twitter` block as defined below.
        :param str unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if active_directory is not None:
            pulumi.set(__self__, "active_directory", active_directory)
        if additional_login_parameters is not None:
            pulumi.set(__self__, "additional_login_parameters", additional_login_parameters)
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if facebook is not None:
            pulumi.set(__self__, "facebook", facebook)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if google is not None:
            pulumi.set(__self__, "google", google)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if microsoft is not None:
            pulumi.set(__self__, "microsoft", microsoft)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if token_refresh_extension_hours is not None:
            pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if twitter is not None:
            pulumi.set(__self__, "twitter", twitter)
        if unauthenticated_client_action is not None:
            pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Should the Authentication / Authorization feature be enabled for the Linux Web App?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="activeDirectory")
    def active_directory(self) -> Optional['outputs.LinuxWebAppAuthSettingsActiveDirectory']:
        """
        An `active_directory` block as defined above.
        """
        return pulumi.get(self, "active_directory")

    @property
    @pulumi.getter(name="additionalLoginParameters")
    def additional_login_parameters(self) -> Optional[Mapping[str, str]]:
        """
        Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        """
        return pulumi.get(self, "additional_login_parameters")

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Linux Web App.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[str]:
        """
        The default authentication provider to use when multiple providers are configured. Possible values include: `BuiltInAuthenticationProviderAzureActiveDirectory`, `BuiltInAuthenticationProviderFacebook`, `BuiltInAuthenticationProviderGoogle`, `BuiltInAuthenticationProviderMicrosoftAccount`, `BuiltInAuthenticationProviderTwitter`, `BuiltInAuthenticationProviderGithub`
        """
        return pulumi.get(self, "default_provider")

    @property
    @pulumi.getter
    def facebook(self) -> Optional['outputs.LinuxWebAppAuthSettingsFacebook']:
        """
        A `facebook` block as defined below.
        """
        return pulumi.get(self, "facebook")

    @property
    @pulumi.getter
    def github(self) -> Optional['outputs.LinuxWebAppAuthSettingsGithub']:
        """
        A `github` block as defined below.
        """
        return pulumi.get(self, "github")

    @property
    @pulumi.getter
    def google(self) -> Optional['outputs.LinuxWebAppAuthSettingsGoogle']:
        """
        A `google` block as defined below.
        """
        return pulumi.get(self, "google")

    @property
    @pulumi.getter
    def issuer(self) -> Optional[str]:
        """
        The OpenID Connect Issuer URI that represents the entity that issues access tokens for this Linux Web App.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def microsoft(self) -> Optional['outputs.LinuxWebAppAuthSettingsMicrosoft']:
        """
        A `microsoft` block as defined below.
        """
        return pulumi.get(self, "microsoft")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[str]:
        """
        The RuntimeVersion of the Authentication / Authorization feature in use for the Linux Web App.
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> Optional[float]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        return pulumi.get(self, "token_refresh_extension_hours")

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[bool]:
        """
        Should the Linux Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        """
        return pulumi.get(self, "token_store_enabled")

    @property
    @pulumi.getter
    def twitter(self) -> Optional['outputs.LinuxWebAppAuthSettingsTwitter']:
        """
        A `twitter` block as defined below.
        """
        return pulumi.get(self, "twitter")

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> Optional[str]:
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        return pulumi.get(self, "unauthenticated_client_action")


@pulumi.output_type
class LinuxWebAppAuthSettingsActiveDirectory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppAuthSettingsActiveDirectory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppAuthSettingsActiveDirectory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppAuthSettingsActiveDirectory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param Sequence[str] allowed_audiences: Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
        :param str client_secret: The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        pulumi.set(__self__, "client_id", client_id)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")


@pulumi.output_type
class LinuxWebAppAuthSettingsFacebook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "appSecret":
            suggest = "app_secret"
        elif key == "appSecretSettingName":
            suggest = "app_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppAuthSettingsFacebook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppAuthSettingsFacebook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppAuthSettingsFacebook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: str,
                 app_secret: Optional[str] = None,
                 app_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str app_id: The App ID of the Facebook app used for login.
        :param str app_secret: The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        :param str app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        if app_secret is not None:
            pulumi.set(__self__, "app_secret", app_secret)
        if app_secret_setting_name is not None:
            pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appSecret")
    def app_secret(self) -> Optional[str]:
        """
        The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        """
        return pulumi.get(self, "app_secret")

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class LinuxWebAppAuthSettingsGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppAuthSettingsGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppAuthSettingsGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppAuthSettingsGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the GitHub app used for login.
        :param str client_secret: The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the GitHub app used for login.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class LinuxWebAppAuthSettingsGoogle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppAuthSettingsGoogle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppAuthSettingsGoogle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppAuthSettingsGoogle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OpenID Connect Client ID for the Google web application.
        :param str client_secret: The client secret associated with the Google web application.  Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OpenID Connect Client ID for the Google web application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The client secret associated with the Google web application.  Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class LinuxWebAppAuthSettingsMicrosoft(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppAuthSettingsMicrosoft. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppAuthSettingsMicrosoft.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppAuthSettingsMicrosoft.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret: The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, "wl.basic" is used as the default scope.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, "wl.basic" is used as the default scope.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class LinuxWebAppAuthSettingsTwitter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerKey":
            suggest = "consumer_key"
        elif key == "consumerSecret":
            suggest = "consumer_secret"
        elif key == "consumerSecretSettingName":
            suggest = "consumer_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppAuthSettingsTwitter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppAuthSettingsTwitter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppAuthSettingsTwitter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_key: str,
                 consumer_secret: Optional[str] = None,
                 consumer_secret_setting_name: Optional[str] = None):
        """
        :param str consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param str consumer_secret: The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        :param str consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        if consumer_secret is not None:
            pulumi.set(__self__, "consumer_secret", consumer_secret)
        if consumer_secret_setting_name is not None:
            pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> str:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> Optional[str]:
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        """
        return pulumi.get(self, "consumer_secret")

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        return pulumi.get(self, "consumer_secret_setting_name")


@pulumi.output_type
class LinuxWebAppBackup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageAccountUrl":
            suggest = "storage_account_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppBackup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppBackup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppBackup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 schedule: 'outputs.LinuxWebAppBackupSchedule',
                 storage_account_url: str,
                 enabled: Optional[bool] = None):
        """
        :param str name: The name which should be used for this Backup.
        :param 'LinuxWebAppBackupScheduleArgs' schedule: A `schedule` block as defined below.
        :param str storage_account_url: The SAS URL to the container.
        :param bool enabled: Should this backup job be enabled?
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "storage_account_url", storage_account_url)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Backup.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def schedule(self) -> 'outputs.LinuxWebAppBackupSchedule':
        """
        A `schedule` block as defined below.
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter(name="storageAccountUrl")
    def storage_account_url(self) -> str:
        """
        The SAS URL to the container.
        """
        return pulumi.get(self, "storage_account_url")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Should this backup job be enabled?
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class LinuxWebAppBackupSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "frequencyUnit":
            suggest = "frequency_unit"
        elif key == "keepAtLeastOneBackup":
            suggest = "keep_at_least_one_backup"
        elif key == "lastExecutionTime":
            suggest = "last_execution_time"
        elif key == "retentionPeriodDays":
            suggest = "retention_period_days"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppBackupSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppBackupSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppBackupSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_unit: str,
                 keep_at_least_one_backup: Optional[bool] = None,
                 last_execution_time: Optional[str] = None,
                 retention_period_days: Optional[int] = None,
                 start_time: Optional[str] = None):
        """
        :param int frequency_interval: How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).
        :param str frequency_unit: The unit of time for how often the backup should take place. Possible values include: `Day`, `Hour`
        :param bool keep_at_least_one_backup: Should the service keep at least one backup, regardless of the age of backup? Defaults to `false`.
        :param int retention_period_days: After how many days backups should be deleted.
        :param str start_time: When the schedule should start working in RFC-3339 format.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_unit", frequency_unit)
        if keep_at_least_one_backup is not None:
            pulumi.set(__self__, "keep_at_least_one_backup", keep_at_least_one_backup)
        if last_execution_time is not None:
            pulumi.set(__self__, "last_execution_time", last_execution_time)
        if retention_period_days is not None:
            pulumi.set(__self__, "retention_period_days", retention_period_days)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyUnit")
    def frequency_unit(self) -> str:
        """
        The unit of time for how often the backup should take place. Possible values include: `Day`, `Hour`
        """
        return pulumi.get(self, "frequency_unit")

    @property
    @pulumi.getter(name="keepAtLeastOneBackup")
    def keep_at_least_one_backup(self) -> Optional[bool]:
        """
        Should the service keep at least one backup, regardless of the age of backup? Defaults to `false`.
        """
        return pulumi.get(self, "keep_at_least_one_backup")

    @property
    @pulumi.getter(name="lastExecutionTime")
    def last_execution_time(self) -> Optional[str]:
        return pulumi.get(self, "last_execution_time")

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> Optional[int]:
        """
        After how many days backups should be deleted.
        """
        return pulumi.get(self, "retention_period_days")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        """
        When the schedule should start working in RFC-3339 format.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class LinuxWebAppConnectionString(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: The name of the Connection String.
        :param str type: Type of database. Possible values include: `MySQL`, `SQLServer`, `SQLAzure`, `Custom`, `NotificationHub`, `ServiceBus`, `EventHub`, `APIHub`, `DocDb`, `RedisCache`, and `PostgreSQL`.
        :param str value: The connection string value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Connection String.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of database. Possible values include: `MySQL`, `SQLServer`, `SQLAzure`, `Custom`, `NotificationHub`, `ServiceBus`, `EventHub`, `APIHub`, `DocDb`, `RedisCache`, and `PostgreSQL`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The connection string value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class LinuxWebAppIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 identity_ids: Optional[Sequence[str]] = None,
                 principal_id: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str type: Specifies the type of Managed Service Identity that should be configured on this Linux Web App. Possible values are `SystemAssigned`, `UserAssigned`, and `SystemAssigned, UserAssigned` (to enable both).
        :param Sequence[str] identity_ids: A list of User Assigned Managed Identity IDs to be assigned to this Linux Web App.
        :param str principal_id: The Principal ID associated with this Managed Service Identity.
        :param str tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the type of Managed Service Identity that should be configured on this Linux Web App. Possible values are `SystemAssigned`, `UserAssigned`, and `SystemAssigned, UserAssigned` (to enable both).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[str]]:
        """
        A list of User Assigned Managed Identity IDs to be assigned to this Linux Web App.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class LinuxWebAppLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationLogs":
            suggest = "application_logs"
        elif key == "detailedErrorMessages":
            suggest = "detailed_error_messages"
        elif key == "failedRequestTracing":
            suggest = "failed_request_tracing"
        elif key == "httpLogs":
            suggest = "http_logs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_logs: Optional['outputs.LinuxWebAppLogsApplicationLogs'] = None,
                 detailed_error_messages: Optional[bool] = None,
                 failed_request_tracing: Optional[bool] = None,
                 http_logs: Optional['outputs.LinuxWebAppLogsHttpLogs'] = None):
        """
        :param 'LinuxWebAppLogsApplicationLogsArgs' application_logs: A `application_logs` block as defined above.
        :param bool detailed_error_messages: Should detailed error messages be enabled?
        :param bool failed_request_tracing: Should the failed request tracing be enabled?
        :param 'LinuxWebAppLogsHttpLogsArgs' http_logs: An `http_logs` block as defined above.
        """
        if application_logs is not None:
            pulumi.set(__self__, "application_logs", application_logs)
        if detailed_error_messages is not None:
            pulumi.set(__self__, "detailed_error_messages", detailed_error_messages)
        if failed_request_tracing is not None:
            pulumi.set(__self__, "failed_request_tracing", failed_request_tracing)
        if http_logs is not None:
            pulumi.set(__self__, "http_logs", http_logs)

    @property
    @pulumi.getter(name="applicationLogs")
    def application_logs(self) -> Optional['outputs.LinuxWebAppLogsApplicationLogs']:
        """
        A `application_logs` block as defined above.
        """
        return pulumi.get(self, "application_logs")

    @property
    @pulumi.getter(name="detailedErrorMessages")
    def detailed_error_messages(self) -> Optional[bool]:
        """
        Should detailed error messages be enabled?
        """
        return pulumi.get(self, "detailed_error_messages")

    @property
    @pulumi.getter(name="failedRequestTracing")
    def failed_request_tracing(self) -> Optional[bool]:
        """
        Should the failed request tracing be enabled?
        """
        return pulumi.get(self, "failed_request_tracing")

    @property
    @pulumi.getter(name="httpLogs")
    def http_logs(self) -> Optional['outputs.LinuxWebAppLogsHttpLogs']:
        """
        An `http_logs` block as defined above.
        """
        return pulumi.get(self, "http_logs")


@pulumi.output_type
class LinuxWebAppLogsApplicationLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileSystemLevel":
            suggest = "file_system_level"
        elif key == "azureBlobStorage":
            suggest = "azure_blob_storage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppLogsApplicationLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppLogsApplicationLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppLogsApplicationLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_system_level: str,
                 azure_blob_storage: Optional['outputs.LinuxWebAppLogsApplicationLogsAzureBlobStorage'] = None):
        """
        :param str file_system_level: Log level. Possible values include: `Verbose`, `Information`, `Warning`, and `Error`.
        :param 'LinuxWebAppLogsApplicationLogsAzureBlobStorageArgs' azure_blob_storage: An `azure_blob_storage` block as defined below.
        """
        pulumi.set(__self__, "file_system_level", file_system_level)
        if azure_blob_storage is not None:
            pulumi.set(__self__, "azure_blob_storage", azure_blob_storage)

    @property
    @pulumi.getter(name="fileSystemLevel")
    def file_system_level(self) -> str:
        """
        Log level. Possible values include: `Verbose`, `Information`, `Warning`, and `Error`.
        """
        return pulumi.get(self, "file_system_level")

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional['outputs.LinuxWebAppLogsApplicationLogsAzureBlobStorage']:
        """
        An `azure_blob_storage` block as defined below.
        """
        return pulumi.get(self, "azure_blob_storage")


@pulumi.output_type
class LinuxWebAppLogsApplicationLogsAzureBlobStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retentionInDays":
            suggest = "retention_in_days"
        elif key == "sasUrl":
            suggest = "sas_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppLogsApplicationLogsAzureBlobStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppLogsApplicationLogsAzureBlobStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppLogsApplicationLogsAzureBlobStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 level: str,
                 retention_in_days: int,
                 sas_url: str):
        """
        :param str level: The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        :param int retention_in_days: The time in days after which to remove blobs. A value of `0` means no retention.
        :param str sas_url: SAS url to an Azure blob container with read/write/list/delete permissions.
        """
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "sas_url", sas_url)

    @property
    @pulumi.getter
    def level(self) -> str:
        """
        The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        """
        return pulumi.get(self, "level")

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> int:
        """
        The time in days after which to remove blobs. A value of `0` means no retention.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> str:
        """
        SAS url to an Azure blob container with read/write/list/delete permissions.
        """
        return pulumi.get(self, "sas_url")


@pulumi.output_type
class LinuxWebAppLogsHttpLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureBlobStorage":
            suggest = "azure_blob_storage"
        elif key == "fileSystem":
            suggest = "file_system"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppLogsHttpLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppLogsHttpLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppLogsHttpLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_blob_storage: Optional['outputs.LinuxWebAppLogsHttpLogsAzureBlobStorage'] = None,
                 file_system: Optional['outputs.LinuxWebAppLogsHttpLogsFileSystem'] = None):
        """
        :param 'LinuxWebAppLogsHttpLogsAzureBlobStorageArgs' azure_blob_storage: A `azure_blob_storage` block as defined above.
        :param 'LinuxWebAppLogsHttpLogsFileSystemArgs' file_system: A `file_system` block as defined above.
        """
        if azure_blob_storage is not None:
            pulumi.set(__self__, "azure_blob_storage", azure_blob_storage)
        if file_system is not None:
            pulumi.set(__self__, "file_system", file_system)

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional['outputs.LinuxWebAppLogsHttpLogsAzureBlobStorage']:
        """
        A `azure_blob_storage` block as defined above.
        """
        return pulumi.get(self, "azure_blob_storage")

    @property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional['outputs.LinuxWebAppLogsHttpLogsFileSystem']:
        """
        A `file_system` block as defined above.
        """
        return pulumi.get(self, "file_system")


@pulumi.output_type
class LinuxWebAppLogsHttpLogsAzureBlobStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sasUrl":
            suggest = "sas_url"
        elif key == "retentionInDays":
            suggest = "retention_in_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppLogsHttpLogsAzureBlobStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppLogsHttpLogsAzureBlobStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppLogsHttpLogsAzureBlobStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sas_url: str,
                 retention_in_days: Optional[int] = None):
        """
        :param str sas_url: SAS url to an Azure blob container with read/write/list/delete permissions.
        :param int retention_in_days: The time in days after which to remove blobs. A value of `0` means no retention.
        """
        pulumi.set(__self__, "sas_url", sas_url)
        if retention_in_days is not None:
            pulumi.set(__self__, "retention_in_days", retention_in_days)

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> str:
        """
        SAS url to an Azure blob container with read/write/list/delete permissions.
        """
        return pulumi.get(self, "sas_url")

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> Optional[int]:
        """
        The time in days after which to remove blobs. A value of `0` means no retention.
        """
        return pulumi.get(self, "retention_in_days")


@pulumi.output_type
class LinuxWebAppLogsHttpLogsFileSystem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retentionInDays":
            suggest = "retention_in_days"
        elif key == "retentionInMb":
            suggest = "retention_in_mb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppLogsHttpLogsFileSystem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppLogsHttpLogsFileSystem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppLogsHttpLogsFileSystem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 retention_in_days: int,
                 retention_in_mb: int):
        """
        :param int retention_in_days: The retention period in days. A value of `0` means no retention.
        :param int retention_in_mb: The maximum size in megabytes that log files can use.
        """
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "retention_in_mb", retention_in_mb)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> int:
        """
        The retention period in days. A value of `0` means no retention.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="retentionInMb")
    def retention_in_mb(self) -> int:
        """
        The maximum size in megabytes that log files can use.
        """
        return pulumi.get(self, "retention_in_mb")


@pulumi.output_type
class LinuxWebAppSiteConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alwaysOn":
            suggest = "always_on"
        elif key == "apiDefinitionUrl":
            suggest = "api_definition_url"
        elif key == "apiManagementApiId":
            suggest = "api_management_api_id"
        elif key == "appCommandLine":
            suggest = "app_command_line"
        elif key == "applicationStack":
            suggest = "application_stack"
        elif key == "autoHealEnabled":
            suggest = "auto_heal_enabled"
        elif key == "autoHealSetting":
            suggest = "auto_heal_setting"
        elif key == "containerRegistryManagedIdentityClientId":
            suggest = "container_registry_managed_identity_client_id"
        elif key == "containerRegistryUseManagedIdentity":
            suggest = "container_registry_use_managed_identity"
        elif key == "defaultDocuments":
            suggest = "default_documents"
        elif key == "detailedErrorLoggingEnabled":
            suggest = "detailed_error_logging_enabled"
        elif key == "ftpsState":
            suggest = "ftps_state"
        elif key == "healthCheckEvictionTimeInMin":
            suggest = "health_check_eviction_time_in_min"
        elif key == "healthCheckPath":
            suggest = "health_check_path"
        elif key == "http2Enabled":
            suggest = "http2_enabled"
        elif key == "ipRestrictions":
            suggest = "ip_restrictions"
        elif key == "linuxFxVersion":
            suggest = "linux_fx_version"
        elif key == "loadBalancingMode":
            suggest = "load_balancing_mode"
        elif key == "localMysqlEnabled":
            suggest = "local_mysql_enabled"
        elif key == "managedPipelineMode":
            suggest = "managed_pipeline_mode"
        elif key == "minimumTlsVersion":
            suggest = "minimum_tls_version"
        elif key == "remoteDebuggingEnabled":
            suggest = "remote_debugging_enabled"
        elif key == "remoteDebuggingVersion":
            suggest = "remote_debugging_version"
        elif key == "scmIpRestrictions":
            suggest = "scm_ip_restrictions"
        elif key == "scmMinimumTlsVersion":
            suggest = "scm_minimum_tls_version"
        elif key == "scmType":
            suggest = "scm_type"
        elif key == "scmUseMainIpRestriction":
            suggest = "scm_use_main_ip_restriction"
        elif key == "use32BitWorker":
            suggest = "use32_bit_worker"
        elif key == "vnetRouteAllEnabled":
            suggest = "vnet_route_all_enabled"
        elif key == "websocketsEnabled":
            suggest = "websockets_enabled"
        elif key == "workerCount":
            suggest = "worker_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSiteConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSiteConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSiteConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 always_on: Optional[bool] = None,
                 api_definition_url: Optional[str] = None,
                 api_management_api_id: Optional[str] = None,
                 app_command_line: Optional[str] = None,
                 application_stack: Optional['outputs.LinuxWebAppSiteConfigApplicationStack'] = None,
                 auto_heal_enabled: Optional[bool] = None,
                 auto_heal_setting: Optional['outputs.LinuxWebAppSiteConfigAutoHealSetting'] = None,
                 container_registry_managed_identity_client_id: Optional[str] = None,
                 container_registry_use_managed_identity: Optional[bool] = None,
                 cors: Optional['outputs.LinuxWebAppSiteConfigCors'] = None,
                 default_documents: Optional[Sequence[str]] = None,
                 detailed_error_logging_enabled: Optional[bool] = None,
                 ftps_state: Optional[str] = None,
                 health_check_eviction_time_in_min: Optional[int] = None,
                 health_check_path: Optional[str] = None,
                 http2_enabled: Optional[bool] = None,
                 ip_restrictions: Optional[Sequence['outputs.LinuxWebAppSiteConfigIpRestriction']] = None,
                 linux_fx_version: Optional[str] = None,
                 load_balancing_mode: Optional[str] = None,
                 local_mysql_enabled: Optional[bool] = None,
                 managed_pipeline_mode: Optional[str] = None,
                 minimum_tls_version: Optional[str] = None,
                 remote_debugging_enabled: Optional[bool] = None,
                 remote_debugging_version: Optional[str] = None,
                 scm_ip_restrictions: Optional[Sequence['outputs.LinuxWebAppSiteConfigScmIpRestriction']] = None,
                 scm_minimum_tls_version: Optional[str] = None,
                 scm_type: Optional[str] = None,
                 scm_use_main_ip_restriction: Optional[bool] = None,
                 use32_bit_worker: Optional[bool] = None,
                 vnet_route_all_enabled: Optional[bool] = None,
                 websockets_enabled: Optional[bool] = None,
                 worker_count: Optional[int] = None):
        """
        :param bool always_on: If this Linux Web App is Always On enabled. Defaults to `true`.
        :param str api_definition_url: The URL to the API Definition for this Linux Web App.
        :param str api_management_api_id: The API Management API ID this Linux Web App is associated with.
        :param str app_command_line: The App command line to launch.
        :param 'LinuxWebAppSiteConfigApplicationStackArgs' application_stack: A `application_stack` block as defined above.
        :param bool auto_heal_enabled: Should Auto heal rules be enabled? Required with `auto_heal_setting`.
        :param 'LinuxWebAppSiteConfigAutoHealSettingArgs' auto_heal_setting: A `auto_heal_setting` block as defined above. Required with `auto_heal`.
        :param str container_registry_managed_identity_client_id: The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
        :param bool container_registry_use_managed_identity: Should connections for Azure Container Registry use Managed Identity.
        :param 'LinuxWebAppSiteConfigCorsArgs' cors: A `cors` block as defined above.
        :param Sequence[str] default_documents: Specifies a list of Default Documents for the Linux Web App.
        :param str ftps_state: The State of FTP / FTPS service. Possible values include `AllAllowed`, `FtpsOnly`, and `Disabled`.
        :param int health_check_eviction_time_in_min: The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        :param str health_check_path: The path to the Health Check.
        :param bool http2_enabled: Should the HTTP2 be enabled?
        :param Sequence['LinuxWebAppSiteConfigIpRestrictionArgs'] ip_restrictions: One or more `ip_restriction` blocks as defined above.
        :param str load_balancing_mode: The Site load balancing. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        :param bool local_mysql_enabled: Use Local MySQL. Defaults to `false`.
        :param str managed_pipeline_mode: Managed pipeline mode. Possible values include `Integrated`, and `Classic`.
        :param str minimum_tls_version: The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and  `1.2`. Defaults to `1.2`.
        :param bool remote_debugging_enabled: Should Remote Debugging be enabled? Defaults to `false`.
        :param str remote_debugging_version: The Remote Debugging Version. Possible values include `VS2017` and `VS2019`
        :param Sequence['LinuxWebAppSiteConfigScmIpRestrictionArgs'] scm_ip_restrictions: One or more `scm_ip_restriction` blocks as defined above.
        :param str scm_minimum_tls_version: The configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and  `1.2`. Defaults to `1.2`.
        :param bool scm_use_main_ip_restriction: Should the Linux Web App `ip_restriction` configuration be used for the SCM also.
        :param bool use32_bit_worker: Should the Linux Web App use a 32-bit worker? Defaults to `true`.
        :param bool vnet_route_all_enabled: Should all outbound traffic have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        :param bool websockets_enabled: Should Web Sockets be enabled? Defaults to `false`.
        :param int worker_count: The number of Workers for this Linux App Service.
        """
        if always_on is not None:
            pulumi.set(__self__, "always_on", always_on)
        if api_definition_url is not None:
            pulumi.set(__self__, "api_definition_url", api_definition_url)
        if api_management_api_id is not None:
            pulumi.set(__self__, "api_management_api_id", api_management_api_id)
        if app_command_line is not None:
            pulumi.set(__self__, "app_command_line", app_command_line)
        if application_stack is not None:
            pulumi.set(__self__, "application_stack", application_stack)
        if auto_heal_enabled is not None:
            pulumi.set(__self__, "auto_heal_enabled", auto_heal_enabled)
        if auto_heal_setting is not None:
            pulumi.set(__self__, "auto_heal_setting", auto_heal_setting)
        if container_registry_managed_identity_client_id is not None:
            pulumi.set(__self__, "container_registry_managed_identity_client_id", container_registry_managed_identity_client_id)
        if container_registry_use_managed_identity is not None:
            pulumi.set(__self__, "container_registry_use_managed_identity", container_registry_use_managed_identity)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if default_documents is not None:
            pulumi.set(__self__, "default_documents", default_documents)
        if detailed_error_logging_enabled is not None:
            pulumi.set(__self__, "detailed_error_logging_enabled", detailed_error_logging_enabled)
        if ftps_state is not None:
            pulumi.set(__self__, "ftps_state", ftps_state)
        if health_check_eviction_time_in_min is not None:
            pulumi.set(__self__, "health_check_eviction_time_in_min", health_check_eviction_time_in_min)
        if health_check_path is not None:
            pulumi.set(__self__, "health_check_path", health_check_path)
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if ip_restrictions is not None:
            pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        if linux_fx_version is not None:
            pulumi.set(__self__, "linux_fx_version", linux_fx_version)
        if load_balancing_mode is not None:
            pulumi.set(__self__, "load_balancing_mode", load_balancing_mode)
        if local_mysql_enabled is not None:
            pulumi.set(__self__, "local_mysql_enabled", local_mysql_enabled)
        if managed_pipeline_mode is not None:
            pulumi.set(__self__, "managed_pipeline_mode", managed_pipeline_mode)
        if minimum_tls_version is not None:
            pulumi.set(__self__, "minimum_tls_version", minimum_tls_version)
        if remote_debugging_enabled is not None:
            pulumi.set(__self__, "remote_debugging_enabled", remote_debugging_enabled)
        if remote_debugging_version is not None:
            pulumi.set(__self__, "remote_debugging_version", remote_debugging_version)
        if scm_ip_restrictions is not None:
            pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        if scm_minimum_tls_version is not None:
            pulumi.set(__self__, "scm_minimum_tls_version", scm_minimum_tls_version)
        if scm_type is not None:
            pulumi.set(__self__, "scm_type", scm_type)
        if scm_use_main_ip_restriction is not None:
            pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        if use32_bit_worker is not None:
            pulumi.set(__self__, "use32_bit_worker", use32_bit_worker)
        if vnet_route_all_enabled is not None:
            pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        if websockets_enabled is not None:
            pulumi.set(__self__, "websockets_enabled", websockets_enabled)
        if worker_count is not None:
            pulumi.set(__self__, "worker_count", worker_count)

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> Optional[bool]:
        """
        If this Linux Web App is Always On enabled. Defaults to `true`.
        """
        return pulumi.get(self, "always_on")

    @property
    @pulumi.getter(name="apiDefinitionUrl")
    def api_definition_url(self) -> Optional[str]:
        """
        The URL to the API Definition for this Linux Web App.
        """
        return pulumi.get(self, "api_definition_url")

    @property
    @pulumi.getter(name="apiManagementApiId")
    def api_management_api_id(self) -> Optional[str]:
        """
        The API Management API ID this Linux Web App is associated with.
        """
        return pulumi.get(self, "api_management_api_id")

    @property
    @pulumi.getter(name="appCommandLine")
    def app_command_line(self) -> Optional[str]:
        """
        The App command line to launch.
        """
        return pulumi.get(self, "app_command_line")

    @property
    @pulumi.getter(name="applicationStack")
    def application_stack(self) -> Optional['outputs.LinuxWebAppSiteConfigApplicationStack']:
        """
        A `application_stack` block as defined above.
        """
        return pulumi.get(self, "application_stack")

    @property
    @pulumi.getter(name="autoHealEnabled")
    def auto_heal_enabled(self) -> Optional[bool]:
        """
        Should Auto heal rules be enabled? Required with `auto_heal_setting`.
        """
        return pulumi.get(self, "auto_heal_enabled")

    @property
    @pulumi.getter(name="autoHealSetting")
    def auto_heal_setting(self) -> Optional['outputs.LinuxWebAppSiteConfigAutoHealSetting']:
        """
        A `auto_heal_setting` block as defined above. Required with `auto_heal`.
        """
        return pulumi.get(self, "auto_heal_setting")

    @property
    @pulumi.getter(name="containerRegistryManagedIdentityClientId")
    def container_registry_managed_identity_client_id(self) -> Optional[str]:
        """
        The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
        """
        return pulumi.get(self, "container_registry_managed_identity_client_id")

    @property
    @pulumi.getter(name="containerRegistryUseManagedIdentity")
    def container_registry_use_managed_identity(self) -> Optional[bool]:
        """
        Should connections for Azure Container Registry use Managed Identity.
        """
        return pulumi.get(self, "container_registry_use_managed_identity")

    @property
    @pulumi.getter
    def cors(self) -> Optional['outputs.LinuxWebAppSiteConfigCors']:
        """
        A `cors` block as defined above.
        """
        return pulumi.get(self, "cors")

    @property
    @pulumi.getter(name="defaultDocuments")
    def default_documents(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Default Documents for the Linux Web App.
        """
        return pulumi.get(self, "default_documents")

    @property
    @pulumi.getter(name="detailedErrorLoggingEnabled")
    def detailed_error_logging_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "detailed_error_logging_enabled")

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> Optional[str]:
        """
        The State of FTP / FTPS service. Possible values include `AllAllowed`, `FtpsOnly`, and `Disabled`.
        """
        return pulumi.get(self, "ftps_state")

    @property
    @pulumi.getter(name="healthCheckEvictionTimeInMin")
    def health_check_eviction_time_in_min(self) -> Optional[int]:
        """
        The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        """
        return pulumi.get(self, "health_check_eviction_time_in_min")

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> Optional[str]:
        """
        The path to the Health Check.
        """
        return pulumi.get(self, "health_check_path")

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[bool]:
        """
        Should the HTTP2 be enabled?
        """
        return pulumi.get(self, "http2_enabled")

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Optional[Sequence['outputs.LinuxWebAppSiteConfigIpRestriction']]:
        """
        One or more `ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "ip_restrictions")

    @property
    @pulumi.getter(name="linuxFxVersion")
    def linux_fx_version(self) -> Optional[str]:
        return pulumi.get(self, "linux_fx_version")

    @property
    @pulumi.getter(name="loadBalancingMode")
    def load_balancing_mode(self) -> Optional[str]:
        """
        The Site load balancing. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        """
        return pulumi.get(self, "load_balancing_mode")

    @property
    @pulumi.getter(name="localMysqlEnabled")
    def local_mysql_enabled(self) -> Optional[bool]:
        """
        Use Local MySQL. Defaults to `false`.
        """
        return pulumi.get(self, "local_mysql_enabled")

    @property
    @pulumi.getter(name="managedPipelineMode")
    def managed_pipeline_mode(self) -> Optional[str]:
        """
        Managed pipeline mode. Possible values include `Integrated`, and `Classic`.
        """
        return pulumi.get(self, "managed_pipeline_mode")

    @property
    @pulumi.getter(name="minimumTlsVersion")
    def minimum_tls_version(self) -> Optional[str]:
        """
        The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and  `1.2`. Defaults to `1.2`.
        """
        return pulumi.get(self, "minimum_tls_version")

    @property
    @pulumi.getter(name="remoteDebuggingEnabled")
    def remote_debugging_enabled(self) -> Optional[bool]:
        """
        Should Remote Debugging be enabled? Defaults to `false`.
        """
        return pulumi.get(self, "remote_debugging_enabled")

    @property
    @pulumi.getter(name="remoteDebuggingVersion")
    def remote_debugging_version(self) -> Optional[str]:
        """
        The Remote Debugging Version. Possible values include `VS2017` and `VS2019`
        """
        return pulumi.get(self, "remote_debugging_version")

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Optional[Sequence['outputs.LinuxWebAppSiteConfigScmIpRestriction']]:
        """
        One or more `scm_ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "scm_ip_restrictions")

    @property
    @pulumi.getter(name="scmMinimumTlsVersion")
    def scm_minimum_tls_version(self) -> Optional[str]:
        """
        The configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and  `1.2`. Defaults to `1.2`.
        """
        return pulumi.get(self, "scm_minimum_tls_version")

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> Optional[str]:
        return pulumi.get(self, "scm_type")

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> Optional[bool]:
        """
        Should the Linux Web App `ip_restriction` configuration be used for the SCM also.
        """
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @property
    @pulumi.getter(name="use32BitWorker")
    def use32_bit_worker(self) -> Optional[bool]:
        """
        Should the Linux Web App use a 32-bit worker? Defaults to `true`.
        """
        return pulumi.get(self, "use32_bit_worker")

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> Optional[bool]:
        """
        Should all outbound traffic have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        """
        return pulumi.get(self, "vnet_route_all_enabled")

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> Optional[bool]:
        """
        Should Web Sockets be enabled? Defaults to `false`.
        """
        return pulumi.get(self, "websockets_enabled")

    @property
    @pulumi.getter(name="workerCount")
    def worker_count(self) -> Optional[int]:
        """
        The number of Workers for this Linux App Service.
        """
        return pulumi.get(self, "worker_count")


@pulumi.output_type
class LinuxWebAppSiteConfigApplicationStack(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dockerImage":
            suggest = "docker_image"
        elif key == "dockerImageTag":
            suggest = "docker_image_tag"
        elif key == "dotnetVersion":
            suggest = "dotnet_version"
        elif key == "javaServer":
            suggest = "java_server"
        elif key == "javaServerVersion":
            suggest = "java_server_version"
        elif key == "javaVersion":
            suggest = "java_version"
        elif key == "nodeVersion":
            suggest = "node_version"
        elif key == "phpVersion":
            suggest = "php_version"
        elif key == "pythonVersion":
            suggest = "python_version"
        elif key == "rubyVersion":
            suggest = "ruby_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSiteConfigApplicationStack. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSiteConfigApplicationStack.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSiteConfigApplicationStack.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 docker_image: Optional[str] = None,
                 docker_image_tag: Optional[str] = None,
                 dotnet_version: Optional[str] = None,
                 java_server: Optional[str] = None,
                 java_server_version: Optional[str] = None,
                 java_version: Optional[str] = None,
                 node_version: Optional[str] = None,
                 php_version: Optional[str] = None,
                 python_version: Optional[str] = None,
                 ruby_version: Optional[str] = None):
        """
        :param str docker_image: The Docker image reference, including repository host as needed.
        :param str docker_image_tag: The image Tag to use. e.g. `latest`.
        :param str dotnet_version: The version of .NET to use. Possible values include `3.1`, `5.0`, `6.0` and `7.0`.
        :param str java_server: The Java server type. Possible values include `JAVA`, `TOMCAT`, and `JBOSSEAP`.
        :param str java_server_version: The Version of the `java_server` to use.
        :param str java_version: The Version of Java to use. Supported versions of Java vary depending on the `java_server` and `java_server_version`, as well as security and fixes to major versions. Please see Azure documentation for the latest information.
        :param str node_version: The version of Node to run. Possible values include `12-lts`, `14-lts`, and `16-lts`. This property conflicts with `java_version`.
        :param str php_version: The version of PHP to run. Possible values include `7.4`, and `8.0`.
        :param str python_version: The version of Python to run. Possible values include `3.7`, `3.8`, `3.9` and `3.10`.
        :param str ruby_version: Te version of Ruby to run. Possible values include `2.6` and `2.7`.
        """
        if docker_image is not None:
            pulumi.set(__self__, "docker_image", docker_image)
        if docker_image_tag is not None:
            pulumi.set(__self__, "docker_image_tag", docker_image_tag)
        if dotnet_version is not None:
            pulumi.set(__self__, "dotnet_version", dotnet_version)
        if java_server is not None:
            pulumi.set(__self__, "java_server", java_server)
        if java_server_version is not None:
            pulumi.set(__self__, "java_server_version", java_server_version)
        if java_version is not None:
            pulumi.set(__self__, "java_version", java_version)
        if node_version is not None:
            pulumi.set(__self__, "node_version", node_version)
        if php_version is not None:
            pulumi.set(__self__, "php_version", php_version)
        if python_version is not None:
            pulumi.set(__self__, "python_version", python_version)
        if ruby_version is not None:
            pulumi.set(__self__, "ruby_version", ruby_version)

    @property
    @pulumi.getter(name="dockerImage")
    def docker_image(self) -> Optional[str]:
        """
        The Docker image reference, including repository host as needed.
        """
        return pulumi.get(self, "docker_image")

    @property
    @pulumi.getter(name="dockerImageTag")
    def docker_image_tag(self) -> Optional[str]:
        """
        The image Tag to use. e.g. `latest`.
        """
        return pulumi.get(self, "docker_image_tag")

    @property
    @pulumi.getter(name="dotnetVersion")
    def dotnet_version(self) -> Optional[str]:
        """
        The version of .NET to use. Possible values include `3.1`, `5.0`, `6.0` and `7.0`.
        """
        return pulumi.get(self, "dotnet_version")

    @property
    @pulumi.getter(name="javaServer")
    def java_server(self) -> Optional[str]:
        """
        The Java server type. Possible values include `JAVA`, `TOMCAT`, and `JBOSSEAP`.
        """
        return pulumi.get(self, "java_server")

    @property
    @pulumi.getter(name="javaServerVersion")
    def java_server_version(self) -> Optional[str]:
        """
        The Version of the `java_server` to use.
        """
        return pulumi.get(self, "java_server_version")

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> Optional[str]:
        """
        The Version of Java to use. Supported versions of Java vary depending on the `java_server` and `java_server_version`, as well as security and fixes to major versions. Please see Azure documentation for the latest information.
        """
        return pulumi.get(self, "java_version")

    @property
    @pulumi.getter(name="nodeVersion")
    def node_version(self) -> Optional[str]:
        """
        The version of Node to run. Possible values include `12-lts`, `14-lts`, and `16-lts`. This property conflicts with `java_version`.
        """
        return pulumi.get(self, "node_version")

    @property
    @pulumi.getter(name="phpVersion")
    def php_version(self) -> Optional[str]:
        """
        The version of PHP to run. Possible values include `7.4`, and `8.0`.
        """
        return pulumi.get(self, "php_version")

    @property
    @pulumi.getter(name="pythonVersion")
    def python_version(self) -> Optional[str]:
        """
        The version of Python to run. Possible values include `3.7`, `3.8`, `3.9` and `3.10`.
        """
        return pulumi.get(self, "python_version")

    @property
    @pulumi.getter(name="rubyVersion")
    def ruby_version(self) -> Optional[str]:
        """
        Te version of Ruby to run. Possible values include `2.6` and `2.7`.
        """
        return pulumi.get(self, "ruby_version")


@pulumi.output_type
class LinuxWebAppSiteConfigAutoHealSetting(dict):
    def __init__(__self__, *,
                 action: Optional['outputs.LinuxWebAppSiteConfigAutoHealSettingAction'] = None,
                 trigger: Optional['outputs.LinuxWebAppSiteConfigAutoHealSettingTrigger'] = None):
        """
        :param 'LinuxWebAppSiteConfigAutoHealSettingActionArgs' action: A `action` block as defined above.
        :param 'LinuxWebAppSiteConfigAutoHealSettingTriggerArgs' trigger: A `trigger` block as defined below.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if trigger is not None:
            pulumi.set(__self__, "trigger", trigger)

    @property
    @pulumi.getter
    def action(self) -> Optional['outputs.LinuxWebAppSiteConfigAutoHealSettingAction']:
        """
        A `action` block as defined above.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def trigger(self) -> Optional['outputs.LinuxWebAppSiteConfigAutoHealSettingTrigger']:
        """
        A `trigger` block as defined below.
        """
        return pulumi.get(self, "trigger")


@pulumi.output_type
class LinuxWebAppSiteConfigAutoHealSettingAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionType":
            suggest = "action_type"
        elif key == "minimumProcessExecutionTime":
            suggest = "minimum_process_execution_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSiteConfigAutoHealSettingAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSiteConfigAutoHealSettingAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSiteConfigAutoHealSettingAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_type: str,
                 minimum_process_execution_time: Optional[str] = None):
        """
        :param str action_type: Predefined action to be taken to an Auto Heal trigger. Possible values include: `Recycle`.
        :param str minimum_process_execution_time: The minimum amount of time in `hh:mm:ss` the Linux Web App must have been running before the defined action will be run in the event of a trigger.
        """
        pulumi.set(__self__, "action_type", action_type)
        if minimum_process_execution_time is not None:
            pulumi.set(__self__, "minimum_process_execution_time", minimum_process_execution_time)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> str:
        """
        Predefined action to be taken to an Auto Heal trigger. Possible values include: `Recycle`.
        """
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter(name="minimumProcessExecutionTime")
    def minimum_process_execution_time(self) -> Optional[str]:
        """
        The minimum amount of time in `hh:mm:ss` the Linux Web App must have been running before the defined action will be run in the event of a trigger.
        """
        return pulumi.get(self, "minimum_process_execution_time")


@pulumi.output_type
class LinuxWebAppSiteConfigAutoHealSettingTrigger(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slowRequests":
            suggest = "slow_requests"
        elif key == "statusCodes":
            suggest = "status_codes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSiteConfigAutoHealSettingTrigger. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSiteConfigAutoHealSettingTrigger.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSiteConfigAutoHealSettingTrigger.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 requests: Optional['outputs.LinuxWebAppSiteConfigAutoHealSettingTriggerRequests'] = None,
                 slow_requests: Optional[Sequence['outputs.LinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequest']] = None,
                 status_codes: Optional[Sequence['outputs.LinuxWebAppSiteConfigAutoHealSettingTriggerStatusCode']] = None):
        """
        :param 'LinuxWebAppSiteConfigAutoHealSettingTriggerRequestsArgs' requests: A `requests` block as defined above.
        :param Sequence['LinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequestArgs'] slow_requests: One or more `slow_request` blocks as defined above.
        :param Sequence['LinuxWebAppSiteConfigAutoHealSettingTriggerStatusCodeArgs'] status_codes: One or more `status_code` blocks as defined above.
        """
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if slow_requests is not None:
            pulumi.set(__self__, "slow_requests", slow_requests)
        if status_codes is not None:
            pulumi.set(__self__, "status_codes", status_codes)

    @property
    @pulumi.getter
    def requests(self) -> Optional['outputs.LinuxWebAppSiteConfigAutoHealSettingTriggerRequests']:
        """
        A `requests` block as defined above.
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="slowRequests")
    def slow_requests(self) -> Optional[Sequence['outputs.LinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequest']]:
        """
        One or more `slow_request` blocks as defined above.
        """
        return pulumi.get(self, "slow_requests")

    @property
    @pulumi.getter(name="statusCodes")
    def status_codes(self) -> Optional[Sequence['outputs.LinuxWebAppSiteConfigAutoHealSettingTriggerStatusCode']]:
        """
        One or more `status_code` blocks as defined above.
        """
        return pulumi.get(self, "status_codes")


@pulumi.output_type
class LinuxWebAppSiteConfigAutoHealSettingTriggerRequests(dict):
    def __init__(__self__, *,
                 count: int,
                 interval: str):
        """
        :param int count: The number of requests in the specified `interval` to trigger this rule.
        :param str interval: The interval in `hh:mm:ss`.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of requests in the specified `interval` to trigger this rule.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        The interval in `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class LinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeTaken":
            suggest = "time_taken"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: int,
                 interval: str,
                 time_taken: str,
                 path: Optional[str] = None):
        """
        :param int count: The number of Slow Requests in the time `interval` to trigger this rule.
        :param str interval: The time interval in the form `hh:mm:ss`.
        :param str time_taken: The threshold of time passed to qualify as a Slow Request in `hh:mm:ss`.
        :param str path: The path for which this slow request rule applies.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "time_taken", time_taken)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of Slow Requests in the time `interval` to trigger this rule.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        The time interval in the form `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="timeTaken")
    def time_taken(self) -> str:
        """
        The threshold of time passed to qualify as a Slow Request in `hh:mm:ss`.
        """
        return pulumi.get(self, "time_taken")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path for which this slow request rule applies.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class LinuxWebAppSiteConfigAutoHealSettingTriggerStatusCode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusCodeRange":
            suggest = "status_code_range"
        elif key == "subStatus":
            suggest = "sub_status"
        elif key == "win32Status":
            suggest = "win32_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSiteConfigAutoHealSettingTriggerStatusCode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSiteConfigAutoHealSettingTriggerStatusCode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSiteConfigAutoHealSettingTriggerStatusCode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: int,
                 interval: str,
                 status_code_range: str,
                 path: Optional[str] = None,
                 sub_status: Optional[int] = None,
                 win32_status: Optional[str] = None):
        """
        :param int count: The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        :param str interval: The time interval in the form `hh:mm:ss`.
        :param str status_code_range: The status code for this rule, accepts single status codes and status code ranges. e.g. `500` or `400-499`. Possible values are integers between `101` and `599`
        :param str path: The path to which this rule status code applies.
        :param int sub_status: The Request Sub Status of the Status Code.
        :param str win32_status: The Win32 Status Code of the Request.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "status_code_range", status_code_range)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if sub_status is not None:
            pulumi.set(__self__, "sub_status", sub_status)
        if win32_status is not None:
            pulumi.set(__self__, "win32_status", win32_status)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        The time interval in the form `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="statusCodeRange")
    def status_code_range(self) -> str:
        """
        The status code for this rule, accepts single status codes and status code ranges. e.g. `500` or `400-499`. Possible values are integers between `101` and `599`
        """
        return pulumi.get(self, "status_code_range")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path to which this rule status code applies.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="subStatus")
    def sub_status(self) -> Optional[int]:
        """
        The Request Sub Status of the Status Code.
        """
        return pulumi.get(self, "sub_status")

    @property
    @pulumi.getter(name="win32Status")
    def win32_status(self) -> Optional[str]:
        """
        The Win32 Status Code of the Request.
        """
        return pulumi.get(self, "win32_status")


@pulumi.output_type
class LinuxWebAppSiteConfigCors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedOrigins":
            suggest = "allowed_origins"
        elif key == "supportCredentials":
            suggest = "support_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSiteConfigCors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSiteConfigCors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSiteConfigCors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_origins: Sequence[str],
                 support_credentials: Optional[bool] = None):
        """
        :param Sequence[str] allowed_origins: Specifies a list of origins that should be allowed to make cross-origin calls.
        :param bool support_credentials: Whether CORS requests with credentials are allowed. Defaults to `false`
        """
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        if support_credentials is not None:
            pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Sequence[str]:
        """
        Specifies a list of origins that should be allowed to make cross-origin calls.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> Optional[bool]:
        """
        Whether CORS requests with credentials are allowed. Defaults to `false`
        """
        return pulumi.get(self, "support_credentials")


@pulumi.output_type
class LinuxWebAppSiteConfigIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSiteConfigIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSiteConfigIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSiteConfigIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.LinuxWebAppSiteConfigIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: The action to take. Possible values are `Allow` or `Deny`.
        :param 'LinuxWebAppSiteConfigIpRestrictionHeadersArgs' headers: A `headers` block as defined above.
        :param str ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param str name: The name which should be used for this `ip_restriction`.
        :param int priority: The priority value of this `ip_restriction`.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        The action to take. Possible values are `Allow` or `Deny`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.LinuxWebAppSiteConfigIpRestrictionHeaders']:
        """
        A `headers` block as defined above.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority value of this `ip_restriction`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class LinuxWebAppSiteConfigIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSiteConfigIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param str x_fd_health_probe: Specifies if a Front Door Health Probe should be expected.
        :param Sequence[str] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param Sequence[str] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        Specifies if a Front Door Health Probe should be expected.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class LinuxWebAppSiteConfigScmIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSiteConfigScmIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSiteConfigScmIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSiteConfigScmIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.LinuxWebAppSiteConfigScmIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: The action to take. Possible values are `Allow` or `Deny`.
        :param 'LinuxWebAppSiteConfigScmIpRestrictionHeadersArgs' headers: A `headers` block as defined above.
        :param str ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param str name: The name which should be used for this `ip_restriction`.
        :param int priority: The priority value of this `ip_restriction`.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        The action to take. Possible values are `Allow` or `Deny`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.LinuxWebAppSiteConfigScmIpRestrictionHeaders']:
        """
        A `headers` block as defined above.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority value of this `ip_restriction`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class LinuxWebAppSiteConfigScmIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSiteConfigScmIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param str x_fd_health_probe: Specifies if a Front Door Health Probe should be expected.
        :param Sequence[str] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param Sequence[str] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        Specifies if a Front Door Health Probe should be expected.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class LinuxWebAppSiteCredential(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 password: Optional[str] = None):
        """
        :param str name: The name which should be used for this Linux Web App. Changing this forces a new Linux Web App to be created.
        :param str password: The Site Credentials Password used for publishing.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name which should be used for this Linux Web App. Changing this forces a new Linux Web App to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The Site Credentials Password used for publishing.
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class LinuxWebAppSlotAuthSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeDirectory":
            suggest = "active_directory"
        elif key == "additionalLoginParameters":
            suggest = "additional_login_parameters"
        elif key == "allowedExternalRedirectUrls":
            suggest = "allowed_external_redirect_urls"
        elif key == "defaultProvider":
            suggest = "default_provider"
        elif key == "runtimeVersion":
            suggest = "runtime_version"
        elif key == "tokenRefreshExtensionHours":
            suggest = "token_refresh_extension_hours"
        elif key == "tokenStoreEnabled":
            suggest = "token_store_enabled"
        elif key == "unauthenticatedClientAction":
            suggest = "unauthenticated_client_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotAuthSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotAuthSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotAuthSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 active_directory: Optional['outputs.LinuxWebAppSlotAuthSettingsActiveDirectory'] = None,
                 additional_login_parameters: Optional[Mapping[str, str]] = None,
                 allowed_external_redirect_urls: Optional[Sequence[str]] = None,
                 default_provider: Optional[str] = None,
                 facebook: Optional['outputs.LinuxWebAppSlotAuthSettingsFacebook'] = None,
                 github: Optional['outputs.LinuxWebAppSlotAuthSettingsGithub'] = None,
                 google: Optional['outputs.LinuxWebAppSlotAuthSettingsGoogle'] = None,
                 issuer: Optional[str] = None,
                 microsoft: Optional['outputs.LinuxWebAppSlotAuthSettingsMicrosoft'] = None,
                 runtime_version: Optional[str] = None,
                 token_refresh_extension_hours: Optional[float] = None,
                 token_store_enabled: Optional[bool] = None,
                 twitter: Optional['outputs.LinuxWebAppSlotAuthSettingsTwitter'] = None,
                 unauthenticated_client_action: Optional[str] = None):
        """
        :param bool enabled: Should the Authentication / Authorization feature be enabled for the Linux Web App?
        :param 'LinuxWebAppSlotAuthSettingsActiveDirectoryArgs' active_directory: An `active_directory` block as defined above.
        :param Mapping[str, str] additional_login_parameters: Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        :param Sequence[str] allowed_external_redirect_urls: Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Linux Web App.
        :param str default_provider: The default authentication provider to use when multiple providers are configured. Possible values include: `BuiltInAuthenticationProviderAzureActiveDirectory`, `BuiltInAuthenticationProviderFacebook`, `BuiltInAuthenticationProviderGoogle`, `BuiltInAuthenticationProviderMicrosoftAccount`, `BuiltInAuthenticationProviderTwitter`, `BuiltInAuthenticationProviderGithub`
        :param 'LinuxWebAppSlotAuthSettingsFacebookArgs' facebook: A `facebook` block as defined below.
        :param 'LinuxWebAppSlotAuthSettingsGithubArgs' github: A `github` block as defined below.
        :param 'LinuxWebAppSlotAuthSettingsGoogleArgs' google: A `google` block as defined below.
        :param str issuer: The OpenID Connect Issuer URI that represents the entity that issues access tokens for this Linux Web App.
        :param 'LinuxWebAppSlotAuthSettingsMicrosoftArgs' microsoft: A `microsoft` block as defined below.
        :param str runtime_version: The RuntimeVersion of the Authentication / Authorization feature in use for the Linux Web App.
        :param float token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        :param bool token_store_enabled: Should the Linux Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        :param 'LinuxWebAppSlotAuthSettingsTwitterArgs' twitter: A `twitter` block as defined below.
        :param str unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if active_directory is not None:
            pulumi.set(__self__, "active_directory", active_directory)
        if additional_login_parameters is not None:
            pulumi.set(__self__, "additional_login_parameters", additional_login_parameters)
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if facebook is not None:
            pulumi.set(__self__, "facebook", facebook)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if google is not None:
            pulumi.set(__self__, "google", google)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if microsoft is not None:
            pulumi.set(__self__, "microsoft", microsoft)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if token_refresh_extension_hours is not None:
            pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if twitter is not None:
            pulumi.set(__self__, "twitter", twitter)
        if unauthenticated_client_action is not None:
            pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Should the Authentication / Authorization feature be enabled for the Linux Web App?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="activeDirectory")
    def active_directory(self) -> Optional['outputs.LinuxWebAppSlotAuthSettingsActiveDirectory']:
        """
        An `active_directory` block as defined above.
        """
        return pulumi.get(self, "active_directory")

    @property
    @pulumi.getter(name="additionalLoginParameters")
    def additional_login_parameters(self) -> Optional[Mapping[str, str]]:
        """
        Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        """
        return pulumi.get(self, "additional_login_parameters")

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Linux Web App.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[str]:
        """
        The default authentication provider to use when multiple providers are configured. Possible values include: `BuiltInAuthenticationProviderAzureActiveDirectory`, `BuiltInAuthenticationProviderFacebook`, `BuiltInAuthenticationProviderGoogle`, `BuiltInAuthenticationProviderMicrosoftAccount`, `BuiltInAuthenticationProviderTwitter`, `BuiltInAuthenticationProviderGithub`
        """
        return pulumi.get(self, "default_provider")

    @property
    @pulumi.getter
    def facebook(self) -> Optional['outputs.LinuxWebAppSlotAuthSettingsFacebook']:
        """
        A `facebook` block as defined below.
        """
        return pulumi.get(self, "facebook")

    @property
    @pulumi.getter
    def github(self) -> Optional['outputs.LinuxWebAppSlotAuthSettingsGithub']:
        """
        A `github` block as defined below.
        """
        return pulumi.get(self, "github")

    @property
    @pulumi.getter
    def google(self) -> Optional['outputs.LinuxWebAppSlotAuthSettingsGoogle']:
        """
        A `google` block as defined below.
        """
        return pulumi.get(self, "google")

    @property
    @pulumi.getter
    def issuer(self) -> Optional[str]:
        """
        The OpenID Connect Issuer URI that represents the entity that issues access tokens for this Linux Web App.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def microsoft(self) -> Optional['outputs.LinuxWebAppSlotAuthSettingsMicrosoft']:
        """
        A `microsoft` block as defined below.
        """
        return pulumi.get(self, "microsoft")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[str]:
        """
        The RuntimeVersion of the Authentication / Authorization feature in use for the Linux Web App.
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> Optional[float]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        return pulumi.get(self, "token_refresh_extension_hours")

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[bool]:
        """
        Should the Linux Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        """
        return pulumi.get(self, "token_store_enabled")

    @property
    @pulumi.getter
    def twitter(self) -> Optional['outputs.LinuxWebAppSlotAuthSettingsTwitter']:
        """
        A `twitter` block as defined below.
        """
        return pulumi.get(self, "twitter")

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> Optional[str]:
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        return pulumi.get(self, "unauthenticated_client_action")


@pulumi.output_type
class LinuxWebAppSlotAuthSettingsActiveDirectory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotAuthSettingsActiveDirectory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotAuthSettingsActiveDirectory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotAuthSettingsActiveDirectory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param Sequence[str] allowed_audiences: Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
        :param str client_secret: The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        pulumi.set(__self__, "client_id", client_id)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")


@pulumi.output_type
class LinuxWebAppSlotAuthSettingsFacebook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "appSecret":
            suggest = "app_secret"
        elif key == "appSecretSettingName":
            suggest = "app_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotAuthSettingsFacebook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotAuthSettingsFacebook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotAuthSettingsFacebook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: str,
                 app_secret: Optional[str] = None,
                 app_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str app_id: The App ID of the Facebook app used for login.
        :param str app_secret: The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        :param str app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        if app_secret is not None:
            pulumi.set(__self__, "app_secret", app_secret)
        if app_secret_setting_name is not None:
            pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appSecret")
    def app_secret(self) -> Optional[str]:
        """
        The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        """
        return pulumi.get(self, "app_secret")

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class LinuxWebAppSlotAuthSettingsGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotAuthSettingsGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotAuthSettingsGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotAuthSettingsGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the GitHub app used for login.
        :param str client_secret: The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the GitHub app used for login.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class LinuxWebAppSlotAuthSettingsGoogle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotAuthSettingsGoogle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotAuthSettingsGoogle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotAuthSettingsGoogle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OpenID Connect Client ID for the Google web application.
        :param str client_secret: The client secret associated with the Google web application.  Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OpenID Connect Client ID for the Google web application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The client secret associated with the Google web application.  Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class LinuxWebAppSlotAuthSettingsMicrosoft(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotAuthSettingsMicrosoft. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotAuthSettingsMicrosoft.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotAuthSettingsMicrosoft.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret: The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, "wl.basic" is used as the default scope.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, "wl.basic" is used as the default scope.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class LinuxWebAppSlotAuthSettingsTwitter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerKey":
            suggest = "consumer_key"
        elif key == "consumerSecret":
            suggest = "consumer_secret"
        elif key == "consumerSecretSettingName":
            suggest = "consumer_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotAuthSettingsTwitter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotAuthSettingsTwitter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotAuthSettingsTwitter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_key: str,
                 consumer_secret: Optional[str] = None,
                 consumer_secret_setting_name: Optional[str] = None):
        """
        :param str consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param str consumer_secret: The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        :param str consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        if consumer_secret is not None:
            pulumi.set(__self__, "consumer_secret", consumer_secret)
        if consumer_secret_setting_name is not None:
            pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> str:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> Optional[str]:
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        """
        return pulumi.get(self, "consumer_secret")

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        return pulumi.get(self, "consumer_secret_setting_name")


@pulumi.output_type
class LinuxWebAppSlotBackup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageAccountUrl":
            suggest = "storage_account_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotBackup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotBackup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotBackup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 schedule: 'outputs.LinuxWebAppSlotBackupSchedule',
                 storage_account_url: str,
                 enabled: Optional[bool] = None):
        """
        :param str name: The name which should be used for this Backup.
        :param 'LinuxWebAppSlotBackupScheduleArgs' schedule: An `schedule` block as defined below.
        :param str storage_account_url: The SAS URL to the container.
        :param bool enabled: Should this backup job be enabled?
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "storage_account_url", storage_account_url)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Backup.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def schedule(self) -> 'outputs.LinuxWebAppSlotBackupSchedule':
        """
        An `schedule` block as defined below.
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter(name="storageAccountUrl")
    def storage_account_url(self) -> str:
        """
        The SAS URL to the container.
        """
        return pulumi.get(self, "storage_account_url")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Should this backup job be enabled?
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class LinuxWebAppSlotBackupSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "frequencyUnit":
            suggest = "frequency_unit"
        elif key == "keepAtLeastOneBackup":
            suggest = "keep_at_least_one_backup"
        elif key == "lastExecutionTime":
            suggest = "last_execution_time"
        elif key == "retentionPeriodDays":
            suggest = "retention_period_days"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotBackupSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotBackupSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotBackupSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_unit: str,
                 keep_at_least_one_backup: Optional[bool] = None,
                 last_execution_time: Optional[str] = None,
                 retention_period_days: Optional[int] = None,
                 start_time: Optional[str] = None):
        """
        :param int frequency_interval: How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).
        :param str frequency_unit: The unit of time for how often the backup should take place. Possible values include: `Day`, `Hour`
        :param bool keep_at_least_one_backup: Should the service keep at least one backup, regardless of the age of backup? Defaults to `false`.
        :param int retention_period_days: After how many days backups should be deleted.
        :param str start_time: When the schedule should start working in RFC-3339 format.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_unit", frequency_unit)
        if keep_at_least_one_backup is not None:
            pulumi.set(__self__, "keep_at_least_one_backup", keep_at_least_one_backup)
        if last_execution_time is not None:
            pulumi.set(__self__, "last_execution_time", last_execution_time)
        if retention_period_days is not None:
            pulumi.set(__self__, "retention_period_days", retention_period_days)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyUnit")
    def frequency_unit(self) -> str:
        """
        The unit of time for how often the backup should take place. Possible values include: `Day`, `Hour`
        """
        return pulumi.get(self, "frequency_unit")

    @property
    @pulumi.getter(name="keepAtLeastOneBackup")
    def keep_at_least_one_backup(self) -> Optional[bool]:
        """
        Should the service keep at least one backup, regardless of the age of backup? Defaults to `false`.
        """
        return pulumi.get(self, "keep_at_least_one_backup")

    @property
    @pulumi.getter(name="lastExecutionTime")
    def last_execution_time(self) -> Optional[str]:
        return pulumi.get(self, "last_execution_time")

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> Optional[int]:
        """
        After how many days backups should be deleted.
        """
        return pulumi.get(self, "retention_period_days")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        """
        When the schedule should start working in RFC-3339 format.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class LinuxWebAppSlotConnectionString(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: The name which should be used for this Linux Web App Slot. Changing this forces a new Linux Web App Slot to be created.
        :param str type: Type of database. Possible values include `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
        :param str value: The connection string value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Linux Web App Slot. Changing this forces a new Linux Web App Slot to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of database. Possible values include `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The connection string value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class LinuxWebAppSlotIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 identity_ids: Optional[Sequence[str]] = None,
                 principal_id: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str type: Specifies the type of Managed Service Identity that should be configured on this Linux Web App Slot. Possible values are `SystemAssigned`, `UserAssigned` and `SystemAssigned, UserAssigned` (to enable both).
        :param Sequence[str] identity_ids: A list of User Assigned Managed Identity IDs to be assigned to this Linux Web App Slot.
        :param str principal_id: The Principal ID associated with this Managed Service Identity.
        :param str tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the type of Managed Service Identity that should be configured on this Linux Web App Slot. Possible values are `SystemAssigned`, `UserAssigned` and `SystemAssigned, UserAssigned` (to enable both).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[str]]:
        """
        A list of User Assigned Managed Identity IDs to be assigned to this Linux Web App Slot.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class LinuxWebAppSlotLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationLogs":
            suggest = "application_logs"
        elif key == "detailedErrorMessages":
            suggest = "detailed_error_messages"
        elif key == "failedRequestTracing":
            suggest = "failed_request_tracing"
        elif key == "httpLogs":
            suggest = "http_logs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_logs: Optional['outputs.LinuxWebAppSlotLogsApplicationLogs'] = None,
                 detailed_error_messages: Optional[bool] = None,
                 failed_request_tracing: Optional[bool] = None,
                 http_logs: Optional['outputs.LinuxWebAppSlotLogsHttpLogs'] = None):
        """
        :param 'LinuxWebAppSlotLogsApplicationLogsArgs' application_logs: A `application_logs` block as defined above.
        :param bool detailed_error_messages: Should detailed error messages be enabled?
        :param bool failed_request_tracing: Should the failed request tracing be enabled?
        :param 'LinuxWebAppSlotLogsHttpLogsArgs' http_logs: An `http_logs` block as defined above.
        """
        if application_logs is not None:
            pulumi.set(__self__, "application_logs", application_logs)
        if detailed_error_messages is not None:
            pulumi.set(__self__, "detailed_error_messages", detailed_error_messages)
        if failed_request_tracing is not None:
            pulumi.set(__self__, "failed_request_tracing", failed_request_tracing)
        if http_logs is not None:
            pulumi.set(__self__, "http_logs", http_logs)

    @property
    @pulumi.getter(name="applicationLogs")
    def application_logs(self) -> Optional['outputs.LinuxWebAppSlotLogsApplicationLogs']:
        """
        A `application_logs` block as defined above.
        """
        return pulumi.get(self, "application_logs")

    @property
    @pulumi.getter(name="detailedErrorMessages")
    def detailed_error_messages(self) -> Optional[bool]:
        """
        Should detailed error messages be enabled?
        """
        return pulumi.get(self, "detailed_error_messages")

    @property
    @pulumi.getter(name="failedRequestTracing")
    def failed_request_tracing(self) -> Optional[bool]:
        """
        Should the failed request tracing be enabled?
        """
        return pulumi.get(self, "failed_request_tracing")

    @property
    @pulumi.getter(name="httpLogs")
    def http_logs(self) -> Optional['outputs.LinuxWebAppSlotLogsHttpLogs']:
        """
        An `http_logs` block as defined above.
        """
        return pulumi.get(self, "http_logs")


@pulumi.output_type
class LinuxWebAppSlotLogsApplicationLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileSystemLevel":
            suggest = "file_system_level"
        elif key == "azureBlobStorage":
            suggest = "azure_blob_storage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotLogsApplicationLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotLogsApplicationLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotLogsApplicationLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_system_level: str,
                 azure_blob_storage: Optional['outputs.LinuxWebAppSlotLogsApplicationLogsAzureBlobStorage'] = None):
        """
        :param str file_system_level: Log level. Possible values include `Verbose`, `Information`, `Warning`, and `Error`.
        :param 'LinuxWebAppSlotLogsApplicationLogsAzureBlobStorageArgs' azure_blob_storage: An `azure_blob_storage` block as defined below.
        """
        pulumi.set(__self__, "file_system_level", file_system_level)
        if azure_blob_storage is not None:
            pulumi.set(__self__, "azure_blob_storage", azure_blob_storage)

    @property
    @pulumi.getter(name="fileSystemLevel")
    def file_system_level(self) -> str:
        """
        Log level. Possible values include `Verbose`, `Information`, `Warning`, and `Error`.
        """
        return pulumi.get(self, "file_system_level")

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional['outputs.LinuxWebAppSlotLogsApplicationLogsAzureBlobStorage']:
        """
        An `azure_blob_storage` block as defined below.
        """
        return pulumi.get(self, "azure_blob_storage")


@pulumi.output_type
class LinuxWebAppSlotLogsApplicationLogsAzureBlobStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retentionInDays":
            suggest = "retention_in_days"
        elif key == "sasUrl":
            suggest = "sas_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotLogsApplicationLogsAzureBlobStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotLogsApplicationLogsAzureBlobStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotLogsApplicationLogsAzureBlobStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 level: str,
                 retention_in_days: int,
                 sas_url: str):
        """
        :param str level: The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        :param int retention_in_days: The time in days after which to remove blobs. A value of `0` means no retention.
        :param str sas_url: SAS URL to an Azure blob container with read/write/list/delete permissions.
        """
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "sas_url", sas_url)

    @property
    @pulumi.getter
    def level(self) -> str:
        """
        The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        """
        return pulumi.get(self, "level")

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> int:
        """
        The time in days after which to remove blobs. A value of `0` means no retention.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> str:
        """
        SAS URL to an Azure blob container with read/write/list/delete permissions.
        """
        return pulumi.get(self, "sas_url")


@pulumi.output_type
class LinuxWebAppSlotLogsHttpLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureBlobStorage":
            suggest = "azure_blob_storage"
        elif key == "fileSystem":
            suggest = "file_system"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotLogsHttpLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotLogsHttpLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotLogsHttpLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_blob_storage: Optional['outputs.LinuxWebAppSlotLogsHttpLogsAzureBlobStorage'] = None,
                 file_system: Optional['outputs.LinuxWebAppSlotLogsHttpLogsFileSystem'] = None):
        """
        :param 'LinuxWebAppSlotLogsHttpLogsAzureBlobStorageArgs' azure_blob_storage: A `azure_blob_storage` block as defined above.
        :param 'LinuxWebAppSlotLogsHttpLogsFileSystemArgs' file_system: A `file_system` block as defined above.
        """
        if azure_blob_storage is not None:
            pulumi.set(__self__, "azure_blob_storage", azure_blob_storage)
        if file_system is not None:
            pulumi.set(__self__, "file_system", file_system)

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional['outputs.LinuxWebAppSlotLogsHttpLogsAzureBlobStorage']:
        """
        A `azure_blob_storage` block as defined above.
        """
        return pulumi.get(self, "azure_blob_storage")

    @property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional['outputs.LinuxWebAppSlotLogsHttpLogsFileSystem']:
        """
        A `file_system` block as defined above.
        """
        return pulumi.get(self, "file_system")


@pulumi.output_type
class LinuxWebAppSlotLogsHttpLogsAzureBlobStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sasUrl":
            suggest = "sas_url"
        elif key == "retentionInDays":
            suggest = "retention_in_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotLogsHttpLogsAzureBlobStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotLogsHttpLogsAzureBlobStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotLogsHttpLogsAzureBlobStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sas_url: str,
                 retention_in_days: Optional[int] = None):
        """
        :param str sas_url: SAS URL to an Azure blob container with read/write/list/delete permissions.
        :param int retention_in_days: The time in days after which to remove blobs. A value of `0` means no retention.
        """
        pulumi.set(__self__, "sas_url", sas_url)
        if retention_in_days is not None:
            pulumi.set(__self__, "retention_in_days", retention_in_days)

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> str:
        """
        SAS URL to an Azure blob container with read/write/list/delete permissions.
        """
        return pulumi.get(self, "sas_url")

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> Optional[int]:
        """
        The time in days after which to remove blobs. A value of `0` means no retention.
        """
        return pulumi.get(self, "retention_in_days")


@pulumi.output_type
class LinuxWebAppSlotLogsHttpLogsFileSystem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retentionInDays":
            suggest = "retention_in_days"
        elif key == "retentionInMb":
            suggest = "retention_in_mb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotLogsHttpLogsFileSystem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotLogsHttpLogsFileSystem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotLogsHttpLogsFileSystem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 retention_in_days: int,
                 retention_in_mb: int):
        """
        :param int retention_in_days: The retention period in days. A values of `0` means no retention.
        :param int retention_in_mb: The maximum size in megabytes that log files can use.
        """
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "retention_in_mb", retention_in_mb)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> int:
        """
        The retention period in days. A values of `0` means no retention.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="retentionInMb")
    def retention_in_mb(self) -> int:
        """
        The maximum size in megabytes that log files can use.
        """
        return pulumi.get(self, "retention_in_mb")


@pulumi.output_type
class LinuxWebAppSlotSiteConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alwaysOn":
            suggest = "always_on"
        elif key == "apiDefinitionUrl":
            suggest = "api_definition_url"
        elif key == "apiManagementApiId":
            suggest = "api_management_api_id"
        elif key == "appCommandLine":
            suggest = "app_command_line"
        elif key == "applicationStack":
            suggest = "application_stack"
        elif key == "autoHealEnabled":
            suggest = "auto_heal_enabled"
        elif key == "autoHealSetting":
            suggest = "auto_heal_setting"
        elif key == "autoSwapSlotName":
            suggest = "auto_swap_slot_name"
        elif key == "containerRegistryManagedIdentityClientId":
            suggest = "container_registry_managed_identity_client_id"
        elif key == "containerRegistryUseManagedIdentity":
            suggest = "container_registry_use_managed_identity"
        elif key == "defaultDocuments":
            suggest = "default_documents"
        elif key == "detailedErrorLoggingEnabled":
            suggest = "detailed_error_logging_enabled"
        elif key == "ftpsState":
            suggest = "ftps_state"
        elif key == "healthCheckEvictionTimeInMin":
            suggest = "health_check_eviction_time_in_min"
        elif key == "healthCheckPath":
            suggest = "health_check_path"
        elif key == "http2Enabled":
            suggest = "http2_enabled"
        elif key == "ipRestrictions":
            suggest = "ip_restrictions"
        elif key == "linuxFxVersion":
            suggest = "linux_fx_version"
        elif key == "loadBalancingMode":
            suggest = "load_balancing_mode"
        elif key == "localMysqlEnabled":
            suggest = "local_mysql_enabled"
        elif key == "managedPipelineMode":
            suggest = "managed_pipeline_mode"
        elif key == "minimumTlsVersion":
            suggest = "minimum_tls_version"
        elif key == "remoteDebuggingEnabled":
            suggest = "remote_debugging_enabled"
        elif key == "remoteDebuggingVersion":
            suggest = "remote_debugging_version"
        elif key == "scmIpRestrictions":
            suggest = "scm_ip_restrictions"
        elif key == "scmMinimumTlsVersion":
            suggest = "scm_minimum_tls_version"
        elif key == "scmType":
            suggest = "scm_type"
        elif key == "scmUseMainIpRestriction":
            suggest = "scm_use_main_ip_restriction"
        elif key == "use32BitWorker":
            suggest = "use32_bit_worker"
        elif key == "vnetRouteAllEnabled":
            suggest = "vnet_route_all_enabled"
        elif key == "websocketsEnabled":
            suggest = "websockets_enabled"
        elif key == "workerCount":
            suggest = "worker_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotSiteConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotSiteConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotSiteConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 always_on: Optional[bool] = None,
                 api_definition_url: Optional[str] = None,
                 api_management_api_id: Optional[str] = None,
                 app_command_line: Optional[str] = None,
                 application_stack: Optional['outputs.LinuxWebAppSlotSiteConfigApplicationStack'] = None,
                 auto_heal_enabled: Optional[bool] = None,
                 auto_heal_setting: Optional['outputs.LinuxWebAppSlotSiteConfigAutoHealSetting'] = None,
                 auto_swap_slot_name: Optional[str] = None,
                 container_registry_managed_identity_client_id: Optional[str] = None,
                 container_registry_use_managed_identity: Optional[bool] = None,
                 cors: Optional['outputs.LinuxWebAppSlotSiteConfigCors'] = None,
                 default_documents: Optional[Sequence[str]] = None,
                 detailed_error_logging_enabled: Optional[bool] = None,
                 ftps_state: Optional[str] = None,
                 health_check_eviction_time_in_min: Optional[int] = None,
                 health_check_path: Optional[str] = None,
                 http2_enabled: Optional[bool] = None,
                 ip_restrictions: Optional[Sequence['outputs.LinuxWebAppSlotSiteConfigIpRestriction']] = None,
                 linux_fx_version: Optional[str] = None,
                 load_balancing_mode: Optional[str] = None,
                 local_mysql_enabled: Optional[bool] = None,
                 managed_pipeline_mode: Optional[str] = None,
                 minimum_tls_version: Optional[str] = None,
                 remote_debugging_enabled: Optional[bool] = None,
                 remote_debugging_version: Optional[str] = None,
                 scm_ip_restrictions: Optional[Sequence['outputs.LinuxWebAppSlotSiteConfigScmIpRestriction']] = None,
                 scm_minimum_tls_version: Optional[str] = None,
                 scm_type: Optional[str] = None,
                 scm_use_main_ip_restriction: Optional[bool] = None,
                 use32_bit_worker: Optional[bool] = None,
                 vnet_route_all_enabled: Optional[bool] = None,
                 websockets_enabled: Optional[bool] = None,
                 worker_count: Optional[int] = None):
        """
        :param bool always_on: If this Linux Web App is Always On enabled. Defaults to `false`.
        :param str api_definition_url: The URL to the API Definition for this Linux Web App Slot.
        :param str api_management_api_id: The API Management API ID this Linux Web App Slot is associated with.
        :param str app_command_line: The App command line to launch.
        :param 'LinuxWebAppSlotSiteConfigApplicationStackArgs' application_stack: A `application_stack` block as defined above.
        :param bool auto_heal_enabled: Should Auto heal rules be enabled? Required with `auto_heal_setting`.
        :param 'LinuxWebAppSlotSiteConfigAutoHealSettingArgs' auto_heal_setting: A `auto_heal_setting` block as defined above. Required with `auto_heal`.
        :param str auto_swap_slot_name: The Linux Web App Slot Name to automatically swap to when deployment to that slot is successfully completed.
        :param str container_registry_managed_identity_client_id: The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
        :param bool container_registry_use_managed_identity: Should connections for Azure Container Registry use Managed Identity.
        :param 'LinuxWebAppSlotSiteConfigCorsArgs' cors: A `cors` block as defined above.
        :param Sequence[str] default_documents: Specifies a list of Default Documents for the Linux Web App.
        :param str ftps_state: The State of FTP / FTPS service. Possible values include `AllAllowed`, `FtpsOnly`, and `Disabled`.
        :param int health_check_eviction_time_in_min: The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        :param str health_check_path: The path to the Health Check.
        :param bool http2_enabled: Should the HTTP2 be enabled?
        :param Sequence['LinuxWebAppSlotSiteConfigIpRestrictionArgs'] ip_restrictions: One or more `ip_restriction` blocks as defined above.
        :param str load_balancing_mode: The Site load balancing. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        :param bool local_mysql_enabled: Use Local MySQL. Defaults to `false`.
        :param str managed_pipeline_mode: Managed pipeline mode. Possible values include: `Integrated`, `Classic`.
        :param str minimum_tls_version: The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and  `1.2`. Defaults to `1.2`.
        :param bool remote_debugging_enabled: Should Remote Debugging be enabled? Defaults to `false`.
        :param str remote_debugging_version: The Remote Debugging Version. Possible values include `VS2017` and `VS2019`
        :param Sequence['LinuxWebAppSlotSiteConfigScmIpRestrictionArgs'] scm_ip_restrictions: One or more `scm_ip_restriction` blocks as defined above.
        :param str scm_minimum_tls_version: The configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and  `1.2`. Defaults to `1.2`.
        :param bool scm_use_main_ip_restriction: Should the Linux Web App `ip_restriction` configuration be used for the SCM also.
        :param bool use32_bit_worker: Should the Linux Web App use a 32-bit worker? Defaults to `true`.
        :param bool vnet_route_all_enabled: Should all outbound traffic have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        :param int worker_count: The number of Workers for this Linux App Service Slot.
        """
        if always_on is not None:
            pulumi.set(__self__, "always_on", always_on)
        if api_definition_url is not None:
            pulumi.set(__self__, "api_definition_url", api_definition_url)
        if api_management_api_id is not None:
            pulumi.set(__self__, "api_management_api_id", api_management_api_id)
        if app_command_line is not None:
            pulumi.set(__self__, "app_command_line", app_command_line)
        if application_stack is not None:
            pulumi.set(__self__, "application_stack", application_stack)
        if auto_heal_enabled is not None:
            pulumi.set(__self__, "auto_heal_enabled", auto_heal_enabled)
        if auto_heal_setting is not None:
            pulumi.set(__self__, "auto_heal_setting", auto_heal_setting)
        if auto_swap_slot_name is not None:
            pulumi.set(__self__, "auto_swap_slot_name", auto_swap_slot_name)
        if container_registry_managed_identity_client_id is not None:
            pulumi.set(__self__, "container_registry_managed_identity_client_id", container_registry_managed_identity_client_id)
        if container_registry_use_managed_identity is not None:
            pulumi.set(__self__, "container_registry_use_managed_identity", container_registry_use_managed_identity)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if default_documents is not None:
            pulumi.set(__self__, "default_documents", default_documents)
        if detailed_error_logging_enabled is not None:
            pulumi.set(__self__, "detailed_error_logging_enabled", detailed_error_logging_enabled)
        if ftps_state is not None:
            pulumi.set(__self__, "ftps_state", ftps_state)
        if health_check_eviction_time_in_min is not None:
            pulumi.set(__self__, "health_check_eviction_time_in_min", health_check_eviction_time_in_min)
        if health_check_path is not None:
            pulumi.set(__self__, "health_check_path", health_check_path)
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if ip_restrictions is not None:
            pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        if linux_fx_version is not None:
            pulumi.set(__self__, "linux_fx_version", linux_fx_version)
        if load_balancing_mode is not None:
            pulumi.set(__self__, "load_balancing_mode", load_balancing_mode)
        if local_mysql_enabled is not None:
            pulumi.set(__self__, "local_mysql_enabled", local_mysql_enabled)
        if managed_pipeline_mode is not None:
            pulumi.set(__self__, "managed_pipeline_mode", managed_pipeline_mode)
        if minimum_tls_version is not None:
            pulumi.set(__self__, "minimum_tls_version", minimum_tls_version)
        if remote_debugging_enabled is not None:
            pulumi.set(__self__, "remote_debugging_enabled", remote_debugging_enabled)
        if remote_debugging_version is not None:
            pulumi.set(__self__, "remote_debugging_version", remote_debugging_version)
        if scm_ip_restrictions is not None:
            pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        if scm_minimum_tls_version is not None:
            pulumi.set(__self__, "scm_minimum_tls_version", scm_minimum_tls_version)
        if scm_type is not None:
            pulumi.set(__self__, "scm_type", scm_type)
        if scm_use_main_ip_restriction is not None:
            pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        if use32_bit_worker is not None:
            pulumi.set(__self__, "use32_bit_worker", use32_bit_worker)
        if vnet_route_all_enabled is not None:
            pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        if websockets_enabled is not None:
            pulumi.set(__self__, "websockets_enabled", websockets_enabled)
        if worker_count is not None:
            pulumi.set(__self__, "worker_count", worker_count)

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> Optional[bool]:
        """
        If this Linux Web App is Always On enabled. Defaults to `false`.
        """
        return pulumi.get(self, "always_on")

    @property
    @pulumi.getter(name="apiDefinitionUrl")
    def api_definition_url(self) -> Optional[str]:
        """
        The URL to the API Definition for this Linux Web App Slot.
        """
        return pulumi.get(self, "api_definition_url")

    @property
    @pulumi.getter(name="apiManagementApiId")
    def api_management_api_id(self) -> Optional[str]:
        """
        The API Management API ID this Linux Web App Slot is associated with.
        """
        return pulumi.get(self, "api_management_api_id")

    @property
    @pulumi.getter(name="appCommandLine")
    def app_command_line(self) -> Optional[str]:
        """
        The App command line to launch.
        """
        return pulumi.get(self, "app_command_line")

    @property
    @pulumi.getter(name="applicationStack")
    def application_stack(self) -> Optional['outputs.LinuxWebAppSlotSiteConfigApplicationStack']:
        """
        A `application_stack` block as defined above.
        """
        return pulumi.get(self, "application_stack")

    @property
    @pulumi.getter(name="autoHealEnabled")
    def auto_heal_enabled(self) -> Optional[bool]:
        """
        Should Auto heal rules be enabled? Required with `auto_heal_setting`.
        """
        return pulumi.get(self, "auto_heal_enabled")

    @property
    @pulumi.getter(name="autoHealSetting")
    def auto_heal_setting(self) -> Optional['outputs.LinuxWebAppSlotSiteConfigAutoHealSetting']:
        """
        A `auto_heal_setting` block as defined above. Required with `auto_heal`.
        """
        return pulumi.get(self, "auto_heal_setting")

    @property
    @pulumi.getter(name="autoSwapSlotName")
    def auto_swap_slot_name(self) -> Optional[str]:
        """
        The Linux Web App Slot Name to automatically swap to when deployment to that slot is successfully completed.
        """
        return pulumi.get(self, "auto_swap_slot_name")

    @property
    @pulumi.getter(name="containerRegistryManagedIdentityClientId")
    def container_registry_managed_identity_client_id(self) -> Optional[str]:
        """
        The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
        """
        return pulumi.get(self, "container_registry_managed_identity_client_id")

    @property
    @pulumi.getter(name="containerRegistryUseManagedIdentity")
    def container_registry_use_managed_identity(self) -> Optional[bool]:
        """
        Should connections for Azure Container Registry use Managed Identity.
        """
        return pulumi.get(self, "container_registry_use_managed_identity")

    @property
    @pulumi.getter
    def cors(self) -> Optional['outputs.LinuxWebAppSlotSiteConfigCors']:
        """
        A `cors` block as defined above.
        """
        return pulumi.get(self, "cors")

    @property
    @pulumi.getter(name="defaultDocuments")
    def default_documents(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Default Documents for the Linux Web App.
        """
        return pulumi.get(self, "default_documents")

    @property
    @pulumi.getter(name="detailedErrorLoggingEnabled")
    def detailed_error_logging_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "detailed_error_logging_enabled")

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> Optional[str]:
        """
        The State of FTP / FTPS service. Possible values include `AllAllowed`, `FtpsOnly`, and `Disabled`.
        """
        return pulumi.get(self, "ftps_state")

    @property
    @pulumi.getter(name="healthCheckEvictionTimeInMin")
    def health_check_eviction_time_in_min(self) -> Optional[int]:
        """
        The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        """
        return pulumi.get(self, "health_check_eviction_time_in_min")

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> Optional[str]:
        """
        The path to the Health Check.
        """
        return pulumi.get(self, "health_check_path")

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[bool]:
        """
        Should the HTTP2 be enabled?
        """
        return pulumi.get(self, "http2_enabled")

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Optional[Sequence['outputs.LinuxWebAppSlotSiteConfigIpRestriction']]:
        """
        One or more `ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "ip_restrictions")

    @property
    @pulumi.getter(name="linuxFxVersion")
    def linux_fx_version(self) -> Optional[str]:
        return pulumi.get(self, "linux_fx_version")

    @property
    @pulumi.getter(name="loadBalancingMode")
    def load_balancing_mode(self) -> Optional[str]:
        """
        The Site load balancing. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        """
        return pulumi.get(self, "load_balancing_mode")

    @property
    @pulumi.getter(name="localMysqlEnabled")
    def local_mysql_enabled(self) -> Optional[bool]:
        """
        Use Local MySQL. Defaults to `false`.
        """
        return pulumi.get(self, "local_mysql_enabled")

    @property
    @pulumi.getter(name="managedPipelineMode")
    def managed_pipeline_mode(self) -> Optional[str]:
        """
        Managed pipeline mode. Possible values include: `Integrated`, `Classic`.
        """
        return pulumi.get(self, "managed_pipeline_mode")

    @property
    @pulumi.getter(name="minimumTlsVersion")
    def minimum_tls_version(self) -> Optional[str]:
        """
        The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and  `1.2`. Defaults to `1.2`.
        """
        return pulumi.get(self, "minimum_tls_version")

    @property
    @pulumi.getter(name="remoteDebuggingEnabled")
    def remote_debugging_enabled(self) -> Optional[bool]:
        """
        Should Remote Debugging be enabled? Defaults to `false`.
        """
        return pulumi.get(self, "remote_debugging_enabled")

    @property
    @pulumi.getter(name="remoteDebuggingVersion")
    def remote_debugging_version(self) -> Optional[str]:
        """
        The Remote Debugging Version. Possible values include `VS2017` and `VS2019`
        """
        return pulumi.get(self, "remote_debugging_version")

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Optional[Sequence['outputs.LinuxWebAppSlotSiteConfigScmIpRestriction']]:
        """
        One or more `scm_ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "scm_ip_restrictions")

    @property
    @pulumi.getter(name="scmMinimumTlsVersion")
    def scm_minimum_tls_version(self) -> Optional[str]:
        """
        The configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and  `1.2`. Defaults to `1.2`.
        """
        return pulumi.get(self, "scm_minimum_tls_version")

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> Optional[str]:
        return pulumi.get(self, "scm_type")

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> Optional[bool]:
        """
        Should the Linux Web App `ip_restriction` configuration be used for the SCM also.
        """
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @property
    @pulumi.getter(name="use32BitWorker")
    def use32_bit_worker(self) -> Optional[bool]:
        """
        Should the Linux Web App use a 32-bit worker? Defaults to `true`.
        """
        return pulumi.get(self, "use32_bit_worker")

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> Optional[bool]:
        """
        Should all outbound traffic have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        """
        return pulumi.get(self, "vnet_route_all_enabled")

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "websockets_enabled")

    @property
    @pulumi.getter(name="workerCount")
    def worker_count(self) -> Optional[int]:
        """
        The number of Workers for this Linux App Service Slot.
        """
        return pulumi.get(self, "worker_count")


@pulumi.output_type
class LinuxWebAppSlotSiteConfigApplicationStack(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dockerImage":
            suggest = "docker_image"
        elif key == "dockerImageTag":
            suggest = "docker_image_tag"
        elif key == "dotnetVersion":
            suggest = "dotnet_version"
        elif key == "javaServer":
            suggest = "java_server"
        elif key == "javaServerVersion":
            suggest = "java_server_version"
        elif key == "javaVersion":
            suggest = "java_version"
        elif key == "nodeVersion":
            suggest = "node_version"
        elif key == "phpVersion":
            suggest = "php_version"
        elif key == "pythonVersion":
            suggest = "python_version"
        elif key == "rubyVersion":
            suggest = "ruby_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotSiteConfigApplicationStack. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotSiteConfigApplicationStack.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotSiteConfigApplicationStack.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 docker_image: Optional[str] = None,
                 docker_image_tag: Optional[str] = None,
                 dotnet_version: Optional[str] = None,
                 java_server: Optional[str] = None,
                 java_server_version: Optional[str] = None,
                 java_version: Optional[str] = None,
                 node_version: Optional[str] = None,
                 php_version: Optional[str] = None,
                 python_version: Optional[str] = None,
                 ruby_version: Optional[str] = None):
        """
        :param str docker_image: The Docker image reference, including repository host as needed.
        :param str docker_image_tag: The image Tag to use. e.g. `latest`.
        :param str dotnet_version: The version of .NET to use. Possible values include `3.1`, `6.0` and `7.0`.
        :param str java_server: The Java server type. Possible values include `JAVA`, `TOMCAT`, and `JBOSSEAP`.
        :param str java_server_version: The Version of the `java_server` to use.
        :param str java_version: The Version of Java to use. Supported versions of Java vary depending on the `java_server` and `java_server_version`, as well as security and fixes to major versions. Please see Azure documentation for the latest information.
        :param str node_version: The version of Node to run. Possible values include `12-lts`, `14-lts`, and `16-lts`. This property conflicts with `java_version`.
        :param str php_version: The version of PHP to run. Possible values include `7.4`, and `8.0`.
        :param str python_version: The version of Python to run. Possible values include `3.7`, `3.8`, `3.9` and `3.10`.
        :param str ruby_version: Te version of Ruby to run. Possible values include `2.6` and `2.7`.
        """
        if docker_image is not None:
            pulumi.set(__self__, "docker_image", docker_image)
        if docker_image_tag is not None:
            pulumi.set(__self__, "docker_image_tag", docker_image_tag)
        if dotnet_version is not None:
            pulumi.set(__self__, "dotnet_version", dotnet_version)
        if java_server is not None:
            pulumi.set(__self__, "java_server", java_server)
        if java_server_version is not None:
            pulumi.set(__self__, "java_server_version", java_server_version)
        if java_version is not None:
            pulumi.set(__self__, "java_version", java_version)
        if node_version is not None:
            pulumi.set(__self__, "node_version", node_version)
        if php_version is not None:
            pulumi.set(__self__, "php_version", php_version)
        if python_version is not None:
            pulumi.set(__self__, "python_version", python_version)
        if ruby_version is not None:
            pulumi.set(__self__, "ruby_version", ruby_version)

    @property
    @pulumi.getter(name="dockerImage")
    def docker_image(self) -> Optional[str]:
        """
        The Docker image reference, including repository host as needed.
        """
        return pulumi.get(self, "docker_image")

    @property
    @pulumi.getter(name="dockerImageTag")
    def docker_image_tag(self) -> Optional[str]:
        """
        The image Tag to use. e.g. `latest`.
        """
        return pulumi.get(self, "docker_image_tag")

    @property
    @pulumi.getter(name="dotnetVersion")
    def dotnet_version(self) -> Optional[str]:
        """
        The version of .NET to use. Possible values include `3.1`, `6.0` and `7.0`.
        """
        return pulumi.get(self, "dotnet_version")

    @property
    @pulumi.getter(name="javaServer")
    def java_server(self) -> Optional[str]:
        """
        The Java server type. Possible values include `JAVA`, `TOMCAT`, and `JBOSSEAP`.
        """
        return pulumi.get(self, "java_server")

    @property
    @pulumi.getter(name="javaServerVersion")
    def java_server_version(self) -> Optional[str]:
        """
        The Version of the `java_server` to use.
        """
        return pulumi.get(self, "java_server_version")

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> Optional[str]:
        """
        The Version of Java to use. Supported versions of Java vary depending on the `java_server` and `java_server_version`, as well as security and fixes to major versions. Please see Azure documentation for the latest information.
        """
        return pulumi.get(self, "java_version")

    @property
    @pulumi.getter(name="nodeVersion")
    def node_version(self) -> Optional[str]:
        """
        The version of Node to run. Possible values include `12-lts`, `14-lts`, and `16-lts`. This property conflicts with `java_version`.
        """
        return pulumi.get(self, "node_version")

    @property
    @pulumi.getter(name="phpVersion")
    def php_version(self) -> Optional[str]:
        """
        The version of PHP to run. Possible values include `7.4`, and `8.0`.
        """
        return pulumi.get(self, "php_version")

    @property
    @pulumi.getter(name="pythonVersion")
    def python_version(self) -> Optional[str]:
        """
        The version of Python to run. Possible values include `3.7`, `3.8`, `3.9` and `3.10`.
        """
        return pulumi.get(self, "python_version")

    @property
    @pulumi.getter(name="rubyVersion")
    def ruby_version(self) -> Optional[str]:
        """
        Te version of Ruby to run. Possible values include `2.6` and `2.7`.
        """
        return pulumi.get(self, "ruby_version")


@pulumi.output_type
class LinuxWebAppSlotSiteConfigAutoHealSetting(dict):
    def __init__(__self__, *,
                 action: Optional['outputs.LinuxWebAppSlotSiteConfigAutoHealSettingAction'] = None,
                 trigger: Optional['outputs.LinuxWebAppSlotSiteConfigAutoHealSettingTrigger'] = None):
        """
        :param 'LinuxWebAppSlotSiteConfigAutoHealSettingActionArgs' action: A `action` block as defined above.
        :param 'LinuxWebAppSlotSiteConfigAutoHealSettingTriggerArgs' trigger: A `trigger` block as defined below.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if trigger is not None:
            pulumi.set(__self__, "trigger", trigger)

    @property
    @pulumi.getter
    def action(self) -> Optional['outputs.LinuxWebAppSlotSiteConfigAutoHealSettingAction']:
        """
        A `action` block as defined above.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def trigger(self) -> Optional['outputs.LinuxWebAppSlotSiteConfigAutoHealSettingTrigger']:
        """
        A `trigger` block as defined below.
        """
        return pulumi.get(self, "trigger")


@pulumi.output_type
class LinuxWebAppSlotSiteConfigAutoHealSettingAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionType":
            suggest = "action_type"
        elif key == "minimumProcessExecutionTime":
            suggest = "minimum_process_execution_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotSiteConfigAutoHealSettingAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotSiteConfigAutoHealSettingAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotSiteConfigAutoHealSettingAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_type: str,
                 minimum_process_execution_time: Optional[str] = None):
        """
        :param str action_type: Predefined action to be taken to an Auto Heal trigger. Possible values include: `Recycle`.
        :param str minimum_process_execution_time: The minimum amount of time in `hh:mm:ss` the Linux Web App must have been running before the defined action will be run in the event of a trigger.
        """
        pulumi.set(__self__, "action_type", action_type)
        if minimum_process_execution_time is not None:
            pulumi.set(__self__, "minimum_process_execution_time", minimum_process_execution_time)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> str:
        """
        Predefined action to be taken to an Auto Heal trigger. Possible values include: `Recycle`.
        """
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter(name="minimumProcessExecutionTime")
    def minimum_process_execution_time(self) -> Optional[str]:
        """
        The minimum amount of time in `hh:mm:ss` the Linux Web App must have been running before the defined action will be run in the event of a trigger.
        """
        return pulumi.get(self, "minimum_process_execution_time")


@pulumi.output_type
class LinuxWebAppSlotSiteConfigAutoHealSettingTrigger(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slowRequests":
            suggest = "slow_requests"
        elif key == "statusCodes":
            suggest = "status_codes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotSiteConfigAutoHealSettingTrigger. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotSiteConfigAutoHealSettingTrigger.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotSiteConfigAutoHealSettingTrigger.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 requests: Optional['outputs.LinuxWebAppSlotSiteConfigAutoHealSettingTriggerRequests'] = None,
                 slow_requests: Optional[Sequence['outputs.LinuxWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequest']] = None,
                 status_codes: Optional[Sequence['outputs.LinuxWebAppSlotSiteConfigAutoHealSettingTriggerStatusCode']] = None):
        """
        :param 'LinuxWebAppSlotSiteConfigAutoHealSettingTriggerRequestsArgs' requests: A `requests` block as defined above.
        :param Sequence['LinuxWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestArgs'] slow_requests: One or more `slow_request` blocks as defined above.
        :param Sequence['LinuxWebAppSlotSiteConfigAutoHealSettingTriggerStatusCodeArgs'] status_codes: One or more `status_code` blocks as defined above.
        """
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if slow_requests is not None:
            pulumi.set(__self__, "slow_requests", slow_requests)
        if status_codes is not None:
            pulumi.set(__self__, "status_codes", status_codes)

    @property
    @pulumi.getter
    def requests(self) -> Optional['outputs.LinuxWebAppSlotSiteConfigAutoHealSettingTriggerRequests']:
        """
        A `requests` block as defined above.
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="slowRequests")
    def slow_requests(self) -> Optional[Sequence['outputs.LinuxWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequest']]:
        """
        One or more `slow_request` blocks as defined above.
        """
        return pulumi.get(self, "slow_requests")

    @property
    @pulumi.getter(name="statusCodes")
    def status_codes(self) -> Optional[Sequence['outputs.LinuxWebAppSlotSiteConfigAutoHealSettingTriggerStatusCode']]:
        """
        One or more `status_code` blocks as defined above.
        """
        return pulumi.get(self, "status_codes")


@pulumi.output_type
class LinuxWebAppSlotSiteConfigAutoHealSettingTriggerRequests(dict):
    def __init__(__self__, *,
                 count: int,
                 interval: str):
        """
        :param int count: The number of requests in the specified `interval` to trigger this rule.
        :param str interval: The interval in `hh:mm:ss`.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of requests in the specified `interval` to trigger this rule.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        The interval in `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class LinuxWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeTaken":
            suggest = "time_taken"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: int,
                 interval: str,
                 time_taken: str,
                 path: Optional[str] = None):
        """
        :param int count: The number of Slow Requests in the time `interval` to trigger this rule.
        :param str interval: The time interval in the form `hh:mm:ss`.
        :param str time_taken: The threshold of time passed to qualify as a Slow Request in `hh:mm:ss`.
        :param str path: The path for which this slow request rule applies.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "time_taken", time_taken)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of Slow Requests in the time `interval` to trigger this rule.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        The time interval in the form `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="timeTaken")
    def time_taken(self) -> str:
        """
        The threshold of time passed to qualify as a Slow Request in `hh:mm:ss`.
        """
        return pulumi.get(self, "time_taken")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path for which this slow request rule applies.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class LinuxWebAppSlotSiteConfigAutoHealSettingTriggerStatusCode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusCodeRange":
            suggest = "status_code_range"
        elif key == "subStatus":
            suggest = "sub_status"
        elif key == "win32Status":
            suggest = "win32_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotSiteConfigAutoHealSettingTriggerStatusCode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotSiteConfigAutoHealSettingTriggerStatusCode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotSiteConfigAutoHealSettingTriggerStatusCode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: int,
                 interval: str,
                 status_code_range: str,
                 path: Optional[str] = None,
                 sub_status: Optional[int] = None,
                 win32_status: Optional[str] = None):
        """
        :param int count: The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        :param str interval: The time interval in the form `hh:mm:ss`.
        :param str status_code_range: The status code for this rule, accepts single status codes and status code ranges. e.g. `500` or `400-499`. Possible values are integers between `101` and `599`
        :param str path: The path to which this rule status code applies.
        :param int sub_status: The Request Sub Status of the Status Code.
        :param str win32_status: The Win32 Status Code of the Request.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "status_code_range", status_code_range)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if sub_status is not None:
            pulumi.set(__self__, "sub_status", sub_status)
        if win32_status is not None:
            pulumi.set(__self__, "win32_status", win32_status)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        The time interval in the form `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="statusCodeRange")
    def status_code_range(self) -> str:
        """
        The status code for this rule, accepts single status codes and status code ranges. e.g. `500` or `400-499`. Possible values are integers between `101` and `599`
        """
        return pulumi.get(self, "status_code_range")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path to which this rule status code applies.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="subStatus")
    def sub_status(self) -> Optional[int]:
        """
        The Request Sub Status of the Status Code.
        """
        return pulumi.get(self, "sub_status")

    @property
    @pulumi.getter(name="win32Status")
    def win32_status(self) -> Optional[str]:
        """
        The Win32 Status Code of the Request.
        """
        return pulumi.get(self, "win32_status")


@pulumi.output_type
class LinuxWebAppSlotSiteConfigCors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedOrigins":
            suggest = "allowed_origins"
        elif key == "supportCredentials":
            suggest = "support_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotSiteConfigCors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotSiteConfigCors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotSiteConfigCors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_origins: Sequence[str],
                 support_credentials: Optional[bool] = None):
        """
        :param Sequence[str] allowed_origins: Specifies a list of origins that should be allowed to make cross-origin calls.
        :param bool support_credentials: Whether CORS requests with credentials are allowed. Defaults to `false`
        """
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        if support_credentials is not None:
            pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Sequence[str]:
        """
        Specifies a list of origins that should be allowed to make cross-origin calls.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> Optional[bool]:
        """
        Whether CORS requests with credentials are allowed. Defaults to `false`
        """
        return pulumi.get(self, "support_credentials")


@pulumi.output_type
class LinuxWebAppSlotSiteConfigIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotSiteConfigIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotSiteConfigIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotSiteConfigIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.LinuxWebAppSlotSiteConfigIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: The action to take. Possible values are `Allow` or `Deny`.
        :param 'LinuxWebAppSlotSiteConfigIpRestrictionHeadersArgs' headers: A `headers` block as defined above.
        :param str ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param str name: The name which should be used for this `ip_restriction`.
        :param int priority: The priority value of this `ip_restriction`.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        The action to take. Possible values are `Allow` or `Deny`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.LinuxWebAppSlotSiteConfigIpRestrictionHeaders']:
        """
        A `headers` block as defined above.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority value of this `ip_restriction`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class LinuxWebAppSlotSiteConfigIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotSiteConfigIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param str x_fd_health_probe: Specifies if a Front Door Health Probe should be expected.
        :param Sequence[str] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param Sequence[str] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        Specifies if a Front Door Health Probe should be expected.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class LinuxWebAppSlotSiteConfigScmIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotSiteConfigScmIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotSiteConfigScmIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotSiteConfigScmIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.LinuxWebAppSlotSiteConfigScmIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: The action to take. Possible values are `Allow` or `Deny`.
        :param 'LinuxWebAppSlotSiteConfigScmIpRestrictionHeadersArgs' headers: A `headers` block as defined above.
        :param str ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param str name: The name which should be used for this `ip_restriction`.
        :param int priority: The priority value of this `ip_restriction`.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        The action to take. Possible values are `Allow` or `Deny`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.LinuxWebAppSlotSiteConfigScmIpRestrictionHeaders']:
        """
        A `headers` block as defined above.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority value of this `ip_restriction`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class LinuxWebAppSlotSiteConfigScmIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotSiteConfigScmIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param str x_fd_health_probe: Specifies if a Front Door Health Probe should be expected.
        :param Sequence[str] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param Sequence[str] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        Specifies if a Front Door Health Probe should be expected.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class LinuxWebAppSlotSiteCredential(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 password: Optional[str] = None):
        """
        :param str name: The name which should be used for this Linux Web App Slot. Changing this forces a new Linux Web App Slot to be created.
        :param str password: The Site Credentials Password used for publishing.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name which should be used for this Linux Web App Slot. Changing this forces a new Linux Web App Slot to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The Site Credentials Password used for publishing.
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class LinuxWebAppSlotStorageAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "accountName":
            suggest = "account_name"
        elif key == "shareName":
            suggest = "share_name"
        elif key == "mountPath":
            suggest = "mount_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppSlotStorageAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppSlotStorageAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppSlotStorageAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: str,
                 account_name: str,
                 name: str,
                 share_name: str,
                 type: str,
                 mount_path: Optional[str] = None):
        """
        :param str access_key: The Access key for the storage account.
        :param str account_name: The Name of the Storage Account.
        :param str name: The name which should be used for this Storage Account.
        :param str share_name: The Name of the File Share or Container Name for Blob storage.
        :param str type: The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`
        :param str mount_path: The path at which to mount the storage share.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "share_name", share_name)
        pulumi.set(__self__, "type", type)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> str:
        """
        The Access key for the storage account.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> str:
        """
        The Name of the Storage Account.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Storage Account.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> str:
        """
        The Name of the File Share or Container Name for Blob storage.
        """
        return pulumi.get(self, "share_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[str]:
        """
        The path at which to mount the storage share.
        """
        return pulumi.get(self, "mount_path")


@pulumi.output_type
class LinuxWebAppStickySettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appSettingNames":
            suggest = "app_setting_names"
        elif key == "connectionStringNames":
            suggest = "connection_string_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppStickySettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppStickySettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppStickySettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_setting_names: Optional[Sequence[str]] = None,
                 connection_string_names: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] app_setting_names: A list of `app_setting` names that the Linux Web App will not swap between Slots when a swap operation is triggered.
        :param Sequence[str] connection_string_names: A list of `connection_string` names that the Linux Web App will not swap between Slots when a swap operation is triggered.
        """
        if app_setting_names is not None:
            pulumi.set(__self__, "app_setting_names", app_setting_names)
        if connection_string_names is not None:
            pulumi.set(__self__, "connection_string_names", connection_string_names)

    @property
    @pulumi.getter(name="appSettingNames")
    def app_setting_names(self) -> Optional[Sequence[str]]:
        """
        A list of `app_setting` names that the Linux Web App will not swap between Slots when a swap operation is triggered.
        """
        return pulumi.get(self, "app_setting_names")

    @property
    @pulumi.getter(name="connectionStringNames")
    def connection_string_names(self) -> Optional[Sequence[str]]:
        """
        A list of `connection_string` names that the Linux Web App will not swap between Slots when a swap operation is triggered.
        """
        return pulumi.get(self, "connection_string_names")


@pulumi.output_type
class LinuxWebAppStorageAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "accountName":
            suggest = "account_name"
        elif key == "shareName":
            suggest = "share_name"
        elif key == "mountPath":
            suggest = "mount_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxWebAppStorageAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxWebAppStorageAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxWebAppStorageAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: str,
                 account_name: str,
                 name: str,
                 share_name: str,
                 type: str,
                 mount_path: Optional[str] = None):
        """
        :param str access_key: The Access key for the storage account.
        :param str account_name: The Name of the Storage Account.
        :param str name: The name which should be used for this Storage Account.
        :param str share_name: The Name of the File Share or Container Name for Blob storage.
        :param str type: The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`
        :param str mount_path: The path at which to mount the storage share.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "share_name", share_name)
        pulumi.set(__self__, "type", type)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> str:
        """
        The Access key for the storage account.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> str:
        """
        The Name of the Storage Account.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Storage Account.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> str:
        """
        The Name of the File Share or Container Name for Blob storage.
        """
        return pulumi.get(self, "share_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[str]:
        """
        The path at which to mount the storage share.
        """
        return pulumi.get(self, "mount_path")


@pulumi.output_type
class PlanSku(dict):
    def __init__(__self__, *,
                 size: str,
                 tier: str,
                 capacity: Optional[int] = None):
        """
        :param str size: Specifies the plan's instance size.
        :param str tier: Specifies the plan's pricing tier.
        :param int capacity: Specifies the number of workers associated with this App Service Plan.
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "tier", tier)
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)

    @property
    @pulumi.getter
    def size(self) -> str:
        """
        Specifies the plan's instance size.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def tier(self) -> str:
        """
        Specifies the plan's pricing tier.
        """
        return pulumi.get(self, "tier")

    @property
    @pulumi.getter
    def capacity(self) -> Optional[int]:
        """
        Specifies the number of workers associated with this App Service Plan.
        """
        return pulumi.get(self, "capacity")


@pulumi.output_type
class SlotAuthSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeDirectory":
            suggest = "active_directory"
        elif key == "additionalLoginParams":
            suggest = "additional_login_params"
        elif key == "allowedExternalRedirectUrls":
            suggest = "allowed_external_redirect_urls"
        elif key == "defaultProvider":
            suggest = "default_provider"
        elif key == "runtimeVersion":
            suggest = "runtime_version"
        elif key == "tokenRefreshExtensionHours":
            suggest = "token_refresh_extension_hours"
        elif key == "tokenStoreEnabled":
            suggest = "token_store_enabled"
        elif key == "unauthenticatedClientAction":
            suggest = "unauthenticated_client_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SlotAuthSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SlotAuthSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SlotAuthSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 active_directory: Optional['outputs.SlotAuthSettingsActiveDirectory'] = None,
                 additional_login_params: Optional[Mapping[str, str]] = None,
                 allowed_external_redirect_urls: Optional[Sequence[str]] = None,
                 default_provider: Optional[str] = None,
                 facebook: Optional['outputs.SlotAuthSettingsFacebook'] = None,
                 google: Optional['outputs.SlotAuthSettingsGoogle'] = None,
                 issuer: Optional[str] = None,
                 microsoft: Optional['outputs.SlotAuthSettingsMicrosoft'] = None,
                 runtime_version: Optional[str] = None,
                 token_refresh_extension_hours: Optional[float] = None,
                 token_store_enabled: Optional[bool] = None,
                 twitter: Optional['outputs.SlotAuthSettingsTwitter'] = None,
                 unauthenticated_client_action: Optional[str] = None):
        """
        :param bool enabled: Is Authentication enabled?
        :param 'SlotAuthSettingsActiveDirectoryArgs' active_directory: A `active_directory` block as defined below.
        :param Mapping[str, str] additional_login_params: Login parameters to send to the OpenID Connect authorization endpoint when a user logs in. Each parameter must be in the form "key=value".
        :param Sequence[str] allowed_external_redirect_urls: External URLs that can be redirected to as part of logging in or logging out of the app.
        :param str default_provider: The default provider to use when multiple providers have been set up. Possible values are `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount` and `Twitter`.
        :param 'SlotAuthSettingsFacebookArgs' facebook: A `facebook` block as defined below.
        :param 'SlotAuthSettingsGoogleArgs' google: A `google` block as defined below.
        :param str issuer: Issuer URI. When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        :param 'SlotAuthSettingsMicrosoftArgs' microsoft: A `microsoft` block as defined below.
        :param str runtime_version: The runtime version of the Authentication/Authorization module.
        :param float token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to 72.
        :param bool token_store_enabled: If enabled the module will durably store platform-specific security tokens that are obtained during login flows. Defaults to false.
        :param 'SlotAuthSettingsTwitterArgs' twitter: A `twitter` block as defined below.
        :param str unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app. Possible values are `AllowAnonymous` and `RedirectToLoginPage`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if active_directory is not None:
            pulumi.set(__self__, "active_directory", active_directory)
        if additional_login_params is not None:
            pulumi.set(__self__, "additional_login_params", additional_login_params)
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if facebook is not None:
            pulumi.set(__self__, "facebook", facebook)
        if google is not None:
            pulumi.set(__self__, "google", google)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if microsoft is not None:
            pulumi.set(__self__, "microsoft", microsoft)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if token_refresh_extension_hours is not None:
            pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if twitter is not None:
            pulumi.set(__self__, "twitter", twitter)
        if unauthenticated_client_action is not None:
            pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is Authentication enabled?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="activeDirectory")
    def active_directory(self) -> Optional['outputs.SlotAuthSettingsActiveDirectory']:
        """
        A `active_directory` block as defined below.
        """
        return pulumi.get(self, "active_directory")

    @property
    @pulumi.getter(name="additionalLoginParams")
    def additional_login_params(self) -> Optional[Mapping[str, str]]:
        """
        Login parameters to send to the OpenID Connect authorization endpoint when a user logs in. Each parameter must be in the form "key=value".
        """
        return pulumi.get(self, "additional_login_params")

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[Sequence[str]]:
        """
        External URLs that can be redirected to as part of logging in or logging out of the app.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[str]:
        """
        The default provider to use when multiple providers have been set up. Possible values are `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount` and `Twitter`.
        """
        return pulumi.get(self, "default_provider")

    @property
    @pulumi.getter
    def facebook(self) -> Optional['outputs.SlotAuthSettingsFacebook']:
        """
        A `facebook` block as defined below.
        """
        return pulumi.get(self, "facebook")

    @property
    @pulumi.getter
    def google(self) -> Optional['outputs.SlotAuthSettingsGoogle']:
        """
        A `google` block as defined below.
        """
        return pulumi.get(self, "google")

    @property
    @pulumi.getter
    def issuer(self) -> Optional[str]:
        """
        Issuer URI. When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def microsoft(self) -> Optional['outputs.SlotAuthSettingsMicrosoft']:
        """
        A `microsoft` block as defined below.
        """
        return pulumi.get(self, "microsoft")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[str]:
        """
        The runtime version of the Authentication/Authorization module.
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> Optional[float]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to 72.
        """
        return pulumi.get(self, "token_refresh_extension_hours")

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[bool]:
        """
        If enabled the module will durably store platform-specific security tokens that are obtained during login flows. Defaults to false.
        """
        return pulumi.get(self, "token_store_enabled")

    @property
    @pulumi.getter
    def twitter(self) -> Optional['outputs.SlotAuthSettingsTwitter']:
        """
        A `twitter` block as defined below.
        """
        return pulumi.get(self, "twitter")

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> Optional[str]:
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values are `AllowAnonymous` and `RedirectToLoginPage`.
        """
        return pulumi.get(self, "unauthenticated_client_action")


@pulumi.output_type
class SlotAuthSettingsActiveDirectory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "clientSecret":
            suggest = "client_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SlotAuthSettingsActiveDirectory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SlotAuthSettingsActiveDirectory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SlotAuthSettingsActiveDirectory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 client_secret: Optional[str] = None):
        """
        :param str client_id: The Client ID of this relying party application. Enables OpenIDConnection authentication with Azure Active Directory.
        :param Sequence[str] allowed_audiences: Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
        :param str client_secret: The Client Secret of this relying party application. If no secret is provided, implicit flow will be used.
        """
        pulumi.set(__self__, "client_id", client_id)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The Client ID of this relying party application. Enables OpenIDConnection authentication with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret of this relying party application. If no secret is provided, implicit flow will be used.
        """
        return pulumi.get(self, "client_secret")


@pulumi.output_type
class SlotAuthSettingsFacebook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "appSecret":
            suggest = "app_secret"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SlotAuthSettingsFacebook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SlotAuthSettingsFacebook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SlotAuthSettingsFacebook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: str,
                 app_secret: str,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str app_id: The App ID of the Facebook app used for login
        :param str app_secret: The App Secret of the Facebook app used for Facebook login.
        :param Sequence[str] oauth_scopes: The OAuth 2.0 scopes that will be requested as part of Facebook login authentication. <https://developers.facebook.com/docs/facebook-login>
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "app_secret", app_secret)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        The App ID of the Facebook app used for login
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appSecret")
    def app_secret(self) -> str:
        """
        The App Secret of the Facebook app used for Facebook login.
        """
        return pulumi.get(self, "app_secret")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        The OAuth 2.0 scopes that will be requested as part of Facebook login authentication. <https://developers.facebook.com/docs/facebook-login>
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class SlotAuthSettingsGoogle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SlotAuthSettingsGoogle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SlotAuthSettingsGoogle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SlotAuthSettingsGoogle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OpenID Connect Client ID for the Google web application.
        :param str client_secret: The client secret associated with the Google web application.
        :param Sequence[str] oauth_scopes: The OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. <https://developers.google.com/identity/sign-in/web/>
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OpenID Connect Client ID for the Google web application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The client secret associated with the Google web application.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        The OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. <https://developers.google.com/identity/sign-in/web/>
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class SlotAuthSettingsMicrosoft(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SlotAuthSettingsMicrosoft. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SlotAuthSettingsMicrosoft.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SlotAuthSettingsMicrosoft.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret: The OAuth 2.0 client secret that was created for the app used for authentication.
        :param Sequence[str] oauth_scopes: The OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. <https://msdn.microsoft.com/en-us/library/dn631845.aspx>
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        The OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. <https://msdn.microsoft.com/en-us/library/dn631845.aspx>
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class SlotAuthSettingsTwitter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerKey":
            suggest = "consumer_key"
        elif key == "consumerSecret":
            suggest = "consumer_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SlotAuthSettingsTwitter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SlotAuthSettingsTwitter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SlotAuthSettingsTwitter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_key: str,
                 consumer_secret: str):
        pulumi.set(__self__, "consumer_key", consumer_key)
        pulumi.set(__self__, "consumer_secret", consumer_secret)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> str:
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> str:
        return pulumi.get(self, "consumer_secret")


@pulumi.output_type
class SlotConnectionString(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: The name of the Connection String. Changing this forces a new resource to be created.
        :param str type: The type of the Connection String. Possible values are `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and  `SQLServer`.
        :param str value: The value for the Connection String.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Connection String. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the Connection String. Possible values are `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and  `SQLServer`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the Connection String.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SlotIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SlotIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SlotIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SlotIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 identity_ids: Optional[Sequence[str]] = None,
                 principal_id: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str type: Specifies the identity type of the App Service. Possible values are `SystemAssigned` (where Azure will generate a Service Principal for you), `UserAssigned` where you can specify the Service Principal IDs in the `identity_ids` field, and `SystemAssigned, UserAssigned` which assigns both a system managed identity as well as the specified user assigned identities.
        :param Sequence[str] identity_ids: Specifies a list of user managed identity ids to be assigned. Required if `type` is `UserAssigned`.
        :param str principal_id: The Principal ID for the Service Principal associated with the Managed Service Identity of this App Service slot.
        :param str tenant_id: The Tenant ID for the Service Principal associated with the Managed Service Identity of this App Service slot.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the identity type of the App Service. Possible values are `SystemAssigned` (where Azure will generate a Service Principal for you), `UserAssigned` where you can specify the Service Principal IDs in the `identity_ids` field, and `SystemAssigned, UserAssigned` which assigns both a system managed identity as well as the specified user assigned identities.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of user managed identity ids to be assigned. Required if `type` is `UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        """
        The Principal ID for the Service Principal associated with the Managed Service Identity of this App Service slot.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The Tenant ID for the Service Principal associated with the Managed Service Identity of this App Service slot.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class SlotLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationLogs":
            suggest = "application_logs"
        elif key == "detailedErrorMessagesEnabled":
            suggest = "detailed_error_messages_enabled"
        elif key == "failedRequestTracingEnabled":
            suggest = "failed_request_tracing_enabled"
        elif key == "httpLogs":
            suggest = "http_logs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SlotLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SlotLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SlotLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_logs: Optional['outputs.SlotLogsApplicationLogs'] = None,
                 detailed_error_messages_enabled: Optional[bool] = None,
                 failed_request_tracing_enabled: Optional[bool] = None,
                 http_logs: Optional['outputs.SlotLogsHttpLogs'] = None):
        """
        :param 'SlotLogsApplicationLogsArgs' application_logs: An `application_logs` block as defined below.
        :param bool detailed_error_messages_enabled: Should `Detailed error messages` be enabled on this App Service slot? Defaults to `false`.
        :param bool failed_request_tracing_enabled: Should `Failed request tracing` be enabled on this App Service slot? Defaults to `false`.
        :param 'SlotLogsHttpLogsArgs' http_logs: An `http_logs` block as defined below.
        """
        if application_logs is not None:
            pulumi.set(__self__, "application_logs", application_logs)
        if detailed_error_messages_enabled is not None:
            pulumi.set(__self__, "detailed_error_messages_enabled", detailed_error_messages_enabled)
        if failed_request_tracing_enabled is not None:
            pulumi.set(__self__, "failed_request_tracing_enabled", failed_request_tracing_enabled)
        if http_logs is not None:
            pulumi.set(__self__, "http_logs", http_logs)

    @property
    @pulumi.getter(name="applicationLogs")
    def application_logs(self) -> Optional['outputs.SlotLogsApplicationLogs']:
        """
        An `application_logs` block as defined below.
        """
        return pulumi.get(self, "application_logs")

    @property
    @pulumi.getter(name="detailedErrorMessagesEnabled")
    def detailed_error_messages_enabled(self) -> Optional[bool]:
        """
        Should `Detailed error messages` be enabled on this App Service slot? Defaults to `false`.
        """
        return pulumi.get(self, "detailed_error_messages_enabled")

    @property
    @pulumi.getter(name="failedRequestTracingEnabled")
    def failed_request_tracing_enabled(self) -> Optional[bool]:
        """
        Should `Failed request tracing` be enabled on this App Service slot? Defaults to `false`.
        """
        return pulumi.get(self, "failed_request_tracing_enabled")

    @property
    @pulumi.getter(name="httpLogs")
    def http_logs(self) -> Optional['outputs.SlotLogsHttpLogs']:
        """
        An `http_logs` block as defined below.
        """
        return pulumi.get(self, "http_logs")


@pulumi.output_type
class SlotLogsApplicationLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureBlobStorage":
            suggest = "azure_blob_storage"
        elif key == "fileSystemLevel":
            suggest = "file_system_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SlotLogsApplicationLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SlotLogsApplicationLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SlotLogsApplicationLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_blob_storage: Optional['outputs.SlotLogsApplicationLogsAzureBlobStorage'] = None,
                 file_system_level: Optional[str] = None):
        """
        :param 'SlotLogsApplicationLogsAzureBlobStorageArgs' azure_blob_storage: An `azure_blob_storage` block as defined below.
        :param str file_system_level: The file system log level. Possible values are `Off`, `Error`, `Warning`, `Information`, and `Verbose`.
        """
        if azure_blob_storage is not None:
            pulumi.set(__self__, "azure_blob_storage", azure_blob_storage)
        if file_system_level is not None:
            pulumi.set(__self__, "file_system_level", file_system_level)

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional['outputs.SlotLogsApplicationLogsAzureBlobStorage']:
        """
        An `azure_blob_storage` block as defined below.
        """
        return pulumi.get(self, "azure_blob_storage")

    @property
    @pulumi.getter(name="fileSystemLevel")
    def file_system_level(self) -> Optional[str]:
        """
        The file system log level. Possible values are `Off`, `Error`, `Warning`, `Information`, and `Verbose`.
        """
        return pulumi.get(self, "file_system_level")


@pulumi.output_type
class SlotLogsApplicationLogsAzureBlobStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retentionInDays":
            suggest = "retention_in_days"
        elif key == "sasUrl":
            suggest = "sas_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SlotLogsApplicationLogsAzureBlobStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SlotLogsApplicationLogsAzureBlobStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SlotLogsApplicationLogsAzureBlobStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 level: str,
                 retention_in_days: int,
                 sas_url: str):
        """
        :param str level: The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        :param int retention_in_days: The number of days to retain logs for.
        :param str sas_url: The URL to the storage container, with a Service SAS token appended. **NOTE:** there is currently no means of generating Service SAS tokens with the `azurerm` provider.
        """
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "sas_url", sas_url)

    @property
    @pulumi.getter
    def level(self) -> str:
        """
        The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        """
        return pulumi.get(self, "level")

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> int:
        """
        The number of days to retain logs for.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> str:
        """
        The URL to the storage container, with a Service SAS token appended. **NOTE:** there is currently no means of generating Service SAS tokens with the `azurerm` provider.
        """
        return pulumi.get(self, "sas_url")


@pulumi.output_type
class SlotLogsHttpLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureBlobStorage":
            suggest = "azure_blob_storage"
        elif key == "fileSystem":
            suggest = "file_system"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SlotLogsHttpLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SlotLogsHttpLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SlotLogsHttpLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_blob_storage: Optional['outputs.SlotLogsHttpLogsAzureBlobStorage'] = None,
                 file_system: Optional['outputs.SlotLogsHttpLogsFileSystem'] = None):
        """
        :param 'SlotLogsHttpLogsAzureBlobStorageArgs' azure_blob_storage: An `azure_blob_storage` block as defined below.
        :param 'SlotLogsHttpLogsFileSystemArgs' file_system: A `file_system` block as defined below.
        """
        if azure_blob_storage is not None:
            pulumi.set(__self__, "azure_blob_storage", azure_blob_storage)
        if file_system is not None:
            pulumi.set(__self__, "file_system", file_system)

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional['outputs.SlotLogsHttpLogsAzureBlobStorage']:
        """
        An `azure_blob_storage` block as defined below.
        """
        return pulumi.get(self, "azure_blob_storage")

    @property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional['outputs.SlotLogsHttpLogsFileSystem']:
        """
        A `file_system` block as defined below.
        """
        return pulumi.get(self, "file_system")


@pulumi.output_type
class SlotLogsHttpLogsAzureBlobStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retentionInDays":
            suggest = "retention_in_days"
        elif key == "sasUrl":
            suggest = "sas_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SlotLogsHttpLogsAzureBlobStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SlotLogsHttpLogsAzureBlobStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SlotLogsHttpLogsAzureBlobStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 retention_in_days: int,
                 sas_url: str):
        """
        :param int retention_in_days: The number of days to retain logs for.
        :param str sas_url: The URL to the storage container, with a Service SAS token appended. **NOTE:** there is currently no means of generating Service SAS tokens with the `azurerm` provider.
        """
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "sas_url", sas_url)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> int:
        """
        The number of days to retain logs for.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> str:
        """
        The URL to the storage container, with a Service SAS token appended. **NOTE:** there is currently no means of generating Service SAS tokens with the `azurerm` provider.
        """
        return pulumi.get(self, "sas_url")


@pulumi.output_type
class SlotLogsHttpLogsFileSystem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retentionInDays":
            suggest = "retention_in_days"
        elif key == "retentionInMb":
            suggest = "retention_in_mb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SlotLogsHttpLogsFileSystem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SlotLogsHttpLogsFileSystem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SlotLogsHttpLogsFileSystem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 retention_in_days: int,
                 retention_in_mb: int):
        """
        :param int retention_in_days: The number of days to retain logs for.
        :param int retention_in_mb: The maximum size in megabytes that HTTP log files can use before being removed.
        """
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "retention_in_mb", retention_in_mb)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> int:
        """
        The number of days to retain logs for.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="retentionInMb")
    def retention_in_mb(self) -> int:
        """
        The maximum size in megabytes that HTTP log files can use before being removed.
        """
        return pulumi.get(self, "retention_in_mb")


@pulumi.output_type
class SlotSiteConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acrUseManagedIdentityCredentials":
            suggest = "acr_use_managed_identity_credentials"
        elif key == "acrUserManagedIdentityClientId":
            suggest = "acr_user_managed_identity_client_id"
        elif key == "alwaysOn":
            suggest = "always_on"
        elif key == "appCommandLine":
            suggest = "app_command_line"
        elif key == "autoSwapSlotName":
            suggest = "auto_swap_slot_name"
        elif key == "defaultDocuments":
            suggest = "default_documents"
        elif key == "dotnetFrameworkVersion":
            suggest = "dotnet_framework_version"
        elif key == "ftpsState":
            suggest = "ftps_state"
        elif key == "healthCheckPath":
            suggest = "health_check_path"
        elif key == "http2Enabled":
            suggest = "http2_enabled"
        elif key == "ipRestrictions":
            suggest = "ip_restrictions"
        elif key == "javaContainer":
            suggest = "java_container"
        elif key == "javaContainerVersion":
            suggest = "java_container_version"
        elif key == "javaVersion":
            suggest = "java_version"
        elif key == "linuxFxVersion":
            suggest = "linux_fx_version"
        elif key == "localMysqlEnabled":
            suggest = "local_mysql_enabled"
        elif key == "managedPipelineMode":
            suggest = "managed_pipeline_mode"
        elif key == "minTlsVersion":
            suggest = "min_tls_version"
        elif key == "numberOfWorkers":
            suggest = "number_of_workers"
        elif key == "phpVersion":
            suggest = "php_version"
        elif key == "pythonVersion":
            suggest = "python_version"
        elif key == "remoteDebuggingEnabled":
            suggest = "remote_debugging_enabled"
        elif key == "remoteDebuggingVersion":
            suggest = "remote_debugging_version"
        elif key == "scmIpRestrictions":
            suggest = "scm_ip_restrictions"
        elif key == "scmType":
            suggest = "scm_type"
        elif key == "scmUseMainIpRestriction":
            suggest = "scm_use_main_ip_restriction"
        elif key == "use32BitWorkerProcess":
            suggest = "use32_bit_worker_process"
        elif key == "vnetRouteAllEnabled":
            suggest = "vnet_route_all_enabled"
        elif key == "websocketsEnabled":
            suggest = "websockets_enabled"
        elif key == "windowsFxVersion":
            suggest = "windows_fx_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SlotSiteConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SlotSiteConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SlotSiteConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acr_use_managed_identity_credentials: Optional[bool] = None,
                 acr_user_managed_identity_client_id: Optional[str] = None,
                 always_on: Optional[bool] = None,
                 app_command_line: Optional[str] = None,
                 auto_swap_slot_name: Optional[str] = None,
                 cors: Optional['outputs.SlotSiteConfigCors'] = None,
                 default_documents: Optional[Sequence[str]] = None,
                 dotnet_framework_version: Optional[str] = None,
                 ftps_state: Optional[str] = None,
                 health_check_path: Optional[str] = None,
                 http2_enabled: Optional[bool] = None,
                 ip_restrictions: Optional[Sequence['outputs.SlotSiteConfigIpRestriction']] = None,
                 java_container: Optional[str] = None,
                 java_container_version: Optional[str] = None,
                 java_version: Optional[str] = None,
                 linux_fx_version: Optional[str] = None,
                 local_mysql_enabled: Optional[bool] = None,
                 managed_pipeline_mode: Optional[str] = None,
                 min_tls_version: Optional[str] = None,
                 number_of_workers: Optional[int] = None,
                 php_version: Optional[str] = None,
                 python_version: Optional[str] = None,
                 remote_debugging_enabled: Optional[bool] = None,
                 remote_debugging_version: Optional[str] = None,
                 scm_ip_restrictions: Optional[Sequence['outputs.SlotSiteConfigScmIpRestriction']] = None,
                 scm_type: Optional[str] = None,
                 scm_use_main_ip_restriction: Optional[bool] = None,
                 use32_bit_worker_process: Optional[bool] = None,
                 vnet_route_all_enabled: Optional[bool] = None,
                 websockets_enabled: Optional[bool] = None,
                 windows_fx_version: Optional[str] = None):
        """
        :param bool acr_use_managed_identity_credentials: Are Managed Identity Credentials used for Azure Container Registry pull
        :param str acr_user_managed_identity_client_id: If using User Managed Identity, the User Managed Identity Client Id
        :param bool always_on: Should the slot be loaded at all times? Defaults to `false`.
        :param str app_command_line: App command line to launch, e.g. `/sbin/myserver -b 0.0.0.0`.
        :param str auto_swap_slot_name: The name of the slot to automatically swap to during deployment
        :param 'SlotSiteConfigCorsArgs' cors: A `cors` block as defined below.
        :param Sequence[str] default_documents: The ordering of default documents to load, if an address isn't specified.
        :param str dotnet_framework_version: The version of the .NET framework's CLR used in this App Service Slot. Possible values are `v2.0` (which will use the latest version of the .NET framework for the .NET CLR v2 - currently `.net 3.5`), `v4.0` (which corresponds to the latest version of the .NET CLR v4 - which at the time of writing is `.net 4.7.1`), `v5.0` and `v6.0`. [For more information on which .NET CLR version to use based on the .NET framework you're targeting - please see this table](https://en.wikipedia.org/wiki/.NET_Framework_version_history#Overview). Defaults to `v4.0`.
        :param str ftps_state: State of FTP / FTPS service for this App Service Slot. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`.
        :param str health_check_path: The health check path to be pinged by App Service Slot. [For more information - please see App Service health check announcement](https://azure.github.io/AppService/2020/08/24/healthcheck-on-app-service.html).
        :param bool http2_enabled: Is HTTP2 Enabled on this App Service? Defaults to `false`.
        :param Sequence['SlotSiteConfigIpRestrictionArgs'] ip_restrictions: A list of objects representing ip restrictions as defined below.
        :param str java_container: The Java Container to use. If specified `java_version` and `java_container_version` must also be specified. Possible values are `JAVA`, `JETTY`, and `TOMCAT`.
        :param str java_container_version: The version of the Java Container to use. If specified `java_version` and `java_container` must also be specified.
        :param str java_version: The version of Java to use. If specified `java_container` and `java_container_version` must also be specified. Possible values are `1.7`, `1.8`, and `11` and their specific versions - except for Java 11 (e.g. `1.7.0_80`, `1.8.0_181`, `11`)
        :param str linux_fx_version: Linux App Framework and version for the App Service Slot. Possible options are a Docker container (`DOCKER|<user/image:tag>`), a base-64 encoded Docker Compose file (`COMPOSE|${filebase64("compose.yml")}`) or a base-64 encoded Kubernetes Manifest (`KUBE|${filebase64("kubernetes.yml")}`).
        :param bool local_mysql_enabled: Is "MySQL In App" Enabled? This runs a local MySQL instance with your app and shares resources from the App Service plan.
        :param str managed_pipeline_mode: The Managed Pipeline Mode. Possible values are `Integrated` and `Classic`. Defaults to `Integrated`.
        :param str min_tls_version: The minimum supported TLS version for the app service. Possible values are `1.0`, `1.1`, and `1.2`. Defaults to `1.2` for new app services.
        :param int number_of_workers: The scaled number of workers (for per site scaling) of this App Service Slot. Requires that `per_site_scaling` is enabled on the `appservice.Plan`. [For more information - please see Microsoft documentation on high-density hosting](https://docs.microsoft.com/azure/app-service/manage-scale-per-app).
        :param str php_version: The version of PHP to use in this App Service Slot. Possible values are `5.5`, `5.6`, `7.0`, `7.1`, `7.2`, `7.3`, and `7.4`.
        :param str python_version: The version of Python to use in this App Service Slot. Possible values are `2.7` and `3.4`.
        :param bool remote_debugging_enabled: Is Remote Debugging Enabled? Defaults to `false`.
        :param str remote_debugging_version: Which version of Visual Studio should the Remote Debugger be compatible with? Possible values are `VS2017` and `VS2019`.
        :param Sequence['SlotSiteConfigScmIpRestrictionArgs'] scm_ip_restrictions: A [List of objects](https://www.terraform.io/docs/configuration/attr-as-blocks.html) representing IP restrictions as defined below.
        :param str scm_type: The type of Source Control enabled for this App Service Slot. Defaults to `None`. Possible values are: `BitbucketGit`, `BitbucketHg`, `CodePlexGit`, `CodePlexHg`, `Dropbox`, `ExternalGit`, `ExternalHg`, `GitHub`, `LocalGit`, `None`, `OneDrive`, `Tfs`, `VSO`, and `VSTSRM`
        :param bool scm_use_main_ip_restriction: IP security restrictions for scm to use main. Defaults to false.
        :param bool use32_bit_worker_process: Should the App Service Slot run in 32 bit mode, rather than 64 bit mode?
        :param bool vnet_route_all_enabled: Should all outbound traffic to have Virtual Network Security Groups and User Defined Routes applied? Defaults to `false`.
        :param bool websockets_enabled: Should WebSockets be enabled?
        :param str windows_fx_version: The Windows Docker container image (`DOCKER|<user/image:tag>`)
        """
        if acr_use_managed_identity_credentials is not None:
            pulumi.set(__self__, "acr_use_managed_identity_credentials", acr_use_managed_identity_credentials)
        if acr_user_managed_identity_client_id is not None:
            pulumi.set(__self__, "acr_user_managed_identity_client_id", acr_user_managed_identity_client_id)
        if always_on is not None:
            pulumi.set(__self__, "always_on", always_on)
        if app_command_line is not None:
            pulumi.set(__self__, "app_command_line", app_command_line)
        if auto_swap_slot_name is not None:
            pulumi.set(__self__, "auto_swap_slot_name", auto_swap_slot_name)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if default_documents is not None:
            pulumi.set(__self__, "default_documents", default_documents)
        if dotnet_framework_version is not None:
            pulumi.set(__self__, "dotnet_framework_version", dotnet_framework_version)
        if ftps_state is not None:
            pulumi.set(__self__, "ftps_state", ftps_state)
        if health_check_path is not None:
            pulumi.set(__self__, "health_check_path", health_check_path)
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if ip_restrictions is not None:
            pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        if java_container is not None:
            pulumi.set(__self__, "java_container", java_container)
        if java_container_version is not None:
            pulumi.set(__self__, "java_container_version", java_container_version)
        if java_version is not None:
            pulumi.set(__self__, "java_version", java_version)
        if linux_fx_version is not None:
            pulumi.set(__self__, "linux_fx_version", linux_fx_version)
        if local_mysql_enabled is not None:
            pulumi.set(__self__, "local_mysql_enabled", local_mysql_enabled)
        if managed_pipeline_mode is not None:
            pulumi.set(__self__, "managed_pipeline_mode", managed_pipeline_mode)
        if min_tls_version is not None:
            pulumi.set(__self__, "min_tls_version", min_tls_version)
        if number_of_workers is not None:
            pulumi.set(__self__, "number_of_workers", number_of_workers)
        if php_version is not None:
            pulumi.set(__self__, "php_version", php_version)
        if python_version is not None:
            pulumi.set(__self__, "python_version", python_version)
        if remote_debugging_enabled is not None:
            pulumi.set(__self__, "remote_debugging_enabled", remote_debugging_enabled)
        if remote_debugging_version is not None:
            pulumi.set(__self__, "remote_debugging_version", remote_debugging_version)
        if scm_ip_restrictions is not None:
            pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        if scm_type is not None:
            pulumi.set(__self__, "scm_type", scm_type)
        if scm_use_main_ip_restriction is not None:
            pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        if use32_bit_worker_process is not None:
            pulumi.set(__self__, "use32_bit_worker_process", use32_bit_worker_process)
        if vnet_route_all_enabled is not None:
            pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        if websockets_enabled is not None:
            pulumi.set(__self__, "websockets_enabled", websockets_enabled)
        if windows_fx_version is not None:
            pulumi.set(__self__, "windows_fx_version", windows_fx_version)

    @property
    @pulumi.getter(name="acrUseManagedIdentityCredentials")
    def acr_use_managed_identity_credentials(self) -> Optional[bool]:
        """
        Are Managed Identity Credentials used for Azure Container Registry pull
        """
        return pulumi.get(self, "acr_use_managed_identity_credentials")

    @property
    @pulumi.getter(name="acrUserManagedIdentityClientId")
    def acr_user_managed_identity_client_id(self) -> Optional[str]:
        """
        If using User Managed Identity, the User Managed Identity Client Id
        """
        return pulumi.get(self, "acr_user_managed_identity_client_id")

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> Optional[bool]:
        """
        Should the slot be loaded at all times? Defaults to `false`.
        """
        return pulumi.get(self, "always_on")

    @property
    @pulumi.getter(name="appCommandLine")
    def app_command_line(self) -> Optional[str]:
        """
        App command line to launch, e.g. `/sbin/myserver -b 0.0.0.0`.
        """
        return pulumi.get(self, "app_command_line")

    @property
    @pulumi.getter(name="autoSwapSlotName")
    def auto_swap_slot_name(self) -> Optional[str]:
        """
        The name of the slot to automatically swap to during deployment
        """
        return pulumi.get(self, "auto_swap_slot_name")

    @property
    @pulumi.getter
    def cors(self) -> Optional['outputs.SlotSiteConfigCors']:
        """
        A `cors` block as defined below.
        """
        return pulumi.get(self, "cors")

    @property
    @pulumi.getter(name="defaultDocuments")
    def default_documents(self) -> Optional[Sequence[str]]:
        """
        The ordering of default documents to load, if an address isn't specified.
        """
        return pulumi.get(self, "default_documents")

    @property
    @pulumi.getter(name="dotnetFrameworkVersion")
    def dotnet_framework_version(self) -> Optional[str]:
        """
        The version of the .NET framework's CLR used in this App Service Slot. Possible values are `v2.0` (which will use the latest version of the .NET framework for the .NET CLR v2 - currently `.net 3.5`), `v4.0` (which corresponds to the latest version of the .NET CLR v4 - which at the time of writing is `.net 4.7.1`), `v5.0` and `v6.0`. [For more information on which .NET CLR version to use based on the .NET framework you're targeting - please see this table](https://en.wikipedia.org/wiki/.NET_Framework_version_history#Overview). Defaults to `v4.0`.
        """
        return pulumi.get(self, "dotnet_framework_version")

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> Optional[str]:
        """
        State of FTP / FTPS service for this App Service Slot. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`.
        """
        return pulumi.get(self, "ftps_state")

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> Optional[str]:
        """
        The health check path to be pinged by App Service Slot. [For more information - please see App Service health check announcement](https://azure.github.io/AppService/2020/08/24/healthcheck-on-app-service.html).
        """
        return pulumi.get(self, "health_check_path")

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[bool]:
        """
        Is HTTP2 Enabled on this App Service? Defaults to `false`.
        """
        return pulumi.get(self, "http2_enabled")

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Optional[Sequence['outputs.SlotSiteConfigIpRestriction']]:
        """
        A list of objects representing ip restrictions as defined below.
        """
        return pulumi.get(self, "ip_restrictions")

    @property
    @pulumi.getter(name="javaContainer")
    def java_container(self) -> Optional[str]:
        """
        The Java Container to use. If specified `java_version` and `java_container_version` must also be specified. Possible values are `JAVA`, `JETTY`, and `TOMCAT`.
        """
        return pulumi.get(self, "java_container")

    @property
    @pulumi.getter(name="javaContainerVersion")
    def java_container_version(self) -> Optional[str]:
        """
        The version of the Java Container to use. If specified `java_version` and `java_container` must also be specified.
        """
        return pulumi.get(self, "java_container_version")

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> Optional[str]:
        """
        The version of Java to use. If specified `java_container` and `java_container_version` must also be specified. Possible values are `1.7`, `1.8`, and `11` and their specific versions - except for Java 11 (e.g. `1.7.0_80`, `1.8.0_181`, `11`)
        """
        return pulumi.get(self, "java_version")

    @property
    @pulumi.getter(name="linuxFxVersion")
    def linux_fx_version(self) -> Optional[str]:
        """
        Linux App Framework and version for the App Service Slot. Possible options are a Docker container (`DOCKER|<user/image:tag>`), a base-64 encoded Docker Compose file (`COMPOSE|${filebase64("compose.yml")}`) or a base-64 encoded Kubernetes Manifest (`KUBE|${filebase64("kubernetes.yml")}`).
        """
        return pulumi.get(self, "linux_fx_version")

    @property
    @pulumi.getter(name="localMysqlEnabled")
    def local_mysql_enabled(self) -> Optional[bool]:
        """
        Is "MySQL In App" Enabled? This runs a local MySQL instance with your app and shares resources from the App Service plan.
        """
        return pulumi.get(self, "local_mysql_enabled")

    @property
    @pulumi.getter(name="managedPipelineMode")
    def managed_pipeline_mode(self) -> Optional[str]:
        """
        The Managed Pipeline Mode. Possible values are `Integrated` and `Classic`. Defaults to `Integrated`.
        """
        return pulumi.get(self, "managed_pipeline_mode")

    @property
    @pulumi.getter(name="minTlsVersion")
    def min_tls_version(self) -> Optional[str]:
        """
        The minimum supported TLS version for the app service. Possible values are `1.0`, `1.1`, and `1.2`. Defaults to `1.2` for new app services.
        """
        return pulumi.get(self, "min_tls_version")

    @property
    @pulumi.getter(name="numberOfWorkers")
    def number_of_workers(self) -> Optional[int]:
        """
        The scaled number of workers (for per site scaling) of this App Service Slot. Requires that `per_site_scaling` is enabled on the `appservice.Plan`. [For more information - please see Microsoft documentation on high-density hosting](https://docs.microsoft.com/azure/app-service/manage-scale-per-app).
        """
        return pulumi.get(self, "number_of_workers")

    @property
    @pulumi.getter(name="phpVersion")
    def php_version(self) -> Optional[str]:
        """
        The version of PHP to use in this App Service Slot. Possible values are `5.5`, `5.6`, `7.0`, `7.1`, `7.2`, `7.3`, and `7.4`.
        """
        return pulumi.get(self, "php_version")

    @property
    @pulumi.getter(name="pythonVersion")
    def python_version(self) -> Optional[str]:
        """
        The version of Python to use in this App Service Slot. Possible values are `2.7` and `3.4`.
        """
        return pulumi.get(self, "python_version")

    @property
    @pulumi.getter(name="remoteDebuggingEnabled")
    def remote_debugging_enabled(self) -> Optional[bool]:
        """
        Is Remote Debugging Enabled? Defaults to `false`.
        """
        return pulumi.get(self, "remote_debugging_enabled")

    @property
    @pulumi.getter(name="remoteDebuggingVersion")
    def remote_debugging_version(self) -> Optional[str]:
        """
        Which version of Visual Studio should the Remote Debugger be compatible with? Possible values are `VS2017` and `VS2019`.
        """
        return pulumi.get(self, "remote_debugging_version")

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Optional[Sequence['outputs.SlotSiteConfigScmIpRestriction']]:
        """
        A [List of objects](https://www.terraform.io/docs/configuration/attr-as-blocks.html) representing IP restrictions as defined below.
        """
        return pulumi.get(self, "scm_ip_restrictions")

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> Optional[str]:
        """
        The type of Source Control enabled for this App Service Slot. Defaults to `None`. Possible values are: `BitbucketGit`, `BitbucketHg`, `CodePlexGit`, `CodePlexHg`, `Dropbox`, `ExternalGit`, `ExternalHg`, `GitHub`, `LocalGit`, `None`, `OneDrive`, `Tfs`, `VSO`, and `VSTSRM`
        """
        return pulumi.get(self, "scm_type")

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> Optional[bool]:
        """
        IP security restrictions for scm to use main. Defaults to false.
        """
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @property
    @pulumi.getter(name="use32BitWorkerProcess")
    def use32_bit_worker_process(self) -> Optional[bool]:
        """
        Should the App Service Slot run in 32 bit mode, rather than 64 bit mode?
        """
        return pulumi.get(self, "use32_bit_worker_process")

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> Optional[bool]:
        """
        Should all outbound traffic to have Virtual Network Security Groups and User Defined Routes applied? Defaults to `false`.
        """
        return pulumi.get(self, "vnet_route_all_enabled")

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> Optional[bool]:
        """
        Should WebSockets be enabled?
        """
        return pulumi.get(self, "websockets_enabled")

    @property
    @pulumi.getter(name="windowsFxVersion")
    def windows_fx_version(self) -> Optional[str]:
        """
        The Windows Docker container image (`DOCKER|<user/image:tag>`)
        """
        return pulumi.get(self, "windows_fx_version")


@pulumi.output_type
class SlotSiteConfigCors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedOrigins":
            suggest = "allowed_origins"
        elif key == "supportCredentials":
            suggest = "support_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SlotSiteConfigCors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SlotSiteConfigCors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SlotSiteConfigCors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_origins: Sequence[str],
                 support_credentials: Optional[bool] = None):
        """
        :param Sequence[str] allowed_origins: A list of origins which should be able to make cross-origin calls. `*` can be used to allow all calls.
        :param bool support_credentials: Are credentials supported?
        """
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        if support_credentials is not None:
            pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Sequence[str]:
        """
        A list of origins which should be able to make cross-origin calls. `*` can be used to allow all calls.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> Optional[bool]:
        """
        Are credentials supported?
        """
        return pulumi.get(self, "support_credentials")


@pulumi.output_type
class SlotSiteConfigIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SlotSiteConfigIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SlotSiteConfigIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SlotSiteConfigIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.SlotSiteConfigIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: Does this restriction `Allow` or `Deny` access for this IP range. Defaults to `Allow`.
        :param 'SlotSiteConfigIpRestrictionHeadersArgs' headers: The headers for this specific `ip_restriction` as defined below. The HTTP header filters are evaluated after the rule itself and both conditions must be true for the rule to apply.
        :param str ip_address: The IP Address used for this IP Restriction in CIDR notation.
        :param str name: The name for this IP Restriction.
        :param int priority: The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        Does this restriction `Allow` or `Deny` access for this IP range. Defaults to `Allow`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.SlotSiteConfigIpRestrictionHeaders']:
        """
        The headers for this specific `ip_restriction` as defined below. The HTTP header filters are evaluated after the rule itself and both conditions must be true for the rule to apply.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The IP Address used for this IP Restriction in CIDR notation.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name for this IP Restriction.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class SlotSiteConfigIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SlotSiteConfigIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SlotSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SlotSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        :param str x_fd_health_probe: A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        :param Sequence[str] x_forwarded_fors: A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        :param Sequence[str] x_forwarded_hosts: A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class SlotSiteConfigScmIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SlotSiteConfigScmIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SlotSiteConfigScmIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SlotSiteConfigScmIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.SlotSiteConfigScmIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: Does this restriction `Allow` or `Deny` access for this IP range. Defaults to `Allow`.
        :param 'SlotSiteConfigScmIpRestrictionHeadersArgs' headers: The headers for this specific `ip_restriction` as defined below. The HTTP header filters are evaluated after the rule itself and both conditions must be true for the rule to apply.
        :param str ip_address: The IP Address used for this IP Restriction in CIDR notation.
        :param str name: Specifies the name of the App Service Slot component. Changing this forces a new resource to be created.
        :param int priority: The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        Does this restriction `Allow` or `Deny` access for this IP range. Defaults to `Allow`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.SlotSiteConfigScmIpRestrictionHeaders']:
        """
        The headers for this specific `ip_restriction` as defined below. The HTTP header filters are evaluated after the rule itself and both conditions must be true for the rule to apply.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The IP Address used for this IP Restriction in CIDR notation.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Specifies the name of the App Service Slot component. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class SlotSiteConfigScmIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SlotSiteConfigScmIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SlotSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SlotSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        :param str x_fd_health_probe: A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        :param Sequence[str] x_forwarded_fors: A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        :param Sequence[str] x_forwarded_hosts: A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class SlotSiteCredential(dict):
    def __init__(__self__, *,
                 password: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str password: The password associated with the username, which can be used to publish to this App Service.
        :param str username: The username which can be used to publish to this App Service
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password associated with the username, which can be used to publish to this App Service.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username which can be used to publish to this App Service
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class SlotStorageAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "accountName":
            suggest = "account_name"
        elif key == "shareName":
            suggest = "share_name"
        elif key == "mountPath":
            suggest = "mount_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SlotStorageAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SlotStorageAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SlotStorageAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: str,
                 account_name: str,
                 name: str,
                 share_name: str,
                 type: str,
                 mount_path: Optional[str] = None):
        """
        :param str access_key: The access key for the storage account.
        :param str account_name: The name of the storage account.
        :param str name: The name of the storage account identifier.
        :param str share_name: The name of the file share (container name, for Blob storage).
        :param str type: The type of storage. Possible values are `AzureBlob` and `AzureFiles`.
        :param str mount_path: The path to mount the storage within the site's runtime environment.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "share_name", share_name)
        pulumi.set(__self__, "type", type)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> str:
        """
        The access key for the storage account.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> str:
        """
        The name of the storage account.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the storage account identifier.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> str:
        """
        The name of the file share (container name, for Blob storage).
        """
        return pulumi.get(self, "share_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of storage. Possible values are `AzureBlob` and `AzureFiles`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[str]:
        """
        The path to mount the storage within the site's runtime environment.
        """
        return pulumi.get(self, "mount_path")


@pulumi.output_type
class SourceControlGithubActionConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "codeConfiguration":
            suggest = "code_configuration"
        elif key == "containerConfiguration":
            suggest = "container_configuration"
        elif key == "generateWorkflowFile":
            suggest = "generate_workflow_file"
        elif key == "linuxAction":
            suggest = "linux_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceControlGithubActionConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceControlGithubActionConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceControlGithubActionConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 code_configuration: Optional['outputs.SourceControlGithubActionConfigurationCodeConfiguration'] = None,
                 container_configuration: Optional['outputs.SourceControlGithubActionConfigurationContainerConfiguration'] = None,
                 generate_workflow_file: Optional[bool] = None,
                 linux_action: Optional[bool] = None):
        """
        :param 'SourceControlGithubActionConfigurationCodeConfigurationArgs' code_configuration: A `code_configuration` block as defined above.
        :param 'SourceControlGithubActionConfigurationContainerConfigurationArgs' container_configuration: A `container_configuration` block as defined above.
        """
        if code_configuration is not None:
            pulumi.set(__self__, "code_configuration", code_configuration)
        if container_configuration is not None:
            pulumi.set(__self__, "container_configuration", container_configuration)
        if generate_workflow_file is not None:
            pulumi.set(__self__, "generate_workflow_file", generate_workflow_file)
        if linux_action is not None:
            pulumi.set(__self__, "linux_action", linux_action)

    @property
    @pulumi.getter(name="codeConfiguration")
    def code_configuration(self) -> Optional['outputs.SourceControlGithubActionConfigurationCodeConfiguration']:
        """
        A `code_configuration` block as defined above.
        """
        return pulumi.get(self, "code_configuration")

    @property
    @pulumi.getter(name="containerConfiguration")
    def container_configuration(self) -> Optional['outputs.SourceControlGithubActionConfigurationContainerConfiguration']:
        """
        A `container_configuration` block as defined above.
        """
        return pulumi.get(self, "container_configuration")

    @property
    @pulumi.getter(name="generateWorkflowFile")
    def generate_workflow_file(self) -> Optional[bool]:
        return pulumi.get(self, "generate_workflow_file")

    @property
    @pulumi.getter(name="linuxAction")
    def linux_action(self) -> Optional[bool]:
        return pulumi.get(self, "linux_action")


@pulumi.output_type
class SourceControlGithubActionConfigurationCodeConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "runtimeStack":
            suggest = "runtime_stack"
        elif key == "runtimeVersion":
            suggest = "runtime_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceControlGithubActionConfigurationCodeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceControlGithubActionConfigurationCodeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceControlGithubActionConfigurationCodeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 runtime_stack: str,
                 runtime_version: str):
        """
        :param str runtime_stack: The value to use for the Runtime Stack in the workflow file content for code base apps. Changing this forces a new resource to be created.
        :param str runtime_version: The value to use for the Runtime Version in the workflow file content for code base apps. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "runtime_stack", runtime_stack)
        pulumi.set(__self__, "runtime_version", runtime_version)

    @property
    @pulumi.getter(name="runtimeStack")
    def runtime_stack(self) -> str:
        """
        The value to use for the Runtime Stack in the workflow file content for code base apps. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "runtime_stack")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> str:
        """
        The value to use for the Runtime Version in the workflow file content for code base apps. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "runtime_version")


@pulumi.output_type
class SourceControlGithubActionConfigurationContainerConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageName":
            suggest = "image_name"
        elif key == "registryUrl":
            suggest = "registry_url"
        elif key == "registryPassword":
            suggest = "registry_password"
        elif key == "registryUsername":
            suggest = "registry_username"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceControlGithubActionConfigurationContainerConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceControlGithubActionConfigurationContainerConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceControlGithubActionConfigurationContainerConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_name: str,
                 registry_url: str,
                 registry_password: Optional[str] = None,
                 registry_username: Optional[str] = None):
        """
        :param str image_name: The image name for the build. Changing this forces a new resource to be created.
        :param str registry_url: The server URL for the container registry where the build will be hosted. Changing this forces a new resource to be created.
        :param str registry_password: The password used to upload the image to the container registry. Changing this forces a new resource to be created.
        :param str registry_username: The username used to upload the image to the container registry. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "image_name", image_name)
        pulumi.set(__self__, "registry_url", registry_url)
        if registry_password is not None:
            pulumi.set(__self__, "registry_password", registry_password)
        if registry_username is not None:
            pulumi.set(__self__, "registry_username", registry_username)

    @property
    @pulumi.getter(name="imageName")
    def image_name(self) -> str:
        """
        The image name for the build. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "image_name")

    @property
    @pulumi.getter(name="registryUrl")
    def registry_url(self) -> str:
        """
        The server URL for the container registry where the build will be hosted. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "registry_url")

    @property
    @pulumi.getter(name="registryPassword")
    def registry_password(self) -> Optional[str]:
        """
        The password used to upload the image to the container registry. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "registry_password")

    @property
    @pulumi.getter(name="registryUsername")
    def registry_username(self) -> Optional[str]:
        """
        The username used to upload the image to the container registry. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "registry_username")


@pulumi.output_type
class SourceControlSlotGithubActionConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "codeConfiguration":
            suggest = "code_configuration"
        elif key == "containerConfiguration":
            suggest = "container_configuration"
        elif key == "generateWorkflowFile":
            suggest = "generate_workflow_file"
        elif key == "linuxAction":
            suggest = "linux_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceControlSlotGithubActionConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceControlSlotGithubActionConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceControlSlotGithubActionConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 code_configuration: Optional['outputs.SourceControlSlotGithubActionConfigurationCodeConfiguration'] = None,
                 container_configuration: Optional['outputs.SourceControlSlotGithubActionConfigurationContainerConfiguration'] = None,
                 generate_workflow_file: Optional[bool] = None,
                 linux_action: Optional[bool] = None):
        """
        :param 'SourceControlSlotGithubActionConfigurationCodeConfigurationArgs' code_configuration: A `code_configuration` block as detailed below.
        :param 'SourceControlSlotGithubActionConfigurationContainerConfigurationArgs' container_configuration: A `container_configuration` block as detailed below.
        :param bool generate_workflow_file: Should the service generate the GitHub Action Workflow file. Defaults to `true` Changing this forces a new resource to be created.
        :param bool linux_action: Denotes this action uses a Linux base image.
        """
        if code_configuration is not None:
            pulumi.set(__self__, "code_configuration", code_configuration)
        if container_configuration is not None:
            pulumi.set(__self__, "container_configuration", container_configuration)
        if generate_workflow_file is not None:
            pulumi.set(__self__, "generate_workflow_file", generate_workflow_file)
        if linux_action is not None:
            pulumi.set(__self__, "linux_action", linux_action)

    @property
    @pulumi.getter(name="codeConfiguration")
    def code_configuration(self) -> Optional['outputs.SourceControlSlotGithubActionConfigurationCodeConfiguration']:
        """
        A `code_configuration` block as detailed below.
        """
        return pulumi.get(self, "code_configuration")

    @property
    @pulumi.getter(name="containerConfiguration")
    def container_configuration(self) -> Optional['outputs.SourceControlSlotGithubActionConfigurationContainerConfiguration']:
        """
        A `container_configuration` block as detailed below.
        """
        return pulumi.get(self, "container_configuration")

    @property
    @pulumi.getter(name="generateWorkflowFile")
    def generate_workflow_file(self) -> Optional[bool]:
        """
        Should the service generate the GitHub Action Workflow file. Defaults to `true` Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "generate_workflow_file")

    @property
    @pulumi.getter(name="linuxAction")
    def linux_action(self) -> Optional[bool]:
        """
        Denotes this action uses a Linux base image.
        """
        return pulumi.get(self, "linux_action")


@pulumi.output_type
class SourceControlSlotGithubActionConfigurationCodeConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "runtimeStack":
            suggest = "runtime_stack"
        elif key == "runtimeVersion":
            suggest = "runtime_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceControlSlotGithubActionConfigurationCodeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceControlSlotGithubActionConfigurationCodeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceControlSlotGithubActionConfigurationCodeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 runtime_stack: str,
                 runtime_version: str):
        """
        :param str runtime_stack: The value to use for the Runtime Stack in the workflow file content for code base apps. Changing this forces a new resource to be created. Possible values are `dotnetcore`, `spring`, `tomcat`, `node` and `python`.
        :param str runtime_version: The value to use for the Runtime Version in the workflow file content for code base apps. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "runtime_stack", runtime_stack)
        pulumi.set(__self__, "runtime_version", runtime_version)

    @property
    @pulumi.getter(name="runtimeStack")
    def runtime_stack(self) -> str:
        """
        The value to use for the Runtime Stack in the workflow file content for code base apps. Changing this forces a new resource to be created. Possible values are `dotnetcore`, `spring`, `tomcat`, `node` and `python`.
        """
        return pulumi.get(self, "runtime_stack")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> str:
        """
        The value to use for the Runtime Version in the workflow file content for code base apps. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "runtime_version")


@pulumi.output_type
class SourceControlSlotGithubActionConfigurationContainerConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageName":
            suggest = "image_name"
        elif key == "registryUrl":
            suggest = "registry_url"
        elif key == "registryPassword":
            suggest = "registry_password"
        elif key == "registryUsername":
            suggest = "registry_username"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceControlSlotGithubActionConfigurationContainerConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceControlSlotGithubActionConfigurationContainerConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceControlSlotGithubActionConfigurationContainerConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_name: str,
                 registry_url: str,
                 registry_password: Optional[str] = None,
                 registry_username: Optional[str] = None):
        """
        :param str image_name: The image name for the build. Changing this forces a new resource to be created.
        :param str registry_url: The server URL for the container registry where the build will be hosted. Changing this forces a new resource to be created.
        :param str registry_password: The password used to upload the image to the container registry. Changing this forces a new resource to be created.
        :param str registry_username: The username used to upload the image to the container registry. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "image_name", image_name)
        pulumi.set(__self__, "registry_url", registry_url)
        if registry_password is not None:
            pulumi.set(__self__, "registry_password", registry_password)
        if registry_username is not None:
            pulumi.set(__self__, "registry_username", registry_username)

    @property
    @pulumi.getter(name="imageName")
    def image_name(self) -> str:
        """
        The image name for the build. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "image_name")

    @property
    @pulumi.getter(name="registryUrl")
    def registry_url(self) -> str:
        """
        The server URL for the container registry where the build will be hosted. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "registry_url")

    @property
    @pulumi.getter(name="registryPassword")
    def registry_password(self) -> Optional[str]:
        """
        The password used to upload the image to the container registry. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "registry_password")

    @property
    @pulumi.getter(name="registryUsername")
    def registry_username(self) -> Optional[str]:
        """
        The username used to upload the image to the container registry. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "registry_username")


@pulumi.output_type
class StaticSiteIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StaticSiteIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StaticSiteIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StaticSiteIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 identity_ids: Optional[Sequence[str]] = None,
                 principal_id: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str type: The Type of Managed Identity assigned to this Static Site resource. Possible values are `SystemAssigned`, `UserAssigned` and `SystemAssigned, UserAssigned`.
        :param Sequence[str] identity_ids: A list of Managed Identity IDs which should be assigned to this Static Site resource.
        :param str principal_id: (Optional) The Principal ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The Type of Managed Identity assigned to this Static Site resource. Possible values are `SystemAssigned`, `UserAssigned` and `SystemAssigned, UserAssigned`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[str]]:
        """
        A list of Managed Identity IDs which should be assigned to this Static Site resource.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        """
        (Optional) The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class WindowsFunctionAppAuthSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeDirectory":
            suggest = "active_directory"
        elif key == "additionalLoginParameters":
            suggest = "additional_login_parameters"
        elif key == "allowedExternalRedirectUrls":
            suggest = "allowed_external_redirect_urls"
        elif key == "defaultProvider":
            suggest = "default_provider"
        elif key == "runtimeVersion":
            suggest = "runtime_version"
        elif key == "tokenRefreshExtensionHours":
            suggest = "token_refresh_extension_hours"
        elif key == "tokenStoreEnabled":
            suggest = "token_store_enabled"
        elif key == "unauthenticatedClientAction":
            suggest = "unauthenticated_client_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppAuthSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppAuthSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppAuthSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 active_directory: Optional['outputs.WindowsFunctionAppAuthSettingsActiveDirectory'] = None,
                 additional_login_parameters: Optional[Mapping[str, str]] = None,
                 allowed_external_redirect_urls: Optional[Sequence[str]] = None,
                 default_provider: Optional[str] = None,
                 facebook: Optional['outputs.WindowsFunctionAppAuthSettingsFacebook'] = None,
                 github: Optional['outputs.WindowsFunctionAppAuthSettingsGithub'] = None,
                 google: Optional['outputs.WindowsFunctionAppAuthSettingsGoogle'] = None,
                 issuer: Optional[str] = None,
                 microsoft: Optional['outputs.WindowsFunctionAppAuthSettingsMicrosoft'] = None,
                 runtime_version: Optional[str] = None,
                 token_refresh_extension_hours: Optional[float] = None,
                 token_store_enabled: Optional[bool] = None,
                 twitter: Optional['outputs.WindowsFunctionAppAuthSettingsTwitter'] = None,
                 unauthenticated_client_action: Optional[str] = None):
        """
        :param bool enabled: Should the Authentication / Authorization feature be enabled for the Windows Function App?
        :param 'WindowsFunctionAppAuthSettingsActiveDirectoryArgs' active_directory: An `active_directory` block as defined above.
        :param Mapping[str, str] additional_login_parameters: Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        :param Sequence[str] allowed_external_redirect_urls: Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Windows Function App.
        :param str default_provider: The default authentication provider to use when multiple providers are configured. Possible values include: `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount`, `Twitter`, `Github`
        :param 'WindowsFunctionAppAuthSettingsFacebookArgs' facebook: A `facebook` block as defined below.
        :param 'WindowsFunctionAppAuthSettingsGithubArgs' github: A `github` block as defined below.
        :param 'WindowsFunctionAppAuthSettingsGoogleArgs' google: A `google` block as defined below.
        :param str issuer: The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Windows Function App.
        :param 'WindowsFunctionAppAuthSettingsMicrosoftArgs' microsoft: A `microsoft` block as defined below.
        :param str runtime_version: The Runtime Version of the Authentication / Authorization feature in use for the Windows Function App.
        :param float token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        :param bool token_store_enabled: Should the Windows Function App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        :param 'WindowsFunctionAppAuthSettingsTwitterArgs' twitter: A `twitter` block as defined below.
        :param str unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if active_directory is not None:
            pulumi.set(__self__, "active_directory", active_directory)
        if additional_login_parameters is not None:
            pulumi.set(__self__, "additional_login_parameters", additional_login_parameters)
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if facebook is not None:
            pulumi.set(__self__, "facebook", facebook)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if google is not None:
            pulumi.set(__self__, "google", google)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if microsoft is not None:
            pulumi.set(__self__, "microsoft", microsoft)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if token_refresh_extension_hours is not None:
            pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if twitter is not None:
            pulumi.set(__self__, "twitter", twitter)
        if unauthenticated_client_action is not None:
            pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Should the Authentication / Authorization feature be enabled for the Windows Function App?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="activeDirectory")
    def active_directory(self) -> Optional['outputs.WindowsFunctionAppAuthSettingsActiveDirectory']:
        """
        An `active_directory` block as defined above.
        """
        return pulumi.get(self, "active_directory")

    @property
    @pulumi.getter(name="additionalLoginParameters")
    def additional_login_parameters(self) -> Optional[Mapping[str, str]]:
        """
        Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        """
        return pulumi.get(self, "additional_login_parameters")

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Windows Function App.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[str]:
        """
        The default authentication provider to use when multiple providers are configured. Possible values include: `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount`, `Twitter`, `Github`
        """
        return pulumi.get(self, "default_provider")

    @property
    @pulumi.getter
    def facebook(self) -> Optional['outputs.WindowsFunctionAppAuthSettingsFacebook']:
        """
        A `facebook` block as defined below.
        """
        return pulumi.get(self, "facebook")

    @property
    @pulumi.getter
    def github(self) -> Optional['outputs.WindowsFunctionAppAuthSettingsGithub']:
        """
        A `github` block as defined below.
        """
        return pulumi.get(self, "github")

    @property
    @pulumi.getter
    def google(self) -> Optional['outputs.WindowsFunctionAppAuthSettingsGoogle']:
        """
        A `google` block as defined below.
        """
        return pulumi.get(self, "google")

    @property
    @pulumi.getter
    def issuer(self) -> Optional[str]:
        """
        The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Windows Function App.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def microsoft(self) -> Optional['outputs.WindowsFunctionAppAuthSettingsMicrosoft']:
        """
        A `microsoft` block as defined below.
        """
        return pulumi.get(self, "microsoft")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[str]:
        """
        The Runtime Version of the Authentication / Authorization feature in use for the Windows Function App.
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> Optional[float]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        return pulumi.get(self, "token_refresh_extension_hours")

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[bool]:
        """
        Should the Windows Function App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        """
        return pulumi.get(self, "token_store_enabled")

    @property
    @pulumi.getter
    def twitter(self) -> Optional['outputs.WindowsFunctionAppAuthSettingsTwitter']:
        """
        A `twitter` block as defined below.
        """
        return pulumi.get(self, "twitter")

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> Optional[str]:
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        return pulumi.get(self, "unauthenticated_client_action")


@pulumi.output_type
class WindowsFunctionAppAuthSettingsActiveDirectory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppAuthSettingsActiveDirectory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppAuthSettingsActiveDirectory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppAuthSettingsActiveDirectory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param Sequence[str] allowed_audiences: Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
        :param str client_secret: The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        pulumi.set(__self__, "client_id", client_id)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")


@pulumi.output_type
class WindowsFunctionAppAuthSettingsFacebook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "appSecret":
            suggest = "app_secret"
        elif key == "appSecretSettingName":
            suggest = "app_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppAuthSettingsFacebook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppAuthSettingsFacebook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppAuthSettingsFacebook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: str,
                 app_secret: Optional[str] = None,
                 app_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str app_id: The App ID of the Facebook app used for login.
        :param str app_secret: The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        :param str app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        if app_secret is not None:
            pulumi.set(__self__, "app_secret", app_secret)
        if app_secret_setting_name is not None:
            pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appSecret")
    def app_secret(self) -> Optional[str]:
        """
        The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        """
        return pulumi.get(self, "app_secret")

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class WindowsFunctionAppAuthSettingsGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppAuthSettingsGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppAuthSettingsGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppAuthSettingsGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the GitHub app used for login.
        :param str client_secret: The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the GitHub app used for login.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class WindowsFunctionAppAuthSettingsGoogle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppAuthSettingsGoogle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppAuthSettingsGoogle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppAuthSettingsGoogle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OpenID Connect Client ID for the Google web application.
        :param str client_secret: The client secret associated with the Google web application.  Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OpenID Connect Client ID for the Google web application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The client secret associated with the Google web application.  Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class WindowsFunctionAppAuthSettingsMicrosoft(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppAuthSettingsMicrosoft. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppAuthSettingsMicrosoft.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppAuthSettingsMicrosoft.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret: The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, `wl.basic` is used as the default scope.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, `wl.basic` is used as the default scope.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class WindowsFunctionAppAuthSettingsTwitter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerKey":
            suggest = "consumer_key"
        elif key == "consumerSecret":
            suggest = "consumer_secret"
        elif key == "consumerSecretSettingName":
            suggest = "consumer_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppAuthSettingsTwitter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppAuthSettingsTwitter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppAuthSettingsTwitter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_key: str,
                 consumer_secret: Optional[str] = None,
                 consumer_secret_setting_name: Optional[str] = None):
        """
        :param str consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param str consumer_secret: The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        :param str consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        if consumer_secret is not None:
            pulumi.set(__self__, "consumer_secret", consumer_secret)
        if consumer_secret_setting_name is not None:
            pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> str:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> Optional[str]:
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        """
        return pulumi.get(self, "consumer_secret")

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        return pulumi.get(self, "consumer_secret_setting_name")


@pulumi.output_type
class WindowsFunctionAppBackup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageAccountUrl":
            suggest = "storage_account_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppBackup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppBackup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppBackup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 schedule: 'outputs.WindowsFunctionAppBackupSchedule',
                 storage_account_url: str,
                 enabled: Optional[bool] = None):
        """
        :param str name: The name which should be used for this Backup.
        :param 'WindowsFunctionAppBackupScheduleArgs' schedule: A `schedule` block as defined below.
        :param str storage_account_url: The SAS URL to the container.
        :param bool enabled: Should this backup job be enabled?
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "storage_account_url", storage_account_url)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Backup.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def schedule(self) -> 'outputs.WindowsFunctionAppBackupSchedule':
        """
        A `schedule` block as defined below.
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter(name="storageAccountUrl")
    def storage_account_url(self) -> str:
        """
        The SAS URL to the container.
        """
        return pulumi.get(self, "storage_account_url")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Should this backup job be enabled?
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class WindowsFunctionAppBackupSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "frequencyUnit":
            suggest = "frequency_unit"
        elif key == "keepAtLeastOneBackup":
            suggest = "keep_at_least_one_backup"
        elif key == "lastExecutionTime":
            suggest = "last_execution_time"
        elif key == "retentionPeriodDays":
            suggest = "retention_period_days"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppBackupSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppBackupSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppBackupSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_unit: str,
                 keep_at_least_one_backup: Optional[bool] = None,
                 last_execution_time: Optional[str] = None,
                 retention_period_days: Optional[int] = None,
                 start_time: Optional[str] = None):
        """
        :param int frequency_interval: How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).
        :param str frequency_unit: The unit of time for how often the backup should take place. Possible values include: `Day` and `Hour`.
        :param bool keep_at_least_one_backup: Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
        :param int retention_period_days: After how many days backups should be deleted.
        :param str start_time: When the schedule should start working in RFC-3339 format.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_unit", frequency_unit)
        if keep_at_least_one_backup is not None:
            pulumi.set(__self__, "keep_at_least_one_backup", keep_at_least_one_backup)
        if last_execution_time is not None:
            pulumi.set(__self__, "last_execution_time", last_execution_time)
        if retention_period_days is not None:
            pulumi.set(__self__, "retention_period_days", retention_period_days)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyUnit")
    def frequency_unit(self) -> str:
        """
        The unit of time for how often the backup should take place. Possible values include: `Day` and `Hour`.
        """
        return pulumi.get(self, "frequency_unit")

    @property
    @pulumi.getter(name="keepAtLeastOneBackup")
    def keep_at_least_one_backup(self) -> Optional[bool]:
        """
        Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
        """
        return pulumi.get(self, "keep_at_least_one_backup")

    @property
    @pulumi.getter(name="lastExecutionTime")
    def last_execution_time(self) -> Optional[str]:
        return pulumi.get(self, "last_execution_time")

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> Optional[int]:
        """
        After how many days backups should be deleted.
        """
        return pulumi.get(self, "retention_period_days")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        """
        When the schedule should start working in RFC-3339 format.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class WindowsFunctionAppConnectionString(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: The name which should be used for this Connection.
        :param str type: Type of database. Possible values include: `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
        :param str value: The connection string value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Connection.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of database. Possible values include: `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The connection string value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class WindowsFunctionAppIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 identity_ids: Optional[Sequence[str]] = None,
                 principal_id: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str type: Specifies the type of Managed Service Identity that should be configured on this Windows Function App. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        :param Sequence[str] identity_ids: A list of User Assigned Managed Identity IDs to be assigned to this Windows Function App.
        :param str principal_id: The Principal ID associated with this Managed Service Identity.
        :param str tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the type of Managed Service Identity that should be configured on this Windows Function App. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[str]]:
        """
        A list of User Assigned Managed Identity IDs to be assigned to this Windows Function App.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class WindowsFunctionAppSiteConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alwaysOn":
            suggest = "always_on"
        elif key == "apiDefinitionUrl":
            suggest = "api_definition_url"
        elif key == "apiManagementApiId":
            suggest = "api_management_api_id"
        elif key == "appCommandLine":
            suggest = "app_command_line"
        elif key == "appScaleLimit":
            suggest = "app_scale_limit"
        elif key == "appServiceLogs":
            suggest = "app_service_logs"
        elif key == "applicationInsightsConnectionString":
            suggest = "application_insights_connection_string"
        elif key == "applicationInsightsKey":
            suggest = "application_insights_key"
        elif key == "applicationStack":
            suggest = "application_stack"
        elif key == "defaultDocuments":
            suggest = "default_documents"
        elif key == "detailedErrorLoggingEnabled":
            suggest = "detailed_error_logging_enabled"
        elif key == "elasticInstanceMinimum":
            suggest = "elastic_instance_minimum"
        elif key == "ftpsState":
            suggest = "ftps_state"
        elif key == "healthCheckEvictionTimeInMin":
            suggest = "health_check_eviction_time_in_min"
        elif key == "healthCheckPath":
            suggest = "health_check_path"
        elif key == "http2Enabled":
            suggest = "http2_enabled"
        elif key == "ipRestrictions":
            suggest = "ip_restrictions"
        elif key == "loadBalancingMode":
            suggest = "load_balancing_mode"
        elif key == "managedPipelineMode":
            suggest = "managed_pipeline_mode"
        elif key == "minimumTlsVersion":
            suggest = "minimum_tls_version"
        elif key == "preWarmedInstanceCount":
            suggest = "pre_warmed_instance_count"
        elif key == "remoteDebuggingEnabled":
            suggest = "remote_debugging_enabled"
        elif key == "remoteDebuggingVersion":
            suggest = "remote_debugging_version"
        elif key == "runtimeScaleMonitoringEnabled":
            suggest = "runtime_scale_monitoring_enabled"
        elif key == "scmIpRestrictions":
            suggest = "scm_ip_restrictions"
        elif key == "scmMinimumTlsVersion":
            suggest = "scm_minimum_tls_version"
        elif key == "scmType":
            suggest = "scm_type"
        elif key == "scmUseMainIpRestriction":
            suggest = "scm_use_main_ip_restriction"
        elif key == "use32BitWorker":
            suggest = "use32_bit_worker"
        elif key == "vnetRouteAllEnabled":
            suggest = "vnet_route_all_enabled"
        elif key == "websocketsEnabled":
            suggest = "websockets_enabled"
        elif key == "windowsFxVersion":
            suggest = "windows_fx_version"
        elif key == "workerCount":
            suggest = "worker_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSiteConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSiteConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSiteConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 always_on: Optional[bool] = None,
                 api_definition_url: Optional[str] = None,
                 api_management_api_id: Optional[str] = None,
                 app_command_line: Optional[str] = None,
                 app_scale_limit: Optional[int] = None,
                 app_service_logs: Optional['outputs.WindowsFunctionAppSiteConfigAppServiceLogs'] = None,
                 application_insights_connection_string: Optional[str] = None,
                 application_insights_key: Optional[str] = None,
                 application_stack: Optional['outputs.WindowsFunctionAppSiteConfigApplicationStack'] = None,
                 cors: Optional['outputs.WindowsFunctionAppSiteConfigCors'] = None,
                 default_documents: Optional[Sequence[str]] = None,
                 detailed_error_logging_enabled: Optional[bool] = None,
                 elastic_instance_minimum: Optional[int] = None,
                 ftps_state: Optional[str] = None,
                 health_check_eviction_time_in_min: Optional[int] = None,
                 health_check_path: Optional[str] = None,
                 http2_enabled: Optional[bool] = None,
                 ip_restrictions: Optional[Sequence['outputs.WindowsFunctionAppSiteConfigIpRestriction']] = None,
                 load_balancing_mode: Optional[str] = None,
                 managed_pipeline_mode: Optional[str] = None,
                 minimum_tls_version: Optional[str] = None,
                 pre_warmed_instance_count: Optional[int] = None,
                 remote_debugging_enabled: Optional[bool] = None,
                 remote_debugging_version: Optional[str] = None,
                 runtime_scale_monitoring_enabled: Optional[bool] = None,
                 scm_ip_restrictions: Optional[Sequence['outputs.WindowsFunctionAppSiteConfigScmIpRestriction']] = None,
                 scm_minimum_tls_version: Optional[str] = None,
                 scm_type: Optional[str] = None,
                 scm_use_main_ip_restriction: Optional[bool] = None,
                 use32_bit_worker: Optional[bool] = None,
                 vnet_route_all_enabled: Optional[bool] = None,
                 websockets_enabled: Optional[bool] = None,
                 windows_fx_version: Optional[str] = None,
                 worker_count: Optional[int] = None):
        """
        :param bool always_on: If this Windows Function App is Always On enabled. Defaults to `false`.
        :param str api_definition_url: The URL of the API definition that describes this Windows Function App.
        :param str api_management_api_id: The ID of the API Management API for this Windows Function App.
        :param str app_command_line: The App command line to launch.
        :param int app_scale_limit: The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
        :param 'WindowsFunctionAppSiteConfigAppServiceLogsArgs' app_service_logs: An `app_service_logs` block as defined above.
        :param str application_insights_connection_string: The Connection String for linking the Windows Function App to Application Insights.
        :param str application_insights_key: The Instrumentation Key for connecting the Windows Function App to Application Insights.
        :param 'WindowsFunctionAppSiteConfigApplicationStackArgs' application_stack: An `application_stack` block as defined above.
        :param 'WindowsFunctionAppSiteConfigCorsArgs' cors: A `cors` block as defined above.
        :param Sequence[str] default_documents: Specifies a list of Default Documents for the Windows Function App.
        :param int elastic_instance_minimum: The number of minimum instances for this Windows Function App. Only affects apps on Elastic Premium plans.
        :param str ftps_state: State of FTP / FTPS service for this Windows Function App. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`. Defaults to `Disabled`.
        :param int health_check_eviction_time_in_min: The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        :param str health_check_path: The path to be checked for this Windows Function App health.
        :param bool http2_enabled: Specifies if the HTTP2 protocol should be enabled. Defaults to `false`.
        :param Sequence['WindowsFunctionAppSiteConfigIpRestrictionArgs'] ip_restrictions: One or more `ip_restriction` blocks as defined above.
        :param str load_balancing_mode: The Site load balancing mode. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        :param str managed_pipeline_mode: Managed pipeline mode. Possible values include: `Integrated`, `Classic`. Defaults to `Integrated`.
        :param str minimum_tls_version: Configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and  `1.2`. Defaults to `1.2`.
        :param int pre_warmed_instance_count: The number of pre-warmed instances for this Windows Function App. Only affects apps on an Elastic Premium plan.
        :param bool remote_debugging_enabled: Should Remote Debugging be enabled. Defaults to `false`.
        :param str remote_debugging_version: The Remote Debugging Version. Possible values include `VS2017`, `VS2019`, and `VS2022`.
        :param bool runtime_scale_monitoring_enabled: Should Scale Monitoring of the Functions Runtime be enabled?
        :param Sequence['WindowsFunctionAppSiteConfigScmIpRestrictionArgs'] scm_ip_restrictions: One or more `scm_ip_restriction` blocks as defined above.
        :param str scm_minimum_tls_version: Configures the minimum version of TLS required for SSL requests to the SCM site. Possible values include: `1.0`, `1.1`, and  `1.2`. Defaults to `1.2`.
        :param bool scm_use_main_ip_restriction: Should the Windows Function App `ip_restriction` configuration be used for the SCM also.
        :param bool use32_bit_worker: Should the Windows Function App use a 32-bit worker process. Defaults to `true`.
        :param bool vnet_route_all_enabled: Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        :param bool websockets_enabled: Should Web Sockets be enabled. Defaults to `false`.
        :param int worker_count: The number of Workers for this Windows Function App.
        """
        if always_on is not None:
            pulumi.set(__self__, "always_on", always_on)
        if api_definition_url is not None:
            pulumi.set(__self__, "api_definition_url", api_definition_url)
        if api_management_api_id is not None:
            pulumi.set(__self__, "api_management_api_id", api_management_api_id)
        if app_command_line is not None:
            pulumi.set(__self__, "app_command_line", app_command_line)
        if app_scale_limit is not None:
            pulumi.set(__self__, "app_scale_limit", app_scale_limit)
        if app_service_logs is not None:
            pulumi.set(__self__, "app_service_logs", app_service_logs)
        if application_insights_connection_string is not None:
            pulumi.set(__self__, "application_insights_connection_string", application_insights_connection_string)
        if application_insights_key is not None:
            pulumi.set(__self__, "application_insights_key", application_insights_key)
        if application_stack is not None:
            pulumi.set(__self__, "application_stack", application_stack)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if default_documents is not None:
            pulumi.set(__self__, "default_documents", default_documents)
        if detailed_error_logging_enabled is not None:
            pulumi.set(__self__, "detailed_error_logging_enabled", detailed_error_logging_enabled)
        if elastic_instance_minimum is not None:
            pulumi.set(__self__, "elastic_instance_minimum", elastic_instance_minimum)
        if ftps_state is not None:
            pulumi.set(__self__, "ftps_state", ftps_state)
        if health_check_eviction_time_in_min is not None:
            pulumi.set(__self__, "health_check_eviction_time_in_min", health_check_eviction_time_in_min)
        if health_check_path is not None:
            pulumi.set(__self__, "health_check_path", health_check_path)
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if ip_restrictions is not None:
            pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        if load_balancing_mode is not None:
            pulumi.set(__self__, "load_balancing_mode", load_balancing_mode)
        if managed_pipeline_mode is not None:
            pulumi.set(__self__, "managed_pipeline_mode", managed_pipeline_mode)
        if minimum_tls_version is not None:
            pulumi.set(__self__, "minimum_tls_version", minimum_tls_version)
        if pre_warmed_instance_count is not None:
            pulumi.set(__self__, "pre_warmed_instance_count", pre_warmed_instance_count)
        if remote_debugging_enabled is not None:
            pulumi.set(__self__, "remote_debugging_enabled", remote_debugging_enabled)
        if remote_debugging_version is not None:
            pulumi.set(__self__, "remote_debugging_version", remote_debugging_version)
        if runtime_scale_monitoring_enabled is not None:
            pulumi.set(__self__, "runtime_scale_monitoring_enabled", runtime_scale_monitoring_enabled)
        if scm_ip_restrictions is not None:
            pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        if scm_minimum_tls_version is not None:
            pulumi.set(__self__, "scm_minimum_tls_version", scm_minimum_tls_version)
        if scm_type is not None:
            pulumi.set(__self__, "scm_type", scm_type)
        if scm_use_main_ip_restriction is not None:
            pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        if use32_bit_worker is not None:
            pulumi.set(__self__, "use32_bit_worker", use32_bit_worker)
        if vnet_route_all_enabled is not None:
            pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        if websockets_enabled is not None:
            pulumi.set(__self__, "websockets_enabled", websockets_enabled)
        if windows_fx_version is not None:
            pulumi.set(__self__, "windows_fx_version", windows_fx_version)
        if worker_count is not None:
            pulumi.set(__self__, "worker_count", worker_count)

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> Optional[bool]:
        """
        If this Windows Function App is Always On enabled. Defaults to `false`.
        """
        return pulumi.get(self, "always_on")

    @property
    @pulumi.getter(name="apiDefinitionUrl")
    def api_definition_url(self) -> Optional[str]:
        """
        The URL of the API definition that describes this Windows Function App.
        """
        return pulumi.get(self, "api_definition_url")

    @property
    @pulumi.getter(name="apiManagementApiId")
    def api_management_api_id(self) -> Optional[str]:
        """
        The ID of the API Management API for this Windows Function App.
        """
        return pulumi.get(self, "api_management_api_id")

    @property
    @pulumi.getter(name="appCommandLine")
    def app_command_line(self) -> Optional[str]:
        """
        The App command line to launch.
        """
        return pulumi.get(self, "app_command_line")

    @property
    @pulumi.getter(name="appScaleLimit")
    def app_scale_limit(self) -> Optional[int]:
        """
        The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
        """
        return pulumi.get(self, "app_scale_limit")

    @property
    @pulumi.getter(name="appServiceLogs")
    def app_service_logs(self) -> Optional['outputs.WindowsFunctionAppSiteConfigAppServiceLogs']:
        """
        An `app_service_logs` block as defined above.
        """
        return pulumi.get(self, "app_service_logs")

    @property
    @pulumi.getter(name="applicationInsightsConnectionString")
    def application_insights_connection_string(self) -> Optional[str]:
        """
        The Connection String for linking the Windows Function App to Application Insights.
        """
        return pulumi.get(self, "application_insights_connection_string")

    @property
    @pulumi.getter(name="applicationInsightsKey")
    def application_insights_key(self) -> Optional[str]:
        """
        The Instrumentation Key for connecting the Windows Function App to Application Insights.
        """
        return pulumi.get(self, "application_insights_key")

    @property
    @pulumi.getter(name="applicationStack")
    def application_stack(self) -> Optional['outputs.WindowsFunctionAppSiteConfigApplicationStack']:
        """
        An `application_stack` block as defined above.
        """
        return pulumi.get(self, "application_stack")

    @property
    @pulumi.getter
    def cors(self) -> Optional['outputs.WindowsFunctionAppSiteConfigCors']:
        """
        A `cors` block as defined above.
        """
        return pulumi.get(self, "cors")

    @property
    @pulumi.getter(name="defaultDocuments")
    def default_documents(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Default Documents for the Windows Function App.
        """
        return pulumi.get(self, "default_documents")

    @property
    @pulumi.getter(name="detailedErrorLoggingEnabled")
    def detailed_error_logging_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "detailed_error_logging_enabled")

    @property
    @pulumi.getter(name="elasticInstanceMinimum")
    def elastic_instance_minimum(self) -> Optional[int]:
        """
        The number of minimum instances for this Windows Function App. Only affects apps on Elastic Premium plans.
        """
        return pulumi.get(self, "elastic_instance_minimum")

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> Optional[str]:
        """
        State of FTP / FTPS service for this Windows Function App. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`. Defaults to `Disabled`.
        """
        return pulumi.get(self, "ftps_state")

    @property
    @pulumi.getter(name="healthCheckEvictionTimeInMin")
    def health_check_eviction_time_in_min(self) -> Optional[int]:
        """
        The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        """
        return pulumi.get(self, "health_check_eviction_time_in_min")

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> Optional[str]:
        """
        The path to be checked for this Windows Function App health.
        """
        return pulumi.get(self, "health_check_path")

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[bool]:
        """
        Specifies if the HTTP2 protocol should be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "http2_enabled")

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Optional[Sequence['outputs.WindowsFunctionAppSiteConfigIpRestriction']]:
        """
        One or more `ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "ip_restrictions")

    @property
    @pulumi.getter(name="loadBalancingMode")
    def load_balancing_mode(self) -> Optional[str]:
        """
        The Site load balancing mode. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        """
        return pulumi.get(self, "load_balancing_mode")

    @property
    @pulumi.getter(name="managedPipelineMode")
    def managed_pipeline_mode(self) -> Optional[str]:
        """
        Managed pipeline mode. Possible values include: `Integrated`, `Classic`. Defaults to `Integrated`.
        """
        return pulumi.get(self, "managed_pipeline_mode")

    @property
    @pulumi.getter(name="minimumTlsVersion")
    def minimum_tls_version(self) -> Optional[str]:
        """
        Configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and  `1.2`. Defaults to `1.2`.
        """
        return pulumi.get(self, "minimum_tls_version")

    @property
    @pulumi.getter(name="preWarmedInstanceCount")
    def pre_warmed_instance_count(self) -> Optional[int]:
        """
        The number of pre-warmed instances for this Windows Function App. Only affects apps on an Elastic Premium plan.
        """
        return pulumi.get(self, "pre_warmed_instance_count")

    @property
    @pulumi.getter(name="remoteDebuggingEnabled")
    def remote_debugging_enabled(self) -> Optional[bool]:
        """
        Should Remote Debugging be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "remote_debugging_enabled")

    @property
    @pulumi.getter(name="remoteDebuggingVersion")
    def remote_debugging_version(self) -> Optional[str]:
        """
        The Remote Debugging Version. Possible values include `VS2017`, `VS2019`, and `VS2022`.
        """
        return pulumi.get(self, "remote_debugging_version")

    @property
    @pulumi.getter(name="runtimeScaleMonitoringEnabled")
    def runtime_scale_monitoring_enabled(self) -> Optional[bool]:
        """
        Should Scale Monitoring of the Functions Runtime be enabled?
        """
        return pulumi.get(self, "runtime_scale_monitoring_enabled")

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Optional[Sequence['outputs.WindowsFunctionAppSiteConfigScmIpRestriction']]:
        """
        One or more `scm_ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "scm_ip_restrictions")

    @property
    @pulumi.getter(name="scmMinimumTlsVersion")
    def scm_minimum_tls_version(self) -> Optional[str]:
        """
        Configures the minimum version of TLS required for SSL requests to the SCM site. Possible values include: `1.0`, `1.1`, and  `1.2`. Defaults to `1.2`.
        """
        return pulumi.get(self, "scm_minimum_tls_version")

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> Optional[str]:
        return pulumi.get(self, "scm_type")

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> Optional[bool]:
        """
        Should the Windows Function App `ip_restriction` configuration be used for the SCM also.
        """
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @property
    @pulumi.getter(name="use32BitWorker")
    def use32_bit_worker(self) -> Optional[bool]:
        """
        Should the Windows Function App use a 32-bit worker process. Defaults to `true`.
        """
        return pulumi.get(self, "use32_bit_worker")

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> Optional[bool]:
        """
        Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        """
        return pulumi.get(self, "vnet_route_all_enabled")

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> Optional[bool]:
        """
        Should Web Sockets be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "websockets_enabled")

    @property
    @pulumi.getter(name="windowsFxVersion")
    def windows_fx_version(self) -> Optional[str]:
        return pulumi.get(self, "windows_fx_version")

    @property
    @pulumi.getter(name="workerCount")
    def worker_count(self) -> Optional[int]:
        """
        The number of Workers for this Windows Function App.
        """
        return pulumi.get(self, "worker_count")


@pulumi.output_type
class WindowsFunctionAppSiteConfigAppServiceLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskQuotaMb":
            suggest = "disk_quota_mb"
        elif key == "retentionPeriodDays":
            suggest = "retention_period_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSiteConfigAppServiceLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSiteConfigAppServiceLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSiteConfigAppServiceLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_quota_mb: Optional[int] = None,
                 retention_period_days: Optional[int] = None):
        """
        :param int disk_quota_mb: The amount of disk space to use for logs. Valid values are between `25` and `100`.
        :param int retention_period_days: The retention period for logs in days. Valid values are between `0` and `99999`. Defaults to `0` (never delete).
        """
        if disk_quota_mb is not None:
            pulumi.set(__self__, "disk_quota_mb", disk_quota_mb)
        if retention_period_days is not None:
            pulumi.set(__self__, "retention_period_days", retention_period_days)

    @property
    @pulumi.getter(name="diskQuotaMb")
    def disk_quota_mb(self) -> Optional[int]:
        """
        The amount of disk space to use for logs. Valid values are between `25` and `100`.
        """
        return pulumi.get(self, "disk_quota_mb")

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> Optional[int]:
        """
        The retention period for logs in days. Valid values are between `0` and `99999`. Defaults to `0` (never delete).
        """
        return pulumi.get(self, "retention_period_days")


@pulumi.output_type
class WindowsFunctionAppSiteConfigApplicationStack(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dotnetVersion":
            suggest = "dotnet_version"
        elif key == "javaVersion":
            suggest = "java_version"
        elif key == "nodeVersion":
            suggest = "node_version"
        elif key == "powershellCoreVersion":
            suggest = "powershell_core_version"
        elif key == "useCustomRuntime":
            suggest = "use_custom_runtime"
        elif key == "useDotnetIsolatedRuntime":
            suggest = "use_dotnet_isolated_runtime"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSiteConfigApplicationStack. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSiteConfigApplicationStack.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSiteConfigApplicationStack.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dotnet_version: Optional[str] = None,
                 java_version: Optional[str] = None,
                 node_version: Optional[str] = None,
                 powershell_core_version: Optional[str] = None,
                 use_custom_runtime: Optional[bool] = None,
                 use_dotnet_isolated_runtime: Optional[bool] = None):
        """
        :param str dotnet_version: The version of .NET to use. Possible values include `3.1`, `6` and `7`.
        :param str java_version: The Version of Java to use. Supported versions include `8`, `11` & `17` (In-Preview).
        :param str node_version: The version of Node to run. Possible values include `~12`, `~14`, `~16` and `~18`.
        :param str powershell_core_version: The version of PowerShell Core to run. Possible values are `7`, and `7.2`.
        :param bool use_custom_runtime: Should the Windows Function App use a custom runtime?
        :param bool use_dotnet_isolated_runtime: Should the DotNet process use an isolated runtime. Defaults to `false`.
        """
        if dotnet_version is not None:
            pulumi.set(__self__, "dotnet_version", dotnet_version)
        if java_version is not None:
            pulumi.set(__self__, "java_version", java_version)
        if node_version is not None:
            pulumi.set(__self__, "node_version", node_version)
        if powershell_core_version is not None:
            pulumi.set(__self__, "powershell_core_version", powershell_core_version)
        if use_custom_runtime is not None:
            pulumi.set(__self__, "use_custom_runtime", use_custom_runtime)
        if use_dotnet_isolated_runtime is not None:
            pulumi.set(__self__, "use_dotnet_isolated_runtime", use_dotnet_isolated_runtime)

    @property
    @pulumi.getter(name="dotnetVersion")
    def dotnet_version(self) -> Optional[str]:
        """
        The version of .NET to use. Possible values include `3.1`, `6` and `7`.
        """
        return pulumi.get(self, "dotnet_version")

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> Optional[str]:
        """
        The Version of Java to use. Supported versions include `8`, `11` & `17` (In-Preview).
        """
        return pulumi.get(self, "java_version")

    @property
    @pulumi.getter(name="nodeVersion")
    def node_version(self) -> Optional[str]:
        """
        The version of Node to run. Possible values include `~12`, `~14`, `~16` and `~18`.
        """
        return pulumi.get(self, "node_version")

    @property
    @pulumi.getter(name="powershellCoreVersion")
    def powershell_core_version(self) -> Optional[str]:
        """
        The version of PowerShell Core to run. Possible values are `7`, and `7.2`.
        """
        return pulumi.get(self, "powershell_core_version")

    @property
    @pulumi.getter(name="useCustomRuntime")
    def use_custom_runtime(self) -> Optional[bool]:
        """
        Should the Windows Function App use a custom runtime?
        """
        return pulumi.get(self, "use_custom_runtime")

    @property
    @pulumi.getter(name="useDotnetIsolatedRuntime")
    def use_dotnet_isolated_runtime(self) -> Optional[bool]:
        """
        Should the DotNet process use an isolated runtime. Defaults to `false`.
        """
        return pulumi.get(self, "use_dotnet_isolated_runtime")


@pulumi.output_type
class WindowsFunctionAppSiteConfigCors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedOrigins":
            suggest = "allowed_origins"
        elif key == "supportCredentials":
            suggest = "support_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSiteConfigCors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSiteConfigCors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSiteConfigCors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_origins: Sequence[str],
                 support_credentials: Optional[bool] = None):
        """
        :param Sequence[str] allowed_origins: Specifies a list of origins that should be allowed to make cross-origin calls.
        :param bool support_credentials: Are credentials allowed in CORS requests? Defaults to `false`.
        """
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        if support_credentials is not None:
            pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Sequence[str]:
        """
        Specifies a list of origins that should be allowed to make cross-origin calls.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> Optional[bool]:
        """
        Are credentials allowed in CORS requests? Defaults to `false`.
        """
        return pulumi.get(self, "support_credentials")


@pulumi.output_type
class WindowsFunctionAppSiteConfigIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSiteConfigIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSiteConfigIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSiteConfigIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.WindowsFunctionAppSiteConfigIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: The action to take. Possible values are `Allow` or `Deny`.
        :param 'WindowsFunctionAppSiteConfigIpRestrictionHeadersArgs' headers: A `headers` block as defined above.
        :param str ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param str name: The name which should be used for this `ip_restriction`.
        :param int priority: The priority value of this `ip_restriction`.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        The action to take. Possible values are `Allow` or `Deny`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.WindowsFunctionAppSiteConfigIpRestrictionHeaders']:
        """
        A `headers` block as defined above.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority value of this `ip_restriction`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class WindowsFunctionAppSiteConfigIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSiteConfigIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param str x_fd_health_probe: Specifies if a Front Door Health Probe should be expected.
        :param Sequence[str] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param Sequence[str] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        Specifies if a Front Door Health Probe should be expected.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class WindowsFunctionAppSiteConfigScmIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSiteConfigScmIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSiteConfigScmIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSiteConfigScmIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.WindowsFunctionAppSiteConfigScmIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: The action to take. Possible values are `Allow` or `Deny`.
        :param 'WindowsFunctionAppSiteConfigScmIpRestrictionHeadersArgs' headers: A `headers` block as defined above.
        :param str ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param str name: The name which should be used for this `ip_restriction`.
        :param int priority: The priority value of this `ip_restriction`.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        The action to take. Possible values are `Allow` or `Deny`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.WindowsFunctionAppSiteConfigScmIpRestrictionHeaders']:
        """
        A `headers` block as defined above.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority value of this `ip_restriction`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class WindowsFunctionAppSiteConfigScmIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSiteConfigScmIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param str x_fd_health_probe: Specifies if a Front Door Health Probe should be expected.
        :param Sequence[str] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param Sequence[str] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        Specifies if a Front Door Health Probe should be expected.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class WindowsFunctionAppSiteCredential(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 password: Optional[str] = None):
        """
        :param str name: The name which should be used for this Windows Function App. Changing this forces a new Windows Function App to be created. Limit the function name to 32 characters to avoid naming collisions. For more information about [Function App naming rule](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/resource-name-rules#microsoftweb) and [Host ID Collisions](https://github.com/Azure/azure-functions-host/wiki/Host-IDs#host-id-collisions)
        :param str password: The Site Credentials Password used for publishing.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name which should be used for this Windows Function App. Changing this forces a new Windows Function App to be created. Limit the function name to 32 characters to avoid naming collisions. For more information about [Function App naming rule](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/resource-name-rules#microsoftweb) and [Host ID Collisions](https://github.com/Azure/azure-functions-host/wiki/Host-IDs#host-id-collisions)
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The Site Credentials Password used for publishing.
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class WindowsFunctionAppSlotAuthSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeDirectory":
            suggest = "active_directory"
        elif key == "additionalLoginParameters":
            suggest = "additional_login_parameters"
        elif key == "allowedExternalRedirectUrls":
            suggest = "allowed_external_redirect_urls"
        elif key == "defaultProvider":
            suggest = "default_provider"
        elif key == "runtimeVersion":
            suggest = "runtime_version"
        elif key == "tokenRefreshExtensionHours":
            suggest = "token_refresh_extension_hours"
        elif key == "tokenStoreEnabled":
            suggest = "token_store_enabled"
        elif key == "unauthenticatedClientAction":
            suggest = "unauthenticated_client_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotAuthSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotAuthSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotAuthSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 active_directory: Optional['outputs.WindowsFunctionAppSlotAuthSettingsActiveDirectory'] = None,
                 additional_login_parameters: Optional[Mapping[str, str]] = None,
                 allowed_external_redirect_urls: Optional[Sequence[str]] = None,
                 default_provider: Optional[str] = None,
                 facebook: Optional['outputs.WindowsFunctionAppSlotAuthSettingsFacebook'] = None,
                 github: Optional['outputs.WindowsFunctionAppSlotAuthSettingsGithub'] = None,
                 google: Optional['outputs.WindowsFunctionAppSlotAuthSettingsGoogle'] = None,
                 issuer: Optional[str] = None,
                 microsoft: Optional['outputs.WindowsFunctionAppSlotAuthSettingsMicrosoft'] = None,
                 runtime_version: Optional[str] = None,
                 token_refresh_extension_hours: Optional[float] = None,
                 token_store_enabled: Optional[bool] = None,
                 twitter: Optional['outputs.WindowsFunctionAppSlotAuthSettingsTwitter'] = None,
                 unauthenticated_client_action: Optional[str] = None):
        """
        :param bool enabled: Should the Authentication / Authorization feature be enabled?
        :param 'WindowsFunctionAppSlotAuthSettingsActiveDirectoryArgs' active_directory: an `active_directory` block as detailed below.
        :param Mapping[str, str] additional_login_parameters: Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        :param Sequence[str] allowed_external_redirect_urls: an `allowed_external_redirect_urls` block as detailed below.
        :param str default_provider: The default authentication provider to use when multiple providers are configured. Possible values include: `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount`, `Twitter`, `Github`.
        :param 'WindowsFunctionAppSlotAuthSettingsFacebookArgs' facebook: a `facebook` block as detailed below.
        :param 'WindowsFunctionAppSlotAuthSettingsGithubArgs' github: a `github` block as detailed below.
        :param 'WindowsFunctionAppSlotAuthSettingsGoogleArgs' google: a `google` block as detailed below.
        :param str issuer: The OpenID Connect Issuer URI that represents the entity which issues access tokens.
        :param 'WindowsFunctionAppSlotAuthSettingsMicrosoftArgs' microsoft: a `microsoft` block as detailed below.
        :param str runtime_version: The RuntimeVersion of the Authentication / Authorization feature in use.
        :param float token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        :param bool token_store_enabled: Should the Windows Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        :param 'WindowsFunctionAppSlotAuthSettingsTwitterArgs' twitter: a `twitter` block as detailed below.
        :param str unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if active_directory is not None:
            pulumi.set(__self__, "active_directory", active_directory)
        if additional_login_parameters is not None:
            pulumi.set(__self__, "additional_login_parameters", additional_login_parameters)
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if facebook is not None:
            pulumi.set(__self__, "facebook", facebook)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if google is not None:
            pulumi.set(__self__, "google", google)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if microsoft is not None:
            pulumi.set(__self__, "microsoft", microsoft)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if token_refresh_extension_hours is not None:
            pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if twitter is not None:
            pulumi.set(__self__, "twitter", twitter)
        if unauthenticated_client_action is not None:
            pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Should the Authentication / Authorization feature be enabled?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="activeDirectory")
    def active_directory(self) -> Optional['outputs.WindowsFunctionAppSlotAuthSettingsActiveDirectory']:
        """
        an `active_directory` block as detailed below.
        """
        return pulumi.get(self, "active_directory")

    @property
    @pulumi.getter(name="additionalLoginParameters")
    def additional_login_parameters(self) -> Optional[Mapping[str, str]]:
        """
        Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        """
        return pulumi.get(self, "additional_login_parameters")

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[Sequence[str]]:
        """
        an `allowed_external_redirect_urls` block as detailed below.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[str]:
        """
        The default authentication provider to use when multiple providers are configured. Possible values include: `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount`, `Twitter`, `Github`.
        """
        return pulumi.get(self, "default_provider")

    @property
    @pulumi.getter
    def facebook(self) -> Optional['outputs.WindowsFunctionAppSlotAuthSettingsFacebook']:
        """
        a `facebook` block as detailed below.
        """
        return pulumi.get(self, "facebook")

    @property
    @pulumi.getter
    def github(self) -> Optional['outputs.WindowsFunctionAppSlotAuthSettingsGithub']:
        """
        a `github` block as detailed below.
        """
        return pulumi.get(self, "github")

    @property
    @pulumi.getter
    def google(self) -> Optional['outputs.WindowsFunctionAppSlotAuthSettingsGoogle']:
        """
        a `google` block as detailed below.
        """
        return pulumi.get(self, "google")

    @property
    @pulumi.getter
    def issuer(self) -> Optional[str]:
        """
        The OpenID Connect Issuer URI that represents the entity which issues access tokens.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def microsoft(self) -> Optional['outputs.WindowsFunctionAppSlotAuthSettingsMicrosoft']:
        """
        a `microsoft` block as detailed below.
        """
        return pulumi.get(self, "microsoft")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[str]:
        """
        The RuntimeVersion of the Authentication / Authorization feature in use.
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> Optional[float]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        return pulumi.get(self, "token_refresh_extension_hours")

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[bool]:
        """
        Should the Windows Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        """
        return pulumi.get(self, "token_store_enabled")

    @property
    @pulumi.getter
    def twitter(self) -> Optional['outputs.WindowsFunctionAppSlotAuthSettingsTwitter']:
        """
        a `twitter` block as detailed below.
        """
        return pulumi.get(self, "twitter")

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> Optional[str]:
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        return pulumi.get(self, "unauthenticated_client_action")


@pulumi.output_type
class WindowsFunctionAppSlotAuthSettingsActiveDirectory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotAuthSettingsActiveDirectory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotAuthSettingsActiveDirectory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotAuthSettingsActiveDirectory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param Sequence[str] allowed_audiences: an `allowed_audiences` block as detailed below.
        :param str client_secret: The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        pulumi.set(__self__, "client_id", client_id)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        an `allowed_audiences` block as detailed below.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")


@pulumi.output_type
class WindowsFunctionAppSlotAuthSettingsFacebook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "appSecret":
            suggest = "app_secret"
        elif key == "appSecretSettingName":
            suggest = "app_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotAuthSettingsFacebook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotAuthSettingsFacebook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotAuthSettingsFacebook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: str,
                 app_secret: Optional[str] = None,
                 app_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str app_id: The App ID of the Facebook app used for login.
        :param str app_secret: The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        :param str app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        :param Sequence[str] oauth_scopes: an `oauth_scopes` block as detailed below.
        """
        pulumi.set(__self__, "app_id", app_id)
        if app_secret is not None:
            pulumi.set(__self__, "app_secret", app_secret)
        if app_secret_setting_name is not None:
            pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appSecret")
    def app_secret(self) -> Optional[str]:
        """
        The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        """
        return pulumi.get(self, "app_secret")

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        an `oauth_scopes` block as detailed below.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class WindowsFunctionAppSlotAuthSettingsGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotAuthSettingsGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotAuthSettingsGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotAuthSettingsGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the GitHub app used for login.
        :param str client_secret: The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: an `oauth_scopes` block as detailed below.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the GitHub app used for login.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        an `oauth_scopes` block as detailed below.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class WindowsFunctionAppSlotAuthSettingsGoogle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotAuthSettingsGoogle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotAuthSettingsGoogle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotAuthSettingsGoogle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OpenID Connect Client ID for the Google web application.
        :param str client_secret: The client secret associated with the Google web application.  Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: an `oauth_scopes` block as detailed below.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OpenID Connect Client ID for the Google web application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The client secret associated with the Google web application.  Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        an `oauth_scopes` block as detailed below.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class WindowsFunctionAppSlotAuthSettingsMicrosoft(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotAuthSettingsMicrosoft. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotAuthSettingsMicrosoft.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotAuthSettingsMicrosoft.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret: The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, `wl.basic` is used as the default scope.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, `wl.basic` is used as the default scope.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class WindowsFunctionAppSlotAuthSettingsTwitter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerKey":
            suggest = "consumer_key"
        elif key == "consumerSecret":
            suggest = "consumer_secret"
        elif key == "consumerSecretSettingName":
            suggest = "consumer_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotAuthSettingsTwitter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotAuthSettingsTwitter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotAuthSettingsTwitter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_key: str,
                 consumer_secret: Optional[str] = None,
                 consumer_secret_setting_name: Optional[str] = None):
        """
        :param str consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param str consumer_secret: The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        :param str consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        if consumer_secret is not None:
            pulumi.set(__self__, "consumer_secret", consumer_secret)
        if consumer_secret_setting_name is not None:
            pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> str:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> Optional[str]:
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        """
        return pulumi.get(self, "consumer_secret")

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        return pulumi.get(self, "consumer_secret_setting_name")


@pulumi.output_type
class WindowsFunctionAppSlotBackup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageAccountUrl":
            suggest = "storage_account_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotBackup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotBackup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotBackup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 schedule: 'outputs.WindowsFunctionAppSlotBackupSchedule',
                 storage_account_url: str,
                 enabled: Optional[bool] = None):
        """
        :param str name: The name which should be used for this Backup.
        :param 'WindowsFunctionAppSlotBackupScheduleArgs' schedule: a `schedule` block as detailed below.
        :param str storage_account_url: The SAS URL to the container.
        :param bool enabled: Should this backup job be enabled?
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "storage_account_url", storage_account_url)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Backup.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def schedule(self) -> 'outputs.WindowsFunctionAppSlotBackupSchedule':
        """
        a `schedule` block as detailed below.
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter(name="storageAccountUrl")
    def storage_account_url(self) -> str:
        """
        The SAS URL to the container.
        """
        return pulumi.get(self, "storage_account_url")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Should this backup job be enabled?
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class WindowsFunctionAppSlotBackupSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "frequencyUnit":
            suggest = "frequency_unit"
        elif key == "keepAtLeastOneBackup":
            suggest = "keep_at_least_one_backup"
        elif key == "lastExecutionTime":
            suggest = "last_execution_time"
        elif key == "retentionPeriodDays":
            suggest = "retention_period_days"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotBackupSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotBackupSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotBackupSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_unit: str,
                 keep_at_least_one_backup: Optional[bool] = None,
                 last_execution_time: Optional[str] = None,
                 retention_period_days: Optional[int] = None,
                 start_time: Optional[str] = None):
        """
        :param int frequency_interval: How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).
        :param str frequency_unit: The unit of time for how often the backup should take place. Possible values include: `Day` and `Hour`.
        :param bool keep_at_least_one_backup: Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
        :param str last_execution_time: The time the backup was last attempted.
        :param int retention_period_days: After how many days backups should be deleted.
        :param str start_time: When the schedule should start working in RFC-3339 format.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_unit", frequency_unit)
        if keep_at_least_one_backup is not None:
            pulumi.set(__self__, "keep_at_least_one_backup", keep_at_least_one_backup)
        if last_execution_time is not None:
            pulumi.set(__self__, "last_execution_time", last_execution_time)
        if retention_period_days is not None:
            pulumi.set(__self__, "retention_period_days", retention_period_days)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyUnit")
    def frequency_unit(self) -> str:
        """
        The unit of time for how often the backup should take place. Possible values include: `Day` and `Hour`.
        """
        return pulumi.get(self, "frequency_unit")

    @property
    @pulumi.getter(name="keepAtLeastOneBackup")
    def keep_at_least_one_backup(self) -> Optional[bool]:
        """
        Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
        """
        return pulumi.get(self, "keep_at_least_one_backup")

    @property
    @pulumi.getter(name="lastExecutionTime")
    def last_execution_time(self) -> Optional[str]:
        """
        The time the backup was last attempted.
        """
        return pulumi.get(self, "last_execution_time")

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> Optional[int]:
        """
        After how many days backups should be deleted.
        """
        return pulumi.get(self, "retention_period_days")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        """
        When the schedule should start working in RFC-3339 format.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class WindowsFunctionAppSlotConnectionString(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: The name which should be used for this Connection.
        :param str type: Type of database. Possible values include: `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
        :param str value: The connection string value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Connection.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of database. Possible values include: `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The connection string value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class WindowsFunctionAppSlotIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 identity_ids: Optional[Sequence[str]] = None,
                 principal_id: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str type: Specifies the type of Managed Service Identity that should be configured on this Windows Function App Slot. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        :param Sequence[str] identity_ids: A list of User Assigned Managed Identity IDs to be assigned to this Windows Function App Slot.
        :param str principal_id: The Principal ID associated with this Managed Service Identity.
        :param str tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the type of Managed Service Identity that should be configured on this Windows Function App Slot. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[str]]:
        """
        A list of User Assigned Managed Identity IDs to be assigned to this Windows Function App Slot.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class WindowsFunctionAppSlotSiteConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alwaysOn":
            suggest = "always_on"
        elif key == "apiDefinitionUrl":
            suggest = "api_definition_url"
        elif key == "apiManagementApiId":
            suggest = "api_management_api_id"
        elif key == "appCommandLine":
            suggest = "app_command_line"
        elif key == "appScaleLimit":
            suggest = "app_scale_limit"
        elif key == "appServiceLogs":
            suggest = "app_service_logs"
        elif key == "applicationInsightsConnectionString":
            suggest = "application_insights_connection_string"
        elif key == "applicationInsightsKey":
            suggest = "application_insights_key"
        elif key == "applicationStack":
            suggest = "application_stack"
        elif key == "autoSwapSlotName":
            suggest = "auto_swap_slot_name"
        elif key == "defaultDocuments":
            suggest = "default_documents"
        elif key == "detailedErrorLoggingEnabled":
            suggest = "detailed_error_logging_enabled"
        elif key == "elasticInstanceMinimum":
            suggest = "elastic_instance_minimum"
        elif key == "ftpsState":
            suggest = "ftps_state"
        elif key == "healthCheckEvictionTimeInMin":
            suggest = "health_check_eviction_time_in_min"
        elif key == "healthCheckPath":
            suggest = "health_check_path"
        elif key == "http2Enabled":
            suggest = "http2_enabled"
        elif key == "ipRestrictions":
            suggest = "ip_restrictions"
        elif key == "loadBalancingMode":
            suggest = "load_balancing_mode"
        elif key == "managedPipelineMode":
            suggest = "managed_pipeline_mode"
        elif key == "minimumTlsVersion":
            suggest = "minimum_tls_version"
        elif key == "preWarmedInstanceCount":
            suggest = "pre_warmed_instance_count"
        elif key == "remoteDebuggingEnabled":
            suggest = "remote_debugging_enabled"
        elif key == "remoteDebuggingVersion":
            suggest = "remote_debugging_version"
        elif key == "runtimeScaleMonitoringEnabled":
            suggest = "runtime_scale_monitoring_enabled"
        elif key == "scmIpRestrictions":
            suggest = "scm_ip_restrictions"
        elif key == "scmMinimumTlsVersion":
            suggest = "scm_minimum_tls_version"
        elif key == "scmType":
            suggest = "scm_type"
        elif key == "scmUseMainIpRestriction":
            suggest = "scm_use_main_ip_restriction"
        elif key == "use32BitWorker":
            suggest = "use32_bit_worker"
        elif key == "vnetRouteAllEnabled":
            suggest = "vnet_route_all_enabled"
        elif key == "websocketsEnabled":
            suggest = "websockets_enabled"
        elif key == "windowsFxVersion":
            suggest = "windows_fx_version"
        elif key == "workerCount":
            suggest = "worker_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotSiteConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotSiteConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotSiteConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 always_on: Optional[bool] = None,
                 api_definition_url: Optional[str] = None,
                 api_management_api_id: Optional[str] = None,
                 app_command_line: Optional[str] = None,
                 app_scale_limit: Optional[int] = None,
                 app_service_logs: Optional['outputs.WindowsFunctionAppSlotSiteConfigAppServiceLogs'] = None,
                 application_insights_connection_string: Optional[str] = None,
                 application_insights_key: Optional[str] = None,
                 application_stack: Optional['outputs.WindowsFunctionAppSlotSiteConfigApplicationStack'] = None,
                 auto_swap_slot_name: Optional[str] = None,
                 cors: Optional['outputs.WindowsFunctionAppSlotSiteConfigCors'] = None,
                 default_documents: Optional[Sequence[str]] = None,
                 detailed_error_logging_enabled: Optional[bool] = None,
                 elastic_instance_minimum: Optional[int] = None,
                 ftps_state: Optional[str] = None,
                 health_check_eviction_time_in_min: Optional[int] = None,
                 health_check_path: Optional[str] = None,
                 http2_enabled: Optional[bool] = None,
                 ip_restrictions: Optional[Sequence['outputs.WindowsFunctionAppSlotSiteConfigIpRestriction']] = None,
                 load_balancing_mode: Optional[str] = None,
                 managed_pipeline_mode: Optional[str] = None,
                 minimum_tls_version: Optional[str] = None,
                 pre_warmed_instance_count: Optional[int] = None,
                 remote_debugging_enabled: Optional[bool] = None,
                 remote_debugging_version: Optional[str] = None,
                 runtime_scale_monitoring_enabled: Optional[bool] = None,
                 scm_ip_restrictions: Optional[Sequence['outputs.WindowsFunctionAppSlotSiteConfigScmIpRestriction']] = None,
                 scm_minimum_tls_version: Optional[str] = None,
                 scm_type: Optional[str] = None,
                 scm_use_main_ip_restriction: Optional[bool] = None,
                 use32_bit_worker: Optional[bool] = None,
                 vnet_route_all_enabled: Optional[bool] = None,
                 websockets_enabled: Optional[bool] = None,
                 windows_fx_version: Optional[str] = None,
                 worker_count: Optional[int] = None):
        """
        :param bool always_on: If this Windows Web App is Always On enabled. Defaults to `false`.
        :param str api_definition_url: The URL of the API definition that describes this Windows Function App.
        :param str api_management_api_id: The ID of the API Management API for this Windows Function App.
        :param str app_command_line: The program and any arguments used to launch this app via the command line. (Example `node myapp.js`).
        :param int app_scale_limit: The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
        :param 'WindowsFunctionAppSlotSiteConfigAppServiceLogsArgs' app_service_logs: an `app_service_logs` block as detailed below.
        :param str application_insights_connection_string: The Connection String for linking the Windows Function App to Application Insights.
        :param str application_insights_key: The Instrumentation Key for connecting the Windows Function App to Application Insights.
        :param 'WindowsFunctionAppSlotSiteConfigApplicationStackArgs' application_stack: an `application_stack` block as detailed below.
        :param str auto_swap_slot_name: The name of the slot to automatically swap with when this slot is successfully deployed.
        :param 'WindowsFunctionAppSlotSiteConfigCorsArgs' cors: a `cors` block as detailed below.
        :param Sequence[str] default_documents: a `default_documents` block as detailed below.
        :param bool detailed_error_logging_enabled: Is detailed error logging enabled
        :param int elastic_instance_minimum: The number of minimum instances for this Windows Function App. Only affects apps on Elastic Premium plans.
        :param str ftps_state: State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`. Defaults to `Disabled`.
        :param int health_check_eviction_time_in_min: The amount of time in minutes that a node is unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Defaults to `10`. Only valid in conjunction with `health_check_path`
        :param str health_check_path: The path to be checked for this function app health.
        :param bool http2_enabled: Specifies if the HTTP2 protocol should be enabled. Defaults to `false`.
        :param Sequence['WindowsFunctionAppSlotSiteConfigIpRestrictionArgs'] ip_restrictions: an `ip_restriction` block as detailed below.
        :param str load_balancing_mode: The Site load balancing mode. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        :param str managed_pipeline_mode: The Managed Pipeline mode. Possible values include: `Integrated`, `Classic`. Defaults to `Integrated`.
        :param str minimum_tls_version: The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and  `1.2`. Defaults to `1.2`.
        :param int pre_warmed_instance_count: The number of pre-warmed instances for this function app. Only affects apps on an Elastic Premium plan.
        :param bool remote_debugging_enabled: Should Remote Debugging be enabled. Defaults to `false`.
        :param str remote_debugging_version: The Remote Debugging Version. Possible values include `VS2017`, `VS2019`, and `VS2022`
        :param bool runtime_scale_monitoring_enabled: Should Scale Monitoring of the Functions Runtime be enabled?
        :param Sequence['WindowsFunctionAppSlotSiteConfigScmIpRestrictionArgs'] scm_ip_restrictions: a `scm_ip_restriction` block as detailed below.
        :param str scm_minimum_tls_version: Configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and  `1.2`. Defaults to `1.2`.
        :param str scm_type: The SCM Type in use by the Windows Function App.
        :param bool scm_use_main_ip_restriction: Should the Windows Function App `ip_restriction` configuration be used for the SCM also.
        :param bool use32_bit_worker: Should the Windows Web App use a 32-bit worker.
        :param bool vnet_route_all_enabled: Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        :param bool websockets_enabled: Should Web Sockets be enabled. Defaults to `false`.
        :param str windows_fx_version: The Windows FX Version string.
        :param int worker_count: The number of Workers for this Windows Function App.
        """
        if always_on is not None:
            pulumi.set(__self__, "always_on", always_on)
        if api_definition_url is not None:
            pulumi.set(__self__, "api_definition_url", api_definition_url)
        if api_management_api_id is not None:
            pulumi.set(__self__, "api_management_api_id", api_management_api_id)
        if app_command_line is not None:
            pulumi.set(__self__, "app_command_line", app_command_line)
        if app_scale_limit is not None:
            pulumi.set(__self__, "app_scale_limit", app_scale_limit)
        if app_service_logs is not None:
            pulumi.set(__self__, "app_service_logs", app_service_logs)
        if application_insights_connection_string is not None:
            pulumi.set(__self__, "application_insights_connection_string", application_insights_connection_string)
        if application_insights_key is not None:
            pulumi.set(__self__, "application_insights_key", application_insights_key)
        if application_stack is not None:
            pulumi.set(__self__, "application_stack", application_stack)
        if auto_swap_slot_name is not None:
            pulumi.set(__self__, "auto_swap_slot_name", auto_swap_slot_name)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if default_documents is not None:
            pulumi.set(__self__, "default_documents", default_documents)
        if detailed_error_logging_enabled is not None:
            pulumi.set(__self__, "detailed_error_logging_enabled", detailed_error_logging_enabled)
        if elastic_instance_minimum is not None:
            pulumi.set(__self__, "elastic_instance_minimum", elastic_instance_minimum)
        if ftps_state is not None:
            pulumi.set(__self__, "ftps_state", ftps_state)
        if health_check_eviction_time_in_min is not None:
            pulumi.set(__self__, "health_check_eviction_time_in_min", health_check_eviction_time_in_min)
        if health_check_path is not None:
            pulumi.set(__self__, "health_check_path", health_check_path)
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if ip_restrictions is not None:
            pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        if load_balancing_mode is not None:
            pulumi.set(__self__, "load_balancing_mode", load_balancing_mode)
        if managed_pipeline_mode is not None:
            pulumi.set(__self__, "managed_pipeline_mode", managed_pipeline_mode)
        if minimum_tls_version is not None:
            pulumi.set(__self__, "minimum_tls_version", minimum_tls_version)
        if pre_warmed_instance_count is not None:
            pulumi.set(__self__, "pre_warmed_instance_count", pre_warmed_instance_count)
        if remote_debugging_enabled is not None:
            pulumi.set(__self__, "remote_debugging_enabled", remote_debugging_enabled)
        if remote_debugging_version is not None:
            pulumi.set(__self__, "remote_debugging_version", remote_debugging_version)
        if runtime_scale_monitoring_enabled is not None:
            pulumi.set(__self__, "runtime_scale_monitoring_enabled", runtime_scale_monitoring_enabled)
        if scm_ip_restrictions is not None:
            pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        if scm_minimum_tls_version is not None:
            pulumi.set(__self__, "scm_minimum_tls_version", scm_minimum_tls_version)
        if scm_type is not None:
            pulumi.set(__self__, "scm_type", scm_type)
        if scm_use_main_ip_restriction is not None:
            pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        if use32_bit_worker is not None:
            pulumi.set(__self__, "use32_bit_worker", use32_bit_worker)
        if vnet_route_all_enabled is not None:
            pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        if websockets_enabled is not None:
            pulumi.set(__self__, "websockets_enabled", websockets_enabled)
        if windows_fx_version is not None:
            pulumi.set(__self__, "windows_fx_version", windows_fx_version)
        if worker_count is not None:
            pulumi.set(__self__, "worker_count", worker_count)

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> Optional[bool]:
        """
        If this Windows Web App is Always On enabled. Defaults to `false`.
        """
        return pulumi.get(self, "always_on")

    @property
    @pulumi.getter(name="apiDefinitionUrl")
    def api_definition_url(self) -> Optional[str]:
        """
        The URL of the API definition that describes this Windows Function App.
        """
        return pulumi.get(self, "api_definition_url")

    @property
    @pulumi.getter(name="apiManagementApiId")
    def api_management_api_id(self) -> Optional[str]:
        """
        The ID of the API Management API for this Windows Function App.
        """
        return pulumi.get(self, "api_management_api_id")

    @property
    @pulumi.getter(name="appCommandLine")
    def app_command_line(self) -> Optional[str]:
        """
        The program and any arguments used to launch this app via the command line. (Example `node myapp.js`).
        """
        return pulumi.get(self, "app_command_line")

    @property
    @pulumi.getter(name="appScaleLimit")
    def app_scale_limit(self) -> Optional[int]:
        """
        The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
        """
        return pulumi.get(self, "app_scale_limit")

    @property
    @pulumi.getter(name="appServiceLogs")
    def app_service_logs(self) -> Optional['outputs.WindowsFunctionAppSlotSiteConfigAppServiceLogs']:
        """
        an `app_service_logs` block as detailed below.
        """
        return pulumi.get(self, "app_service_logs")

    @property
    @pulumi.getter(name="applicationInsightsConnectionString")
    def application_insights_connection_string(self) -> Optional[str]:
        """
        The Connection String for linking the Windows Function App to Application Insights.
        """
        return pulumi.get(self, "application_insights_connection_string")

    @property
    @pulumi.getter(name="applicationInsightsKey")
    def application_insights_key(self) -> Optional[str]:
        """
        The Instrumentation Key for connecting the Windows Function App to Application Insights.
        """
        return pulumi.get(self, "application_insights_key")

    @property
    @pulumi.getter(name="applicationStack")
    def application_stack(self) -> Optional['outputs.WindowsFunctionAppSlotSiteConfigApplicationStack']:
        """
        an `application_stack` block as detailed below.
        """
        return pulumi.get(self, "application_stack")

    @property
    @pulumi.getter(name="autoSwapSlotName")
    def auto_swap_slot_name(self) -> Optional[str]:
        """
        The name of the slot to automatically swap with when this slot is successfully deployed.
        """
        return pulumi.get(self, "auto_swap_slot_name")

    @property
    @pulumi.getter
    def cors(self) -> Optional['outputs.WindowsFunctionAppSlotSiteConfigCors']:
        """
        a `cors` block as detailed below.
        """
        return pulumi.get(self, "cors")

    @property
    @pulumi.getter(name="defaultDocuments")
    def default_documents(self) -> Optional[Sequence[str]]:
        """
        a `default_documents` block as detailed below.
        """
        return pulumi.get(self, "default_documents")

    @property
    @pulumi.getter(name="detailedErrorLoggingEnabled")
    def detailed_error_logging_enabled(self) -> Optional[bool]:
        """
        Is detailed error logging enabled
        """
        return pulumi.get(self, "detailed_error_logging_enabled")

    @property
    @pulumi.getter(name="elasticInstanceMinimum")
    def elastic_instance_minimum(self) -> Optional[int]:
        """
        The number of minimum instances for this Windows Function App. Only affects apps on Elastic Premium plans.
        """
        return pulumi.get(self, "elastic_instance_minimum")

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> Optional[str]:
        """
        State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`. Defaults to `Disabled`.
        """
        return pulumi.get(self, "ftps_state")

    @property
    @pulumi.getter(name="healthCheckEvictionTimeInMin")
    def health_check_eviction_time_in_min(self) -> Optional[int]:
        """
        The amount of time in minutes that a node is unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Defaults to `10`. Only valid in conjunction with `health_check_path`
        """
        return pulumi.get(self, "health_check_eviction_time_in_min")

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> Optional[str]:
        """
        The path to be checked for this function app health.
        """
        return pulumi.get(self, "health_check_path")

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[bool]:
        """
        Specifies if the HTTP2 protocol should be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "http2_enabled")

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Optional[Sequence['outputs.WindowsFunctionAppSlotSiteConfigIpRestriction']]:
        """
        an `ip_restriction` block as detailed below.
        """
        return pulumi.get(self, "ip_restrictions")

    @property
    @pulumi.getter(name="loadBalancingMode")
    def load_balancing_mode(self) -> Optional[str]:
        """
        The Site load balancing mode. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        """
        return pulumi.get(self, "load_balancing_mode")

    @property
    @pulumi.getter(name="managedPipelineMode")
    def managed_pipeline_mode(self) -> Optional[str]:
        """
        The Managed Pipeline mode. Possible values include: `Integrated`, `Classic`. Defaults to `Integrated`.
        """
        return pulumi.get(self, "managed_pipeline_mode")

    @property
    @pulumi.getter(name="minimumTlsVersion")
    def minimum_tls_version(self) -> Optional[str]:
        """
        The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and  `1.2`. Defaults to `1.2`.
        """
        return pulumi.get(self, "minimum_tls_version")

    @property
    @pulumi.getter(name="preWarmedInstanceCount")
    def pre_warmed_instance_count(self) -> Optional[int]:
        """
        The number of pre-warmed instances for this function app. Only affects apps on an Elastic Premium plan.
        """
        return pulumi.get(self, "pre_warmed_instance_count")

    @property
    @pulumi.getter(name="remoteDebuggingEnabled")
    def remote_debugging_enabled(self) -> Optional[bool]:
        """
        Should Remote Debugging be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "remote_debugging_enabled")

    @property
    @pulumi.getter(name="remoteDebuggingVersion")
    def remote_debugging_version(self) -> Optional[str]:
        """
        The Remote Debugging Version. Possible values include `VS2017`, `VS2019`, and `VS2022`
        """
        return pulumi.get(self, "remote_debugging_version")

    @property
    @pulumi.getter(name="runtimeScaleMonitoringEnabled")
    def runtime_scale_monitoring_enabled(self) -> Optional[bool]:
        """
        Should Scale Monitoring of the Functions Runtime be enabled?
        """
        return pulumi.get(self, "runtime_scale_monitoring_enabled")

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Optional[Sequence['outputs.WindowsFunctionAppSlotSiteConfigScmIpRestriction']]:
        """
        a `scm_ip_restriction` block as detailed below.
        """
        return pulumi.get(self, "scm_ip_restrictions")

    @property
    @pulumi.getter(name="scmMinimumTlsVersion")
    def scm_minimum_tls_version(self) -> Optional[str]:
        """
        Configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and  `1.2`. Defaults to `1.2`.
        """
        return pulumi.get(self, "scm_minimum_tls_version")

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> Optional[str]:
        """
        The SCM Type in use by the Windows Function App.
        """
        return pulumi.get(self, "scm_type")

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> Optional[bool]:
        """
        Should the Windows Function App `ip_restriction` configuration be used for the SCM also.
        """
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @property
    @pulumi.getter(name="use32BitWorker")
    def use32_bit_worker(self) -> Optional[bool]:
        """
        Should the Windows Web App use a 32-bit worker.
        """
        return pulumi.get(self, "use32_bit_worker")

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> Optional[bool]:
        """
        Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        """
        return pulumi.get(self, "vnet_route_all_enabled")

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> Optional[bool]:
        """
        Should Web Sockets be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "websockets_enabled")

    @property
    @pulumi.getter(name="windowsFxVersion")
    def windows_fx_version(self) -> Optional[str]:
        """
        The Windows FX Version string.
        """
        return pulumi.get(self, "windows_fx_version")

    @property
    @pulumi.getter(name="workerCount")
    def worker_count(self) -> Optional[int]:
        """
        The number of Workers for this Windows Function App.
        """
        return pulumi.get(self, "worker_count")


@pulumi.output_type
class WindowsFunctionAppSlotSiteConfigAppServiceLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskQuotaMb":
            suggest = "disk_quota_mb"
        elif key == "retentionPeriodDays":
            suggest = "retention_period_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotSiteConfigAppServiceLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotSiteConfigAppServiceLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotSiteConfigAppServiceLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_quota_mb: Optional[int] = None,
                 retention_period_days: Optional[int] = None):
        """
        :param int disk_quota_mb: The amount of disk space to use for logs. Valid values are between `25` and `100`.
        :param int retention_period_days: The retention period for logs in days. Valid values are between `0` and `99999`. Defaults to `0` (never delete).
        """
        if disk_quota_mb is not None:
            pulumi.set(__self__, "disk_quota_mb", disk_quota_mb)
        if retention_period_days is not None:
            pulumi.set(__self__, "retention_period_days", retention_period_days)

    @property
    @pulumi.getter(name="diskQuotaMb")
    def disk_quota_mb(self) -> Optional[int]:
        """
        The amount of disk space to use for logs. Valid values are between `25` and `100`.
        """
        return pulumi.get(self, "disk_quota_mb")

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> Optional[int]:
        """
        The retention period for logs in days. Valid values are between `0` and `99999`. Defaults to `0` (never delete).
        """
        return pulumi.get(self, "retention_period_days")


@pulumi.output_type
class WindowsFunctionAppSlotSiteConfigApplicationStack(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dotnetVersion":
            suggest = "dotnet_version"
        elif key == "javaVersion":
            suggest = "java_version"
        elif key == "nodeVersion":
            suggest = "node_version"
        elif key == "powershellCoreVersion":
            suggest = "powershell_core_version"
        elif key == "useCustomRuntime":
            suggest = "use_custom_runtime"
        elif key == "useDotnetIsolatedRuntime":
            suggest = "use_dotnet_isolated_runtime"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotSiteConfigApplicationStack. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotSiteConfigApplicationStack.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotSiteConfigApplicationStack.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dotnet_version: Optional[str] = None,
                 java_version: Optional[str] = None,
                 node_version: Optional[str] = None,
                 powershell_core_version: Optional[str] = None,
                 use_custom_runtime: Optional[bool] = None,
                 use_dotnet_isolated_runtime: Optional[bool] = None):
        """
        :param str dotnet_version: The version of .Net. Possible values are `3.1`, `6` and `7`
        :param str java_version: The version of Java to use. Possible values are `8`, `11` & `17` (In-Preview).
        :param str node_version: The version of Node to use. Possible values are `~12`, `~14`, `~16` and `~18`.
        :param str powershell_core_version: The PowerShell Core version to use. Possible values are `7`, and `7.2`.
        :param bool use_custom_runtime: Does the Function App use a custom Application Stack?
        :param bool use_dotnet_isolated_runtime: Should the DotNet process use an isolated runtime. Defaults to `false`.
        """
        if dotnet_version is not None:
            pulumi.set(__self__, "dotnet_version", dotnet_version)
        if java_version is not None:
            pulumi.set(__self__, "java_version", java_version)
        if node_version is not None:
            pulumi.set(__self__, "node_version", node_version)
        if powershell_core_version is not None:
            pulumi.set(__self__, "powershell_core_version", powershell_core_version)
        if use_custom_runtime is not None:
            pulumi.set(__self__, "use_custom_runtime", use_custom_runtime)
        if use_dotnet_isolated_runtime is not None:
            pulumi.set(__self__, "use_dotnet_isolated_runtime", use_dotnet_isolated_runtime)

    @property
    @pulumi.getter(name="dotnetVersion")
    def dotnet_version(self) -> Optional[str]:
        """
        The version of .Net. Possible values are `3.1`, `6` and `7`
        """
        return pulumi.get(self, "dotnet_version")

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> Optional[str]:
        """
        The version of Java to use. Possible values are `8`, `11` & `17` (In-Preview).
        """
        return pulumi.get(self, "java_version")

    @property
    @pulumi.getter(name="nodeVersion")
    def node_version(self) -> Optional[str]:
        """
        The version of Node to use. Possible values are `~12`, `~14`, `~16` and `~18`.
        """
        return pulumi.get(self, "node_version")

    @property
    @pulumi.getter(name="powershellCoreVersion")
    def powershell_core_version(self) -> Optional[str]:
        """
        The PowerShell Core version to use. Possible values are `7`, and `7.2`.
        """
        return pulumi.get(self, "powershell_core_version")

    @property
    @pulumi.getter(name="useCustomRuntime")
    def use_custom_runtime(self) -> Optional[bool]:
        """
        Does the Function App use a custom Application Stack?
        """
        return pulumi.get(self, "use_custom_runtime")

    @property
    @pulumi.getter(name="useDotnetIsolatedRuntime")
    def use_dotnet_isolated_runtime(self) -> Optional[bool]:
        """
        Should the DotNet process use an isolated runtime. Defaults to `false`.
        """
        return pulumi.get(self, "use_dotnet_isolated_runtime")


@pulumi.output_type
class WindowsFunctionAppSlotSiteConfigCors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedOrigins":
            suggest = "allowed_origins"
        elif key == "supportCredentials":
            suggest = "support_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotSiteConfigCors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotSiteConfigCors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotSiteConfigCors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_origins: Sequence[str],
                 support_credentials: Optional[bool] = None):
        """
        :param Sequence[str] allowed_origins: an `allowed_origins` block as detailed below.
        :param bool support_credentials: Are credentials allowed in CORS requests? Defaults to `false`.
        """
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        if support_credentials is not None:
            pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Sequence[str]:
        """
        an `allowed_origins` block as detailed below.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> Optional[bool]:
        """
        Are credentials allowed in CORS requests? Defaults to `false`.
        """
        return pulumi.get(self, "support_credentials")


@pulumi.output_type
class WindowsFunctionAppSlotSiteConfigIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotSiteConfigIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotSiteConfigIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotSiteConfigIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.WindowsFunctionAppSlotSiteConfigIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: The action to take. Possible values are `Allow` or `Deny`.
        :param 'WindowsFunctionAppSlotSiteConfigIpRestrictionHeadersArgs' headers: a `headers` block as detailed below.
        :param str ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param str name: The name which should be used for this `ip_restriction`.
        :param int priority: The priority value of this `ip_restriction`.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        The action to take. Possible values are `Allow` or `Deny`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.WindowsFunctionAppSlotSiteConfigIpRestrictionHeaders']:
        """
        a `headers` block as detailed below.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority value of this `ip_restriction`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class WindowsFunctionAppSlotSiteConfigIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotSiteConfigIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param str x_fd_health_probe: Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        :param Sequence[str] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param Sequence[str] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class WindowsFunctionAppSlotSiteConfigScmIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotSiteConfigScmIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotSiteConfigScmIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotSiteConfigScmIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.WindowsFunctionAppSlotSiteConfigScmIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: The action to take. Possible values are `Allow` or `Deny`.
        :param 'WindowsFunctionAppSlotSiteConfigScmIpRestrictionHeadersArgs' headers: a `headers` block as detailed below.
        :param str ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param str name: The name which should be used for this `ip_restriction`.
        :param int priority: The priority value of this `ip_restriction`.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.ENDEXPERIMENT
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        The action to take. Possible values are `Allow` or `Deny`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.WindowsFunctionAppSlotSiteConfigScmIpRestrictionHeaders']:
        """
        a `headers` block as detailed below.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority value of this `ip_restriction`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.ENDEXPERIMENT
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class WindowsFunctionAppSlotSiteConfigScmIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotSiteConfigScmIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param str x_fd_health_probe: Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        :param Sequence[str] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param Sequence[str] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class WindowsFunctionAppSlotSiteCredential(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 password: Optional[str] = None):
        """
        :param str name: The Site Credentials Username used for publishing.
        :param str password: The Site Credentials Password used for publishing.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The Site Credentials Username used for publishing.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The Site Credentials Password used for publishing.
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class WindowsFunctionAppSlotStorageAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "accountName":
            suggest = "account_name"
        elif key == "shareName":
            suggest = "share_name"
        elif key == "mountPath":
            suggest = "mount_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppSlotStorageAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppSlotStorageAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppSlotStorageAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: str,
                 account_name: str,
                 name: str,
                 share_name: str,
                 type: str,
                 mount_path: Optional[str] = None):
        """
        :param str access_key: The Access key for the storage account.
        :param str account_name: The Name of the Storage Account.
        :param str name: The name which should be used for this Storage Account.
        :param str share_name: The Name of the File Share or Container Name for Blob storage.
        :param str type: The Azure Storage Type. Possible values include `AzureFiles`.
        :param str mount_path: The path at which to mount the storage share.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "share_name", share_name)
        pulumi.set(__self__, "type", type)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> str:
        """
        The Access key for the storage account.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> str:
        """
        The Name of the Storage Account.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Storage Account.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> str:
        """
        The Name of the File Share or Container Name for Blob storage.
        """
        return pulumi.get(self, "share_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The Azure Storage Type. Possible values include `AzureFiles`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[str]:
        """
        The path at which to mount the storage share.
        """
        return pulumi.get(self, "mount_path")


@pulumi.output_type
class WindowsFunctionAppStickySettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appSettingNames":
            suggest = "app_setting_names"
        elif key == "connectionStringNames":
            suggest = "connection_string_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppStickySettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppStickySettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppStickySettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_setting_names: Optional[Sequence[str]] = None,
                 connection_string_names: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] app_setting_names: A list of `app_setting` names that the Windows Function App will not swap between Slots when a swap operation is triggered.
        :param Sequence[str] connection_string_names: A list of `connection_string` names that the Windows Function App will not swap between Slots when a swap operation is triggered.
        """
        if app_setting_names is not None:
            pulumi.set(__self__, "app_setting_names", app_setting_names)
        if connection_string_names is not None:
            pulumi.set(__self__, "connection_string_names", connection_string_names)

    @property
    @pulumi.getter(name="appSettingNames")
    def app_setting_names(self) -> Optional[Sequence[str]]:
        """
        A list of `app_setting` names that the Windows Function App will not swap between Slots when a swap operation is triggered.
        """
        return pulumi.get(self, "app_setting_names")

    @property
    @pulumi.getter(name="connectionStringNames")
    def connection_string_names(self) -> Optional[Sequence[str]]:
        """
        A list of `connection_string` names that the Windows Function App will not swap between Slots when a swap operation is triggered.
        """
        return pulumi.get(self, "connection_string_names")


@pulumi.output_type
class WindowsFunctionAppStorageAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "accountName":
            suggest = "account_name"
        elif key == "shareName":
            suggest = "share_name"
        elif key == "mountPath":
            suggest = "mount_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFunctionAppStorageAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFunctionAppStorageAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFunctionAppStorageAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: str,
                 account_name: str,
                 name: str,
                 share_name: str,
                 type: str,
                 mount_path: Optional[str] = None):
        """
        :param str access_key: The Access key for the storage account.
        :param str account_name: The Name of the Storage Account.
        :param str name: The name which should be used for this Storage Account.
        :param str share_name: The Name of the File Share or Container Name for Blob storage.
        :param str type: The Azure Storage Type. Possible values include `AzureFiles`.
        :param str mount_path: The path at which to mount the storage share.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "share_name", share_name)
        pulumi.set(__self__, "type", type)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> str:
        """
        The Access key for the storage account.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> str:
        """
        The Name of the Storage Account.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Storage Account.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> str:
        """
        The Name of the File Share or Container Name for Blob storage.
        """
        return pulumi.get(self, "share_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The Azure Storage Type. Possible values include `AzureFiles`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[str]:
        """
        The path at which to mount the storage share.
        """
        return pulumi.get(self, "mount_path")


@pulumi.output_type
class WindowsWebAppAuthSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeDirectory":
            suggest = "active_directory"
        elif key == "additionalLoginParameters":
            suggest = "additional_login_parameters"
        elif key == "allowedExternalRedirectUrls":
            suggest = "allowed_external_redirect_urls"
        elif key == "defaultProvider":
            suggest = "default_provider"
        elif key == "runtimeVersion":
            suggest = "runtime_version"
        elif key == "tokenRefreshExtensionHours":
            suggest = "token_refresh_extension_hours"
        elif key == "tokenStoreEnabled":
            suggest = "token_store_enabled"
        elif key == "unauthenticatedClientAction":
            suggest = "unauthenticated_client_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppAuthSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppAuthSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppAuthSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 active_directory: Optional['outputs.WindowsWebAppAuthSettingsActiveDirectory'] = None,
                 additional_login_parameters: Optional[Mapping[str, str]] = None,
                 allowed_external_redirect_urls: Optional[Sequence[str]] = None,
                 default_provider: Optional[str] = None,
                 facebook: Optional['outputs.WindowsWebAppAuthSettingsFacebook'] = None,
                 github: Optional['outputs.WindowsWebAppAuthSettingsGithub'] = None,
                 google: Optional['outputs.WindowsWebAppAuthSettingsGoogle'] = None,
                 issuer: Optional[str] = None,
                 microsoft: Optional['outputs.WindowsWebAppAuthSettingsMicrosoft'] = None,
                 runtime_version: Optional[str] = None,
                 token_refresh_extension_hours: Optional[float] = None,
                 token_store_enabled: Optional[bool] = None,
                 twitter: Optional['outputs.WindowsWebAppAuthSettingsTwitter'] = None,
                 unauthenticated_client_action: Optional[str] = None):
        """
        :param bool enabled: Should the Authentication / Authorization feature is enabled for the Windows Web App be enabled?
        :param 'WindowsWebAppAuthSettingsActiveDirectoryArgs' active_directory: An `active_directory` block as defined above.
        :param Mapping[str, str] additional_login_parameters: Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        :param Sequence[str] allowed_external_redirect_urls: Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Windows Web App.
        :param str default_provider: The default authentication provider to use when multiple providers are configured. Possible values include: `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount`, `Twitter`, `Github`
        :param 'WindowsWebAppAuthSettingsFacebookArgs' facebook: A `facebook` block as defined below.
        :param 'WindowsWebAppAuthSettingsGithubArgs' github: A `github` block as defined below.
        :param 'WindowsWebAppAuthSettingsGoogleArgs' google: A `google` block as defined below.
        :param str issuer: The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Windows Web App.
        :param 'WindowsWebAppAuthSettingsMicrosoftArgs' microsoft: A `microsoft` block as defined below.
        :param str runtime_version: The RuntimeVersion of the Authentication / Authorization feature in use for the Windows Web App.
        :param float token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        :param bool token_store_enabled: Should the Windows Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        :param 'WindowsWebAppAuthSettingsTwitterArgs' twitter: A `twitter` block as defined below.
        :param str unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if active_directory is not None:
            pulumi.set(__self__, "active_directory", active_directory)
        if additional_login_parameters is not None:
            pulumi.set(__self__, "additional_login_parameters", additional_login_parameters)
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if facebook is not None:
            pulumi.set(__self__, "facebook", facebook)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if google is not None:
            pulumi.set(__self__, "google", google)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if microsoft is not None:
            pulumi.set(__self__, "microsoft", microsoft)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if token_refresh_extension_hours is not None:
            pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if twitter is not None:
            pulumi.set(__self__, "twitter", twitter)
        if unauthenticated_client_action is not None:
            pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Should the Authentication / Authorization feature is enabled for the Windows Web App be enabled?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="activeDirectory")
    def active_directory(self) -> Optional['outputs.WindowsWebAppAuthSettingsActiveDirectory']:
        """
        An `active_directory` block as defined above.
        """
        return pulumi.get(self, "active_directory")

    @property
    @pulumi.getter(name="additionalLoginParameters")
    def additional_login_parameters(self) -> Optional[Mapping[str, str]]:
        """
        Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        """
        return pulumi.get(self, "additional_login_parameters")

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Windows Web App.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[str]:
        """
        The default authentication provider to use when multiple providers are configured. Possible values include: `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount`, `Twitter`, `Github`
        """
        return pulumi.get(self, "default_provider")

    @property
    @pulumi.getter
    def facebook(self) -> Optional['outputs.WindowsWebAppAuthSettingsFacebook']:
        """
        A `facebook` block as defined below.
        """
        return pulumi.get(self, "facebook")

    @property
    @pulumi.getter
    def github(self) -> Optional['outputs.WindowsWebAppAuthSettingsGithub']:
        """
        A `github` block as defined below.
        """
        return pulumi.get(self, "github")

    @property
    @pulumi.getter
    def google(self) -> Optional['outputs.WindowsWebAppAuthSettingsGoogle']:
        """
        A `google` block as defined below.
        """
        return pulumi.get(self, "google")

    @property
    @pulumi.getter
    def issuer(self) -> Optional[str]:
        """
        The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Windows Web App.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def microsoft(self) -> Optional['outputs.WindowsWebAppAuthSettingsMicrosoft']:
        """
        A `microsoft` block as defined below.
        """
        return pulumi.get(self, "microsoft")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[str]:
        """
        The RuntimeVersion of the Authentication / Authorization feature in use for the Windows Web App.
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> Optional[float]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        return pulumi.get(self, "token_refresh_extension_hours")

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[bool]:
        """
        Should the Windows Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        """
        return pulumi.get(self, "token_store_enabled")

    @property
    @pulumi.getter
    def twitter(self) -> Optional['outputs.WindowsWebAppAuthSettingsTwitter']:
        """
        A `twitter` block as defined below.
        """
        return pulumi.get(self, "twitter")

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> Optional[str]:
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        return pulumi.get(self, "unauthenticated_client_action")


@pulumi.output_type
class WindowsWebAppAuthSettingsActiveDirectory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppAuthSettingsActiveDirectory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppAuthSettingsActiveDirectory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppAuthSettingsActiveDirectory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param Sequence[str] allowed_audiences: Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
        :param str client_secret: The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        pulumi.set(__self__, "client_id", client_id)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")


@pulumi.output_type
class WindowsWebAppAuthSettingsFacebook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "appSecret":
            suggest = "app_secret"
        elif key == "appSecretSettingName":
            suggest = "app_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppAuthSettingsFacebook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppAuthSettingsFacebook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppAuthSettingsFacebook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: str,
                 app_secret: Optional[str] = None,
                 app_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str app_id: The App ID of the Facebook app used for login.
        :param str app_secret: The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        :param str app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        if app_secret is not None:
            pulumi.set(__self__, "app_secret", app_secret)
        if app_secret_setting_name is not None:
            pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appSecret")
    def app_secret(self) -> Optional[str]:
        """
        The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        """
        return pulumi.get(self, "app_secret")

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class WindowsWebAppAuthSettingsGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppAuthSettingsGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppAuthSettingsGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppAuthSettingsGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the GitHub app used for login.
        :param str client_secret: The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the GitHub app used for login.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class WindowsWebAppAuthSettingsGoogle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppAuthSettingsGoogle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppAuthSettingsGoogle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppAuthSettingsGoogle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OpenID Connect Client ID for the Google web application.
        :param str client_secret: The client secret associated with the Google web application.  Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OpenID Connect Client ID for the Google web application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The client secret associated with the Google web application.  Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class WindowsWebAppAuthSettingsMicrosoft(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppAuthSettingsMicrosoft. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppAuthSettingsMicrosoft.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppAuthSettingsMicrosoft.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret: The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, "wl.basic" is used as the default scope.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, "wl.basic" is used as the default scope.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class WindowsWebAppAuthSettingsTwitter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerKey":
            suggest = "consumer_key"
        elif key == "consumerSecret":
            suggest = "consumer_secret"
        elif key == "consumerSecretSettingName":
            suggest = "consumer_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppAuthSettingsTwitter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppAuthSettingsTwitter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppAuthSettingsTwitter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_key: str,
                 consumer_secret: Optional[str] = None,
                 consumer_secret_setting_name: Optional[str] = None):
        """
        :param str consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param str consumer_secret: The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        :param str consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        if consumer_secret is not None:
            pulumi.set(__self__, "consumer_secret", consumer_secret)
        if consumer_secret_setting_name is not None:
            pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> str:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> Optional[str]:
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        """
        return pulumi.get(self, "consumer_secret")

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        return pulumi.get(self, "consumer_secret_setting_name")


@pulumi.output_type
class WindowsWebAppBackup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageAccountUrl":
            suggest = "storage_account_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppBackup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppBackup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppBackup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 schedule: 'outputs.WindowsWebAppBackupSchedule',
                 storage_account_url: str,
                 enabled: Optional[bool] = None):
        """
        :param str name: The name which should be used for this Backup.
        :param 'WindowsWebAppBackupScheduleArgs' schedule: A `schedule` block as defined below.
        :param str storage_account_url: The SAS URL to the container.
        :param bool enabled: Should this backup job be enabled?
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "storage_account_url", storage_account_url)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Backup.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def schedule(self) -> 'outputs.WindowsWebAppBackupSchedule':
        """
        A `schedule` block as defined below.
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter(name="storageAccountUrl")
    def storage_account_url(self) -> str:
        """
        The SAS URL to the container.
        """
        return pulumi.get(self, "storage_account_url")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Should this backup job be enabled?
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class WindowsWebAppBackupSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "frequencyUnit":
            suggest = "frequency_unit"
        elif key == "keepAtLeastOneBackup":
            suggest = "keep_at_least_one_backup"
        elif key == "lastExecutionTime":
            suggest = "last_execution_time"
        elif key == "retentionPeriodDays":
            suggest = "retention_period_days"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppBackupSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppBackupSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppBackupSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_unit: str,
                 keep_at_least_one_backup: Optional[bool] = None,
                 last_execution_time: Optional[str] = None,
                 retention_period_days: Optional[int] = None,
                 start_time: Optional[str] = None):
        """
        :param int frequency_interval: How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).
        :param str frequency_unit: The unit of time for how often the backup should take place. Possible values include: `Day`, `Hour`
        :param bool keep_at_least_one_backup: Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
        :param int retention_period_days: After how many days backups should be deleted.
        :param str start_time: When the schedule should start working in RFC-3339 format.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_unit", frequency_unit)
        if keep_at_least_one_backup is not None:
            pulumi.set(__self__, "keep_at_least_one_backup", keep_at_least_one_backup)
        if last_execution_time is not None:
            pulumi.set(__self__, "last_execution_time", last_execution_time)
        if retention_period_days is not None:
            pulumi.set(__self__, "retention_period_days", retention_period_days)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyUnit")
    def frequency_unit(self) -> str:
        """
        The unit of time for how often the backup should take place. Possible values include: `Day`, `Hour`
        """
        return pulumi.get(self, "frequency_unit")

    @property
    @pulumi.getter(name="keepAtLeastOneBackup")
    def keep_at_least_one_backup(self) -> Optional[bool]:
        """
        Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
        """
        return pulumi.get(self, "keep_at_least_one_backup")

    @property
    @pulumi.getter(name="lastExecutionTime")
    def last_execution_time(self) -> Optional[str]:
        return pulumi.get(self, "last_execution_time")

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> Optional[int]:
        """
        After how many days backups should be deleted.
        """
        return pulumi.get(self, "retention_period_days")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        """
        When the schedule should start working in RFC-3339 format.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class WindowsWebAppConnectionString(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: The name of the Connection String.
        :param str type: Type of database. Possible values include: `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
        :param str value: The connection string value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Connection String.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of database. Possible values include: `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The connection string value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class WindowsWebAppIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 identity_ids: Optional[Sequence[str]] = None,
                 principal_id: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str type: Specifies the type of Managed Service Identity that should be configured on this Windows Web App. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        :param Sequence[str] identity_ids: A list of User Assigned Managed Identity IDs to be assigned to this Windows Web App.
        :param str principal_id: The Principal ID associated with this Managed Service Identity.
        :param str tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the type of Managed Service Identity that should be configured on this Windows Web App. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[str]]:
        """
        A list of User Assigned Managed Identity IDs to be assigned to this Windows Web App.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class WindowsWebAppLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationLogs":
            suggest = "application_logs"
        elif key == "detailedErrorMessages":
            suggest = "detailed_error_messages"
        elif key == "failedRequestTracing":
            suggest = "failed_request_tracing"
        elif key == "httpLogs":
            suggest = "http_logs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_logs: Optional['outputs.WindowsWebAppLogsApplicationLogs'] = None,
                 detailed_error_messages: Optional[bool] = None,
                 failed_request_tracing: Optional[bool] = None,
                 http_logs: Optional['outputs.WindowsWebAppLogsHttpLogs'] = None):
        """
        :param 'WindowsWebAppLogsApplicationLogsArgs' application_logs: A `application_logs` block as defined above.
        :param bool detailed_error_messages: Should detailed error messages be enabled.
        :param bool failed_request_tracing: Should tracing be enabled for failed requests.
        :param 'WindowsWebAppLogsHttpLogsArgs' http_logs: A `http_logs` block as defined above.
        """
        if application_logs is not None:
            pulumi.set(__self__, "application_logs", application_logs)
        if detailed_error_messages is not None:
            pulumi.set(__self__, "detailed_error_messages", detailed_error_messages)
        if failed_request_tracing is not None:
            pulumi.set(__self__, "failed_request_tracing", failed_request_tracing)
        if http_logs is not None:
            pulumi.set(__self__, "http_logs", http_logs)

    @property
    @pulumi.getter(name="applicationLogs")
    def application_logs(self) -> Optional['outputs.WindowsWebAppLogsApplicationLogs']:
        """
        A `application_logs` block as defined above.
        """
        return pulumi.get(self, "application_logs")

    @property
    @pulumi.getter(name="detailedErrorMessages")
    def detailed_error_messages(self) -> Optional[bool]:
        """
        Should detailed error messages be enabled.
        """
        return pulumi.get(self, "detailed_error_messages")

    @property
    @pulumi.getter(name="failedRequestTracing")
    def failed_request_tracing(self) -> Optional[bool]:
        """
        Should tracing be enabled for failed requests.
        """
        return pulumi.get(self, "failed_request_tracing")

    @property
    @pulumi.getter(name="httpLogs")
    def http_logs(self) -> Optional['outputs.WindowsWebAppLogsHttpLogs']:
        """
        A `http_logs` block as defined above.
        """
        return pulumi.get(self, "http_logs")


@pulumi.output_type
class WindowsWebAppLogsApplicationLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileSystemLevel":
            suggest = "file_system_level"
        elif key == "azureBlobStorage":
            suggest = "azure_blob_storage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppLogsApplicationLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppLogsApplicationLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppLogsApplicationLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_system_level: str,
                 azure_blob_storage: Optional['outputs.WindowsWebAppLogsApplicationLogsAzureBlobStorage'] = None):
        """
        :param str file_system_level: Log level. Possible values include: `Verbose`, `Information`, `Warning`, and `Error`.
        :param 'WindowsWebAppLogsApplicationLogsAzureBlobStorageArgs' azure_blob_storage: An `azure_blob_storage` block as defined below.
        """
        pulumi.set(__self__, "file_system_level", file_system_level)
        if azure_blob_storage is not None:
            pulumi.set(__self__, "azure_blob_storage", azure_blob_storage)

    @property
    @pulumi.getter(name="fileSystemLevel")
    def file_system_level(self) -> str:
        """
        Log level. Possible values include: `Verbose`, `Information`, `Warning`, and `Error`.
        """
        return pulumi.get(self, "file_system_level")

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional['outputs.WindowsWebAppLogsApplicationLogsAzureBlobStorage']:
        """
        An `azure_blob_storage` block as defined below.
        """
        return pulumi.get(self, "azure_blob_storage")


@pulumi.output_type
class WindowsWebAppLogsApplicationLogsAzureBlobStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retentionInDays":
            suggest = "retention_in_days"
        elif key == "sasUrl":
            suggest = "sas_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppLogsApplicationLogsAzureBlobStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppLogsApplicationLogsAzureBlobStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppLogsApplicationLogsAzureBlobStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 level: str,
                 retention_in_days: int,
                 sas_url: str):
        """
        :param str level: The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        :param int retention_in_days: The time in days after which to remove blobs. A value of `0` means no retention.
        :param str sas_url: SAS url to an Azure blob container with read/write/list/delete permissions.
        """
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "sas_url", sas_url)

    @property
    @pulumi.getter
    def level(self) -> str:
        """
        The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        """
        return pulumi.get(self, "level")

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> int:
        """
        The time in days after which to remove blobs. A value of `0` means no retention.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> str:
        """
        SAS url to an Azure blob container with read/write/list/delete permissions.
        """
        return pulumi.get(self, "sas_url")


@pulumi.output_type
class WindowsWebAppLogsHttpLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureBlobStorage":
            suggest = "azure_blob_storage"
        elif key == "fileSystem":
            suggest = "file_system"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppLogsHttpLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppLogsHttpLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppLogsHttpLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_blob_storage: Optional['outputs.WindowsWebAppLogsHttpLogsAzureBlobStorage'] = None,
                 file_system: Optional['outputs.WindowsWebAppLogsHttpLogsFileSystem'] = None):
        """
        :param 'WindowsWebAppLogsHttpLogsAzureBlobStorageArgs' azure_blob_storage: A `azure_blob_storage` block as defined above.
        :param 'WindowsWebAppLogsHttpLogsFileSystemArgs' file_system: A `file_system` block as defined above.
        """
        if azure_blob_storage is not None:
            pulumi.set(__self__, "azure_blob_storage", azure_blob_storage)
        if file_system is not None:
            pulumi.set(__self__, "file_system", file_system)

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional['outputs.WindowsWebAppLogsHttpLogsAzureBlobStorage']:
        """
        A `azure_blob_storage` block as defined above.
        """
        return pulumi.get(self, "azure_blob_storage")

    @property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional['outputs.WindowsWebAppLogsHttpLogsFileSystem']:
        """
        A `file_system` block as defined above.
        """
        return pulumi.get(self, "file_system")


@pulumi.output_type
class WindowsWebAppLogsHttpLogsAzureBlobStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sasUrl":
            suggest = "sas_url"
        elif key == "retentionInDays":
            suggest = "retention_in_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppLogsHttpLogsAzureBlobStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppLogsHttpLogsAzureBlobStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppLogsHttpLogsAzureBlobStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sas_url: str,
                 retention_in_days: Optional[int] = None):
        """
        :param str sas_url: SAS url to an Azure blob container with read/write/list/delete permissions.
        :param int retention_in_days: The time in days after which to remove blobs. A value of `0` means no retention.
        """
        pulumi.set(__self__, "sas_url", sas_url)
        if retention_in_days is not None:
            pulumi.set(__self__, "retention_in_days", retention_in_days)

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> str:
        """
        SAS url to an Azure blob container with read/write/list/delete permissions.
        """
        return pulumi.get(self, "sas_url")

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> Optional[int]:
        """
        The time in days after which to remove blobs. A value of `0` means no retention.
        """
        return pulumi.get(self, "retention_in_days")


@pulumi.output_type
class WindowsWebAppLogsHttpLogsFileSystem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retentionInDays":
            suggest = "retention_in_days"
        elif key == "retentionInMb":
            suggest = "retention_in_mb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppLogsHttpLogsFileSystem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppLogsHttpLogsFileSystem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppLogsHttpLogsFileSystem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 retention_in_days: int,
                 retention_in_mb: int):
        """
        :param int retention_in_days: The retention period in days. A values of `0` means no retention.
        :param int retention_in_mb: The maximum size in megabytes that log files can use.
        """
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "retention_in_mb", retention_in_mb)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> int:
        """
        The retention period in days. A values of `0` means no retention.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="retentionInMb")
    def retention_in_mb(self) -> int:
        """
        The maximum size in megabytes that log files can use.
        """
        return pulumi.get(self, "retention_in_mb")


@pulumi.output_type
class WindowsWebAppSiteConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alwaysOn":
            suggest = "always_on"
        elif key == "apiDefinitionUrl":
            suggest = "api_definition_url"
        elif key == "apiManagementApiId":
            suggest = "api_management_api_id"
        elif key == "appCommandLine":
            suggest = "app_command_line"
        elif key == "applicationStack":
            suggest = "application_stack"
        elif key == "autoHealEnabled":
            suggest = "auto_heal_enabled"
        elif key == "autoHealSetting":
            suggest = "auto_heal_setting"
        elif key == "containerRegistryManagedIdentityClientId":
            suggest = "container_registry_managed_identity_client_id"
        elif key == "containerRegistryUseManagedIdentity":
            suggest = "container_registry_use_managed_identity"
        elif key == "defaultDocuments":
            suggest = "default_documents"
        elif key == "detailedErrorLoggingEnabled":
            suggest = "detailed_error_logging_enabled"
        elif key == "ftpsState":
            suggest = "ftps_state"
        elif key == "healthCheckEvictionTimeInMin":
            suggest = "health_check_eviction_time_in_min"
        elif key == "healthCheckPath":
            suggest = "health_check_path"
        elif key == "http2Enabled":
            suggest = "http2_enabled"
        elif key == "ipRestrictions":
            suggest = "ip_restrictions"
        elif key == "linuxFxVersion":
            suggest = "linux_fx_version"
        elif key == "loadBalancingMode":
            suggest = "load_balancing_mode"
        elif key == "localMysqlEnabled":
            suggest = "local_mysql_enabled"
        elif key == "managedPipelineMode":
            suggest = "managed_pipeline_mode"
        elif key == "minimumTlsVersion":
            suggest = "minimum_tls_version"
        elif key == "remoteDebuggingEnabled":
            suggest = "remote_debugging_enabled"
        elif key == "remoteDebuggingVersion":
            suggest = "remote_debugging_version"
        elif key == "scmIpRestrictions":
            suggest = "scm_ip_restrictions"
        elif key == "scmMinimumTlsVersion":
            suggest = "scm_minimum_tls_version"
        elif key == "scmType":
            suggest = "scm_type"
        elif key == "scmUseMainIpRestriction":
            suggest = "scm_use_main_ip_restriction"
        elif key == "use32BitWorker":
            suggest = "use32_bit_worker"
        elif key == "virtualApplications":
            suggest = "virtual_applications"
        elif key == "vnetRouteAllEnabled":
            suggest = "vnet_route_all_enabled"
        elif key == "websocketsEnabled":
            suggest = "websockets_enabled"
        elif key == "windowsFxVersion":
            suggest = "windows_fx_version"
        elif key == "workerCount":
            suggest = "worker_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSiteConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSiteConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSiteConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 always_on: Optional[bool] = None,
                 api_definition_url: Optional[str] = None,
                 api_management_api_id: Optional[str] = None,
                 app_command_line: Optional[str] = None,
                 application_stack: Optional['outputs.WindowsWebAppSiteConfigApplicationStack'] = None,
                 auto_heal_enabled: Optional[bool] = None,
                 auto_heal_setting: Optional['outputs.WindowsWebAppSiteConfigAutoHealSetting'] = None,
                 container_registry_managed_identity_client_id: Optional[str] = None,
                 container_registry_use_managed_identity: Optional[bool] = None,
                 cors: Optional['outputs.WindowsWebAppSiteConfigCors'] = None,
                 default_documents: Optional[Sequence[str]] = None,
                 detailed_error_logging_enabled: Optional[bool] = None,
                 ftps_state: Optional[str] = None,
                 health_check_eviction_time_in_min: Optional[int] = None,
                 health_check_path: Optional[str] = None,
                 http2_enabled: Optional[bool] = None,
                 ip_restrictions: Optional[Sequence['outputs.WindowsWebAppSiteConfigIpRestriction']] = None,
                 linux_fx_version: Optional[str] = None,
                 load_balancing_mode: Optional[str] = None,
                 local_mysql_enabled: Optional[bool] = None,
                 managed_pipeline_mode: Optional[str] = None,
                 minimum_tls_version: Optional[str] = None,
                 remote_debugging_enabled: Optional[bool] = None,
                 remote_debugging_version: Optional[str] = None,
                 scm_ip_restrictions: Optional[Sequence['outputs.WindowsWebAppSiteConfigScmIpRestriction']] = None,
                 scm_minimum_tls_version: Optional[str] = None,
                 scm_type: Optional[str] = None,
                 scm_use_main_ip_restriction: Optional[bool] = None,
                 use32_bit_worker: Optional[bool] = None,
                 virtual_applications: Optional[Sequence['outputs.WindowsWebAppSiteConfigVirtualApplication']] = None,
                 vnet_route_all_enabled: Optional[bool] = None,
                 websockets_enabled: Optional[bool] = None,
                 windows_fx_version: Optional[str] = None,
                 worker_count: Optional[int] = None):
        """
        :param bool always_on: If this Windows Web App is Always On enabled. Defaults to `true`.
        :param str api_management_api_id: The API Management API ID this Windows Web App Slot is associated with.
        :param str app_command_line: The App command line to launch.
        :param 'WindowsWebAppSiteConfigApplicationStackArgs' application_stack: A `application_stack` block as defined above.
        :param bool auto_heal_enabled: Should Auto heal rules be enabled. Required with `auto_heal_setting`.
        :param 'WindowsWebAppSiteConfigAutoHealSettingArgs' auto_heal_setting: A `auto_heal_setting` block as defined above. Required with `auto_heal`.
        :param str container_registry_managed_identity_client_id: The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
        :param bool container_registry_use_managed_identity: Should connections for Azure Container Registry use Managed Identity.
        :param 'WindowsWebAppSiteConfigCorsArgs' cors: A `cors` block as defined above.
        :param Sequence[str] default_documents: Specifies a list of Default Documents for the Windows Web App.
        :param str ftps_state: The State of FTP / FTPS service. Possible values include: `AllAllowed`, `FtpsOnly`, `Disabled`.
        :param int health_check_eviction_time_in_min: The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        :param str health_check_path: The path to the Health Check.
        :param bool http2_enabled: Should the HTTP2 be enabled?
        :param Sequence['WindowsWebAppSiteConfigIpRestrictionArgs'] ip_restrictions: One or more `ip_restriction` blocks as defined above.
        :param str load_balancing_mode: The Site load balancing. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        :param bool local_mysql_enabled: Use Local MySQL. Defaults to `false`.
        :param str managed_pipeline_mode: Managed pipeline mode. Possible values include: `Integrated`, `Classic`.
        :param str minimum_tls_version: The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and  `1.2`. Defaults to `1.2`.
        :param bool remote_debugging_enabled: Should Remote Debugging be enabled. Defaults to `false`.
        :param str remote_debugging_version: The Remote Debugging Version. Possible values include `VS2017` and `VS2019`
        :param Sequence['WindowsWebAppSiteConfigScmIpRestrictionArgs'] scm_ip_restrictions: One or more `scm_ip_restriction` blocks as defined above.
        :param str scm_minimum_tls_version: The configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and  `1.2`. Defaults to `1.2`.
        :param bool scm_use_main_ip_restriction: Should the Windows Web App `ip_restriction` configuration be used for the SCM also.
        :param bool use32_bit_worker: Should the Windows Web App use a 32-bit worker.
        :param Sequence['WindowsWebAppSiteConfigVirtualApplicationArgs'] virtual_applications: One or more `virtual_application` blocks as defined below.
        :param bool vnet_route_all_enabled: Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        :param bool websockets_enabled: Should Web Sockets be enabled. Defaults to `false`.
        :param int worker_count: The number of Workers for this Windows App Service.
        """
        if always_on is not None:
            pulumi.set(__self__, "always_on", always_on)
        if api_definition_url is not None:
            pulumi.set(__self__, "api_definition_url", api_definition_url)
        if api_management_api_id is not None:
            pulumi.set(__self__, "api_management_api_id", api_management_api_id)
        if app_command_line is not None:
            pulumi.set(__self__, "app_command_line", app_command_line)
        if application_stack is not None:
            pulumi.set(__self__, "application_stack", application_stack)
        if auto_heal_enabled is not None:
            pulumi.set(__self__, "auto_heal_enabled", auto_heal_enabled)
        if auto_heal_setting is not None:
            pulumi.set(__self__, "auto_heal_setting", auto_heal_setting)
        if container_registry_managed_identity_client_id is not None:
            pulumi.set(__self__, "container_registry_managed_identity_client_id", container_registry_managed_identity_client_id)
        if container_registry_use_managed_identity is not None:
            pulumi.set(__self__, "container_registry_use_managed_identity", container_registry_use_managed_identity)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if default_documents is not None:
            pulumi.set(__self__, "default_documents", default_documents)
        if detailed_error_logging_enabled is not None:
            pulumi.set(__self__, "detailed_error_logging_enabled", detailed_error_logging_enabled)
        if ftps_state is not None:
            pulumi.set(__self__, "ftps_state", ftps_state)
        if health_check_eviction_time_in_min is not None:
            pulumi.set(__self__, "health_check_eviction_time_in_min", health_check_eviction_time_in_min)
        if health_check_path is not None:
            pulumi.set(__self__, "health_check_path", health_check_path)
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if ip_restrictions is not None:
            pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        if linux_fx_version is not None:
            pulumi.set(__self__, "linux_fx_version", linux_fx_version)
        if load_balancing_mode is not None:
            pulumi.set(__self__, "load_balancing_mode", load_balancing_mode)
        if local_mysql_enabled is not None:
            pulumi.set(__self__, "local_mysql_enabled", local_mysql_enabled)
        if managed_pipeline_mode is not None:
            pulumi.set(__self__, "managed_pipeline_mode", managed_pipeline_mode)
        if minimum_tls_version is not None:
            pulumi.set(__self__, "minimum_tls_version", minimum_tls_version)
        if remote_debugging_enabled is not None:
            pulumi.set(__self__, "remote_debugging_enabled", remote_debugging_enabled)
        if remote_debugging_version is not None:
            pulumi.set(__self__, "remote_debugging_version", remote_debugging_version)
        if scm_ip_restrictions is not None:
            pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        if scm_minimum_tls_version is not None:
            pulumi.set(__self__, "scm_minimum_tls_version", scm_minimum_tls_version)
        if scm_type is not None:
            pulumi.set(__self__, "scm_type", scm_type)
        if scm_use_main_ip_restriction is not None:
            pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        if use32_bit_worker is not None:
            pulumi.set(__self__, "use32_bit_worker", use32_bit_worker)
        if virtual_applications is not None:
            pulumi.set(__self__, "virtual_applications", virtual_applications)
        if vnet_route_all_enabled is not None:
            pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        if websockets_enabled is not None:
            pulumi.set(__self__, "websockets_enabled", websockets_enabled)
        if windows_fx_version is not None:
            pulumi.set(__self__, "windows_fx_version", windows_fx_version)
        if worker_count is not None:
            pulumi.set(__self__, "worker_count", worker_count)

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> Optional[bool]:
        """
        If this Windows Web App is Always On enabled. Defaults to `true`.
        """
        return pulumi.get(self, "always_on")

    @property
    @pulumi.getter(name="apiDefinitionUrl")
    def api_definition_url(self) -> Optional[str]:
        return pulumi.get(self, "api_definition_url")

    @property
    @pulumi.getter(name="apiManagementApiId")
    def api_management_api_id(self) -> Optional[str]:
        """
        The API Management API ID this Windows Web App Slot is associated with.
        """
        return pulumi.get(self, "api_management_api_id")

    @property
    @pulumi.getter(name="appCommandLine")
    def app_command_line(self) -> Optional[str]:
        """
        The App command line to launch.
        """
        return pulumi.get(self, "app_command_line")

    @property
    @pulumi.getter(name="applicationStack")
    def application_stack(self) -> Optional['outputs.WindowsWebAppSiteConfigApplicationStack']:
        """
        A `application_stack` block as defined above.
        """
        return pulumi.get(self, "application_stack")

    @property
    @pulumi.getter(name="autoHealEnabled")
    def auto_heal_enabled(self) -> Optional[bool]:
        """
        Should Auto heal rules be enabled. Required with `auto_heal_setting`.
        """
        return pulumi.get(self, "auto_heal_enabled")

    @property
    @pulumi.getter(name="autoHealSetting")
    def auto_heal_setting(self) -> Optional['outputs.WindowsWebAppSiteConfigAutoHealSetting']:
        """
        A `auto_heal_setting` block as defined above. Required with `auto_heal`.
        """
        return pulumi.get(self, "auto_heal_setting")

    @property
    @pulumi.getter(name="containerRegistryManagedIdentityClientId")
    def container_registry_managed_identity_client_id(self) -> Optional[str]:
        """
        The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
        """
        return pulumi.get(self, "container_registry_managed_identity_client_id")

    @property
    @pulumi.getter(name="containerRegistryUseManagedIdentity")
    def container_registry_use_managed_identity(self) -> Optional[bool]:
        """
        Should connections for Azure Container Registry use Managed Identity.
        """
        return pulumi.get(self, "container_registry_use_managed_identity")

    @property
    @pulumi.getter
    def cors(self) -> Optional['outputs.WindowsWebAppSiteConfigCors']:
        """
        A `cors` block as defined above.
        """
        return pulumi.get(self, "cors")

    @property
    @pulumi.getter(name="defaultDocuments")
    def default_documents(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Default Documents for the Windows Web App.
        """
        return pulumi.get(self, "default_documents")

    @property
    @pulumi.getter(name="detailedErrorLoggingEnabled")
    def detailed_error_logging_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "detailed_error_logging_enabled")

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> Optional[str]:
        """
        The State of FTP / FTPS service. Possible values include: `AllAllowed`, `FtpsOnly`, `Disabled`.
        """
        return pulumi.get(self, "ftps_state")

    @property
    @pulumi.getter(name="healthCheckEvictionTimeInMin")
    def health_check_eviction_time_in_min(self) -> Optional[int]:
        """
        The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        """
        return pulumi.get(self, "health_check_eviction_time_in_min")

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> Optional[str]:
        """
        The path to the Health Check.
        """
        return pulumi.get(self, "health_check_path")

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[bool]:
        """
        Should the HTTP2 be enabled?
        """
        return pulumi.get(self, "http2_enabled")

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Optional[Sequence['outputs.WindowsWebAppSiteConfigIpRestriction']]:
        """
        One or more `ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "ip_restrictions")

    @property
    @pulumi.getter(name="linuxFxVersion")
    def linux_fx_version(self) -> Optional[str]:
        return pulumi.get(self, "linux_fx_version")

    @property
    @pulumi.getter(name="loadBalancingMode")
    def load_balancing_mode(self) -> Optional[str]:
        """
        The Site load balancing. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        """
        return pulumi.get(self, "load_balancing_mode")

    @property
    @pulumi.getter(name="localMysqlEnabled")
    def local_mysql_enabled(self) -> Optional[bool]:
        """
        Use Local MySQL. Defaults to `false`.
        """
        return pulumi.get(self, "local_mysql_enabled")

    @property
    @pulumi.getter(name="managedPipelineMode")
    def managed_pipeline_mode(self) -> Optional[str]:
        """
        Managed pipeline mode. Possible values include: `Integrated`, `Classic`.
        """
        return pulumi.get(self, "managed_pipeline_mode")

    @property
    @pulumi.getter(name="minimumTlsVersion")
    def minimum_tls_version(self) -> Optional[str]:
        """
        The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and  `1.2`. Defaults to `1.2`.
        """
        return pulumi.get(self, "minimum_tls_version")

    @property
    @pulumi.getter(name="remoteDebuggingEnabled")
    def remote_debugging_enabled(self) -> Optional[bool]:
        """
        Should Remote Debugging be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "remote_debugging_enabled")

    @property
    @pulumi.getter(name="remoteDebuggingVersion")
    def remote_debugging_version(self) -> Optional[str]:
        """
        The Remote Debugging Version. Possible values include `VS2017` and `VS2019`
        """
        return pulumi.get(self, "remote_debugging_version")

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Optional[Sequence['outputs.WindowsWebAppSiteConfigScmIpRestriction']]:
        """
        One or more `scm_ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "scm_ip_restrictions")

    @property
    @pulumi.getter(name="scmMinimumTlsVersion")
    def scm_minimum_tls_version(self) -> Optional[str]:
        """
        The configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and  `1.2`. Defaults to `1.2`.
        """
        return pulumi.get(self, "scm_minimum_tls_version")

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> Optional[str]:
        return pulumi.get(self, "scm_type")

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> Optional[bool]:
        """
        Should the Windows Web App `ip_restriction` configuration be used for the SCM also.
        """
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @property
    @pulumi.getter(name="use32BitWorker")
    def use32_bit_worker(self) -> Optional[bool]:
        """
        Should the Windows Web App use a 32-bit worker.
        """
        return pulumi.get(self, "use32_bit_worker")

    @property
    @pulumi.getter(name="virtualApplications")
    def virtual_applications(self) -> Optional[Sequence['outputs.WindowsWebAppSiteConfigVirtualApplication']]:
        """
        One or more `virtual_application` blocks as defined below.
        """
        return pulumi.get(self, "virtual_applications")

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> Optional[bool]:
        """
        Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        """
        return pulumi.get(self, "vnet_route_all_enabled")

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> Optional[bool]:
        """
        Should Web Sockets be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "websockets_enabled")

    @property
    @pulumi.getter(name="windowsFxVersion")
    def windows_fx_version(self) -> Optional[str]:
        return pulumi.get(self, "windows_fx_version")

    @property
    @pulumi.getter(name="workerCount")
    def worker_count(self) -> Optional[int]:
        """
        The number of Workers for this Windows App Service.
        """
        return pulumi.get(self, "worker_count")


@pulumi.output_type
class WindowsWebAppSiteConfigApplicationStack(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "currentStack":
            suggest = "current_stack"
        elif key == "dockerContainerName":
            suggest = "docker_container_name"
        elif key == "dockerContainerRegistry":
            suggest = "docker_container_registry"
        elif key == "dockerContainerTag":
            suggest = "docker_container_tag"
        elif key == "dotnetVersion":
            suggest = "dotnet_version"
        elif key == "javaContainer":
            suggest = "java_container"
        elif key == "javaContainerVersion":
            suggest = "java_container_version"
        elif key == "javaVersion":
            suggest = "java_version"
        elif key == "nodeVersion":
            suggest = "node_version"
        elif key == "phpVersion":
            suggest = "php_version"
        elif key == "pythonVersion":
            suggest = "python_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSiteConfigApplicationStack. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSiteConfigApplicationStack.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSiteConfigApplicationStack.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 current_stack: Optional[str] = None,
                 docker_container_name: Optional[str] = None,
                 docker_container_registry: Optional[str] = None,
                 docker_container_tag: Optional[str] = None,
                 dotnet_version: Optional[str] = None,
                 java_container: Optional[str] = None,
                 java_container_version: Optional[str] = None,
                 java_version: Optional[str] = None,
                 node_version: Optional[str] = None,
                 php_version: Optional[str] = None,
                 python_version: Optional[str] = None):
        """
        :param str current_stack: The Application Stack for the Windows Web App. Possible values include `dotnet`, `dotnetcore`, `node`, `python`, `php`, and `java`.
        :param str docker_container_name: The name of the Docker Container. For example `azure-app-service/samples/aspnethelloworld`
        :param str docker_container_registry: The registry Host on which the specified Docker Container can be located. For example `mcr.microsoft.com`
        :param str docker_container_tag: The Image Tag of the specified Docker Container to use. For example `latest`
        :param str dotnet_version: The version of .NET to use when `current_stack` is set to `dotnet`. Possible values include  `v2.0`,`v3.0`,`core3.1`, `v4.0`, `v5.0`, `v6.0` and `v7.0`.
        :param str java_container: The Java container type to use when `current_stack` is set to `java`. Possible values include `JAVA`, `JETTY`, and `TOMCAT`. Required with `java_version` and `java_container_version`.
        :param str java_container_version: The Version of the `java_container` to use. Required with `java_version` and `java_container`.
        :param str java_version: The version of Java to use when `current_stack` is set to `java`. Possible values include `1.7`, `1.8`, `11` and `17`. Required with `java_container` and `java_container_version`.
        :param str node_version: The version of node to use when `current_stack` is set to `node`. Possible values include `12-LTS`, `14-LTS`, and `16-LTS`.
        :param str php_version: The version of PHP to use when `current_stack` is set to `php`. Possible values include `v7.4`.
        :param str python_version: The version of Python to use when `current_stack` is set to `python`. Possible values include `2.7` and `3.4.0`.
        """
        if current_stack is not None:
            pulumi.set(__self__, "current_stack", current_stack)
        if docker_container_name is not None:
            pulumi.set(__self__, "docker_container_name", docker_container_name)
        if docker_container_registry is not None:
            pulumi.set(__self__, "docker_container_registry", docker_container_registry)
        if docker_container_tag is not None:
            pulumi.set(__self__, "docker_container_tag", docker_container_tag)
        if dotnet_version is not None:
            pulumi.set(__self__, "dotnet_version", dotnet_version)
        if java_container is not None:
            pulumi.set(__self__, "java_container", java_container)
        if java_container_version is not None:
            pulumi.set(__self__, "java_container_version", java_container_version)
        if java_version is not None:
            pulumi.set(__self__, "java_version", java_version)
        if node_version is not None:
            pulumi.set(__self__, "node_version", node_version)
        if php_version is not None:
            pulumi.set(__self__, "php_version", php_version)
        if python_version is not None:
            pulumi.set(__self__, "python_version", python_version)

    @property
    @pulumi.getter(name="currentStack")
    def current_stack(self) -> Optional[str]:
        """
        The Application Stack for the Windows Web App. Possible values include `dotnet`, `dotnetcore`, `node`, `python`, `php`, and `java`.
        """
        return pulumi.get(self, "current_stack")

    @property
    @pulumi.getter(name="dockerContainerName")
    def docker_container_name(self) -> Optional[str]:
        """
        The name of the Docker Container. For example `azure-app-service/samples/aspnethelloworld`
        """
        return pulumi.get(self, "docker_container_name")

    @property
    @pulumi.getter(name="dockerContainerRegistry")
    def docker_container_registry(self) -> Optional[str]:
        """
        The registry Host on which the specified Docker Container can be located. For example `mcr.microsoft.com`
        """
        return pulumi.get(self, "docker_container_registry")

    @property
    @pulumi.getter(name="dockerContainerTag")
    def docker_container_tag(self) -> Optional[str]:
        """
        The Image Tag of the specified Docker Container to use. For example `latest`
        """
        return pulumi.get(self, "docker_container_tag")

    @property
    @pulumi.getter(name="dotnetVersion")
    def dotnet_version(self) -> Optional[str]:
        """
        The version of .NET to use when `current_stack` is set to `dotnet`. Possible values include  `v2.0`,`v3.0`,`core3.1`, `v4.0`, `v5.0`, `v6.0` and `v7.0`.
        """
        return pulumi.get(self, "dotnet_version")

    @property
    @pulumi.getter(name="javaContainer")
    def java_container(self) -> Optional[str]:
        """
        The Java container type to use when `current_stack` is set to `java`. Possible values include `JAVA`, `JETTY`, and `TOMCAT`. Required with `java_version` and `java_container_version`.
        """
        return pulumi.get(self, "java_container")

    @property
    @pulumi.getter(name="javaContainerVersion")
    def java_container_version(self) -> Optional[str]:
        """
        The Version of the `java_container` to use. Required with `java_version` and `java_container`.
        """
        return pulumi.get(self, "java_container_version")

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> Optional[str]:
        """
        The version of Java to use when `current_stack` is set to `java`. Possible values include `1.7`, `1.8`, `11` and `17`. Required with `java_container` and `java_container_version`.
        """
        return pulumi.get(self, "java_version")

    @property
    @pulumi.getter(name="nodeVersion")
    def node_version(self) -> Optional[str]:
        """
        The version of node to use when `current_stack` is set to `node`. Possible values include `12-LTS`, `14-LTS`, and `16-LTS`.
        """
        return pulumi.get(self, "node_version")

    @property
    @pulumi.getter(name="phpVersion")
    def php_version(self) -> Optional[str]:
        """
        The version of PHP to use when `current_stack` is set to `php`. Possible values include `v7.4`.
        """
        return pulumi.get(self, "php_version")

    @property
    @pulumi.getter(name="pythonVersion")
    def python_version(self) -> Optional[str]:
        """
        The version of Python to use when `current_stack` is set to `python`. Possible values include `2.7` and `3.4.0`.
        """
        return pulumi.get(self, "python_version")


@pulumi.output_type
class WindowsWebAppSiteConfigAutoHealSetting(dict):
    def __init__(__self__, *,
                 action: 'outputs.WindowsWebAppSiteConfigAutoHealSettingAction',
                 trigger: 'outputs.WindowsWebAppSiteConfigAutoHealSettingTrigger'):
        """
        :param 'WindowsWebAppSiteConfigAutoHealSettingActionArgs' action: An `action` block as defined above.
        :param 'WindowsWebAppSiteConfigAutoHealSettingTriggerArgs' trigger: A `trigger` block as defined below.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "trigger", trigger)

    @property
    @pulumi.getter
    def action(self) -> 'outputs.WindowsWebAppSiteConfigAutoHealSettingAction':
        """
        An `action` block as defined above.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def trigger(self) -> 'outputs.WindowsWebAppSiteConfigAutoHealSettingTrigger':
        """
        A `trigger` block as defined below.
        """
        return pulumi.get(self, "trigger")


@pulumi.output_type
class WindowsWebAppSiteConfigAutoHealSettingAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionType":
            suggest = "action_type"
        elif key == "customAction":
            suggest = "custom_action"
        elif key == "minimumProcessExecutionTime":
            suggest = "minimum_process_execution_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSiteConfigAutoHealSettingAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSiteConfigAutoHealSettingAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSiteConfigAutoHealSettingAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_type: str,
                 custom_action: Optional['outputs.WindowsWebAppSiteConfigAutoHealSettingActionCustomAction'] = None,
                 minimum_process_execution_time: Optional[str] = None):
        """
        :param str action_type: Predefined action to be taken to an Auto Heal trigger. Possible values include: `Recycle`, `LogEvent`, and `CustomAction`.
        :param 'WindowsWebAppSiteConfigAutoHealSettingActionCustomActionArgs' custom_action: A `custom_action` block as defined below.
        :param str minimum_process_execution_time: The minimum amount of time in `hh:mm:ss` the Windows Web App must have been running before the defined action will be run in the event of a trigger.
        """
        pulumi.set(__self__, "action_type", action_type)
        if custom_action is not None:
            pulumi.set(__self__, "custom_action", custom_action)
        if minimum_process_execution_time is not None:
            pulumi.set(__self__, "minimum_process_execution_time", minimum_process_execution_time)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> str:
        """
        Predefined action to be taken to an Auto Heal trigger. Possible values include: `Recycle`, `LogEvent`, and `CustomAction`.
        """
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter(name="customAction")
    def custom_action(self) -> Optional['outputs.WindowsWebAppSiteConfigAutoHealSettingActionCustomAction']:
        """
        A `custom_action` block as defined below.
        """
        return pulumi.get(self, "custom_action")

    @property
    @pulumi.getter(name="minimumProcessExecutionTime")
    def minimum_process_execution_time(self) -> Optional[str]:
        """
        The minimum amount of time in `hh:mm:ss` the Windows Web App must have been running before the defined action will be run in the event of a trigger.
        """
        return pulumi.get(self, "minimum_process_execution_time")


@pulumi.output_type
class WindowsWebAppSiteConfigAutoHealSettingActionCustomAction(dict):
    def __init__(__self__, *,
                 executable: str,
                 parameters: Optional[str] = None):
        """
        :param str executable: The executable to run for the `custom_action`.
        :param str parameters: The parameters to pass to the specified `executable`.
        """
        pulumi.set(__self__, "executable", executable)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def executable(self) -> str:
        """
        The executable to run for the `custom_action`.
        """
        return pulumi.get(self, "executable")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[str]:
        """
        The parameters to pass to the specified `executable`.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class WindowsWebAppSiteConfigAutoHealSettingTrigger(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateMemoryKb":
            suggest = "private_memory_kb"
        elif key == "slowRequests":
            suggest = "slow_requests"
        elif key == "statusCodes":
            suggest = "status_codes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSiteConfigAutoHealSettingTrigger. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSiteConfigAutoHealSettingTrigger.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSiteConfigAutoHealSettingTrigger.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_memory_kb: Optional[int] = None,
                 requests: Optional['outputs.WindowsWebAppSiteConfigAutoHealSettingTriggerRequests'] = None,
                 slow_requests: Optional[Sequence['outputs.WindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequest']] = None,
                 status_codes: Optional[Sequence['outputs.WindowsWebAppSiteConfigAutoHealSettingTriggerStatusCode']] = None):
        """
        :param int private_memory_kb: The amount of Private Memory to be consumed for this rule to trigger. Possible values are between `102400` and  `13631488`.
        :param 'WindowsWebAppSiteConfigAutoHealSettingTriggerRequestsArgs' requests: A `requests` block as defined above.
        :param Sequence['WindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequestArgs'] slow_requests: One or more `slow_request` blocks as defined above.
        :param Sequence['WindowsWebAppSiteConfigAutoHealSettingTriggerStatusCodeArgs'] status_codes: One or more `status_code` blocks as defined above.
        """
        if private_memory_kb is not None:
            pulumi.set(__self__, "private_memory_kb", private_memory_kb)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if slow_requests is not None:
            pulumi.set(__self__, "slow_requests", slow_requests)
        if status_codes is not None:
            pulumi.set(__self__, "status_codes", status_codes)

    @property
    @pulumi.getter(name="privateMemoryKb")
    def private_memory_kb(self) -> Optional[int]:
        """
        The amount of Private Memory to be consumed for this rule to trigger. Possible values are between `102400` and  `13631488`.
        """
        return pulumi.get(self, "private_memory_kb")

    @property
    @pulumi.getter
    def requests(self) -> Optional['outputs.WindowsWebAppSiteConfigAutoHealSettingTriggerRequests']:
        """
        A `requests` block as defined above.
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="slowRequests")
    def slow_requests(self) -> Optional[Sequence['outputs.WindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequest']]:
        """
        One or more `slow_request` blocks as defined above.
        """
        return pulumi.get(self, "slow_requests")

    @property
    @pulumi.getter(name="statusCodes")
    def status_codes(self) -> Optional[Sequence['outputs.WindowsWebAppSiteConfigAutoHealSettingTriggerStatusCode']]:
        """
        One or more `status_code` blocks as defined above.
        """
        return pulumi.get(self, "status_codes")


@pulumi.output_type
class WindowsWebAppSiteConfigAutoHealSettingTriggerRequests(dict):
    def __init__(__self__, *,
                 count: int,
                 interval: str):
        """
        :param int count: The number of requests in the specified `interval` to trigger this rule.
        :param str interval: The interval in `hh:mm:ss`.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of requests in the specified `interval` to trigger this rule.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        The interval in `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class WindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeTaken":
            suggest = "time_taken"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: int,
                 interval: str,
                 time_taken: str,
                 path: Optional[str] = None):
        """
        :param int count: The number of Slow Requests in the time `interval` to trigger this rule.
        :param str interval: The time interval in the form `hh:mm:ss`.
        :param str time_taken: The threshold of time passed to qualify as a Slow Request in `hh:mm:ss`.
        :param str path: The path for which this slow request rule applies.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "time_taken", time_taken)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of Slow Requests in the time `interval` to trigger this rule.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        The time interval in the form `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="timeTaken")
    def time_taken(self) -> str:
        """
        The threshold of time passed to qualify as a Slow Request in `hh:mm:ss`.
        """
        return pulumi.get(self, "time_taken")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path for which this slow request rule applies.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class WindowsWebAppSiteConfigAutoHealSettingTriggerStatusCode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusCodeRange":
            suggest = "status_code_range"
        elif key == "subStatus":
            suggest = "sub_status"
        elif key == "win32Status":
            suggest = "win32_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSiteConfigAutoHealSettingTriggerStatusCode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSiteConfigAutoHealSettingTriggerStatusCode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSiteConfigAutoHealSettingTriggerStatusCode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: int,
                 interval: str,
                 status_code_range: str,
                 path: Optional[str] = None,
                 sub_status: Optional[int] = None,
                 win32_status: Optional[str] = None):
        """
        :param int count: The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        :param str interval: The time interval in the form `hh:mm:ss`.
        :param str status_code_range: The status code for this rule, accepts single status codes and status code ranges. e.g. `500` or `400-499`. Possible values are integers between `101` and `599`
        :param str path: The path to which this rule status code applies.
        :param int sub_status: The Request Sub Status of the Status Code.
        :param str win32_status: The Win32 Status Code of the Request.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "status_code_range", status_code_range)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if sub_status is not None:
            pulumi.set(__self__, "sub_status", sub_status)
        if win32_status is not None:
            pulumi.set(__self__, "win32_status", win32_status)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        The time interval in the form `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="statusCodeRange")
    def status_code_range(self) -> str:
        """
        The status code for this rule, accepts single status codes and status code ranges. e.g. `500` or `400-499`. Possible values are integers between `101` and `599`
        """
        return pulumi.get(self, "status_code_range")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path to which this rule status code applies.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="subStatus")
    def sub_status(self) -> Optional[int]:
        """
        The Request Sub Status of the Status Code.
        """
        return pulumi.get(self, "sub_status")

    @property
    @pulumi.getter(name="win32Status")
    def win32_status(self) -> Optional[str]:
        """
        The Win32 Status Code of the Request.
        """
        return pulumi.get(self, "win32_status")


@pulumi.output_type
class WindowsWebAppSiteConfigCors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedOrigins":
            suggest = "allowed_origins"
        elif key == "supportCredentials":
            suggest = "support_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSiteConfigCors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSiteConfigCors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSiteConfigCors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_origins: Sequence[str],
                 support_credentials: Optional[bool] = None):
        """
        :param Sequence[str] allowed_origins: Specifies a list of origins that should be allowed to make cross-origin calls.
        :param bool support_credentials: Whether CORS requests with credentials are allowed. Defaults to `false`
        """
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        if support_credentials is not None:
            pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Sequence[str]:
        """
        Specifies a list of origins that should be allowed to make cross-origin calls.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> Optional[bool]:
        """
        Whether CORS requests with credentials are allowed. Defaults to `false`
        """
        return pulumi.get(self, "support_credentials")


@pulumi.output_type
class WindowsWebAppSiteConfigIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSiteConfigIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSiteConfigIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSiteConfigIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.WindowsWebAppSiteConfigIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: The action to take. Possible values are `Allow` or `Deny`.
        :param 'WindowsWebAppSiteConfigIpRestrictionHeadersArgs' headers: A `headers` block as defined above.
        :param str ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param str name: The name which should be used for this `ip_restriction`.
        :param int priority: The priority value of this `ip_restriction`.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        The action to take. Possible values are `Allow` or `Deny`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.WindowsWebAppSiteConfigIpRestrictionHeaders']:
        """
        A `headers` block as defined above.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority value of this `ip_restriction`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class WindowsWebAppSiteConfigIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSiteConfigIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param str x_fd_health_probe: Specifies if a Front Door Health Probe should be expected.
        :param Sequence[str] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param Sequence[str] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        Specifies if a Front Door Health Probe should be expected.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class WindowsWebAppSiteConfigScmIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSiteConfigScmIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSiteConfigScmIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSiteConfigScmIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.WindowsWebAppSiteConfigScmIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: The action to take. Possible values are `Allow` or `Deny`.
        :param 'WindowsWebAppSiteConfigScmIpRestrictionHeadersArgs' headers: A `headers` block as defined above.
        :param str ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param str name: The name which should be used for this `ip_restriction`.
        :param int priority: The priority value of this `ip_restriction`.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        The action to take. Possible values are `Allow` or `Deny`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.WindowsWebAppSiteConfigScmIpRestrictionHeaders']:
        """
        A `headers` block as defined above.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority value of this `ip_restriction`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class WindowsWebAppSiteConfigScmIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSiteConfigScmIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param str x_fd_health_probe: Specifies if a Front Door Health Probe should be expected.
        :param Sequence[str] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param Sequence[str] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        Specifies if a Front Door Health Probe should be expected.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class WindowsWebAppSiteConfigVirtualApplication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "physicalPath":
            suggest = "physical_path"
        elif key == "virtualPath":
            suggest = "virtual_path"
        elif key == "virtualDirectories":
            suggest = "virtual_directories"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSiteConfigVirtualApplication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSiteConfigVirtualApplication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSiteConfigVirtualApplication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 physical_path: str,
                 preload: bool,
                 virtual_path: str,
                 virtual_directories: Optional[Sequence['outputs.WindowsWebAppSiteConfigVirtualApplicationVirtualDirectory']] = None):
        """
        :param str physical_path: The physical path for the Virtual Application.
        :param bool preload: Should pre-loading be enabled. Defaults to `false`.
        :param str virtual_path: The Virtual Path for the Virtual Application.
        :param Sequence['WindowsWebAppSiteConfigVirtualApplicationVirtualDirectoryArgs'] virtual_directories: One or more `virtual_directory` blocks as defined below.
        """
        pulumi.set(__self__, "physical_path", physical_path)
        pulumi.set(__self__, "preload", preload)
        pulumi.set(__self__, "virtual_path", virtual_path)
        if virtual_directories is not None:
            pulumi.set(__self__, "virtual_directories", virtual_directories)

    @property
    @pulumi.getter(name="physicalPath")
    def physical_path(self) -> str:
        """
        The physical path for the Virtual Application.
        """
        return pulumi.get(self, "physical_path")

    @property
    @pulumi.getter
    def preload(self) -> bool:
        """
        Should pre-loading be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "preload")

    @property
    @pulumi.getter(name="virtualPath")
    def virtual_path(self) -> str:
        """
        The Virtual Path for the Virtual Application.
        """
        return pulumi.get(self, "virtual_path")

    @property
    @pulumi.getter(name="virtualDirectories")
    def virtual_directories(self) -> Optional[Sequence['outputs.WindowsWebAppSiteConfigVirtualApplicationVirtualDirectory']]:
        """
        One or more `virtual_directory` blocks as defined below.
        """
        return pulumi.get(self, "virtual_directories")


@pulumi.output_type
class WindowsWebAppSiteConfigVirtualApplicationVirtualDirectory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "physicalPath":
            suggest = "physical_path"
        elif key == "virtualPath":
            suggest = "virtual_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSiteConfigVirtualApplicationVirtualDirectory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSiteConfigVirtualApplicationVirtualDirectory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSiteConfigVirtualApplicationVirtualDirectory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 physical_path: Optional[str] = None,
                 virtual_path: Optional[str] = None):
        """
        :param str physical_path: The physical path for the Virtual Application.
        :param str virtual_path: The Virtual Path for the Virtual Application.
        """
        if physical_path is not None:
            pulumi.set(__self__, "physical_path", physical_path)
        if virtual_path is not None:
            pulumi.set(__self__, "virtual_path", virtual_path)

    @property
    @pulumi.getter(name="physicalPath")
    def physical_path(self) -> Optional[str]:
        """
        The physical path for the Virtual Application.
        """
        return pulumi.get(self, "physical_path")

    @property
    @pulumi.getter(name="virtualPath")
    def virtual_path(self) -> Optional[str]:
        """
        The Virtual Path for the Virtual Application.
        """
        return pulumi.get(self, "virtual_path")


@pulumi.output_type
class WindowsWebAppSiteCredential(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 password: Optional[str] = None):
        """
        :param str name: The name which should be used for this Windows Web App. Changing this forces a new Windows Web App to be created.
        :param str password: The Site Credentials Password used for publishing.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name which should be used for this Windows Web App. Changing this forces a new Windows Web App to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The Site Credentials Password used for publishing.
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class WindowsWebAppSlotAuthSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeDirectory":
            suggest = "active_directory"
        elif key == "additionalLoginParameters":
            suggest = "additional_login_parameters"
        elif key == "allowedExternalRedirectUrls":
            suggest = "allowed_external_redirect_urls"
        elif key == "defaultProvider":
            suggest = "default_provider"
        elif key == "runtimeVersion":
            suggest = "runtime_version"
        elif key == "tokenRefreshExtensionHours":
            suggest = "token_refresh_extension_hours"
        elif key == "tokenStoreEnabled":
            suggest = "token_store_enabled"
        elif key == "unauthenticatedClientAction":
            suggest = "unauthenticated_client_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotAuthSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotAuthSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotAuthSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 active_directory: Optional['outputs.WindowsWebAppSlotAuthSettingsActiveDirectory'] = None,
                 additional_login_parameters: Optional[Mapping[str, str]] = None,
                 allowed_external_redirect_urls: Optional[Sequence[str]] = None,
                 default_provider: Optional[str] = None,
                 facebook: Optional['outputs.WindowsWebAppSlotAuthSettingsFacebook'] = None,
                 github: Optional['outputs.WindowsWebAppSlotAuthSettingsGithub'] = None,
                 google: Optional['outputs.WindowsWebAppSlotAuthSettingsGoogle'] = None,
                 issuer: Optional[str] = None,
                 microsoft: Optional['outputs.WindowsWebAppSlotAuthSettingsMicrosoft'] = None,
                 runtime_version: Optional[str] = None,
                 token_refresh_extension_hours: Optional[float] = None,
                 token_store_enabled: Optional[bool] = None,
                 twitter: Optional['outputs.WindowsWebAppSlotAuthSettingsTwitter'] = None,
                 unauthenticated_client_action: Optional[str] = None):
        """
        :param bool enabled: Should the Authentication / Authorization feature be enabled for the Windows Web App?
        :param 'WindowsWebAppSlotAuthSettingsActiveDirectoryArgs' active_directory: An `active_directory` block as defined above.
        :param Mapping[str, str] additional_login_parameters: Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        :param Sequence[str] allowed_external_redirect_urls: Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Windows Web App Slot.
        :param str default_provider: The default authentication provider to use when multiple providers are configured. Possible values include: `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount`, `Twitter`, `Github`.
        :param 'WindowsWebAppSlotAuthSettingsFacebookArgs' facebook: A `facebook` block as defined below.
        :param 'WindowsWebAppSlotAuthSettingsGithubArgs' github: A `github` block as defined below.
        :param 'WindowsWebAppSlotAuthSettingsGoogleArgs' google: A `google` block as defined below.
        :param str issuer: The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Windows Web App Slot.
        :param 'WindowsWebAppSlotAuthSettingsMicrosoftArgs' microsoft: A `microsoft` block as defined below.
        :param str runtime_version: The RuntimeVersion of the Authentication / Authorization feature in use for the Windows Web App Slot.
        :param float token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        :param bool token_store_enabled: Should the Windows Web App Slot durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        :param 'WindowsWebAppSlotAuthSettingsTwitterArgs' twitter: A `twitter` block as defined below.
        :param str unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if active_directory is not None:
            pulumi.set(__self__, "active_directory", active_directory)
        if additional_login_parameters is not None:
            pulumi.set(__self__, "additional_login_parameters", additional_login_parameters)
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if facebook is not None:
            pulumi.set(__self__, "facebook", facebook)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if google is not None:
            pulumi.set(__self__, "google", google)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if microsoft is not None:
            pulumi.set(__self__, "microsoft", microsoft)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if token_refresh_extension_hours is not None:
            pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if twitter is not None:
            pulumi.set(__self__, "twitter", twitter)
        if unauthenticated_client_action is not None:
            pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Should the Authentication / Authorization feature be enabled for the Windows Web App?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="activeDirectory")
    def active_directory(self) -> Optional['outputs.WindowsWebAppSlotAuthSettingsActiveDirectory']:
        """
        An `active_directory` block as defined above.
        """
        return pulumi.get(self, "active_directory")

    @property
    @pulumi.getter(name="additionalLoginParameters")
    def additional_login_parameters(self) -> Optional[Mapping[str, str]]:
        """
        Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        """
        return pulumi.get(self, "additional_login_parameters")

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Windows Web App Slot.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[str]:
        """
        The default authentication provider to use when multiple providers are configured. Possible values include: `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount`, `Twitter`, `Github`.
        """
        return pulumi.get(self, "default_provider")

    @property
    @pulumi.getter
    def facebook(self) -> Optional['outputs.WindowsWebAppSlotAuthSettingsFacebook']:
        """
        A `facebook` block as defined below.
        """
        return pulumi.get(self, "facebook")

    @property
    @pulumi.getter
    def github(self) -> Optional['outputs.WindowsWebAppSlotAuthSettingsGithub']:
        """
        A `github` block as defined below.
        """
        return pulumi.get(self, "github")

    @property
    @pulumi.getter
    def google(self) -> Optional['outputs.WindowsWebAppSlotAuthSettingsGoogle']:
        """
        A `google` block as defined below.
        """
        return pulumi.get(self, "google")

    @property
    @pulumi.getter
    def issuer(self) -> Optional[str]:
        """
        The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Windows Web App Slot.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def microsoft(self) -> Optional['outputs.WindowsWebAppSlotAuthSettingsMicrosoft']:
        """
        A `microsoft` block as defined below.
        """
        return pulumi.get(self, "microsoft")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[str]:
        """
        The RuntimeVersion of the Authentication / Authorization feature in use for the Windows Web App Slot.
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> Optional[float]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        return pulumi.get(self, "token_refresh_extension_hours")

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[bool]:
        """
        Should the Windows Web App Slot durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        """
        return pulumi.get(self, "token_store_enabled")

    @property
    @pulumi.getter
    def twitter(self) -> Optional['outputs.WindowsWebAppSlotAuthSettingsTwitter']:
        """
        A `twitter` block as defined below.
        """
        return pulumi.get(self, "twitter")

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> Optional[str]:
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        return pulumi.get(self, "unauthenticated_client_action")


@pulumi.output_type
class WindowsWebAppSlotAuthSettingsActiveDirectory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotAuthSettingsActiveDirectory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotAuthSettingsActiveDirectory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotAuthSettingsActiveDirectory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None):
        """
        :param str client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param Sequence[str] allowed_audiences: Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
        :param str client_secret: The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        :param str client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        pulumi.set(__self__, "client_id", client_id)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")


@pulumi.output_type
class WindowsWebAppSlotAuthSettingsFacebook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "appSecret":
            suggest = "app_secret"
        elif key == "appSecretSettingName":
            suggest = "app_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotAuthSettingsFacebook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotAuthSettingsFacebook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotAuthSettingsFacebook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: str,
                 app_secret: Optional[str] = None,
                 app_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str app_id: The App ID of the Facebook app used for login.
        :param str app_secret: The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        :param str app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        if app_secret is not None:
            pulumi.set(__self__, "app_secret", app_secret)
        if app_secret_setting_name is not None:
            pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appSecret")
    def app_secret(self) -> Optional[str]:
        """
        The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        """
        return pulumi.get(self, "app_secret")

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class WindowsWebAppSlotAuthSettingsGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotAuthSettingsGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotAuthSettingsGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotAuthSettingsGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The ID of the GitHub app used for login.
        :param str client_secret: The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The ID of the GitHub app used for login.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class WindowsWebAppSlotAuthSettingsGoogle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotAuthSettingsGoogle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotAuthSettingsGoogle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotAuthSettingsGoogle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OpenID Connect Client ID for the Google web application.
        :param str client_secret: The client secret associated with the Google web application.  Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OpenID Connect Client ID for the Google web application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The client secret associated with the Google web application.  Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class WindowsWebAppSlotAuthSettingsMicrosoft(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotAuthSettingsMicrosoft. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotAuthSettingsMicrosoft.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotAuthSettingsMicrosoft.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 oauth_scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret: The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        :param Sequence[str] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, "wl.basic" is used as the default scope.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, "wl.basic" is used as the default scope.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class WindowsWebAppSlotAuthSettingsTwitter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerKey":
            suggest = "consumer_key"
        elif key == "consumerSecret":
            suggest = "consumer_secret"
        elif key == "consumerSecretSettingName":
            suggest = "consumer_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotAuthSettingsTwitter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotAuthSettingsTwitter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotAuthSettingsTwitter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_key: str,
                 consumer_secret: Optional[str] = None,
                 consumer_secret_setting_name: Optional[str] = None):
        """
        :param str consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param str consumer_secret: The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        :param str consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        if consumer_secret is not None:
            pulumi.set(__self__, "consumer_secret", consumer_secret)
        if consumer_secret_setting_name is not None:
            pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> str:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> Optional[str]:
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        """
        return pulumi.get(self, "consumer_secret")

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        return pulumi.get(self, "consumer_secret_setting_name")


@pulumi.output_type
class WindowsWebAppSlotBackup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageAccountUrl":
            suggest = "storage_account_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotBackup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotBackup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotBackup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 schedule: 'outputs.WindowsWebAppSlotBackupSchedule',
                 storage_account_url: str,
                 enabled: Optional[bool] = None):
        """
        :param str name: The name which should be used for this Backup.
        :param 'WindowsWebAppSlotBackupScheduleArgs' schedule: A `schedule` block as defined below.
        :param str storage_account_url: The SAS URL to the container.
        :param bool enabled: Should this backup job be enabled?
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "storage_account_url", storage_account_url)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Backup.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def schedule(self) -> 'outputs.WindowsWebAppSlotBackupSchedule':
        """
        A `schedule` block as defined below.
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter(name="storageAccountUrl")
    def storage_account_url(self) -> str:
        """
        The SAS URL to the container.
        """
        return pulumi.get(self, "storage_account_url")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Should this backup job be enabled?
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class WindowsWebAppSlotBackupSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "frequencyUnit":
            suggest = "frequency_unit"
        elif key == "keepAtLeastOneBackup":
            suggest = "keep_at_least_one_backup"
        elif key == "lastExecutionTime":
            suggest = "last_execution_time"
        elif key == "retentionPeriodDays":
            suggest = "retention_period_days"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotBackupSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotBackupSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotBackupSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_unit: str,
                 keep_at_least_one_backup: Optional[bool] = None,
                 last_execution_time: Optional[str] = None,
                 retention_period_days: Optional[int] = None,
                 start_time: Optional[str] = None):
        """
        :param int frequency_interval: How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).
        :param str frequency_unit: The unit of time for how often the backup should take place. Possible values include: `Day`, `Hour`
        :param bool keep_at_least_one_backup: Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
        :param int retention_period_days: After how many days backups should be deleted.
        :param str start_time: When the schedule should start working in RFC-3339 format.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_unit", frequency_unit)
        if keep_at_least_one_backup is not None:
            pulumi.set(__self__, "keep_at_least_one_backup", keep_at_least_one_backup)
        if last_execution_time is not None:
            pulumi.set(__self__, "last_execution_time", last_execution_time)
        if retention_period_days is not None:
            pulumi.set(__self__, "retention_period_days", retention_period_days)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyUnit")
    def frequency_unit(self) -> str:
        """
        The unit of time for how often the backup should take place. Possible values include: `Day`, `Hour`
        """
        return pulumi.get(self, "frequency_unit")

    @property
    @pulumi.getter(name="keepAtLeastOneBackup")
    def keep_at_least_one_backup(self) -> Optional[bool]:
        """
        Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
        """
        return pulumi.get(self, "keep_at_least_one_backup")

    @property
    @pulumi.getter(name="lastExecutionTime")
    def last_execution_time(self) -> Optional[str]:
        return pulumi.get(self, "last_execution_time")

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> Optional[int]:
        """
        After how many days backups should be deleted.
        """
        return pulumi.get(self, "retention_period_days")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        """
        When the schedule should start working in RFC-3339 format.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class WindowsWebAppSlotConnectionString(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: The name which should be used for this Windows Web App Slot. Changing this forces a new Windows Web App Slot to be created.
        :param str type: Type of database. Possible values include: `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
        :param str value: The connection string value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Windows Web App Slot. Changing this forces a new Windows Web App Slot to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of database. Possible values include: `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The connection string value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class WindowsWebAppSlotIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 identity_ids: Optional[Sequence[str]] = None,
                 principal_id: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str type: Specifies the type of Managed Service Identity that should be configured on this Windows Web App Slot. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        :param Sequence[str] identity_ids: A list of User Assigned Managed Identity IDs to be assigned to this Windows Web App Slot.
        :param str principal_id: The Principal ID associated with this Managed Service Identity.
        :param str tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the type of Managed Service Identity that should be configured on this Windows Web App Slot. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[str]]:
        """
        A list of User Assigned Managed Identity IDs to be assigned to this Windows Web App Slot.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class WindowsWebAppSlotLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationLogs":
            suggest = "application_logs"
        elif key == "detailedErrorMessages":
            suggest = "detailed_error_messages"
        elif key == "failedRequestTracing":
            suggest = "failed_request_tracing"
        elif key == "httpLogs":
            suggest = "http_logs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_logs: Optional['outputs.WindowsWebAppSlotLogsApplicationLogs'] = None,
                 detailed_error_messages: Optional[bool] = None,
                 failed_request_tracing: Optional[bool] = None,
                 http_logs: Optional['outputs.WindowsWebAppSlotLogsHttpLogs'] = None):
        """
        :param 'WindowsWebAppSlotLogsApplicationLogsArgs' application_logs: A `application_logs` block as defined above.
        :param bool detailed_error_messages: Should detailed error messages be enabled.
        :param bool failed_request_tracing: Should failed request tracing be enabled.
        :param 'WindowsWebAppSlotLogsHttpLogsArgs' http_logs: An `http_logs` block as defined above.
        """
        if application_logs is not None:
            pulumi.set(__self__, "application_logs", application_logs)
        if detailed_error_messages is not None:
            pulumi.set(__self__, "detailed_error_messages", detailed_error_messages)
        if failed_request_tracing is not None:
            pulumi.set(__self__, "failed_request_tracing", failed_request_tracing)
        if http_logs is not None:
            pulumi.set(__self__, "http_logs", http_logs)

    @property
    @pulumi.getter(name="applicationLogs")
    def application_logs(self) -> Optional['outputs.WindowsWebAppSlotLogsApplicationLogs']:
        """
        A `application_logs` block as defined above.
        """
        return pulumi.get(self, "application_logs")

    @property
    @pulumi.getter(name="detailedErrorMessages")
    def detailed_error_messages(self) -> Optional[bool]:
        """
        Should detailed error messages be enabled.
        """
        return pulumi.get(self, "detailed_error_messages")

    @property
    @pulumi.getter(name="failedRequestTracing")
    def failed_request_tracing(self) -> Optional[bool]:
        """
        Should failed request tracing be enabled.
        """
        return pulumi.get(self, "failed_request_tracing")

    @property
    @pulumi.getter(name="httpLogs")
    def http_logs(self) -> Optional['outputs.WindowsWebAppSlotLogsHttpLogs']:
        """
        An `http_logs` block as defined above.
        """
        return pulumi.get(self, "http_logs")


@pulumi.output_type
class WindowsWebAppSlotLogsApplicationLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileSystemLevel":
            suggest = "file_system_level"
        elif key == "azureBlobStorage":
            suggest = "azure_blob_storage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotLogsApplicationLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotLogsApplicationLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotLogsApplicationLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_system_level: str,
                 azure_blob_storage: Optional['outputs.WindowsWebAppSlotLogsApplicationLogsAzureBlobStorage'] = None):
        """
        :param str file_system_level: Log level. Possible values include: `Verbose`, `Information`, `Warning`, and `Error`.
        :param 'WindowsWebAppSlotLogsApplicationLogsAzureBlobStorageArgs' azure_blob_storage: An `azure_blob_storage` block as defined below.
        """
        pulumi.set(__self__, "file_system_level", file_system_level)
        if azure_blob_storage is not None:
            pulumi.set(__self__, "azure_blob_storage", azure_blob_storage)

    @property
    @pulumi.getter(name="fileSystemLevel")
    def file_system_level(self) -> str:
        """
        Log level. Possible values include: `Verbose`, `Information`, `Warning`, and `Error`.
        """
        return pulumi.get(self, "file_system_level")

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional['outputs.WindowsWebAppSlotLogsApplicationLogsAzureBlobStorage']:
        """
        An `azure_blob_storage` block as defined below.
        """
        return pulumi.get(self, "azure_blob_storage")


@pulumi.output_type
class WindowsWebAppSlotLogsApplicationLogsAzureBlobStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retentionInDays":
            suggest = "retention_in_days"
        elif key == "sasUrl":
            suggest = "sas_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotLogsApplicationLogsAzureBlobStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotLogsApplicationLogsAzureBlobStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotLogsApplicationLogsAzureBlobStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 level: str,
                 retention_in_days: int,
                 sas_url: str):
        """
        :param str level: The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        :param int retention_in_days: The time in days after which to remove blobs. A value of `0` means no retention.
        :param str sas_url: SAS url to an Azure blob container with read/write/list/delete permissions.
        """
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "sas_url", sas_url)

    @property
    @pulumi.getter
    def level(self) -> str:
        """
        The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        """
        return pulumi.get(self, "level")

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> int:
        """
        The time in days after which to remove blobs. A value of `0` means no retention.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> str:
        """
        SAS url to an Azure blob container with read/write/list/delete permissions.
        """
        return pulumi.get(self, "sas_url")


@pulumi.output_type
class WindowsWebAppSlotLogsHttpLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureBlobStorage":
            suggest = "azure_blob_storage"
        elif key == "fileSystem":
            suggest = "file_system"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotLogsHttpLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotLogsHttpLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotLogsHttpLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_blob_storage: Optional['outputs.WindowsWebAppSlotLogsHttpLogsAzureBlobStorage'] = None,
                 file_system: Optional['outputs.WindowsWebAppSlotLogsHttpLogsFileSystem'] = None):
        """
        :param 'WindowsWebAppSlotLogsHttpLogsAzureBlobStorageArgs' azure_blob_storage: A `azure_blob_storage` block as defined above.
        :param 'WindowsWebAppSlotLogsHttpLogsFileSystemArgs' file_system: A `file_system` block as defined above.
        """
        if azure_blob_storage is not None:
            pulumi.set(__self__, "azure_blob_storage", azure_blob_storage)
        if file_system is not None:
            pulumi.set(__self__, "file_system", file_system)

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional['outputs.WindowsWebAppSlotLogsHttpLogsAzureBlobStorage']:
        """
        A `azure_blob_storage` block as defined above.
        """
        return pulumi.get(self, "azure_blob_storage")

    @property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional['outputs.WindowsWebAppSlotLogsHttpLogsFileSystem']:
        """
        A `file_system` block as defined above.
        """
        return pulumi.get(self, "file_system")


@pulumi.output_type
class WindowsWebAppSlotLogsHttpLogsAzureBlobStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sasUrl":
            suggest = "sas_url"
        elif key == "retentionInDays":
            suggest = "retention_in_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotLogsHttpLogsAzureBlobStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotLogsHttpLogsAzureBlobStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotLogsHttpLogsAzureBlobStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sas_url: str,
                 retention_in_days: Optional[int] = None):
        """
        :param str sas_url: SAS url to an Azure blob container with read/write/list/delete permissions.
        :param int retention_in_days: The time in days after which to remove blobs. A value of `0` means no retention.
        """
        pulumi.set(__self__, "sas_url", sas_url)
        if retention_in_days is not None:
            pulumi.set(__self__, "retention_in_days", retention_in_days)

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> str:
        """
        SAS url to an Azure blob container with read/write/list/delete permissions.
        """
        return pulumi.get(self, "sas_url")

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> Optional[int]:
        """
        The time in days after which to remove blobs. A value of `0` means no retention.
        """
        return pulumi.get(self, "retention_in_days")


@pulumi.output_type
class WindowsWebAppSlotLogsHttpLogsFileSystem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retentionInDays":
            suggest = "retention_in_days"
        elif key == "retentionInMb":
            suggest = "retention_in_mb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotLogsHttpLogsFileSystem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotLogsHttpLogsFileSystem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotLogsHttpLogsFileSystem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 retention_in_days: int,
                 retention_in_mb: int):
        """
        :param int retention_in_days: The retention period in days. A values of `0` means no retention.
        :param int retention_in_mb: The maximum size in megabytes that log files can use.
        """
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "retention_in_mb", retention_in_mb)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> int:
        """
        The retention period in days. A values of `0` means no retention.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="retentionInMb")
    def retention_in_mb(self) -> int:
        """
        The maximum size in megabytes that log files can use.
        """
        return pulumi.get(self, "retention_in_mb")


@pulumi.output_type
class WindowsWebAppSlotSiteConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alwaysOn":
            suggest = "always_on"
        elif key == "apiDefinitionUrl":
            suggest = "api_definition_url"
        elif key == "apiManagementApiId":
            suggest = "api_management_api_id"
        elif key == "appCommandLine":
            suggest = "app_command_line"
        elif key == "applicationStack":
            suggest = "application_stack"
        elif key == "autoHealEnabled":
            suggest = "auto_heal_enabled"
        elif key == "autoHealSetting":
            suggest = "auto_heal_setting"
        elif key == "autoSwapSlotName":
            suggest = "auto_swap_slot_name"
        elif key == "containerRegistryManagedIdentityClientId":
            suggest = "container_registry_managed_identity_client_id"
        elif key == "containerRegistryUseManagedIdentity":
            suggest = "container_registry_use_managed_identity"
        elif key == "defaultDocuments":
            suggest = "default_documents"
        elif key == "detailedErrorLoggingEnabled":
            suggest = "detailed_error_logging_enabled"
        elif key == "ftpsState":
            suggest = "ftps_state"
        elif key == "healthCheckEvictionTimeInMin":
            suggest = "health_check_eviction_time_in_min"
        elif key == "healthCheckPath":
            suggest = "health_check_path"
        elif key == "http2Enabled":
            suggest = "http2_enabled"
        elif key == "ipRestrictions":
            suggest = "ip_restrictions"
        elif key == "loadBalancingMode":
            suggest = "load_balancing_mode"
        elif key == "localMysqlEnabled":
            suggest = "local_mysql_enabled"
        elif key == "managedPipelineMode":
            suggest = "managed_pipeline_mode"
        elif key == "minimumTlsVersion":
            suggest = "minimum_tls_version"
        elif key == "remoteDebuggingEnabled":
            suggest = "remote_debugging_enabled"
        elif key == "remoteDebuggingVersion":
            suggest = "remote_debugging_version"
        elif key == "scmIpRestrictions":
            suggest = "scm_ip_restrictions"
        elif key == "scmMinimumTlsVersion":
            suggest = "scm_minimum_tls_version"
        elif key == "scmType":
            suggest = "scm_type"
        elif key == "scmUseMainIpRestriction":
            suggest = "scm_use_main_ip_restriction"
        elif key == "use32BitWorker":
            suggest = "use32_bit_worker"
        elif key == "virtualApplications":
            suggest = "virtual_applications"
        elif key == "vnetRouteAllEnabled":
            suggest = "vnet_route_all_enabled"
        elif key == "websocketsEnabled":
            suggest = "websockets_enabled"
        elif key == "windowsFxVersion":
            suggest = "windows_fx_version"
        elif key == "workerCount":
            suggest = "worker_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotSiteConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotSiteConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotSiteConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 always_on: Optional[bool] = None,
                 api_definition_url: Optional[str] = None,
                 api_management_api_id: Optional[str] = None,
                 app_command_line: Optional[str] = None,
                 application_stack: Optional['outputs.WindowsWebAppSlotSiteConfigApplicationStack'] = None,
                 auto_heal_enabled: Optional[bool] = None,
                 auto_heal_setting: Optional['outputs.WindowsWebAppSlotSiteConfigAutoHealSetting'] = None,
                 auto_swap_slot_name: Optional[str] = None,
                 container_registry_managed_identity_client_id: Optional[str] = None,
                 container_registry_use_managed_identity: Optional[bool] = None,
                 cors: Optional['outputs.WindowsWebAppSlotSiteConfigCors'] = None,
                 default_documents: Optional[Sequence[str]] = None,
                 detailed_error_logging_enabled: Optional[bool] = None,
                 ftps_state: Optional[str] = None,
                 health_check_eviction_time_in_min: Optional[int] = None,
                 health_check_path: Optional[str] = None,
                 http2_enabled: Optional[bool] = None,
                 ip_restrictions: Optional[Sequence['outputs.WindowsWebAppSlotSiteConfigIpRestriction']] = None,
                 load_balancing_mode: Optional[str] = None,
                 local_mysql_enabled: Optional[bool] = None,
                 managed_pipeline_mode: Optional[str] = None,
                 minimum_tls_version: Optional[str] = None,
                 remote_debugging_enabled: Optional[bool] = None,
                 remote_debugging_version: Optional[str] = None,
                 scm_ip_restrictions: Optional[Sequence['outputs.WindowsWebAppSlotSiteConfigScmIpRestriction']] = None,
                 scm_minimum_tls_version: Optional[str] = None,
                 scm_type: Optional[str] = None,
                 scm_use_main_ip_restriction: Optional[bool] = None,
                 use32_bit_worker: Optional[bool] = None,
                 virtual_applications: Optional[Sequence['outputs.WindowsWebAppSlotSiteConfigVirtualApplication']] = None,
                 vnet_route_all_enabled: Optional[bool] = None,
                 websockets_enabled: Optional[bool] = None,
                 windows_fx_version: Optional[str] = None,
                 worker_count: Optional[int] = None):
        """
        :param bool always_on: If this Windows Web App Slot is Always On enabled. Defaults to `false`.
        :param str api_definition_url: The URL to the API Definition for this Windows Web App Slot.
        :param str api_management_api_id: The API Management API ID this Windows Web App Slot os associated with.
        :param str app_command_line: The App command line to launch.
        :param 'WindowsWebAppSlotSiteConfigApplicationStackArgs' application_stack: A `application_stack` block as defined above.
        :param bool auto_heal_enabled: Should Auto heal rules be enabled. Required with `auto_heal_setting`.
        :param 'WindowsWebAppSlotSiteConfigAutoHealSettingArgs' auto_heal_setting: A `auto_heal_setting` block as defined above. Required with `auto_heal`.
        :param str auto_swap_slot_name: The Windows Web App Slot Name to automatically swap to when deployment to that slot is successfully completed.
        :param str container_registry_managed_identity_client_id: The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
        :param bool container_registry_use_managed_identity: Should connections for Azure Container Registry use Managed Identity.
        :param 'WindowsWebAppSlotSiteConfigCorsArgs' cors: A `cors` block as defined above.
        :param Sequence[str] default_documents: Specifies a list of Default Documents for the Windows Web App Slot.
        :param str ftps_state: The State of FTP / FTPS service. Possible values include: `AllAllowed`, `FtpsOnly`, `Disabled`.
        :param int health_check_eviction_time_in_min: The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        :param str health_check_path: The path to the Health Check.
        :param bool http2_enabled: Should the HTTP2 be enabled?
        :param Sequence['WindowsWebAppSlotSiteConfigIpRestrictionArgs'] ip_restrictions: One or more `ip_restriction` blocks as defined above.
        :param str load_balancing_mode: The Site load balancing. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        :param bool local_mysql_enabled: Use Local MySQL. Defaults to `false`.
        :param str managed_pipeline_mode: Managed pipeline mode. Possible values include: `Integrated`, `Classic`.
        :param str minimum_tls_version: The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and  `1.2`. Defaults to `1.2`.
        :param bool remote_debugging_enabled: Should Remote Debugging be enabled. Defaults to `false`.
        :param str remote_debugging_version: The Remote Debugging Version. Possible values include `VS2017` and `VS2019`
        :param Sequence['WindowsWebAppSlotSiteConfigScmIpRestrictionArgs'] scm_ip_restrictions: One or more `scm_ip_restriction` blocks as defined above.
        :param str scm_minimum_tls_version: The configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and  `1.2`. Defaults to `1.2`.
        :param bool scm_use_main_ip_restriction: Should the Windows Web App Slot `ip_restriction` configuration be used for the SCM also.
        :param bool use32_bit_worker: Should the Windows Web App Slotuse a 32-bit worker. Defaults to `true`.
        :param Sequence['WindowsWebAppSlotSiteConfigVirtualApplicationArgs'] virtual_applications: One or more `virtual_application` blocks as defined below.
        :param bool vnet_route_all_enabled: Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        :param int worker_count: The number of Workers for this Windows App Service Slot.
        """
        if always_on is not None:
            pulumi.set(__self__, "always_on", always_on)
        if api_definition_url is not None:
            pulumi.set(__self__, "api_definition_url", api_definition_url)
        if api_management_api_id is not None:
            pulumi.set(__self__, "api_management_api_id", api_management_api_id)
        if app_command_line is not None:
            pulumi.set(__self__, "app_command_line", app_command_line)
        if application_stack is not None:
            pulumi.set(__self__, "application_stack", application_stack)
        if auto_heal_enabled is not None:
            pulumi.set(__self__, "auto_heal_enabled", auto_heal_enabled)
        if auto_heal_setting is not None:
            pulumi.set(__self__, "auto_heal_setting", auto_heal_setting)
        if auto_swap_slot_name is not None:
            pulumi.set(__self__, "auto_swap_slot_name", auto_swap_slot_name)
        if container_registry_managed_identity_client_id is not None:
            pulumi.set(__self__, "container_registry_managed_identity_client_id", container_registry_managed_identity_client_id)
        if container_registry_use_managed_identity is not None:
            pulumi.set(__self__, "container_registry_use_managed_identity", container_registry_use_managed_identity)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if default_documents is not None:
            pulumi.set(__self__, "default_documents", default_documents)
        if detailed_error_logging_enabled is not None:
            pulumi.set(__self__, "detailed_error_logging_enabled", detailed_error_logging_enabled)
        if ftps_state is not None:
            pulumi.set(__self__, "ftps_state", ftps_state)
        if health_check_eviction_time_in_min is not None:
            pulumi.set(__self__, "health_check_eviction_time_in_min", health_check_eviction_time_in_min)
        if health_check_path is not None:
            pulumi.set(__self__, "health_check_path", health_check_path)
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if ip_restrictions is not None:
            pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        if load_balancing_mode is not None:
            pulumi.set(__self__, "load_balancing_mode", load_balancing_mode)
        if local_mysql_enabled is not None:
            pulumi.set(__self__, "local_mysql_enabled", local_mysql_enabled)
        if managed_pipeline_mode is not None:
            pulumi.set(__self__, "managed_pipeline_mode", managed_pipeline_mode)
        if minimum_tls_version is not None:
            pulumi.set(__self__, "minimum_tls_version", minimum_tls_version)
        if remote_debugging_enabled is not None:
            pulumi.set(__self__, "remote_debugging_enabled", remote_debugging_enabled)
        if remote_debugging_version is not None:
            pulumi.set(__self__, "remote_debugging_version", remote_debugging_version)
        if scm_ip_restrictions is not None:
            pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        if scm_minimum_tls_version is not None:
            pulumi.set(__self__, "scm_minimum_tls_version", scm_minimum_tls_version)
        if scm_type is not None:
            pulumi.set(__self__, "scm_type", scm_type)
        if scm_use_main_ip_restriction is not None:
            pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        if use32_bit_worker is not None:
            pulumi.set(__self__, "use32_bit_worker", use32_bit_worker)
        if virtual_applications is not None:
            pulumi.set(__self__, "virtual_applications", virtual_applications)
        if vnet_route_all_enabled is not None:
            pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        if websockets_enabled is not None:
            pulumi.set(__self__, "websockets_enabled", websockets_enabled)
        if windows_fx_version is not None:
            pulumi.set(__self__, "windows_fx_version", windows_fx_version)
        if worker_count is not None:
            pulumi.set(__self__, "worker_count", worker_count)

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> Optional[bool]:
        """
        If this Windows Web App Slot is Always On enabled. Defaults to `false`.
        """
        return pulumi.get(self, "always_on")

    @property
    @pulumi.getter(name="apiDefinitionUrl")
    def api_definition_url(self) -> Optional[str]:
        """
        The URL to the API Definition for this Windows Web App Slot.
        """
        return pulumi.get(self, "api_definition_url")

    @property
    @pulumi.getter(name="apiManagementApiId")
    def api_management_api_id(self) -> Optional[str]:
        """
        The API Management API ID this Windows Web App Slot os associated with.
        """
        return pulumi.get(self, "api_management_api_id")

    @property
    @pulumi.getter(name="appCommandLine")
    def app_command_line(self) -> Optional[str]:
        """
        The App command line to launch.
        """
        return pulumi.get(self, "app_command_line")

    @property
    @pulumi.getter(name="applicationStack")
    def application_stack(self) -> Optional['outputs.WindowsWebAppSlotSiteConfigApplicationStack']:
        """
        A `application_stack` block as defined above.
        """
        return pulumi.get(self, "application_stack")

    @property
    @pulumi.getter(name="autoHealEnabled")
    def auto_heal_enabled(self) -> Optional[bool]:
        """
        Should Auto heal rules be enabled. Required with `auto_heal_setting`.
        """
        return pulumi.get(self, "auto_heal_enabled")

    @property
    @pulumi.getter(name="autoHealSetting")
    def auto_heal_setting(self) -> Optional['outputs.WindowsWebAppSlotSiteConfigAutoHealSetting']:
        """
        A `auto_heal_setting` block as defined above. Required with `auto_heal`.
        """
        return pulumi.get(self, "auto_heal_setting")

    @property
    @pulumi.getter(name="autoSwapSlotName")
    def auto_swap_slot_name(self) -> Optional[str]:
        """
        The Windows Web App Slot Name to automatically swap to when deployment to that slot is successfully completed.
        """
        return pulumi.get(self, "auto_swap_slot_name")

    @property
    @pulumi.getter(name="containerRegistryManagedIdentityClientId")
    def container_registry_managed_identity_client_id(self) -> Optional[str]:
        """
        The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
        """
        return pulumi.get(self, "container_registry_managed_identity_client_id")

    @property
    @pulumi.getter(name="containerRegistryUseManagedIdentity")
    def container_registry_use_managed_identity(self) -> Optional[bool]:
        """
        Should connections for Azure Container Registry use Managed Identity.
        """
        return pulumi.get(self, "container_registry_use_managed_identity")

    @property
    @pulumi.getter
    def cors(self) -> Optional['outputs.WindowsWebAppSlotSiteConfigCors']:
        """
        A `cors` block as defined above.
        """
        return pulumi.get(self, "cors")

    @property
    @pulumi.getter(name="defaultDocuments")
    def default_documents(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Default Documents for the Windows Web App Slot.
        """
        return pulumi.get(self, "default_documents")

    @property
    @pulumi.getter(name="detailedErrorLoggingEnabled")
    def detailed_error_logging_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "detailed_error_logging_enabled")

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> Optional[str]:
        """
        The State of FTP / FTPS service. Possible values include: `AllAllowed`, `FtpsOnly`, `Disabled`.
        """
        return pulumi.get(self, "ftps_state")

    @property
    @pulumi.getter(name="healthCheckEvictionTimeInMin")
    def health_check_eviction_time_in_min(self) -> Optional[int]:
        """
        The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        """
        return pulumi.get(self, "health_check_eviction_time_in_min")

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> Optional[str]:
        """
        The path to the Health Check.
        """
        return pulumi.get(self, "health_check_path")

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[bool]:
        """
        Should the HTTP2 be enabled?
        """
        return pulumi.get(self, "http2_enabled")

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Optional[Sequence['outputs.WindowsWebAppSlotSiteConfigIpRestriction']]:
        """
        One or more `ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "ip_restrictions")

    @property
    @pulumi.getter(name="loadBalancingMode")
    def load_balancing_mode(self) -> Optional[str]:
        """
        The Site load balancing. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        """
        return pulumi.get(self, "load_balancing_mode")

    @property
    @pulumi.getter(name="localMysqlEnabled")
    def local_mysql_enabled(self) -> Optional[bool]:
        """
        Use Local MySQL. Defaults to `false`.
        """
        return pulumi.get(self, "local_mysql_enabled")

    @property
    @pulumi.getter(name="managedPipelineMode")
    def managed_pipeline_mode(self) -> Optional[str]:
        """
        Managed pipeline mode. Possible values include: `Integrated`, `Classic`.
        """
        return pulumi.get(self, "managed_pipeline_mode")

    @property
    @pulumi.getter(name="minimumTlsVersion")
    def minimum_tls_version(self) -> Optional[str]:
        """
        The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and  `1.2`. Defaults to `1.2`.
        """
        return pulumi.get(self, "minimum_tls_version")

    @property
    @pulumi.getter(name="remoteDebuggingEnabled")
    def remote_debugging_enabled(self) -> Optional[bool]:
        """
        Should Remote Debugging be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "remote_debugging_enabled")

    @property
    @pulumi.getter(name="remoteDebuggingVersion")
    def remote_debugging_version(self) -> Optional[str]:
        """
        The Remote Debugging Version. Possible values include `VS2017` and `VS2019`
        """
        return pulumi.get(self, "remote_debugging_version")

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Optional[Sequence['outputs.WindowsWebAppSlotSiteConfigScmIpRestriction']]:
        """
        One or more `scm_ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "scm_ip_restrictions")

    @property
    @pulumi.getter(name="scmMinimumTlsVersion")
    def scm_minimum_tls_version(self) -> Optional[str]:
        """
        The configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and  `1.2`. Defaults to `1.2`.
        """
        return pulumi.get(self, "scm_minimum_tls_version")

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> Optional[str]:
        return pulumi.get(self, "scm_type")

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> Optional[bool]:
        """
        Should the Windows Web App Slot `ip_restriction` configuration be used for the SCM also.
        """
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @property
    @pulumi.getter(name="use32BitWorker")
    def use32_bit_worker(self) -> Optional[bool]:
        """
        Should the Windows Web App Slotuse a 32-bit worker. Defaults to `true`.
        """
        return pulumi.get(self, "use32_bit_worker")

    @property
    @pulumi.getter(name="virtualApplications")
    def virtual_applications(self) -> Optional[Sequence['outputs.WindowsWebAppSlotSiteConfigVirtualApplication']]:
        """
        One or more `virtual_application` blocks as defined below.
        """
        return pulumi.get(self, "virtual_applications")

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> Optional[bool]:
        """
        Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        """
        return pulumi.get(self, "vnet_route_all_enabled")

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "websockets_enabled")

    @property
    @pulumi.getter(name="windowsFxVersion")
    def windows_fx_version(self) -> Optional[str]:
        return pulumi.get(self, "windows_fx_version")

    @property
    @pulumi.getter(name="workerCount")
    def worker_count(self) -> Optional[int]:
        """
        The number of Workers for this Windows App Service Slot.
        """
        return pulumi.get(self, "worker_count")


@pulumi.output_type
class WindowsWebAppSlotSiteConfigApplicationStack(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "currentStack":
            suggest = "current_stack"
        elif key == "dockerContainerName":
            suggest = "docker_container_name"
        elif key == "dockerContainerRegistry":
            suggest = "docker_container_registry"
        elif key == "dockerContainerTag":
            suggest = "docker_container_tag"
        elif key == "dotnetVersion":
            suggest = "dotnet_version"
        elif key == "javaContainer":
            suggest = "java_container"
        elif key == "javaContainerVersion":
            suggest = "java_container_version"
        elif key == "javaVersion":
            suggest = "java_version"
        elif key == "nodeVersion":
            suggest = "node_version"
        elif key == "phpVersion":
            suggest = "php_version"
        elif key == "pythonVersion":
            suggest = "python_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotSiteConfigApplicationStack. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotSiteConfigApplicationStack.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotSiteConfigApplicationStack.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 current_stack: Optional[str] = None,
                 docker_container_name: Optional[str] = None,
                 docker_container_registry: Optional[str] = None,
                 docker_container_tag: Optional[str] = None,
                 dotnet_version: Optional[str] = None,
                 java_container: Optional[str] = None,
                 java_container_version: Optional[str] = None,
                 java_version: Optional[str] = None,
                 node_version: Optional[str] = None,
                 php_version: Optional[str] = None,
                 python_version: Optional[str] = None):
        """
        :param str current_stack: The Application Stack for the Windows Web App Slot. Possible values include `dotnet`, `dotnetcore`, `node`, `python`, `php`, and `java`.
        :param str docker_container_name: The name of the Docker Container. For example `azure-app-service/samples/aspnethelloworld`
        :param str docker_container_registry: The registry Host on which the specified Docker Container can be located. For example `mcr.microsoft.com`
        :param str docker_container_tag: The Image Tag of the specified Docker Container to use. For example `latest`
        :param str dotnet_version: The version of .NET to use when `current_stack` is set to `dotnet`. Possible values include `v3.0`, `v4.0`, `v5.0`, `v6.0` and `v7.0` .
        :param str java_container: The Java container type to use when `current_stack` is set to `java`. Possible values include `JAVA`, `JETTY`, and `TOMCAT`. Required with `java_version` and `java_container_version`.
        :param str java_container_version: The Version of the `java_container` to use. Required with `java_version` and `java_container`.
        :param str java_version: The version of Java to use when `current_stack` is set to `java`. Possible values include `1.7`, `1.8`, `11` and `17`. Required with `java_container` and `java_container_version`.
        :param str node_version: The version of node to use when `current_stack` is set to `node`. Possible values include `12-LTS`, `14-LTS`, and `16-LTS`.
        :param str php_version: The version of PHP to use when `current_stack` is set to `php`. Possible values include `v7.4`.
        :param str python_version: The version of Python to use when `current_stack` is set to `python`. Possible values include `2.7` and `3.4.0`.
        """
        if current_stack is not None:
            pulumi.set(__self__, "current_stack", current_stack)
        if docker_container_name is not None:
            pulumi.set(__self__, "docker_container_name", docker_container_name)
        if docker_container_registry is not None:
            pulumi.set(__self__, "docker_container_registry", docker_container_registry)
        if docker_container_tag is not None:
            pulumi.set(__self__, "docker_container_tag", docker_container_tag)
        if dotnet_version is not None:
            pulumi.set(__self__, "dotnet_version", dotnet_version)
        if java_container is not None:
            pulumi.set(__self__, "java_container", java_container)
        if java_container_version is not None:
            pulumi.set(__self__, "java_container_version", java_container_version)
        if java_version is not None:
            pulumi.set(__self__, "java_version", java_version)
        if node_version is not None:
            pulumi.set(__self__, "node_version", node_version)
        if php_version is not None:
            pulumi.set(__self__, "php_version", php_version)
        if python_version is not None:
            pulumi.set(__self__, "python_version", python_version)

    @property
    @pulumi.getter(name="currentStack")
    def current_stack(self) -> Optional[str]:
        """
        The Application Stack for the Windows Web App Slot. Possible values include `dotnet`, `dotnetcore`, `node`, `python`, `php`, and `java`.
        """
        return pulumi.get(self, "current_stack")

    @property
    @pulumi.getter(name="dockerContainerName")
    def docker_container_name(self) -> Optional[str]:
        """
        The name of the Docker Container. For example `azure-app-service/samples/aspnethelloworld`
        """
        return pulumi.get(self, "docker_container_name")

    @property
    @pulumi.getter(name="dockerContainerRegistry")
    def docker_container_registry(self) -> Optional[str]:
        """
        The registry Host on which the specified Docker Container can be located. For example `mcr.microsoft.com`
        """
        return pulumi.get(self, "docker_container_registry")

    @property
    @pulumi.getter(name="dockerContainerTag")
    def docker_container_tag(self) -> Optional[str]:
        """
        The Image Tag of the specified Docker Container to use. For example `latest`
        """
        return pulumi.get(self, "docker_container_tag")

    @property
    @pulumi.getter(name="dotnetVersion")
    def dotnet_version(self) -> Optional[str]:
        """
        The version of .NET to use when `current_stack` is set to `dotnet`. Possible values include `v3.0`, `v4.0`, `v5.0`, `v6.0` and `v7.0` .
        """
        return pulumi.get(self, "dotnet_version")

    @property
    @pulumi.getter(name="javaContainer")
    def java_container(self) -> Optional[str]:
        """
        The Java container type to use when `current_stack` is set to `java`. Possible values include `JAVA`, `JETTY`, and `TOMCAT`. Required with `java_version` and `java_container_version`.
        """
        return pulumi.get(self, "java_container")

    @property
    @pulumi.getter(name="javaContainerVersion")
    def java_container_version(self) -> Optional[str]:
        """
        The Version of the `java_container` to use. Required with `java_version` and `java_container`.
        """
        return pulumi.get(self, "java_container_version")

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> Optional[str]:
        """
        The version of Java to use when `current_stack` is set to `java`. Possible values include `1.7`, `1.8`, `11` and `17`. Required with `java_container` and `java_container_version`.
        """
        return pulumi.get(self, "java_version")

    @property
    @pulumi.getter(name="nodeVersion")
    def node_version(self) -> Optional[str]:
        """
        The version of node to use when `current_stack` is set to `node`. Possible values include `12-LTS`, `14-LTS`, and `16-LTS`.
        """
        return pulumi.get(self, "node_version")

    @property
    @pulumi.getter(name="phpVersion")
    def php_version(self) -> Optional[str]:
        """
        The version of PHP to use when `current_stack` is set to `php`. Possible values include `v7.4`.
        """
        return pulumi.get(self, "php_version")

    @property
    @pulumi.getter(name="pythonVersion")
    def python_version(self) -> Optional[str]:
        """
        The version of Python to use when `current_stack` is set to `python`. Possible values include `2.7` and `3.4.0`.
        """
        return pulumi.get(self, "python_version")


@pulumi.output_type
class WindowsWebAppSlotSiteConfigAutoHealSetting(dict):
    def __init__(__self__, *,
                 action: 'outputs.WindowsWebAppSlotSiteConfigAutoHealSettingAction',
                 trigger: 'outputs.WindowsWebAppSlotSiteConfigAutoHealSettingTrigger'):
        """
        :param 'WindowsWebAppSlotSiteConfigAutoHealSettingActionArgs' action: A `action` block as defined above.
        :param 'WindowsWebAppSlotSiteConfigAutoHealSettingTriggerArgs' trigger: A `trigger` block as defined below.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "trigger", trigger)

    @property
    @pulumi.getter
    def action(self) -> 'outputs.WindowsWebAppSlotSiteConfigAutoHealSettingAction':
        """
        A `action` block as defined above.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def trigger(self) -> 'outputs.WindowsWebAppSlotSiteConfigAutoHealSettingTrigger':
        """
        A `trigger` block as defined below.
        """
        return pulumi.get(self, "trigger")


@pulumi.output_type
class WindowsWebAppSlotSiteConfigAutoHealSettingAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionType":
            suggest = "action_type"
        elif key == "customAction":
            suggest = "custom_action"
        elif key == "minimumProcessExecutionTime":
            suggest = "minimum_process_execution_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotSiteConfigAutoHealSettingAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotSiteConfigAutoHealSettingAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotSiteConfigAutoHealSettingAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_type: str,
                 custom_action: Optional['outputs.WindowsWebAppSlotSiteConfigAutoHealSettingActionCustomAction'] = None,
                 minimum_process_execution_time: Optional[str] = None):
        """
        :param str action_type: Predefined action to be taken to an Auto Heal trigger. Possible values include: `Recycle`.
        :param 'WindowsWebAppSlotSiteConfigAutoHealSettingActionCustomActionArgs' custom_action: A `custom_action` block as defined below.
        :param str minimum_process_execution_time: The minimum amount of time in `hh:mm:ss` the Windows Web App Slot must have been running before the defined action will be run in the event of a trigger.
        """
        pulumi.set(__self__, "action_type", action_type)
        if custom_action is not None:
            pulumi.set(__self__, "custom_action", custom_action)
        if minimum_process_execution_time is not None:
            pulumi.set(__self__, "minimum_process_execution_time", minimum_process_execution_time)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> str:
        """
        Predefined action to be taken to an Auto Heal trigger. Possible values include: `Recycle`.
        """
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter(name="customAction")
    def custom_action(self) -> Optional['outputs.WindowsWebAppSlotSiteConfigAutoHealSettingActionCustomAction']:
        """
        A `custom_action` block as defined below.
        """
        return pulumi.get(self, "custom_action")

    @property
    @pulumi.getter(name="minimumProcessExecutionTime")
    def minimum_process_execution_time(self) -> Optional[str]:
        """
        The minimum amount of time in `hh:mm:ss` the Windows Web App Slot must have been running before the defined action will be run in the event of a trigger.
        """
        return pulumi.get(self, "minimum_process_execution_time")


@pulumi.output_type
class WindowsWebAppSlotSiteConfigAutoHealSettingActionCustomAction(dict):
    def __init__(__self__, *,
                 executable: str,
                 parameters: Optional[str] = None):
        """
        :param str executable: The executable to run for the `custom_action`.
        :param str parameters: The parameters to pass to the specified `executable`.
        """
        pulumi.set(__self__, "executable", executable)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def executable(self) -> str:
        """
        The executable to run for the `custom_action`.
        """
        return pulumi.get(self, "executable")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[str]:
        """
        The parameters to pass to the specified `executable`.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class WindowsWebAppSlotSiteConfigAutoHealSettingTrigger(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateMemoryKb":
            suggest = "private_memory_kb"
        elif key == "slowRequests":
            suggest = "slow_requests"
        elif key == "statusCodes":
            suggest = "status_codes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotSiteConfigAutoHealSettingTrigger. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotSiteConfigAutoHealSettingTrigger.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotSiteConfigAutoHealSettingTrigger.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_memory_kb: Optional[int] = None,
                 requests: Optional['outputs.WindowsWebAppSlotSiteConfigAutoHealSettingTriggerRequests'] = None,
                 slow_requests: Optional[Sequence['outputs.WindowsWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequest']] = None,
                 status_codes: Optional[Sequence['outputs.WindowsWebAppSlotSiteConfigAutoHealSettingTriggerStatusCode']] = None):
        """
        :param int private_memory_kb: The amount of Private Memory to be consumed for this rule to trigger. Possible values are between `102400` and  `13631488`.
        :param 'WindowsWebAppSlotSiteConfigAutoHealSettingTriggerRequestsArgs' requests: A `requests` block as defined above.
        :param Sequence['WindowsWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestArgs'] slow_requests: One or more `slow_request` blocks as defined above.
        :param Sequence['WindowsWebAppSlotSiteConfigAutoHealSettingTriggerStatusCodeArgs'] status_codes: One or more `status_code` blocks as defined above.
        """
        if private_memory_kb is not None:
            pulumi.set(__self__, "private_memory_kb", private_memory_kb)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if slow_requests is not None:
            pulumi.set(__self__, "slow_requests", slow_requests)
        if status_codes is not None:
            pulumi.set(__self__, "status_codes", status_codes)

    @property
    @pulumi.getter(name="privateMemoryKb")
    def private_memory_kb(self) -> Optional[int]:
        """
        The amount of Private Memory to be consumed for this rule to trigger. Possible values are between `102400` and  `13631488`.
        """
        return pulumi.get(self, "private_memory_kb")

    @property
    @pulumi.getter
    def requests(self) -> Optional['outputs.WindowsWebAppSlotSiteConfigAutoHealSettingTriggerRequests']:
        """
        A `requests` block as defined above.
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="slowRequests")
    def slow_requests(self) -> Optional[Sequence['outputs.WindowsWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequest']]:
        """
        One or more `slow_request` blocks as defined above.
        """
        return pulumi.get(self, "slow_requests")

    @property
    @pulumi.getter(name="statusCodes")
    def status_codes(self) -> Optional[Sequence['outputs.WindowsWebAppSlotSiteConfigAutoHealSettingTriggerStatusCode']]:
        """
        One or more `status_code` blocks as defined above.
        """
        return pulumi.get(self, "status_codes")


@pulumi.output_type
class WindowsWebAppSlotSiteConfigAutoHealSettingTriggerRequests(dict):
    def __init__(__self__, *,
                 count: int,
                 interval: str):
        """
        :param int count: The number of requests in the specified `interval` to trigger this rule.
        :param str interval: The interval in `hh:mm:ss`.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of requests in the specified `interval` to trigger this rule.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        The interval in `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class WindowsWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeTaken":
            suggest = "time_taken"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: int,
                 interval: str,
                 time_taken: str,
                 path: Optional[str] = None):
        """
        :param int count: The number of Slow Requests in the time `interval` to trigger this rule.
        :param str interval: The time interval in the form `hh:mm:ss`.
        :param str time_taken: The threshold of time passed to qualify as a Slow Request in `hh:mm:ss`.
        :param str path: The path for which this slow request rule applies.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "time_taken", time_taken)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of Slow Requests in the time `interval` to trigger this rule.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        The time interval in the form `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="timeTaken")
    def time_taken(self) -> str:
        """
        The threshold of time passed to qualify as a Slow Request in `hh:mm:ss`.
        """
        return pulumi.get(self, "time_taken")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path for which this slow request rule applies.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class WindowsWebAppSlotSiteConfigAutoHealSettingTriggerStatusCode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusCodeRange":
            suggest = "status_code_range"
        elif key == "subStatus":
            suggest = "sub_status"
        elif key == "win32Status":
            suggest = "win32_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotSiteConfigAutoHealSettingTriggerStatusCode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotSiteConfigAutoHealSettingTriggerStatusCode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotSiteConfigAutoHealSettingTriggerStatusCode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: int,
                 interval: str,
                 status_code_range: str,
                 path: Optional[str] = None,
                 sub_status: Optional[int] = None,
                 win32_status: Optional[str] = None):
        """
        :param int count: The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        :param str interval: The time interval in the form `hh:mm:ss`.
        :param str status_code_range: The status code for this rule, accepts single status codes and status code ranges. e.g. `500` or `400-499`. Possible values are integers between `101` and `599`
        :param str path: The path to which this rule status code applies.
        :param int sub_status: The Request Sub Status of the Status Code.
        :param str win32_status: The Win32 Status Code of the Request.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "status_code_range", status_code_range)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if sub_status is not None:
            pulumi.set(__self__, "sub_status", sub_status)
        if win32_status is not None:
            pulumi.set(__self__, "win32_status", win32_status)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        The time interval in the form `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="statusCodeRange")
    def status_code_range(self) -> str:
        """
        The status code for this rule, accepts single status codes and status code ranges. e.g. `500` or `400-499`. Possible values are integers between `101` and `599`
        """
        return pulumi.get(self, "status_code_range")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path to which this rule status code applies.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="subStatus")
    def sub_status(self) -> Optional[int]:
        """
        The Request Sub Status of the Status Code.
        """
        return pulumi.get(self, "sub_status")

    @property
    @pulumi.getter(name="win32Status")
    def win32_status(self) -> Optional[str]:
        """
        The Win32 Status Code of the Request.
        """
        return pulumi.get(self, "win32_status")


@pulumi.output_type
class WindowsWebAppSlotSiteConfigCors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedOrigins":
            suggest = "allowed_origins"
        elif key == "supportCredentials":
            suggest = "support_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotSiteConfigCors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotSiteConfigCors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotSiteConfigCors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_origins: Sequence[str],
                 support_credentials: Optional[bool] = None):
        """
        :param Sequence[str] allowed_origins: Specifies a list of origins that should be allowed to make cross-origin calls.
        :param bool support_credentials: Whether CORS requests with credentials are allowed. Defaults to `false`
        """
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        if support_credentials is not None:
            pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Sequence[str]:
        """
        Specifies a list of origins that should be allowed to make cross-origin calls.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> Optional[bool]:
        """
        Whether CORS requests with credentials are allowed. Defaults to `false`
        """
        return pulumi.get(self, "support_credentials")


@pulumi.output_type
class WindowsWebAppSlotSiteConfigIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotSiteConfigIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotSiteConfigIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotSiteConfigIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.WindowsWebAppSlotSiteConfigIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: The action to take. Possible values are `Allow` or `Deny`.
        :param 'WindowsWebAppSlotSiteConfigIpRestrictionHeadersArgs' headers: A `headers` block as defined above.
        :param str ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param str name: The name which should be used for this `ip_restriction`.
        :param int priority: The priority value of this `ip_restriction`.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        The action to take. Possible values are `Allow` or `Deny`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.WindowsWebAppSlotSiteConfigIpRestrictionHeaders']:
        """
        A `headers` block as defined above.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority value of this `ip_restriction`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class WindowsWebAppSlotSiteConfigIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotSiteConfigIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotSiteConfigIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param str x_fd_health_probe: Specifies if a Front Door Health Probe should be expected.
        :param Sequence[str] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param Sequence[str] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        Specifies if a Front Door Health Probe should be expected.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class WindowsWebAppSlotSiteConfigScmIpRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceTag":
            suggest = "service_tag"
        elif key == "virtualNetworkSubnetId":
            suggest = "virtual_network_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotSiteConfigScmIpRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotSiteConfigScmIpRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotSiteConfigScmIpRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 headers: Optional['outputs.WindowsWebAppSlotSiteConfigScmIpRestrictionHeaders'] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 service_tag: Optional[str] = None,
                 virtual_network_subnet_id: Optional[str] = None):
        """
        :param str action: The action to take. Possible values are `Allow` or `Deny`.
        :param 'WindowsWebAppSlotSiteConfigScmIpRestrictionHeadersArgs' headers: A `headers` block as defined above.
        :param str ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param str name: The name which should be used for this `ip_restriction`.
        :param int priority: The priority value of this `ip_restriction`.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        The action to take. Possible values are `Allow` or `Deny`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.WindowsWebAppSlotSiteConfigScmIpRestrictionHeaders']:
        """
        A `headers` block as defined above.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority value of this `ip_restriction`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[str]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class WindowsWebAppSlotSiteConfigScmIpRestrictionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAzureFdids":
            suggest = "x_azure_fdids"
        elif key == "xFdHealthProbe":
            suggest = "x_fd_health_probe"
        elif key == "xForwardedFors":
            suggest = "x_forwarded_fors"
        elif key == "xForwardedHosts":
            suggest = "x_forwarded_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotSiteConfigScmIpRestrictionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotSiteConfigScmIpRestrictionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_azure_fdids: Optional[Sequence[str]] = None,
                 x_fd_health_probe: Optional[str] = None,
                 x_forwarded_fors: Optional[Sequence[str]] = None,
                 x_forwarded_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param str x_fd_health_probe: Specifies if a Front Door Health Probe should be expected.
        :param Sequence[str] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param Sequence[str] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[str]:
        """
        Specifies if a Front Door Health Probe should be expected.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class WindowsWebAppSlotSiteConfigVirtualApplication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "physicalPath":
            suggest = "physical_path"
        elif key == "virtualPath":
            suggest = "virtual_path"
        elif key == "virtualDirectories":
            suggest = "virtual_directories"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotSiteConfigVirtualApplication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotSiteConfigVirtualApplication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotSiteConfigVirtualApplication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 physical_path: str,
                 preload: bool,
                 virtual_path: str,
                 virtual_directories: Optional[Sequence['outputs.WindowsWebAppSlotSiteConfigVirtualApplicationVirtualDirectory']] = None):
        """
        :param str physical_path: The physical path for the Virtual Application.
        :param bool preload: Should pre-loading be enabled. Defaults to `false`.
        :param str virtual_path: The Virtual Path for the Virtual Application.
        :param Sequence['WindowsWebAppSlotSiteConfigVirtualApplicationVirtualDirectoryArgs'] virtual_directories: One or more `virtual_directory` blocks as defined below.
        """
        pulumi.set(__self__, "physical_path", physical_path)
        pulumi.set(__self__, "preload", preload)
        pulumi.set(__self__, "virtual_path", virtual_path)
        if virtual_directories is not None:
            pulumi.set(__self__, "virtual_directories", virtual_directories)

    @property
    @pulumi.getter(name="physicalPath")
    def physical_path(self) -> str:
        """
        The physical path for the Virtual Application.
        """
        return pulumi.get(self, "physical_path")

    @property
    @pulumi.getter
    def preload(self) -> bool:
        """
        Should pre-loading be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "preload")

    @property
    @pulumi.getter(name="virtualPath")
    def virtual_path(self) -> str:
        """
        The Virtual Path for the Virtual Application.
        """
        return pulumi.get(self, "virtual_path")

    @property
    @pulumi.getter(name="virtualDirectories")
    def virtual_directories(self) -> Optional[Sequence['outputs.WindowsWebAppSlotSiteConfigVirtualApplicationVirtualDirectory']]:
        """
        One or more `virtual_directory` blocks as defined below.
        """
        return pulumi.get(self, "virtual_directories")


@pulumi.output_type
class WindowsWebAppSlotSiteConfigVirtualApplicationVirtualDirectory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "physicalPath":
            suggest = "physical_path"
        elif key == "virtualPath":
            suggest = "virtual_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotSiteConfigVirtualApplicationVirtualDirectory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotSiteConfigVirtualApplicationVirtualDirectory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotSiteConfigVirtualApplicationVirtualDirectory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 physical_path: Optional[str] = None,
                 virtual_path: Optional[str] = None):
        """
        :param str physical_path: The physical path for the Virtual Application.
        :param str virtual_path: The Virtual Path for the Virtual Application.
        """
        if physical_path is not None:
            pulumi.set(__self__, "physical_path", physical_path)
        if virtual_path is not None:
            pulumi.set(__self__, "virtual_path", virtual_path)

    @property
    @pulumi.getter(name="physicalPath")
    def physical_path(self) -> Optional[str]:
        """
        The physical path for the Virtual Application.
        """
        return pulumi.get(self, "physical_path")

    @property
    @pulumi.getter(name="virtualPath")
    def virtual_path(self) -> Optional[str]:
        """
        The Virtual Path for the Virtual Application.
        """
        return pulumi.get(self, "virtual_path")


@pulumi.output_type
class WindowsWebAppSlotSiteCredential(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 password: Optional[str] = None):
        """
        :param str name: The name which should be used for this Windows Web App Slot. Changing this forces a new Windows Web App Slot to be created.
        :param str password: The Site Credentials Password used for publishing.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name which should be used for this Windows Web App Slot. Changing this forces a new Windows Web App Slot to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The Site Credentials Password used for publishing.
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class WindowsWebAppSlotStorageAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "accountName":
            suggest = "account_name"
        elif key == "shareName":
            suggest = "share_name"
        elif key == "mountPath":
            suggest = "mount_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppSlotStorageAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppSlotStorageAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppSlotStorageAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: str,
                 account_name: str,
                 name: str,
                 share_name: str,
                 type: str,
                 mount_path: Optional[str] = None):
        """
        :param str access_key: The Access key for the storage account.
        :param str account_name: The Name of the Storage Account.
        :param str name: The name which should be used for this Storage Account.
        :param str share_name: The Name of the File Share or Container Name for Blob storage.
        :param str type: The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`
        :param str mount_path: The path at which to mount the storage share.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "share_name", share_name)
        pulumi.set(__self__, "type", type)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> str:
        """
        The Access key for the storage account.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> str:
        """
        The Name of the Storage Account.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Storage Account.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> str:
        """
        The Name of the File Share or Container Name for Blob storage.
        """
        return pulumi.get(self, "share_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[str]:
        """
        The path at which to mount the storage share.
        """
        return pulumi.get(self, "mount_path")


@pulumi.output_type
class WindowsWebAppStickySettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appSettingNames":
            suggest = "app_setting_names"
        elif key == "connectionStringNames":
            suggest = "connection_string_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppStickySettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppStickySettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppStickySettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_setting_names: Optional[Sequence[str]] = None,
                 connection_string_names: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] app_setting_names: A list of `app_setting` names that the Windows Web App will not swap between Slots when a swap operation is triggered.
        :param Sequence[str] connection_string_names: A list of `connection_string` names that the Windows Web App will not swap between Slots when a swap operation is triggered.
        """
        if app_setting_names is not None:
            pulumi.set(__self__, "app_setting_names", app_setting_names)
        if connection_string_names is not None:
            pulumi.set(__self__, "connection_string_names", connection_string_names)

    @property
    @pulumi.getter(name="appSettingNames")
    def app_setting_names(self) -> Optional[Sequence[str]]:
        """
        A list of `app_setting` names that the Windows Web App will not swap between Slots when a swap operation is triggered.
        """
        return pulumi.get(self, "app_setting_names")

    @property
    @pulumi.getter(name="connectionStringNames")
    def connection_string_names(self) -> Optional[Sequence[str]]:
        """
        A list of `connection_string` names that the Windows Web App will not swap between Slots when a swap operation is triggered.
        """
        return pulumi.get(self, "connection_string_names")


@pulumi.output_type
class WindowsWebAppStorageAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "accountName":
            suggest = "account_name"
        elif key == "shareName":
            suggest = "share_name"
        elif key == "mountPath":
            suggest = "mount_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsWebAppStorageAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsWebAppStorageAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsWebAppStorageAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: str,
                 account_name: str,
                 name: str,
                 share_name: str,
                 type: str,
                 mount_path: Optional[str] = None):
        """
        :param str access_key: The Access key for the storage account.
        :param str account_name: The Name of the Storage Account.
        :param str name: The name which should be used for this TODO.
        :param str share_name: The Name of the File Share or Container Name for Blob storage.
        :param str type: The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`
        :param str mount_path: The path at which to mount the storage share.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "share_name", share_name)
        pulumi.set(__self__, "type", type)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> str:
        """
        The Access key for the storage account.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> str:
        """
        The Name of the Storage Account.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this TODO.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> str:
        """
        The Name of the File Share or Container Name for Blob storage.
        """
        return pulumi.get(self, "share_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[str]:
        """
        The path at which to mount the storage share.
        """
        return pulumi.get(self, "mount_path")


@pulumi.output_type
class GetAppServiceConnectionStringResult(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: The name of the App Service.
        :param str type: The type of the Connection String.
        :param str value: The value for the Connection String.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the App Service.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the Connection String.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the Connection String.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAppServiceEnvironmentClusterSettingResult(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: The name of this App Service Environment.
        :param str value: The value for the Cluster Setting.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this App Service Environment.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the Cluster Setting.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAppServicePlanSkuResult(dict):
    def __init__(__self__, *,
                 capacity: int,
                 size: str,
                 tier: str):
        """
        :param int capacity: Specifies the number of workers associated with this App Service Plan.
        :param str size: Specifies the plan's instance size.
        :param str tier: Specifies the plan's pricing tier.
        """
        pulumi.set(__self__, "capacity", capacity)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter
    def capacity(self) -> int:
        """
        Specifies the number of workers associated with this App Service Plan.
        """
        return pulumi.get(self, "capacity")

    @property
    @pulumi.getter
    def size(self) -> str:
        """
        Specifies the plan's instance size.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def tier(self) -> str:
        """
        Specifies the plan's pricing tier.
        """
        return pulumi.get(self, "tier")


@pulumi.output_type
class GetAppServiceSiteConfigResult(dict):
    def __init__(__self__, *,
                 acr_use_managed_identity_credentials: bool,
                 acr_user_managed_identity_client_id: str,
                 always_on: bool,
                 app_command_line: str,
                 cors: Sequence['outputs.GetAppServiceSiteConfigCorResult'],
                 default_documents: Sequence[str],
                 dotnet_framework_version: str,
                 ftps_state: str,
                 health_check_path: str,
                 http2_enabled: bool,
                 ip_restrictions: Sequence['outputs.GetAppServiceSiteConfigIpRestrictionResult'],
                 java_container: str,
                 java_container_version: str,
                 java_version: str,
                 linux_fx_version: str,
                 local_mysql_enabled: bool,
                 managed_pipeline_mode: str,
                 min_tls_version: str,
                 number_of_workers: int,
                 php_version: str,
                 python_version: str,
                 remote_debugging_enabled: bool,
                 remote_debugging_version: str,
                 scm_ip_restrictions: Sequence['outputs.GetAppServiceSiteConfigScmIpRestrictionResult'],
                 scm_type: str,
                 scm_use_main_ip_restriction: bool,
                 use32_bit_worker_process: bool,
                 vnet_route_all_enabled: bool,
                 websockets_enabled: bool,
                 windows_fx_version: str):
        """
        :param bool acr_use_managed_identity_credentials: Are Managed Identity Credentials used for Azure Container Registry pull.
        :param str acr_user_managed_identity_client_id: The User Managed Identity Client Id.
        :param bool always_on: Is the app loaded at all times?
        :param str app_command_line: App command line to launch.
        :param Sequence['GetAppServiceSiteConfigCorArgs'] cors: A `cors` block as defined above.
        :param Sequence[str] default_documents: The ordering of default documents to load, if an address isn't specified.
        :param str dotnet_framework_version: The version of the .NET framework's CLR used in this App Service.
        :param str ftps_state: State of FTP / FTPS service for this AppService.
        :param str health_check_path: The health check path to be pinged by App Service.
        :param bool http2_enabled: Is HTTP2 Enabled on this App Service?
        :param Sequence['GetAppServiceSiteConfigIpRestrictionArgs'] ip_restrictions: One or more `ip_restriction` blocks as defined above.
        :param str java_container: The Java Container in use.
        :param str java_container_version: The version of the Java Container in use.
        :param str java_version: The version of Java in use.
        :param str linux_fx_version: Linux App Framework and version for the AppService.
        :param bool local_mysql_enabled: Is "MySQL In App" Enabled? This runs a local MySQL instance with your app and shares resources from the App Service plan.
        :param str managed_pipeline_mode: The Managed Pipeline Mode used in this App Service.
        :param str min_tls_version: The minimum supported TLS version for this App Service.
        :param int number_of_workers: The scaled number of workers (for per site scaling) of this App Service.
        :param str php_version: The version of PHP used in this App Service.
        :param str python_version: The version of Python used in this App Service.
        :param bool remote_debugging_enabled: Is Remote Debugging Enabled in this App Service?
        :param str remote_debugging_version: Which version of Visual Studio is the Remote Debugger compatible with?
        :param Sequence['GetAppServiceSiteConfigScmIpRestrictionArgs'] scm_ip_restrictions: One or more `scm_ip_restriction` blocks as defined above.
        :param str scm_type: The type of Source Control enabled for this App Service.
        :param bool scm_use_main_ip_restriction: IP security restrictions for scm to use main.
        :param bool use32_bit_worker_process: Does the App Service run in 32 bit mode, rather than 64 bit mode?
        :param bool vnet_route_all_enabled: (Optional) Should all outbound traffic to have Virtual Network Security Groups and User Defined Routes applied?
        :param bool websockets_enabled: Are WebSockets enabled for this App Service?
        :param str windows_fx_version: Windows Container Docker Image for the AppService.
        """
        pulumi.set(__self__, "acr_use_managed_identity_credentials", acr_use_managed_identity_credentials)
        pulumi.set(__self__, "acr_user_managed_identity_client_id", acr_user_managed_identity_client_id)
        pulumi.set(__self__, "always_on", always_on)
        pulumi.set(__self__, "app_command_line", app_command_line)
        pulumi.set(__self__, "cors", cors)
        pulumi.set(__self__, "default_documents", default_documents)
        pulumi.set(__self__, "dotnet_framework_version", dotnet_framework_version)
        pulumi.set(__self__, "ftps_state", ftps_state)
        pulumi.set(__self__, "health_check_path", health_check_path)
        pulumi.set(__self__, "http2_enabled", http2_enabled)
        pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        pulumi.set(__self__, "java_container", java_container)
        pulumi.set(__self__, "java_container_version", java_container_version)
        pulumi.set(__self__, "java_version", java_version)
        pulumi.set(__self__, "linux_fx_version", linux_fx_version)
        pulumi.set(__self__, "local_mysql_enabled", local_mysql_enabled)
        pulumi.set(__self__, "managed_pipeline_mode", managed_pipeline_mode)
        pulumi.set(__self__, "min_tls_version", min_tls_version)
        pulumi.set(__self__, "number_of_workers", number_of_workers)
        pulumi.set(__self__, "php_version", php_version)
        pulumi.set(__self__, "python_version", python_version)
        pulumi.set(__self__, "remote_debugging_enabled", remote_debugging_enabled)
        pulumi.set(__self__, "remote_debugging_version", remote_debugging_version)
        pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        pulumi.set(__self__, "scm_type", scm_type)
        pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        pulumi.set(__self__, "use32_bit_worker_process", use32_bit_worker_process)
        pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        pulumi.set(__self__, "websockets_enabled", websockets_enabled)
        pulumi.set(__self__, "windows_fx_version", windows_fx_version)

    @property
    @pulumi.getter(name="acrUseManagedIdentityCredentials")
    def acr_use_managed_identity_credentials(self) -> bool:
        """
        Are Managed Identity Credentials used for Azure Container Registry pull.
        """
        return pulumi.get(self, "acr_use_managed_identity_credentials")

    @property
    @pulumi.getter(name="acrUserManagedIdentityClientId")
    def acr_user_managed_identity_client_id(self) -> str:
        """
        The User Managed Identity Client Id.
        """
        return pulumi.get(self, "acr_user_managed_identity_client_id")

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> bool:
        """
        Is the app loaded at all times?
        """
        return pulumi.get(self, "always_on")

    @property
    @pulumi.getter(name="appCommandLine")
    def app_command_line(self) -> str:
        """
        App command line to launch.
        """
        return pulumi.get(self, "app_command_line")

    @property
    @pulumi.getter
    def cors(self) -> Sequence['outputs.GetAppServiceSiteConfigCorResult']:
        """
        A `cors` block as defined above.
        """
        return pulumi.get(self, "cors")

    @property
    @pulumi.getter(name="defaultDocuments")
    def default_documents(self) -> Sequence[str]:
        """
        The ordering of default documents to load, if an address isn't specified.
        """
        return pulumi.get(self, "default_documents")

    @property
    @pulumi.getter(name="dotnetFrameworkVersion")
    def dotnet_framework_version(self) -> str:
        """
        The version of the .NET framework's CLR used in this App Service.
        """
        return pulumi.get(self, "dotnet_framework_version")

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> str:
        """
        State of FTP / FTPS service for this AppService.
        """
        return pulumi.get(self, "ftps_state")

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> str:
        """
        The health check path to be pinged by App Service.
        """
        return pulumi.get(self, "health_check_path")

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> bool:
        """
        Is HTTP2 Enabled on this App Service?
        """
        return pulumi.get(self, "http2_enabled")

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Sequence['outputs.GetAppServiceSiteConfigIpRestrictionResult']:
        """
        One or more `ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "ip_restrictions")

    @property
    @pulumi.getter(name="javaContainer")
    def java_container(self) -> str:
        """
        The Java Container in use.
        """
        return pulumi.get(self, "java_container")

    @property
    @pulumi.getter(name="javaContainerVersion")
    def java_container_version(self) -> str:
        """
        The version of the Java Container in use.
        """
        return pulumi.get(self, "java_container_version")

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> str:
        """
        The version of Java in use.
        """
        return pulumi.get(self, "java_version")

    @property
    @pulumi.getter(name="linuxFxVersion")
    def linux_fx_version(self) -> str:
        """
        Linux App Framework and version for the AppService.
        """
        return pulumi.get(self, "linux_fx_version")

    @property
    @pulumi.getter(name="localMysqlEnabled")
    def local_mysql_enabled(self) -> bool:
        """
        Is "MySQL In App" Enabled? This runs a local MySQL instance with your app and shares resources from the App Service plan.
        """
        return pulumi.get(self, "local_mysql_enabled")

    @property
    @pulumi.getter(name="managedPipelineMode")
    def managed_pipeline_mode(self) -> str:
        """
        The Managed Pipeline Mode used in this App Service.
        """
        return pulumi.get(self, "managed_pipeline_mode")

    @property
    @pulumi.getter(name="minTlsVersion")
    def min_tls_version(self) -> str:
        """
        The minimum supported TLS version for this App Service.
        """
        return pulumi.get(self, "min_tls_version")

    @property
    @pulumi.getter(name="numberOfWorkers")
    def number_of_workers(self) -> int:
        """
        The scaled number of workers (for per site scaling) of this App Service.
        """
        return pulumi.get(self, "number_of_workers")

    @property
    @pulumi.getter(name="phpVersion")
    def php_version(self) -> str:
        """
        The version of PHP used in this App Service.
        """
        return pulumi.get(self, "php_version")

    @property
    @pulumi.getter(name="pythonVersion")
    def python_version(self) -> str:
        """
        The version of Python used in this App Service.
        """
        return pulumi.get(self, "python_version")

    @property
    @pulumi.getter(name="remoteDebuggingEnabled")
    def remote_debugging_enabled(self) -> bool:
        """
        Is Remote Debugging Enabled in this App Service?
        """
        return pulumi.get(self, "remote_debugging_enabled")

    @property
    @pulumi.getter(name="remoteDebuggingVersion")
    def remote_debugging_version(self) -> str:
        """
        Which version of Visual Studio is the Remote Debugger compatible with?
        """
        return pulumi.get(self, "remote_debugging_version")

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Sequence['outputs.GetAppServiceSiteConfigScmIpRestrictionResult']:
        """
        One or more `scm_ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "scm_ip_restrictions")

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> str:
        """
        The type of Source Control enabled for this App Service.
        """
        return pulumi.get(self, "scm_type")

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> bool:
        """
        IP security restrictions for scm to use main.
        """
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @property
    @pulumi.getter(name="use32BitWorkerProcess")
    def use32_bit_worker_process(self) -> bool:
        """
        Does the App Service run in 32 bit mode, rather than 64 bit mode?
        """
        return pulumi.get(self, "use32_bit_worker_process")

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> bool:
        """
        (Optional) Should all outbound traffic to have Virtual Network Security Groups and User Defined Routes applied?
        """
        return pulumi.get(self, "vnet_route_all_enabled")

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> bool:
        """
        Are WebSockets enabled for this App Service?
        """
        return pulumi.get(self, "websockets_enabled")

    @property
    @pulumi.getter(name="windowsFxVersion")
    def windows_fx_version(self) -> str:
        """
        Windows Container Docker Image for the AppService.
        """
        return pulumi.get(self, "windows_fx_version")


@pulumi.output_type
class GetAppServiceSiteConfigCorResult(dict):
    def __init__(__self__, *,
                 allowed_origins: Sequence[str],
                 support_credentials: bool):
        """
        :param Sequence[str] allowed_origins: A list of origins which are able to make cross-origin calls.
        :param bool support_credentials: Are credentials supported?
        """
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Sequence[str]:
        """
        A list of origins which are able to make cross-origin calls.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> bool:
        """
        Are credentials supported?
        """
        return pulumi.get(self, "support_credentials")


@pulumi.output_type
class GetAppServiceSiteConfigIpRestrictionResult(dict):
    def __init__(__self__, *,
                 action: str,
                 headers: 'outputs.GetAppServiceSiteConfigIpRestrictionHeadersResult',
                 ip_address: str,
                 name: str,
                 priority: int,
                 service_tag: str,
                 virtual_network_subnet_id: str):
        """
        :param str action: Allow or Deny access for this IP range. Defaults to Allow.
        :param str ip_address: The IP Address used for this IP Restriction in CIDR notation.
        :param str name: The name of the App Service.
        :param int priority: The priority for this IP Restriction.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "service_tag", service_tag)
        pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Allow or Deny access for this IP range. Defaults to Allow.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> 'outputs.GetAppServiceSiteConfigIpRestrictionHeadersResult':
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The IP Address used for this IP Restriction in CIDR notation.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the App Service.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        The priority for this IP Restriction.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> str:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> str:
        """
        The Virtual Network Subnet ID used for this IP Restriction.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class GetAppServiceSiteConfigIpRestrictionHeadersResult(dict):
    def __init__(__self__, *,
                 x_azure_fdids: Sequence[str],
                 x_fd_health_probes: Sequence[str],
                 x_forwarded_fors: Sequence[str],
                 x_forwarded_hosts: Sequence[str]):
        pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        pulumi.set(__self__, "x_fd_health_probes", x_fd_health_probes)
        pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Sequence[str]:
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbes")
    def x_fd_health_probes(self) -> Sequence[str]:
        return pulumi.get(self, "x_fd_health_probes")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Sequence[str]:
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Sequence[str]:
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class GetAppServiceSiteConfigScmIpRestrictionResult(dict):
    def __init__(__self__, *,
                 action: str,
                 headers: 'outputs.GetAppServiceSiteConfigScmIpRestrictionHeadersResult',
                 ip_address: str,
                 name: str,
                 priority: int,
                 service_tag: str,
                 virtual_network_subnet_id: str):
        """
        :param str action: Allow or Deny access for this IP range. Defaults to Allow.
        :param str ip_address: The IP Address used for this IP Restriction in CIDR notation.
        :param str name: The name of the App Service.
        :param int priority: The priority for this IP Restriction.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "service_tag", service_tag)
        pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Allow or Deny access for this IP range. Defaults to Allow.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> 'outputs.GetAppServiceSiteConfigScmIpRestrictionHeadersResult':
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The IP Address used for this IP Restriction in CIDR notation.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the App Service.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        The priority for this IP Restriction.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> str:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> str:
        """
        The Virtual Network Subnet ID used for this IP Restriction.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class GetAppServiceSiteConfigScmIpRestrictionHeadersResult(dict):
    def __init__(__self__, *,
                 x_azure_fdids: Sequence[str],
                 x_fd_health_probes: Sequence[str],
                 x_forwarded_fors: Sequence[str],
                 x_forwarded_hosts: Sequence[str]):
        pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        pulumi.set(__self__, "x_fd_health_probes", x_fd_health_probes)
        pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Sequence[str]:
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbes")
    def x_fd_health_probes(self) -> Sequence[str]:
        return pulumi.get(self, "x_fd_health_probes")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Sequence[str]:
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Sequence[str]:
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class GetAppServiceSiteCredentialResult(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        return pulumi.get(self, "username")


@pulumi.output_type
class GetAppServiceSourceControlResult(dict):
    def __init__(__self__, *,
                 branch: str,
                 manual_integration: bool,
                 repo_url: str,
                 rollback_enabled: bool,
                 use_mercurial: bool):
        """
        :param str branch: The branch of the remote repository in use.
        :param bool manual_integration: Limits to manual integration.
        :param str repo_url: The URL of the source code repository.
        :param bool rollback_enabled: Is roll-back enabled for the repository.
        :param bool use_mercurial: Uses Mercurial if `true`, otherwise uses Git.
        """
        pulumi.set(__self__, "branch", branch)
        pulumi.set(__self__, "manual_integration", manual_integration)
        pulumi.set(__self__, "repo_url", repo_url)
        pulumi.set(__self__, "rollback_enabled", rollback_enabled)
        pulumi.set(__self__, "use_mercurial", use_mercurial)

    @property
    @pulumi.getter
    def branch(self) -> str:
        """
        The branch of the remote repository in use.
        """
        return pulumi.get(self, "branch")

    @property
    @pulumi.getter(name="manualIntegration")
    def manual_integration(self) -> bool:
        """
        Limits to manual integration.
        """
        return pulumi.get(self, "manual_integration")

    @property
    @pulumi.getter(name="repoUrl")
    def repo_url(self) -> str:
        """
        The URL of the source code repository.
        """
        return pulumi.get(self, "repo_url")

    @property
    @pulumi.getter(name="rollbackEnabled")
    def rollback_enabled(self) -> bool:
        """
        Is roll-back enabled for the repository.
        """
        return pulumi.get(self, "rollback_enabled")

    @property
    @pulumi.getter(name="useMercurial")
    def use_mercurial(self) -> bool:
        """
        Uses Mercurial if `true`, otherwise uses Git.
        """
        return pulumi.get(self, "use_mercurial")


@pulumi.output_type
class GetCertificateOrderCertificateResult(dict):
    def __init__(__self__, *,
                 certificate_name: str,
                 key_vault_id: str,
                 key_vault_secret_name: str,
                 provisioning_state: str):
        """
        :param str certificate_name: The name of the App Service Certificate.
        :param str key_vault_id: Key Vault resource Id.
        :param str key_vault_secret_name: Key Vault secret name.
        :param str provisioning_state: Status of the Key Vault secret.
        """
        pulumi.set(__self__, "certificate_name", certificate_name)
        pulumi.set(__self__, "key_vault_id", key_vault_id)
        pulumi.set(__self__, "key_vault_secret_name", key_vault_secret_name)
        pulumi.set(__self__, "provisioning_state", provisioning_state)

    @property
    @pulumi.getter(name="certificateName")
    def certificate_name(self) -> str:
        """
        The name of the App Service Certificate.
        """
        return pulumi.get(self, "certificate_name")

    @property
    @pulumi.getter(name="keyVaultId")
    def key_vault_id(self) -> str:
        """
        Key Vault resource Id.
        """
        return pulumi.get(self, "key_vault_id")

    @property
    @pulumi.getter(name="keyVaultSecretName")
    def key_vault_secret_name(self) -> str:
        """
        Key Vault secret name.
        """
        return pulumi.get(self, "key_vault_secret_name")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        Status of the Key Vault secret.
        """
        return pulumi.get(self, "provisioning_state")


@pulumi.output_type
class GetEnvironmentV3ClusterSettingResult(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: The name of this v3 App Service Environment.
        :param str value: The value for the Cluster Setting.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this v3 App Service Environment.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the Cluster Setting.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetEnvironmentV3InboundNetworkDependencyResult(dict):
    def __init__(__self__, *,
                 description: str,
                 ip_addresses: Sequence[str],
                 ports: Sequence[str]):
        """
        :param str description: A short description of the purpose of the network traffic.
        :param Sequence[str] ip_addresses: A list of IP addresses that network traffic will originate from in CIDR notation.
        :param Sequence[str] ports: The ports that network traffic will arrive to the App Service Environment V3 on.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "ip_addresses", ip_addresses)
        pulumi.set(__self__, "ports", ports)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        A short description of the purpose of the network traffic.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Sequence[str]:
        """
        A list of IP addresses that network traffic will originate from in CIDR notation.
        """
        return pulumi.get(self, "ip_addresses")

    @property
    @pulumi.getter
    def ports(self) -> Sequence[str]:
        """
        The ports that network traffic will arrive to the App Service Environment V3 on.
        """
        return pulumi.get(self, "ports")


@pulumi.output_type
class GetFunctionAppConnectionStringResult(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: The name of the Function App resource.
        :param str type: The identity type of the Managed Identity assigned to the Function App.
        :param str value: The value for the Connection String.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Function App resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The identity type of the Managed Identity assigned to the Function App.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the Connection String.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetFunctionAppIdentityResult(dict):
    def __init__(__self__, *,
                 identity_ids: Sequence[str],
                 principal_id: str,
                 tenant_id: str,
                 type: str):
        """
        :param Sequence[str] identity_ids: A list of User Assigned Identity IDs assigned to the Function App.
        :param str principal_id: The ID of the Managed Identity assigned to the Function App.
        :param str tenant_id: The ID of the Tenant where the Managed Identity assigned to the Function App is located.
        :param str type: The identity type of the Managed Identity assigned to the Function App.
        """
        pulumi.set(__self__, "identity_ids", identity_ids)
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Sequence[str]:
        """
        A list of User Assigned Identity IDs assigned to the Function App.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The ID of the Managed Identity assigned to the Function App.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The ID of the Tenant where the Managed Identity assigned to the Function App is located.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The identity type of the Managed Identity assigned to the Function App.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetFunctionAppSiteConfigResult(dict):
    def __init__(__self__, *,
                 always_on: bool,
                 app_scale_limit: int,
                 auto_swap_slot_name: str,
                 cors: 'outputs.GetFunctionAppSiteConfigCorsResult',
                 dotnet_framework_version: str,
                 elastic_instance_minimum: int,
                 ftps_state: str,
                 health_check_path: str,
                 http2_enabled: bool,
                 ip_restrictions: Sequence['outputs.GetFunctionAppSiteConfigIpRestrictionResult'],
                 java_version: str,
                 linux_fx_version: str,
                 min_tls_version: str,
                 pre_warmed_instance_count: int,
                 runtime_scale_monitoring_enabled: bool,
                 scm_ip_restrictions: Sequence['outputs.GetFunctionAppSiteConfigScmIpRestrictionResult'],
                 scm_type: str,
                 scm_use_main_ip_restriction: bool,
                 use32_bit_worker_process: bool,
                 vnet_route_all_enabled: bool,
                 websockets_enabled: bool):
        """
        :param bool always_on: Is the app loaded at all times?
        :param int app_scale_limit: The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
        :param 'GetFunctionAppSiteConfigCorsArgs' cors: A `cors` block as defined above.
        :param str dotnet_framework_version: The version of the .NET framework's CLR used in this App Service.
        :param int elastic_instance_minimum: The number of minimum instances for this function app. Only applicable to apps on the Premium plan.
        :param str ftps_state: State of FTP / FTPS service for this AppService.
        :param bool http2_enabled: Is HTTP2 Enabled on this App Service?
        :param Sequence['GetFunctionAppSiteConfigIpRestrictionArgs'] ip_restrictions: One or more `ip_restriction` blocks as defined above.
        :param str java_version: Java version hosted by the function app in Azure.
        :param str linux_fx_version: Linux App Framework and version for the AppService.
        :param str min_tls_version: The minimum supported TLS version for this App Service.
        :param int pre_warmed_instance_count: The number of pre-warmed instances for this function app. Only applicable to apps on the Premium plan.
        :param bool runtime_scale_monitoring_enabled: Is Runtime Scale Monitoring Enabled on this function app?
        :param Sequence['GetFunctionAppSiteConfigScmIpRestrictionArgs'] scm_ip_restrictions: One or more `scm_ip_restriction` blocks as defined above.
        :param str scm_type: The type of Source Control enabled for this App Service.
        :param bool scm_use_main_ip_restriction: IP security restrictions for scm to use main.
        :param bool use32_bit_worker_process: Does the App Service run in 32 bit mode, rather than 64 bit mode?
        :param bool vnet_route_all_enabled: (Optional) Should all outbound traffic to have Virtual Network Security Groups and User Defined Routes applied?
        :param bool websockets_enabled: Are WebSockets enabled for this App Service?
        """
        pulumi.set(__self__, "always_on", always_on)
        pulumi.set(__self__, "app_scale_limit", app_scale_limit)
        pulumi.set(__self__, "auto_swap_slot_name", auto_swap_slot_name)
        pulumi.set(__self__, "cors", cors)
        pulumi.set(__self__, "dotnet_framework_version", dotnet_framework_version)
        pulumi.set(__self__, "elastic_instance_minimum", elastic_instance_minimum)
        pulumi.set(__self__, "ftps_state", ftps_state)
        pulumi.set(__self__, "health_check_path", health_check_path)
        pulumi.set(__self__, "http2_enabled", http2_enabled)
        pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        pulumi.set(__self__, "java_version", java_version)
        pulumi.set(__self__, "linux_fx_version", linux_fx_version)
        pulumi.set(__self__, "min_tls_version", min_tls_version)
        pulumi.set(__self__, "pre_warmed_instance_count", pre_warmed_instance_count)
        pulumi.set(__self__, "runtime_scale_monitoring_enabled", runtime_scale_monitoring_enabled)
        pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        pulumi.set(__self__, "scm_type", scm_type)
        pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        pulumi.set(__self__, "use32_bit_worker_process", use32_bit_worker_process)
        pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        pulumi.set(__self__, "websockets_enabled", websockets_enabled)

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> bool:
        """
        Is the app loaded at all times?
        """
        return pulumi.get(self, "always_on")

    @property
    @pulumi.getter(name="appScaleLimit")
    def app_scale_limit(self) -> int:
        """
        The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
        """
        return pulumi.get(self, "app_scale_limit")

    @property
    @pulumi.getter(name="autoSwapSlotName")
    def auto_swap_slot_name(self) -> str:
        return pulumi.get(self, "auto_swap_slot_name")

    @property
    @pulumi.getter
    def cors(self) -> 'outputs.GetFunctionAppSiteConfigCorsResult':
        """
        A `cors` block as defined above.
        """
        return pulumi.get(self, "cors")

    @property
    @pulumi.getter(name="dotnetFrameworkVersion")
    def dotnet_framework_version(self) -> str:
        """
        The version of the .NET framework's CLR used in this App Service.
        """
        return pulumi.get(self, "dotnet_framework_version")

    @property
    @pulumi.getter(name="elasticInstanceMinimum")
    def elastic_instance_minimum(self) -> int:
        """
        The number of minimum instances for this function app. Only applicable to apps on the Premium plan.
        """
        return pulumi.get(self, "elastic_instance_minimum")

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> str:
        """
        State of FTP / FTPS service for this AppService.
        """
        return pulumi.get(self, "ftps_state")

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> str:
        return pulumi.get(self, "health_check_path")

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> bool:
        """
        Is HTTP2 Enabled on this App Service?
        """
        return pulumi.get(self, "http2_enabled")

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Sequence['outputs.GetFunctionAppSiteConfigIpRestrictionResult']:
        """
        One or more `ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "ip_restrictions")

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> str:
        """
        Java version hosted by the function app in Azure.
        """
        return pulumi.get(self, "java_version")

    @property
    @pulumi.getter(name="linuxFxVersion")
    def linux_fx_version(self) -> str:
        """
        Linux App Framework and version for the AppService.
        """
        return pulumi.get(self, "linux_fx_version")

    @property
    @pulumi.getter(name="minTlsVersion")
    def min_tls_version(self) -> str:
        """
        The minimum supported TLS version for this App Service.
        """
        return pulumi.get(self, "min_tls_version")

    @property
    @pulumi.getter(name="preWarmedInstanceCount")
    def pre_warmed_instance_count(self) -> int:
        """
        The number of pre-warmed instances for this function app. Only applicable to apps on the Premium plan.
        """
        return pulumi.get(self, "pre_warmed_instance_count")

    @property
    @pulumi.getter(name="runtimeScaleMonitoringEnabled")
    def runtime_scale_monitoring_enabled(self) -> bool:
        """
        Is Runtime Scale Monitoring Enabled on this function app?
        """
        return pulumi.get(self, "runtime_scale_monitoring_enabled")

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Sequence['outputs.GetFunctionAppSiteConfigScmIpRestrictionResult']:
        """
        One or more `scm_ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "scm_ip_restrictions")

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> str:
        """
        The type of Source Control enabled for this App Service.
        """
        return pulumi.get(self, "scm_type")

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> bool:
        """
        IP security restrictions for scm to use main.
        """
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @property
    @pulumi.getter(name="use32BitWorkerProcess")
    def use32_bit_worker_process(self) -> bool:
        """
        Does the App Service run in 32 bit mode, rather than 64 bit mode?
        """
        return pulumi.get(self, "use32_bit_worker_process")

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> bool:
        """
        (Optional) Should all outbound traffic to have Virtual Network Security Groups and User Defined Routes applied?
        """
        return pulumi.get(self, "vnet_route_all_enabled")

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> bool:
        """
        Are WebSockets enabled for this App Service?
        """
        return pulumi.get(self, "websockets_enabled")


@pulumi.output_type
class GetFunctionAppSiteConfigCorsResult(dict):
    def __init__(__self__, *,
                 allowed_origins: Sequence[str],
                 support_credentials: Optional[bool] = None):
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        if support_credentials is not None:
            pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Sequence[str]:
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> Optional[bool]:
        return pulumi.get(self, "support_credentials")


@pulumi.output_type
class GetFunctionAppSiteConfigIpRestrictionResult(dict):
    def __init__(__self__, *,
                 action: str,
                 headers: 'outputs.GetFunctionAppSiteConfigIpRestrictionHeadersResult',
                 ip_address: str,
                 name: str,
                 priority: int,
                 service_tag: str,
                 virtual_network_subnet_id: str):
        """
        :param str action: Allow or Deny access for this IP range. Defaults to Allow.
        :param str ip_address: The IP Address used for this IP Restriction in CIDR notation.
        :param str name: The name of the Function App resource.
        :param int priority: The priority for this IP Restriction.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "service_tag", service_tag)
        pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Allow or Deny access for this IP range. Defaults to Allow.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> 'outputs.GetFunctionAppSiteConfigIpRestrictionHeadersResult':
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The IP Address used for this IP Restriction in CIDR notation.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Function App resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        The priority for this IP Restriction.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> str:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> str:
        """
        The Virtual Network Subnet ID used for this IP Restriction.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class GetFunctionAppSiteConfigIpRestrictionHeadersResult(dict):
    def __init__(__self__, *,
                 x_azure_fdids: Sequence[str],
                 x_fd_health_probes: Sequence[str],
                 x_forwarded_fors: Sequence[str],
                 x_forwarded_hosts: Sequence[str]):
        pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        pulumi.set(__self__, "x_fd_health_probes", x_fd_health_probes)
        pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Sequence[str]:
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbes")
    def x_fd_health_probes(self) -> Sequence[str]:
        return pulumi.get(self, "x_fd_health_probes")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Sequence[str]:
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Sequence[str]:
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class GetFunctionAppSiteConfigScmIpRestrictionResult(dict):
    def __init__(__self__, *,
                 action: str,
                 headers: 'outputs.GetFunctionAppSiteConfigScmIpRestrictionHeadersResult',
                 ip_address: str,
                 name: str,
                 priority: int,
                 service_tag: str,
                 virtual_network_subnet_id: str):
        """
        :param str action: Allow or Deny access for this IP range. Defaults to Allow.
        :param str ip_address: The IP Address used for this IP Restriction in CIDR notation.
        :param str name: The name of the Function App resource.
        :param int priority: The priority for this IP Restriction.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "service_tag", service_tag)
        pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Allow or Deny access for this IP range. Defaults to Allow.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> 'outputs.GetFunctionAppSiteConfigScmIpRestrictionHeadersResult':
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The IP Address used for this IP Restriction in CIDR notation.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Function App resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        The priority for this IP Restriction.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> str:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> str:
        """
        The Virtual Network Subnet ID used for this IP Restriction.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class GetFunctionAppSiteConfigScmIpRestrictionHeadersResult(dict):
    def __init__(__self__, *,
                 x_azure_fdids: Sequence[str],
                 x_fd_health_probes: Sequence[str],
                 x_forwarded_fors: Sequence[str],
                 x_forwarded_hosts: Sequence[str]):
        pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        pulumi.set(__self__, "x_fd_health_probes", x_fd_health_probes)
        pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Sequence[str]:
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbes")
    def x_fd_health_probes(self) -> Sequence[str]:
        return pulumi.get(self, "x_fd_health_probes")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Sequence[str]:
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Sequence[str]:
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class GetFunctionAppSiteCredentialResult(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str):
        """
        :param str password: The password associated with the username, which can be used to publish to this App Service.
        :param str username: The username which can be used to publish to this App Service
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password associated with the username, which can be used to publish to this App Service.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username which can be used to publish to this App Service
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetFunctionAppSourceControlResult(dict):
    def __init__(__self__, *,
                 branch: str,
                 manual_integration: bool,
                 repo_url: str,
                 rollback_enabled: bool,
                 use_mercurial: bool):
        """
        :param str branch: The branch of the remote repository in use.
        :param bool manual_integration: Limits to manual integration.
        :param str repo_url: The URL of the source code repository.
        :param bool rollback_enabled: Is roll-back enabled for the repository.
        :param bool use_mercurial: Uses Mercurial if `true`, otherwise uses Git.
        """
        pulumi.set(__self__, "branch", branch)
        pulumi.set(__self__, "manual_integration", manual_integration)
        pulumi.set(__self__, "repo_url", repo_url)
        pulumi.set(__self__, "rollback_enabled", rollback_enabled)
        pulumi.set(__self__, "use_mercurial", use_mercurial)

    @property
    @pulumi.getter
    def branch(self) -> str:
        """
        The branch of the remote repository in use.
        """
        return pulumi.get(self, "branch")

    @property
    @pulumi.getter(name="manualIntegration")
    def manual_integration(self) -> bool:
        """
        Limits to manual integration.
        """
        return pulumi.get(self, "manual_integration")

    @property
    @pulumi.getter(name="repoUrl")
    def repo_url(self) -> str:
        """
        The URL of the source code repository.
        """
        return pulumi.get(self, "repo_url")

    @property
    @pulumi.getter(name="rollbackEnabled")
    def rollback_enabled(self) -> bool:
        """
        Is roll-back enabled for the repository.
        """
        return pulumi.get(self, "rollback_enabled")

    @property
    @pulumi.getter(name="useMercurial")
    def use_mercurial(self) -> bool:
        """
        Uses Mercurial if `true`, otherwise uses Git.
        """
        return pulumi.get(self, "use_mercurial")


@pulumi.output_type
class GetLinuxFunctionAppAuthSettingResult(dict):
    def __init__(__self__, *,
                 active_directories: Sequence['outputs.GetLinuxFunctionAppAuthSettingActiveDirectoryResult'],
                 additional_login_parameters: Mapping[str, str],
                 allowed_external_redirect_urls: Sequence[str],
                 default_provider: str,
                 enabled: bool,
                 facebooks: Sequence['outputs.GetLinuxFunctionAppAuthSettingFacebookResult'],
                 githubs: Sequence['outputs.GetLinuxFunctionAppAuthSettingGithubResult'],
                 googles: Sequence['outputs.GetLinuxFunctionAppAuthSettingGoogleResult'],
                 issuer: str,
                 microsofts: Sequence['outputs.GetLinuxFunctionAppAuthSettingMicrosoftResult'],
                 runtime_version: str,
                 token_refresh_extension_hours: float,
                 token_store_enabled: bool,
                 twitters: Sequence['outputs.GetLinuxFunctionAppAuthSettingTwitterResult'],
                 unauthenticated_client_action: str):
        """
        :param Sequence['GetLinuxFunctionAppAuthSettingActiveDirectoryArgs'] active_directories: An `active_directory` block as defined above.
        :param Mapping[str, str] additional_login_parameters: A map of login parameters sent to the OpenID Connect authorization endpoint when a user logs in.
        :param Sequence[str] allowed_external_redirect_urls: A list of External URLs that can be redirected to as part of logging in or logging out of the Linux Web App.
        :param str default_provider: The default authentication provider used when multiple providers are configured.
        :param bool enabled: Is this backup job enabled?
        :param Sequence['GetLinuxFunctionAppAuthSettingFacebookArgs'] facebooks: A `facebook` block as defined below.
        :param Sequence['GetLinuxFunctionAppAuthSettingGithubArgs'] githubs: A `github` block as defined below.
        :param Sequence['GetLinuxFunctionAppAuthSettingGoogleArgs'] googles: A `google` block as defined below.
        :param str issuer: The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Linux Web App.
        :param Sequence['GetLinuxFunctionAppAuthSettingMicrosoftArgs'] microsofts: A `microsoft` block as defined below.
        :param str runtime_version: The RuntimeVersion of the Authentication / Authorization feature in use for the Linux Web App.
        :param float token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to call the token refresh API.
        :param bool token_store_enabled: Does the Linux Web App durably store platform-specific security tokens that are obtained during login flows?
        :param Sequence['GetLinuxFunctionAppAuthSettingTwitterArgs'] twitters: A `twitter` block as defined below.
        :param str unauthenticated_client_action: The action to taken when an unauthenticated client attempts to access the app.
        """
        pulumi.set(__self__, "active_directories", active_directories)
        pulumi.set(__self__, "additional_login_parameters", additional_login_parameters)
        pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        pulumi.set(__self__, "default_provider", default_provider)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "facebooks", facebooks)
        pulumi.set(__self__, "githubs", githubs)
        pulumi.set(__self__, "googles", googles)
        pulumi.set(__self__, "issuer", issuer)
        pulumi.set(__self__, "microsofts", microsofts)
        pulumi.set(__self__, "runtime_version", runtime_version)
        pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)
        pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        pulumi.set(__self__, "twitters", twitters)
        pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter(name="activeDirectories")
    def active_directories(self) -> Sequence['outputs.GetLinuxFunctionAppAuthSettingActiveDirectoryResult']:
        """
        An `active_directory` block as defined above.
        """
        return pulumi.get(self, "active_directories")

    @property
    @pulumi.getter(name="additionalLoginParameters")
    def additional_login_parameters(self) -> Mapping[str, str]:
        """
        A map of login parameters sent to the OpenID Connect authorization endpoint when a user logs in.
        """
        return pulumi.get(self, "additional_login_parameters")

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Sequence[str]:
        """
        A list of External URLs that can be redirected to as part of logging in or logging out of the Linux Web App.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> str:
        """
        The default authentication provider used when multiple providers are configured.
        """
        return pulumi.get(self, "default_provider")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is this backup job enabled?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def facebooks(self) -> Sequence['outputs.GetLinuxFunctionAppAuthSettingFacebookResult']:
        """
        A `facebook` block as defined below.
        """
        return pulumi.get(self, "facebooks")

    @property
    @pulumi.getter
    def githubs(self) -> Sequence['outputs.GetLinuxFunctionAppAuthSettingGithubResult']:
        """
        A `github` block as defined below.
        """
        return pulumi.get(self, "githubs")

    @property
    @pulumi.getter
    def googles(self) -> Sequence['outputs.GetLinuxFunctionAppAuthSettingGoogleResult']:
        """
        A `google` block as defined below.
        """
        return pulumi.get(self, "googles")

    @property
    @pulumi.getter
    def issuer(self) -> str:
        """
        The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Linux Web App.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def microsofts(self) -> Sequence['outputs.GetLinuxFunctionAppAuthSettingMicrosoftResult']:
        """
        A `microsoft` block as defined below.
        """
        return pulumi.get(self, "microsofts")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> str:
        """
        The RuntimeVersion of the Authentication / Authorization feature in use for the Linux Web App.
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> float:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API.
        """
        return pulumi.get(self, "token_refresh_extension_hours")

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> bool:
        """
        Does the Linux Web App durably store platform-specific security tokens that are obtained during login flows?
        """
        return pulumi.get(self, "token_store_enabled")

    @property
    @pulumi.getter
    def twitters(self) -> Sequence['outputs.GetLinuxFunctionAppAuthSettingTwitterResult']:
        """
        A `twitter` block as defined below.
        """
        return pulumi.get(self, "twitters")

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> str:
        """
        The action to taken when an unauthenticated client attempts to access the app.
        """
        return pulumi.get(self, "unauthenticated_client_action")


@pulumi.output_type
class GetLinuxFunctionAppAuthSettingActiveDirectoryResult(dict):
    def __init__(__self__, *,
                 allowed_audiences: Sequence[str],
                 client_id: str,
                 client_secret: str,
                 client_secret_setting_name: str):
        """
        :param Sequence[str] allowed_audiences: A list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret: The OAuth 2.0 client secret that was created for the app used for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        """
        pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Sequence[str]:
        """
        A list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")


@pulumi.output_type
class GetLinuxFunctionAppAuthSettingFacebookResult(dict):
    def __init__(__self__, *,
                 app_id: str,
                 app_secret: str,
                 app_secret_setting_name: str,
                 oauth_scopes: Sequence[str]):
        """
        :param str app_id: The App ID of the Facebook app used for login.
        :param str app_secret: The App Secret of the Facebook app used for Facebook login.
        :param str app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook login.
        :param Sequence[str] oauth_scopes: A list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "app_secret", app_secret)
        pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appSecret")
    def app_secret(self) -> str:
        """
        The App Secret of the Facebook app used for Facebook login.
        """
        return pulumi.get(self, "app_secret")

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> str:
        """
        The app setting name that contains the `app_secret` value used for Facebook login.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Sequence[str]:
        """
        A list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class GetLinuxFunctionAppAuthSettingGithubResult(dict):
    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 client_secret_setting_name: str,
                 oauth_scopes: Sequence[str]):
        """
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret: The OAuth 2.0 client secret that was created for the app used for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        :param Sequence[str] oauth_scopes: A list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Sequence[str]:
        """
        A list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class GetLinuxFunctionAppAuthSettingGoogleResult(dict):
    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 client_secret_setting_name: str,
                 oauth_scopes: Sequence[str]):
        """
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret: The OAuth 2.0 client secret that was created for the app used for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        :param Sequence[str] oauth_scopes: A list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Sequence[str]:
        """
        A list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class GetLinuxFunctionAppAuthSettingMicrosoftResult(dict):
    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 client_secret_setting_name: str,
                 oauth_scopes: Sequence[str]):
        """
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret: The OAuth 2.0 client secret that was created for the app used for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        :param Sequence[str] oauth_scopes: A list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Sequence[str]:
        """
        A list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class GetLinuxFunctionAppAuthSettingTwitterResult(dict):
    def __init__(__self__, *,
                 consumer_key: str,
                 consumer_secret: str,
                 consumer_secret_setting_name: str):
        """
        :param str consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param str consumer_secret: The OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        :param str consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        pulumi.set(__self__, "consumer_secret", consumer_secret)
        pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> str:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> str:
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_secret")

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> str:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_secret_setting_name")


@pulumi.output_type
class GetLinuxFunctionAppBackupResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 name: str,
                 schedules: Sequence['outputs.GetLinuxFunctionAppBackupScheduleResult'],
                 storage_account_url: str):
        """
        :param bool enabled: Is this backup job enabled?
        :param str name: The name which should be used for this Linux Function App.
        :param Sequence['GetLinuxFunctionAppBackupScheduleArgs'] schedules: A `schedule` block as defined below.
        :param str storage_account_url: The SAS URL to the container.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schedules", schedules)
        pulumi.set(__self__, "storage_account_url", storage_account_url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is this backup job enabled?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Linux Function App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def schedules(self) -> Sequence['outputs.GetLinuxFunctionAppBackupScheduleResult']:
        """
        A `schedule` block as defined below.
        """
        return pulumi.get(self, "schedules")

    @property
    @pulumi.getter(name="storageAccountUrl")
    def storage_account_url(self) -> str:
        """
        The SAS URL to the container.
        """
        return pulumi.get(self, "storage_account_url")


@pulumi.output_type
class GetLinuxFunctionAppBackupScheduleResult(dict):
    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_unit: str,
                 keep_at_least_one_backup: bool,
                 last_execution_time: str,
                 retention_period_days: int,
                 start_time: str):
        """
        :param int frequency_interval: How often the backup is executed.
        :param str frequency_unit: The unit of time for how often the backup takes place.
        :param bool keep_at_least_one_backup: Does the service keep at least one backup, regardless of age of backup?
        :param int retention_period_days: After how many days backups are deleted.
        :param str start_time: When the schedule starts working in RFC-3339 format.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_unit", frequency_unit)
        pulumi.set(__self__, "keep_at_least_one_backup", keep_at_least_one_backup)
        pulumi.set(__self__, "last_execution_time", last_execution_time)
        pulumi.set(__self__, "retention_period_days", retention_period_days)
        pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        How often the backup is executed.
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyUnit")
    def frequency_unit(self) -> str:
        """
        The unit of time for how often the backup takes place.
        """
        return pulumi.get(self, "frequency_unit")

    @property
    @pulumi.getter(name="keepAtLeastOneBackup")
    def keep_at_least_one_backup(self) -> bool:
        """
        Does the service keep at least one backup, regardless of age of backup?
        """
        return pulumi.get(self, "keep_at_least_one_backup")

    @property
    @pulumi.getter(name="lastExecutionTime")
    def last_execution_time(self) -> str:
        return pulumi.get(self, "last_execution_time")

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> int:
        """
        After how many days backups are deleted.
        """
        return pulumi.get(self, "retention_period_days")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        """
        When the schedule starts working in RFC-3339 format.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class GetLinuxFunctionAppConnectionStringResult(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: The name which should be used for this Linux Function App.
        :param str type: The type of Managed Service Identity that is configured on this Linux Function App.
        :param str value: The connection string value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Linux Function App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of Managed Service Identity that is configured on this Linux Function App.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The connection string value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetLinuxFunctionAppIdentityResult(dict):
    def __init__(__self__, *,
                 identity_ids: Sequence[str],
                 principal_id: str,
                 tenant_id: str,
                 type: str):
        """
        :param Sequence[str] identity_ids: The list of User Assigned Managed Identity IDs assigned to this Linux Function App.
        :param str principal_id: The Principal ID of the System Assigned Managed Service Identity that is configured on this Linux Function App.
        :param str tenant_id: The Tenant ID of the System Assigned Managed Service Identity that is configured on this Linux Function App.
        :param str type: The type of Managed Service Identity that is configured on this Linux Function App.
        """
        pulumi.set(__self__, "identity_ids", identity_ids)
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Sequence[str]:
        """
        The list of User Assigned Managed Identity IDs assigned to this Linux Function App.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The Principal ID of the System Assigned Managed Service Identity that is configured on this Linux Function App.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The Tenant ID of the System Assigned Managed Service Identity that is configured on this Linux Function App.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of Managed Service Identity that is configured on this Linux Function App.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetLinuxFunctionAppSiteConfigResult(dict):
    def __init__(__self__, *,
                 always_on: bool,
                 api_definition_url: str,
                 api_management_api_id: str,
                 app_command_line: str,
                 app_scale_limit: int,
                 app_service_logs: Sequence['outputs.GetLinuxFunctionAppSiteConfigAppServiceLogResult'],
                 application_insights_connection_string: str,
                 application_insights_key: str,
                 application_stacks: Sequence['outputs.GetLinuxFunctionAppSiteConfigApplicationStackResult'],
                 container_registry_managed_identity_client_id: str,
                 container_registry_use_managed_identity: bool,
                 cors: Sequence['outputs.GetLinuxFunctionAppSiteConfigCorResult'],
                 default_documents: Sequence[str],
                 detailed_error_logging_enabled: bool,
                 elastic_instance_minimum: int,
                 ftps_state: str,
                 health_check_eviction_time_in_min: int,
                 health_check_path: str,
                 http2_enabled: bool,
                 ip_restrictions: Sequence['outputs.GetLinuxFunctionAppSiteConfigIpRestrictionResult'],
                 linux_fx_version: str,
                 load_balancing_mode: str,
                 managed_pipeline_mode: str,
                 minimum_tls_version: str,
                 pre_warmed_instance_count: int,
                 remote_debugging_enabled: bool,
                 remote_debugging_version: str,
                 runtime_scale_monitoring_enabled: bool,
                 scm_ip_restrictions: Sequence['outputs.GetLinuxFunctionAppSiteConfigScmIpRestrictionResult'],
                 scm_minimum_tls_version: str,
                 scm_type: str,
                 scm_use_main_ip_restriction: bool,
                 use32_bit_worker: bool,
                 vnet_route_all_enabled: bool,
                 websockets_enabled: bool,
                 worker_count: int):
        """
        :param bool always_on: If this Linux Web App is Always On enabled.
        :param str api_definition_url: The URL of the API definition that describes this Linux Function App.
        :param str api_management_api_id: The ID of the API Management API for this Linux Function App.
        :param str app_command_line: The App command line that is launched.
        :param int app_scale_limit: The number of workers this function app can scale out to.
        :param Sequence['GetLinuxFunctionAppSiteConfigAppServiceLogArgs'] app_service_logs: An `app_service_logs` block as defined above.
        :param str application_insights_connection_string: The Connection String that links the Linux Function App to Application Insights.
        :param str application_insights_key: The Instrumentation Key that connects the Linux Function App to Application Insights.
        :param Sequence['GetLinuxFunctionAppSiteConfigApplicationStackArgs'] application_stacks: An `application_stack` block as defined above.
        :param str container_registry_managed_identity_client_id: The Client ID of the Managed Service Identity that is used for connections to the Azure Container Registry.
        :param bool container_registry_use_managed_identity: Do connections for Azure Container Registry use Managed Identity?
        :param Sequence['GetLinuxFunctionAppSiteConfigCorArgs'] cors: A `cors` block as defined above.
        :param Sequence[str] default_documents: A list of Default Documents for the Linux Web App.
        :param int elastic_instance_minimum: The number of minimum instances for this Linux Function App.
        :param str ftps_state: State of FTP / FTPS service for this function app.
        :param int health_check_eviction_time_in_min: The amount of time in minutes that a node can be unhealthy before being removed from the load balancer.
        :param str health_check_path: The path that is checked for this function app health.
        :param bool http2_enabled: Is the HTTP2 protocol enabled?
        :param Sequence['GetLinuxFunctionAppSiteConfigIpRestrictionArgs'] ip_restrictions: One or more `ip_restriction` blocks as defined above.
        :param str load_balancing_mode: The Site load balancing mode.
        :param str managed_pipeline_mode: Managed pipeline mode.
        :param str minimum_tls_version: The minimum version of TLS required for SSL requests.
        :param int pre_warmed_instance_count: The number of pre-warmed instances for this function app.
        :param bool remote_debugging_enabled: Is Remote Debugging enabled?
        :param str remote_debugging_version: The Remote Debugging Version.
        :param bool runtime_scale_monitoring_enabled: Is Scale Monitoring of the Functions Runtime enabled?
        :param Sequence['GetLinuxFunctionAppSiteConfigScmIpRestrictionArgs'] scm_ip_restrictions: One or more `scm_ip_restriction` blocks as defined above.
        :param str scm_minimum_tls_version: The minimum version of TLS for SSL requests to the SCM site.
        :param bool scm_use_main_ip_restriction: Is the Linux Function App `ip_restriction` configuration used for the SCM also?
        :param bool use32_bit_worker: Does the Linux Web App use a 32-bit worker process?
        :param bool vnet_route_all_enabled: Are all outbound traffic to NAT Gateways, Network Security Groups and User Defined Routes applied?
        :param bool websockets_enabled: Are Web Sockets enabled?
        :param int worker_count: The number of Workers for this Linux Function App.
        """
        pulumi.set(__self__, "always_on", always_on)
        pulumi.set(__self__, "api_definition_url", api_definition_url)
        pulumi.set(__self__, "api_management_api_id", api_management_api_id)
        pulumi.set(__self__, "app_command_line", app_command_line)
        pulumi.set(__self__, "app_scale_limit", app_scale_limit)
        pulumi.set(__self__, "app_service_logs", app_service_logs)
        pulumi.set(__self__, "application_insights_connection_string", application_insights_connection_string)
        pulumi.set(__self__, "application_insights_key", application_insights_key)
        pulumi.set(__self__, "application_stacks", application_stacks)
        pulumi.set(__self__, "container_registry_managed_identity_client_id", container_registry_managed_identity_client_id)
        pulumi.set(__self__, "container_registry_use_managed_identity", container_registry_use_managed_identity)
        pulumi.set(__self__, "cors", cors)
        pulumi.set(__self__, "default_documents", default_documents)
        pulumi.set(__self__, "detailed_error_logging_enabled", detailed_error_logging_enabled)
        pulumi.set(__self__, "elastic_instance_minimum", elastic_instance_minimum)
        pulumi.set(__self__, "ftps_state", ftps_state)
        pulumi.set(__self__, "health_check_eviction_time_in_min", health_check_eviction_time_in_min)
        pulumi.set(__self__, "health_check_path", health_check_path)
        pulumi.set(__self__, "http2_enabled", http2_enabled)
        pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        pulumi.set(__self__, "linux_fx_version", linux_fx_version)
        pulumi.set(__self__, "load_balancing_mode", load_balancing_mode)
        pulumi.set(__self__, "managed_pipeline_mode", managed_pipeline_mode)
        pulumi.set(__self__, "minimum_tls_version", minimum_tls_version)
        pulumi.set(__self__, "pre_warmed_instance_count", pre_warmed_instance_count)
        pulumi.set(__self__, "remote_debugging_enabled", remote_debugging_enabled)
        pulumi.set(__self__, "remote_debugging_version", remote_debugging_version)
        pulumi.set(__self__, "runtime_scale_monitoring_enabled", runtime_scale_monitoring_enabled)
        pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        pulumi.set(__self__, "scm_minimum_tls_version", scm_minimum_tls_version)
        pulumi.set(__self__, "scm_type", scm_type)
        pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        pulumi.set(__self__, "use32_bit_worker", use32_bit_worker)
        pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        pulumi.set(__self__, "websockets_enabled", websockets_enabled)
        pulumi.set(__self__, "worker_count", worker_count)

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> bool:
        """
        If this Linux Web App is Always On enabled.
        """
        return pulumi.get(self, "always_on")

    @property
    @pulumi.getter(name="apiDefinitionUrl")
    def api_definition_url(self) -> str:
        """
        The URL of the API definition that describes this Linux Function App.
        """
        return pulumi.get(self, "api_definition_url")

    @property
    @pulumi.getter(name="apiManagementApiId")
    def api_management_api_id(self) -> str:
        """
        The ID of the API Management API for this Linux Function App.
        """
        return pulumi.get(self, "api_management_api_id")

    @property
    @pulumi.getter(name="appCommandLine")
    def app_command_line(self) -> str:
        """
        The App command line that is launched.
        """
        return pulumi.get(self, "app_command_line")

    @property
    @pulumi.getter(name="appScaleLimit")
    def app_scale_limit(self) -> int:
        """
        The number of workers this function app can scale out to.
        """
        return pulumi.get(self, "app_scale_limit")

    @property
    @pulumi.getter(name="appServiceLogs")
    def app_service_logs(self) -> Sequence['outputs.GetLinuxFunctionAppSiteConfigAppServiceLogResult']:
        """
        An `app_service_logs` block as defined above.
        """
        return pulumi.get(self, "app_service_logs")

    @property
    @pulumi.getter(name="applicationInsightsConnectionString")
    def application_insights_connection_string(self) -> str:
        """
        The Connection String that links the Linux Function App to Application Insights.
        """
        return pulumi.get(self, "application_insights_connection_string")

    @property
    @pulumi.getter(name="applicationInsightsKey")
    def application_insights_key(self) -> str:
        """
        The Instrumentation Key that connects the Linux Function App to Application Insights.
        """
        return pulumi.get(self, "application_insights_key")

    @property
    @pulumi.getter(name="applicationStacks")
    def application_stacks(self) -> Sequence['outputs.GetLinuxFunctionAppSiteConfigApplicationStackResult']:
        """
        An `application_stack` block as defined above.
        """
        return pulumi.get(self, "application_stacks")

    @property
    @pulumi.getter(name="containerRegistryManagedIdentityClientId")
    def container_registry_managed_identity_client_id(self) -> str:
        """
        The Client ID of the Managed Service Identity that is used for connections to the Azure Container Registry.
        """
        return pulumi.get(self, "container_registry_managed_identity_client_id")

    @property
    @pulumi.getter(name="containerRegistryUseManagedIdentity")
    def container_registry_use_managed_identity(self) -> bool:
        """
        Do connections for Azure Container Registry use Managed Identity?
        """
        return pulumi.get(self, "container_registry_use_managed_identity")

    @property
    @pulumi.getter
    def cors(self) -> Sequence['outputs.GetLinuxFunctionAppSiteConfigCorResult']:
        """
        A `cors` block as defined above.
        """
        return pulumi.get(self, "cors")

    @property
    @pulumi.getter(name="defaultDocuments")
    def default_documents(self) -> Sequence[str]:
        """
        A list of Default Documents for the Linux Web App.
        """
        return pulumi.get(self, "default_documents")

    @property
    @pulumi.getter(name="detailedErrorLoggingEnabled")
    def detailed_error_logging_enabled(self) -> bool:
        return pulumi.get(self, "detailed_error_logging_enabled")

    @property
    @pulumi.getter(name="elasticInstanceMinimum")
    def elastic_instance_minimum(self) -> int:
        """
        The number of minimum instances for this Linux Function App.
        """
        return pulumi.get(self, "elastic_instance_minimum")

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> str:
        """
        State of FTP / FTPS service for this function app.
        """
        return pulumi.get(self, "ftps_state")

    @property
    @pulumi.getter(name="healthCheckEvictionTimeInMin")
    def health_check_eviction_time_in_min(self) -> int:
        """
        The amount of time in minutes that a node can be unhealthy before being removed from the load balancer.
        """
        return pulumi.get(self, "health_check_eviction_time_in_min")

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> str:
        """
        The path that is checked for this function app health.
        """
        return pulumi.get(self, "health_check_path")

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> bool:
        """
        Is the HTTP2 protocol enabled?
        """
        return pulumi.get(self, "http2_enabled")

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Sequence['outputs.GetLinuxFunctionAppSiteConfigIpRestrictionResult']:
        """
        One or more `ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "ip_restrictions")

    @property
    @pulumi.getter(name="linuxFxVersion")
    def linux_fx_version(self) -> str:
        return pulumi.get(self, "linux_fx_version")

    @property
    @pulumi.getter(name="loadBalancingMode")
    def load_balancing_mode(self) -> str:
        """
        The Site load balancing mode.
        """
        return pulumi.get(self, "load_balancing_mode")

    @property
    @pulumi.getter(name="managedPipelineMode")
    def managed_pipeline_mode(self) -> str:
        """
        Managed pipeline mode.
        """
        return pulumi.get(self, "managed_pipeline_mode")

    @property
    @pulumi.getter(name="minimumTlsVersion")
    def minimum_tls_version(self) -> str:
        """
        The minimum version of TLS required for SSL requests.
        """
        return pulumi.get(self, "minimum_tls_version")

    @property
    @pulumi.getter(name="preWarmedInstanceCount")
    def pre_warmed_instance_count(self) -> int:
        """
        The number of pre-warmed instances for this function app.
        """
        return pulumi.get(self, "pre_warmed_instance_count")

    @property
    @pulumi.getter(name="remoteDebuggingEnabled")
    def remote_debugging_enabled(self) -> bool:
        """
        Is Remote Debugging enabled?
        """
        return pulumi.get(self, "remote_debugging_enabled")

    @property
    @pulumi.getter(name="remoteDebuggingVersion")
    def remote_debugging_version(self) -> str:
        """
        The Remote Debugging Version.
        """
        return pulumi.get(self, "remote_debugging_version")

    @property
    @pulumi.getter(name="runtimeScaleMonitoringEnabled")
    def runtime_scale_monitoring_enabled(self) -> bool:
        """
        Is Scale Monitoring of the Functions Runtime enabled?
        """
        return pulumi.get(self, "runtime_scale_monitoring_enabled")

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Sequence['outputs.GetLinuxFunctionAppSiteConfigScmIpRestrictionResult']:
        """
        One or more `scm_ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "scm_ip_restrictions")

    @property
    @pulumi.getter(name="scmMinimumTlsVersion")
    def scm_minimum_tls_version(self) -> str:
        """
        The minimum version of TLS for SSL requests to the SCM site.
        """
        return pulumi.get(self, "scm_minimum_tls_version")

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> str:
        return pulumi.get(self, "scm_type")

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> bool:
        """
        Is the Linux Function App `ip_restriction` configuration used for the SCM also?
        """
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @property
    @pulumi.getter(name="use32BitWorker")
    def use32_bit_worker(self) -> bool:
        """
        Does the Linux Web App use a 32-bit worker process?
        """
        return pulumi.get(self, "use32_bit_worker")

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> bool:
        """
        Are all outbound traffic to NAT Gateways, Network Security Groups and User Defined Routes applied?
        """
        return pulumi.get(self, "vnet_route_all_enabled")

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> bool:
        """
        Are Web Sockets enabled?
        """
        return pulumi.get(self, "websockets_enabled")

    @property
    @pulumi.getter(name="workerCount")
    def worker_count(self) -> int:
        """
        The number of Workers for this Linux Function App.
        """
        return pulumi.get(self, "worker_count")


@pulumi.output_type
class GetLinuxFunctionAppSiteConfigAppServiceLogResult(dict):
    def __init__(__self__, *,
                 disk_quota_mb: int,
                 retention_period_days: int):
        """
        :param int disk_quota_mb: The amount of disk space used for logs.
        :param int retention_period_days: After how many days backups are deleted.
        """
        pulumi.set(__self__, "disk_quota_mb", disk_quota_mb)
        pulumi.set(__self__, "retention_period_days", retention_period_days)

    @property
    @pulumi.getter(name="diskQuotaMb")
    def disk_quota_mb(self) -> int:
        """
        The amount of disk space used for logs.
        """
        return pulumi.get(self, "disk_quota_mb")

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> int:
        """
        After how many days backups are deleted.
        """
        return pulumi.get(self, "retention_period_days")


@pulumi.output_type
class GetLinuxFunctionAppSiteConfigApplicationStackResult(dict):
    def __init__(__self__, *,
                 dockers: Sequence['outputs.GetLinuxFunctionAppSiteConfigApplicationStackDockerResult'],
                 dotnet_version: str,
                 java_version: str,
                 node_version: str,
                 powershell_core_version: str,
                 python_version: str,
                 use_custom_runtime: bool,
                 use_dotnet_isolated_runtime: bool):
        """
        :param Sequence['GetLinuxFunctionAppSiteConfigApplicationStackDockerArgs'] dockers: One or more `docker` blocks as defined below.
        :param str dotnet_version: The version of .NET used.
        :param str java_version: The Version of Java used.
        :param str node_version: The version of Node used.
        :param str powershell_core_version: The version of PowerShell Core used.
        :param str python_version: The version of Python used.
        :param bool use_custom_runtime: Does the Linux Function App use a custom runtime?
        """
        pulumi.set(__self__, "dockers", dockers)
        pulumi.set(__self__, "dotnet_version", dotnet_version)
        pulumi.set(__self__, "java_version", java_version)
        pulumi.set(__self__, "node_version", node_version)
        pulumi.set(__self__, "powershell_core_version", powershell_core_version)
        pulumi.set(__self__, "python_version", python_version)
        pulumi.set(__self__, "use_custom_runtime", use_custom_runtime)
        pulumi.set(__self__, "use_dotnet_isolated_runtime", use_dotnet_isolated_runtime)

    @property
    @pulumi.getter
    def dockers(self) -> Sequence['outputs.GetLinuxFunctionAppSiteConfigApplicationStackDockerResult']:
        """
        One or more `docker` blocks as defined below.
        """
        return pulumi.get(self, "dockers")

    @property
    @pulumi.getter(name="dotnetVersion")
    def dotnet_version(self) -> str:
        """
        The version of .NET used.
        """
        return pulumi.get(self, "dotnet_version")

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> str:
        """
        The Version of Java used.
        """
        return pulumi.get(self, "java_version")

    @property
    @pulumi.getter(name="nodeVersion")
    def node_version(self) -> str:
        """
        The version of Node used.
        """
        return pulumi.get(self, "node_version")

    @property
    @pulumi.getter(name="powershellCoreVersion")
    def powershell_core_version(self) -> str:
        """
        The version of PowerShell Core used.
        """
        return pulumi.get(self, "powershell_core_version")

    @property
    @pulumi.getter(name="pythonVersion")
    def python_version(self) -> str:
        """
        The version of Python used.
        """
        return pulumi.get(self, "python_version")

    @property
    @pulumi.getter(name="useCustomRuntime")
    def use_custom_runtime(self) -> bool:
        """
        Does the Linux Function App use a custom runtime?
        """
        return pulumi.get(self, "use_custom_runtime")

    @property
    @pulumi.getter(name="useDotnetIsolatedRuntime")
    def use_dotnet_isolated_runtime(self) -> bool:
        return pulumi.get(self, "use_dotnet_isolated_runtime")


@pulumi.output_type
class GetLinuxFunctionAppSiteConfigApplicationStackDockerResult(dict):
    def __init__(__self__, *,
                 image_name: str,
                 image_tag: str,
                 registry_password: str,
                 registry_url: str,
                 registry_username: str):
        """
        :param str image_name: The name of the Docker image used.
        :param str image_tag: The image tag of the image used.
        :param str registry_password: The password for the account to use to connect to the registry.
        :param str registry_url: The URL of the docker registry.
        :param str registry_username: The username used for connections to the registry.
        """
        pulumi.set(__self__, "image_name", image_name)
        pulumi.set(__self__, "image_tag", image_tag)
        pulumi.set(__self__, "registry_password", registry_password)
        pulumi.set(__self__, "registry_url", registry_url)
        pulumi.set(__self__, "registry_username", registry_username)

    @property
    @pulumi.getter(name="imageName")
    def image_name(self) -> str:
        """
        The name of the Docker image used.
        """
        return pulumi.get(self, "image_name")

    @property
    @pulumi.getter(name="imageTag")
    def image_tag(self) -> str:
        """
        The image tag of the image used.
        """
        return pulumi.get(self, "image_tag")

    @property
    @pulumi.getter(name="registryPassword")
    def registry_password(self) -> str:
        """
        The password for the account to use to connect to the registry.
        """
        return pulumi.get(self, "registry_password")

    @property
    @pulumi.getter(name="registryUrl")
    def registry_url(self) -> str:
        """
        The URL of the docker registry.
        """
        return pulumi.get(self, "registry_url")

    @property
    @pulumi.getter(name="registryUsername")
    def registry_username(self) -> str:
        """
        The username used for connections to the registry.
        """
        return pulumi.get(self, "registry_username")


@pulumi.output_type
class GetLinuxFunctionAppSiteConfigCorResult(dict):
    def __init__(__self__, *,
                 allowed_origins: Sequence[str],
                 support_credentials: bool):
        """
        :param Sequence[str] allowed_origins: A list of origins that are allowed to make cross-origin calls.
        :param bool support_credentials: Are credentials allowed in CORS requests?
        """
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Sequence[str]:
        """
        A list of origins that are allowed to make cross-origin calls.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> bool:
        """
        Are credentials allowed in CORS requests?
        """
        return pulumi.get(self, "support_credentials")


@pulumi.output_type
class GetLinuxFunctionAppSiteConfigIpRestrictionResult(dict):
    def __init__(__self__, *,
                 action: str,
                 headers: Sequence['outputs.GetLinuxFunctionAppSiteConfigIpRestrictionHeaderResult'],
                 ip_address: str,
                 name: str,
                 priority: int,
                 service_tag: str,
                 virtual_network_subnet_id: str):
        """
        :param str action: The action taken.
        :param Sequence['GetLinuxFunctionAppSiteConfigIpRestrictionHeaderArgs'] headers: A `headers` block as defined above.
        :param str ip_address: The CIDR notation of the IP or IP Range matched.
        :param str name: The name which should be used for this Linux Function App.
        :param int priority: The priority value of this `ip_restriction`.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "service_tag", service_tag)
        pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action taken.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.GetLinuxFunctionAppSiteConfigIpRestrictionHeaderResult']:
        """
        A `headers` block as defined above.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The CIDR notation of the IP or IP Range matched.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Linux Function App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        The priority value of this `ip_restriction`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> str:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> str:
        """
        The Virtual Network Subnet ID used for this IP Restriction.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class GetLinuxFunctionAppSiteConfigIpRestrictionHeaderResult(dict):
    def __init__(__self__, *,
                 x_azure_fdids: Sequence[str],
                 x_fd_health_probes: Sequence[str],
                 x_forwarded_fors: Sequence[str],
                 x_forwarded_hosts: Sequence[str]):
        """
        :param Sequence[str] x_azure_fdids: A list of Azure Front Door IDs.
        :param Sequence[str] x_fd_health_probes: Should a Front Door Health Probe be expected?
        :param Sequence[str] x_forwarded_fors: A list of addresses for which matching is applied.
        :param Sequence[str] x_forwarded_hosts: A list of Hosts for which matching is applied.
        """
        pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        pulumi.set(__self__, "x_fd_health_probes", x_fd_health_probes)
        pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Sequence[str]:
        """
        A list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbes")
    def x_fd_health_probes(self) -> Sequence[str]:
        """
        Should a Front Door Health Probe be expected?
        """
        return pulumi.get(self, "x_fd_health_probes")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Sequence[str]:
        """
        A list of addresses for which matching is applied.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Sequence[str]:
        """
        A list of Hosts for which matching is applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class GetLinuxFunctionAppSiteConfigScmIpRestrictionResult(dict):
    def __init__(__self__, *,
                 action: str,
                 headers: Sequence['outputs.GetLinuxFunctionAppSiteConfigScmIpRestrictionHeaderResult'],
                 ip_address: str,
                 name: str,
                 priority: int,
                 service_tag: str,
                 virtual_network_subnet_id: str):
        """
        :param str action: The action taken.
        :param Sequence['GetLinuxFunctionAppSiteConfigScmIpRestrictionHeaderArgs'] headers: A `headers` block as defined above.
        :param str ip_address: The CIDR notation of the IP or IP Range matched.
        :param str name: The name which should be used for this Linux Function App.
        :param int priority: The priority value of this `ip_restriction`.
        :param str service_tag: The Service Tag used for this IP Restriction.
        :param str virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "service_tag", service_tag)
        pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action taken.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.GetLinuxFunctionAppSiteConfigScmIpRestrictionHeaderResult']:
        """
        A `headers` block as defined above.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The CIDR notation of the IP or IP Range matched.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Linux Function App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        The priority value of this `ip_restriction`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> str:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> str:
        """
        The Virtual Network Subnet ID used for this IP Restriction.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class GetLinuxFunctionAppSiteConfigScmIpRestrictionHeaderResult(dict):
    def __init__(__self__, *,
                 x_azure_fdids: Sequence[str],
                 x_fd_health_probes: Sequence[str],
                 x_forwarded_fors: Sequence[str],
                 x_forwarded_hosts: Sequence[str]):
        """
        :param Sequence[str] x_azure_fdids: A list of Azure Front Door IDs.
        :param Sequence[str] x_fd_health_probes: Should a Front Door Health Probe be expected?
        :param Sequence[str] x_forwarded_fors: A list of addresses for which matching is applied.
        :param Sequence[str] x_forwarded_hosts: A list of Hosts for which matching is applied.
        """
        pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        pulumi.set(__self__, "x_fd_health_probes", x_fd_health_probes)
        pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Sequence[str]:
        """
        A list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbes")
    def x_fd_health_probes(self) -> Sequence[str]:
        """
        Should a Front Door Health Probe be expected?
        """
        return pulumi.get(self, "x_fd_health_probes")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Sequence[str]:
        """
        A list of addresses for which matching is applied.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Sequence[str]:
        """
        A list of Hosts for which matching is applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class GetLinuxFunctionAppSiteCredentialResult(dict):
    def __init__(__self__, *,
                 name: str,
                 password: str):
        """
        :param str name: The name which should be used for this Linux Function App.
        :param str password: The Site Credentials Password used for publishing.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Linux Function App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The Site Credentials Password used for publishing.
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class GetLinuxFunctionAppStickySettingResult(dict):
    def __init__(__self__, *,
                 app_setting_names: Sequence[str],
                 connection_string_names: Sequence[str]):
        """
        :param Sequence[str] app_setting_names: A list of `app_setting` names that the Linux Function App will not swap between Slots when a swap operation is triggered.
        :param Sequence[str] connection_string_names: A list of `connection_string` names that the Linux Function App will not swap between Slots when a swap operation is triggered.
        """
        pulumi.set(__self__, "app_setting_names", app_setting_names)
        pulumi.set(__self__, "connection_string_names", connection_string_names)

    @property
    @pulumi.getter(name="appSettingNames")
    def app_setting_names(self) -> Sequence[str]:
        """
        A list of `app_setting` names that the Linux Function App will not swap between Slots when a swap operation is triggered.
        """
        return pulumi.get(self, "app_setting_names")

    @property
    @pulumi.getter(name="connectionStringNames")
    def connection_string_names(self) -> Sequence[str]:
        """
        A list of `connection_string` names that the Linux Function App will not swap between Slots when a swap operation is triggered.
        """
        return pulumi.get(self, "connection_string_names")


@pulumi.output_type
class GetLinuxWebAppAuthSettingResult(dict):
    def __init__(__self__, *,
                 active_directories: Sequence['outputs.GetLinuxWebAppAuthSettingActiveDirectoryResult'],
                 additional_login_parameters: Mapping[str, str],
                 allowed_external_redirect_urls: Sequence[str],
                 default_provider: str,
                 enabled: bool,
                 facebooks: Sequence['outputs.GetLinuxWebAppAuthSettingFacebookResult'],
                 githubs: Sequence['outputs.GetLinuxWebAppAuthSettingGithubResult'],
                 googles: Sequence['outputs.GetLinuxWebAppAuthSettingGoogleResult'],
                 issuer: str,
                 microsofts: Sequence['outputs.GetLinuxWebAppAuthSettingMicrosoftResult'],
                 runtime_version: str,
                 token_refresh_extension_hours: float,
                 token_store_enabled: bool,
                 twitters: Sequence['outputs.GetLinuxWebAppAuthSettingTwitterResult'],
                 unauthenticated_client_action: str):
        """
        :param Sequence['GetLinuxWebAppAuthSettingActiveDirectoryArgs'] active_directories: A `active_directory` block as defined above.
        :param Mapping[str, str] additional_login_parameters: A `additional_login_parameters` block as defined above.
        :param Sequence[str] allowed_external_redirect_urls: A `allowed_external_redirect_urls` block as defined above.
        :param str default_provider: The default authentication provider in use when multiple providers are configured.
        :param bool enabled: Is the Backup enabled?
        :param Sequence['GetLinuxWebAppAuthSettingFacebookArgs'] facebooks: A `facebook` block as defined below.
        :param Sequence['GetLinuxWebAppAuthSettingGithubArgs'] githubs: A `github` block as defined below.
        :param Sequence['GetLinuxWebAppAuthSettingGoogleArgs'] googles: A `google` block as defined below.
        :param str issuer: The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Linux Web App.
        :param Sequence['GetLinuxWebAppAuthSettingMicrosoftArgs'] microsofts: A `microsoft` block as defined below.
        :param str runtime_version: The RuntimeVersion of the Authentication / Authorization feature in use for the Linux Web App.
        :param float token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to call the token refresh API.
        :param bool token_store_enabled: Does Linux Web App durably store platform-specific security tokens that are obtained during login flows enabled?
        :param Sequence['GetLinuxWebAppAuthSettingTwitterArgs'] twitters: A `twitter` block as defined below.
        :param str unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app.
        """
        pulumi.set(__self__, "active_directories", active_directories)
        pulumi.set(__self__, "additional_login_parameters", additional_login_parameters)
        pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        pulumi.set(__self__, "default_provider", default_provider)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "facebooks", facebooks)
        pulumi.set(__self__, "githubs", githubs)
        pulumi.set(__self__, "googles", googles)
        pulumi.set(__self__, "issuer", issuer)
        pulumi.set(__self__, "microsofts", microsofts)
        pulumi.set(__self__, "runtime_version", runtime_version)
        pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)
        pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        pulumi.set(__self__, "twitters", twitters)
        pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter(name="activeDirectories")
    def active_directories(self) -> Sequence['outputs.GetLinuxWebAppAuthSettingActiveDirectoryResult']:
        """
        A `active_directory` block as defined above.
        """
        return pulumi.get(self, "active_directories")

    @property
    @pulumi.getter(name="additionalLoginParameters")
    def additional_login_parameters(self) -> Mapping[str, str]:
        """
        A `additional_login_parameters` block as defined above.
        """
        return pulumi.get(self, "additional_login_parameters")

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Sequence[str]:
        """
        A `allowed_external_redirect_urls` block as defined above.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> str:
        """
        The default authentication provider in use when multiple providers are configured.
        """
        return pulumi.get(self, "default_provider")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is the Backup enabled?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def facebooks(self) -> Sequence['outputs.GetLinuxWebAppAuthSettingFacebookResult']:
        """
        A `facebook` block as defined below.
        """
        return pulumi.get(self, "facebooks")

    @property
    @pulumi.getter
    def githubs(self) -> Sequence['outputs.GetLinuxWebAppAuthSettingGithubResult']:
        """
        A `github` block as defined below.
        """
        return pulumi.get(self, "githubs")

    @property
    @pulumi.getter
    def googles(self) -> Sequence['outputs.GetLinuxWebAppAuthSettingGoogleResult']:
        """
        A `google` block as defined below.
        """
        return pulumi.get(self, "googles")

    @property
    @pulumi.getter
    def issuer(self) -> str:
        """
        The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Linux Web App.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def microsofts(self) -> Sequence['outputs.GetLinuxWebAppAuthSettingMicrosoftResult']:
        """
        A `microsoft` block as defined below.
        """
        return pulumi.get(self, "microsofts")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> str:
        """
        The RuntimeVersion of the Authentication / Authorization feature in use for the Linux Web App.
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> float:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API.
        """
        return pulumi.get(self, "token_refresh_extension_hours")

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> bool:
        """
        Does Linux Web App durably store platform-specific security tokens that are obtained during login flows enabled?
        """
        return pulumi.get(self, "token_store_enabled")

    @property
    @pulumi.getter
    def twitters(self) -> Sequence['outputs.GetLinuxWebAppAuthSettingTwitterResult']:
        """
        A `twitter` block as defined below.
        """
        return pulumi.get(self, "twitters")

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> str:
        """
        The action to take when an unauthenticated client attempts to access the app.
        """
        return pulumi.get(self, "unauthenticated_client_action")


@pulumi.output_type
class GetLinuxWebAppAuthSettingActiveDirectoryResult(dict):
    def __init__(__self__, *,
                 allowed_audiences: Sequence[str],
                 client_id: str,
                 client_secret: str,
                 client_secret_setting_name: str):
        """
        :param Sequence[str] allowed_audiences: An `allowed_audiences` block as defined below.
        :param str client_id: The OAuth 2.0 client ID used by the app for authentication.
        :param str client_secret: The OAuth 2.0 client secret used by the app for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        """
        pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Sequence[str]:
        """
        An `allowed_audiences` block as defined below.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID used by the app for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The OAuth 2.0 client secret used by the app for authentication.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")


@pulumi.output_type
class GetLinuxWebAppAuthSettingFacebookResult(dict):
    def __init__(__self__, *,
                 app_id: str,
                 app_secret: str,
                 app_secret_setting_name: str,
                 oauth_scopes: Sequence[str]):
        """
        :param str app_id: The App ID of the Facebook app used for login.
        :param str app_secret: The App Secret of the Facebook app used for Facebook login.
        :param str app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook login.
        :param Sequence[str] oauth_scopes: A list of OAuth 2.0 scopes requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "app_secret", app_secret)
        pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appSecret")
    def app_secret(self) -> str:
        """
        The App Secret of the Facebook app used for Facebook login.
        """
        return pulumi.get(self, "app_secret")

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> str:
        """
        The app setting name that contains the `app_secret` value used for Facebook login.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Sequence[str]:
        """
        A list of OAuth 2.0 scopes requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class GetLinuxWebAppAuthSettingGithubResult(dict):
    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 client_secret_setting_name: str,
                 oauth_scopes: Sequence[str]):
        """
        :param str client_id: The OAuth 2.0 client ID used by the app for authentication.
        :param str client_secret: The OAuth 2.0 client secret used by the app for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        :param Sequence[str] oauth_scopes: A list of OAuth 2.0 scopes requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID used by the app for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The OAuth 2.0 client secret used by the app for authentication.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Sequence[str]:
        """
        A list of OAuth 2.0 scopes requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class GetLinuxWebAppAuthSettingGoogleResult(dict):
    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 client_secret_setting_name: str,
                 oauth_scopes: Sequence[str]):
        """
        :param str client_id: The OAuth 2.0 client ID used by the app for authentication.
        :param str client_secret: The OAuth 2.0 client secret used by the app for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        :param Sequence[str] oauth_scopes: A list of OAuth 2.0 scopes requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID used by the app for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The OAuth 2.0 client secret used by the app for authentication.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Sequence[str]:
        """
        A list of OAuth 2.0 scopes requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class GetLinuxWebAppAuthSettingMicrosoftResult(dict):
    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 client_secret_setting_name: str,
                 oauth_scopes: Sequence[str]):
        """
        :param str client_id: The OAuth 2.0 client ID used by the app for authentication.
        :param str client_secret: The OAuth 2.0 client secret used by the app for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        :param Sequence[str] oauth_scopes: A list of OAuth 2.0 scopes requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID used by the app for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The OAuth 2.0 client secret used by the app for authentication.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Sequence[str]:
        """
        A list of OAuth 2.0 scopes requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class GetLinuxWebAppAuthSettingTwitterResult(dict):
    def __init__(__self__, *,
                 consumer_key: str,
                 consumer_secret: str,
                 consumer_secret_setting_name: str):
        """
        :param str consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param str consumer_secret: The OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        :param str consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        pulumi.set(__self__, "consumer_secret", consumer_secret)
        pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> str:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> str:
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_secret")

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> str:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_secret_setting_name")


@pulumi.output_type
class GetLinuxWebAppBackupResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 name: str,
                 schedules: Sequence['outputs.GetLinuxWebAppBackupScheduleResult'],
                 storage_account_url: str):
        """
        :param bool enabled: Is the Backup enabled?
        :param str name: The name of this Linux Web App.
        :param Sequence['GetLinuxWebAppBackupScheduleArgs'] schedules: A `schedule` block as defined below.
        :param str storage_account_url: The SAS URL to the container.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schedules", schedules)
        pulumi.set(__self__, "storage_account_url", storage_account_url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is the Backup enabled?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this Linux Web App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def schedules(self) -> Sequence['outputs.GetLinuxWebAppBackupScheduleResult']:
        """
        A `schedule` block as defined below.
        """
        return pulumi.get(self, "schedules")

    @property
    @pulumi.getter(name="storageAccountUrl")
    def storage_account_url(self) -> str:
        """
        The SAS URL to the container.
        """
        return pulumi.get(self, "storage_account_url")


@pulumi.output_type
class GetLinuxWebAppBackupScheduleResult(dict):
    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_unit: str,
                 keep_at_least_one_backup: bool,
                 last_execution_time: str,
                 retention_period_days: int,
                 start_time: str):
        """
        :param int frequency_interval: How often the backup will be executed.
        :param str frequency_unit: The unit of time for how often the backup should take place.
        :param bool keep_at_least_one_backup: Will the service keep at least one backup, regardless of age of backup.
        :param str last_execution_time: The time of the last backup attempt.
        :param int retention_period_days: After how many days backups should be deleted.
        :param str start_time: When the schedule should start in RFC-3339 format.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_unit", frequency_unit)
        pulumi.set(__self__, "keep_at_least_one_backup", keep_at_least_one_backup)
        pulumi.set(__self__, "last_execution_time", last_execution_time)
        pulumi.set(__self__, "retention_period_days", retention_period_days)
        pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        How often the backup will be executed.
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyUnit")
    def frequency_unit(self) -> str:
        """
        The unit of time for how often the backup should take place.
        """
        return pulumi.get(self, "frequency_unit")

    @property
    @pulumi.getter(name="keepAtLeastOneBackup")
    def keep_at_least_one_backup(self) -> bool:
        """
        Will the service keep at least one backup, regardless of age of backup.
        """
        return pulumi.get(self, "keep_at_least_one_backup")

    @property
    @pulumi.getter(name="lastExecutionTime")
    def last_execution_time(self) -> str:
        """
        The time of the last backup attempt.
        """
        return pulumi.get(self, "last_execution_time")

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> int:
        """
        After how many days backups should be deleted.
        """
        return pulumi.get(self, "retention_period_days")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        """
        When the schedule should start in RFC-3339 format.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class GetLinuxWebAppConnectionStringResult(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: The name of this Linux Web App.
        :param str type: The Azure Storage Type.
        :param str value: The Connection String value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this Linux Web App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The Azure Storage Type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The Connection String value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetLinuxWebAppIdentityResult(dict):
    def __init__(__self__, *,
                 identity_ids: Sequence[str],
                 principal_id: str,
                 tenant_id: str,
                 type: str):
        """
        :param Sequence[str] identity_ids: The list of User Assigned Managed Identity IDs assigned to this Linux Web App.
        :param str principal_id: The Principal ID of the System Assigned Managed Service Identity that is configured on this Linux Web App.
        :param str tenant_id: The Tenant ID of the System Assigned Managed Service Identity that is configured on this Linux Web App.
        :param str type: The Azure Storage Type.
        """
        pulumi.set(__self__, "identity_ids", identity_ids)
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Sequence[str]:
        """
        The list of User Assigned Managed Identity IDs assigned to this Linux Web App.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The Principal ID of the System Assigned Managed Service Identity that is configured on this Linux Web App.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The Tenant ID of the System Assigned Managed Service Identity that is configured on this Linux Web App.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The Azure Storage Type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetLinuxWebAppLogResult(dict):
    def __init__(__self__, *,
                 application_logs: Sequence['outputs.GetLinuxWebAppLogApplicationLogResult'],
                 detailed_error_messages: bool,
                 failed_request_tracing: bool,
                 http_logs: Sequence['outputs.GetLinuxWebAppLogHttpLogResult']):
        """
        :param Sequence['GetLinuxWebAppLogApplicationLogArgs'] application_logs: A `application_logs` block as defined above.
        :param bool detailed_error_messages: Is Detailed Error Messaging enabled.
        :param bool failed_request_tracing: Is Failed Request Tracing enabled.
        :param Sequence['GetLinuxWebAppLogHttpLogArgs'] http_logs: An `http_logs` block as defined above.
        """
        pulumi.set(__self__, "application_logs", application_logs)
        pulumi.set(__self__, "detailed_error_messages", detailed_error_messages)
        pulumi.set(__self__, "failed_request_tracing", failed_request_tracing)
        pulumi.set(__self__, "http_logs", http_logs)

    @property
    @pulumi.getter(name="applicationLogs")
    def application_logs(self) -> Sequence['outputs.GetLinuxWebAppLogApplicationLogResult']:
        """
        A `application_logs` block as defined above.
        """
        return pulumi.get(self, "application_logs")

    @property
    @pulumi.getter(name="detailedErrorMessages")
    def detailed_error_messages(self) -> bool:
        """
        Is Detailed Error Messaging enabled.
        """
        return pulumi.get(self, "detailed_error_messages")

    @property
    @pulumi.getter(name="failedRequestTracing")
    def failed_request_tracing(self) -> bool:
        """
        Is Failed Request Tracing enabled.
        """
        return pulumi.get(self, "failed_request_tracing")

    @property
    @pulumi.getter(name="httpLogs")
    def http_logs(self) -> Sequence['outputs.GetLinuxWebAppLogHttpLogResult']:
        """
        An `http_logs` block as defined above.
        """
        return pulumi.get(self, "http_logs")


@pulumi.output_type
class GetLinuxWebAppLogApplicationLogResult(dict):
    def __init__(__self__, *,
                 azure_blob_storages: Sequence['outputs.GetLinuxWebAppLogApplicationLogAzureBlobStorageResult'],
                 file_system_level: str):
        """
        :param Sequence['GetLinuxWebAppLogApplicationLogAzureBlobStorageArgs'] azure_blob_storages: A `azure_blob_storage` block as defined above.
        :param str file_system_level: The logging level.
        """
        pulumi.set(__self__, "azure_blob_storages", azure_blob_storages)
        pulumi.set(__self__, "file_system_level", file_system_level)

    @property
    @pulumi.getter(name="azureBlobStorages")
    def azure_blob_storages(self) -> Sequence['outputs.GetLinuxWebAppLogApplicationLogAzureBlobStorageResult']:
        """
        A `azure_blob_storage` block as defined above.
        """
        return pulumi.get(self, "azure_blob_storages")

    @property
    @pulumi.getter(name="fileSystemLevel")
    def file_system_level(self) -> str:
        """
        The logging level.
        """
        return pulumi.get(self, "file_system_level")


@pulumi.output_type
class GetLinuxWebAppLogApplicationLogAzureBlobStorageResult(dict):
    def __init__(__self__, *,
                 level: str,
                 retention_in_days: int,
                 sas_url: str):
        """
        :param str level: The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        :param int retention_in_days: The retention period in days.
        :param str sas_url: The SAS url to an Azure blob container.
        """
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "sas_url", sas_url)

    @property
    @pulumi.getter
    def level(self) -> str:
        """
        The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        """
        return pulumi.get(self, "level")

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> int:
        """
        The retention period in days.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> str:
        """
        The SAS url to an Azure blob container.
        """
        return pulumi.get(self, "sas_url")


@pulumi.output_type
class GetLinuxWebAppLogHttpLogResult(dict):
    def __init__(__self__, *,
                 azure_blob_storages: Sequence['outputs.GetLinuxWebAppLogHttpLogAzureBlobStorageResult'],
                 file_systems: Sequence['outputs.GetLinuxWebAppLogHttpLogFileSystemResult']):
        """
        :param Sequence['GetLinuxWebAppLogHttpLogAzureBlobStorageArgs'] azure_blob_storages: A `azure_blob_storage` block as defined above.
        :param Sequence['GetLinuxWebAppLogHttpLogFileSystemArgs'] file_systems: A `file_system` block as defined above.
        """
        pulumi.set(__self__, "azure_blob_storages", azure_blob_storages)
        pulumi.set(__self__, "file_systems", file_systems)

    @property
    @pulumi.getter(name="azureBlobStorages")
    def azure_blob_storages(self) -> Sequence['outputs.GetLinuxWebAppLogHttpLogAzureBlobStorageResult']:
        """
        A `azure_blob_storage` block as defined above.
        """
        return pulumi.get(self, "azure_blob_storages")

    @property
    @pulumi.getter(name="fileSystems")
    def file_systems(self) -> Sequence['outputs.GetLinuxWebAppLogHttpLogFileSystemResult']:
        """
        A `file_system` block as defined above.
        """
        return pulumi.get(self, "file_systems")


@pulumi.output_type
class GetLinuxWebAppLogHttpLogAzureBlobStorageResult(dict):
    def __init__(__self__, *,
                 retention_in_days: int,
                 sas_url: str):
        """
        :param int retention_in_days: The retention period in days.
        :param str sas_url: The SAS url to an Azure blob container.
        """
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "sas_url", sas_url)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> int:
        """
        The retention period in days.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> str:
        """
        The SAS url to an Azure blob container.
        """
        return pulumi.get(self, "sas_url")


@pulumi.output_type
class GetLinuxWebAppLogHttpLogFileSystemResult(dict):
    def __init__(__self__, *,
                 retention_in_days: int,
                 retention_in_mb: int):
        """
        :param int retention_in_days: The retention period in days.
        :param int retention_in_mb: The maximum size in megabytes that log files can use.
        """
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "retention_in_mb", retention_in_mb)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> int:
        """
        The retention period in days.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="retentionInMb")
    def retention_in_mb(self) -> int:
        """
        The maximum size in megabytes that log files can use.
        """
        return pulumi.get(self, "retention_in_mb")


@pulumi.output_type
class GetLinuxWebAppSiteConfigResult(dict):
    def __init__(__self__, *,
                 always_on: bool,
                 api_definition_url: str,
                 api_management_api_id: str,
                 app_command_line: str,
                 application_stacks: Sequence['outputs.GetLinuxWebAppSiteConfigApplicationStackResult'],
                 auto_heal_enabled: bool,
                 auto_heal_settings: Sequence['outputs.GetLinuxWebAppSiteConfigAutoHealSettingResult'],
                 container_registry_managed_identity_client_id: str,
                 container_registry_use_managed_identity: bool,
                 cors: Sequence['outputs.GetLinuxWebAppSiteConfigCorResult'],
                 default_documents: Sequence[str],
                 detailed_error_logging_enabled: bool,
                 ftps_state: str,
                 health_check_eviction_time_in_min: int,
                 health_check_path: str,
                 http2_enabled: bool,
                 ip_restrictions: Sequence['outputs.GetLinuxWebAppSiteConfigIpRestrictionResult'],
                 linux_fx_version: str,
                 load_balancing_mode: str,
                 local_mysql_enabled: bool,
                 managed_pipeline_mode: str,
                 minimum_tls_version: str,
                 remote_debugging_enabled: bool,
                 remote_debugging_version: str,
                 scm_ip_restrictions: Sequence['outputs.GetLinuxWebAppSiteConfigScmIpRestrictionResult'],
                 scm_minimum_tls_version: str,
                 scm_type: str,
                 scm_use_main_ip_restriction: bool,
                 use32_bit_worker: bool,
                 vnet_route_all_enabled: bool,
                 websockets_enabled: bool,
                 worker_count: int):
        """
        :param bool always_on: Is this Linux Web App is Always On enabled.
        :param str api_definition_url: The ID of the APIM configuration for this Linux Web App.
        :param str api_management_api_id: The ID of the API Management API for this Linux Web App.
        :param str app_command_line: The command line used to launch this app.
        :param Sequence['GetLinuxWebAppSiteConfigApplicationStackArgs'] application_stacks: A `application_stack` block as defined above.
        :param bool auto_heal_enabled: Are Auto heal rules be enabled.
        :param Sequence['GetLinuxWebAppSiteConfigAutoHealSettingArgs'] auto_heal_settings: A `auto_heal_setting` block as defined above.
        :param str container_registry_managed_identity_client_id: The Client ID of the Managed Service Identity used for connections to the Azure Container Registry.
        :param bool container_registry_use_managed_identity: Do connections for Azure Container Registry use Managed Identity.
        :param Sequence['GetLinuxWebAppSiteConfigCorArgs'] cors: A `cors` block as defined above.
        :param Sequence[str] default_documents: The list of Default Documents for the Linux Web App.
        :param bool detailed_error_logging_enabled: Is Detailed Error Logging enabled.
        :param str ftps_state: The State of FTP / FTPS service.
        :param int health_check_eviction_time_in_min: (Optional) The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        :param str health_check_path: The path to the Health Check endpoint.
        :param bool http2_enabled: Is HTTP2.0 enabled.
        :param Sequence['GetLinuxWebAppSiteConfigIpRestrictionArgs'] ip_restrictions: A `ip_restriction` block as defined above.
        :param str linux_fx_version: The `LinuxFXVersion` string.
        :param str load_balancing_mode: The site Load Balancing Mode.
        :param bool local_mysql_enabled: Is the Local MySQL enabled.
        :param str managed_pipeline_mode: The Managed Pipeline Mode.
        :param str minimum_tls_version: The Minimum version of TLS for requests.
        :param bool remote_debugging_enabled: Is Remote Debugging enabled.
        :param str remote_debugging_version: The Remote Debugging Version.
        :param Sequence['GetLinuxWebAppSiteConfigScmIpRestrictionArgs'] scm_ip_restrictions: A `scm_ip_restriction` block as defined above.
        :param str scm_minimum_tls_version: The Minimum version of TLS for requests to SCM.
        :param str scm_type: The Source Control Management Type in use.
        :param bool scm_use_main_ip_restriction: Is the Linux Web App `ip_restriction` configuration used for the SCM also.
        :param bool use32_bit_worker: Does the Linux Web App use a 32-bit worker.
        :param bool vnet_route_all_enabled: Are all outbound traffic to NAT Gateways, Network Security Groups and User Defined Routes applied?
        :param bool websockets_enabled: Are Web Sockets enabled?
        :param int worker_count: The number of Workers for this Linux App Service.
        """
        pulumi.set(__self__, "always_on", always_on)
        pulumi.set(__self__, "api_definition_url", api_definition_url)
        pulumi.set(__self__, "api_management_api_id", api_management_api_id)
        pulumi.set(__self__, "app_command_line", app_command_line)
        pulumi.set(__self__, "application_stacks", application_stacks)
        pulumi.set(__self__, "auto_heal_enabled", auto_heal_enabled)
        pulumi.set(__self__, "auto_heal_settings", auto_heal_settings)
        pulumi.set(__self__, "container_registry_managed_identity_client_id", container_registry_managed_identity_client_id)
        pulumi.set(__self__, "container_registry_use_managed_identity", container_registry_use_managed_identity)
        pulumi.set(__self__, "cors", cors)
        pulumi.set(__self__, "default_documents", default_documents)
        pulumi.set(__self__, "detailed_error_logging_enabled", detailed_error_logging_enabled)
        pulumi.set(__self__, "ftps_state", ftps_state)
        pulumi.set(__self__, "health_check_eviction_time_in_min", health_check_eviction_time_in_min)
        pulumi.set(__self__, "health_check_path", health_check_path)
        pulumi.set(__self__, "http2_enabled", http2_enabled)
        pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        pulumi.set(__self__, "linux_fx_version", linux_fx_version)
        pulumi.set(__self__, "load_balancing_mode", load_balancing_mode)
        pulumi.set(__self__, "local_mysql_enabled", local_mysql_enabled)
        pulumi.set(__self__, "managed_pipeline_mode", managed_pipeline_mode)
        pulumi.set(__self__, "minimum_tls_version", minimum_tls_version)
        pulumi.set(__self__, "remote_debugging_enabled", remote_debugging_enabled)
        pulumi.set(__self__, "remote_debugging_version", remote_debugging_version)
        pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        pulumi.set(__self__, "scm_minimum_tls_version", scm_minimum_tls_version)
        pulumi.set(__self__, "scm_type", scm_type)
        pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        pulumi.set(__self__, "use32_bit_worker", use32_bit_worker)
        pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        pulumi.set(__self__, "websockets_enabled", websockets_enabled)
        pulumi.set(__self__, "worker_count", worker_count)

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> bool:
        """
        Is this Linux Web App is Always On enabled.
        """
        return pulumi.get(self, "always_on")

    @property
    @pulumi.getter(name="apiDefinitionUrl")
    def api_definition_url(self) -> str:
        """
        The ID of the APIM configuration for this Linux Web App.
        """
        return pulumi.get(self, "api_definition_url")

    @property
    @pulumi.getter(name="apiManagementApiId")
    def api_management_api_id(self) -> str:
        """
        The ID of the API Management API for this Linux Web App.
        """
        return pulumi.get(self, "api_management_api_id")

    @property
    @pulumi.getter(name="appCommandLine")
    def app_command_line(self) -> str:
        """
        The command line used to launch this app.
        """
        return pulumi.get(self, "app_command_line")

    @property
    @pulumi.getter(name="applicationStacks")
    def application_stacks(self) -> Sequence['outputs.GetLinuxWebAppSiteConfigApplicationStackResult']:
        """
        A `application_stack` block as defined above.
        """
        return pulumi.get(self, "application_stacks")

    @property
    @pulumi.getter(name="autoHealEnabled")
    def auto_heal_enabled(self) -> bool:
        """
        Are Auto heal rules be enabled.
        """
        return pulumi.get(self, "auto_heal_enabled")

    @property
    @pulumi.getter(name="autoHealSettings")
    def auto_heal_settings(self) -> Sequence['outputs.GetLinuxWebAppSiteConfigAutoHealSettingResult']:
        """
        A `auto_heal_setting` block as defined above.
        """
        return pulumi.get(self, "auto_heal_settings")

    @property
    @pulumi.getter(name="containerRegistryManagedIdentityClientId")
    def container_registry_managed_identity_client_id(self) -> str:
        """
        The Client ID of the Managed Service Identity used for connections to the Azure Container Registry.
        """
        return pulumi.get(self, "container_registry_managed_identity_client_id")

    @property
    @pulumi.getter(name="containerRegistryUseManagedIdentity")
    def container_registry_use_managed_identity(self) -> bool:
        """
        Do connections for Azure Container Registry use Managed Identity.
        """
        return pulumi.get(self, "container_registry_use_managed_identity")

    @property
    @pulumi.getter
    def cors(self) -> Sequence['outputs.GetLinuxWebAppSiteConfigCorResult']:
        """
        A `cors` block as defined above.
        """
        return pulumi.get(self, "cors")

    @property
    @pulumi.getter(name="defaultDocuments")
    def default_documents(self) -> Sequence[str]:
        """
        The list of Default Documents for the Linux Web App.
        """
        return pulumi.get(self, "default_documents")

    @property
    @pulumi.getter(name="detailedErrorLoggingEnabled")
    def detailed_error_logging_enabled(self) -> bool:
        """
        Is Detailed Error Logging enabled.
        """
        return pulumi.get(self, "detailed_error_logging_enabled")

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> str:
        """
        The State of FTP / FTPS service.
        """
        return pulumi.get(self, "ftps_state")

    @property
    @pulumi.getter(name="healthCheckEvictionTimeInMin")
    def health_check_eviction_time_in_min(self) -> int:
        """
        (Optional) The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        """
        return pulumi.get(self, "health_check_eviction_time_in_min")

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> str:
        """
        The path to the Health Check endpoint.
        """
        return pulumi.get(self, "health_check_path")

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> bool:
        """
        Is HTTP2.0 enabled.
        """
        return pulumi.get(self, "http2_enabled")

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Sequence['outputs.GetLinuxWebAppSiteConfigIpRestrictionResult']:
        """
        A `ip_restriction` block as defined above.
        """
        return pulumi.get(self, "ip_restrictions")

    @property
    @pulumi.getter(name="linuxFxVersion")
    def linux_fx_version(self) -> str:
        """
        The `LinuxFXVersion` string.
        """
        return pulumi.get(self, "linux_fx_version")

    @property
    @pulumi.getter(name="loadBalancingMode")
    def load_balancing_mode(self) -> str:
        """
        The site Load Balancing Mode.
        """
        return pulumi.get(self, "load_balancing_mode")

    @property
    @pulumi.getter(name="localMysqlEnabled")
    def local_mysql_enabled(self) -> bool:
        """
        Is the Local MySQL enabled.
        """
        return pulumi.get(self, "local_mysql_enabled")

    @property
    @pulumi.getter(name="managedPipelineMode")
    def managed_pipeline_mode(self) -> str:
        """
        The Managed Pipeline Mode.
        """
        return pulumi.get(self, "managed_pipeline_mode")

    @property
    @pulumi.getter(name="minimumTlsVersion")
    def minimum_tls_version(self) -> str:
        """
        The Minimum version of TLS for requests.
        """
        return pulumi.get(self, "minimum_tls_version")

    @property
    @pulumi.getter(name="remoteDebuggingEnabled")
    def remote_debugging_enabled(self) -> bool:
        """
        Is Remote Debugging enabled.
        """
        return pulumi.get(self, "remote_debugging_enabled")

    @property
    @pulumi.getter(name="remoteDebuggingVersion")
    def remote_debugging_version(self) -> str:
        """
        The Remote Debugging Version.
        """
        return pulumi.get(self, "remote_debugging_version")

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Sequence['outputs.GetLinuxWebAppSiteConfigScmIpRestrictionResult']:
        """
        A `scm_ip_restriction` block as defined above.
        """
        return pulumi.get(self, "scm_ip_restrictions")

    @property
    @pulumi.getter(name="scmMinimumTlsVersion")
    def scm_minimum_tls_version(self) -> str:
        """
        The Minimum version of TLS for requests to SCM.
        """
        return pulumi.get(self, "scm_minimum_tls_version")

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> str:
        """
        The Source Control Management Type in use.
        """
        return pulumi.get(self, "scm_type")

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> bool:
        """
        Is the Linux Web App `ip_restriction` configuration used for the SCM also.
        """
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @property
    @pulumi.getter(name="use32BitWorker")
    def use32_bit_worker(self) -> bool:
        """
        Does the Linux Web App use a 32-bit worker.
        """
        return pulumi.get(self, "use32_bit_worker")

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> bool:
        """
        Are all outbound traffic to NAT Gateways, Network Security Groups and User Defined Routes applied?
        """
        return pulumi.get(self, "vnet_route_all_enabled")

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> bool:
        """
        Are Web Sockets enabled?
        """
        return pulumi.get(self, "websockets_enabled")

    @property
    @pulumi.getter(name="workerCount")
    def worker_count(self) -> int:
        """
        The number of Workers for this Linux App Service.
        """
        return pulumi.get(self, "worker_count")


@pulumi.output_type
class GetLinuxWebAppSiteConfigApplicationStackResult(dict):
    def __init__(__self__, *,
                 docker_image: str,
                 docker_image_tag: str,
                 dotnet_version: str,
                 java_server: str,
                 java_server_version: str,
                 java_version: str,
                 node_version: str,
                 php_version: str,
                 python_version: str,
                 ruby_version: str):
        """
        :param str docker_image: The Docker image reference, including repository.
        :param str docker_image_tag: The image Tag.
        :param str dotnet_version: The version of .NET in use.
        :param str java_server: The Java server type.
        :param str java_server_version: The Version of the `java_server` in use.
        :param str java_version: The Version of Java in use.
        :param str node_version: The version of Node in use.
        :param str php_version: The version of PHP in use.
        :param str python_version: The version of Python in use.
        :param str ruby_version: The version of Ruby in use.
        """
        pulumi.set(__self__, "docker_image", docker_image)
        pulumi.set(__self__, "docker_image_tag", docker_image_tag)
        pulumi.set(__self__, "dotnet_version", dotnet_version)
        pulumi.set(__self__, "java_server", java_server)
        pulumi.set(__self__, "java_server_version", java_server_version)
        pulumi.set(__self__, "java_version", java_version)
        pulumi.set(__self__, "node_version", node_version)
        pulumi.set(__self__, "php_version", php_version)
        pulumi.set(__self__, "python_version", python_version)
        pulumi.set(__self__, "ruby_version", ruby_version)

    @property
    @pulumi.getter(name="dockerImage")
    def docker_image(self) -> str:
        """
        The Docker image reference, including repository.
        """
        return pulumi.get(self, "docker_image")

    @property
    @pulumi.getter(name="dockerImageTag")
    def docker_image_tag(self) -> str:
        """
        The image Tag.
        """
        return pulumi.get(self, "docker_image_tag")

    @property
    @pulumi.getter(name="dotnetVersion")
    def dotnet_version(self) -> str:
        """
        The version of .NET in use.
        """
        return pulumi.get(self, "dotnet_version")

    @property
    @pulumi.getter(name="javaServer")
    def java_server(self) -> str:
        """
        The Java server type.
        """
        return pulumi.get(self, "java_server")

    @property
    @pulumi.getter(name="javaServerVersion")
    def java_server_version(self) -> str:
        """
        The Version of the `java_server` in use.
        """
        return pulumi.get(self, "java_server_version")

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> str:
        """
        The Version of Java in use.
        """
        return pulumi.get(self, "java_version")

    @property
    @pulumi.getter(name="nodeVersion")
    def node_version(self) -> str:
        """
        The version of Node in use.
        """
        return pulumi.get(self, "node_version")

    @property
    @pulumi.getter(name="phpVersion")
    def php_version(self) -> str:
        """
        The version of PHP in use.
        """
        return pulumi.get(self, "php_version")

    @property
    @pulumi.getter(name="pythonVersion")
    def python_version(self) -> str:
        """
        The version of Python in use.
        """
        return pulumi.get(self, "python_version")

    @property
    @pulumi.getter(name="rubyVersion")
    def ruby_version(self) -> str:
        """
        The version of Ruby in use.
        """
        return pulumi.get(self, "ruby_version")


@pulumi.output_type
class GetLinuxWebAppSiteConfigAutoHealSettingResult(dict):
    def __init__(__self__, *,
                 actions: Sequence['outputs.GetLinuxWebAppSiteConfigAutoHealSettingActionResult'],
                 triggers: Sequence['outputs.GetLinuxWebAppSiteConfigAutoHealSettingTriggerResult']):
        """
        :param Sequence['GetLinuxWebAppSiteConfigAutoHealSettingActionArgs'] actions: A `action` block as defined above.
        :param Sequence['GetLinuxWebAppSiteConfigAutoHealSettingTriggerArgs'] triggers: A `trigger` block as defined below.
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "triggers", triggers)

    @property
    @pulumi.getter
    def actions(self) -> Sequence['outputs.GetLinuxWebAppSiteConfigAutoHealSettingActionResult']:
        """
        A `action` block as defined above.
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter
    def triggers(self) -> Sequence['outputs.GetLinuxWebAppSiteConfigAutoHealSettingTriggerResult']:
        """
        A `trigger` block as defined below.
        """
        return pulumi.get(self, "triggers")


@pulumi.output_type
class GetLinuxWebAppSiteConfigAutoHealSettingActionResult(dict):
    def __init__(__self__, *,
                 action_type: str,
                 minimum_process_execution_time: str):
        """
        :param str action_type: The predefined action to be taken to an Auto Heal trigger.
        :param str minimum_process_execution_time: The minimum amount of time in `hh:mm:ss` the Linux Web App must have been running before the defined action will be run in the event of a trigger.
        """
        pulumi.set(__self__, "action_type", action_type)
        pulumi.set(__self__, "minimum_process_execution_time", minimum_process_execution_time)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> str:
        """
        The predefined action to be taken to an Auto Heal trigger.
        """
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter(name="minimumProcessExecutionTime")
    def minimum_process_execution_time(self) -> str:
        """
        The minimum amount of time in `hh:mm:ss` the Linux Web App must have been running before the defined action will be run in the event of a trigger.
        """
        return pulumi.get(self, "minimum_process_execution_time")


@pulumi.output_type
class GetLinuxWebAppSiteConfigAutoHealSettingTriggerResult(dict):
    def __init__(__self__, *,
                 requests: Sequence['outputs.GetLinuxWebAppSiteConfigAutoHealSettingTriggerRequestResult'],
                 status_codes: Sequence['outputs.GetLinuxWebAppSiteConfigAutoHealSettingTriggerStatusCodeResult'],
                 slow_requests: Optional[Sequence['outputs.GetLinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequestResult']] = None):
        """
        :param Sequence['GetLinuxWebAppSiteConfigAutoHealSettingTriggerRequestArgs'] requests: A `requests` block as defined above.
        :param Sequence['GetLinuxWebAppSiteConfigAutoHealSettingTriggerStatusCodeArgs'] status_codes: A `status_code` block as defined above.
        :param Sequence['GetLinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequestArgs'] slow_requests: A `slow_request` block as defined above.
        """
        pulumi.set(__self__, "requests", requests)
        pulumi.set(__self__, "status_codes", status_codes)
        if slow_requests is not None:
            pulumi.set(__self__, "slow_requests", slow_requests)

    @property
    @pulumi.getter
    def requests(self) -> Sequence['outputs.GetLinuxWebAppSiteConfigAutoHealSettingTriggerRequestResult']:
        """
        A `requests` block as defined above.
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="statusCodes")
    def status_codes(self) -> Sequence['outputs.GetLinuxWebAppSiteConfigAutoHealSettingTriggerStatusCodeResult']:
        """
        A `status_code` block as defined above.
        """
        return pulumi.get(self, "status_codes")

    @property
    @pulumi.getter(name="slowRequests")
    def slow_requests(self) -> Optional[Sequence['outputs.GetLinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequestResult']]:
        """
        A `slow_request` block as defined above.
        """
        return pulumi.get(self, "slow_requests")


@pulumi.output_type
class GetLinuxWebAppSiteConfigAutoHealSettingTriggerRequestResult(dict):
    def __init__(__self__, *,
                 count: int,
                 interval: str):
        """
        :param int count: The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        :param str interval: The time interval in the form `hh:mm:ss`.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        The time interval in the form `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class GetLinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequestResult(dict):
    def __init__(__self__, *,
                 count: int,
                 interval: str,
                 path: str,
                 time_taken: str):
        """
        :param int count: The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        :param str interval: The time interval in the form `hh:mm:ss`.
        :param str path: The path to which this rule status code applies.
        :param str time_taken: The amount of time that qualifies as slow for this rule.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "time_taken", time_taken)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        The time interval in the form `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The path to which this rule status code applies.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="timeTaken")
    def time_taken(self) -> str:
        """
        The amount of time that qualifies as slow for this rule.
        """
        return pulumi.get(self, "time_taken")


@pulumi.output_type
class GetLinuxWebAppSiteConfigAutoHealSettingTriggerStatusCodeResult(dict):
    def __init__(__self__, *,
                 count: int,
                 interval: str,
                 path: str,
                 status_code_range: str,
                 sub_status: int,
                 win32_status: str):
        """
        :param int count: The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        :param str interval: The time interval in the form `hh:mm:ss`.
        :param str path: The path to which this rule status code applies.
        :param str status_code_range: The status code or range for this rule.
        :param int sub_status: The Request Sub Status of the Status Code.
        :param str win32_status: The Win32 Status Code of the Request.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "status_code_range", status_code_range)
        pulumi.set(__self__, "sub_status", sub_status)
        pulumi.set(__self__, "win32_status", win32_status)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        The time interval in the form `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The path to which this rule status code applies.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="statusCodeRange")
    def status_code_range(self) -> str:
        """
        The status code or range for this rule.
        """
        return pulumi.get(self, "status_code_range")

    @property
    @pulumi.getter(name="subStatus")
    def sub_status(self) -> int:
        """
        The Request Sub Status of the Status Code.
        """
        return pulumi.get(self, "sub_status")

    @property
    @pulumi.getter(name="win32Status")
    def win32_status(self) -> str:
        """
        The Win32 Status Code of the Request.
        """
        return pulumi.get(self, "win32_status")


@pulumi.output_type
class GetLinuxWebAppSiteConfigCorResult(dict):
    def __init__(__self__, *,
                 allowed_origins: Sequence[str],
                 support_credentials: bool):
        """
        :param Sequence[str] allowed_origins: A list of origins that should be allowed to make cross-origin calls.
        :param bool support_credentials: Whether CORS requests with credentials are allowed.
        """
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Sequence[str]:
        """
        A list of origins that should be allowed to make cross-origin calls.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> bool:
        """
        Whether CORS requests with credentials are allowed.
        """
        return pulumi.get(self, "support_credentials")


@pulumi.output_type
class GetLinuxWebAppSiteConfigIpRestrictionResult(dict):
    def __init__(__self__, *,
                 action: str,
                 headers: Sequence['outputs.GetLinuxWebAppSiteConfigIpRestrictionHeaderResult'],
                 ip_address: str,
                 name: str,
                 priority: int,
                 service_tag: str,
                 virtual_network_subnet_id: str):
        """
        :param str action: A `action` block as defined above.
        :param str name: The name of this Linux Web App.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "service_tag", service_tag)
        pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        A `action` block as defined above.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.GetLinuxWebAppSiteConfigIpRestrictionHeaderResult']:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this Linux Web App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> str:
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> str:
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class GetLinuxWebAppSiteConfigIpRestrictionHeaderResult(dict):
    def __init__(__self__, *,
                 x_azure_fdids: Sequence[str],
                 x_fd_health_probes: Sequence[str],
                 x_forwarded_fors: Sequence[str],
                 x_forwarded_hosts: Sequence[str]):
        pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        pulumi.set(__self__, "x_fd_health_probes", x_fd_health_probes)
        pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Sequence[str]:
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbes")
    def x_fd_health_probes(self) -> Sequence[str]:
        return pulumi.get(self, "x_fd_health_probes")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Sequence[str]:
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Sequence[str]:
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class GetLinuxWebAppSiteConfigScmIpRestrictionResult(dict):
    def __init__(__self__, *,
                 action: str,
                 headers: Sequence['outputs.GetLinuxWebAppSiteConfigScmIpRestrictionHeaderResult'],
                 ip_address: str,
                 name: str,
                 priority: int,
                 service_tag: str,
                 virtual_network_subnet_id: str):
        """
        :param str action: A `action` block as defined above.
        :param str name: The name of this Linux Web App.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "service_tag", service_tag)
        pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        A `action` block as defined above.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.GetLinuxWebAppSiteConfigScmIpRestrictionHeaderResult']:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this Linux Web App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> str:
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> str:
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class GetLinuxWebAppSiteConfigScmIpRestrictionHeaderResult(dict):
    def __init__(__self__, *,
                 x_azure_fdids: Sequence[str],
                 x_fd_health_probes: Sequence[str],
                 x_forwarded_fors: Sequence[str],
                 x_forwarded_hosts: Sequence[str]):
        pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        pulumi.set(__self__, "x_fd_health_probes", x_fd_health_probes)
        pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Sequence[str]:
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbes")
    def x_fd_health_probes(self) -> Sequence[str]:
        return pulumi.get(self, "x_fd_health_probes")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Sequence[str]:
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Sequence[str]:
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class GetLinuxWebAppSiteCredentialResult(dict):
    def __init__(__self__, *,
                 name: str,
                 password: str):
        """
        :param str name: The name of this Linux Web App.
        :param str password: The Site Credentials Password used for publishing.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this Linux Web App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The Site Credentials Password used for publishing.
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class GetLinuxWebAppStickySettingResult(dict):
    def __init__(__self__, *,
                 app_setting_names: Sequence[str],
                 connection_string_names: Sequence[str]):
        """
        :param Sequence[str] app_setting_names: A list of `app_setting` names that the Linux Web App will not swap between Slots when a swap operation is triggered.
        :param Sequence[str] connection_string_names: A list of `connection_string` names that the Linux Web App will not swap between Slots when a swap operation is triggered.
        """
        pulumi.set(__self__, "app_setting_names", app_setting_names)
        pulumi.set(__self__, "connection_string_names", connection_string_names)

    @property
    @pulumi.getter(name="appSettingNames")
    def app_setting_names(self) -> Sequence[str]:
        """
        A list of `app_setting` names that the Linux Web App will not swap between Slots when a swap operation is triggered.
        """
        return pulumi.get(self, "app_setting_names")

    @property
    @pulumi.getter(name="connectionStringNames")
    def connection_string_names(self) -> Sequence[str]:
        """
        A list of `connection_string` names that the Linux Web App will not swap between Slots when a swap operation is triggered.
        """
        return pulumi.get(self, "connection_string_names")


@pulumi.output_type
class GetLinuxWebAppStorageAccountResult(dict):
    def __init__(__self__, *,
                 access_key: str,
                 account_name: str,
                 mount_path: str,
                 name: str,
                 share_name: str,
                 type: str):
        """
        :param str access_key: The Access key for the storage account.
        :param str account_name: The Name of the Storage Account.
        :param str mount_path: The path at which to mount the Storage Share.
        :param str name: The name of this Linux Web App.
        :param str share_name: The Name of the File Share or Container Name for Blob storage.
        :param str type: The Azure Storage Type.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "mount_path", mount_path)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "share_name", share_name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> str:
        """
        The Access key for the storage account.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> str:
        """
        The Name of the Storage Account.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> str:
        """
        The path at which to mount the Storage Share.
        """
        return pulumi.get(self, "mount_path")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this Linux Web App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> str:
        """
        The Name of the File Share or Container Name for Blob storage.
        """
        return pulumi.get(self, "share_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The Azure Storage Type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetWindowsFunctionAppAuthSettingResult(dict):
    def __init__(__self__, *,
                 active_directories: Sequence['outputs.GetWindowsFunctionAppAuthSettingActiveDirectoryResult'],
                 additional_login_parameters: Mapping[str, str],
                 allowed_external_redirect_urls: Sequence[str],
                 default_provider: str,
                 enabled: bool,
                 facebooks: Sequence['outputs.GetWindowsFunctionAppAuthSettingFacebookResult'],
                 githubs: Sequence['outputs.GetWindowsFunctionAppAuthSettingGithubResult'],
                 googles: Sequence['outputs.GetWindowsFunctionAppAuthSettingGoogleResult'],
                 issuer: str,
                 microsofts: Sequence['outputs.GetWindowsFunctionAppAuthSettingMicrosoftResult'],
                 runtime_version: str,
                 token_refresh_extension_hours: float,
                 token_store_enabled: bool,
                 twitters: Sequence['outputs.GetWindowsFunctionAppAuthSettingTwitterResult'],
                 unauthenticated_client_action: str):
        """
        :param Sequence['GetWindowsFunctionAppAuthSettingActiveDirectoryArgs'] active_directories: A `active_directory` block as defined above.
        :param Mapping[str, str] additional_login_parameters: A map of Login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        :param Sequence[str] allowed_external_redirect_urls: A list of External URLs that can be redirected to as part of logging in or logging out of the Windows Function App.
        :param str default_provider: The default authentication provider to use when multiple providers are configured.
        :param bool enabled: Is the Backup Job enabled?
        :param Sequence['GetWindowsFunctionAppAuthSettingFacebookArgs'] facebooks: A `facebook` block as defined below.
        :param Sequence['GetWindowsFunctionAppAuthSettingGithubArgs'] githubs: A `github` block as defined below.
        :param Sequence['GetWindowsFunctionAppAuthSettingGoogleArgs'] googles: A `google` block as defined below.
        :param str issuer: The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Windows Function App.
        :param Sequence['GetWindowsFunctionAppAuthSettingMicrosoftArgs'] microsofts: A `microsoft` block as defined below.
        :param str runtime_version: The Runtime Version of the Authentication / Authorization feature in use for the Windows Function App.
        :param float token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to call the token refresh API.
        :param bool token_store_enabled: Is the durable storing of platform-specific security token that are obtained during login flows enabled?
        :param Sequence['GetWindowsFunctionAppAuthSettingTwitterArgs'] twitters: A `twitter` block as defined below.
        :param str unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app.
        """
        pulumi.set(__self__, "active_directories", active_directories)
        pulumi.set(__self__, "additional_login_parameters", additional_login_parameters)
        pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        pulumi.set(__self__, "default_provider", default_provider)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "facebooks", facebooks)
        pulumi.set(__self__, "githubs", githubs)
        pulumi.set(__self__, "googles", googles)
        pulumi.set(__self__, "issuer", issuer)
        pulumi.set(__self__, "microsofts", microsofts)
        pulumi.set(__self__, "runtime_version", runtime_version)
        pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)
        pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        pulumi.set(__self__, "twitters", twitters)
        pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter(name="activeDirectories")
    def active_directories(self) -> Sequence['outputs.GetWindowsFunctionAppAuthSettingActiveDirectoryResult']:
        """
        A `active_directory` block as defined above.
        """
        return pulumi.get(self, "active_directories")

    @property
    @pulumi.getter(name="additionalLoginParameters")
    def additional_login_parameters(self) -> Mapping[str, str]:
        """
        A map of Login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        """
        return pulumi.get(self, "additional_login_parameters")

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Sequence[str]:
        """
        A list of External URLs that can be redirected to as part of logging in or logging out of the Windows Function App.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> str:
        """
        The default authentication provider to use when multiple providers are configured.
        """
        return pulumi.get(self, "default_provider")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is the Backup Job enabled?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def facebooks(self) -> Sequence['outputs.GetWindowsFunctionAppAuthSettingFacebookResult']:
        """
        A `facebook` block as defined below.
        """
        return pulumi.get(self, "facebooks")

    @property
    @pulumi.getter
    def githubs(self) -> Sequence['outputs.GetWindowsFunctionAppAuthSettingGithubResult']:
        """
        A `github` block as defined below.
        """
        return pulumi.get(self, "githubs")

    @property
    @pulumi.getter
    def googles(self) -> Sequence['outputs.GetWindowsFunctionAppAuthSettingGoogleResult']:
        """
        A `google` block as defined below.
        """
        return pulumi.get(self, "googles")

    @property
    @pulumi.getter
    def issuer(self) -> str:
        """
        The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Windows Function App.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def microsofts(self) -> Sequence['outputs.GetWindowsFunctionAppAuthSettingMicrosoftResult']:
        """
        A `microsoft` block as defined below.
        """
        return pulumi.get(self, "microsofts")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> str:
        """
        The Runtime Version of the Authentication / Authorization feature in use for the Windows Function App.
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> float:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API.
        """
        return pulumi.get(self, "token_refresh_extension_hours")

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> bool:
        """
        Is the durable storing of platform-specific security token that are obtained during login flows enabled?
        """
        return pulumi.get(self, "token_store_enabled")

    @property
    @pulumi.getter
    def twitters(self) -> Sequence['outputs.GetWindowsFunctionAppAuthSettingTwitterResult']:
        """
        A `twitter` block as defined below.
        """
        return pulumi.get(self, "twitters")

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> str:
        """
        The action to take when an unauthenticated client attempts to access the app.
        """
        return pulumi.get(self, "unauthenticated_client_action")


@pulumi.output_type
class GetWindowsFunctionAppAuthSettingActiveDirectoryResult(dict):
    def __init__(__self__, *,
                 allowed_audiences: Sequence[str],
                 client_id: str,
                 client_secret: str,
                 client_secret_setting_name: str):
        """
        :param Sequence[str] allowed_audiences: A list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret: The OAuth 2.0 client secret that was created for the app used for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        """
        pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Sequence[str]:
        """
        A list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")


@pulumi.output_type
class GetWindowsFunctionAppAuthSettingFacebookResult(dict):
    def __init__(__self__, *,
                 app_id: str,
                 app_secret: str,
                 app_secret_setting_name: str,
                 oauth_scopes: Sequence[str]):
        """
        :param str app_id: The App ID of the Facebook app used for login.
        :param str app_secret: The App Secret of the Facebook app used for Facebook Login.
        :param str app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook Login.
        :param Sequence[str] oauth_scopes: A list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "app_secret", app_secret)
        pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appSecret")
    def app_secret(self) -> str:
        """
        The App Secret of the Facebook app used for Facebook Login.
        """
        return pulumi.get(self, "app_secret")

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> str:
        """
        The app setting name that contains the `app_secret` value used for Facebook Login.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Sequence[str]:
        """
        A list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class GetWindowsFunctionAppAuthSettingGithubResult(dict):
    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 client_secret_setting_name: str,
                 oauth_scopes: Sequence[str]):
        """
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret: The OAuth 2.0 client secret that was created for the app used for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        :param Sequence[str] oauth_scopes: A list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Sequence[str]:
        """
        A list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class GetWindowsFunctionAppAuthSettingGoogleResult(dict):
    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 client_secret_setting_name: str,
                 oauth_scopes: Sequence[str]):
        """
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret: The OAuth 2.0 client secret that was created for the app used for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        :param Sequence[str] oauth_scopes: A list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Sequence[str]:
        """
        A list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class GetWindowsFunctionAppAuthSettingMicrosoftResult(dict):
    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 client_secret_setting_name: str,
                 oauth_scopes: Sequence[str]):
        """
        :param str client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param str client_secret: The OAuth 2.0 client secret that was created for the app used for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        :param Sequence[str] oauth_scopes: A list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Sequence[str]:
        """
        A list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class GetWindowsFunctionAppAuthSettingTwitterResult(dict):
    def __init__(__self__, *,
                 consumer_key: str,
                 consumer_secret: str,
                 consumer_secret_setting_name: str):
        """
        :param str consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param str consumer_secret: The OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        :param str consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        pulumi.set(__self__, "consumer_secret", consumer_secret)
        pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> str:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> str:
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_secret")

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> str:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_secret_setting_name")


@pulumi.output_type
class GetWindowsFunctionAppBackupResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 name: str,
                 schedules: Sequence['outputs.GetWindowsFunctionAppBackupScheduleResult'],
                 storage_account_url: str):
        """
        :param bool enabled: Is the Backup Job enabled?
        :param str name: The name of this Windows Function App.
        :param Sequence['GetWindowsFunctionAppBackupScheduleArgs'] schedules: A `schedule` block as defined below.
        :param str storage_account_url: The SAS URL to the container.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schedules", schedules)
        pulumi.set(__self__, "storage_account_url", storage_account_url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is the Backup Job enabled?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this Windows Function App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def schedules(self) -> Sequence['outputs.GetWindowsFunctionAppBackupScheduleResult']:
        """
        A `schedule` block as defined below.
        """
        return pulumi.get(self, "schedules")

    @property
    @pulumi.getter(name="storageAccountUrl")
    def storage_account_url(self) -> str:
        """
        The SAS URL to the container.
        """
        return pulumi.get(self, "storage_account_url")


@pulumi.output_type
class GetWindowsFunctionAppBackupScheduleResult(dict):
    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_unit: str,
                 keep_at_least_one_backup: bool,
                 last_execution_time: str,
                 retention_period_days: int,
                 start_time: str):
        """
        :param int frequency_interval: How often the backup is executed.
        :param str frequency_unit: The unit of time the backup should take place.
        :param bool keep_at_least_one_backup: Should the service keep at least one backup.
        :param int retention_period_days: After how many days backups is deleted.
        :param str start_time: When the schedule should start working in RFC-3339 format.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_unit", frequency_unit)
        pulumi.set(__self__, "keep_at_least_one_backup", keep_at_least_one_backup)
        pulumi.set(__self__, "last_execution_time", last_execution_time)
        pulumi.set(__self__, "retention_period_days", retention_period_days)
        pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        How often the backup is executed.
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyUnit")
    def frequency_unit(self) -> str:
        """
        The unit of time the backup should take place.
        """
        return pulumi.get(self, "frequency_unit")

    @property
    @pulumi.getter(name="keepAtLeastOneBackup")
    def keep_at_least_one_backup(self) -> bool:
        """
        Should the service keep at least one backup.
        """
        return pulumi.get(self, "keep_at_least_one_backup")

    @property
    @pulumi.getter(name="lastExecutionTime")
    def last_execution_time(self) -> str:
        return pulumi.get(self, "last_execution_time")

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> int:
        """
        After how many days backups is deleted.
        """
        return pulumi.get(self, "retention_period_days")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        """
        When the schedule should start working in RFC-3339 format.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class GetWindowsFunctionAppConnectionStringResult(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: The name of this Windows Function App.
        :param str type: The type of Managed Service Identity that is configured on this Windows Function App.
        :param str value: The connection string value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this Windows Function App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of Managed Service Identity that is configured on this Windows Function App.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The connection string value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetWindowsFunctionAppIdentityResult(dict):
    def __init__(__self__, *,
                 identity_ids: Sequence[str],
                 principal_id: str,
                 tenant_id: str,
                 type: str):
        """
        :param Sequence[str] identity_ids: The list of User Assigned Managed Identity IDs assigned to this Windows Function App.
        :param str principal_id: The Principal ID of the System Assigned Managed Service Identity that is configured on this Windows Function App.
        :param str tenant_id: The Tenant ID of the System Assigned Managed Service Identity that is configured on this Windows Function App.
        :param str type: The type of Managed Service Identity that is configured on this Windows Function App.
        """
        pulumi.set(__self__, "identity_ids", identity_ids)
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Sequence[str]:
        """
        The list of User Assigned Managed Identity IDs assigned to this Windows Function App.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The Principal ID of the System Assigned Managed Service Identity that is configured on this Windows Function App.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The Tenant ID of the System Assigned Managed Service Identity that is configured on this Windows Function App.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of Managed Service Identity that is configured on this Windows Function App.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetWindowsFunctionAppSiteConfigResult(dict):
    def __init__(__self__, *,
                 always_on: bool,
                 api_definition_url: str,
                 api_management_api_id: str,
                 app_command_line: str,
                 app_scale_limit: int,
                 app_service_logs: Sequence['outputs.GetWindowsFunctionAppSiteConfigAppServiceLogResult'],
                 application_insights_connection_string: str,
                 application_insights_key: str,
                 application_stacks: Sequence['outputs.GetWindowsFunctionAppSiteConfigApplicationStackResult'],
                 cors: Sequence['outputs.GetWindowsFunctionAppSiteConfigCorResult'],
                 default_documents: Sequence[str],
                 detailed_error_logging_enabled: bool,
                 elastic_instance_minimum: int,
                 ftps_state: str,
                 health_check_eviction_time_in_min: int,
                 health_check_path: str,
                 http2_enabled: bool,
                 ip_restrictions: Sequence['outputs.GetWindowsFunctionAppSiteConfigIpRestrictionResult'],
                 load_balancing_mode: str,
                 managed_pipeline_mode: str,
                 minimum_tls_version: str,
                 pre_warmed_instance_count: int,
                 remote_debugging_enabled: bool,
                 remote_debugging_version: str,
                 runtime_scale_monitoring_enabled: bool,
                 scm_ip_restrictions: Sequence['outputs.GetWindowsFunctionAppSiteConfigScmIpRestrictionResult'],
                 scm_minimum_tls_version: str,
                 scm_type: str,
                 scm_use_main_ip_restriction: bool,
                 use32_bit_worker: bool,
                 vnet_route_all_enabled: bool,
                 websockets_enabled: bool,
                 windows_fx_version: str,
                 worker_count: int):
        """
        :param bool always_on: Is this Windows Function App Always On?.
        :param str api_definition_url: The URL of the API definition that describes this Windows Function App.
        :param str api_management_api_id: The ID of the API Management API for this Windows Function App.
        :param str app_command_line: The App command line to launch.
        :param int app_scale_limit: The number of workers this function app can scale out to.
        :param Sequence['GetWindowsFunctionAppSiteConfigAppServiceLogArgs'] app_service_logs: A `app_service_logs` block as defined above.
        :param str application_insights_connection_string: The Connection String for linking the Windows Function App to Application Insights.
        :param str application_insights_key: The Instrumentation Key for connecting the Windows Function App to Application Insights.
        :param Sequence['GetWindowsFunctionAppSiteConfigApplicationStackArgs'] application_stacks: A `application_stack` block as defined above.
        :param Sequence['GetWindowsFunctionAppSiteConfigCorArgs'] cors: A `cors` block as defined above.
        :param Sequence[str] default_documents: A list of Default Documents for the Windows Web App.
        :param bool detailed_error_logging_enabled: Is detailed error logging enabled?
        :param int elastic_instance_minimum: The number of minimum instances for this Windows Function App.
        :param str ftps_state: State of FTP / FTPS service for this Windows Function App.
        :param int health_check_eviction_time_in_min: The amount of time in minutes that a node can be unhealthy before being removed from the load balancer.
        :param str health_check_path: The path to be checked for this Windows Function App health.
        :param bool http2_enabled: Is the HTTP2 protocol enabled?
        :param Sequence['GetWindowsFunctionAppSiteConfigIpRestrictionArgs'] ip_restrictions: One or more `ip_restriction` blocks as defined above.
        :param str load_balancing_mode: The Site load balancing mode.
        :param str managed_pipeline_mode: The Managed pipeline mode.
        :param str minimum_tls_version: The minimum version of TLS required for SSL requests.
        :param int pre_warmed_instance_count: The number of pre-warmed instances for this Windows Function App.
        :param bool remote_debugging_enabled: Is Remote Debugging enabled?
        :param str remote_debugging_version: The Remote Debugging Version.
        :param bool runtime_scale_monitoring_enabled: Is Scale Monitoring of the Functions Runtime enabled?
        :param Sequence['GetWindowsFunctionAppSiteConfigScmIpRestrictionArgs'] scm_ip_restrictions: One or more `scm_ip_restriction` blocks as defined above.
        :param str scm_minimum_tls_version: The minimum version of TLS required for SSL requests to the SCM site.
        :param str scm_type: The SCM type.
        :param bool scm_use_main_ip_restriction: Is the `ip_restriction` configuration used for the SCM?.
        :param bool use32_bit_worker: Is the Windows Function App using a 32-bit worker process?
        :param bool vnet_route_all_enabled: Are all outbound traffic to NAT Gateways, Network Security Groups and User Defined Routes applied?
        :param bool websockets_enabled: Are Web Sockets enabled?
        :param str windows_fx_version: The Windows FX version.
        :param int worker_count: The number of Workers for this Windows Function App.
        """
        pulumi.set(__self__, "always_on", always_on)
        pulumi.set(__self__, "api_definition_url", api_definition_url)
        pulumi.set(__self__, "api_management_api_id", api_management_api_id)
        pulumi.set(__self__, "app_command_line", app_command_line)
        pulumi.set(__self__, "app_scale_limit", app_scale_limit)
        pulumi.set(__self__, "app_service_logs", app_service_logs)
        pulumi.set(__self__, "application_insights_connection_string", application_insights_connection_string)
        pulumi.set(__self__, "application_insights_key", application_insights_key)
        pulumi.set(__self__, "application_stacks", application_stacks)
        pulumi.set(__self__, "cors", cors)
        pulumi.set(__self__, "default_documents", default_documents)
        pulumi.set(__self__, "detailed_error_logging_enabled", detailed_error_logging_enabled)
        pulumi.set(__self__, "elastic_instance_minimum", elastic_instance_minimum)
        pulumi.set(__self__, "ftps_state", ftps_state)
        pulumi.set(__self__, "health_check_eviction_time_in_min", health_check_eviction_time_in_min)
        pulumi.set(__self__, "health_check_path", health_check_path)
        pulumi.set(__self__, "http2_enabled", http2_enabled)
        pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        pulumi.set(__self__, "load_balancing_mode", load_balancing_mode)
        pulumi.set(__self__, "managed_pipeline_mode", managed_pipeline_mode)
        pulumi.set(__self__, "minimum_tls_version", minimum_tls_version)
        pulumi.set(__self__, "pre_warmed_instance_count", pre_warmed_instance_count)
        pulumi.set(__self__, "remote_debugging_enabled", remote_debugging_enabled)
        pulumi.set(__self__, "remote_debugging_version", remote_debugging_version)
        pulumi.set(__self__, "runtime_scale_monitoring_enabled", runtime_scale_monitoring_enabled)
        pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        pulumi.set(__self__, "scm_minimum_tls_version", scm_minimum_tls_version)
        pulumi.set(__self__, "scm_type", scm_type)
        pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        pulumi.set(__self__, "use32_bit_worker", use32_bit_worker)
        pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        pulumi.set(__self__, "websockets_enabled", websockets_enabled)
        pulumi.set(__self__, "windows_fx_version", windows_fx_version)
        pulumi.set(__self__, "worker_count", worker_count)

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> bool:
        """
        Is this Windows Function App Always On?.
        """
        return pulumi.get(self, "always_on")

    @property
    @pulumi.getter(name="apiDefinitionUrl")
    def api_definition_url(self) -> str:
        """
        The URL of the API definition that describes this Windows Function App.
        """
        return pulumi.get(self, "api_definition_url")

    @property
    @pulumi.getter(name="apiManagementApiId")
    def api_management_api_id(self) -> str:
        """
        The ID of the API Management API for this Windows Function App.
        """
        return pulumi.get(self, "api_management_api_id")

    @property
    @pulumi.getter(name="appCommandLine")
    def app_command_line(self) -> str:
        """
        The App command line to launch.
        """
        return pulumi.get(self, "app_command_line")

    @property
    @pulumi.getter(name="appScaleLimit")
    def app_scale_limit(self) -> int:
        """
        The number of workers this function app can scale out to.
        """
        return pulumi.get(self, "app_scale_limit")

    @property
    @pulumi.getter(name="appServiceLogs")
    def app_service_logs(self) -> Sequence['outputs.GetWindowsFunctionAppSiteConfigAppServiceLogResult']:
        """
        A `app_service_logs` block as defined above.
        """
        return pulumi.get(self, "app_service_logs")

    @property
    @pulumi.getter(name="applicationInsightsConnectionString")
    def application_insights_connection_string(self) -> str:
        """
        The Connection String for linking the Windows Function App to Application Insights.
        """
        return pulumi.get(self, "application_insights_connection_string")

    @property
    @pulumi.getter(name="applicationInsightsKey")
    def application_insights_key(self) -> str:
        """
        The Instrumentation Key for connecting the Windows Function App to Application Insights.
        """
        return pulumi.get(self, "application_insights_key")

    @property
    @pulumi.getter(name="applicationStacks")
    def application_stacks(self) -> Sequence['outputs.GetWindowsFunctionAppSiteConfigApplicationStackResult']:
        """
        A `application_stack` block as defined above.
        """
        return pulumi.get(self, "application_stacks")

    @property
    @pulumi.getter
    def cors(self) -> Sequence['outputs.GetWindowsFunctionAppSiteConfigCorResult']:
        """
        A `cors` block as defined above.
        """
        return pulumi.get(self, "cors")

    @property
    @pulumi.getter(name="defaultDocuments")
    def default_documents(self) -> Sequence[str]:
        """
        A list of Default Documents for the Windows Web App.
        """
        return pulumi.get(self, "default_documents")

    @property
    @pulumi.getter(name="detailedErrorLoggingEnabled")
    def detailed_error_logging_enabled(self) -> bool:
        """
        Is detailed error logging enabled?
        """
        return pulumi.get(self, "detailed_error_logging_enabled")

    @property
    @pulumi.getter(name="elasticInstanceMinimum")
    def elastic_instance_minimum(self) -> int:
        """
        The number of minimum instances for this Windows Function App.
        """
        return pulumi.get(self, "elastic_instance_minimum")

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> str:
        """
        State of FTP / FTPS service for this Windows Function App.
        """
        return pulumi.get(self, "ftps_state")

    @property
    @pulumi.getter(name="healthCheckEvictionTimeInMin")
    def health_check_eviction_time_in_min(self) -> int:
        """
        The amount of time in minutes that a node can be unhealthy before being removed from the load balancer.
        """
        return pulumi.get(self, "health_check_eviction_time_in_min")

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> str:
        """
        The path to be checked for this Windows Function App health.
        """
        return pulumi.get(self, "health_check_path")

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> bool:
        """
        Is the HTTP2 protocol enabled?
        """
        return pulumi.get(self, "http2_enabled")

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Sequence['outputs.GetWindowsFunctionAppSiteConfigIpRestrictionResult']:
        """
        One or more `ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "ip_restrictions")

    @property
    @pulumi.getter(name="loadBalancingMode")
    def load_balancing_mode(self) -> str:
        """
        The Site load balancing mode.
        """
        return pulumi.get(self, "load_balancing_mode")

    @property
    @pulumi.getter(name="managedPipelineMode")
    def managed_pipeline_mode(self) -> str:
        """
        The Managed pipeline mode.
        """
        return pulumi.get(self, "managed_pipeline_mode")

    @property
    @pulumi.getter(name="minimumTlsVersion")
    def minimum_tls_version(self) -> str:
        """
        The minimum version of TLS required for SSL requests.
        """
        return pulumi.get(self, "minimum_tls_version")

    @property
    @pulumi.getter(name="preWarmedInstanceCount")
    def pre_warmed_instance_count(self) -> int:
        """
        The number of pre-warmed instances for this Windows Function App.
        """
        return pulumi.get(self, "pre_warmed_instance_count")

    @property
    @pulumi.getter(name="remoteDebuggingEnabled")
    def remote_debugging_enabled(self) -> bool:
        """
        Is Remote Debugging enabled?
        """
        return pulumi.get(self, "remote_debugging_enabled")

    @property
    @pulumi.getter(name="remoteDebuggingVersion")
    def remote_debugging_version(self) -> str:
        """
        The Remote Debugging Version.
        """
        return pulumi.get(self, "remote_debugging_version")

    @property
    @pulumi.getter(name="runtimeScaleMonitoringEnabled")
    def runtime_scale_monitoring_enabled(self) -> bool:
        """
        Is Scale Monitoring of the Functions Runtime enabled?
        """
        return pulumi.get(self, "runtime_scale_monitoring_enabled")

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Sequence['outputs.GetWindowsFunctionAppSiteConfigScmIpRestrictionResult']:
        """
        One or more `scm_ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "scm_ip_restrictions")

    @property
    @pulumi.getter(name="scmMinimumTlsVersion")
    def scm_minimum_tls_version(self) -> str:
        """
        The minimum version of TLS required for SSL requests to the SCM site.
        """
        return pulumi.get(self, "scm_minimum_tls_version")

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> str:
        """
        The SCM type.
        """
        return pulumi.get(self, "scm_type")

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> bool:
        """
        Is the `ip_restriction` configuration used for the SCM?.
        """
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @property
    @pulumi.getter(name="use32BitWorker")
    def use32_bit_worker(self) -> bool:
        """
        Is the Windows Function App using a 32-bit worker process?
        """
        return pulumi.get(self, "use32_bit_worker")

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> bool:
        """
        Are all outbound traffic to NAT Gateways, Network Security Groups and User Defined Routes applied?
        """
        return pulumi.get(self, "vnet_route_all_enabled")

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> bool:
        """
        Are Web Sockets enabled?
        """
        return pulumi.get(self, "websockets_enabled")

    @property
    @pulumi.getter(name="windowsFxVersion")
    def windows_fx_version(self) -> str:
        """
        The Windows FX version.
        """
        return pulumi.get(self, "windows_fx_version")

    @property
    @pulumi.getter(name="workerCount")
    def worker_count(self) -> int:
        """
        The number of Workers for this Windows Function App.
        """
        return pulumi.get(self, "worker_count")


@pulumi.output_type
class GetWindowsFunctionAppSiteConfigAppServiceLogResult(dict):
    def __init__(__self__, *,
                 disk_quota_mb: int,
                 retention_period_days: int):
        """
        :param int disk_quota_mb: The amount of disk space to use for logs.
        :param int retention_period_days: After how many days backups is deleted.
        """
        pulumi.set(__self__, "disk_quota_mb", disk_quota_mb)
        pulumi.set(__self__, "retention_period_days", retention_period_days)

    @property
    @pulumi.getter(name="diskQuotaMb")
    def disk_quota_mb(self) -> int:
        """
        The amount of disk space to use for logs.
        """
        return pulumi.get(self, "disk_quota_mb")

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> int:
        """
        After how many days backups is deleted.
        """
        return pulumi.get(self, "retention_period_days")


@pulumi.output_type
class GetWindowsFunctionAppSiteConfigApplicationStackResult(dict):
    def __init__(__self__, *,
                 dotnet_version: str,
                 java_version: str,
                 node_version: str,
                 powershell_core_version: str,
                 use_custom_runtime: bool,
                 use_dotnet_isolated_runtime: bool):
        """
        :param str dotnet_version: The version of .Net to use.
        :param str java_version: The version of Java to use.
        :param str node_version: The version of Node to use.
        :param str powershell_core_version: The version of PowerShell Core to use.
        :param bool use_custom_runtime: Is the Windows Function App using a custom runtime?.
        """
        pulumi.set(__self__, "dotnet_version", dotnet_version)
        pulumi.set(__self__, "java_version", java_version)
        pulumi.set(__self__, "node_version", node_version)
        pulumi.set(__self__, "powershell_core_version", powershell_core_version)
        pulumi.set(__self__, "use_custom_runtime", use_custom_runtime)
        pulumi.set(__self__, "use_dotnet_isolated_runtime", use_dotnet_isolated_runtime)

    @property
    @pulumi.getter(name="dotnetVersion")
    def dotnet_version(self) -> str:
        """
        The version of .Net to use.
        """
        return pulumi.get(self, "dotnet_version")

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> str:
        """
        The version of Java to use.
        """
        return pulumi.get(self, "java_version")

    @property
    @pulumi.getter(name="nodeVersion")
    def node_version(self) -> str:
        """
        The version of Node to use.
        """
        return pulumi.get(self, "node_version")

    @property
    @pulumi.getter(name="powershellCoreVersion")
    def powershell_core_version(self) -> str:
        """
        The version of PowerShell Core to use.
        """
        return pulumi.get(self, "powershell_core_version")

    @property
    @pulumi.getter(name="useCustomRuntime")
    def use_custom_runtime(self) -> bool:
        """
        Is the Windows Function App using a custom runtime?.
        """
        return pulumi.get(self, "use_custom_runtime")

    @property
    @pulumi.getter(name="useDotnetIsolatedRuntime")
    def use_dotnet_isolated_runtime(self) -> bool:
        return pulumi.get(self, "use_dotnet_isolated_runtime")


@pulumi.output_type
class GetWindowsFunctionAppSiteConfigCorResult(dict):
    def __init__(__self__, *,
                 allowed_origins: Sequence[str],
                 support_credentials: bool):
        """
        :param Sequence[str] allowed_origins: A list of origins that should be allowed to make cross-origin calls.
        :param bool support_credentials: Are credentials allows in CORS requests?.
        """
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Sequence[str]:
        """
        A list of origins that should be allowed to make cross-origin calls.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> bool:
        """
        Are credentials allows in CORS requests?.
        """
        return pulumi.get(self, "support_credentials")


@pulumi.output_type
class GetWindowsFunctionAppSiteConfigIpRestrictionResult(dict):
    def __init__(__self__, *,
                 action: str,
                 headers: Sequence['outputs.GetWindowsFunctionAppSiteConfigIpRestrictionHeaderResult'],
                 ip_address: str,
                 name: str,
                 priority: int,
                 service_tag: str,
                 virtual_network_subnet_id: str):
        """
        :param str name: The name of this Windows Function App.
        :param str virtual_network_subnet_id: The subnet id which the Windows Function App is vNet Integrated with.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "service_tag", service_tag)
        pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> str:
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.GetWindowsFunctionAppSiteConfigIpRestrictionHeaderResult']:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this Windows Function App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> str:
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> str:
        """
        The subnet id which the Windows Function App is vNet Integrated with.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class GetWindowsFunctionAppSiteConfigIpRestrictionHeaderResult(dict):
    def __init__(__self__, *,
                 x_azure_fdids: Sequence[str],
                 x_fd_health_probes: Sequence[str],
                 x_forwarded_fors: Sequence[str],
                 x_forwarded_hosts: Sequence[str]):
        pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        pulumi.set(__self__, "x_fd_health_probes", x_fd_health_probes)
        pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Sequence[str]:
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbes")
    def x_fd_health_probes(self) -> Sequence[str]:
        return pulumi.get(self, "x_fd_health_probes")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Sequence[str]:
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Sequence[str]:
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class GetWindowsFunctionAppSiteConfigScmIpRestrictionResult(dict):
    def __init__(__self__, *,
                 action: str,
                 headers: Sequence['outputs.GetWindowsFunctionAppSiteConfigScmIpRestrictionHeaderResult'],
                 ip_address: str,
                 name: str,
                 priority: int,
                 service_tag: str,
                 virtual_network_subnet_id: str):
        """
        :param str name: The name of this Windows Function App.
        :param str virtual_network_subnet_id: The subnet id which the Windows Function App is vNet Integrated with.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "service_tag", service_tag)
        pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> str:
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.GetWindowsFunctionAppSiteConfigScmIpRestrictionHeaderResult']:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this Windows Function App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> str:
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> str:
        """
        The subnet id which the Windows Function App is vNet Integrated with.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class GetWindowsFunctionAppSiteConfigScmIpRestrictionHeaderResult(dict):
    def __init__(__self__, *,
                 x_azure_fdids: Sequence[str],
                 x_fd_health_probes: Sequence[str],
                 x_forwarded_fors: Sequence[str],
                 x_forwarded_hosts: Sequence[str]):
        pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        pulumi.set(__self__, "x_fd_health_probes", x_fd_health_probes)
        pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Sequence[str]:
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbes")
    def x_fd_health_probes(self) -> Sequence[str]:
        return pulumi.get(self, "x_fd_health_probes")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Sequence[str]:
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Sequence[str]:
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class GetWindowsFunctionAppSiteCredentialResult(dict):
    def __init__(__self__, *,
                 name: str,
                 password: str):
        """
        :param str name: The name of this Windows Function App.
        :param str password: The Site Credentials Password used for publishing.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this Windows Function App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The Site Credentials Password used for publishing.
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class GetWindowsFunctionAppStickySettingResult(dict):
    def __init__(__self__, *,
                 app_setting_names: Sequence[str],
                 connection_string_names: Sequence[str]):
        """
        :param Sequence[str] app_setting_names: A list of `app_setting` names that the Windows Function App will not swap between Slots when a swap operation is triggered.
        :param Sequence[str] connection_string_names: A list of `connection_string` names that the Windows Function App will not swap between Slots when a swap operation is triggered.
        """
        pulumi.set(__self__, "app_setting_names", app_setting_names)
        pulumi.set(__self__, "connection_string_names", connection_string_names)

    @property
    @pulumi.getter(name="appSettingNames")
    def app_setting_names(self) -> Sequence[str]:
        """
        A list of `app_setting` names that the Windows Function App will not swap between Slots when a swap operation is triggered.
        """
        return pulumi.get(self, "app_setting_names")

    @property
    @pulumi.getter(name="connectionStringNames")
    def connection_string_names(self) -> Sequence[str]:
        """
        A list of `connection_string` names that the Windows Function App will not swap between Slots when a swap operation is triggered.
        """
        return pulumi.get(self, "connection_string_names")


@pulumi.output_type
class GetWindowsWebAppAuthSettingResult(dict):
    def __init__(__self__, *,
                 active_directories: Sequence['outputs.GetWindowsWebAppAuthSettingActiveDirectoryResult'],
                 additional_login_parameters: Mapping[str, str],
                 allowed_external_redirect_urls: Sequence[str],
                 default_provider: str,
                 enabled: bool,
                 facebooks: Sequence['outputs.GetWindowsWebAppAuthSettingFacebookResult'],
                 githubs: Sequence['outputs.GetWindowsWebAppAuthSettingGithubResult'],
                 googles: Sequence['outputs.GetWindowsWebAppAuthSettingGoogleResult'],
                 issuer: str,
                 microsofts: Sequence['outputs.GetWindowsWebAppAuthSettingMicrosoftResult'],
                 runtime_version: str,
                 token_refresh_extension_hours: float,
                 token_store_enabled: bool,
                 twitters: Sequence['outputs.GetWindowsWebAppAuthSettingTwitterResult'],
                 unauthenticated_client_action: str):
        """
        :param Sequence['GetWindowsWebAppAuthSettingActiveDirectoryArgs'] active_directories: A `active_directory` block as defined above.
        :param Mapping[str, str] additional_login_parameters: A `additional_login_parameters` block as defined above.
        :param Sequence[str] allowed_external_redirect_urls: A `allowed_external_redirect_urls` block as defined above.
        :param str default_provider: The default authentication provider in use when multiple providers are configured.
        :param bool enabled: Is the Backup enabled?
        :param Sequence['GetWindowsWebAppAuthSettingFacebookArgs'] facebooks: A `facebook` block as defined below.
        :param Sequence['GetWindowsWebAppAuthSettingGithubArgs'] githubs: A `github` block as defined below.
        :param Sequence['GetWindowsWebAppAuthSettingGoogleArgs'] googles: A `google` block as defined below.
        :param str issuer: The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Windows Web App.
        :param Sequence['GetWindowsWebAppAuthSettingMicrosoftArgs'] microsofts: A `microsoft` block as defined below.
        :param str runtime_version: The RuntimeVersion of the Authentication / Authorization feature in use for the Windows Web App.
        :param float token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to call the token refresh API.
        :param bool token_store_enabled: Does Windows Web App durably store platform-specific security tokens that are obtained during login flows enabled?
        :param Sequence['GetWindowsWebAppAuthSettingTwitterArgs'] twitters: A `twitter` block as defined below.
        :param str unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app.
        """
        pulumi.set(__self__, "active_directories", active_directories)
        pulumi.set(__self__, "additional_login_parameters", additional_login_parameters)
        pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        pulumi.set(__self__, "default_provider", default_provider)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "facebooks", facebooks)
        pulumi.set(__self__, "githubs", githubs)
        pulumi.set(__self__, "googles", googles)
        pulumi.set(__self__, "issuer", issuer)
        pulumi.set(__self__, "microsofts", microsofts)
        pulumi.set(__self__, "runtime_version", runtime_version)
        pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)
        pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        pulumi.set(__self__, "twitters", twitters)
        pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter(name="activeDirectories")
    def active_directories(self) -> Sequence['outputs.GetWindowsWebAppAuthSettingActiveDirectoryResult']:
        """
        A `active_directory` block as defined above.
        """
        return pulumi.get(self, "active_directories")

    @property
    @pulumi.getter(name="additionalLoginParameters")
    def additional_login_parameters(self) -> Mapping[str, str]:
        """
        A `additional_login_parameters` block as defined above.
        """
        return pulumi.get(self, "additional_login_parameters")

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Sequence[str]:
        """
        A `allowed_external_redirect_urls` block as defined above.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> str:
        """
        The default authentication provider in use when multiple providers are configured.
        """
        return pulumi.get(self, "default_provider")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is the Backup enabled?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def facebooks(self) -> Sequence['outputs.GetWindowsWebAppAuthSettingFacebookResult']:
        """
        A `facebook` block as defined below.
        """
        return pulumi.get(self, "facebooks")

    @property
    @pulumi.getter
    def githubs(self) -> Sequence['outputs.GetWindowsWebAppAuthSettingGithubResult']:
        """
        A `github` block as defined below.
        """
        return pulumi.get(self, "githubs")

    @property
    @pulumi.getter
    def googles(self) -> Sequence['outputs.GetWindowsWebAppAuthSettingGoogleResult']:
        """
        A `google` block as defined below.
        """
        return pulumi.get(self, "googles")

    @property
    @pulumi.getter
    def issuer(self) -> str:
        """
        The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Windows Web App.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def microsofts(self) -> Sequence['outputs.GetWindowsWebAppAuthSettingMicrosoftResult']:
        """
        A `microsoft` block as defined below.
        """
        return pulumi.get(self, "microsofts")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> str:
        """
        The RuntimeVersion of the Authentication / Authorization feature in use for the Windows Web App.
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> float:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API.
        """
        return pulumi.get(self, "token_refresh_extension_hours")

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> bool:
        """
        Does Windows Web App durably store platform-specific security tokens that are obtained during login flows enabled?
        """
        return pulumi.get(self, "token_store_enabled")

    @property
    @pulumi.getter
    def twitters(self) -> Sequence['outputs.GetWindowsWebAppAuthSettingTwitterResult']:
        """
        A `twitter` block as defined below.
        """
        return pulumi.get(self, "twitters")

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> str:
        """
        The action to take when an unauthenticated client attempts to access the app.
        """
        return pulumi.get(self, "unauthenticated_client_action")


@pulumi.output_type
class GetWindowsWebAppAuthSettingActiveDirectoryResult(dict):
    def __init__(__self__, *,
                 allowed_audiences: Sequence[str],
                 client_id: str,
                 client_secret: str,
                 client_secret_setting_name: str):
        """
        :param Sequence[str] allowed_audiences: An `allowed_audiences` block as defined below.
        :param str client_id: The OAuth 2.0 client ID used by the app for authentication.
        :param str client_secret: The OAuth 2.0 client secret used by the app for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        """
        pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Sequence[str]:
        """
        An `allowed_audiences` block as defined below.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID used by the app for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The OAuth 2.0 client secret used by the app for authentication.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")


@pulumi.output_type
class GetWindowsWebAppAuthSettingFacebookResult(dict):
    def __init__(__self__, *,
                 app_id: str,
                 app_secret: str,
                 app_secret_setting_name: str,
                 oauth_scopes: Sequence[str]):
        """
        :param str app_id: The App ID of the Facebook app used for login.
        :param str app_secret: The App Secret of the Facebook app used for Facebook login.
        :param str app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook login.
        :param Sequence[str] oauth_scopes: A list of OAuth 2.0 scopes requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "app_secret", app_secret)
        pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appSecret")
    def app_secret(self) -> str:
        """
        The App Secret of the Facebook app used for Facebook login.
        """
        return pulumi.get(self, "app_secret")

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> str:
        """
        The app setting name that contains the `app_secret` value used for Facebook login.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Sequence[str]:
        """
        A list of OAuth 2.0 scopes requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class GetWindowsWebAppAuthSettingGithubResult(dict):
    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 client_secret_setting_name: str,
                 oauth_scopes: Sequence[str]):
        """
        :param str client_id: The OAuth 2.0 client ID used by the app for authentication.
        :param str client_secret: The OAuth 2.0 client secret used by the app for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        :param Sequence[str] oauth_scopes: A list of OAuth 2.0 scopes requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID used by the app for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The OAuth 2.0 client secret used by the app for authentication.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Sequence[str]:
        """
        A list of OAuth 2.0 scopes requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class GetWindowsWebAppAuthSettingGoogleResult(dict):
    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 client_secret_setting_name: str,
                 oauth_scopes: Sequence[str]):
        """
        :param str client_id: The OAuth 2.0 client ID used by the app for authentication.
        :param str client_secret: The OAuth 2.0 client secret used by the app for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        :param Sequence[str] oauth_scopes: A list of OAuth 2.0 scopes requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID used by the app for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The OAuth 2.0 client secret used by the app for authentication.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Sequence[str]:
        """
        A list of OAuth 2.0 scopes requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class GetWindowsWebAppAuthSettingMicrosoftResult(dict):
    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 client_secret_setting_name: str,
                 oauth_scopes: Sequence[str]):
        """
        :param str client_id: The OAuth 2.0 client ID used by the app for authentication.
        :param str client_secret: The OAuth 2.0 client secret used by the app for authentication.
        :param str client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        :param Sequence[str] oauth_scopes: A list of OAuth 2.0 scopes requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client ID used by the app for authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The OAuth 2.0 client secret used by the app for authentication.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> str:
        """
        The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Sequence[str]:
        """
        A list of OAuth 2.0 scopes requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "oauth_scopes")


@pulumi.output_type
class GetWindowsWebAppAuthSettingTwitterResult(dict):
    def __init__(__self__, *,
                 consumer_key: str,
                 consumer_secret: str,
                 consumer_secret_setting_name: str):
        """
        :param str consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param str consumer_secret: The OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        :param str consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        pulumi.set(__self__, "consumer_secret", consumer_secret)
        pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> str:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> str:
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_secret")

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> str:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_secret_setting_name")


@pulumi.output_type
class GetWindowsWebAppBackupResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 name: str,
                 schedules: Sequence['outputs.GetWindowsWebAppBackupScheduleResult'],
                 storage_account_url: str):
        """
        :param bool enabled: Is the Backup enabled?
        :param str name: The name of this Windows Web App.
        :param Sequence['GetWindowsWebAppBackupScheduleArgs'] schedules: A `schedule` block as defined below.
        :param str storage_account_url: The SAS URL to the container.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schedules", schedules)
        pulumi.set(__self__, "storage_account_url", storage_account_url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is the Backup enabled?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this Windows Web App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def schedules(self) -> Sequence['outputs.GetWindowsWebAppBackupScheduleResult']:
        """
        A `schedule` block as defined below.
        """
        return pulumi.get(self, "schedules")

    @property
    @pulumi.getter(name="storageAccountUrl")
    def storage_account_url(self) -> str:
        """
        The SAS URL to the container.
        """
        return pulumi.get(self, "storage_account_url")


@pulumi.output_type
class GetWindowsWebAppBackupScheduleResult(dict):
    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_unit: str,
                 keep_at_least_one_backup: bool,
                 last_execution_time: str,
                 retention_period_days: int,
                 start_time: str):
        """
        :param int frequency_interval: How often the backup will be executed.
        :param str frequency_unit: The unit of time for how often the backup should take place.
        :param bool keep_at_least_one_backup: Will the service keep at least one backup, regardless of age of backup.
        :param str last_execution_time: The time of the last backup attempt.
        :param int retention_period_days: After how many days backups should be deleted.
        :param str start_time: When the schedule should start in RFC-3339 format.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_unit", frequency_unit)
        pulumi.set(__self__, "keep_at_least_one_backup", keep_at_least_one_backup)
        pulumi.set(__self__, "last_execution_time", last_execution_time)
        pulumi.set(__self__, "retention_period_days", retention_period_days)
        pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        How often the backup will be executed.
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyUnit")
    def frequency_unit(self) -> str:
        """
        The unit of time for how often the backup should take place.
        """
        return pulumi.get(self, "frequency_unit")

    @property
    @pulumi.getter(name="keepAtLeastOneBackup")
    def keep_at_least_one_backup(self) -> bool:
        """
        Will the service keep at least one backup, regardless of age of backup.
        """
        return pulumi.get(self, "keep_at_least_one_backup")

    @property
    @pulumi.getter(name="lastExecutionTime")
    def last_execution_time(self) -> str:
        """
        The time of the last backup attempt.
        """
        return pulumi.get(self, "last_execution_time")

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> int:
        """
        After how many days backups should be deleted.
        """
        return pulumi.get(self, "retention_period_days")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        """
        When the schedule should start in RFC-3339 format.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class GetWindowsWebAppConnectionStringResult(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: The name of this Windows Web App.
        :param str type: The Azure Storage Type.
        :param str value: The Connection String value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this Windows Web App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The Azure Storage Type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The Connection String value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetWindowsWebAppIdentityResult(dict):
    def __init__(__self__, *,
                 identity_ids: Sequence[str],
                 principal_id: str,
                 tenant_id: str,
                 type: str):
        """
        :param Sequence[str] identity_ids: A `identity_ids` block as defined below.
        :param str principal_id: The Principal ID Managed Service Identity.
        :param str tenant_id: The Tenant ID of the Managed Service Identity.
        :param str type: The Azure Storage Type.
        """
        pulumi.set(__self__, "identity_ids", identity_ids)
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Sequence[str]:
        """
        A `identity_ids` block as defined below.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The Principal ID Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The Tenant ID of the Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The Azure Storage Type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetWindowsWebAppLogResult(dict):
    def __init__(__self__, *,
                 application_logs: Sequence['outputs.GetWindowsWebAppLogApplicationLogResult'],
                 detailed_error_messages: bool,
                 failed_request_tracing: bool,
                 http_logs: Sequence['outputs.GetWindowsWebAppLogHttpLogResult']):
        """
        :param Sequence['GetWindowsWebAppLogApplicationLogArgs'] application_logs: A `application_logs` block as defined above.
        :param bool detailed_error_messages: Is Detailed Error Messaging enabled.
        :param bool failed_request_tracing: Is Failed Request Tracing enabled.
        :param Sequence['GetWindowsWebAppLogHttpLogArgs'] http_logs: An `http_logs` block as defined above.
        """
        pulumi.set(__self__, "application_logs", application_logs)
        pulumi.set(__self__, "detailed_error_messages", detailed_error_messages)
        pulumi.set(__self__, "failed_request_tracing", failed_request_tracing)
        pulumi.set(__self__, "http_logs", http_logs)

    @property
    @pulumi.getter(name="applicationLogs")
    def application_logs(self) -> Sequence['outputs.GetWindowsWebAppLogApplicationLogResult']:
        """
        A `application_logs` block as defined above.
        """
        return pulumi.get(self, "application_logs")

    @property
    @pulumi.getter(name="detailedErrorMessages")
    def detailed_error_messages(self) -> bool:
        """
        Is Detailed Error Messaging enabled.
        """
        return pulumi.get(self, "detailed_error_messages")

    @property
    @pulumi.getter(name="failedRequestTracing")
    def failed_request_tracing(self) -> bool:
        """
        Is Failed Request Tracing enabled.
        """
        return pulumi.get(self, "failed_request_tracing")

    @property
    @pulumi.getter(name="httpLogs")
    def http_logs(self) -> Sequence['outputs.GetWindowsWebAppLogHttpLogResult']:
        """
        An `http_logs` block as defined above.
        """
        return pulumi.get(self, "http_logs")


@pulumi.output_type
class GetWindowsWebAppLogApplicationLogResult(dict):
    def __init__(__self__, *,
                 azure_blob_storages: Sequence['outputs.GetWindowsWebAppLogApplicationLogAzureBlobStorageResult'],
                 file_system_level: str):
        """
        :param Sequence['GetWindowsWebAppLogApplicationLogAzureBlobStorageArgs'] azure_blob_storages: A `azure_blob_storage` block as defined above.
        :param str file_system_level: The logging level.
        """
        pulumi.set(__self__, "azure_blob_storages", azure_blob_storages)
        pulumi.set(__self__, "file_system_level", file_system_level)

    @property
    @pulumi.getter(name="azureBlobStorages")
    def azure_blob_storages(self) -> Sequence['outputs.GetWindowsWebAppLogApplicationLogAzureBlobStorageResult']:
        """
        A `azure_blob_storage` block as defined above.
        """
        return pulumi.get(self, "azure_blob_storages")

    @property
    @pulumi.getter(name="fileSystemLevel")
    def file_system_level(self) -> str:
        """
        The logging level.
        """
        return pulumi.get(self, "file_system_level")


@pulumi.output_type
class GetWindowsWebAppLogApplicationLogAzureBlobStorageResult(dict):
    def __init__(__self__, *,
                 level: str,
                 retention_in_days: int,
                 sas_url: str):
        """
        :param str level: The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        :param int retention_in_days: The retention period in days.
        :param str sas_url: The SAS url to the Azure Blob container.
        """
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "sas_url", sas_url)

    @property
    @pulumi.getter
    def level(self) -> str:
        """
        The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        """
        return pulumi.get(self, "level")

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> int:
        """
        The retention period in days.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> str:
        """
        The SAS url to the Azure Blob container.
        """
        return pulumi.get(self, "sas_url")


@pulumi.output_type
class GetWindowsWebAppLogHttpLogResult(dict):
    def __init__(__self__, *,
                 azure_blob_storages: Sequence['outputs.GetWindowsWebAppLogHttpLogAzureBlobStorageResult'],
                 file_systems: Sequence['outputs.GetWindowsWebAppLogHttpLogFileSystemResult']):
        """
        :param Sequence['GetWindowsWebAppLogHttpLogAzureBlobStorageArgs'] azure_blob_storages: A `azure_blob_storage` block as defined above.
        :param Sequence['GetWindowsWebAppLogHttpLogFileSystemArgs'] file_systems: A `file_system` block as defined above.
        """
        pulumi.set(__self__, "azure_blob_storages", azure_blob_storages)
        pulumi.set(__self__, "file_systems", file_systems)

    @property
    @pulumi.getter(name="azureBlobStorages")
    def azure_blob_storages(self) -> Sequence['outputs.GetWindowsWebAppLogHttpLogAzureBlobStorageResult']:
        """
        A `azure_blob_storage` block as defined above.
        """
        return pulumi.get(self, "azure_blob_storages")

    @property
    @pulumi.getter(name="fileSystems")
    def file_systems(self) -> Sequence['outputs.GetWindowsWebAppLogHttpLogFileSystemResult']:
        """
        A `file_system` block as defined above.
        """
        return pulumi.get(self, "file_systems")


@pulumi.output_type
class GetWindowsWebAppLogHttpLogAzureBlobStorageResult(dict):
    def __init__(__self__, *,
                 retention_in_days: int,
                 sas_url: str):
        """
        :param int retention_in_days: The retention period in days.
        :param str sas_url: The SAS url to the Azure Blob container.
        """
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "sas_url", sas_url)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> int:
        """
        The retention period in days.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> str:
        """
        The SAS url to the Azure Blob container.
        """
        return pulumi.get(self, "sas_url")


@pulumi.output_type
class GetWindowsWebAppLogHttpLogFileSystemResult(dict):
    def __init__(__self__, *,
                 retention_in_days: int,
                 retention_in_mb: int):
        """
        :param int retention_in_days: The retention period in days.
        :param int retention_in_mb: The maximum size in megabytes that log files can use.
        """
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "retention_in_mb", retention_in_mb)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> int:
        """
        The retention period in days.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="retentionInMb")
    def retention_in_mb(self) -> int:
        """
        The maximum size in megabytes that log files can use.
        """
        return pulumi.get(self, "retention_in_mb")


@pulumi.output_type
class GetWindowsWebAppSiteConfigResult(dict):
    def __init__(__self__, *,
                 always_on: bool,
                 api_definition_url: str,
                 api_management_api_id: str,
                 app_command_line: str,
                 application_stacks: Sequence['outputs.GetWindowsWebAppSiteConfigApplicationStackResult'],
                 auto_heal_enabled: bool,
                 auto_heal_settings: Sequence['outputs.GetWindowsWebAppSiteConfigAutoHealSettingResult'],
                 container_registry_managed_identity_client_id: str,
                 container_registry_use_managed_identity: bool,
                 cors: Sequence['outputs.GetWindowsWebAppSiteConfigCorResult'],
                 default_documents: Sequence[str],
                 detailed_error_logging_enabled: bool,
                 ftps_state: str,
                 health_check_eviction_time_in_min: int,
                 health_check_path: str,
                 http2_enabled: bool,
                 ip_restrictions: Sequence['outputs.GetWindowsWebAppSiteConfigIpRestrictionResult'],
                 load_balancing_mode: str,
                 local_mysql_enabled: bool,
                 managed_pipeline_mode: str,
                 minimum_tls_version: str,
                 remote_debugging_enabled: bool,
                 remote_debugging_version: str,
                 scm_ip_restrictions: Sequence['outputs.GetWindowsWebAppSiteConfigScmIpRestrictionResult'],
                 scm_minimum_tls_version: str,
                 scm_type: str,
                 scm_use_main_ip_restriction: bool,
                 use32_bit_worker: bool,
                 virtual_applications: Sequence['outputs.GetWindowsWebAppSiteConfigVirtualApplicationResult'],
                 vnet_route_all_enabled: bool,
                 websockets_enabled: bool,
                 windows_fx_version: str,
                 worker_count: int):
        """
        :param bool always_on: Is this Windows Web App is Always On enabled.
        :param str api_definition_url: The ID of the APIM configuration for this Windows Web App.
        :param str api_management_api_id: The ID of the API Management setting linked to the Windows Web App.
        :param str app_command_line: The command line used to launch this app.
        :param Sequence['GetWindowsWebAppSiteConfigApplicationStackArgs'] application_stacks: A `application_stack` block as defined above.
        :param bool auto_heal_enabled: Are Auto heal rules to be enabled.
        :param Sequence['GetWindowsWebAppSiteConfigAutoHealSettingArgs'] auto_heal_settings: A `auto_heal_setting` block as defined above.
        :param str container_registry_managed_identity_client_id: The Client ID of the Managed Service Identity used for connections to the Azure Container Registry.
        :param bool container_registry_use_managed_identity: Do connections for Azure Container Registry use Managed Identity.
        :param Sequence['GetWindowsWebAppSiteConfigCorArgs'] cors: A `cors` block as defined above.
        :param Sequence[str] default_documents: The list of Default Documents for the Windows Web App.
        :param bool detailed_error_logging_enabled: Is Detailed Error Logging enabled.
        :param str ftps_state: The State of FTP / FTPS service.
        :param int health_check_eviction_time_in_min: (Optional) The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        :param str health_check_path: The path to the Health Check endpoint.
        :param bool http2_enabled: Is HTTP2.0 enabled.
        :param Sequence['GetWindowsWebAppSiteConfigIpRestrictionArgs'] ip_restrictions: A `ip_restriction` block as defined above.
        :param str load_balancing_mode: The site Load Balancing Mode.
        :param bool local_mysql_enabled: Is the Local MySQL enabled.
        :param str managed_pipeline_mode: The Managed Pipeline Mode.
        :param str minimum_tls_version: The Minimum version of TLS for requests.
        :param str remote_debugging_version: The Remote Debugging Version.
        :param Sequence['GetWindowsWebAppSiteConfigScmIpRestrictionArgs'] scm_ip_restrictions: A `scm_ip_restriction` block as defined above.
        :param str scm_minimum_tls_version: The Minimum version of TLS for requests to SCM.
        :param str scm_type: The Source Control Management Type in use.
        :param bool scm_use_main_ip_restriction: Is the Windows Web App `ip_restriction` configuration used for the SCM also.
        :param bool use32_bit_worker: Does the Windows Web App use a 32-bit worker.
        :param Sequence['GetWindowsWebAppSiteConfigVirtualApplicationArgs'] virtual_applications: A `virtual_application` block as defined below.
        :param bool vnet_route_all_enabled: Are all outbound traffic to NAT Gateways, Network Security Groups and User Defined Routes applied?
        :param bool websockets_enabled: Are Web Sockets enabled?
        :param str windows_fx_version: The string representation of the Windows FX Version.
        :param int worker_count: The number of Workers for this Windows App Service.
        """
        pulumi.set(__self__, "always_on", always_on)
        pulumi.set(__self__, "api_definition_url", api_definition_url)
        pulumi.set(__self__, "api_management_api_id", api_management_api_id)
        pulumi.set(__self__, "app_command_line", app_command_line)
        pulumi.set(__self__, "application_stacks", application_stacks)
        pulumi.set(__self__, "auto_heal_enabled", auto_heal_enabled)
        pulumi.set(__self__, "auto_heal_settings", auto_heal_settings)
        pulumi.set(__self__, "container_registry_managed_identity_client_id", container_registry_managed_identity_client_id)
        pulumi.set(__self__, "container_registry_use_managed_identity", container_registry_use_managed_identity)
        pulumi.set(__self__, "cors", cors)
        pulumi.set(__self__, "default_documents", default_documents)
        pulumi.set(__self__, "detailed_error_logging_enabled", detailed_error_logging_enabled)
        pulumi.set(__self__, "ftps_state", ftps_state)
        pulumi.set(__self__, "health_check_eviction_time_in_min", health_check_eviction_time_in_min)
        pulumi.set(__self__, "health_check_path", health_check_path)
        pulumi.set(__self__, "http2_enabled", http2_enabled)
        pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        pulumi.set(__self__, "load_balancing_mode", load_balancing_mode)
        pulumi.set(__self__, "local_mysql_enabled", local_mysql_enabled)
        pulumi.set(__self__, "managed_pipeline_mode", managed_pipeline_mode)
        pulumi.set(__self__, "minimum_tls_version", minimum_tls_version)
        pulumi.set(__self__, "remote_debugging_enabled", remote_debugging_enabled)
        pulumi.set(__self__, "remote_debugging_version", remote_debugging_version)
        pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        pulumi.set(__self__, "scm_minimum_tls_version", scm_minimum_tls_version)
        pulumi.set(__self__, "scm_type", scm_type)
        pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        pulumi.set(__self__, "use32_bit_worker", use32_bit_worker)
        pulumi.set(__self__, "virtual_applications", virtual_applications)
        pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        pulumi.set(__self__, "websockets_enabled", websockets_enabled)
        pulumi.set(__self__, "windows_fx_version", windows_fx_version)
        pulumi.set(__self__, "worker_count", worker_count)

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> bool:
        """
        Is this Windows Web App is Always On enabled.
        """
        return pulumi.get(self, "always_on")

    @property
    @pulumi.getter(name="apiDefinitionUrl")
    def api_definition_url(self) -> str:
        """
        The ID of the APIM configuration for this Windows Web App.
        """
        return pulumi.get(self, "api_definition_url")

    @property
    @pulumi.getter(name="apiManagementApiId")
    def api_management_api_id(self) -> str:
        """
        The ID of the API Management setting linked to the Windows Web App.
        """
        return pulumi.get(self, "api_management_api_id")

    @property
    @pulumi.getter(name="appCommandLine")
    def app_command_line(self) -> str:
        """
        The command line used to launch this app.
        """
        return pulumi.get(self, "app_command_line")

    @property
    @pulumi.getter(name="applicationStacks")
    def application_stacks(self) -> Sequence['outputs.GetWindowsWebAppSiteConfigApplicationStackResult']:
        """
        A `application_stack` block as defined above.
        """
        return pulumi.get(self, "application_stacks")

    @property
    @pulumi.getter(name="autoHealEnabled")
    def auto_heal_enabled(self) -> bool:
        """
        Are Auto heal rules to be enabled.
        """
        return pulumi.get(self, "auto_heal_enabled")

    @property
    @pulumi.getter(name="autoHealSettings")
    def auto_heal_settings(self) -> Sequence['outputs.GetWindowsWebAppSiteConfigAutoHealSettingResult']:
        """
        A `auto_heal_setting` block as defined above.
        """
        return pulumi.get(self, "auto_heal_settings")

    @property
    @pulumi.getter(name="containerRegistryManagedIdentityClientId")
    def container_registry_managed_identity_client_id(self) -> str:
        """
        The Client ID of the Managed Service Identity used for connections to the Azure Container Registry.
        """
        return pulumi.get(self, "container_registry_managed_identity_client_id")

    @property
    @pulumi.getter(name="containerRegistryUseManagedIdentity")
    def container_registry_use_managed_identity(self) -> bool:
        """
        Do connections for Azure Container Registry use Managed Identity.
        """
        return pulumi.get(self, "container_registry_use_managed_identity")

    @property
    @pulumi.getter
    def cors(self) -> Sequence['outputs.GetWindowsWebAppSiteConfigCorResult']:
        """
        A `cors` block as defined above.
        """
        return pulumi.get(self, "cors")

    @property
    @pulumi.getter(name="defaultDocuments")
    def default_documents(self) -> Sequence[str]:
        """
        The list of Default Documents for the Windows Web App.
        """
        return pulumi.get(self, "default_documents")

    @property
    @pulumi.getter(name="detailedErrorLoggingEnabled")
    def detailed_error_logging_enabled(self) -> bool:
        """
        Is Detailed Error Logging enabled.
        """
        return pulumi.get(self, "detailed_error_logging_enabled")

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> str:
        """
        The State of FTP / FTPS service.
        """
        return pulumi.get(self, "ftps_state")

    @property
    @pulumi.getter(name="healthCheckEvictionTimeInMin")
    def health_check_eviction_time_in_min(self) -> int:
        """
        (Optional) The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        """
        return pulumi.get(self, "health_check_eviction_time_in_min")

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> str:
        """
        The path to the Health Check endpoint.
        """
        return pulumi.get(self, "health_check_path")

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> bool:
        """
        Is HTTP2.0 enabled.
        """
        return pulumi.get(self, "http2_enabled")

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Sequence['outputs.GetWindowsWebAppSiteConfigIpRestrictionResult']:
        """
        A `ip_restriction` block as defined above.
        """
        return pulumi.get(self, "ip_restrictions")

    @property
    @pulumi.getter(name="loadBalancingMode")
    def load_balancing_mode(self) -> str:
        """
        The site Load Balancing Mode.
        """
        return pulumi.get(self, "load_balancing_mode")

    @property
    @pulumi.getter(name="localMysqlEnabled")
    def local_mysql_enabled(self) -> bool:
        """
        Is the Local MySQL enabled.
        """
        return pulumi.get(self, "local_mysql_enabled")

    @property
    @pulumi.getter(name="managedPipelineMode")
    def managed_pipeline_mode(self) -> str:
        """
        The Managed Pipeline Mode.
        """
        return pulumi.get(self, "managed_pipeline_mode")

    @property
    @pulumi.getter(name="minimumTlsVersion")
    def minimum_tls_version(self) -> str:
        """
        The Minimum version of TLS for requests.
        """
        return pulumi.get(self, "minimum_tls_version")

    @property
    @pulumi.getter(name="remoteDebuggingEnabled")
    def remote_debugging_enabled(self) -> bool:
        return pulumi.get(self, "remote_debugging_enabled")

    @property
    @pulumi.getter(name="remoteDebuggingVersion")
    def remote_debugging_version(self) -> str:
        """
        The Remote Debugging Version.
        """
        return pulumi.get(self, "remote_debugging_version")

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Sequence['outputs.GetWindowsWebAppSiteConfigScmIpRestrictionResult']:
        """
        A `scm_ip_restriction` block as defined above.
        """
        return pulumi.get(self, "scm_ip_restrictions")

    @property
    @pulumi.getter(name="scmMinimumTlsVersion")
    def scm_minimum_tls_version(self) -> str:
        """
        The Minimum version of TLS for requests to SCM.
        """
        return pulumi.get(self, "scm_minimum_tls_version")

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> str:
        """
        The Source Control Management Type in use.
        """
        return pulumi.get(self, "scm_type")

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> bool:
        """
        Is the Windows Web App `ip_restriction` configuration used for the SCM also.
        """
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @property
    @pulumi.getter(name="use32BitWorker")
    def use32_bit_worker(self) -> bool:
        """
        Does the Windows Web App use a 32-bit worker.
        """
        return pulumi.get(self, "use32_bit_worker")

    @property
    @pulumi.getter(name="virtualApplications")
    def virtual_applications(self) -> Sequence['outputs.GetWindowsWebAppSiteConfigVirtualApplicationResult']:
        """
        A `virtual_application` block as defined below.
        """
        return pulumi.get(self, "virtual_applications")

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> bool:
        """
        Are all outbound traffic to NAT Gateways, Network Security Groups and User Defined Routes applied?
        """
        return pulumi.get(self, "vnet_route_all_enabled")

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> bool:
        """
        Are Web Sockets enabled?
        """
        return pulumi.get(self, "websockets_enabled")

    @property
    @pulumi.getter(name="windowsFxVersion")
    def windows_fx_version(self) -> str:
        """
        The string representation of the Windows FX Version.
        """
        return pulumi.get(self, "windows_fx_version")

    @property
    @pulumi.getter(name="workerCount")
    def worker_count(self) -> int:
        """
        The number of Workers for this Windows App Service.
        """
        return pulumi.get(self, "worker_count")


@pulumi.output_type
class GetWindowsWebAppSiteConfigApplicationStackResult(dict):
    def __init__(__self__, *,
                 current_stack: str,
                 docker_container_name: str,
                 docker_container_registry: str,
                 docker_container_tag: str,
                 dotnet_version: str,
                 java_container: str,
                 java_container_version: str,
                 java_version: str,
                 node_version: str,
                 php_version: str,
                 python_version: str):
        """
        :param str current_stack: The Current Stack value of the Windows Web App.
        :param str docker_container_name: The name of the Docker Container in used.
        :param str docker_container_registry: The Container Registry where the Docker Container is pulled from.
        :param str docker_container_tag: The Docker Container Tag of the Container in use.
        :param str dotnet_version: The version of .NET in use.
        :param str java_container: The Java Container in use.
        :param str java_container_version: The Version of the Java Container in use.
        :param str java_version: The Version of Java in use.
        :param str node_version: The Version of Node in use.
        :param str php_version: The Version of the PHP in use.
        :param str python_version: The Version of Python in use.
        """
        pulumi.set(__self__, "current_stack", current_stack)
        pulumi.set(__self__, "docker_container_name", docker_container_name)
        pulumi.set(__self__, "docker_container_registry", docker_container_registry)
        pulumi.set(__self__, "docker_container_tag", docker_container_tag)
        pulumi.set(__self__, "dotnet_version", dotnet_version)
        pulumi.set(__self__, "java_container", java_container)
        pulumi.set(__self__, "java_container_version", java_container_version)
        pulumi.set(__self__, "java_version", java_version)
        pulumi.set(__self__, "node_version", node_version)
        pulumi.set(__self__, "php_version", php_version)
        pulumi.set(__self__, "python_version", python_version)

    @property
    @pulumi.getter(name="currentStack")
    def current_stack(self) -> str:
        """
        The Current Stack value of the Windows Web App.
        """
        return pulumi.get(self, "current_stack")

    @property
    @pulumi.getter(name="dockerContainerName")
    def docker_container_name(self) -> str:
        """
        The name of the Docker Container in used.
        """
        return pulumi.get(self, "docker_container_name")

    @property
    @pulumi.getter(name="dockerContainerRegistry")
    def docker_container_registry(self) -> str:
        """
        The Container Registry where the Docker Container is pulled from.
        """
        return pulumi.get(self, "docker_container_registry")

    @property
    @pulumi.getter(name="dockerContainerTag")
    def docker_container_tag(self) -> str:
        """
        The Docker Container Tag of the Container in use.
        """
        return pulumi.get(self, "docker_container_tag")

    @property
    @pulumi.getter(name="dotnetVersion")
    def dotnet_version(self) -> str:
        """
        The version of .NET in use.
        """
        return pulumi.get(self, "dotnet_version")

    @property
    @pulumi.getter(name="javaContainer")
    def java_container(self) -> str:
        """
        The Java Container in use.
        """
        return pulumi.get(self, "java_container")

    @property
    @pulumi.getter(name="javaContainerVersion")
    def java_container_version(self) -> str:
        """
        The Version of the Java Container in use.
        """
        return pulumi.get(self, "java_container_version")

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> str:
        """
        The Version of Java in use.
        """
        return pulumi.get(self, "java_version")

    @property
    @pulumi.getter(name="nodeVersion")
    def node_version(self) -> str:
        """
        The Version of Node in use.
        """
        return pulumi.get(self, "node_version")

    @property
    @pulumi.getter(name="phpVersion")
    def php_version(self) -> str:
        """
        The Version of the PHP in use.
        """
        return pulumi.get(self, "php_version")

    @property
    @pulumi.getter(name="pythonVersion")
    def python_version(self) -> str:
        """
        The Version of Python in use.
        """
        return pulumi.get(self, "python_version")


@pulumi.output_type
class GetWindowsWebAppSiteConfigAutoHealSettingResult(dict):
    def __init__(__self__, *,
                 actions: Sequence['outputs.GetWindowsWebAppSiteConfigAutoHealSettingActionResult'],
                 triggers: Sequence['outputs.GetWindowsWebAppSiteConfigAutoHealSettingTriggerResult']):
        """
        :param Sequence['GetWindowsWebAppSiteConfigAutoHealSettingActionArgs'] actions: A `action` block as defined above.
        :param Sequence['GetWindowsWebAppSiteConfigAutoHealSettingTriggerArgs'] triggers: A `trigger` block as defined below.
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "triggers", triggers)

    @property
    @pulumi.getter
    def actions(self) -> Sequence['outputs.GetWindowsWebAppSiteConfigAutoHealSettingActionResult']:
        """
        A `action` block as defined above.
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter
    def triggers(self) -> Sequence['outputs.GetWindowsWebAppSiteConfigAutoHealSettingTriggerResult']:
        """
        A `trigger` block as defined below.
        """
        return pulumi.get(self, "triggers")


@pulumi.output_type
class GetWindowsWebAppSiteConfigAutoHealSettingActionResult(dict):
    def __init__(__self__, *,
                 action_type: str,
                 custom_actions: Sequence['outputs.GetWindowsWebAppSiteConfigAutoHealSettingActionCustomActionResult'],
                 minimum_process_execution_time: str):
        """
        :param str action_type: The predefined action to be taken to an Auto Heal trigger.
        :param Sequence['GetWindowsWebAppSiteConfigAutoHealSettingActionCustomActionArgs'] custom_actions: A `custom_action` block as defined below.
        :param str minimum_process_execution_time: The minimum amount of time in `hh:mm:ss` the Windows Web App must have been running before the defined action will be run in the event of a trigger.
        """
        pulumi.set(__self__, "action_type", action_type)
        pulumi.set(__self__, "custom_actions", custom_actions)
        pulumi.set(__self__, "minimum_process_execution_time", minimum_process_execution_time)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> str:
        """
        The predefined action to be taken to an Auto Heal trigger.
        """
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter(name="customActions")
    def custom_actions(self) -> Sequence['outputs.GetWindowsWebAppSiteConfigAutoHealSettingActionCustomActionResult']:
        """
        A `custom_action` block as defined below.
        """
        return pulumi.get(self, "custom_actions")

    @property
    @pulumi.getter(name="minimumProcessExecutionTime")
    def minimum_process_execution_time(self) -> str:
        """
        The minimum amount of time in `hh:mm:ss` the Windows Web App must have been running before the defined action will be run in the event of a trigger.
        """
        return pulumi.get(self, "minimum_process_execution_time")


@pulumi.output_type
class GetWindowsWebAppSiteConfigAutoHealSettingActionCustomActionResult(dict):
    def __init__(__self__, *,
                 executable: str,
                 parameters: str):
        """
        :param str executable: The command run when this `auto_heal` action is triggered.
        :param str parameters: The parameters passed to the `executable`.
        """
        pulumi.set(__self__, "executable", executable)
        pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def executable(self) -> str:
        """
        The command run when this `auto_heal` action is triggered.
        """
        return pulumi.get(self, "executable")

    @property
    @pulumi.getter
    def parameters(self) -> str:
        """
        The parameters passed to the `executable`.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class GetWindowsWebAppSiteConfigAutoHealSettingTriggerResult(dict):
    def __init__(__self__, *,
                 private_memory_kb: int,
                 requests: Sequence['outputs.GetWindowsWebAppSiteConfigAutoHealSettingTriggerRequestResult'],
                 slow_requests: Sequence['outputs.GetWindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequestResult'],
                 status_codes: Sequence['outputs.GetWindowsWebAppSiteConfigAutoHealSettingTriggerStatusCodeResult']):
        """
        :param int private_memory_kb: The amount of Private Memory used.
        :param Sequence['GetWindowsWebAppSiteConfigAutoHealSettingTriggerRequestArgs'] requests: A `requests` block as defined above.
        :param Sequence['GetWindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequestArgs'] slow_requests: A `slow_request` block as defined above.
        :param Sequence['GetWindowsWebAppSiteConfigAutoHealSettingTriggerStatusCodeArgs'] status_codes: A `status_code` block as defined above.
        """
        pulumi.set(__self__, "private_memory_kb", private_memory_kb)
        pulumi.set(__self__, "requests", requests)
        pulumi.set(__self__, "slow_requests", slow_requests)
        pulumi.set(__self__, "status_codes", status_codes)

    @property
    @pulumi.getter(name="privateMemoryKb")
    def private_memory_kb(self) -> int:
        """
        The amount of Private Memory used.
        """
        return pulumi.get(self, "private_memory_kb")

    @property
    @pulumi.getter
    def requests(self) -> Sequence['outputs.GetWindowsWebAppSiteConfigAutoHealSettingTriggerRequestResult']:
        """
        A `requests` block as defined above.
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="slowRequests")
    def slow_requests(self) -> Sequence['outputs.GetWindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequestResult']:
        """
        A `slow_request` block as defined above.
        """
        return pulumi.get(self, "slow_requests")

    @property
    @pulumi.getter(name="statusCodes")
    def status_codes(self) -> Sequence['outputs.GetWindowsWebAppSiteConfigAutoHealSettingTriggerStatusCodeResult']:
        """
        A `status_code` block as defined above.
        """
        return pulumi.get(self, "status_codes")


@pulumi.output_type
class GetWindowsWebAppSiteConfigAutoHealSettingTriggerRequestResult(dict):
    def __init__(__self__, *,
                 count: int,
                 interval: str):
        """
        :param int count: The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        :param str interval: The time interval in the form `hh:mm:ss`.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        The time interval in the form `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class GetWindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequestResult(dict):
    def __init__(__self__, *,
                 count: int,
                 interval: str,
                 path: str,
                 time_taken: str):
        """
        :param int count: The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        :param str interval: The time interval in the form `hh:mm:ss`.
        :param str path: The path to which this rule status code applies.
        :param str time_taken: The amount of time that qualifies as slow for this rule.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "time_taken", time_taken)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        The time interval in the form `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The path to which this rule status code applies.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="timeTaken")
    def time_taken(self) -> str:
        """
        The amount of time that qualifies as slow for this rule.
        """
        return pulumi.get(self, "time_taken")


@pulumi.output_type
class GetWindowsWebAppSiteConfigAutoHealSettingTriggerStatusCodeResult(dict):
    def __init__(__self__, *,
                 count: int,
                 interval: str,
                 path: str,
                 status_code_range: str,
                 sub_status: int,
                 win32_status: str):
        """
        :param int count: The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        :param str interval: The time interval in the form `hh:mm:ss`.
        :param str path: The path to which this rule status code applies.
        :param str status_code_range: The status code or range for this rule.
        :param int sub_status: The Request Sub Status of the Status Code.
        :param str win32_status: The Win32 Status Code of the Request.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "status_code_range", status_code_range)
        pulumi.set(__self__, "sub_status", sub_status)
        pulumi.set(__self__, "win32_status", win32_status)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        The time interval in the form `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The path to which this rule status code applies.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="statusCodeRange")
    def status_code_range(self) -> str:
        """
        The status code or range for this rule.
        """
        return pulumi.get(self, "status_code_range")

    @property
    @pulumi.getter(name="subStatus")
    def sub_status(self) -> int:
        """
        The Request Sub Status of the Status Code.
        """
        return pulumi.get(self, "sub_status")

    @property
    @pulumi.getter(name="win32Status")
    def win32_status(self) -> str:
        """
        The Win32 Status Code of the Request.
        """
        return pulumi.get(self, "win32_status")


@pulumi.output_type
class GetWindowsWebAppSiteConfigCorResult(dict):
    def __init__(__self__, *,
                 allowed_origins: Sequence[str],
                 support_credentials: bool):
        """
        :param Sequence[str] allowed_origins: A `allowed_origins` block as defined above.
        :param bool support_credentials: Whether CORS requests with credentials are allowed.
        """
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Sequence[str]:
        """
        A `allowed_origins` block as defined above.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> bool:
        """
        Whether CORS requests with credentials are allowed.
        """
        return pulumi.get(self, "support_credentials")


@pulumi.output_type
class GetWindowsWebAppSiteConfigIpRestrictionResult(dict):
    def __init__(__self__, *,
                 action: str,
                 headers: Sequence['outputs.GetWindowsWebAppSiteConfigIpRestrictionHeaderResult'],
                 ip_address: str,
                 name: str,
                 priority: int,
                 service_tag: str,
                 virtual_network_subnet_id: str):
        """
        :param str action: A `action` block as defined above.
        :param str name: The name of this Windows Web App.
        :param str virtual_network_subnet_id: The subnet id which the Windows Web App is vNet Integrated with.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "service_tag", service_tag)
        pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        A `action` block as defined above.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.GetWindowsWebAppSiteConfigIpRestrictionHeaderResult']:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this Windows Web App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> str:
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> str:
        """
        The subnet id which the Windows Web App is vNet Integrated with.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class GetWindowsWebAppSiteConfigIpRestrictionHeaderResult(dict):
    def __init__(__self__, *,
                 x_azure_fdids: Sequence[str],
                 x_fd_health_probes: Sequence[str],
                 x_forwarded_fors: Sequence[str],
                 x_forwarded_hosts: Sequence[str]):
        pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        pulumi.set(__self__, "x_fd_health_probes", x_fd_health_probes)
        pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Sequence[str]:
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbes")
    def x_fd_health_probes(self) -> Sequence[str]:
        return pulumi.get(self, "x_fd_health_probes")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Sequence[str]:
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Sequence[str]:
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class GetWindowsWebAppSiteConfigScmIpRestrictionResult(dict):
    def __init__(__self__, *,
                 action: str,
                 headers: Sequence['outputs.GetWindowsWebAppSiteConfigScmIpRestrictionHeaderResult'],
                 ip_address: str,
                 name: str,
                 priority: int,
                 service_tag: str,
                 virtual_network_subnet_id: str):
        """
        :param str action: A `action` block as defined above.
        :param str name: The name of this Windows Web App.
        :param str virtual_network_subnet_id: The subnet id which the Windows Web App is vNet Integrated with.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "service_tag", service_tag)
        pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        A `action` block as defined above.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.GetWindowsWebAppSiteConfigScmIpRestrictionHeaderResult']:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this Windows Web App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> str:
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> str:
        """
        The subnet id which the Windows Web App is vNet Integrated with.
        """
        return pulumi.get(self, "virtual_network_subnet_id")


@pulumi.output_type
class GetWindowsWebAppSiteConfigScmIpRestrictionHeaderResult(dict):
    def __init__(__self__, *,
                 x_azure_fdids: Sequence[str],
                 x_fd_health_probes: Sequence[str],
                 x_forwarded_fors: Sequence[str],
                 x_forwarded_hosts: Sequence[str]):
        pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        pulumi.set(__self__, "x_fd_health_probes", x_fd_health_probes)
        pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Sequence[str]:
        return pulumi.get(self, "x_azure_fdids")

    @property
    @pulumi.getter(name="xFdHealthProbes")
    def x_fd_health_probes(self) -> Sequence[str]:
        return pulumi.get(self, "x_fd_health_probes")

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Sequence[str]:
        return pulumi.get(self, "x_forwarded_fors")

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Sequence[str]:
        return pulumi.get(self, "x_forwarded_hosts")


@pulumi.output_type
class GetWindowsWebAppSiteConfigVirtualApplicationResult(dict):
    def __init__(__self__, *,
                 physical_path: str,
                 preload: bool,
                 virtual_directories: Sequence['outputs.GetWindowsWebAppSiteConfigVirtualApplicationVirtualDirectoryResult'],
                 virtual_path: str):
        """
        :param str physical_path: The path on disk to the Virtual Directory
        :param bool preload: Is this Application Pre-loaded at startup.
        :param Sequence['GetWindowsWebAppSiteConfigVirtualApplicationVirtualDirectoryArgs'] virtual_directories: A `virtual_directory` block as defined below.
        :param str virtual_path: The Virtual Path of the Virtual Directory.
        """
        pulumi.set(__self__, "physical_path", physical_path)
        pulumi.set(__self__, "preload", preload)
        pulumi.set(__self__, "virtual_directories", virtual_directories)
        pulumi.set(__self__, "virtual_path", virtual_path)

    @property
    @pulumi.getter(name="physicalPath")
    def physical_path(self) -> str:
        """
        The path on disk to the Virtual Directory
        """
        return pulumi.get(self, "physical_path")

    @property
    @pulumi.getter
    def preload(self) -> bool:
        """
        Is this Application Pre-loaded at startup.
        """
        return pulumi.get(self, "preload")

    @property
    @pulumi.getter(name="virtualDirectories")
    def virtual_directories(self) -> Sequence['outputs.GetWindowsWebAppSiteConfigVirtualApplicationVirtualDirectoryResult']:
        """
        A `virtual_directory` block as defined below.
        """
        return pulumi.get(self, "virtual_directories")

    @property
    @pulumi.getter(name="virtualPath")
    def virtual_path(self) -> str:
        """
        The Virtual Path of the Virtual Directory.
        """
        return pulumi.get(self, "virtual_path")


@pulumi.output_type
class GetWindowsWebAppSiteConfigVirtualApplicationVirtualDirectoryResult(dict):
    def __init__(__self__, *,
                 physical_path: str,
                 virtual_path: str):
        """
        :param str physical_path: The path on disk to the Virtual Directory
        :param str virtual_path: The Virtual Path of the Virtual Directory.
        """
        pulumi.set(__self__, "physical_path", physical_path)
        pulumi.set(__self__, "virtual_path", virtual_path)

    @property
    @pulumi.getter(name="physicalPath")
    def physical_path(self) -> str:
        """
        The path on disk to the Virtual Directory
        """
        return pulumi.get(self, "physical_path")

    @property
    @pulumi.getter(name="virtualPath")
    def virtual_path(self) -> str:
        """
        The Virtual Path of the Virtual Directory.
        """
        return pulumi.get(self, "virtual_path")


@pulumi.output_type
class GetWindowsWebAppSiteCredentialResult(dict):
    def __init__(__self__, *,
                 name: str,
                 password: str):
        """
        :param str name: The name of this Windows Web App.
        :param str password: The Site Credentials Password used for publishing.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this Windows Web App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The Site Credentials Password used for publishing.
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class GetWindowsWebAppStickySettingResult(dict):
    def __init__(__self__, *,
                 app_setting_names: Sequence[str],
                 connection_string_names: Sequence[str]):
        """
        :param Sequence[str] app_setting_names: A list of `app_setting` names that the Windows Web App will not swap between Slots when a swap operation is triggered.
        :param Sequence[str] connection_string_names: A list of `connection_string` names that the Windows Web App will not swap between Slots when a swap operation is triggered.
        """
        pulumi.set(__self__, "app_setting_names", app_setting_names)
        pulumi.set(__self__, "connection_string_names", connection_string_names)

    @property
    @pulumi.getter(name="appSettingNames")
    def app_setting_names(self) -> Sequence[str]:
        """
        A list of `app_setting` names that the Windows Web App will not swap between Slots when a swap operation is triggered.
        """
        return pulumi.get(self, "app_setting_names")

    @property
    @pulumi.getter(name="connectionStringNames")
    def connection_string_names(self) -> Sequence[str]:
        """
        A list of `connection_string` names that the Windows Web App will not swap between Slots when a swap operation is triggered.
        """
        return pulumi.get(self, "connection_string_names")


@pulumi.output_type
class GetWindowsWebAppStorageAccountResult(dict):
    def __init__(__self__, *,
                 access_key: str,
                 account_name: str,
                 mount_path: str,
                 name: str,
                 share_name: str,
                 type: str):
        """
        :param str access_key: The Access key for the storage account.
        :param str account_name: The Name of the Storage Account.
        :param str mount_path: The path at which to mount the Storage Share.
        :param str name: The name of this Windows Web App.
        :param str share_name: The Name of the File Share.
        :param str type: The Azure Storage Type.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "mount_path", mount_path)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "share_name", share_name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> str:
        """
        The Access key for the storage account.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> str:
        """
        The Name of the Storage Account.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> str:
        """
        The path at which to mount the Storage Share.
        """
        return pulumi.get(self, "mount_path")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this Windows Web App.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> str:
        """
        The Name of the File Share.
        """
        return pulumi.get(self, "share_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The Azure Storage Type.
        """
        return pulumi.get(self, "type")


