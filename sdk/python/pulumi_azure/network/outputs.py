# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'ApplicationGatewayAuthenticationCertificate',
    'ApplicationGatewayAutoscaleConfiguration',
    'ApplicationGatewayBackendAddressPool',
    'ApplicationGatewayBackendHttpSetting',
    'ApplicationGatewayBackendHttpSettingAuthenticationCertificate',
    'ApplicationGatewayBackendHttpSettingConnectionDraining',
    'ApplicationGatewayCustomErrorConfiguration',
    'ApplicationGatewayFrontendIpConfiguration',
    'ApplicationGatewayFrontendPort',
    'ApplicationGatewayGatewayIpConfiguration',
    'ApplicationGatewayHttpListener',
    'ApplicationGatewayHttpListenerCustomErrorConfiguration',
    'ApplicationGatewayIdentity',
    'ApplicationGatewayProbe',
    'ApplicationGatewayProbeMatch',
    'ApplicationGatewayRedirectConfiguration',
    'ApplicationGatewayRequestRoutingRule',
    'ApplicationGatewayRewriteRuleSet',
    'ApplicationGatewayRewriteRuleSetRewriteRule',
    'ApplicationGatewayRewriteRuleSetRewriteRuleCondition',
    'ApplicationGatewayRewriteRuleSetRewriteRuleRequestHeaderConfiguration',
    'ApplicationGatewayRewriteRuleSetRewriteRuleResponseHeaderConfiguration',
    'ApplicationGatewayRewriteRuleSetRewriteRuleUrl',
    'ApplicationGatewaySku',
    'ApplicationGatewaySslCertificate',
    'ApplicationGatewaySslPolicy',
    'ApplicationGatewayTrustedRootCertificate',
    'ApplicationGatewayUrlPathMap',
    'ApplicationGatewayUrlPathMapPathRule',
    'ApplicationGatewayWafConfiguration',
    'ApplicationGatewayWafConfigurationDisabledRuleGroup',
    'ApplicationGatewayWafConfigurationExclusion',
    'ExpressRouteCircuitPeeringIpv6',
    'ExpressRouteCircuitPeeringIpv6MicrosoftPeering',
    'ExpressRouteCircuitPeeringMicrosoftPeeringConfig',
    'ExpressRouteCircuitSku',
    'ExpressRouteConnectionRouting',
    'ExpressRouteConnectionRoutingPropagatedRouteTable',
    'ExpressRoutePortIdentity',
    'ExpressRoutePortLink1',
    'ExpressRoutePortLink2',
    'FirewallApplicationRuleCollectionRule',
    'FirewallApplicationRuleCollectionRuleProtocol',
    'FirewallIpConfiguration',
    'FirewallManagementIpConfiguration',
    'FirewallNatRuleCollectionRule',
    'FirewallNetworkRuleCollectionRule',
    'FirewallPolicyDns',
    'FirewallPolicyRuleCollectionGroupApplicationRuleCollection',
    'FirewallPolicyRuleCollectionGroupApplicationRuleCollectionRule',
    'FirewallPolicyRuleCollectionGroupApplicationRuleCollectionRuleProtocol',
    'FirewallPolicyRuleCollectionGroupNatRuleCollection',
    'FirewallPolicyRuleCollectionGroupNatRuleCollectionRule',
    'FirewallPolicyRuleCollectionGroupNetworkRuleCollection',
    'FirewallPolicyRuleCollectionGroupNetworkRuleCollectionRule',
    'FirewallPolicyThreatIntelligenceAllowlist',
    'FirewallVirtualHub',
    'LocalNetworkGatewayBgpSettings',
    'NetworkConnectionMonitorDestination',
    'NetworkConnectionMonitorEndpoint',
    'NetworkConnectionMonitorEndpointFilter',
    'NetworkConnectionMonitorEndpointFilterItem',
    'NetworkConnectionMonitorSource',
    'NetworkConnectionMonitorTestConfiguration',
    'NetworkConnectionMonitorTestConfigurationHttpConfiguration',
    'NetworkConnectionMonitorTestConfigurationHttpConfigurationRequestHeader',
    'NetworkConnectionMonitorTestConfigurationIcmpConfiguration',
    'NetworkConnectionMonitorTestConfigurationSuccessThreshold',
    'NetworkConnectionMonitorTestConfigurationTcpConfiguration',
    'NetworkConnectionMonitorTestGroup',
    'NetworkInterfaceIpConfiguration',
    'NetworkPacketCaptureFilter',
    'NetworkPacketCaptureStorageLocation',
    'NetworkSecurityGroupSecurityRule',
    'NetworkWatcherFlowLogRetentionPolicy',
    'NetworkWatcherFlowLogTrafficAnalytics',
    'PacketCaptureFilter',
    'PacketCaptureStorageLocation',
    'PointToPointVpnGatewayConnectionConfiguration',
    'PointToPointVpnGatewayConnectionConfigurationRoute',
    'PointToPointVpnGatewayConnectionConfigurationRoutePropagatedRouteTable',
    'PointToPointVpnGatewayConnectionConfigurationVpnClientAddressPool',
    'ProfileContainerNetworkInterface',
    'ProfileContainerNetworkInterfaceIpConfiguration',
    'RouteFilterRule',
    'RouteTableRoute',
    'SubnetDelegation',
    'SubnetDelegationServiceDelegation',
    'SubnetServiceEndpointStoragePolicyDefinition',
    'TrafficManagerEndpointCustomHeader',
    'TrafficManagerEndpointSubnet',
    'TrafficManagerProfileDnsConfig',
    'TrafficManagerProfileMonitorConfig',
    'TrafficManagerProfileMonitorConfigCustomHeader',
    'VirtualHubConnectionRouting',
    'VirtualHubConnectionRoutingPropagatedRouteTable',
    'VirtualHubConnectionRoutingStaticVnetRoute',
    'VirtualHubRoute',
    'VirtualHubRouteTableRoute',
    'VirtualNetworkDdosProtectionPlan',
    'VirtualNetworkGatewayBgpSettings',
    'VirtualNetworkGatewayBgpSettingsPeeringAddress',
    'VirtualNetworkGatewayConnectionIpsecPolicy',
    'VirtualNetworkGatewayConnectionTrafficSelectorPolicy',
    'VirtualNetworkGatewayCustomRoute',
    'VirtualNetworkGatewayIpConfiguration',
    'VirtualNetworkGatewayVpnClientConfiguration',
    'VirtualNetworkGatewayVpnClientConfigurationRevokedCertificate',
    'VirtualNetworkGatewayVpnClientConfigurationRootCertificate',
    'VirtualNetworkSubnet',
    'VpnGatewayBgpSettings',
    'VpnGatewayBgpSettingsInstance0BgpPeeringAddress',
    'VpnGatewayBgpSettingsInstance1BgpPeeringAddress',
    'VpnGatewayConnectionRouting',
    'VpnGatewayConnectionVpnLink',
    'VpnGatewayConnectionVpnLinkIpsecPolicy',
    'VpnServerConfigurationAzureActiveDirectoryAuthentication',
    'VpnServerConfigurationClientRevokedCertificate',
    'VpnServerConfigurationClientRootCertificate',
    'VpnServerConfigurationIpsecPolicy',
    'VpnServerConfigurationRadius',
    'VpnServerConfigurationRadiusClientRootCertificate',
    'VpnServerConfigurationRadiusServer',
    'VpnServerConfigurationRadiusServerClientRootCertificate',
    'VpnServerConfigurationRadiusServerRootCertificate',
    'VpnServerConfigurationRadiusServerServerRootCertificate',
    'VpnSiteLink',
    'VpnSiteLinkBgp',
    'GetApplicationGatewayIdentityResult',
    'GetExpressRouteCircuitPeeringResult',
    'GetExpressRouteCircuitServiceProviderPropertyResult',
    'GetExpressRouteCircuitSkuResult',
    'GetFirewallIpConfigurationResult',
    'GetFirewallManagementIpConfigurationResult',
    'GetFirewallPolicyDnResult',
    'GetFirewallPolicyThreatIntelligenceAllowlistResult',
    'GetFirewallVirtualHubResult',
    'GetGatewayConnectionIpsecPolicyResult',
    'GetGatewayConnectionTrafficSelectorPolicyResult',
    'GetNetworkInterfaceIpConfigurationResult',
    'GetNetworkSecurityGroupSecurityRuleResult',
    'GetPublicIPsPublicIpResult',
    'GetRouteFilterRuleResult',
    'GetRouteTableRouteResult',
    'GetTrafficManagerProfileDnsConfigResult',
    'GetTrafficManagerProfileMonitorConfigResult',
    'GetTrafficManagerProfileMonitorConfigCustomHeaderResult',
    'GetVirtualNetworkGatewayBgpSettingResult',
    'GetVirtualNetworkGatewayCustomRouteResult',
    'GetVirtualNetworkGatewayIpConfigurationResult',
    'GetVirtualNetworkGatewayVpnClientConfigurationResult',
    'GetVirtualNetworkGatewayVpnClientConfigurationRevokedCertificateResult',
    'GetVirtualNetworkGatewayVpnClientConfigurationRootCertificateResult',
]

@pulumi.output_type
class ApplicationGatewayAuthenticationCertificate(dict):
    def __init__(__self__, *,
                 data: str,
                 name: str,
                 id: Optional[str] = None):
        """
        :param str data: The contents of the Authentication Certificate which should be used.
        :param str name: The name of the Authentication Certificate.
        :param str id: The ID of the Rewrite Rule Set
        """
        pulumi.set(__self__, "data", data)
        pulumi.set(__self__, "name", name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def data(self) -> str:
        """
        The contents of the Authentication Certificate which should be used.
        """
        return pulumi.get(self, "data")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Authentication Certificate.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Rewrite Rule Set
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ApplicationGatewayAutoscaleConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minCapacity":
            suggest = "min_capacity"
        elif key == "maxCapacity":
            suggest = "max_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayAutoscaleConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayAutoscaleConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayAutoscaleConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 min_capacity: int,
                 max_capacity: Optional[int] = None):
        """
        :param int min_capacity: Minimum capacity for autoscaling. Accepted values are in the range `0` to `100`.
        :param int max_capacity: Maximum capacity for autoscaling. Accepted values are in the range `2` to `125`.
        """
        pulumi.set(__self__, "min_capacity", min_capacity)
        if max_capacity is not None:
            pulumi.set(__self__, "max_capacity", max_capacity)

    @property
    @pulumi.getter(name="minCapacity")
    def min_capacity(self) -> int:
        """
        Minimum capacity for autoscaling. Accepted values are in the range `0` to `100`.
        """
        return pulumi.get(self, "min_capacity")

    @property
    @pulumi.getter(name="maxCapacity")
    def max_capacity(self) -> Optional[int]:
        """
        Maximum capacity for autoscaling. Accepted values are in the range `2` to `125`.
        """
        return pulumi.get(self, "max_capacity")


@pulumi.output_type
class ApplicationGatewayBackendAddressPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddresses":
            suggest = "ip_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayBackendAddressPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayBackendAddressPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayBackendAddressPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 fqdns: Optional[Sequence[str]] = None,
                 id: Optional[str] = None,
                 ip_addresses: Optional[Sequence[str]] = None):
        """
        :param str name: The name of the Backend Address Pool.
        :param Sequence[str] fqdns: A list of FQDN's which should be part of the Backend Address Pool.
        :param str id: The ID of the Rewrite Rule Set
        :param Sequence[str] ip_addresses: A list of IP Addresses which should be part of the Backend Address Pool.
        """
        pulumi.set(__self__, "name", name)
        if fqdns is not None:
            pulumi.set(__self__, "fqdns", fqdns)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Backend Address Pool.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def fqdns(self) -> Optional[Sequence[str]]:
        """
        A list of FQDN's which should be part of the Backend Address Pool.
        """
        return pulumi.get(self, "fqdns")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Rewrite Rule Set
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[Sequence[str]]:
        """
        A list of IP Addresses which should be part of the Backend Address Pool.
        """
        return pulumi.get(self, "ip_addresses")


@pulumi.output_type
class ApplicationGatewayBackendHttpSetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cookieBasedAffinity":
            suggest = "cookie_based_affinity"
        elif key == "affinityCookieName":
            suggest = "affinity_cookie_name"
        elif key == "authenticationCertificates":
            suggest = "authentication_certificates"
        elif key == "connectionDraining":
            suggest = "connection_draining"
        elif key == "hostName":
            suggest = "host_name"
        elif key == "pickHostNameFromBackendAddress":
            suggest = "pick_host_name_from_backend_address"
        elif key == "probeId":
            suggest = "probe_id"
        elif key == "probeName":
            suggest = "probe_name"
        elif key == "requestTimeout":
            suggest = "request_timeout"
        elif key == "trustedRootCertificateNames":
            suggest = "trusted_root_certificate_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayBackendHttpSetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayBackendHttpSetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayBackendHttpSetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cookie_based_affinity: str,
                 name: str,
                 port: int,
                 protocol: str,
                 affinity_cookie_name: Optional[str] = None,
                 authentication_certificates: Optional[Sequence['outputs.ApplicationGatewayBackendHttpSettingAuthenticationCertificate']] = None,
                 connection_draining: Optional['outputs.ApplicationGatewayBackendHttpSettingConnectionDraining'] = None,
                 host_name: Optional[str] = None,
                 id: Optional[str] = None,
                 path: Optional[str] = None,
                 pick_host_name_from_backend_address: Optional[bool] = None,
                 probe_id: Optional[str] = None,
                 probe_name: Optional[str] = None,
                 request_timeout: Optional[int] = None,
                 trusted_root_certificate_names: Optional[Sequence[str]] = None):
        """
        :param str cookie_based_affinity: Is Cookie-Based Affinity enabled? Possible values are `Enabled` and `Disabled`.
        :param str name: The name of the Backend HTTP Settings Collection.
        :param int port: The port which should be used for this Backend HTTP Settings Collection.
        :param str protocol: The Protocol which should be used. Possible values are `Http` and `Https`.
        :param str affinity_cookie_name: The name of the affinity cookie.
        :param Sequence['ApplicationGatewayBackendHttpSettingAuthenticationCertificateArgs'] authentication_certificates: One or more `authentication_certificate` blocks.
        :param 'ApplicationGatewayBackendHttpSettingConnectionDrainingArgs' connection_draining: A `connection_draining` block as defined below.
        :param str host_name: Host header to be sent to the backend servers. Cannot be set if `pick_host_name_from_backend_address` is set to `true`.
        :param str id: The ID of the Rewrite Rule Set
        :param str path: The Path which should be used as a prefix for all HTTP requests.
        :param bool pick_host_name_from_backend_address: Whether host header should be picked from the host name of the backend server. Defaults to `false`.
        :param str probe_id: The ID of the associated Probe.
        :param str probe_name: The name of an associated HTTP Probe.
        :param int request_timeout: The request timeout in seconds, which must be between 1 and 86400 seconds.
        :param Sequence[str] trusted_root_certificate_names: A list of `trusted_root_certificate` names.
        """
        pulumi.set(__self__, "cookie_based_affinity", cookie_based_affinity)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        if affinity_cookie_name is not None:
            pulumi.set(__self__, "affinity_cookie_name", affinity_cookie_name)
        if authentication_certificates is not None:
            pulumi.set(__self__, "authentication_certificates", authentication_certificates)
        if connection_draining is not None:
            pulumi.set(__self__, "connection_draining", connection_draining)
        if host_name is not None:
            pulumi.set(__self__, "host_name", host_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if pick_host_name_from_backend_address is not None:
            pulumi.set(__self__, "pick_host_name_from_backend_address", pick_host_name_from_backend_address)
        if probe_id is not None:
            pulumi.set(__self__, "probe_id", probe_id)
        if probe_name is not None:
            pulumi.set(__self__, "probe_name", probe_name)
        if request_timeout is not None:
            pulumi.set(__self__, "request_timeout", request_timeout)
        if trusted_root_certificate_names is not None:
            pulumi.set(__self__, "trusted_root_certificate_names", trusted_root_certificate_names)

    @property
    @pulumi.getter(name="cookieBasedAffinity")
    def cookie_based_affinity(self) -> str:
        """
        Is Cookie-Based Affinity enabled? Possible values are `Enabled` and `Disabled`.
        """
        return pulumi.get(self, "cookie_based_affinity")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Backend HTTP Settings Collection.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port which should be used for this Backend HTTP Settings Collection.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The Protocol which should be used. Possible values are `Http` and `Https`.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="affinityCookieName")
    def affinity_cookie_name(self) -> Optional[str]:
        """
        The name of the affinity cookie.
        """
        return pulumi.get(self, "affinity_cookie_name")

    @property
    @pulumi.getter(name="authenticationCertificates")
    def authentication_certificates(self) -> Optional[Sequence['outputs.ApplicationGatewayBackendHttpSettingAuthenticationCertificate']]:
        """
        One or more `authentication_certificate` blocks.
        """
        return pulumi.get(self, "authentication_certificates")

    @property
    @pulumi.getter(name="connectionDraining")
    def connection_draining(self) -> Optional['outputs.ApplicationGatewayBackendHttpSettingConnectionDraining']:
        """
        A `connection_draining` block as defined below.
        """
        return pulumi.get(self, "connection_draining")

    @property
    @pulumi.getter(name="hostName")
    def host_name(self) -> Optional[str]:
        """
        Host header to be sent to the backend servers. Cannot be set if `pick_host_name_from_backend_address` is set to `true`.
        """
        return pulumi.get(self, "host_name")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Rewrite Rule Set
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The Path which should be used as a prefix for all HTTP requests.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="pickHostNameFromBackendAddress")
    def pick_host_name_from_backend_address(self) -> Optional[bool]:
        """
        Whether host header should be picked from the host name of the backend server. Defaults to `false`.
        """
        return pulumi.get(self, "pick_host_name_from_backend_address")

    @property
    @pulumi.getter(name="probeId")
    def probe_id(self) -> Optional[str]:
        """
        The ID of the associated Probe.
        """
        return pulumi.get(self, "probe_id")

    @property
    @pulumi.getter(name="probeName")
    def probe_name(self) -> Optional[str]:
        """
        The name of an associated HTTP Probe.
        """
        return pulumi.get(self, "probe_name")

    @property
    @pulumi.getter(name="requestTimeout")
    def request_timeout(self) -> Optional[int]:
        """
        The request timeout in seconds, which must be between 1 and 86400 seconds.
        """
        return pulumi.get(self, "request_timeout")

    @property
    @pulumi.getter(name="trustedRootCertificateNames")
    def trusted_root_certificate_names(self) -> Optional[Sequence[str]]:
        """
        A list of `trusted_root_certificate` names.
        """
        return pulumi.get(self, "trusted_root_certificate_names")


@pulumi.output_type
class ApplicationGatewayBackendHttpSettingAuthenticationCertificate(dict):
    def __init__(__self__, *,
                 name: str,
                 id: Optional[str] = None):
        """
        :param str name: The name of the Authentication Certificate.
        :param str id: The ID of the Rewrite Rule Set
        """
        pulumi.set(__self__, "name", name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Authentication Certificate.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Rewrite Rule Set
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ApplicationGatewayBackendHttpSettingConnectionDraining(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "drainTimeoutSec":
            suggest = "drain_timeout_sec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayBackendHttpSettingConnectionDraining. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayBackendHttpSettingConnectionDraining.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayBackendHttpSettingConnectionDraining.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 drain_timeout_sec: int,
                 enabled: bool):
        """
        :param int drain_timeout_sec: The number of seconds connection draining is active. Acceptable values are from `1` second to `3600` seconds.
        :param bool enabled: If connection draining is enabled or not.
        """
        pulumi.set(__self__, "drain_timeout_sec", drain_timeout_sec)
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="drainTimeoutSec")
    def drain_timeout_sec(self) -> int:
        """
        The number of seconds connection draining is active. Acceptable values are from `1` second to `3600` seconds.
        """
        return pulumi.get(self, "drain_timeout_sec")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        If connection draining is enabled or not.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ApplicationGatewayCustomErrorConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customErrorPageUrl":
            suggest = "custom_error_page_url"
        elif key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayCustomErrorConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayCustomErrorConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayCustomErrorConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_error_page_url: str,
                 status_code: str,
                 id: Optional[str] = None):
        """
        :param str custom_error_page_url: Error page URL of the application gateway customer error.
        :param str status_code: Status code of the application gateway customer error. Possible values are `HttpStatus403` and `HttpStatus502`
        :param str id: The ID of the Rewrite Rule Set
        """
        pulumi.set(__self__, "custom_error_page_url", custom_error_page_url)
        pulumi.set(__self__, "status_code", status_code)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="customErrorPageUrl")
    def custom_error_page_url(self) -> str:
        """
        Error page URL of the application gateway customer error.
        """
        return pulumi.get(self, "custom_error_page_url")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> str:
        """
        Status code of the application gateway customer error. Possible values are `HttpStatus403` and `HttpStatus502`
        """
        return pulumi.get(self, "status_code")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Rewrite Rule Set
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ApplicationGatewayFrontendIpConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateIpAddress":
            suggest = "private_ip_address"
        elif key == "privateIpAddressAllocation":
            suggest = "private_ip_address_allocation"
        elif key == "publicIpAddressId":
            suggest = "public_ip_address_id"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayFrontendIpConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayFrontendIpConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayFrontendIpConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 id: Optional[str] = None,
                 private_ip_address: Optional[str] = None,
                 private_ip_address_allocation: Optional[str] = None,
                 public_ip_address_id: Optional[str] = None,
                 subnet_id: Optional[str] = None):
        """
        :param str name: The name of the Frontend IP Configuration.
        :param str id: The ID of the Rewrite Rule Set
        :param str private_ip_address: The Private IP Address to use for the Application Gateway.
        :param str private_ip_address_allocation: The Allocation Method for the Private IP Address. Possible values are `Dynamic` and `Static`.
        :param str public_ip_address_id: The ID of a Public IP Address which the Application Gateway should use. The allocation method for the Public IP Address depends on the `sku` of this Application Gateway. Please refer to the [Azure documentation for public IP addresses](https://docs.microsoft.com/en-us/azure/virtual-network/public-ip-addresses#application-gateways) for details.
        :param str subnet_id: The ID of the Subnet.
        """
        pulumi.set(__self__, "name", name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)
        if private_ip_address_allocation is not None:
            pulumi.set(__self__, "private_ip_address_allocation", private_ip_address_allocation)
        if public_ip_address_id is not None:
            pulumi.set(__self__, "public_ip_address_id", public_ip_address_id)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Frontend IP Configuration.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Rewrite Rule Set
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> Optional[str]:
        """
        The Private IP Address to use for the Application Gateway.
        """
        return pulumi.get(self, "private_ip_address")

    @property
    @pulumi.getter(name="privateIpAddressAllocation")
    def private_ip_address_allocation(self) -> Optional[str]:
        """
        The Allocation Method for the Private IP Address. Possible values are `Dynamic` and `Static`.
        """
        return pulumi.get(self, "private_ip_address_allocation")

    @property
    @pulumi.getter(name="publicIpAddressId")
    def public_ip_address_id(self) -> Optional[str]:
        """
        The ID of a Public IP Address which the Application Gateway should use. The allocation method for the Public IP Address depends on the `sku` of this Application Gateway. Please refer to the [Azure documentation for public IP addresses](https://docs.microsoft.com/en-us/azure/virtual-network/public-ip-addresses#application-gateways) for details.
        """
        return pulumi.get(self, "public_ip_address_id")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The ID of the Subnet.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class ApplicationGatewayFrontendPort(dict):
    def __init__(__self__, *,
                 name: str,
                 port: int,
                 id: Optional[str] = None):
        """
        :param str name: The name of the Frontend Port.
        :param int port: The port used for this Frontend Port.
        :param str id: The ID of the Rewrite Rule Set
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Frontend Port.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port used for this Frontend Port.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Rewrite Rule Set
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ApplicationGatewayGatewayIpConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayGatewayIpConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayGatewayIpConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayGatewayIpConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 subnet_id: str,
                 id: Optional[str] = None):
        """
        :param str name: The Name of this Gateway IP Configuration.
        :param str subnet_id: The ID of the Subnet which the Application Gateway should be connected to.
        :param str id: The ID of the Rewrite Rule Set
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subnet_id", subnet_id)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Name of this Gateway IP Configuration.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The ID of the Subnet which the Application Gateway should be connected to.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Rewrite Rule Set
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ApplicationGatewayHttpListener(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frontendIpConfigurationName":
            suggest = "frontend_ip_configuration_name"
        elif key == "frontendPortName":
            suggest = "frontend_port_name"
        elif key == "customErrorConfigurations":
            suggest = "custom_error_configurations"
        elif key == "firewallPolicyId":
            suggest = "firewall_policy_id"
        elif key == "frontendIpConfigurationId":
            suggest = "frontend_ip_configuration_id"
        elif key == "frontendPortId":
            suggest = "frontend_port_id"
        elif key == "hostName":
            suggest = "host_name"
        elif key == "hostNames":
            suggest = "host_names"
        elif key == "requireSni":
            suggest = "require_sni"
        elif key == "sslCertificateId":
            suggest = "ssl_certificate_id"
        elif key == "sslCertificateName":
            suggest = "ssl_certificate_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayHttpListener. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayHttpListener.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayHttpListener.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frontend_ip_configuration_name: str,
                 frontend_port_name: str,
                 name: str,
                 protocol: str,
                 custom_error_configurations: Optional[Sequence['outputs.ApplicationGatewayHttpListenerCustomErrorConfiguration']] = None,
                 firewall_policy_id: Optional[str] = None,
                 frontend_ip_configuration_id: Optional[str] = None,
                 frontend_port_id: Optional[str] = None,
                 host_name: Optional[str] = None,
                 host_names: Optional[Sequence[str]] = None,
                 id: Optional[str] = None,
                 require_sni: Optional[bool] = None,
                 ssl_certificate_id: Optional[str] = None,
                 ssl_certificate_name: Optional[str] = None):
        """
        :param str frontend_ip_configuration_name: The Name of the Frontend IP Configuration used for this HTTP Listener.
        :param str frontend_port_name: The Name of the Frontend Port use for this HTTP Listener.
        :param str name: The Name of the HTTP Listener.
        :param str protocol: The Protocol to use for this HTTP Listener. Possible values are `Http` and `Https`.
        :param Sequence['ApplicationGatewayHttpListenerCustomErrorConfigurationArgs'] custom_error_configurations: One or more `custom_error_configuration` blocks as defined below.
        :param str firewall_policy_id: The ID of the Web Application Firewall Policy which should be used as a HTTP Listener.
        :param str frontend_ip_configuration_id: The ID of the associated Frontend Configuration.
        :param str frontend_port_id: The ID of the associated Frontend Port.
        :param str host_name: The Hostname which should be used for this HTTP Listener. Setting this value changes Listener Type to 'Multi site'.
        :param Sequence[str] host_names: A list of Hostname(s) should be used for this HTTP Listener. It allows special wildcard characters.
        :param str id: The ID of the Rewrite Rule Set
        :param bool require_sni: Should Server Name Indication be Required? Defaults to `false`.
        :param str ssl_certificate_id: The ID of the associated SSL Certificate.
        :param str ssl_certificate_name: The name of the associated SSL Certificate which should be used for this HTTP Listener.
        """
        pulumi.set(__self__, "frontend_ip_configuration_name", frontend_ip_configuration_name)
        pulumi.set(__self__, "frontend_port_name", frontend_port_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "protocol", protocol)
        if custom_error_configurations is not None:
            pulumi.set(__self__, "custom_error_configurations", custom_error_configurations)
        if firewall_policy_id is not None:
            pulumi.set(__self__, "firewall_policy_id", firewall_policy_id)
        if frontend_ip_configuration_id is not None:
            pulumi.set(__self__, "frontend_ip_configuration_id", frontend_ip_configuration_id)
        if frontend_port_id is not None:
            pulumi.set(__self__, "frontend_port_id", frontend_port_id)
        if host_name is not None:
            pulumi.set(__self__, "host_name", host_name)
        if host_names is not None:
            pulumi.set(__self__, "host_names", host_names)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if require_sni is not None:
            pulumi.set(__self__, "require_sni", require_sni)
        if ssl_certificate_id is not None:
            pulumi.set(__self__, "ssl_certificate_id", ssl_certificate_id)
        if ssl_certificate_name is not None:
            pulumi.set(__self__, "ssl_certificate_name", ssl_certificate_name)

    @property
    @pulumi.getter(name="frontendIpConfigurationName")
    def frontend_ip_configuration_name(self) -> str:
        """
        The Name of the Frontend IP Configuration used for this HTTP Listener.
        """
        return pulumi.get(self, "frontend_ip_configuration_name")

    @property
    @pulumi.getter(name="frontendPortName")
    def frontend_port_name(self) -> str:
        """
        The Name of the Frontend Port use for this HTTP Listener.
        """
        return pulumi.get(self, "frontend_port_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Name of the HTTP Listener.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The Protocol to use for this HTTP Listener. Possible values are `Http` and `Https`.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="customErrorConfigurations")
    def custom_error_configurations(self) -> Optional[Sequence['outputs.ApplicationGatewayHttpListenerCustomErrorConfiguration']]:
        """
        One or more `custom_error_configuration` blocks as defined below.
        """
        return pulumi.get(self, "custom_error_configurations")

    @property
    @pulumi.getter(name="firewallPolicyId")
    def firewall_policy_id(self) -> Optional[str]:
        """
        The ID of the Web Application Firewall Policy which should be used as a HTTP Listener.
        """
        return pulumi.get(self, "firewall_policy_id")

    @property
    @pulumi.getter(name="frontendIpConfigurationId")
    def frontend_ip_configuration_id(self) -> Optional[str]:
        """
        The ID of the associated Frontend Configuration.
        """
        return pulumi.get(self, "frontend_ip_configuration_id")

    @property
    @pulumi.getter(name="frontendPortId")
    def frontend_port_id(self) -> Optional[str]:
        """
        The ID of the associated Frontend Port.
        """
        return pulumi.get(self, "frontend_port_id")

    @property
    @pulumi.getter(name="hostName")
    def host_name(self) -> Optional[str]:
        """
        The Hostname which should be used for this HTTP Listener. Setting this value changes Listener Type to 'Multi site'.
        """
        return pulumi.get(self, "host_name")

    @property
    @pulumi.getter(name="hostNames")
    def host_names(self) -> Optional[Sequence[str]]:
        """
        A list of Hostname(s) should be used for this HTTP Listener. It allows special wildcard characters.
        """
        return pulumi.get(self, "host_names")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Rewrite Rule Set
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="requireSni")
    def require_sni(self) -> Optional[bool]:
        """
        Should Server Name Indication be Required? Defaults to `false`.
        """
        return pulumi.get(self, "require_sni")

    @property
    @pulumi.getter(name="sslCertificateId")
    def ssl_certificate_id(self) -> Optional[str]:
        """
        The ID of the associated SSL Certificate.
        """
        return pulumi.get(self, "ssl_certificate_id")

    @property
    @pulumi.getter(name="sslCertificateName")
    def ssl_certificate_name(self) -> Optional[str]:
        """
        The name of the associated SSL Certificate which should be used for this HTTP Listener.
        """
        return pulumi.get(self, "ssl_certificate_name")


@pulumi.output_type
class ApplicationGatewayHttpListenerCustomErrorConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customErrorPageUrl":
            suggest = "custom_error_page_url"
        elif key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayHttpListenerCustomErrorConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayHttpListenerCustomErrorConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayHttpListenerCustomErrorConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_error_page_url: str,
                 status_code: str,
                 id: Optional[str] = None):
        """
        :param str custom_error_page_url: Error page URL of the application gateway customer error.
        :param str status_code: Status code of the application gateway customer error. Possible values are `HttpStatus403` and `HttpStatus502`
        :param str id: The ID of the Rewrite Rule Set
        """
        pulumi.set(__self__, "custom_error_page_url", custom_error_page_url)
        pulumi.set(__self__, "status_code", status_code)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="customErrorPageUrl")
    def custom_error_page_url(self) -> str:
        """
        Error page URL of the application gateway customer error.
        """
        return pulumi.get(self, "custom_error_page_url")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> str:
        """
        Status code of the application gateway customer error. Possible values are `HttpStatus403` and `HttpStatus502`
        """
        return pulumi.get(self, "status_code")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Rewrite Rule Set
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ApplicationGatewayIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_ids: str,
                 type: Optional[str] = None):
        """
        :param str identity_ids: Specifies a list with a single user managed identity id to be assigned to the Application Gateway.
        :param str type: The Managed Service Identity Type of this Application Gateway. The only possible value is `UserAssigned`. Defaults to `UserAssigned`.
        """
        pulumi.set(__self__, "identity_ids", identity_ids)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> str:
        """
        Specifies a list with a single user managed identity id to be assigned to the Application Gateway.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The Managed Service Identity Type of this Application Gateway. The only possible value is `UserAssigned`. Defaults to `UserAssigned`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ApplicationGatewayProbe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "unhealthyThreshold":
            suggest = "unhealthy_threshold"
        elif key == "minimumServers":
            suggest = "minimum_servers"
        elif key == "pickHostNameFromBackendHttpSettings":
            suggest = "pick_host_name_from_backend_http_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayProbe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayProbe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayProbe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interval: int,
                 name: str,
                 path: str,
                 protocol: str,
                 timeout: int,
                 unhealthy_threshold: int,
                 host: Optional[str] = None,
                 id: Optional[str] = None,
                 match: Optional['outputs.ApplicationGatewayProbeMatch'] = None,
                 minimum_servers: Optional[int] = None,
                 pick_host_name_from_backend_http_settings: Optional[bool] = None,
                 port: Optional[int] = None):
        """
        :param int interval: The Interval between two consecutive probes in seconds. Possible values range from 1 second to a maximum of 86,400 seconds.
        :param str name: The Name of the Probe.
        :param str path: The Path used for this Probe.
        :param str protocol: The Protocol used for this Probe. Possible values are `Http` and `Https`.
        :param int timeout: The Timeout used for this Probe, which indicates when a probe becomes unhealthy. Possible values range from 1 second to a maximum of 86,400 seconds.
        :param int unhealthy_threshold: The Unhealthy Threshold for this Probe, which indicates the amount of retries which should be attempted before a node is deemed unhealthy. Possible values are from 1 - 20 seconds.
        :param str host: The Hostname used for this Probe. If the Application Gateway is configured for a single site, by default the Host name should be specified as ‘127.0.0.1’, unless otherwise configured in custom probe. Cannot be set if `pick_host_name_from_backend_http_settings` is set to `true`.
        :param str id: The ID of the Rewrite Rule Set
        :param 'ApplicationGatewayProbeMatchArgs' match: A `match` block as defined above.
        :param int minimum_servers: The minimum number of servers that are always marked as healthy. Defaults to `0`.
        :param bool pick_host_name_from_backend_http_settings: Whether the host header should be picked from the backend http settings. Defaults to `false`.
        :param int port: Custom port which will be used for probing the backend servers. The valid value ranges from 1 to 65535. In case not set, port from http settings will be used. This property is valid for Standard_v2 and WAF_v2 only.
        """
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if minimum_servers is not None:
            pulumi.set(__self__, "minimum_servers", minimum_servers)
        if pick_host_name_from_backend_http_settings is not None:
            pulumi.set(__self__, "pick_host_name_from_backend_http_settings", pick_host_name_from_backend_http_settings)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def interval(self) -> int:
        """
        The Interval between two consecutive probes in seconds. Possible values range from 1 second to a maximum of 86,400 seconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Name of the Probe.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The Path used for this Probe.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The Protocol used for this Probe. Possible values are `Http` and `Https`.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def timeout(self) -> int:
        """
        The Timeout used for this Probe, which indicates when a probe becomes unhealthy. Possible values range from 1 second to a maximum of 86,400 seconds.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> int:
        """
        The Unhealthy Threshold for this Probe, which indicates the amount of retries which should be attempted before a node is deemed unhealthy. Possible values are from 1 - 20 seconds.
        """
        return pulumi.get(self, "unhealthy_threshold")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The Hostname used for this Probe. If the Application Gateway is configured for a single site, by default the Host name should be specified as ‘127.0.0.1’, unless otherwise configured in custom probe. Cannot be set if `pick_host_name_from_backend_http_settings` is set to `true`.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Rewrite Rule Set
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def match(self) -> Optional['outputs.ApplicationGatewayProbeMatch']:
        """
        A `match` block as defined above.
        """
        return pulumi.get(self, "match")

    @property
    @pulumi.getter(name="minimumServers")
    def minimum_servers(self) -> Optional[int]:
        """
        The minimum number of servers that are always marked as healthy. Defaults to `0`.
        """
        return pulumi.get(self, "minimum_servers")

    @property
    @pulumi.getter(name="pickHostNameFromBackendHttpSettings")
    def pick_host_name_from_backend_http_settings(self) -> Optional[bool]:
        """
        Whether the host header should be picked from the backend http settings. Defaults to `false`.
        """
        return pulumi.get(self, "pick_host_name_from_backend_http_settings")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Custom port which will be used for probing the backend servers. The valid value ranges from 1 to 65535. In case not set, port from http settings will be used. This property is valid for Standard_v2 and WAF_v2 only.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class ApplicationGatewayProbeMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusCodes":
            suggest = "status_codes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayProbeMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayProbeMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayProbeMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 body: Optional[str] = None,
                 status_codes: Optional[Sequence[str]] = None):
        """
        :param str body: A snippet from the Response Body which must be present in the Response..
        :param Sequence[str] status_codes: A list of allowed status codes for this Health Probe.
        """
        if body is not None:
            pulumi.set(__self__, "body", body)
        if status_codes is not None:
            pulumi.set(__self__, "status_codes", status_codes)

    @property
    @pulumi.getter
    def body(self) -> Optional[str]:
        """
        A snippet from the Response Body which must be present in the Response..
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter(name="statusCodes")
    def status_codes(self) -> Optional[Sequence[str]]:
        """
        A list of allowed status codes for this Health Probe.
        """
        return pulumi.get(self, "status_codes")


@pulumi.output_type
class ApplicationGatewayRedirectConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "redirectType":
            suggest = "redirect_type"
        elif key == "includePath":
            suggest = "include_path"
        elif key == "includeQueryString":
            suggest = "include_query_string"
        elif key == "targetListenerId":
            suggest = "target_listener_id"
        elif key == "targetListenerName":
            suggest = "target_listener_name"
        elif key == "targetUrl":
            suggest = "target_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayRedirectConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayRedirectConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayRedirectConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 redirect_type: str,
                 id: Optional[str] = None,
                 include_path: Optional[bool] = None,
                 include_query_string: Optional[bool] = None,
                 target_listener_id: Optional[str] = None,
                 target_listener_name: Optional[str] = None,
                 target_url: Optional[str] = None):
        """
        :param str name: Unique name of the redirect configuration block
        :param str redirect_type: The type of redirect. Possible values are `Permanent`, `Temporary`, `Found` and `SeeOther`
        :param str id: The ID of the Rewrite Rule Set
        :param bool include_path: Whether or not to include the path in the redirected Url. Defaults to `false`
        :param bool include_query_string: Whether or not to include the query string in the redirected Url. Default to `false`
        :param str target_listener_name: The name of the listener to redirect to. Cannot be set if `target_url` is set.
        :param str target_url: The Url to redirect the request to. Cannot be set if `target_listener_name` is set.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "redirect_type", redirect_type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if include_path is not None:
            pulumi.set(__self__, "include_path", include_path)
        if include_query_string is not None:
            pulumi.set(__self__, "include_query_string", include_query_string)
        if target_listener_id is not None:
            pulumi.set(__self__, "target_listener_id", target_listener_id)
        if target_listener_name is not None:
            pulumi.set(__self__, "target_listener_name", target_listener_name)
        if target_url is not None:
            pulumi.set(__self__, "target_url", target_url)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique name of the redirect configuration block
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="redirectType")
    def redirect_type(self) -> str:
        """
        The type of redirect. Possible values are `Permanent`, `Temporary`, `Found` and `SeeOther`
        """
        return pulumi.get(self, "redirect_type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Rewrite Rule Set
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="includePath")
    def include_path(self) -> Optional[bool]:
        """
        Whether or not to include the path in the redirected Url. Defaults to `false`
        """
        return pulumi.get(self, "include_path")

    @property
    @pulumi.getter(name="includeQueryString")
    def include_query_string(self) -> Optional[bool]:
        """
        Whether or not to include the query string in the redirected Url. Default to `false`
        """
        return pulumi.get(self, "include_query_string")

    @property
    @pulumi.getter(name="targetListenerId")
    def target_listener_id(self) -> Optional[str]:
        return pulumi.get(self, "target_listener_id")

    @property
    @pulumi.getter(name="targetListenerName")
    def target_listener_name(self) -> Optional[str]:
        """
        The name of the listener to redirect to. Cannot be set if `target_url` is set.
        """
        return pulumi.get(self, "target_listener_name")

    @property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> Optional[str]:
        """
        The Url to redirect the request to. Cannot be set if `target_listener_name` is set.
        """
        return pulumi.get(self, "target_url")


@pulumi.output_type
class ApplicationGatewayRequestRoutingRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpListenerName":
            suggest = "http_listener_name"
        elif key == "ruleType":
            suggest = "rule_type"
        elif key == "backendAddressPoolId":
            suggest = "backend_address_pool_id"
        elif key == "backendAddressPoolName":
            suggest = "backend_address_pool_name"
        elif key == "backendHttpSettingsId":
            suggest = "backend_http_settings_id"
        elif key == "backendHttpSettingsName":
            suggest = "backend_http_settings_name"
        elif key == "httpListenerId":
            suggest = "http_listener_id"
        elif key == "redirectConfigurationId":
            suggest = "redirect_configuration_id"
        elif key == "redirectConfigurationName":
            suggest = "redirect_configuration_name"
        elif key == "rewriteRuleSetId":
            suggest = "rewrite_rule_set_id"
        elif key == "rewriteRuleSetName":
            suggest = "rewrite_rule_set_name"
        elif key == "urlPathMapId":
            suggest = "url_path_map_id"
        elif key == "urlPathMapName":
            suggest = "url_path_map_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayRequestRoutingRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayRequestRoutingRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayRequestRoutingRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_listener_name: str,
                 name: str,
                 rule_type: str,
                 backend_address_pool_id: Optional[str] = None,
                 backend_address_pool_name: Optional[str] = None,
                 backend_http_settings_id: Optional[str] = None,
                 backend_http_settings_name: Optional[str] = None,
                 http_listener_id: Optional[str] = None,
                 id: Optional[str] = None,
                 redirect_configuration_id: Optional[str] = None,
                 redirect_configuration_name: Optional[str] = None,
                 rewrite_rule_set_id: Optional[str] = None,
                 rewrite_rule_set_name: Optional[str] = None,
                 url_path_map_id: Optional[str] = None,
                 url_path_map_name: Optional[str] = None):
        """
        :param str http_listener_name: The Name of the HTTP Listener which should be used for this Routing Rule.
        :param str name: The Name of this Request Routing Rule.
        :param str rule_type: The Type of Routing that should be used for this Rule. Possible values are `Basic` and `PathBasedRouting`.
        :param str backend_address_pool_id: The ID of the associated Backend Address Pool.
        :param str backend_address_pool_name: The Name of the Backend Address Pool which should be used for this Routing Rule. Cannot be set if `redirect_configuration_name` is set.
        :param str backend_http_settings_id: The ID of the associated Backend HTTP Settings Configuration.
        :param str backend_http_settings_name: The Name of the Backend HTTP Settings Collection which should be used for this Routing Rule. Cannot be set if `redirect_configuration_name` is set.
        :param str http_listener_id: The ID of the associated HTTP Listener.
        :param str id: The ID of the Rewrite Rule Set
        :param str redirect_configuration_id: The ID of the associated Redirect Configuration.
        :param str redirect_configuration_name: The Name of the Redirect Configuration which should be used for this Routing Rule. Cannot be set if either `backend_address_pool_name` or `backend_http_settings_name` is set.
        :param str rewrite_rule_set_id: The ID of the associated Rewrite Rule Set.
        :param str rewrite_rule_set_name: The Name of the Rewrite Rule Set which should be used for this Routing Rule. Only valid for v2 SKUs.
        :param str url_path_map_id: The ID of the associated URL Path Map.
        :param str url_path_map_name: The Name of the URL Path Map which should be associated with this Routing Rule.
        """
        pulumi.set(__self__, "http_listener_name", http_listener_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "rule_type", rule_type)
        if backend_address_pool_id is not None:
            pulumi.set(__self__, "backend_address_pool_id", backend_address_pool_id)
        if backend_address_pool_name is not None:
            pulumi.set(__self__, "backend_address_pool_name", backend_address_pool_name)
        if backend_http_settings_id is not None:
            pulumi.set(__self__, "backend_http_settings_id", backend_http_settings_id)
        if backend_http_settings_name is not None:
            pulumi.set(__self__, "backend_http_settings_name", backend_http_settings_name)
        if http_listener_id is not None:
            pulumi.set(__self__, "http_listener_id", http_listener_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if redirect_configuration_id is not None:
            pulumi.set(__self__, "redirect_configuration_id", redirect_configuration_id)
        if redirect_configuration_name is not None:
            pulumi.set(__self__, "redirect_configuration_name", redirect_configuration_name)
        if rewrite_rule_set_id is not None:
            pulumi.set(__self__, "rewrite_rule_set_id", rewrite_rule_set_id)
        if rewrite_rule_set_name is not None:
            pulumi.set(__self__, "rewrite_rule_set_name", rewrite_rule_set_name)
        if url_path_map_id is not None:
            pulumi.set(__self__, "url_path_map_id", url_path_map_id)
        if url_path_map_name is not None:
            pulumi.set(__self__, "url_path_map_name", url_path_map_name)

    @property
    @pulumi.getter(name="httpListenerName")
    def http_listener_name(self) -> str:
        """
        The Name of the HTTP Listener which should be used for this Routing Rule.
        """
        return pulumi.get(self, "http_listener_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Name of this Request Routing Rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> str:
        """
        The Type of Routing that should be used for this Rule. Possible values are `Basic` and `PathBasedRouting`.
        """
        return pulumi.get(self, "rule_type")

    @property
    @pulumi.getter(name="backendAddressPoolId")
    def backend_address_pool_id(self) -> Optional[str]:
        """
        The ID of the associated Backend Address Pool.
        """
        return pulumi.get(self, "backend_address_pool_id")

    @property
    @pulumi.getter(name="backendAddressPoolName")
    def backend_address_pool_name(self) -> Optional[str]:
        """
        The Name of the Backend Address Pool which should be used for this Routing Rule. Cannot be set if `redirect_configuration_name` is set.
        """
        return pulumi.get(self, "backend_address_pool_name")

    @property
    @pulumi.getter(name="backendHttpSettingsId")
    def backend_http_settings_id(self) -> Optional[str]:
        """
        The ID of the associated Backend HTTP Settings Configuration.
        """
        return pulumi.get(self, "backend_http_settings_id")

    @property
    @pulumi.getter(name="backendHttpSettingsName")
    def backend_http_settings_name(self) -> Optional[str]:
        """
        The Name of the Backend HTTP Settings Collection which should be used for this Routing Rule. Cannot be set if `redirect_configuration_name` is set.
        """
        return pulumi.get(self, "backend_http_settings_name")

    @property
    @pulumi.getter(name="httpListenerId")
    def http_listener_id(self) -> Optional[str]:
        """
        The ID of the associated HTTP Listener.
        """
        return pulumi.get(self, "http_listener_id")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Rewrite Rule Set
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="redirectConfigurationId")
    def redirect_configuration_id(self) -> Optional[str]:
        """
        The ID of the associated Redirect Configuration.
        """
        return pulumi.get(self, "redirect_configuration_id")

    @property
    @pulumi.getter(name="redirectConfigurationName")
    def redirect_configuration_name(self) -> Optional[str]:
        """
        The Name of the Redirect Configuration which should be used for this Routing Rule. Cannot be set if either `backend_address_pool_name` or `backend_http_settings_name` is set.
        """
        return pulumi.get(self, "redirect_configuration_name")

    @property
    @pulumi.getter(name="rewriteRuleSetId")
    def rewrite_rule_set_id(self) -> Optional[str]:
        """
        The ID of the associated Rewrite Rule Set.
        """
        return pulumi.get(self, "rewrite_rule_set_id")

    @property
    @pulumi.getter(name="rewriteRuleSetName")
    def rewrite_rule_set_name(self) -> Optional[str]:
        """
        The Name of the Rewrite Rule Set which should be used for this Routing Rule. Only valid for v2 SKUs.
        """
        return pulumi.get(self, "rewrite_rule_set_name")

    @property
    @pulumi.getter(name="urlPathMapId")
    def url_path_map_id(self) -> Optional[str]:
        """
        The ID of the associated URL Path Map.
        """
        return pulumi.get(self, "url_path_map_id")

    @property
    @pulumi.getter(name="urlPathMapName")
    def url_path_map_name(self) -> Optional[str]:
        """
        The Name of the URL Path Map which should be associated with this Routing Rule.
        """
        return pulumi.get(self, "url_path_map_name")


@pulumi.output_type
class ApplicationGatewayRewriteRuleSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rewriteRules":
            suggest = "rewrite_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayRewriteRuleSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayRewriteRuleSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayRewriteRuleSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 id: Optional[str] = None,
                 rewrite_rules: Optional[Sequence['outputs.ApplicationGatewayRewriteRuleSetRewriteRule']] = None):
        """
        :param str name: Unique name of the rewrite rule set block
        :param str id: The ID of the Rewrite Rule Set
        :param Sequence['ApplicationGatewayRewriteRuleSetRewriteRuleArgs'] rewrite_rules: One or more `rewrite_rule` blocks as defined above.
        """
        pulumi.set(__self__, "name", name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if rewrite_rules is not None:
            pulumi.set(__self__, "rewrite_rules", rewrite_rules)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique name of the rewrite rule set block
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Rewrite Rule Set
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="rewriteRules")
    def rewrite_rules(self) -> Optional[Sequence['outputs.ApplicationGatewayRewriteRuleSetRewriteRule']]:
        """
        One or more `rewrite_rule` blocks as defined above.
        """
        return pulumi.get(self, "rewrite_rules")


@pulumi.output_type
class ApplicationGatewayRewriteRuleSetRewriteRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleSequence":
            suggest = "rule_sequence"
        elif key == "requestHeaderConfigurations":
            suggest = "request_header_configurations"
        elif key == "responseHeaderConfigurations":
            suggest = "response_header_configurations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayRewriteRuleSetRewriteRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayRewriteRuleSetRewriteRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayRewriteRuleSetRewriteRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 rule_sequence: int,
                 conditions: Optional[Sequence['outputs.ApplicationGatewayRewriteRuleSetRewriteRuleCondition']] = None,
                 request_header_configurations: Optional[Sequence['outputs.ApplicationGatewayRewriteRuleSetRewriteRuleRequestHeaderConfiguration']] = None,
                 response_header_configurations: Optional[Sequence['outputs.ApplicationGatewayRewriteRuleSetRewriteRuleResponseHeaderConfiguration']] = None,
                 url: Optional['outputs.ApplicationGatewayRewriteRuleSetRewriteRuleUrl'] = None):
        """
        :param str name: Unique name of the rewrite rule block
        :param int rule_sequence: Rule sequence of the rewrite rule that determines the order of execution in a set.
        :param Sequence['ApplicationGatewayRewriteRuleSetRewriteRuleConditionArgs'] conditions: One or more `condition` blocks as defined above.
        :param Sequence['ApplicationGatewayRewriteRuleSetRewriteRuleRequestHeaderConfigurationArgs'] request_header_configurations: One or more `request_header_configuration` blocks as defined above.
        :param Sequence['ApplicationGatewayRewriteRuleSetRewriteRuleResponseHeaderConfigurationArgs'] response_header_configurations: One or more `response_header_configuration` blocks as defined above.
        :param 'ApplicationGatewayRewriteRuleSetRewriteRuleUrlArgs' url: One `url` block as defined above
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "rule_sequence", rule_sequence)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if request_header_configurations is not None:
            pulumi.set(__self__, "request_header_configurations", request_header_configurations)
        if response_header_configurations is not None:
            pulumi.set(__self__, "response_header_configurations", response_header_configurations)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique name of the rewrite rule block
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="ruleSequence")
    def rule_sequence(self) -> int:
        """
        Rule sequence of the rewrite rule that determines the order of execution in a set.
        """
        return pulumi.get(self, "rule_sequence")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.ApplicationGatewayRewriteRuleSetRewriteRuleCondition']]:
        """
        One or more `condition` blocks as defined above.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="requestHeaderConfigurations")
    def request_header_configurations(self) -> Optional[Sequence['outputs.ApplicationGatewayRewriteRuleSetRewriteRuleRequestHeaderConfiguration']]:
        """
        One or more `request_header_configuration` blocks as defined above.
        """
        return pulumi.get(self, "request_header_configurations")

    @property
    @pulumi.getter(name="responseHeaderConfigurations")
    def response_header_configurations(self) -> Optional[Sequence['outputs.ApplicationGatewayRewriteRuleSetRewriteRuleResponseHeaderConfiguration']]:
        """
        One or more `response_header_configuration` blocks as defined above.
        """
        return pulumi.get(self, "response_header_configurations")

    @property
    @pulumi.getter
    def url(self) -> Optional['outputs.ApplicationGatewayRewriteRuleSetRewriteRuleUrl']:
        """
        One `url` block as defined above
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class ApplicationGatewayRewriteRuleSetRewriteRuleCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ignoreCase":
            suggest = "ignore_case"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayRewriteRuleSetRewriteRuleCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayRewriteRuleSetRewriteRuleCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayRewriteRuleSetRewriteRuleCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pattern: str,
                 variable: str,
                 ignore_case: Optional[bool] = None,
                 negate: Optional[bool] = None):
        """
        :param str pattern: The pattern, either fixed string or regular expression, that evaluates the truthfulness of the condition.
        :param str variable: The [variable](https://docs.microsoft.com/en-us/azure/application-gateway/rewrite-http-headers#server-variables) of the condition.
        :param bool ignore_case: Perform a case in-sensitive comparison. Defaults to `false`
        :param bool negate: Negate the result of the condition evaluation. Defaults to `false`
        """
        pulumi.set(__self__, "pattern", pattern)
        pulumi.set(__self__, "variable", variable)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)

    @property
    @pulumi.getter
    def pattern(self) -> str:
        """
        The pattern, either fixed string or regular expression, that evaluates the truthfulness of the condition.
        """
        return pulumi.get(self, "pattern")

    @property
    @pulumi.getter
    def variable(self) -> str:
        """
        The [variable](https://docs.microsoft.com/en-us/azure/application-gateway/rewrite-http-headers#server-variables) of the condition.
        """
        return pulumi.get(self, "variable")

    @property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[bool]:
        """
        Perform a case in-sensitive comparison. Defaults to `false`
        """
        return pulumi.get(self, "ignore_case")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Negate the result of the condition evaluation. Defaults to `false`
        """
        return pulumi.get(self, "negate")


@pulumi.output_type
class ApplicationGatewayRewriteRuleSetRewriteRuleRequestHeaderConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerName":
            suggest = "header_name"
        elif key == "headerValue":
            suggest = "header_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayRewriteRuleSetRewriteRuleRequestHeaderConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayRewriteRuleSetRewriteRuleRequestHeaderConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayRewriteRuleSetRewriteRuleRequestHeaderConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_name: str,
                 header_value: str):
        """
        :param str header_name: Header name of the header configuration.
        :param str header_value: Header value of the header configuration. To delete a request header set this property to an empty string.
        """
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "header_value", header_value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        Header name of the header configuration.
        """
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> str:
        """
        Header value of the header configuration. To delete a request header set this property to an empty string.
        """
        return pulumi.get(self, "header_value")


@pulumi.output_type
class ApplicationGatewayRewriteRuleSetRewriteRuleResponseHeaderConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerName":
            suggest = "header_name"
        elif key == "headerValue":
            suggest = "header_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayRewriteRuleSetRewriteRuleResponseHeaderConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayRewriteRuleSetRewriteRuleResponseHeaderConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayRewriteRuleSetRewriteRuleResponseHeaderConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_name: str,
                 header_value: str):
        """
        :param str header_name: Header name of the header configuration.
        :param str header_value: Header value of the header configuration. To delete a response header set this property to an empty string.
        """
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "header_value", header_value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        Header name of the header configuration.
        """
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> str:
        """
        Header value of the header configuration. To delete a response header set this property to an empty string.
        """
        return pulumi.get(self, "header_value")


@pulumi.output_type
class ApplicationGatewayRewriteRuleSetRewriteRuleUrl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryString":
            suggest = "query_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayRewriteRuleSetRewriteRuleUrl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayRewriteRuleSetRewriteRuleUrl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayRewriteRuleSetRewriteRuleUrl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: Optional[str] = None,
                 query_string: Optional[str] = None,
                 reroute: Optional[bool] = None):
        """
        :param str path: The URL path to rewrite.
        :param str query_string: The query string to rewrite.
        :param bool reroute: Whether the URL path map should be reevaluated after this rewrite has been applied. [More info on rewrite configutation](https://docs.microsoft.com/en-us/azure/application-gateway/rewrite-http-headers-url#rewrite-configuration)
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if reroute is not None:
            pulumi.set(__self__, "reroute", reroute)

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The URL path to rewrite.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[str]:
        """
        The query string to rewrite.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter
    def reroute(self) -> Optional[bool]:
        """
        Whether the URL path map should be reevaluated after this rewrite has been applied. [More info on rewrite configutation](https://docs.microsoft.com/en-us/azure/application-gateway/rewrite-http-headers-url#rewrite-configuration)
        """
        return pulumi.get(self, "reroute")


@pulumi.output_type
class ApplicationGatewaySku(dict):
    def __init__(__self__, *,
                 name: str,
                 tier: str,
                 capacity: Optional[int] = None):
        """
        :param str name: The Name of the SKU to use for this Application Gateway. Possible values are `Standard_Small`, `Standard_Medium`, `Standard_Large`, `Standard_v2`, `WAF_Medium`, `WAF_Large`, and `WAF_v2`.
        :param str tier: The Tier of the SKU to use for this Application Gateway. Possible values are `Standard`, `Standard_v2`, `WAF` and `WAF_v2`.
        :param int capacity: The Capacity of the SKU to use for this Application Gateway. When using a V1 SKU this value must be between 1 and 32, and 1 to 125 for a V2 SKU. This property is optional if `autoscale_configuration` is set.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "tier", tier)
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Name of the SKU to use for this Application Gateway. Possible values are `Standard_Small`, `Standard_Medium`, `Standard_Large`, `Standard_v2`, `WAF_Medium`, `WAF_Large`, and `WAF_v2`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tier(self) -> str:
        """
        The Tier of the SKU to use for this Application Gateway. Possible values are `Standard`, `Standard_v2`, `WAF` and `WAF_v2`.
        """
        return pulumi.get(self, "tier")

    @property
    @pulumi.getter
    def capacity(self) -> Optional[int]:
        """
        The Capacity of the SKU to use for this Application Gateway. When using a V1 SKU this value must be between 1 and 32, and 1 to 125 for a V2 SKU. This property is optional if `autoscale_configuration` is set.
        """
        return pulumi.get(self, "capacity")


@pulumi.output_type
class ApplicationGatewaySslCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVaultSecretId":
            suggest = "key_vault_secret_id"
        elif key == "publicCertData":
            suggest = "public_cert_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewaySslCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewaySslCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewaySslCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 data: Optional[str] = None,
                 id: Optional[str] = None,
                 key_vault_secret_id: Optional[str] = None,
                 password: Optional[str] = None,
                 public_cert_data: Optional[str] = None):
        """
        :param str name: The Name of the SSL certificate that is unique within this Application Gateway
        :param str data: PFX certificate. Required if `key_vault_secret_id` is not set.
        :param str id: The ID of the Rewrite Rule Set
        :param str key_vault_secret_id: Secret Id of (base-64 encoded unencrypted pfx) `Secret` or `Certificate` object stored in Azure KeyVault. You need to enable soft delete for keyvault to use this feature. Required if `data` is not set.
        :param str password: Password for the pfx file specified in data.  Required if `data` is set.
        :param str public_cert_data: The Public Certificate Data associated with the SSL Certificate.
        """
        pulumi.set(__self__, "name", name)
        if data is not None:
            pulumi.set(__self__, "data", data)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if key_vault_secret_id is not None:
            pulumi.set(__self__, "key_vault_secret_id", key_vault_secret_id)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if public_cert_data is not None:
            pulumi.set(__self__, "public_cert_data", public_cert_data)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Name of the SSL certificate that is unique within this Application Gateway
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def data(self) -> Optional[str]:
        """
        PFX certificate. Required if `key_vault_secret_id` is not set.
        """
        return pulumi.get(self, "data")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Rewrite Rule Set
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="keyVaultSecretId")
    def key_vault_secret_id(self) -> Optional[str]:
        """
        Secret Id of (base-64 encoded unencrypted pfx) `Secret` or `Certificate` object stored in Azure KeyVault. You need to enable soft delete for keyvault to use this feature. Required if `data` is not set.
        """
        return pulumi.get(self, "key_vault_secret_id")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Password for the pfx file specified in data.  Required if `data` is set.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="publicCertData")
    def public_cert_data(self) -> Optional[str]:
        """
        The Public Certificate Data associated with the SSL Certificate.
        """
        return pulumi.get(self, "public_cert_data")


@pulumi.output_type
class ApplicationGatewaySslPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cipherSuites":
            suggest = "cipher_suites"
        elif key == "disabledProtocols":
            suggest = "disabled_protocols"
        elif key == "minProtocolVersion":
            suggest = "min_protocol_version"
        elif key == "policyName":
            suggest = "policy_name"
        elif key == "policyType":
            suggest = "policy_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewaySslPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewaySslPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewaySslPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cipher_suites: Optional[Sequence[str]] = None,
                 disabled_protocols: Optional[Sequence[str]] = None,
                 min_protocol_version: Optional[str] = None,
                 policy_name: Optional[str] = None,
                 policy_type: Optional[str] = None):
        """
        :param Sequence[str] cipher_suites: A List of accepted cipher suites. Possible values are: `TLS_DHE_DSS_WITH_AES_128_CBC_SHA`, `TLS_DHE_DSS_WITH_AES_128_CBC_SHA256`, `TLS_DHE_DSS_WITH_AES_256_CBC_SHA`, `TLS_DHE_DSS_WITH_AES_256_CBC_SHA256`, `TLS_DHE_RSA_WITH_AES_128_CBC_SHA`, `TLS_DHE_RSA_WITH_AES_128_GCM_SHA256`, `TLS_DHE_RSA_WITH_AES_256_CBC_SHA`, `TLS_DHE_RSA_WITH_AES_256_GCM_SHA384`, `TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA`, `TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256`, `TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256`, `TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA`, `TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384`, `TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384`, `TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA`, `TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256`, `TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA`, `TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384`, `TLS_RSA_WITH_3DES_EDE_CBC_SHA`, `TLS_RSA_WITH_AES_128_CBC_SHA`, `TLS_RSA_WITH_AES_128_CBC_SHA256`, `TLS_RSA_WITH_AES_128_GCM_SHA256`, `TLS_RSA_WITH_AES_256_CBC_SHA`, `TLS_RSA_WITH_AES_256_CBC_SHA256` and `TLS_RSA_WITH_AES_256_GCM_SHA384`.
        :param Sequence[str] disabled_protocols: A list of SSL Protocols which should be disabled on this Application Gateway. Possible values are `TLSv1_0`, `TLSv1_1` and `TLSv1_2`.
        :param str min_protocol_version: The minimal TLS version. Possible values are `TLSv1_0`, `TLSv1_1` and `TLSv1_2`.
        :param str policy_name: The Name of the Policy e.g AppGwSslPolicy20170401S. Required if `policy_type` is set to `Predefined`. Possible values can change over time and
               are published here https://docs.microsoft.com/en-us/azure/application-gateway/application-gateway-ssl-policy-overview. Not compatible with `disabled_protocols`.
        :param str policy_type: The Type of the Policy. Possible values are `Predefined` and `Custom`.
        """
        if cipher_suites is not None:
            pulumi.set(__self__, "cipher_suites", cipher_suites)
        if disabled_protocols is not None:
            pulumi.set(__self__, "disabled_protocols", disabled_protocols)
        if min_protocol_version is not None:
            pulumi.set(__self__, "min_protocol_version", min_protocol_version)
        if policy_name is not None:
            pulumi.set(__self__, "policy_name", policy_name)
        if policy_type is not None:
            pulumi.set(__self__, "policy_type", policy_type)

    @property
    @pulumi.getter(name="cipherSuites")
    def cipher_suites(self) -> Optional[Sequence[str]]:
        """
        A List of accepted cipher suites. Possible values are: `TLS_DHE_DSS_WITH_AES_128_CBC_SHA`, `TLS_DHE_DSS_WITH_AES_128_CBC_SHA256`, `TLS_DHE_DSS_WITH_AES_256_CBC_SHA`, `TLS_DHE_DSS_WITH_AES_256_CBC_SHA256`, `TLS_DHE_RSA_WITH_AES_128_CBC_SHA`, `TLS_DHE_RSA_WITH_AES_128_GCM_SHA256`, `TLS_DHE_RSA_WITH_AES_256_CBC_SHA`, `TLS_DHE_RSA_WITH_AES_256_GCM_SHA384`, `TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA`, `TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256`, `TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256`, `TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA`, `TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384`, `TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384`, `TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA`, `TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256`, `TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA`, `TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384`, `TLS_RSA_WITH_3DES_EDE_CBC_SHA`, `TLS_RSA_WITH_AES_128_CBC_SHA`, `TLS_RSA_WITH_AES_128_CBC_SHA256`, `TLS_RSA_WITH_AES_128_GCM_SHA256`, `TLS_RSA_WITH_AES_256_CBC_SHA`, `TLS_RSA_WITH_AES_256_CBC_SHA256` and `TLS_RSA_WITH_AES_256_GCM_SHA384`.
        """
        return pulumi.get(self, "cipher_suites")

    @property
    @pulumi.getter(name="disabledProtocols")
    def disabled_protocols(self) -> Optional[Sequence[str]]:
        """
        A list of SSL Protocols which should be disabled on this Application Gateway. Possible values are `TLSv1_0`, `TLSv1_1` and `TLSv1_2`.
        """
        return pulumi.get(self, "disabled_protocols")

    @property
    @pulumi.getter(name="minProtocolVersion")
    def min_protocol_version(self) -> Optional[str]:
        """
        The minimal TLS version. Possible values are `TLSv1_0`, `TLSv1_1` and `TLSv1_2`.
        """
        return pulumi.get(self, "min_protocol_version")

    @property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> Optional[str]:
        """
        The Name of the Policy e.g AppGwSslPolicy20170401S. Required if `policy_type` is set to `Predefined`. Possible values can change over time and
        are published here https://docs.microsoft.com/en-us/azure/application-gateway/application-gateway-ssl-policy-overview. Not compatible with `disabled_protocols`.
        """
        return pulumi.get(self, "policy_name")

    @property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> Optional[str]:
        """
        The Type of the Policy. Possible values are `Predefined` and `Custom`.
        """
        return pulumi.get(self, "policy_type")


@pulumi.output_type
class ApplicationGatewayTrustedRootCertificate(dict):
    def __init__(__self__, *,
                 data: str,
                 name: str,
                 id: Optional[str] = None):
        """
        :param str data: The contents of the Trusted Root Certificate which should be used.
        :param str name: The Name of the Trusted Root Certificate to use.
        :param str id: The ID of the Rewrite Rule Set
        """
        pulumi.set(__self__, "data", data)
        pulumi.set(__self__, "name", name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def data(self) -> str:
        """
        The contents of the Trusted Root Certificate which should be used.
        """
        return pulumi.get(self, "data")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Name of the Trusted Root Certificate to use.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Rewrite Rule Set
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ApplicationGatewayUrlPathMap(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pathRules":
            suggest = "path_rules"
        elif key == "defaultBackendAddressPoolId":
            suggest = "default_backend_address_pool_id"
        elif key == "defaultBackendAddressPoolName":
            suggest = "default_backend_address_pool_name"
        elif key == "defaultBackendHttpSettingsId":
            suggest = "default_backend_http_settings_id"
        elif key == "defaultBackendHttpSettingsName":
            suggest = "default_backend_http_settings_name"
        elif key == "defaultRedirectConfigurationId":
            suggest = "default_redirect_configuration_id"
        elif key == "defaultRedirectConfigurationName":
            suggest = "default_redirect_configuration_name"
        elif key == "defaultRewriteRuleSetId":
            suggest = "default_rewrite_rule_set_id"
        elif key == "defaultRewriteRuleSetName":
            suggest = "default_rewrite_rule_set_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayUrlPathMap. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayUrlPathMap.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayUrlPathMap.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 path_rules: Sequence['outputs.ApplicationGatewayUrlPathMapPathRule'],
                 default_backend_address_pool_id: Optional[str] = None,
                 default_backend_address_pool_name: Optional[str] = None,
                 default_backend_http_settings_id: Optional[str] = None,
                 default_backend_http_settings_name: Optional[str] = None,
                 default_redirect_configuration_id: Optional[str] = None,
                 default_redirect_configuration_name: Optional[str] = None,
                 default_rewrite_rule_set_id: Optional[str] = None,
                 default_rewrite_rule_set_name: Optional[str] = None,
                 id: Optional[str] = None):
        """
        :param str name: The Name of the URL Path Map.
        :param Sequence['ApplicationGatewayUrlPathMapPathRuleArgs'] path_rules: One or more `path_rule` blocks as defined above.
        :param str default_backend_address_pool_id: The ID of the Default Backend Address Pool.
        :param str default_backend_address_pool_name: The Name of the Default Backend Address Pool which should be used for this URL Path Map. Cannot be set if `default_redirect_configuration_name` is set.
        :param str default_backend_http_settings_id: The ID of the Default Backend HTTP Settings Collection.
        :param str default_backend_http_settings_name: The Name of the Default Backend HTTP Settings Collection which should be used for this URL Path Map. Cannot be set if `default_redirect_configuration_name` is set.
        :param str default_redirect_configuration_id: The ID of the Default Redirect Configuration.
        :param str default_redirect_configuration_name: The Name of the Default Redirect Configuration which should be used for this URL Path Map. Cannot be set if either `default_backend_address_pool_name` or `default_backend_http_settings_name` is set.
        :param str default_rewrite_rule_set_name: The Name of the Default Rewrite Rule Set which should be used for this URL Path Map. Only valid for v2 SKUs.
        :param str id: The ID of the Rewrite Rule Set
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path_rules", path_rules)
        if default_backend_address_pool_id is not None:
            pulumi.set(__self__, "default_backend_address_pool_id", default_backend_address_pool_id)
        if default_backend_address_pool_name is not None:
            pulumi.set(__self__, "default_backend_address_pool_name", default_backend_address_pool_name)
        if default_backend_http_settings_id is not None:
            pulumi.set(__self__, "default_backend_http_settings_id", default_backend_http_settings_id)
        if default_backend_http_settings_name is not None:
            pulumi.set(__self__, "default_backend_http_settings_name", default_backend_http_settings_name)
        if default_redirect_configuration_id is not None:
            pulumi.set(__self__, "default_redirect_configuration_id", default_redirect_configuration_id)
        if default_redirect_configuration_name is not None:
            pulumi.set(__self__, "default_redirect_configuration_name", default_redirect_configuration_name)
        if default_rewrite_rule_set_id is not None:
            pulumi.set(__self__, "default_rewrite_rule_set_id", default_rewrite_rule_set_id)
        if default_rewrite_rule_set_name is not None:
            pulumi.set(__self__, "default_rewrite_rule_set_name", default_rewrite_rule_set_name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Name of the URL Path Map.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="pathRules")
    def path_rules(self) -> Sequence['outputs.ApplicationGatewayUrlPathMapPathRule']:
        """
        One or more `path_rule` blocks as defined above.
        """
        return pulumi.get(self, "path_rules")

    @property
    @pulumi.getter(name="defaultBackendAddressPoolId")
    def default_backend_address_pool_id(self) -> Optional[str]:
        """
        The ID of the Default Backend Address Pool.
        """
        return pulumi.get(self, "default_backend_address_pool_id")

    @property
    @pulumi.getter(name="defaultBackendAddressPoolName")
    def default_backend_address_pool_name(self) -> Optional[str]:
        """
        The Name of the Default Backend Address Pool which should be used for this URL Path Map. Cannot be set if `default_redirect_configuration_name` is set.
        """
        return pulumi.get(self, "default_backend_address_pool_name")

    @property
    @pulumi.getter(name="defaultBackendHttpSettingsId")
    def default_backend_http_settings_id(self) -> Optional[str]:
        """
        The ID of the Default Backend HTTP Settings Collection.
        """
        return pulumi.get(self, "default_backend_http_settings_id")

    @property
    @pulumi.getter(name="defaultBackendHttpSettingsName")
    def default_backend_http_settings_name(self) -> Optional[str]:
        """
        The Name of the Default Backend HTTP Settings Collection which should be used for this URL Path Map. Cannot be set if `default_redirect_configuration_name` is set.
        """
        return pulumi.get(self, "default_backend_http_settings_name")

    @property
    @pulumi.getter(name="defaultRedirectConfigurationId")
    def default_redirect_configuration_id(self) -> Optional[str]:
        """
        The ID of the Default Redirect Configuration.
        """
        return pulumi.get(self, "default_redirect_configuration_id")

    @property
    @pulumi.getter(name="defaultRedirectConfigurationName")
    def default_redirect_configuration_name(self) -> Optional[str]:
        """
        The Name of the Default Redirect Configuration which should be used for this URL Path Map. Cannot be set if either `default_backend_address_pool_name` or `default_backend_http_settings_name` is set.
        """
        return pulumi.get(self, "default_redirect_configuration_name")

    @property
    @pulumi.getter(name="defaultRewriteRuleSetId")
    def default_rewrite_rule_set_id(self) -> Optional[str]:
        return pulumi.get(self, "default_rewrite_rule_set_id")

    @property
    @pulumi.getter(name="defaultRewriteRuleSetName")
    def default_rewrite_rule_set_name(self) -> Optional[str]:
        """
        The Name of the Default Rewrite Rule Set which should be used for this URL Path Map. Only valid for v2 SKUs.
        """
        return pulumi.get(self, "default_rewrite_rule_set_name")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Rewrite Rule Set
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ApplicationGatewayUrlPathMapPathRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendAddressPoolId":
            suggest = "backend_address_pool_id"
        elif key == "backendAddressPoolName":
            suggest = "backend_address_pool_name"
        elif key == "backendHttpSettingsId":
            suggest = "backend_http_settings_id"
        elif key == "backendHttpSettingsName":
            suggest = "backend_http_settings_name"
        elif key == "firewallPolicyId":
            suggest = "firewall_policy_id"
        elif key == "redirectConfigurationId":
            suggest = "redirect_configuration_id"
        elif key == "redirectConfigurationName":
            suggest = "redirect_configuration_name"
        elif key == "rewriteRuleSetId":
            suggest = "rewrite_rule_set_id"
        elif key == "rewriteRuleSetName":
            suggest = "rewrite_rule_set_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayUrlPathMapPathRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayUrlPathMapPathRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayUrlPathMapPathRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 paths: Sequence[str],
                 backend_address_pool_id: Optional[str] = None,
                 backend_address_pool_name: Optional[str] = None,
                 backend_http_settings_id: Optional[str] = None,
                 backend_http_settings_name: Optional[str] = None,
                 firewall_policy_id: Optional[str] = None,
                 id: Optional[str] = None,
                 redirect_configuration_id: Optional[str] = None,
                 redirect_configuration_name: Optional[str] = None,
                 rewrite_rule_set_id: Optional[str] = None,
                 rewrite_rule_set_name: Optional[str] = None):
        """
        :param str name: The Name of the Path Rule.
        :param Sequence[str] paths: A list of Paths used in this Path Rule.
        :param str backend_address_pool_id: The ID of the associated Backend Address Pool.
        :param str backend_address_pool_name: The Name of the Backend Address Pool to use for this Path Rule. Cannot be set if `redirect_configuration_name` is set.
        :param str backend_http_settings_id: The ID of the associated Backend HTTP Settings Configuration.
        :param str backend_http_settings_name: The Name of the Backend HTTP Settings Collection to use for this Path Rule. Cannot be set if `redirect_configuration_name` is set.
        :param str firewall_policy_id: The ID of the Web Application Firewall Policy which should be used as a HTTP Listener.
        :param str id: The ID of the Rewrite Rule Set
        :param str redirect_configuration_id: The ID of the associated Redirect Configuration.
        :param str redirect_configuration_name: The Name of a Redirect Configuration to use for this Path Rule. Cannot be set if `backend_address_pool_name` or `backend_http_settings_name` is set.
        :param str rewrite_rule_set_id: The ID of the associated Rewrite Rule Set.
        :param str rewrite_rule_set_name: The Name of the Rewrite Rule Set which should be used for this URL Path Map. Only valid for v2 SKUs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "paths", paths)
        if backend_address_pool_id is not None:
            pulumi.set(__self__, "backend_address_pool_id", backend_address_pool_id)
        if backend_address_pool_name is not None:
            pulumi.set(__self__, "backend_address_pool_name", backend_address_pool_name)
        if backend_http_settings_id is not None:
            pulumi.set(__self__, "backend_http_settings_id", backend_http_settings_id)
        if backend_http_settings_name is not None:
            pulumi.set(__self__, "backend_http_settings_name", backend_http_settings_name)
        if firewall_policy_id is not None:
            pulumi.set(__self__, "firewall_policy_id", firewall_policy_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if redirect_configuration_id is not None:
            pulumi.set(__self__, "redirect_configuration_id", redirect_configuration_id)
        if redirect_configuration_name is not None:
            pulumi.set(__self__, "redirect_configuration_name", redirect_configuration_name)
        if rewrite_rule_set_id is not None:
            pulumi.set(__self__, "rewrite_rule_set_id", rewrite_rule_set_id)
        if rewrite_rule_set_name is not None:
            pulumi.set(__self__, "rewrite_rule_set_name", rewrite_rule_set_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Name of the Path Rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def paths(self) -> Sequence[str]:
        """
        A list of Paths used in this Path Rule.
        """
        return pulumi.get(self, "paths")

    @property
    @pulumi.getter(name="backendAddressPoolId")
    def backend_address_pool_id(self) -> Optional[str]:
        """
        The ID of the associated Backend Address Pool.
        """
        return pulumi.get(self, "backend_address_pool_id")

    @property
    @pulumi.getter(name="backendAddressPoolName")
    def backend_address_pool_name(self) -> Optional[str]:
        """
        The Name of the Backend Address Pool to use for this Path Rule. Cannot be set if `redirect_configuration_name` is set.
        """
        return pulumi.get(self, "backend_address_pool_name")

    @property
    @pulumi.getter(name="backendHttpSettingsId")
    def backend_http_settings_id(self) -> Optional[str]:
        """
        The ID of the associated Backend HTTP Settings Configuration.
        """
        return pulumi.get(self, "backend_http_settings_id")

    @property
    @pulumi.getter(name="backendHttpSettingsName")
    def backend_http_settings_name(self) -> Optional[str]:
        """
        The Name of the Backend HTTP Settings Collection to use for this Path Rule. Cannot be set if `redirect_configuration_name` is set.
        """
        return pulumi.get(self, "backend_http_settings_name")

    @property
    @pulumi.getter(name="firewallPolicyId")
    def firewall_policy_id(self) -> Optional[str]:
        """
        The ID of the Web Application Firewall Policy which should be used as a HTTP Listener.
        """
        return pulumi.get(self, "firewall_policy_id")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Rewrite Rule Set
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="redirectConfigurationId")
    def redirect_configuration_id(self) -> Optional[str]:
        """
        The ID of the associated Redirect Configuration.
        """
        return pulumi.get(self, "redirect_configuration_id")

    @property
    @pulumi.getter(name="redirectConfigurationName")
    def redirect_configuration_name(self) -> Optional[str]:
        """
        The Name of a Redirect Configuration to use for this Path Rule. Cannot be set if `backend_address_pool_name` or `backend_http_settings_name` is set.
        """
        return pulumi.get(self, "redirect_configuration_name")

    @property
    @pulumi.getter(name="rewriteRuleSetId")
    def rewrite_rule_set_id(self) -> Optional[str]:
        """
        The ID of the associated Rewrite Rule Set.
        """
        return pulumi.get(self, "rewrite_rule_set_id")

    @property
    @pulumi.getter(name="rewriteRuleSetName")
    def rewrite_rule_set_name(self) -> Optional[str]:
        """
        The Name of the Rewrite Rule Set which should be used for this URL Path Map. Only valid for v2 SKUs.
        """
        return pulumi.get(self, "rewrite_rule_set_name")


@pulumi.output_type
class ApplicationGatewayWafConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "firewallMode":
            suggest = "firewall_mode"
        elif key == "ruleSetVersion":
            suggest = "rule_set_version"
        elif key == "disabledRuleGroups":
            suggest = "disabled_rule_groups"
        elif key == "fileUploadLimitMb":
            suggest = "file_upload_limit_mb"
        elif key == "maxRequestBodySizeKb":
            suggest = "max_request_body_size_kb"
        elif key == "requestBodyCheck":
            suggest = "request_body_check"
        elif key == "ruleSetType":
            suggest = "rule_set_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayWafConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayWafConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayWafConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 firewall_mode: str,
                 rule_set_version: str,
                 disabled_rule_groups: Optional[Sequence['outputs.ApplicationGatewayWafConfigurationDisabledRuleGroup']] = None,
                 exclusions: Optional[Sequence['outputs.ApplicationGatewayWafConfigurationExclusion']] = None,
                 file_upload_limit_mb: Optional[int] = None,
                 max_request_body_size_kb: Optional[int] = None,
                 request_body_check: Optional[bool] = None,
                 rule_set_type: Optional[str] = None):
        """
        :param bool enabled: Is the Web Application Firewall be enabled?
        :param str firewall_mode: The Web Application Firewall Mode. Possible values are `Detection` and `Prevention`.
        :param str rule_set_version: The Version of the Rule Set used for this Web Application Firewall. Possible values are `2.2.9`, `3.0`, and `3.1`.
        :param Sequence['ApplicationGatewayWafConfigurationDisabledRuleGroupArgs'] disabled_rule_groups: one or more `disabled_rule_group` blocks as defined below.
        :param Sequence['ApplicationGatewayWafConfigurationExclusionArgs'] exclusions: one or more `exclusion` blocks as defined below.
        :param int file_upload_limit_mb: The File Upload Limit in MB. Accepted values are in the range `1`MB to `750`MB for the `WAF_v2` SKU, and `1`MB to `500`MB for all other SKUs. Defaults to `100`MB.
        :param int max_request_body_size_kb: The Maximum Request Body Size in KB.  Accepted values are in the range `1`KB to `128`KB.  Defaults to `128`KB.
        :param bool request_body_check: Is Request Body Inspection enabled?  Defaults to `true`.
        :param str rule_set_type: The Type of the Rule Set used for this Web Application Firewall. Currently, only `OWASP` is supported.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "firewall_mode", firewall_mode)
        pulumi.set(__self__, "rule_set_version", rule_set_version)
        if disabled_rule_groups is not None:
            pulumi.set(__self__, "disabled_rule_groups", disabled_rule_groups)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if file_upload_limit_mb is not None:
            pulumi.set(__self__, "file_upload_limit_mb", file_upload_limit_mb)
        if max_request_body_size_kb is not None:
            pulumi.set(__self__, "max_request_body_size_kb", max_request_body_size_kb)
        if request_body_check is not None:
            pulumi.set(__self__, "request_body_check", request_body_check)
        if rule_set_type is not None:
            pulumi.set(__self__, "rule_set_type", rule_set_type)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is the Web Application Firewall be enabled?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="firewallMode")
    def firewall_mode(self) -> str:
        """
        The Web Application Firewall Mode. Possible values are `Detection` and `Prevention`.
        """
        return pulumi.get(self, "firewall_mode")

    @property
    @pulumi.getter(name="ruleSetVersion")
    def rule_set_version(self) -> str:
        """
        The Version of the Rule Set used for this Web Application Firewall. Possible values are `2.2.9`, `3.0`, and `3.1`.
        """
        return pulumi.get(self, "rule_set_version")

    @property
    @pulumi.getter(name="disabledRuleGroups")
    def disabled_rule_groups(self) -> Optional[Sequence['outputs.ApplicationGatewayWafConfigurationDisabledRuleGroup']]:
        """
        one or more `disabled_rule_group` blocks as defined below.
        """
        return pulumi.get(self, "disabled_rule_groups")

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence['outputs.ApplicationGatewayWafConfigurationExclusion']]:
        """
        one or more `exclusion` blocks as defined below.
        """
        return pulumi.get(self, "exclusions")

    @property
    @pulumi.getter(name="fileUploadLimitMb")
    def file_upload_limit_mb(self) -> Optional[int]:
        """
        The File Upload Limit in MB. Accepted values are in the range `1`MB to `750`MB for the `WAF_v2` SKU, and `1`MB to `500`MB for all other SKUs. Defaults to `100`MB.
        """
        return pulumi.get(self, "file_upload_limit_mb")

    @property
    @pulumi.getter(name="maxRequestBodySizeKb")
    def max_request_body_size_kb(self) -> Optional[int]:
        """
        The Maximum Request Body Size in KB.  Accepted values are in the range `1`KB to `128`KB.  Defaults to `128`KB.
        """
        return pulumi.get(self, "max_request_body_size_kb")

    @property
    @pulumi.getter(name="requestBodyCheck")
    def request_body_check(self) -> Optional[bool]:
        """
        Is Request Body Inspection enabled?  Defaults to `true`.
        """
        return pulumi.get(self, "request_body_check")

    @property
    @pulumi.getter(name="ruleSetType")
    def rule_set_type(self) -> Optional[str]:
        """
        The Type of the Rule Set used for this Web Application Firewall. Currently, only `OWASP` is supported.
        """
        return pulumi.get(self, "rule_set_type")


@pulumi.output_type
class ApplicationGatewayWafConfigurationDisabledRuleGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleGroupName":
            suggest = "rule_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayWafConfigurationDisabledRuleGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayWafConfigurationDisabledRuleGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayWafConfigurationDisabledRuleGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rule_group_name: str,
                 rules: Optional[Sequence[int]] = None):
        """
        :param str rule_group_name: The rule group where specific rules should be disabled. Accepted values are:  `crs_20_protocol_violations`, `crs_21_protocol_anomalies`, `crs_23_request_limits`, `crs_30_http_policy`, `crs_35_bad_robots`, `crs_40_generic_attacks`, `crs_41_sql_injection_attacks`, `crs_41_xss_attacks`, `crs_42_tight_security`, `crs_45_trojans`, `General`, `REQUEST-911-METHOD-ENFORCEMENT`, `REQUEST-913-SCANNER-DETECTION`, `REQUEST-920-PROTOCOL-ENFORCEMENT`, `REQUEST-921-PROTOCOL-ATTACK`, `REQUEST-930-APPLICATION-ATTACK-LFI`, `REQUEST-931-APPLICATION-ATTACK-RFI`, `REQUEST-932-APPLICATION-ATTACK-RCE`, `REQUEST-933-APPLICATION-ATTACK-PHP`, `REQUEST-941-APPLICATION-ATTACK-XSS`, `REQUEST-942-APPLICATION-ATTACK-SQLI`, `REQUEST-943-APPLICATION-ATTACK-SESSION-FIXATION`
        :param Sequence[int] rules: A list of rules which should be disabled in that group. Disables all rules in the specified group if `rules` is not specified.
        """
        pulumi.set(__self__, "rule_group_name", rule_group_name)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter(name="ruleGroupName")
    def rule_group_name(self) -> str:
        """
        The rule group where specific rules should be disabled. Accepted values are:  `crs_20_protocol_violations`, `crs_21_protocol_anomalies`, `crs_23_request_limits`, `crs_30_http_policy`, `crs_35_bad_robots`, `crs_40_generic_attacks`, `crs_41_sql_injection_attacks`, `crs_41_xss_attacks`, `crs_42_tight_security`, `crs_45_trojans`, `General`, `REQUEST-911-METHOD-ENFORCEMENT`, `REQUEST-913-SCANNER-DETECTION`, `REQUEST-920-PROTOCOL-ENFORCEMENT`, `REQUEST-921-PROTOCOL-ATTACK`, `REQUEST-930-APPLICATION-ATTACK-LFI`, `REQUEST-931-APPLICATION-ATTACK-RFI`, `REQUEST-932-APPLICATION-ATTACK-RCE`, `REQUEST-933-APPLICATION-ATTACK-PHP`, `REQUEST-941-APPLICATION-ATTACK-XSS`, `REQUEST-942-APPLICATION-ATTACK-SQLI`, `REQUEST-943-APPLICATION-ATTACK-SESSION-FIXATION`
        """
        return pulumi.get(self, "rule_group_name")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence[int]]:
        """
        A list of rules which should be disabled in that group. Disables all rules in the specified group if `rules` is not specified.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class ApplicationGatewayWafConfigurationExclusion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchVariable":
            suggest = "match_variable"
        elif key == "selectorMatchOperator":
            suggest = "selector_match_operator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayWafConfigurationExclusion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayWafConfigurationExclusion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayWafConfigurationExclusion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_variable: str,
                 selector: Optional[str] = None,
                 selector_match_operator: Optional[str] = None):
        """
        :param str match_variable: Match variable of the exclusion rule to exclude header, cookie or GET arguments. Possible values are `RequestHeaderNames`, `RequestArgNames` and `RequestCookieNames`
        :param str selector: String value which will be used for the filter operation. If empty will exclude all traffic on this `match_variable`
        :param str selector_match_operator: Operator which will be used to search in the variable content. Possible values are `Equals`, `StartsWith`, `EndsWith`, `Contains`. If empty will exclude all traffic on this `match_variable`
        """
        pulumi.set(__self__, "match_variable", match_variable)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if selector_match_operator is not None:
            pulumi.set(__self__, "selector_match_operator", selector_match_operator)

    @property
    @pulumi.getter(name="matchVariable")
    def match_variable(self) -> str:
        """
        Match variable of the exclusion rule to exclude header, cookie or GET arguments. Possible values are `RequestHeaderNames`, `RequestArgNames` and `RequestCookieNames`
        """
        return pulumi.get(self, "match_variable")

    @property
    @pulumi.getter
    def selector(self) -> Optional[str]:
        """
        String value which will be used for the filter operation. If empty will exclude all traffic on this `match_variable`
        """
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter(name="selectorMatchOperator")
    def selector_match_operator(self) -> Optional[str]:
        """
        Operator which will be used to search in the variable content. Possible values are `Equals`, `StartsWith`, `EndsWith`, `Contains`. If empty will exclude all traffic on this `match_variable`
        """
        return pulumi.get(self, "selector_match_operator")


@pulumi.output_type
class ExpressRouteCircuitPeeringIpv6(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "microsoftPeering":
            suggest = "microsoft_peering"
        elif key == "primaryPeerAddressPrefix":
            suggest = "primary_peer_address_prefix"
        elif key == "secondaryPeerAddressPrefix":
            suggest = "secondary_peer_address_prefix"
        elif key == "routeFilterId":
            suggest = "route_filter_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExpressRouteCircuitPeeringIpv6. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExpressRouteCircuitPeeringIpv6.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExpressRouteCircuitPeeringIpv6.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 microsoft_peering: 'outputs.ExpressRouteCircuitPeeringIpv6MicrosoftPeering',
                 primary_peer_address_prefix: str,
                 secondary_peer_address_prefix: str,
                 route_filter_id: Optional[str] = None):
        """
        :param 'ExpressRouteCircuitPeeringIpv6MicrosoftPeeringArgs' microsoft_peering: A `microsoft_peering` block as defined below.
        :param str primary_peer_address_prefix: A subnet for the primary link.
        :param str secondary_peer_address_prefix: A subnet for the secondary link.
        :param str route_filter_id: The ID of the Route Filter. Only available when `peering_type` is set to `MicrosoftPeering`.
        """
        pulumi.set(__self__, "microsoft_peering", microsoft_peering)
        pulumi.set(__self__, "primary_peer_address_prefix", primary_peer_address_prefix)
        pulumi.set(__self__, "secondary_peer_address_prefix", secondary_peer_address_prefix)
        if route_filter_id is not None:
            pulumi.set(__self__, "route_filter_id", route_filter_id)

    @property
    @pulumi.getter(name="microsoftPeering")
    def microsoft_peering(self) -> 'outputs.ExpressRouteCircuitPeeringIpv6MicrosoftPeering':
        """
        A `microsoft_peering` block as defined below.
        """
        return pulumi.get(self, "microsoft_peering")

    @property
    @pulumi.getter(name="primaryPeerAddressPrefix")
    def primary_peer_address_prefix(self) -> str:
        """
        A subnet for the primary link.
        """
        return pulumi.get(self, "primary_peer_address_prefix")

    @property
    @pulumi.getter(name="secondaryPeerAddressPrefix")
    def secondary_peer_address_prefix(self) -> str:
        """
        A subnet for the secondary link.
        """
        return pulumi.get(self, "secondary_peer_address_prefix")

    @property
    @pulumi.getter(name="routeFilterId")
    def route_filter_id(self) -> Optional[str]:
        """
        The ID of the Route Filter. Only available when `peering_type` is set to `MicrosoftPeering`.
        """
        return pulumi.get(self, "route_filter_id")


@pulumi.output_type
class ExpressRouteCircuitPeeringIpv6MicrosoftPeering(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "advertisedPublicPrefixes":
            suggest = "advertised_public_prefixes"
        elif key == "customerAsn":
            suggest = "customer_asn"
        elif key == "routingRegistryName":
            suggest = "routing_registry_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExpressRouteCircuitPeeringIpv6MicrosoftPeering. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExpressRouteCircuitPeeringIpv6MicrosoftPeering.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExpressRouteCircuitPeeringIpv6MicrosoftPeering.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 advertised_public_prefixes: Optional[Sequence[str]] = None,
                 customer_asn: Optional[int] = None,
                 routing_registry_name: Optional[str] = None):
        """
        :param Sequence[str] advertised_public_prefixes: A list of Advertised Public Prefixes.
        :param int customer_asn: The CustomerASN of the peering.
        :param str routing_registry_name: The Routing Registry against which the AS number and prefixes are registered. For example:  `ARIN`, `RIPE`, `AFRINIC` etc.
        """
        if advertised_public_prefixes is not None:
            pulumi.set(__self__, "advertised_public_prefixes", advertised_public_prefixes)
        if customer_asn is not None:
            pulumi.set(__self__, "customer_asn", customer_asn)
        if routing_registry_name is not None:
            pulumi.set(__self__, "routing_registry_name", routing_registry_name)

    @property
    @pulumi.getter(name="advertisedPublicPrefixes")
    def advertised_public_prefixes(self) -> Optional[Sequence[str]]:
        """
        A list of Advertised Public Prefixes.
        """
        return pulumi.get(self, "advertised_public_prefixes")

    @property
    @pulumi.getter(name="customerAsn")
    def customer_asn(self) -> Optional[int]:
        """
        The CustomerASN of the peering.
        """
        return pulumi.get(self, "customer_asn")

    @property
    @pulumi.getter(name="routingRegistryName")
    def routing_registry_name(self) -> Optional[str]:
        """
        The Routing Registry against which the AS number and prefixes are registered. For example:  `ARIN`, `RIPE`, `AFRINIC` etc.
        """
        return pulumi.get(self, "routing_registry_name")


@pulumi.output_type
class ExpressRouteCircuitPeeringMicrosoftPeeringConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "advertisedPublicPrefixes":
            suggest = "advertised_public_prefixes"
        elif key == "customerAsn":
            suggest = "customer_asn"
        elif key == "routingRegistryName":
            suggest = "routing_registry_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExpressRouteCircuitPeeringMicrosoftPeeringConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExpressRouteCircuitPeeringMicrosoftPeeringConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExpressRouteCircuitPeeringMicrosoftPeeringConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 advertised_public_prefixes: Sequence[str],
                 customer_asn: Optional[int] = None,
                 routing_registry_name: Optional[str] = None):
        """
        :param Sequence[str] advertised_public_prefixes: A list of Advertised Public Prefixes.
        :param int customer_asn: The CustomerASN of the peering.
        :param str routing_registry_name: The Routing Registry against which the AS number and prefixes are registered. For example:  `ARIN`, `RIPE`, `AFRINIC` etc.
        """
        pulumi.set(__self__, "advertised_public_prefixes", advertised_public_prefixes)
        if customer_asn is not None:
            pulumi.set(__self__, "customer_asn", customer_asn)
        if routing_registry_name is not None:
            pulumi.set(__self__, "routing_registry_name", routing_registry_name)

    @property
    @pulumi.getter(name="advertisedPublicPrefixes")
    def advertised_public_prefixes(self) -> Sequence[str]:
        """
        A list of Advertised Public Prefixes.
        """
        return pulumi.get(self, "advertised_public_prefixes")

    @property
    @pulumi.getter(name="customerAsn")
    def customer_asn(self) -> Optional[int]:
        """
        The CustomerASN of the peering.
        """
        return pulumi.get(self, "customer_asn")

    @property
    @pulumi.getter(name="routingRegistryName")
    def routing_registry_name(self) -> Optional[str]:
        """
        The Routing Registry against which the AS number and prefixes are registered. For example:  `ARIN`, `RIPE`, `AFRINIC` etc.
        """
        return pulumi.get(self, "routing_registry_name")


@pulumi.output_type
class ExpressRouteCircuitSku(dict):
    def __init__(__self__, *,
                 family: str,
                 tier: str):
        """
        :param str family: The billing mode for bandwidth. Possible values are `MeteredData` or `UnlimitedData`.
        :param str tier: The service tier. Possible values are `Basic`, `Local`, `Standard` or `Premium`.
        """
        pulumi.set(__self__, "family", family)
        pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter
    def family(self) -> str:
        """
        The billing mode for bandwidth. Possible values are `MeteredData` or `UnlimitedData`.
        """
        return pulumi.get(self, "family")

    @property
    @pulumi.getter
    def tier(self) -> str:
        """
        The service tier. Possible values are `Basic`, `Local`, `Standard` or `Premium`.
        """
        return pulumi.get(self, "tier")


@pulumi.output_type
class ExpressRouteConnectionRouting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "associatedRouteTableId":
            suggest = "associated_route_table_id"
        elif key == "propagatedRouteTable":
            suggest = "propagated_route_table"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExpressRouteConnectionRouting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExpressRouteConnectionRouting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExpressRouteConnectionRouting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 associated_route_table_id: Optional[str] = None,
                 propagated_route_table: Optional['outputs.ExpressRouteConnectionRoutingPropagatedRouteTable'] = None):
        """
        :param str associated_route_table_id: The ID of the Virtual Hub Route Table associated with this Express Route Connection.
        :param 'ExpressRouteConnectionRoutingPropagatedRouteTableArgs' propagated_route_table: A `propagated_route_table` block as defined below.
        """
        if associated_route_table_id is not None:
            pulumi.set(__self__, "associated_route_table_id", associated_route_table_id)
        if propagated_route_table is not None:
            pulumi.set(__self__, "propagated_route_table", propagated_route_table)

    @property
    @pulumi.getter(name="associatedRouteTableId")
    def associated_route_table_id(self) -> Optional[str]:
        """
        The ID of the Virtual Hub Route Table associated with this Express Route Connection.
        """
        return pulumi.get(self, "associated_route_table_id")

    @property
    @pulumi.getter(name="propagatedRouteTable")
    def propagated_route_table(self) -> Optional['outputs.ExpressRouteConnectionRoutingPropagatedRouteTable']:
        """
        A `propagated_route_table` block as defined below.
        """
        return pulumi.get(self, "propagated_route_table")


@pulumi.output_type
class ExpressRouteConnectionRoutingPropagatedRouteTable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "routeTableIds":
            suggest = "route_table_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExpressRouteConnectionRoutingPropagatedRouteTable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExpressRouteConnectionRoutingPropagatedRouteTable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExpressRouteConnectionRoutingPropagatedRouteTable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 labels: Optional[Sequence[str]] = None,
                 route_table_ids: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] labels: The list of labels to logically group route tables.
        :param Sequence[str] route_table_ids: A list of IDs of the Virtual Hub Route Table to propagate routes from Express Route Connection to the route table.
        """
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if route_table_ids is not None:
            pulumi.set(__self__, "route_table_ids", route_table_ids)

    @property
    @pulumi.getter
    def labels(self) -> Optional[Sequence[str]]:
        """
        The list of labels to logically group route tables.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="routeTableIds")
    def route_table_ids(self) -> Optional[Sequence[str]]:
        """
        A list of IDs of the Virtual Hub Route Table to propagate routes from Express Route Connection to the route table.
        """
        return pulumi.get(self, "route_table_ids")


@pulumi.output_type
class ExpressRoutePortIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExpressRoutePortIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExpressRoutePortIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExpressRoutePortIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 identity_ids: Optional[Sequence[str]] = None):
        """
        :param str type: The type of the identity used for the Express Route Port. Currently, the only possible values is `UserAssigned`.
        :param Sequence[str] identity_ids: Specifies a list with a single user managed identity id to be assigned to the Express Route Port. Currently, exactly one id is allowed to specify.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the identity used for the Express Route Port. Currently, the only possible values is `UserAssigned`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list with a single user managed identity id to be assigned to the Express Route Port. Currently, exactly one id is allowed to specify.
        """
        return pulumi.get(self, "identity_ids")


@pulumi.output_type
class ExpressRoutePortLink1(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminEnabled":
            suggest = "admin_enabled"
        elif key == "connectorType":
            suggest = "connector_type"
        elif key == "interfaceName":
            suggest = "interface_name"
        elif key == "macsecCakKeyvaultSecretId":
            suggest = "macsec_cak_keyvault_secret_id"
        elif key == "macsecCipher":
            suggest = "macsec_cipher"
        elif key == "macsecCknKeyvaultSecretId":
            suggest = "macsec_ckn_keyvault_secret_id"
        elif key == "patchPanelId":
            suggest = "patch_panel_id"
        elif key == "rackId":
            suggest = "rack_id"
        elif key == "routerName":
            suggest = "router_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExpressRoutePortLink1. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExpressRoutePortLink1.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExpressRoutePortLink1.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_enabled: Optional[bool] = None,
                 connector_type: Optional[str] = None,
                 id: Optional[str] = None,
                 interface_name: Optional[str] = None,
                 macsec_cak_keyvault_secret_id: Optional[str] = None,
                 macsec_cipher: Optional[str] = None,
                 macsec_ckn_keyvault_secret_id: Optional[str] = None,
                 patch_panel_id: Optional[str] = None,
                 rack_id: Optional[str] = None,
                 router_name: Optional[str] = None):
        """
        :param bool admin_enabled: Whether enable administration state on the Express Route Port Link? Defaults to `false`.
        :param str connector_type: The connector type of the Express Route Port Link.
        :param str id: The ID of this Express Route Port Link.
        :param str interface_name: The interface name of the Azure router associated with the Express Route Port Link.
        :param str macsec_cak_keyvault_secret_id: The ID of the Key Vault Secret that contains the Mac security CAK key for this Express Route Port Link.
        :param str macsec_cipher: The MACSec cipher used for this Express Route Port Link. Possible values are `GcmAes128` and `GcmAes256`. Defaults to `GcmAes128`.
        :param str macsec_ckn_keyvault_secret_id: The ID of the Key Vault Secret that contains the MACSec CKN key for this Express Route Port Link.
        :param str patch_panel_id: The ID that maps from the Express Route Port Link to the patch panel port.
        :param str rack_id: The ID that maps from the patch panel port to the rack.
        :param str router_name: The name of the Azure router associated with the Express Route Port Link.
        """
        if admin_enabled is not None:
            pulumi.set(__self__, "admin_enabled", admin_enabled)
        if connector_type is not None:
            pulumi.set(__self__, "connector_type", connector_type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if interface_name is not None:
            pulumi.set(__self__, "interface_name", interface_name)
        if macsec_cak_keyvault_secret_id is not None:
            pulumi.set(__self__, "macsec_cak_keyvault_secret_id", macsec_cak_keyvault_secret_id)
        if macsec_cipher is not None:
            pulumi.set(__self__, "macsec_cipher", macsec_cipher)
        if macsec_ckn_keyvault_secret_id is not None:
            pulumi.set(__self__, "macsec_ckn_keyvault_secret_id", macsec_ckn_keyvault_secret_id)
        if patch_panel_id is not None:
            pulumi.set(__self__, "patch_panel_id", patch_panel_id)
        if rack_id is not None:
            pulumi.set(__self__, "rack_id", rack_id)
        if router_name is not None:
            pulumi.set(__self__, "router_name", router_name)

    @property
    @pulumi.getter(name="adminEnabled")
    def admin_enabled(self) -> Optional[bool]:
        """
        Whether enable administration state on the Express Route Port Link? Defaults to `false`.
        """
        return pulumi.get(self, "admin_enabled")

    @property
    @pulumi.getter(name="connectorType")
    def connector_type(self) -> Optional[str]:
        """
        The connector type of the Express Route Port Link.
        """
        return pulumi.get(self, "connector_type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of this Express Route Port Link.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="interfaceName")
    def interface_name(self) -> Optional[str]:
        """
        The interface name of the Azure router associated with the Express Route Port Link.
        """
        return pulumi.get(self, "interface_name")

    @property
    @pulumi.getter(name="macsecCakKeyvaultSecretId")
    def macsec_cak_keyvault_secret_id(self) -> Optional[str]:
        """
        The ID of the Key Vault Secret that contains the Mac security CAK key for this Express Route Port Link.
        """
        return pulumi.get(self, "macsec_cak_keyvault_secret_id")

    @property
    @pulumi.getter(name="macsecCipher")
    def macsec_cipher(self) -> Optional[str]:
        """
        The MACSec cipher used for this Express Route Port Link. Possible values are `GcmAes128` and `GcmAes256`. Defaults to `GcmAes128`.
        """
        return pulumi.get(self, "macsec_cipher")

    @property
    @pulumi.getter(name="macsecCknKeyvaultSecretId")
    def macsec_ckn_keyvault_secret_id(self) -> Optional[str]:
        """
        The ID of the Key Vault Secret that contains the MACSec CKN key for this Express Route Port Link.
        """
        return pulumi.get(self, "macsec_ckn_keyvault_secret_id")

    @property
    @pulumi.getter(name="patchPanelId")
    def patch_panel_id(self) -> Optional[str]:
        """
        The ID that maps from the Express Route Port Link to the patch panel port.
        """
        return pulumi.get(self, "patch_panel_id")

    @property
    @pulumi.getter(name="rackId")
    def rack_id(self) -> Optional[str]:
        """
        The ID that maps from the patch panel port to the rack.
        """
        return pulumi.get(self, "rack_id")

    @property
    @pulumi.getter(name="routerName")
    def router_name(self) -> Optional[str]:
        """
        The name of the Azure router associated with the Express Route Port Link.
        """
        return pulumi.get(self, "router_name")


@pulumi.output_type
class ExpressRoutePortLink2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminEnabled":
            suggest = "admin_enabled"
        elif key == "connectorType":
            suggest = "connector_type"
        elif key == "interfaceName":
            suggest = "interface_name"
        elif key == "macsecCakKeyvaultSecretId":
            suggest = "macsec_cak_keyvault_secret_id"
        elif key == "macsecCipher":
            suggest = "macsec_cipher"
        elif key == "macsecCknKeyvaultSecretId":
            suggest = "macsec_ckn_keyvault_secret_id"
        elif key == "patchPanelId":
            suggest = "patch_panel_id"
        elif key == "rackId":
            suggest = "rack_id"
        elif key == "routerName":
            suggest = "router_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExpressRoutePortLink2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExpressRoutePortLink2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExpressRoutePortLink2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_enabled: Optional[bool] = None,
                 connector_type: Optional[str] = None,
                 id: Optional[str] = None,
                 interface_name: Optional[str] = None,
                 macsec_cak_keyvault_secret_id: Optional[str] = None,
                 macsec_cipher: Optional[str] = None,
                 macsec_ckn_keyvault_secret_id: Optional[str] = None,
                 patch_panel_id: Optional[str] = None,
                 rack_id: Optional[str] = None,
                 router_name: Optional[str] = None):
        """
        :param bool admin_enabled: Whether enable administration state on the Express Route Port Link? Defaults to `false`.
        :param str connector_type: The connector type of the Express Route Port Link.
        :param str id: The ID of this Express Route Port Link.
        :param str interface_name: The interface name of the Azure router associated with the Express Route Port Link.
        :param str macsec_cak_keyvault_secret_id: The ID of the Key Vault Secret that contains the Mac security CAK key for this Express Route Port Link.
        :param str macsec_cipher: The MACSec cipher used for this Express Route Port Link. Possible values are `GcmAes128` and `GcmAes256`. Defaults to `GcmAes128`.
        :param str macsec_ckn_keyvault_secret_id: The ID of the Key Vault Secret that contains the MACSec CKN key for this Express Route Port Link.
        :param str patch_panel_id: The ID that maps from the Express Route Port Link to the patch panel port.
        :param str rack_id: The ID that maps from the patch panel port to the rack.
        :param str router_name: The name of the Azure router associated with the Express Route Port Link.
        """
        if admin_enabled is not None:
            pulumi.set(__self__, "admin_enabled", admin_enabled)
        if connector_type is not None:
            pulumi.set(__self__, "connector_type", connector_type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if interface_name is not None:
            pulumi.set(__self__, "interface_name", interface_name)
        if macsec_cak_keyvault_secret_id is not None:
            pulumi.set(__self__, "macsec_cak_keyvault_secret_id", macsec_cak_keyvault_secret_id)
        if macsec_cipher is not None:
            pulumi.set(__self__, "macsec_cipher", macsec_cipher)
        if macsec_ckn_keyvault_secret_id is not None:
            pulumi.set(__self__, "macsec_ckn_keyvault_secret_id", macsec_ckn_keyvault_secret_id)
        if patch_panel_id is not None:
            pulumi.set(__self__, "patch_panel_id", patch_panel_id)
        if rack_id is not None:
            pulumi.set(__self__, "rack_id", rack_id)
        if router_name is not None:
            pulumi.set(__self__, "router_name", router_name)

    @property
    @pulumi.getter(name="adminEnabled")
    def admin_enabled(self) -> Optional[bool]:
        """
        Whether enable administration state on the Express Route Port Link? Defaults to `false`.
        """
        return pulumi.get(self, "admin_enabled")

    @property
    @pulumi.getter(name="connectorType")
    def connector_type(self) -> Optional[str]:
        """
        The connector type of the Express Route Port Link.
        """
        return pulumi.get(self, "connector_type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of this Express Route Port Link.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="interfaceName")
    def interface_name(self) -> Optional[str]:
        """
        The interface name of the Azure router associated with the Express Route Port Link.
        """
        return pulumi.get(self, "interface_name")

    @property
    @pulumi.getter(name="macsecCakKeyvaultSecretId")
    def macsec_cak_keyvault_secret_id(self) -> Optional[str]:
        """
        The ID of the Key Vault Secret that contains the Mac security CAK key for this Express Route Port Link.
        """
        return pulumi.get(self, "macsec_cak_keyvault_secret_id")

    @property
    @pulumi.getter(name="macsecCipher")
    def macsec_cipher(self) -> Optional[str]:
        """
        The MACSec cipher used for this Express Route Port Link. Possible values are `GcmAes128` and `GcmAes256`. Defaults to `GcmAes128`.
        """
        return pulumi.get(self, "macsec_cipher")

    @property
    @pulumi.getter(name="macsecCknKeyvaultSecretId")
    def macsec_ckn_keyvault_secret_id(self) -> Optional[str]:
        """
        The ID of the Key Vault Secret that contains the MACSec CKN key for this Express Route Port Link.
        """
        return pulumi.get(self, "macsec_ckn_keyvault_secret_id")

    @property
    @pulumi.getter(name="patchPanelId")
    def patch_panel_id(self) -> Optional[str]:
        """
        The ID that maps from the Express Route Port Link to the patch panel port.
        """
        return pulumi.get(self, "patch_panel_id")

    @property
    @pulumi.getter(name="rackId")
    def rack_id(self) -> Optional[str]:
        """
        The ID that maps from the patch panel port to the rack.
        """
        return pulumi.get(self, "rack_id")

    @property
    @pulumi.getter(name="routerName")
    def router_name(self) -> Optional[str]:
        """
        The name of the Azure router associated with the Express Route Port Link.
        """
        return pulumi.get(self, "router_name")


@pulumi.output_type
class FirewallApplicationRuleCollectionRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fqdnTags":
            suggest = "fqdn_tags"
        elif key == "sourceAddresses":
            suggest = "source_addresses"
        elif key == "sourceIpGroups":
            suggest = "source_ip_groups"
        elif key == "targetFqdns":
            suggest = "target_fqdns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallApplicationRuleCollectionRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallApplicationRuleCollectionRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallApplicationRuleCollectionRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 description: Optional[str] = None,
                 fqdn_tags: Optional[Sequence[str]] = None,
                 protocols: Optional[Sequence['outputs.FirewallApplicationRuleCollectionRuleProtocol']] = None,
                 source_addresses: Optional[Sequence[str]] = None,
                 source_ip_groups: Optional[Sequence[str]] = None,
                 target_fqdns: Optional[Sequence[str]] = None):
        """
        :param str name: Specifies the name of the rule.
        :param str description: Specifies a description for the rule.
        :param Sequence[str] fqdn_tags: A list of FQDN tags. Possible values are `AppServiceEnvironment`, `AzureBackup`, `AzureKubernetesService`, `HDInsight`, `MicrosoftActiveProtectionService`, `WindowsDiagnostics`, `WindowsUpdate` and `WindowsVirtualDesktop`.
        :param Sequence['FirewallApplicationRuleCollectionRuleProtocolArgs'] protocols: One or more `protocol` blocks as defined below.
        :param Sequence[str] source_addresses: A list of source IP addresses and/or IP ranges.
        :param Sequence[str] source_ip_groups: A list of source IP Group IDs for the rule.
        :param Sequence[str] target_fqdns: A list of FQDNs.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if fqdn_tags is not None:
            pulumi.set(__self__, "fqdn_tags", fqdn_tags)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_ip_groups is not None:
            pulumi.set(__self__, "source_ip_groups", source_ip_groups)
        if target_fqdns is not None:
            pulumi.set(__self__, "target_fqdns", target_fqdns)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Specifies a description for the rule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="fqdnTags")
    def fqdn_tags(self) -> Optional[Sequence[str]]:
        """
        A list of FQDN tags. Possible values are `AppServiceEnvironment`, `AzureBackup`, `AzureKubernetesService`, `HDInsight`, `MicrosoftActiveProtectionService`, `WindowsDiagnostics`, `WindowsUpdate` and `WindowsVirtualDesktop`.
        """
        return pulumi.get(self, "fqdn_tags")

    @property
    @pulumi.getter
    def protocols(self) -> Optional[Sequence['outputs.FirewallApplicationRuleCollectionRuleProtocol']]:
        """
        One or more `protocol` blocks as defined below.
        """
        return pulumi.get(self, "protocols")

    @property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[str]]:
        """
        A list of source IP addresses and/or IP ranges.
        """
        return pulumi.get(self, "source_addresses")

    @property
    @pulumi.getter(name="sourceIpGroups")
    def source_ip_groups(self) -> Optional[Sequence[str]]:
        """
        A list of source IP Group IDs for the rule.
        """
        return pulumi.get(self, "source_ip_groups")

    @property
    @pulumi.getter(name="targetFqdns")
    def target_fqdns(self) -> Optional[Sequence[str]]:
        """
        A list of FQDNs.
        """
        return pulumi.get(self, "target_fqdns")


@pulumi.output_type
class FirewallApplicationRuleCollectionRuleProtocol(dict):
    def __init__(__self__, *,
                 type: str,
                 port: Optional[int] = None):
        """
        :param str type: Specifies the type of connection. Possible values are `Http`, `Https` and `Mssql`.
        :param int port: Specify a port for the connection.
        """
        pulumi.set(__self__, "type", type)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the type of connection. Possible values are `Http`, `Https` and `Mssql`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Specify a port for the connection.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class FirewallIpConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicIpAddressId":
            suggest = "public_ip_address_id"
        elif key == "privateIpAddress":
            suggest = "private_ip_address"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallIpConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallIpConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallIpConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 public_ip_address_id: str,
                 private_ip_address: Optional[str] = None,
                 subnet_id: Optional[str] = None):
        """
        :param str name: Specifies the name of the IP Configuration.
        :param str public_ip_address_id: The ID of the Public IP Address associated with the firewall.
        :param str private_ip_address: The private IP address associated with the Firewall.
        :param str subnet_id: Reference to the subnet associated with the IP Configuration.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "public_ip_address_id", public_ip_address_id)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the IP Configuration.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="publicIpAddressId")
    def public_ip_address_id(self) -> str:
        """
        The ID of the Public IP Address associated with the firewall.
        """
        return pulumi.get(self, "public_ip_address_id")

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> Optional[str]:
        """
        The private IP address associated with the Firewall.
        """
        return pulumi.get(self, "private_ip_address")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        Reference to the subnet associated with the IP Configuration.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class FirewallManagementIpConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicIpAddressId":
            suggest = "public_ip_address_id"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "privateIpAddress":
            suggest = "private_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallManagementIpConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallManagementIpConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallManagementIpConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 public_ip_address_id: str,
                 subnet_id: str,
                 private_ip_address: Optional[str] = None):
        """
        :param str name: Specifies the name of the IP Configuration.
        :param str public_ip_address_id: The ID of the Public IP Address associated with the firewall.
        :param str subnet_id: Reference to the subnet associated with the IP Configuration. Changing this forces a new resource to be created.
        :param str private_ip_address: The private IP address associated with the Firewall.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "public_ip_address_id", public_ip_address_id)
        pulumi.set(__self__, "subnet_id", subnet_id)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the IP Configuration.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="publicIpAddressId")
    def public_ip_address_id(self) -> str:
        """
        The ID of the Public IP Address associated with the firewall.
        """
        return pulumi.get(self, "public_ip_address_id")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        Reference to the subnet associated with the IP Configuration. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> Optional[str]:
        """
        The private IP address associated with the Firewall.
        """
        return pulumi.get(self, "private_ip_address")


@pulumi.output_type
class FirewallNatRuleCollectionRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationAddresses":
            suggest = "destination_addresses"
        elif key == "destinationPorts":
            suggest = "destination_ports"
        elif key == "translatedAddress":
            suggest = "translated_address"
        elif key == "translatedPort":
            suggest = "translated_port"
        elif key == "sourceAddresses":
            suggest = "source_addresses"
        elif key == "sourceIpGroups":
            suggest = "source_ip_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallNatRuleCollectionRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallNatRuleCollectionRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallNatRuleCollectionRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_addresses: Sequence[str],
                 destination_ports: Sequence[str],
                 name: str,
                 protocols: Sequence[str],
                 translated_address: str,
                 translated_port: str,
                 description: Optional[str] = None,
                 source_addresses: Optional[Sequence[str]] = None,
                 source_ip_groups: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] destination_addresses: A list of destination IP addresses and/or IP ranges.
        :param Sequence[str] destination_ports: A list of destination ports.
        :param str name: Specifies the name of the rule.
        :param Sequence[str] protocols: A list of protocols. Possible values are `Any`, `ICMP`, `TCP` and `UDP`.  If `action` is `Dnat`, protocols can only be `TCP` and `UDP`.
        :param str translated_address: The address of the service behind the Firewall.
        :param str translated_port: The port of the service behind the Firewall.
        :param str description: Specifies a description for the rule.
        :param Sequence[str] source_addresses: A list of source IP addresses and/or IP ranges.
        :param Sequence[str] source_ip_groups: A list of source IP Group IDs for the rule.
        """
        pulumi.set(__self__, "destination_addresses", destination_addresses)
        pulumi.set(__self__, "destination_ports", destination_ports)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "protocols", protocols)
        pulumi.set(__self__, "translated_address", translated_address)
        pulumi.set(__self__, "translated_port", translated_port)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_ip_groups is not None:
            pulumi.set(__self__, "source_ip_groups", source_ip_groups)

    @property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Sequence[str]:
        """
        A list of destination IP addresses and/or IP ranges.
        """
        return pulumi.get(self, "destination_addresses")

    @property
    @pulumi.getter(name="destinationPorts")
    def destination_ports(self) -> Sequence[str]:
        """
        A list of destination ports.
        """
        return pulumi.get(self, "destination_ports")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def protocols(self) -> Sequence[str]:
        """
        A list of protocols. Possible values are `Any`, `ICMP`, `TCP` and `UDP`.  If `action` is `Dnat`, protocols can only be `TCP` and `UDP`.
        """
        return pulumi.get(self, "protocols")

    @property
    @pulumi.getter(name="translatedAddress")
    def translated_address(self) -> str:
        """
        The address of the service behind the Firewall.
        """
        return pulumi.get(self, "translated_address")

    @property
    @pulumi.getter(name="translatedPort")
    def translated_port(self) -> str:
        """
        The port of the service behind the Firewall.
        """
        return pulumi.get(self, "translated_port")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Specifies a description for the rule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[str]]:
        """
        A list of source IP addresses and/or IP ranges.
        """
        return pulumi.get(self, "source_addresses")

    @property
    @pulumi.getter(name="sourceIpGroups")
    def source_ip_groups(self) -> Optional[Sequence[str]]:
        """
        A list of source IP Group IDs for the rule.
        """
        return pulumi.get(self, "source_ip_groups")


@pulumi.output_type
class FirewallNetworkRuleCollectionRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationPorts":
            suggest = "destination_ports"
        elif key == "destinationAddresses":
            suggest = "destination_addresses"
        elif key == "destinationFqdns":
            suggest = "destination_fqdns"
        elif key == "destinationIpGroups":
            suggest = "destination_ip_groups"
        elif key == "sourceAddresses":
            suggest = "source_addresses"
        elif key == "sourceIpGroups":
            suggest = "source_ip_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallNetworkRuleCollectionRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallNetworkRuleCollectionRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallNetworkRuleCollectionRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_ports: Sequence[str],
                 name: str,
                 protocols: Sequence[str],
                 description: Optional[str] = None,
                 destination_addresses: Optional[Sequence[str]] = None,
                 destination_fqdns: Optional[Sequence[str]] = None,
                 destination_ip_groups: Optional[Sequence[str]] = None,
                 source_addresses: Optional[Sequence[str]] = None,
                 source_ip_groups: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] destination_ports: A list of destination ports.
        :param str name: Specifies the name of the rule.
        :param Sequence[str] protocols: A list of protocols. Possible values are `Any`, `ICMP`, `TCP` and `UDP`.
        :param str description: Specifies a description for the rule.
        :param Sequence[str] destination_addresses: Either a list of destination IP addresses and/or IP ranges, or a list of destination [Service Tags](https://docs.microsoft.com/en-us/azure/virtual-network/service-tags-overview#available-service-tags).
        :param Sequence[str] destination_fqdns: A list of destination FQDNS for the rule.
        :param Sequence[str] destination_ip_groups: A list of destination IP Group IDs for the rule.
        :param Sequence[str] source_addresses: A list of source IP addresses and/or IP ranges.
        :param Sequence[str] source_ip_groups: A list of IP Group IDs for the rule.
        """
        pulumi.set(__self__, "destination_ports", destination_ports)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "protocols", protocols)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if destination_fqdns is not None:
            pulumi.set(__self__, "destination_fqdns", destination_fqdns)
        if destination_ip_groups is not None:
            pulumi.set(__self__, "destination_ip_groups", destination_ip_groups)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_ip_groups is not None:
            pulumi.set(__self__, "source_ip_groups", source_ip_groups)

    @property
    @pulumi.getter(name="destinationPorts")
    def destination_ports(self) -> Sequence[str]:
        """
        A list of destination ports.
        """
        return pulumi.get(self, "destination_ports")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def protocols(self) -> Sequence[str]:
        """
        A list of protocols. Possible values are `Any`, `ICMP`, `TCP` and `UDP`.
        """
        return pulumi.get(self, "protocols")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Specifies a description for the rule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[Sequence[str]]:
        """
        Either a list of destination IP addresses and/or IP ranges, or a list of destination [Service Tags](https://docs.microsoft.com/en-us/azure/virtual-network/service-tags-overview#available-service-tags).
        """
        return pulumi.get(self, "destination_addresses")

    @property
    @pulumi.getter(name="destinationFqdns")
    def destination_fqdns(self) -> Optional[Sequence[str]]:
        """
        A list of destination FQDNS for the rule.
        """
        return pulumi.get(self, "destination_fqdns")

    @property
    @pulumi.getter(name="destinationIpGroups")
    def destination_ip_groups(self) -> Optional[Sequence[str]]:
        """
        A list of destination IP Group IDs for the rule.
        """
        return pulumi.get(self, "destination_ip_groups")

    @property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[str]]:
        """
        A list of source IP addresses and/or IP ranges.
        """
        return pulumi.get(self, "source_addresses")

    @property
    @pulumi.getter(name="sourceIpGroups")
    def source_ip_groups(self) -> Optional[Sequence[str]]:
        """
        A list of IP Group IDs for the rule.
        """
        return pulumi.get(self, "source_ip_groups")


@pulumi.output_type
class FirewallPolicyDns(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkRuleFqdnEnabled":
            suggest = "network_rule_fqdn_enabled"
        elif key == "proxyEnabled":
            suggest = "proxy_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyDns. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyDns.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyDns.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_rule_fqdn_enabled: Optional[bool] = None,
                 proxy_enabled: Optional[bool] = None,
                 servers: Optional[Sequence[str]] = None):
        """
        :param bool proxy_enabled: Whether to enable DNS proxy on Firewalls attached to this Firewall Policy? Defaults to `false`.
        :param Sequence[str] servers: A list of custom DNS servers' IP addresses.
        """
        if network_rule_fqdn_enabled is not None:
            pulumi.set(__self__, "network_rule_fqdn_enabled", network_rule_fqdn_enabled)
        if proxy_enabled is not None:
            pulumi.set(__self__, "proxy_enabled", proxy_enabled)
        if servers is not None:
            pulumi.set(__self__, "servers", servers)

    @property
    @pulumi.getter(name="networkRuleFqdnEnabled")
    def network_rule_fqdn_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "network_rule_fqdn_enabled")

    @property
    @pulumi.getter(name="proxyEnabled")
    def proxy_enabled(self) -> Optional[bool]:
        """
        Whether to enable DNS proxy on Firewalls attached to this Firewall Policy? Defaults to `false`.
        """
        return pulumi.get(self, "proxy_enabled")

    @property
    @pulumi.getter
    def servers(self) -> Optional[Sequence[str]]:
        """
        A list of custom DNS servers' IP addresses.
        """
        return pulumi.get(self, "servers")


@pulumi.output_type
class FirewallPolicyRuleCollectionGroupApplicationRuleCollection(dict):
    def __init__(__self__, *,
                 action: str,
                 name: str,
                 priority: int,
                 rules: Sequence['outputs.FirewallPolicyRuleCollectionGroupApplicationRuleCollectionRule']):
        """
        :param str action: The action to take for the application rules in this collection. Possible values are `Allow` and `Deny`.
        :param str name: The name which should be used for this application rule collection.
        :param int priority: The priority of the application rule collection. The range is `100` - `65000`.
        :param Sequence['FirewallPolicyRuleCollectionGroupApplicationRuleCollectionRuleArgs'] rules: One or more `rule` (application rule) blocks as defined below.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action to take for the application rules in this collection. Possible values are `Allow` and `Deny`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this application rule collection.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        The priority of the application rule collection. The range is `100` - `65000`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.FirewallPolicyRuleCollectionGroupApplicationRuleCollectionRule']:
        """
        One or more `rule` (application rule) blocks as defined below.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class FirewallPolicyRuleCollectionGroupApplicationRuleCollectionRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationFqdnTags":
            suggest = "destination_fqdn_tags"
        elif key == "destinationFqdns":
            suggest = "destination_fqdns"
        elif key == "sourceAddresses":
            suggest = "source_addresses"
        elif key == "sourceIpGroups":
            suggest = "source_ip_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyRuleCollectionGroupApplicationRuleCollectionRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyRuleCollectionGroupApplicationRuleCollectionRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyRuleCollectionGroupApplicationRuleCollectionRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 protocols: Sequence['outputs.FirewallPolicyRuleCollectionGroupApplicationRuleCollectionRuleProtocol'],
                 destination_fqdn_tags: Optional[Sequence[str]] = None,
                 destination_fqdns: Optional[Sequence[str]] = None,
                 source_addresses: Optional[Sequence[str]] = None,
                 source_ip_groups: Optional[Sequence[str]] = None):
        """
        :param str name: The name which should be used for this rule.
        :param Sequence['FirewallPolicyRuleCollectionGroupApplicationRuleCollectionRuleProtocolArgs'] protocols: Specifies a list of network protocols this rule applies to. Possible values are `TCP`, `UDP`.
        :param Sequence[str] destination_fqdn_tags: Specifies a list of destination FQDN tags.
        :param Sequence[str] destination_fqdns: Specifies a list of destination FQDNs.
        :param Sequence[str] source_addresses: Specifies a list of source IP addresses (including CIDR and `*`).
        :param Sequence[str] source_ip_groups: Specifies a list of source IP groups.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "protocols", protocols)
        if destination_fqdn_tags is not None:
            pulumi.set(__self__, "destination_fqdn_tags", destination_fqdn_tags)
        if destination_fqdns is not None:
            pulumi.set(__self__, "destination_fqdns", destination_fqdns)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_ip_groups is not None:
            pulumi.set(__self__, "source_ip_groups", source_ip_groups)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def protocols(self) -> Sequence['outputs.FirewallPolicyRuleCollectionGroupApplicationRuleCollectionRuleProtocol']:
        """
        Specifies a list of network protocols this rule applies to. Possible values are `TCP`, `UDP`.
        """
        return pulumi.get(self, "protocols")

    @property
    @pulumi.getter(name="destinationFqdnTags")
    def destination_fqdn_tags(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of destination FQDN tags.
        """
        return pulumi.get(self, "destination_fqdn_tags")

    @property
    @pulumi.getter(name="destinationFqdns")
    def destination_fqdns(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of destination FQDNs.
        """
        return pulumi.get(self, "destination_fqdns")

    @property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of source IP addresses (including CIDR and `*`).
        """
        return pulumi.get(self, "source_addresses")

    @property
    @pulumi.getter(name="sourceIpGroups")
    def source_ip_groups(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of source IP groups.
        """
        return pulumi.get(self, "source_ip_groups")


@pulumi.output_type
class FirewallPolicyRuleCollectionGroupApplicationRuleCollectionRuleProtocol(dict):
    def __init__(__self__, *,
                 port: int,
                 type: str):
        """
        :param int port: Port number of the protocol. Range is 0-64000.
        :param str type: Protocol type. Possible values are `Http` and `Https`.
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Port number of the protocol. Range is 0-64000.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Protocol type. Possible values are `Http` and `Https`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class FirewallPolicyRuleCollectionGroupNatRuleCollection(dict):
    def __init__(__self__, *,
                 action: str,
                 name: str,
                 priority: int,
                 rules: Sequence['outputs.FirewallPolicyRuleCollectionGroupNatRuleCollectionRule']):
        """
        :param str action: The action to take for the nat rules in this collection. Currently, the only possible value is `Dnat`.
        :param str name: The name which should be used for this nat rule collection.
        :param int priority: The priority of the nat rule collection. The range is `100` - `65000`.
        :param Sequence['FirewallPolicyRuleCollectionGroupNatRuleCollectionRuleArgs'] rules: A `rule` (nat rule) block as defined above.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action to take for the nat rules in this collection. Currently, the only possible value is `Dnat`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this nat rule collection.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        The priority of the nat rule collection. The range is `100` - `65000`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.FirewallPolicyRuleCollectionGroupNatRuleCollectionRule']:
        """
        A `rule` (nat rule) block as defined above.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class FirewallPolicyRuleCollectionGroupNatRuleCollectionRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "translatedAddress":
            suggest = "translated_address"
        elif key == "translatedPort":
            suggest = "translated_port"
        elif key == "destinationAddress":
            suggest = "destination_address"
        elif key == "destinationPorts":
            suggest = "destination_ports"
        elif key == "sourceAddresses":
            suggest = "source_addresses"
        elif key == "sourceIpGroups":
            suggest = "source_ip_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyRuleCollectionGroupNatRuleCollectionRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyRuleCollectionGroupNatRuleCollectionRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyRuleCollectionGroupNatRuleCollectionRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 protocols: Sequence[str],
                 translated_address: str,
                 translated_port: int,
                 destination_address: Optional[str] = None,
                 destination_ports: Optional[Sequence[str]] = None,
                 source_addresses: Optional[Sequence[str]] = None,
                 source_ip_groups: Optional[Sequence[str]] = None):
        """
        :param str name: The name which should be used for this rule.
        :param Sequence[str] protocols: Specifies a list of network protocols this rule applies to. Possible values are `TCP`, `UDP`.
        :param str translated_address: Specifies the translated address.
        :param int translated_port: Specifies the translated port.
        :param str destination_address: The destination IP address (including CIDR).
        :param Sequence[str] destination_ports: Specifies a list of destination ports.
        :param Sequence[str] source_addresses: Specifies a list of source IP addresses (including CIDR and `*`).
        :param Sequence[str] source_ip_groups: Specifies a list of source IP groups.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "protocols", protocols)
        pulumi.set(__self__, "translated_address", translated_address)
        pulumi.set(__self__, "translated_port", translated_port)
        if destination_address is not None:
            pulumi.set(__self__, "destination_address", destination_address)
        if destination_ports is not None:
            pulumi.set(__self__, "destination_ports", destination_ports)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_ip_groups is not None:
            pulumi.set(__self__, "source_ip_groups", source_ip_groups)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def protocols(self) -> Sequence[str]:
        """
        Specifies a list of network protocols this rule applies to. Possible values are `TCP`, `UDP`.
        """
        return pulumi.get(self, "protocols")

    @property
    @pulumi.getter(name="translatedAddress")
    def translated_address(self) -> str:
        """
        Specifies the translated address.
        """
        return pulumi.get(self, "translated_address")

    @property
    @pulumi.getter(name="translatedPort")
    def translated_port(self) -> int:
        """
        Specifies the translated port.
        """
        return pulumi.get(self, "translated_port")

    @property
    @pulumi.getter(name="destinationAddress")
    def destination_address(self) -> Optional[str]:
        """
        The destination IP address (including CIDR).
        """
        return pulumi.get(self, "destination_address")

    @property
    @pulumi.getter(name="destinationPorts")
    def destination_ports(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of destination ports.
        """
        return pulumi.get(self, "destination_ports")

    @property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of source IP addresses (including CIDR and `*`).
        """
        return pulumi.get(self, "source_addresses")

    @property
    @pulumi.getter(name="sourceIpGroups")
    def source_ip_groups(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of source IP groups.
        """
        return pulumi.get(self, "source_ip_groups")


@pulumi.output_type
class FirewallPolicyRuleCollectionGroupNetworkRuleCollection(dict):
    def __init__(__self__, *,
                 action: str,
                 name: str,
                 priority: int,
                 rules: Sequence['outputs.FirewallPolicyRuleCollectionGroupNetworkRuleCollectionRule']):
        """
        :param str action: The action to take for the network rules in this collection. Possible values are `Allow` and `Deny`.
        :param str name: The name which should be used for this network rule collection.
        :param int priority: The priority of the network rule collection. The range is `100` - `65000`.
        :param Sequence['FirewallPolicyRuleCollectionGroupNetworkRuleCollectionRuleArgs'] rules: One or more `rule` (network rule) blocks as defined above.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action to take for the network rules in this collection. Possible values are `Allow` and `Deny`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this network rule collection.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        The priority of the network rule collection. The range is `100` - `65000`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.FirewallPolicyRuleCollectionGroupNetworkRuleCollectionRule']:
        """
        One or more `rule` (network rule) blocks as defined above.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class FirewallPolicyRuleCollectionGroupNetworkRuleCollectionRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationPorts":
            suggest = "destination_ports"
        elif key == "destinationAddresses":
            suggest = "destination_addresses"
        elif key == "destinationFqdns":
            suggest = "destination_fqdns"
        elif key == "destinationIpGroups":
            suggest = "destination_ip_groups"
        elif key == "sourceAddresses":
            suggest = "source_addresses"
        elif key == "sourceIpGroups":
            suggest = "source_ip_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyRuleCollectionGroupNetworkRuleCollectionRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyRuleCollectionGroupNetworkRuleCollectionRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyRuleCollectionGroupNetworkRuleCollectionRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_ports: Sequence[str],
                 name: str,
                 protocols: Sequence[str],
                 destination_addresses: Optional[Sequence[str]] = None,
                 destination_fqdns: Optional[Sequence[str]] = None,
                 destination_ip_groups: Optional[Sequence[str]] = None,
                 source_addresses: Optional[Sequence[str]] = None,
                 source_ip_groups: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] destination_ports: Specifies a list of destination ports.
        :param str name: The name which should be used for this rule.
        :param Sequence[str] protocols: Specifies a list of network protocols this rule applies to. Possible values are `TCP`, `UDP`.
        :param Sequence[str] destination_addresses: Specifies a list of destination IP addresses (including CIDR and `*`) or Service Tags.
        :param Sequence[str] destination_fqdns: Specifies a list of destination FQDNs.
        :param Sequence[str] destination_ip_groups: Specifies a list of destination IP groups.
        :param Sequence[str] source_addresses: Specifies a list of source IP addresses (including CIDR and `*`).
        :param Sequence[str] source_ip_groups: Specifies a list of source IP groups.
        """
        pulumi.set(__self__, "destination_ports", destination_ports)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "protocols", protocols)
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if destination_fqdns is not None:
            pulumi.set(__self__, "destination_fqdns", destination_fqdns)
        if destination_ip_groups is not None:
            pulumi.set(__self__, "destination_ip_groups", destination_ip_groups)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_ip_groups is not None:
            pulumi.set(__self__, "source_ip_groups", source_ip_groups)

    @property
    @pulumi.getter(name="destinationPorts")
    def destination_ports(self) -> Sequence[str]:
        """
        Specifies a list of destination ports.
        """
        return pulumi.get(self, "destination_ports")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def protocols(self) -> Sequence[str]:
        """
        Specifies a list of network protocols this rule applies to. Possible values are `TCP`, `UDP`.
        """
        return pulumi.get(self, "protocols")

    @property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of destination IP addresses (including CIDR and `*`) or Service Tags.
        """
        return pulumi.get(self, "destination_addresses")

    @property
    @pulumi.getter(name="destinationFqdns")
    def destination_fqdns(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of destination FQDNs.
        """
        return pulumi.get(self, "destination_fqdns")

    @property
    @pulumi.getter(name="destinationIpGroups")
    def destination_ip_groups(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of destination IP groups.
        """
        return pulumi.get(self, "destination_ip_groups")

    @property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of source IP addresses (including CIDR and `*`).
        """
        return pulumi.get(self, "source_addresses")

    @property
    @pulumi.getter(name="sourceIpGroups")
    def source_ip_groups(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of source IP groups.
        """
        return pulumi.get(self, "source_ip_groups")


@pulumi.output_type
class FirewallPolicyThreatIntelligenceAllowlist(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddresses":
            suggest = "ip_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyThreatIntelligenceAllowlist. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyThreatIntelligenceAllowlist.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyThreatIntelligenceAllowlist.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fqdns: Optional[Sequence[str]] = None,
                 ip_addresses: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] fqdns: A list of FQDNs that will be skipped for threat detection.
        :param Sequence[str] ip_addresses: A list of IP addresses or IP address ranges that will be skipped for threat detection.
        """
        if fqdns is not None:
            pulumi.set(__self__, "fqdns", fqdns)
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)

    @property
    @pulumi.getter
    def fqdns(self) -> Optional[Sequence[str]]:
        """
        A list of FQDNs that will be skipped for threat detection.
        """
        return pulumi.get(self, "fqdns")

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[Sequence[str]]:
        """
        A list of IP addresses or IP address ranges that will be skipped for threat detection.
        """
        return pulumi.get(self, "ip_addresses")


@pulumi.output_type
class FirewallVirtualHub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "virtualHubId":
            suggest = "virtual_hub_id"
        elif key == "privateIpAddress":
            suggest = "private_ip_address"
        elif key == "publicIpAddresses":
            suggest = "public_ip_addresses"
        elif key == "publicIpCount":
            suggest = "public_ip_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallVirtualHub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallVirtualHub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallVirtualHub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 virtual_hub_id: str,
                 private_ip_address: Optional[str] = None,
                 public_ip_addresses: Optional[Sequence[str]] = None,
                 public_ip_count: Optional[int] = None):
        """
        :param str virtual_hub_id: Specifies the ID of the Virtual Hub where the Firewall resides in.
        :param str private_ip_address: The private IP address associated with the Firewall.
        :param Sequence[str] public_ip_addresses: The list of public IP addresses associated with the Firewall.
        :param int public_ip_count: Specifies the number of public IPs to assign to the Firewall. Defaults to `1`.
        """
        pulumi.set(__self__, "virtual_hub_id", virtual_hub_id)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)
        if public_ip_addresses is not None:
            pulumi.set(__self__, "public_ip_addresses", public_ip_addresses)
        if public_ip_count is not None:
            pulumi.set(__self__, "public_ip_count", public_ip_count)

    @property
    @pulumi.getter(name="virtualHubId")
    def virtual_hub_id(self) -> str:
        """
        Specifies the ID of the Virtual Hub where the Firewall resides in.
        """
        return pulumi.get(self, "virtual_hub_id")

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> Optional[str]:
        """
        The private IP address associated with the Firewall.
        """
        return pulumi.get(self, "private_ip_address")

    @property
    @pulumi.getter(name="publicIpAddresses")
    def public_ip_addresses(self) -> Optional[Sequence[str]]:
        """
        The list of public IP addresses associated with the Firewall.
        """
        return pulumi.get(self, "public_ip_addresses")

    @property
    @pulumi.getter(name="publicIpCount")
    def public_ip_count(self) -> Optional[int]:
        """
        Specifies the number of public IPs to assign to the Firewall. Defaults to `1`.
        """
        return pulumi.get(self, "public_ip_count")


@pulumi.output_type
class LocalNetworkGatewayBgpSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bgpPeeringAddress":
            suggest = "bgp_peering_address"
        elif key == "peerWeight":
            suggest = "peer_weight"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LocalNetworkGatewayBgpSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LocalNetworkGatewayBgpSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LocalNetworkGatewayBgpSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 asn: int,
                 bgp_peering_address: str,
                 peer_weight: Optional[int] = None):
        """
        :param int asn: The BGP speaker's ASN.
        :param str bgp_peering_address: The BGP peering address and BGP identifier
               of this BGP speaker.
        :param int peer_weight: The weight added to routes learned from this
               BGP speaker.
        """
        pulumi.set(__self__, "asn", asn)
        pulumi.set(__self__, "bgp_peering_address", bgp_peering_address)
        if peer_weight is not None:
            pulumi.set(__self__, "peer_weight", peer_weight)

    @property
    @pulumi.getter
    def asn(self) -> int:
        """
        The BGP speaker's ASN.
        """
        return pulumi.get(self, "asn")

    @property
    @pulumi.getter(name="bgpPeeringAddress")
    def bgp_peering_address(self) -> str:
        """
        The BGP peering address and BGP identifier
        of this BGP speaker.
        """
        return pulumi.get(self, "bgp_peering_address")

    @property
    @pulumi.getter(name="peerWeight")
    def peer_weight(self) -> Optional[int]:
        """
        The weight added to routes learned from this
        BGP speaker.
        """
        return pulumi.get(self, "peer_weight")


@pulumi.output_type
class NetworkConnectionMonitorDestination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "virtualMachineId":
            suggest = "virtual_machine_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkConnectionMonitorDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkConnectionMonitorDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkConnectionMonitorDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[str] = None,
                 port: Optional[int] = None,
                 virtual_machine_id: Optional[str] = None):
        """
        :param str address: The IP address or domain name of the Network Connection Monitor endpoint.
        :param int port: The port for the HTTP connection.
        :param str virtual_machine_id: The ID of the Virtual Machine which is used as the endpoint by the Network Connection Monitor. This property is deprecated in favour of `target_resource_id`.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if virtual_machine_id is not None:
            pulumi.set(__self__, "virtual_machine_id", virtual_machine_id)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        The IP address or domain name of the Network Connection Monitor endpoint.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port for the HTTP connection.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="virtualMachineId")
    def virtual_machine_id(self) -> Optional[str]:
        """
        The ID of the Virtual Machine which is used as the endpoint by the Network Connection Monitor. This property is deprecated in favour of `target_resource_id`.
        """
        return pulumi.get(self, "virtual_machine_id")


@pulumi.output_type
class NetworkConnectionMonitorEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "coverageLevel":
            suggest = "coverage_level"
        elif key == "excludedIpAddresses":
            suggest = "excluded_ip_addresses"
        elif key == "includedIpAddresses":
            suggest = "included_ip_addresses"
        elif key == "targetResourceId":
            suggest = "target_resource_id"
        elif key == "targetResourceType":
            suggest = "target_resource_type"
        elif key == "virtualMachineId":
            suggest = "virtual_machine_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkConnectionMonitorEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkConnectionMonitorEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkConnectionMonitorEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 address: Optional[str] = None,
                 coverage_level: Optional[str] = None,
                 excluded_ip_addresses: Optional[Sequence[str]] = None,
                 filter: Optional['outputs.NetworkConnectionMonitorEndpointFilter'] = None,
                 included_ip_addresses: Optional[Sequence[str]] = None,
                 target_resource_id: Optional[str] = None,
                 target_resource_type: Optional[str] = None,
                 virtual_machine_id: Optional[str] = None):
        """
        :param str name: The name of the endpoint for the Network Connection Monitor .
        :param str address: The IP address or domain name of the Network Connection Monitor endpoint.
        :param str coverage_level: The test coverage for the Network Connection Monitor endpoint. Possible values are `AboveAverage`, `Average`, `BelowAverage`, `Default`, `Full` and `Low`.
        :param Sequence[str] excluded_ip_addresses: A list of IPv4/IPv6 subnet masks or IPv4/IPv6 IP addresses to be excluded to the Network Connection Monitor endpoint.
        :param 'NetworkConnectionMonitorEndpointFilterArgs' filter: A `filter` block as defined below.
        :param Sequence[str] included_ip_addresses: A list of IPv4/IPv6 subnet masks or IPv4/IPv6 IP addresses to be included to the Network Connection Monitor endpoint.
        :param str target_resource_id: The resource ID which is used as the endpoint by the Network Connection Monitor.
        :param str target_resource_type: The endpoint type of the Network Connection Monitor. Possible values are `AzureSubnet`, `AzureVM`, `AzureVNet`, `ExternalAddress`, `MMAWorkspaceMachine` and `MMAWorkspaceNetwork`.
        :param str virtual_machine_id: The ID of the Virtual Machine which is used as the endpoint by the Network Connection Monitor. This property is deprecated in favour of `target_resource_id`.
        """
        pulumi.set(__self__, "name", name)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if coverage_level is not None:
            pulumi.set(__self__, "coverage_level", coverage_level)
        if excluded_ip_addresses is not None:
            pulumi.set(__self__, "excluded_ip_addresses", excluded_ip_addresses)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if included_ip_addresses is not None:
            pulumi.set(__self__, "included_ip_addresses", included_ip_addresses)
        if target_resource_id is not None:
            pulumi.set(__self__, "target_resource_id", target_resource_id)
        if target_resource_type is not None:
            pulumi.set(__self__, "target_resource_type", target_resource_type)
        if virtual_machine_id is not None:
            pulumi.set(__self__, "virtual_machine_id", virtual_machine_id)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the endpoint for the Network Connection Monitor .
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        The IP address or domain name of the Network Connection Monitor endpoint.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="coverageLevel")
    def coverage_level(self) -> Optional[str]:
        """
        The test coverage for the Network Connection Monitor endpoint. Possible values are `AboveAverage`, `Average`, `BelowAverage`, `Default`, `Full` and `Low`.
        """
        return pulumi.get(self, "coverage_level")

    @property
    @pulumi.getter(name="excludedIpAddresses")
    def excluded_ip_addresses(self) -> Optional[Sequence[str]]:
        """
        A list of IPv4/IPv6 subnet masks or IPv4/IPv6 IP addresses to be excluded to the Network Connection Monitor endpoint.
        """
        return pulumi.get(self, "excluded_ip_addresses")

    @property
    @pulumi.getter
    def filter(self) -> Optional['outputs.NetworkConnectionMonitorEndpointFilter']:
        """
        A `filter` block as defined below.
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter(name="includedIpAddresses")
    def included_ip_addresses(self) -> Optional[Sequence[str]]:
        """
        A list of IPv4/IPv6 subnet masks or IPv4/IPv6 IP addresses to be included to the Network Connection Monitor endpoint.
        """
        return pulumi.get(self, "included_ip_addresses")

    @property
    @pulumi.getter(name="targetResourceId")
    def target_resource_id(self) -> Optional[str]:
        """
        The resource ID which is used as the endpoint by the Network Connection Monitor.
        """
        return pulumi.get(self, "target_resource_id")

    @property
    @pulumi.getter(name="targetResourceType")
    def target_resource_type(self) -> Optional[str]:
        """
        The endpoint type of the Network Connection Monitor. Possible values are `AzureSubnet`, `AzureVM`, `AzureVNet`, `ExternalAddress`, `MMAWorkspaceMachine` and `MMAWorkspaceNetwork`.
        """
        return pulumi.get(self, "target_resource_type")

    @property
    @pulumi.getter(name="virtualMachineId")
    def virtual_machine_id(self) -> Optional[str]:
        """
        The ID of the Virtual Machine which is used as the endpoint by the Network Connection Monitor. This property is deprecated in favour of `target_resource_id`.
        """
        return pulumi.get(self, "virtual_machine_id")


@pulumi.output_type
class NetworkConnectionMonitorEndpointFilter(dict):
    def __init__(__self__, *,
                 items: Optional[Sequence['outputs.NetworkConnectionMonitorEndpointFilterItem']] = None,
                 type: Optional[str] = None):
        """
        :param Sequence['NetworkConnectionMonitorEndpointFilterItemArgs'] items: A `item` block as defined below.
        :param str type: The behaviour type of this endpoint filter. Currently the only allowed value is `Include`. Defaults to `Include`.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.NetworkConnectionMonitorEndpointFilterItem']]:
        """
        A `item` block as defined below.
        """
        return pulumi.get(self, "items")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The behaviour type of this endpoint filter. Currently the only allowed value is `Include`. Defaults to `Include`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class NetworkConnectionMonitorEndpointFilterItem(dict):
    def __init__(__self__, *,
                 address: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str address: The address of the filter item.
        :param str type: The type of items included in the filter. Possible values are `AgentAddress`. Defaults to `AgentAddress`.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        The address of the filter item.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of items included in the filter. Possible values are `AgentAddress`. Defaults to `AgentAddress`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class NetworkConnectionMonitorSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "virtualMachineId":
            suggest = "virtual_machine_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkConnectionMonitorSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkConnectionMonitorSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkConnectionMonitorSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port: Optional[int] = None,
                 virtual_machine_id: Optional[str] = None):
        """
        :param int port: The port for the HTTP connection.
        :param str virtual_machine_id: The ID of the Virtual Machine which is used as the endpoint by the Network Connection Monitor. This property is deprecated in favour of `target_resource_id`.
        """
        if port is not None:
            pulumi.set(__self__, "port", port)
        if virtual_machine_id is not None:
            pulumi.set(__self__, "virtual_machine_id", virtual_machine_id)

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port for the HTTP connection.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="virtualMachineId")
    def virtual_machine_id(self) -> Optional[str]:
        """
        The ID of the Virtual Machine which is used as the endpoint by the Network Connection Monitor. This property is deprecated in favour of `target_resource_id`.
        """
        return pulumi.get(self, "virtual_machine_id")


@pulumi.output_type
class NetworkConnectionMonitorTestConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpConfiguration":
            suggest = "http_configuration"
        elif key == "icmpConfiguration":
            suggest = "icmp_configuration"
        elif key == "preferredIpVersion":
            suggest = "preferred_ip_version"
        elif key == "successThreshold":
            suggest = "success_threshold"
        elif key == "tcpConfiguration":
            suggest = "tcp_configuration"
        elif key == "testFrequencyInSeconds":
            suggest = "test_frequency_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkConnectionMonitorTestConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkConnectionMonitorTestConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkConnectionMonitorTestConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 protocol: str,
                 http_configuration: Optional['outputs.NetworkConnectionMonitorTestConfigurationHttpConfiguration'] = None,
                 icmp_configuration: Optional['outputs.NetworkConnectionMonitorTestConfigurationIcmpConfiguration'] = None,
                 preferred_ip_version: Optional[str] = None,
                 success_threshold: Optional['outputs.NetworkConnectionMonitorTestConfigurationSuccessThreshold'] = None,
                 tcp_configuration: Optional['outputs.NetworkConnectionMonitorTestConfigurationTcpConfiguration'] = None,
                 test_frequency_in_seconds: Optional[int] = None):
        """
        :param str name: The name of test configuration for the Network Connection Monitor.
        :param str protocol: The protocol used to evaluate tests. Possible values are `Tcp`, `Http` and `Icmp`.
        :param 'NetworkConnectionMonitorTestConfigurationHttpConfigurationArgs' http_configuration: A `http_configuration` block as defined below.
        :param 'NetworkConnectionMonitorTestConfigurationIcmpConfigurationArgs' icmp_configuration: A `icmp_configuration` block as defined below.
        :param str preferred_ip_version: The preferred IP version which is used in the test evaluation. Possible values are `IPv4` and `IPv6`.
        :param 'NetworkConnectionMonitorTestConfigurationSuccessThresholdArgs' success_threshold: A `success_threshold` block as defined below.
        :param 'NetworkConnectionMonitorTestConfigurationTcpConfigurationArgs' tcp_configuration: A `tcp_configuration` block as defined below.
        :param int test_frequency_in_seconds: The time interval in seconds at which the test evaluation will happen. Defaults to `60`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "protocol", protocol)
        if http_configuration is not None:
            pulumi.set(__self__, "http_configuration", http_configuration)
        if icmp_configuration is not None:
            pulumi.set(__self__, "icmp_configuration", icmp_configuration)
        if preferred_ip_version is not None:
            pulumi.set(__self__, "preferred_ip_version", preferred_ip_version)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if tcp_configuration is not None:
            pulumi.set(__self__, "tcp_configuration", tcp_configuration)
        if test_frequency_in_seconds is not None:
            pulumi.set(__self__, "test_frequency_in_seconds", test_frequency_in_seconds)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of test configuration for the Network Connection Monitor.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The protocol used to evaluate tests. Possible values are `Tcp`, `Http` and `Icmp`.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="httpConfiguration")
    def http_configuration(self) -> Optional['outputs.NetworkConnectionMonitorTestConfigurationHttpConfiguration']:
        """
        A `http_configuration` block as defined below.
        """
        return pulumi.get(self, "http_configuration")

    @property
    @pulumi.getter(name="icmpConfiguration")
    def icmp_configuration(self) -> Optional['outputs.NetworkConnectionMonitorTestConfigurationIcmpConfiguration']:
        """
        A `icmp_configuration` block as defined below.
        """
        return pulumi.get(self, "icmp_configuration")

    @property
    @pulumi.getter(name="preferredIpVersion")
    def preferred_ip_version(self) -> Optional[str]:
        """
        The preferred IP version which is used in the test evaluation. Possible values are `IPv4` and `IPv6`.
        """
        return pulumi.get(self, "preferred_ip_version")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional['outputs.NetworkConnectionMonitorTestConfigurationSuccessThreshold']:
        """
        A `success_threshold` block as defined below.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="tcpConfiguration")
    def tcp_configuration(self) -> Optional['outputs.NetworkConnectionMonitorTestConfigurationTcpConfiguration']:
        """
        A `tcp_configuration` block as defined below.
        """
        return pulumi.get(self, "tcp_configuration")

    @property
    @pulumi.getter(name="testFrequencyInSeconds")
    def test_frequency_in_seconds(self) -> Optional[int]:
        """
        The time interval in seconds at which the test evaluation will happen. Defaults to `60`.
        """
        return pulumi.get(self, "test_frequency_in_seconds")


@pulumi.output_type
class NetworkConnectionMonitorTestConfigurationHttpConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "preferHttps":
            suggest = "prefer_https"
        elif key == "requestHeaders":
            suggest = "request_headers"
        elif key == "validStatusCodeRanges":
            suggest = "valid_status_code_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkConnectionMonitorTestConfigurationHttpConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkConnectionMonitorTestConfigurationHttpConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkConnectionMonitorTestConfigurationHttpConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: Optional[str] = None,
                 path: Optional[str] = None,
                 port: Optional[int] = None,
                 prefer_https: Optional[bool] = None,
                 request_headers: Optional[Sequence['outputs.NetworkConnectionMonitorTestConfigurationHttpConfigurationRequestHeader']] = None,
                 valid_status_code_ranges: Optional[Sequence[str]] = None):
        """
        :param str method: The HTTP method for the HTTP request. Possible values are `Get` and `Post`. Defaults to `Get`.
        :param str path: The path component of the URI. It only accepts the absolute path.
        :param int port: The port for the HTTP connection.
        :param bool prefer_https: Should HTTPS be preferred over HTTP in cases where the choice is not explicit? Defaults to `false`.
        :param Sequence['NetworkConnectionMonitorTestConfigurationHttpConfigurationRequestHeaderArgs'] request_headers: A `request_header` block as defined below.
        :param Sequence[str] valid_status_code_ranges: The HTTP status codes to consider successful. For instance, `2xx`, `301-304` and `418`.
        """
        if method is not None:
            pulumi.set(__self__, "method", method)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if prefer_https is not None:
            pulumi.set(__self__, "prefer_https", prefer_https)
        if request_headers is not None:
            pulumi.set(__self__, "request_headers", request_headers)
        if valid_status_code_ranges is not None:
            pulumi.set(__self__, "valid_status_code_ranges", valid_status_code_ranges)

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        """
        The HTTP method for the HTTP request. Possible values are `Get` and `Post`. Defaults to `Get`.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path component of the URI. It only accepts the absolute path.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port for the HTTP connection.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="preferHttps")
    def prefer_https(self) -> Optional[bool]:
        """
        Should HTTPS be preferred over HTTP in cases where the choice is not explicit? Defaults to `false`.
        """
        return pulumi.get(self, "prefer_https")

    @property
    @pulumi.getter(name="requestHeaders")
    def request_headers(self) -> Optional[Sequence['outputs.NetworkConnectionMonitorTestConfigurationHttpConfigurationRequestHeader']]:
        """
        A `request_header` block as defined below.
        """
        return pulumi.get(self, "request_headers")

    @property
    @pulumi.getter(name="validStatusCodeRanges")
    def valid_status_code_ranges(self) -> Optional[Sequence[str]]:
        """
        The HTTP status codes to consider successful. For instance, `2xx`, `301-304` and `418`.
        """
        return pulumi.get(self, "valid_status_code_ranges")


@pulumi.output_type
class NetworkConnectionMonitorTestConfigurationHttpConfigurationRequestHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: The name of the HTTP header.
        :param str value: The value of the HTTP header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the HTTP header.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the HTTP header.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NetworkConnectionMonitorTestConfigurationIcmpConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "traceRouteEnabled":
            suggest = "trace_route_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkConnectionMonitorTestConfigurationIcmpConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkConnectionMonitorTestConfigurationIcmpConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkConnectionMonitorTestConfigurationIcmpConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 trace_route_enabled: Optional[bool] = None):
        """
        :param bool trace_route_enabled: Should path evaluation with trace route be enabled? Defaults to `true`.
        """
        if trace_route_enabled is not None:
            pulumi.set(__self__, "trace_route_enabled", trace_route_enabled)

    @property
    @pulumi.getter(name="traceRouteEnabled")
    def trace_route_enabled(self) -> Optional[bool]:
        """
        Should path evaluation with trace route be enabled? Defaults to `true`.
        """
        return pulumi.get(self, "trace_route_enabled")


@pulumi.output_type
class NetworkConnectionMonitorTestConfigurationSuccessThreshold(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checksFailedPercent":
            suggest = "checks_failed_percent"
        elif key == "roundTripTimeMs":
            suggest = "round_trip_time_ms"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkConnectionMonitorTestConfigurationSuccessThreshold. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkConnectionMonitorTestConfigurationSuccessThreshold.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkConnectionMonitorTestConfigurationSuccessThreshold.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 checks_failed_percent: Optional[int] = None,
                 round_trip_time_ms: Optional[float] = None):
        """
        :param int checks_failed_percent: The maximum percentage of failed checks permitted for a test to be successful.
        :param float round_trip_time_ms: The maximum round-trip time in milliseconds permitted for a test to be successful.
        """
        if checks_failed_percent is not None:
            pulumi.set(__self__, "checks_failed_percent", checks_failed_percent)
        if round_trip_time_ms is not None:
            pulumi.set(__self__, "round_trip_time_ms", round_trip_time_ms)

    @property
    @pulumi.getter(name="checksFailedPercent")
    def checks_failed_percent(self) -> Optional[int]:
        """
        The maximum percentage of failed checks permitted for a test to be successful.
        """
        return pulumi.get(self, "checks_failed_percent")

    @property
    @pulumi.getter(name="roundTripTimeMs")
    def round_trip_time_ms(self) -> Optional[float]:
        """
        The maximum round-trip time in milliseconds permitted for a test to be successful.
        """
        return pulumi.get(self, "round_trip_time_ms")


@pulumi.output_type
class NetworkConnectionMonitorTestConfigurationTcpConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "traceRouteEnabled":
            suggest = "trace_route_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkConnectionMonitorTestConfigurationTcpConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkConnectionMonitorTestConfigurationTcpConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkConnectionMonitorTestConfigurationTcpConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port: int,
                 trace_route_enabled: Optional[bool] = None):
        """
        :param int port: The port for the Tcp connection.
        :param bool trace_route_enabled: Should path evaluation with trace route be enabled? Defaults to `true`.
        """
        pulumi.set(__self__, "port", port)
        if trace_route_enabled is not None:
            pulumi.set(__self__, "trace_route_enabled", trace_route_enabled)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port for the Tcp connection.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="traceRouteEnabled")
    def trace_route_enabled(self) -> Optional[bool]:
        """
        Should path evaluation with trace route be enabled? Defaults to `true`.
        """
        return pulumi.get(self, "trace_route_enabled")


@pulumi.output_type
class NetworkConnectionMonitorTestGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationEndpoints":
            suggest = "destination_endpoints"
        elif key == "sourceEndpoints":
            suggest = "source_endpoints"
        elif key == "testConfigurationNames":
            suggest = "test_configuration_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkConnectionMonitorTestGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkConnectionMonitorTestGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkConnectionMonitorTestGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_endpoints: Sequence[str],
                 name: str,
                 source_endpoints: Sequence[str],
                 test_configuration_names: Sequence[str],
                 enabled: Optional[bool] = None):
        """
        :param Sequence[str] destination_endpoints: A list of destination endpoint names.
        :param str name: The name of the test group for the Network Connection Monitor.
        :param Sequence[str] source_endpoints: A list of source endpoint names.
        :param Sequence[str] test_configuration_names: A list of test configuration names.
        :param bool enabled: Should the test group be enabled? Defaults to `true`.
        """
        pulumi.set(__self__, "destination_endpoints", destination_endpoints)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "source_endpoints", source_endpoints)
        pulumi.set(__self__, "test_configuration_names", test_configuration_names)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="destinationEndpoints")
    def destination_endpoints(self) -> Sequence[str]:
        """
        A list of destination endpoint names.
        """
        return pulumi.get(self, "destination_endpoints")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the test group for the Network Connection Monitor.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sourceEndpoints")
    def source_endpoints(self) -> Sequence[str]:
        """
        A list of source endpoint names.
        """
        return pulumi.get(self, "source_endpoints")

    @property
    @pulumi.getter(name="testConfigurationNames")
    def test_configuration_names(self) -> Sequence[str]:
        """
        A list of test configuration names.
        """
        return pulumi.get(self, "test_configuration_names")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Should the test group be enabled? Defaults to `true`.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class NetworkInterfaceIpConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateIpAddressAllocation":
            suggest = "private_ip_address_allocation"
        elif key == "privateIpAddress":
            suggest = "private_ip_address"
        elif key == "privateIpAddressVersion":
            suggest = "private_ip_address_version"
        elif key == "publicIpAddressId":
            suggest = "public_ip_address_id"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInterfaceIpConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInterfaceIpConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInterfaceIpConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 private_ip_address_allocation: str,
                 primary: Optional[bool] = None,
                 private_ip_address: Optional[str] = None,
                 private_ip_address_version: Optional[str] = None,
                 public_ip_address_id: Optional[str] = None,
                 subnet_id: Optional[str] = None):
        """
        :param str name: A name used for this IP Configuration.
        :param str private_ip_address_allocation: The allocation method used for the Private IP Address. Possible values are `Dynamic` and `Static`.
        :param bool primary: Is this the Primary IP Configuration? Must be `true` for the first `ip_configuration` when multiple are specified. Defaults to `false`.
        :param str private_ip_address: The Static IP Address which should be used.
        :param str private_ip_address_version: The IP Version to use. Possible values are `IPv4` or `IPv6`. Defaults to `IPv4`.
        :param str public_ip_address_id: Reference to a Public IP Address to associate with this NIC
        :param str subnet_id: The ID of the Subnet where this Network Interface should be located in.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "private_ip_address_allocation", private_ip_address_allocation)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)
        if private_ip_address_version is not None:
            pulumi.set(__self__, "private_ip_address_version", private_ip_address_version)
        if public_ip_address_id is not None:
            pulumi.set(__self__, "public_ip_address_id", public_ip_address_id)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A name used for this IP Configuration.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateIpAddressAllocation")
    def private_ip_address_allocation(self) -> str:
        """
        The allocation method used for the Private IP Address. Possible values are `Dynamic` and `Static`.
        """
        return pulumi.get(self, "private_ip_address_allocation")

    @property
    @pulumi.getter
    def primary(self) -> Optional[bool]:
        """
        Is this the Primary IP Configuration? Must be `true` for the first `ip_configuration` when multiple are specified. Defaults to `false`.
        """
        return pulumi.get(self, "primary")

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> Optional[str]:
        """
        The Static IP Address which should be used.
        """
        return pulumi.get(self, "private_ip_address")

    @property
    @pulumi.getter(name="privateIpAddressVersion")
    def private_ip_address_version(self) -> Optional[str]:
        """
        The IP Version to use. Possible values are `IPv4` or `IPv6`. Defaults to `IPv4`.
        """
        return pulumi.get(self, "private_ip_address_version")

    @property
    @pulumi.getter(name="publicIpAddressId")
    def public_ip_address_id(self) -> Optional[str]:
        """
        Reference to a Public IP Address to associate with this NIC
        """
        return pulumi.get(self, "public_ip_address_id")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The ID of the Subnet where this Network Interface should be located in.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class NetworkPacketCaptureFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localIpAddress":
            suggest = "local_ip_address"
        elif key == "localPort":
            suggest = "local_port"
        elif key == "remoteIpAddress":
            suggest = "remote_ip_address"
        elif key == "remotePort":
            suggest = "remote_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkPacketCaptureFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkPacketCaptureFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkPacketCaptureFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 protocol: str,
                 local_ip_address: Optional[str] = None,
                 local_port: Optional[str] = None,
                 remote_ip_address: Optional[str] = None,
                 remote_port: Optional[str] = None):
        """
        :param str protocol: The Protocol to be filtered on. Possible values include `Any`, `TCP` and `UDP`. Changing this forces a new resource to be created.
        :param str local_ip_address: The local IP Address to be filtered on. Notation: "127.0.0.1" for single address entry. "127.0.0.1-127.0.0.255" for range. "127.0.0.1;127.0.0.5" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported. Changing this forces a new resource to be created.
        :param str local_port: The local port to be filtered on. Notation: "80" for single port entry."80-85" for range. "80;443;" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported. Changing this forces a new resource to be created.
        :param str remote_ip_address: The remote IP Address to be filtered on. Notation: "127.0.0.1" for single address entry. "127.0.0.1-127.0.0.255" for range. "127.0.0.1;127.0.0.5;" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported.. Changing this forces a new resource to be created.
        :param str remote_port: The remote port to be filtered on. Notation: "80" for single port entry."80-85" for range. "80;443;" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "protocol", protocol)
        if local_ip_address is not None:
            pulumi.set(__self__, "local_ip_address", local_ip_address)
        if local_port is not None:
            pulumi.set(__self__, "local_port", local_port)
        if remote_ip_address is not None:
            pulumi.set(__self__, "remote_ip_address", remote_ip_address)
        if remote_port is not None:
            pulumi.set(__self__, "remote_port", remote_port)

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The Protocol to be filtered on. Possible values include `Any`, `TCP` and `UDP`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="localIpAddress")
    def local_ip_address(self) -> Optional[str]:
        """
        The local IP Address to be filtered on. Notation: "127.0.0.1" for single address entry. "127.0.0.1-127.0.0.255" for range. "127.0.0.1;127.0.0.5" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "local_ip_address")

    @property
    @pulumi.getter(name="localPort")
    def local_port(self) -> Optional[str]:
        """
        The local port to be filtered on. Notation: "80" for single port entry."80-85" for range. "80;443;" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "local_port")

    @property
    @pulumi.getter(name="remoteIpAddress")
    def remote_ip_address(self) -> Optional[str]:
        """
        The remote IP Address to be filtered on. Notation: "127.0.0.1" for single address entry. "127.0.0.1-127.0.0.255" for range. "127.0.0.1;127.0.0.5;" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported.. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "remote_ip_address")

    @property
    @pulumi.getter(name="remotePort")
    def remote_port(self) -> Optional[str]:
        """
        The remote port to be filtered on. Notation: "80" for single port entry."80-85" for range. "80;443;" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "remote_port")


@pulumi.output_type
class NetworkPacketCaptureStorageLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filePath":
            suggest = "file_path"
        elif key == "storageAccountId":
            suggest = "storage_account_id"
        elif key == "storagePath":
            suggest = "storage_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkPacketCaptureStorageLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkPacketCaptureStorageLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkPacketCaptureStorageLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_path: Optional[str] = None,
                 storage_account_id: Optional[str] = None,
                 storage_path: Optional[str] = None):
        """
        :param str file_path: A valid local path on the targeting VM. Must include the name of the capture file (*.cap). For linux virtual machine it must start with `/var/captures`.
        :param str storage_account_id: The ID of the storage account to save the packet capture session
        :param str storage_path: The URI of the storage path to save the packet capture.
        """
        if file_path is not None:
            pulumi.set(__self__, "file_path", file_path)
        if storage_account_id is not None:
            pulumi.set(__self__, "storage_account_id", storage_account_id)
        if storage_path is not None:
            pulumi.set(__self__, "storage_path", storage_path)

    @property
    @pulumi.getter(name="filePath")
    def file_path(self) -> Optional[str]:
        """
        A valid local path on the targeting VM. Must include the name of the capture file (*.cap). For linux virtual machine it must start with `/var/captures`.
        """
        return pulumi.get(self, "file_path")

    @property
    @pulumi.getter(name="storageAccountId")
    def storage_account_id(self) -> Optional[str]:
        """
        The ID of the storage account to save the packet capture session
        """
        return pulumi.get(self, "storage_account_id")

    @property
    @pulumi.getter(name="storagePath")
    def storage_path(self) -> Optional[str]:
        """
        The URI of the storage path to save the packet capture.
        """
        return pulumi.get(self, "storage_path")


@pulumi.output_type
class NetworkSecurityGroupSecurityRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationAddressPrefix":
            suggest = "destination_address_prefix"
        elif key == "destinationAddressPrefixes":
            suggest = "destination_address_prefixes"
        elif key == "destinationApplicationSecurityGroupIds":
            suggest = "destination_application_security_group_ids"
        elif key == "destinationPortRange":
            suggest = "destination_port_range"
        elif key == "destinationPortRanges":
            suggest = "destination_port_ranges"
        elif key == "sourceAddressPrefix":
            suggest = "source_address_prefix"
        elif key == "sourceAddressPrefixes":
            suggest = "source_address_prefixes"
        elif key == "sourceApplicationSecurityGroupIds":
            suggest = "source_application_security_group_ids"
        elif key == "sourcePortRange":
            suggest = "source_port_range"
        elif key == "sourcePortRanges":
            suggest = "source_port_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkSecurityGroupSecurityRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkSecurityGroupSecurityRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkSecurityGroupSecurityRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access: str,
                 direction: str,
                 name: str,
                 priority: int,
                 protocol: str,
                 description: Optional[str] = None,
                 destination_address_prefix: Optional[str] = None,
                 destination_address_prefixes: Optional[Sequence[str]] = None,
                 destination_application_security_group_ids: Optional[Sequence[str]] = None,
                 destination_port_range: Optional[str] = None,
                 destination_port_ranges: Optional[Sequence[str]] = None,
                 source_address_prefix: Optional[str] = None,
                 source_address_prefixes: Optional[Sequence[str]] = None,
                 source_application_security_group_ids: Optional[Sequence[str]] = None,
                 source_port_range: Optional[str] = None,
                 source_port_ranges: Optional[Sequence[str]] = None):
        """
        :param str access: Specifies whether network traffic is allowed or denied. Possible values are `Allow` and `Deny`.
        :param str direction: The direction specifies if rule will be evaluated on incoming or outgoing traffic. Possible values are `Inbound` and `Outbound`.
        :param str name: The name of the security rule.
        :param int priority: Specifies the priority of the rule. The value can be between 100 and 4096. The priority number must be unique for each rule in the collection. The lower the priority number, the higher the priority of the rule.
        :param str protocol: Network protocol this rule applies to. Can be `Tcp`, `Udp`, `Icmp`, or `*` to match all.
        :param str description: A description for this rule. Restricted to 140 characters.
        :param str destination_address_prefix: CIDR or destination IP range or * to match any IP. Tags such as ‘VirtualNetwork’, ‘AzureLoadBalancer’ and ‘Internet’ can also be used. This is required if `destination_address_prefixes` is not specified.
        :param Sequence[str] destination_address_prefixes: List of destination address prefixes. Tags may not be used. This is required if `destination_address_prefix` is not specified.
        :param Sequence[str] destination_application_security_group_ids: A List of destination Application Security Group ID's
        :param str destination_port_range: Destination Port or Range. Integer or range between `0` and `65535` or `*` to match any. This is required if `destination_port_ranges` is not specified.
        :param Sequence[str] destination_port_ranges: List of destination ports or port ranges. This is required if `destination_port_range` is not specified.
        :param str source_address_prefix: CIDR or source IP range or * to match any IP. Tags such as ‘VirtualNetwork’, ‘AzureLoadBalancer’ and ‘Internet’ can also be used. This is required if `source_address_prefixes` is not specified.
        :param Sequence[str] source_address_prefixes: List of source address prefixes. Tags may not be used. This is required if `source_address_prefix` is not specified.
        :param Sequence[str] source_application_security_group_ids: A List of source Application Security Group ID's
        :param str source_port_range: Source Port or Range. Integer or range between `0` and `65535` or `*` to match any. This is required if `source_port_ranges` is not specified.
        :param Sequence[str] source_port_ranges: List of source ports or port ranges. This is required if `source_port_range` is not specified.
        """
        pulumi.set(__self__, "access", access)
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "protocol", protocol)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if destination_address_prefix is not None:
            pulumi.set(__self__, "destination_address_prefix", destination_address_prefix)
        if destination_address_prefixes is not None:
            pulumi.set(__self__, "destination_address_prefixes", destination_address_prefixes)
        if destination_application_security_group_ids is not None:
            pulumi.set(__self__, "destination_application_security_group_ids", destination_application_security_group_ids)
        if destination_port_range is not None:
            pulumi.set(__self__, "destination_port_range", destination_port_range)
        if destination_port_ranges is not None:
            pulumi.set(__self__, "destination_port_ranges", destination_port_ranges)
        if source_address_prefix is not None:
            pulumi.set(__self__, "source_address_prefix", source_address_prefix)
        if source_address_prefixes is not None:
            pulumi.set(__self__, "source_address_prefixes", source_address_prefixes)
        if source_application_security_group_ids is not None:
            pulumi.set(__self__, "source_application_security_group_ids", source_application_security_group_ids)
        if source_port_range is not None:
            pulumi.set(__self__, "source_port_range", source_port_range)
        if source_port_ranges is not None:
            pulumi.set(__self__, "source_port_ranges", source_port_ranges)

    @property
    @pulumi.getter
    def access(self) -> str:
        """
        Specifies whether network traffic is allowed or denied. Possible values are `Allow` and `Deny`.
        """
        return pulumi.get(self, "access")

    @property
    @pulumi.getter
    def direction(self) -> str:
        """
        The direction specifies if rule will be evaluated on incoming or outgoing traffic. Possible values are `Inbound` and `Outbound`.
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the security rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Specifies the priority of the rule. The value can be between 100 and 4096. The priority number must be unique for each rule in the collection. The lower the priority number, the higher the priority of the rule.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Network protocol this rule applies to. Can be `Tcp`, `Udp`, `Icmp`, or `*` to match all.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A description for this rule. Restricted to 140 characters.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="destinationAddressPrefix")
    def destination_address_prefix(self) -> Optional[str]:
        """
        CIDR or destination IP range or * to match any IP. Tags such as ‘VirtualNetwork’, ‘AzureLoadBalancer’ and ‘Internet’ can also be used. This is required if `destination_address_prefixes` is not specified.
        """
        return pulumi.get(self, "destination_address_prefix")

    @property
    @pulumi.getter(name="destinationAddressPrefixes")
    def destination_address_prefixes(self) -> Optional[Sequence[str]]:
        """
        List of destination address prefixes. Tags may not be used. This is required if `destination_address_prefix` is not specified.
        """
        return pulumi.get(self, "destination_address_prefixes")

    @property
    @pulumi.getter(name="destinationApplicationSecurityGroupIds")
    def destination_application_security_group_ids(self) -> Optional[Sequence[str]]:
        """
        A List of destination Application Security Group ID's
        """
        return pulumi.get(self, "destination_application_security_group_ids")

    @property
    @pulumi.getter(name="destinationPortRange")
    def destination_port_range(self) -> Optional[str]:
        """
        Destination Port or Range. Integer or range between `0` and `65535` or `*` to match any. This is required if `destination_port_ranges` is not specified.
        """
        return pulumi.get(self, "destination_port_range")

    @property
    @pulumi.getter(name="destinationPortRanges")
    def destination_port_ranges(self) -> Optional[Sequence[str]]:
        """
        List of destination ports or port ranges. This is required if `destination_port_range` is not specified.
        """
        return pulumi.get(self, "destination_port_ranges")

    @property
    @pulumi.getter(name="sourceAddressPrefix")
    def source_address_prefix(self) -> Optional[str]:
        """
        CIDR or source IP range or * to match any IP. Tags such as ‘VirtualNetwork’, ‘AzureLoadBalancer’ and ‘Internet’ can also be used. This is required if `source_address_prefixes` is not specified.
        """
        return pulumi.get(self, "source_address_prefix")

    @property
    @pulumi.getter(name="sourceAddressPrefixes")
    def source_address_prefixes(self) -> Optional[Sequence[str]]:
        """
        List of source address prefixes. Tags may not be used. This is required if `source_address_prefix` is not specified.
        """
        return pulumi.get(self, "source_address_prefixes")

    @property
    @pulumi.getter(name="sourceApplicationSecurityGroupIds")
    def source_application_security_group_ids(self) -> Optional[Sequence[str]]:
        """
        A List of source Application Security Group ID's
        """
        return pulumi.get(self, "source_application_security_group_ids")

    @property
    @pulumi.getter(name="sourcePortRange")
    def source_port_range(self) -> Optional[str]:
        """
        Source Port or Range. Integer or range between `0` and `65535` or `*` to match any. This is required if `source_port_ranges` is not specified.
        """
        return pulumi.get(self, "source_port_range")

    @property
    @pulumi.getter(name="sourcePortRanges")
    def source_port_ranges(self) -> Optional[Sequence[str]]:
        """
        List of source ports or port ranges. This is required if `source_port_range` is not specified.
        """
        return pulumi.get(self, "source_port_ranges")


@pulumi.output_type
class NetworkWatcherFlowLogRetentionPolicy(dict):
    def __init__(__self__, *,
                 days: int,
                 enabled: bool):
        """
        :param int days: The number of days to retain flow log records.
        :param bool enabled: Boolean flag to enable/disable traffic analytics.
        """
        pulumi.set(__self__, "days", days)
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def days(self) -> int:
        """
        The number of days to retain flow log records.
        """
        return pulumi.get(self, "days")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Boolean flag to enable/disable traffic analytics.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class NetworkWatcherFlowLogTrafficAnalytics(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workspaceId":
            suggest = "workspace_id"
        elif key == "workspaceRegion":
            suggest = "workspace_region"
        elif key == "workspaceResourceId":
            suggest = "workspace_resource_id"
        elif key == "intervalInMinutes":
            suggest = "interval_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkWatcherFlowLogTrafficAnalytics. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkWatcherFlowLogTrafficAnalytics.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkWatcherFlowLogTrafficAnalytics.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 workspace_id: str,
                 workspace_region: str,
                 workspace_resource_id: str,
                 interval_in_minutes: Optional[int] = None):
        """
        :param bool enabled: Boolean flag to enable/disable traffic analytics.
        :param str workspace_id: The resource guid of the attached workspace.
        :param str workspace_region: The location of the attached workspace.
        :param str workspace_resource_id: The resource ID of the attached workspace.
        :param int interval_in_minutes: How frequently service should do flow analytics in minutes.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "workspace_id", workspace_id)
        pulumi.set(__self__, "workspace_region", workspace_region)
        pulumi.set(__self__, "workspace_resource_id", workspace_resource_id)
        if interval_in_minutes is not None:
            pulumi.set(__self__, "interval_in_minutes", interval_in_minutes)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Boolean flag to enable/disable traffic analytics.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> str:
        """
        The resource guid of the attached workspace.
        """
        return pulumi.get(self, "workspace_id")

    @property
    @pulumi.getter(name="workspaceRegion")
    def workspace_region(self) -> str:
        """
        The location of the attached workspace.
        """
        return pulumi.get(self, "workspace_region")

    @property
    @pulumi.getter(name="workspaceResourceId")
    def workspace_resource_id(self) -> str:
        """
        The resource ID of the attached workspace.
        """
        return pulumi.get(self, "workspace_resource_id")

    @property
    @pulumi.getter(name="intervalInMinutes")
    def interval_in_minutes(self) -> Optional[int]:
        """
        How frequently service should do flow analytics in minutes.
        """
        return pulumi.get(self, "interval_in_minutes")


@pulumi.output_type
class PacketCaptureFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localIpAddress":
            suggest = "local_ip_address"
        elif key == "localPort":
            suggest = "local_port"
        elif key == "remoteIpAddress":
            suggest = "remote_ip_address"
        elif key == "remotePort":
            suggest = "remote_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PacketCaptureFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PacketCaptureFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PacketCaptureFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 protocol: str,
                 local_ip_address: Optional[str] = None,
                 local_port: Optional[str] = None,
                 remote_ip_address: Optional[str] = None,
                 remote_port: Optional[str] = None):
        """
        :param str protocol: The Protocol to be filtered on. Possible values include `Any`, `TCP` and `UDP`. Changing this forces a new resource to be created.
        :param str local_ip_address: The local IP Address to be filtered on. Notation: "127.0.0.1" for single address entry. "127.0.0.1-127.0.0.255" for range. "127.0.0.1;127.0.0.5" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported. Changing this forces a new resource to be created.
        :param str local_port: The local port to be filtered on. Notation: "80" for single port entry."80-85" for range. "80;443;" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported. Changing this forces a new resource to be created.
        :param str remote_ip_address: The remote IP Address to be filtered on. Notation: "127.0.0.1" for single address entry. "127.0.0.1-127.0.0.255" for range. "127.0.0.1;127.0.0.5;" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported.. Changing this forces a new resource to be created.
        :param str remote_port: The remote port to be filtered on. Notation: "80" for single port entry."80-85" for range. "80;443;" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "protocol", protocol)
        if local_ip_address is not None:
            pulumi.set(__self__, "local_ip_address", local_ip_address)
        if local_port is not None:
            pulumi.set(__self__, "local_port", local_port)
        if remote_ip_address is not None:
            pulumi.set(__self__, "remote_ip_address", remote_ip_address)
        if remote_port is not None:
            pulumi.set(__self__, "remote_port", remote_port)

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The Protocol to be filtered on. Possible values include `Any`, `TCP` and `UDP`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="localIpAddress")
    def local_ip_address(self) -> Optional[str]:
        """
        The local IP Address to be filtered on. Notation: "127.0.0.1" for single address entry. "127.0.0.1-127.0.0.255" for range. "127.0.0.1;127.0.0.5" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "local_ip_address")

    @property
    @pulumi.getter(name="localPort")
    def local_port(self) -> Optional[str]:
        """
        The local port to be filtered on. Notation: "80" for single port entry."80-85" for range. "80;443;" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "local_port")

    @property
    @pulumi.getter(name="remoteIpAddress")
    def remote_ip_address(self) -> Optional[str]:
        """
        The remote IP Address to be filtered on. Notation: "127.0.0.1" for single address entry. "127.0.0.1-127.0.0.255" for range. "127.0.0.1;127.0.0.5;" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported.. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "remote_ip_address")

    @property
    @pulumi.getter(name="remotePort")
    def remote_port(self) -> Optional[str]:
        """
        The remote port to be filtered on. Notation: "80" for single port entry."80-85" for range. "80;443;" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "remote_port")


@pulumi.output_type
class PacketCaptureStorageLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filePath":
            suggest = "file_path"
        elif key == "storageAccountId":
            suggest = "storage_account_id"
        elif key == "storagePath":
            suggest = "storage_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PacketCaptureStorageLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PacketCaptureStorageLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PacketCaptureStorageLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_path: Optional[str] = None,
                 storage_account_id: Optional[str] = None,
                 storage_path: Optional[str] = None):
        """
        :param str file_path: A valid local path on the targeting VM. Must include the name of the capture file (*.cap). For linux virtual machine it must start with `/var/captures`.
        :param str storage_account_id: The ID of the storage account to save the packet capture session
        :param str storage_path: The URI of the storage path to save the packet capture.
        """
        if file_path is not None:
            pulumi.set(__self__, "file_path", file_path)
        if storage_account_id is not None:
            pulumi.set(__self__, "storage_account_id", storage_account_id)
        if storage_path is not None:
            pulumi.set(__self__, "storage_path", storage_path)

    @property
    @pulumi.getter(name="filePath")
    def file_path(self) -> Optional[str]:
        """
        A valid local path on the targeting VM. Must include the name of the capture file (*.cap). For linux virtual machine it must start with `/var/captures`.
        """
        return pulumi.get(self, "file_path")

    @property
    @pulumi.getter(name="storageAccountId")
    def storage_account_id(self) -> Optional[str]:
        """
        The ID of the storage account to save the packet capture session
        """
        return pulumi.get(self, "storage_account_id")

    @property
    @pulumi.getter(name="storagePath")
    def storage_path(self) -> Optional[str]:
        """
        The URI of the storage path to save the packet capture.
        """
        return pulumi.get(self, "storage_path")


@pulumi.output_type
class PointToPointVpnGatewayConnectionConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vpnClientAddressPool":
            suggest = "vpn_client_address_pool"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PointToPointVpnGatewayConnectionConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PointToPointVpnGatewayConnectionConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PointToPointVpnGatewayConnectionConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 vpn_client_address_pool: 'outputs.PointToPointVpnGatewayConnectionConfigurationVpnClientAddressPool',
                 route: Optional['outputs.PointToPointVpnGatewayConnectionConfigurationRoute'] = None):
        """
        :param str name: The Name which should be used for this Connection Configuration.
        :param 'PointToPointVpnGatewayConnectionConfigurationVpnClientAddressPoolArgs' vpn_client_address_pool: A `vpn_client_address_pool` block as defined below.
        :param 'PointToPointVpnGatewayConnectionConfigurationRouteArgs' route: A `route` block as defined below.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "vpn_client_address_pool", vpn_client_address_pool)
        if route is not None:
            pulumi.set(__self__, "route", route)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Name which should be used for this Connection Configuration.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="vpnClientAddressPool")
    def vpn_client_address_pool(self) -> 'outputs.PointToPointVpnGatewayConnectionConfigurationVpnClientAddressPool':
        """
        A `vpn_client_address_pool` block as defined below.
        """
        return pulumi.get(self, "vpn_client_address_pool")

    @property
    @pulumi.getter
    def route(self) -> Optional['outputs.PointToPointVpnGatewayConnectionConfigurationRoute']:
        """
        A `route` block as defined below.
        """
        return pulumi.get(self, "route")


@pulumi.output_type
class PointToPointVpnGatewayConnectionConfigurationRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "associatedRouteTableId":
            suggest = "associated_route_table_id"
        elif key == "propagatedRouteTable":
            suggest = "propagated_route_table"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PointToPointVpnGatewayConnectionConfigurationRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PointToPointVpnGatewayConnectionConfigurationRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PointToPointVpnGatewayConnectionConfigurationRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 associated_route_table_id: str,
                 propagated_route_table: Optional['outputs.PointToPointVpnGatewayConnectionConfigurationRoutePropagatedRouteTable'] = None):
        """
        :param str associated_route_table_id: The Virtual Hub Route Table resource id associated with this Routing Configuration.
        :param 'PointToPointVpnGatewayConnectionConfigurationRoutePropagatedRouteTableArgs' propagated_route_table: A `propagated_route_table` block as defined below.
        """
        pulumi.set(__self__, "associated_route_table_id", associated_route_table_id)
        if propagated_route_table is not None:
            pulumi.set(__self__, "propagated_route_table", propagated_route_table)

    @property
    @pulumi.getter(name="associatedRouteTableId")
    def associated_route_table_id(self) -> str:
        """
        The Virtual Hub Route Table resource id associated with this Routing Configuration.
        """
        return pulumi.get(self, "associated_route_table_id")

    @property
    @pulumi.getter(name="propagatedRouteTable")
    def propagated_route_table(self) -> Optional['outputs.PointToPointVpnGatewayConnectionConfigurationRoutePropagatedRouteTable']:
        """
        A `propagated_route_table` block as defined below.
        """
        return pulumi.get(self, "propagated_route_table")


@pulumi.output_type
class PointToPointVpnGatewayConnectionConfigurationRoutePropagatedRouteTable(dict):
    def __init__(__self__, *,
                 ids: Sequence[str],
                 labels: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] ids: The list of Virtual Hub Route Table resource id which the routes will be propagated to.
        :param Sequence[str] labels: The list of labels to logically group Virtual Hub Route Tables which the routes will be propagated to.
        """
        pulumi.set(__self__, "ids", ids)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def ids(self) -> Sequence[str]:
        """
        The list of Virtual Hub Route Table resource id which the routes will be propagated to.
        """
        return pulumi.get(self, "ids")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Sequence[str]]:
        """
        The list of labels to logically group Virtual Hub Route Tables which the routes will be propagated to.
        """
        return pulumi.get(self, "labels")


@pulumi.output_type
class PointToPointVpnGatewayConnectionConfigurationVpnClientAddressPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressPrefixes":
            suggest = "address_prefixes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PointToPointVpnGatewayConnectionConfigurationVpnClientAddressPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PointToPointVpnGatewayConnectionConfigurationVpnClientAddressPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PointToPointVpnGatewayConnectionConfigurationVpnClientAddressPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address_prefixes: Sequence[str]):
        """
        :param Sequence[str] address_prefixes: A list of CIDR Ranges which should be used as Address Prefixes.
        """
        pulumi.set(__self__, "address_prefixes", address_prefixes)

    @property
    @pulumi.getter(name="addressPrefixes")
    def address_prefixes(self) -> Sequence[str]:
        """
        A list of CIDR Ranges which should be used as Address Prefixes.
        """
        return pulumi.get(self, "address_prefixes")


@pulumi.output_type
class ProfileContainerNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipConfigurations":
            suggest = "ip_configurations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProfileContainerNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProfileContainerNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProfileContainerNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_configurations: Sequence['outputs.ProfileContainerNetworkInterfaceIpConfiguration'],
                 name: str):
        """
        :param Sequence['ProfileContainerNetworkInterfaceIpConfigurationArgs'] ip_configurations: One or more `ip_configuration` blocks as documented below.
        :param str name: Specifies the name of the IP Configuration.
        """
        pulumi.set(__self__, "ip_configurations", ip_configurations)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="ipConfigurations")
    def ip_configurations(self) -> Sequence['outputs.ProfileContainerNetworkInterfaceIpConfiguration']:
        """
        One or more `ip_configuration` blocks as documented below.
        """
        return pulumi.get(self, "ip_configurations")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the IP Configuration.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ProfileContainerNetworkInterfaceIpConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProfileContainerNetworkInterfaceIpConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProfileContainerNetworkInterfaceIpConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProfileContainerNetworkInterfaceIpConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 subnet_id: str):
        """
        :param str name: Specifies the name of the IP Configuration.
        :param str subnet_id: Reference to the subnet associated with the IP Configuration.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the IP Configuration.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        Reference to the subnet associated with the IP Configuration.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class RouteFilterRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleType":
            suggest = "rule_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouteFilterRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouteFilterRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouteFilterRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access: str,
                 communities: Sequence[str],
                 name: str,
                 rule_type: str):
        """
        :param str access: The access type of the rule. The only possible value is `Allow`.
        :param Sequence[str] communities: The collection for bgp community values to filter on. e.g. ['12076:5010','12076:5020'].
        :param str name: The name of the route filter rule.
        :param str rule_type: The rule type of the rule. The only possible value is `Community`.
        """
        pulumi.set(__self__, "access", access)
        pulumi.set(__self__, "communities", communities)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "rule_type", rule_type)

    @property
    @pulumi.getter
    def access(self) -> str:
        """
        The access type of the rule. The only possible value is `Allow`.
        """
        return pulumi.get(self, "access")

    @property
    @pulumi.getter
    def communities(self) -> Sequence[str]:
        """
        The collection for bgp community values to filter on. e.g. ['12076:5010','12076:5020'].
        """
        return pulumi.get(self, "communities")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the route filter rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> str:
        """
        The rule type of the rule. The only possible value is `Community`.
        """
        return pulumi.get(self, "rule_type")


@pulumi.output_type
class RouteTableRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressPrefix":
            suggest = "address_prefix"
        elif key == "nextHopType":
            suggest = "next_hop_type"
        elif key == "nextHopInIpAddress":
            suggest = "next_hop_in_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouteTableRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouteTableRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouteTableRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address_prefix: str,
                 name: str,
                 next_hop_type: str,
                 next_hop_in_ip_address: Optional[str] = None):
        """
        :param str address_prefix: The destination CIDR to which the route applies, such as 10.1.0.0/16. Tags such as `VirtualNetwork`, `AzureLoadBalancer` or `Internet` can also be used.
        :param str name: The name of the route.
        :param str next_hop_type: The type of Azure hop the packet should be sent to. Possible values are `VirtualNetworkGateway`, `VnetLocal`, `Internet`, `VirtualAppliance` and `None`.
        :param str next_hop_in_ip_address: Contains the IP address packets should be forwarded to. Next hop values are only allowed in routes where the next hop type is `VirtualAppliance`.
        """
        pulumi.set(__self__, "address_prefix", address_prefix)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "next_hop_type", next_hop_type)
        if next_hop_in_ip_address is not None:
            pulumi.set(__self__, "next_hop_in_ip_address", next_hop_in_ip_address)

    @property
    @pulumi.getter(name="addressPrefix")
    def address_prefix(self) -> str:
        """
        The destination CIDR to which the route applies, such as 10.1.0.0/16. Tags such as `VirtualNetwork`, `AzureLoadBalancer` or `Internet` can also be used.
        """
        return pulumi.get(self, "address_prefix")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the route.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nextHopType")
    def next_hop_type(self) -> str:
        """
        The type of Azure hop the packet should be sent to. Possible values are `VirtualNetworkGateway`, `VnetLocal`, `Internet`, `VirtualAppliance` and `None`.
        """
        return pulumi.get(self, "next_hop_type")

    @property
    @pulumi.getter(name="nextHopInIpAddress")
    def next_hop_in_ip_address(self) -> Optional[str]:
        """
        Contains the IP address packets should be forwarded to. Next hop values are only allowed in routes where the next hop type is `VirtualAppliance`.
        """
        return pulumi.get(self, "next_hop_in_ip_address")


@pulumi.output_type
class SubnetDelegation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceDelegation":
            suggest = "service_delegation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SubnetDelegation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SubnetDelegation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SubnetDelegation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 service_delegation: 'outputs.SubnetDelegationServiceDelegation'):
        """
        :param str name: A name for this delegation.
        :param 'SubnetDelegationServiceDelegationArgs' service_delegation: A `service_delegation` block as defined below.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service_delegation", service_delegation)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A name for this delegation.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="serviceDelegation")
    def service_delegation(self) -> 'outputs.SubnetDelegationServiceDelegation':
        """
        A `service_delegation` block as defined below.
        """
        return pulumi.get(self, "service_delegation")


@pulumi.output_type
class SubnetDelegationServiceDelegation(dict):
    def __init__(__self__, *,
                 name: str,
                 actions: Optional[Sequence[str]] = None):
        """
        :param str name: The name of service to delegate to. Possible values include `Microsoft.ApiManagement/service`, `Microsoft.AzureCosmosDB/clusters`, `Microsoft.BareMetal/AzureVMware`, `Microsoft.BareMetal/CrayServers`, `Microsoft.Batch/batchAccounts`, `Microsoft.ContainerInstance/containerGroups`, `Microsoft.Databricks/workspaces`, `Microsoft.DBforMySQL/flexibleServers`, `Microsoft.DBforMySQL/serversv2`, `Microsoft.DBforPostgreSQL/flexibleServers`, `Microsoft.DBforPostgreSQL/serversv2`, `Microsoft.DBforPostgreSQL/singleServers`, `Microsoft.HardwareSecurityModules/dedicatedHSMs`, `Microsoft.Kusto/clusters`, `Microsoft.Logic/integrationServiceEnvironments`, `Microsoft.MachineLearningServices/workspaces`,  `Microsoft.Netapp/volumes`, `Microsoft.Network/managedResolvers`, `Microsoft.PowerPlatform/vnetaccesslinks`, `Microsoft.ServiceFabricMesh/networks`, `Microsoft.Sql/managedInstances`, `Microsoft.Sql/servers`, `Microsoft.StreamAnalytics/streamingJobs`, `Microsoft.Synapse/workspaces`, `Microsoft.Web/hostingEnvironments`, and `Microsoft.Web/serverFarms`.
        :param Sequence[str] actions: A list of Actions which should be delegated. This list is specific to the service to delegate to. Possible values include `Microsoft.Network/networkinterfaces/*`, `Microsoft.Network/virtualNetworks/subnets/action`, `Microsoft.Network/virtualNetworks/subnets/join/action`, `Microsoft.Network/virtualNetworks/subnets/prepareNetworkPolicies/action` and `Microsoft.Network/virtualNetworks/subnets/unprepareNetworkPolicies/action`.
        """
        pulumi.set(__self__, "name", name)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of service to delegate to. Possible values include `Microsoft.ApiManagement/service`, `Microsoft.AzureCosmosDB/clusters`, `Microsoft.BareMetal/AzureVMware`, `Microsoft.BareMetal/CrayServers`, `Microsoft.Batch/batchAccounts`, `Microsoft.ContainerInstance/containerGroups`, `Microsoft.Databricks/workspaces`, `Microsoft.DBforMySQL/flexibleServers`, `Microsoft.DBforMySQL/serversv2`, `Microsoft.DBforPostgreSQL/flexibleServers`, `Microsoft.DBforPostgreSQL/serversv2`, `Microsoft.DBforPostgreSQL/singleServers`, `Microsoft.HardwareSecurityModules/dedicatedHSMs`, `Microsoft.Kusto/clusters`, `Microsoft.Logic/integrationServiceEnvironments`, `Microsoft.MachineLearningServices/workspaces`,  `Microsoft.Netapp/volumes`, `Microsoft.Network/managedResolvers`, `Microsoft.PowerPlatform/vnetaccesslinks`, `Microsoft.ServiceFabricMesh/networks`, `Microsoft.Sql/managedInstances`, `Microsoft.Sql/servers`, `Microsoft.StreamAnalytics/streamingJobs`, `Microsoft.Synapse/workspaces`, `Microsoft.Web/hostingEnvironments`, and `Microsoft.Web/serverFarms`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence[str]]:
        """
        A list of Actions which should be delegated. This list is specific to the service to delegate to. Possible values include `Microsoft.Network/networkinterfaces/*`, `Microsoft.Network/virtualNetworks/subnets/action`, `Microsoft.Network/virtualNetworks/subnets/join/action`, `Microsoft.Network/virtualNetworks/subnets/prepareNetworkPolicies/action` and `Microsoft.Network/virtualNetworks/subnets/unprepareNetworkPolicies/action`.
        """
        return pulumi.get(self, "actions")


@pulumi.output_type
class SubnetServiceEndpointStoragePolicyDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceResources":
            suggest = "service_resources"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SubnetServiceEndpointStoragePolicyDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SubnetServiceEndpointStoragePolicyDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SubnetServiceEndpointStoragePolicyDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 service_resources: Sequence[str],
                 description: Optional[str] = None):
        """
        :param str name: The name which should be used for this Subnet Service Endpoint Storage Policy Definition.
        :param Sequence[str] service_resources: Specifies a list of resources that this Subnet Service Endpoint Storage Policy Definition applies to.
        :param str description: The description of this Subnet Service Endpoint Storage Policy Definition.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service_resources", service_resources)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Subnet Service Endpoint Storage Policy Definition.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="serviceResources")
    def service_resources(self) -> Sequence[str]:
        """
        Specifies a list of resources that this Subnet Service Endpoint Storage Policy Definition applies to.
        """
        return pulumi.get(self, "service_resources")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of this Subnet Service Endpoint Storage Policy Definition.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class TrafficManagerEndpointCustomHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: The name of the custom header.
        :param str value: The value of custom header. Applicable for Http and Https protocol.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the custom header.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of custom header. Applicable for Http and Https protocol.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class TrafficManagerEndpointSubnet(dict):
    def __init__(__self__, *,
                 first: str,
                 last: Optional[str] = None,
                 scope: Optional[int] = None):
        """
        :param str first: The First IP....
        :param str last: The Last IP...
        :param int scope: The Scope...
        """
        pulumi.set(__self__, "first", first)
        if last is not None:
            pulumi.set(__self__, "last", last)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter
    def first(self) -> str:
        """
        The First IP....
        """
        return pulumi.get(self, "first")

    @property
    @pulumi.getter
    def last(self) -> Optional[str]:
        """
        The Last IP...
        """
        return pulumi.get(self, "last")

    @property
    @pulumi.getter
    def scope(self) -> Optional[int]:
        """
        The Scope...
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class TrafficManagerProfileDnsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "relativeName":
            suggest = "relative_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TrafficManagerProfileDnsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TrafficManagerProfileDnsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TrafficManagerProfileDnsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 relative_name: str,
                 ttl: int):
        """
        :param str relative_name: The relative domain name, this is combined with the domain name used by Traffic Manager to form the FQDN which is exported as documented below. Changing this forces a new resource to be created.
        :param int ttl: The TTL value of the Profile used by Local DNS resolvers and clients.
        """
        pulumi.set(__self__, "relative_name", relative_name)
        pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter(name="relativeName")
    def relative_name(self) -> str:
        """
        The relative domain name, this is combined with the domain name used by Traffic Manager to form the FQDN which is exported as documented below. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "relative_name")

    @property
    @pulumi.getter
    def ttl(self) -> int:
        """
        The TTL value of the Profile used by Local DNS resolvers and clients.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class TrafficManagerProfileMonitorConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHeaders":
            suggest = "custom_headers"
        elif key == "expectedStatusCodeRanges":
            suggest = "expected_status_code_ranges"
        elif key == "intervalInSeconds":
            suggest = "interval_in_seconds"
        elif key == "timeoutInSeconds":
            suggest = "timeout_in_seconds"
        elif key == "toleratedNumberOfFailures":
            suggest = "tolerated_number_of_failures"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TrafficManagerProfileMonitorConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TrafficManagerProfileMonitorConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TrafficManagerProfileMonitorConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port: int,
                 protocol: str,
                 custom_headers: Optional[Sequence['outputs.TrafficManagerProfileMonitorConfigCustomHeader']] = None,
                 expected_status_code_ranges: Optional[Sequence[str]] = None,
                 interval_in_seconds: Optional[int] = None,
                 path: Optional[str] = None,
                 timeout_in_seconds: Optional[int] = None,
                 tolerated_number_of_failures: Optional[int] = None):
        """
        :param int port: The port number used by the monitoring checks.
        :param str protocol: The protocol used by the monitoring checks, supported values are `HTTP`, `HTTPS` and `TCP`.
        :param Sequence['TrafficManagerProfileMonitorConfigCustomHeaderArgs'] custom_headers: One or more `custom_header` blocks as defined below.
        :param Sequence[str] expected_status_code_ranges: A list of status code ranges in the format of `100-101`.
        :param int interval_in_seconds: The interval used to check the endpoint health from a Traffic Manager probing agent. You can specify two values here: `30` (normal probing) and `10` (fast probing). The default value is `30`.
        :param str path: The path used by the monitoring checks. Required when `protocol` is set to `HTTP` or `HTTPS` - cannot be set when `protocol` is set to `TCP`.
        :param int timeout_in_seconds: The amount of time the Traffic Manager probing agent should wait before considering that check a failure when a health check probe is sent to the endpoint. If `interval_in_seconds` is set to `30`, then `timeout_in_seconds` can be between `5` and `10`. The default value is `10`. If `interval_in_seconds` is set to `10`, then valid values are between `5` and `9` and `timeout_in_seconds` is required.
        :param int tolerated_number_of_failures: The number of failures a Traffic Manager probing agent tolerates before marking that endpoint as unhealthy. Valid values are between `0` and `9`. The default value is `3`
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        if custom_headers is not None:
            pulumi.set(__self__, "custom_headers", custom_headers)
        if expected_status_code_ranges is not None:
            pulumi.set(__self__, "expected_status_code_ranges", expected_status_code_ranges)
        if interval_in_seconds is not None:
            pulumi.set(__self__, "interval_in_seconds", interval_in_seconds)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if timeout_in_seconds is not None:
            pulumi.set(__self__, "timeout_in_seconds", timeout_in_seconds)
        if tolerated_number_of_failures is not None:
            pulumi.set(__self__, "tolerated_number_of_failures", tolerated_number_of_failures)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port number used by the monitoring checks.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The protocol used by the monitoring checks, supported values are `HTTP`, `HTTPS` and `TCP`.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="customHeaders")
    def custom_headers(self) -> Optional[Sequence['outputs.TrafficManagerProfileMonitorConfigCustomHeader']]:
        """
        One or more `custom_header` blocks as defined below.
        """
        return pulumi.get(self, "custom_headers")

    @property
    @pulumi.getter(name="expectedStatusCodeRanges")
    def expected_status_code_ranges(self) -> Optional[Sequence[str]]:
        """
        A list of status code ranges in the format of `100-101`.
        """
        return pulumi.get(self, "expected_status_code_ranges")

    @property
    @pulumi.getter(name="intervalInSeconds")
    def interval_in_seconds(self) -> Optional[int]:
        """
        The interval used to check the endpoint health from a Traffic Manager probing agent. You can specify two values here: `30` (normal probing) and `10` (fast probing). The default value is `30`.
        """
        return pulumi.get(self, "interval_in_seconds")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path used by the monitoring checks. Required when `protocol` is set to `HTTP` or `HTTPS` - cannot be set when `protocol` is set to `TCP`.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> Optional[int]:
        """
        The amount of time the Traffic Manager probing agent should wait before considering that check a failure when a health check probe is sent to the endpoint. If `interval_in_seconds` is set to `30`, then `timeout_in_seconds` can be between `5` and `10`. The default value is `10`. If `interval_in_seconds` is set to `10`, then valid values are between `5` and `9` and `timeout_in_seconds` is required.
        """
        return pulumi.get(self, "timeout_in_seconds")

    @property
    @pulumi.getter(name="toleratedNumberOfFailures")
    def tolerated_number_of_failures(self) -> Optional[int]:
        """
        The number of failures a Traffic Manager probing agent tolerates before marking that endpoint as unhealthy. Valid values are between `0` and `9`. The default value is `3`
        """
        return pulumi.get(self, "tolerated_number_of_failures")


@pulumi.output_type
class TrafficManagerProfileMonitorConfigCustomHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: The name of the custom header.
        :param str value: The value of custom header. Applicable for Http and Https protocol.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the custom header.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of custom header. Applicable for Http and Https protocol.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class VirtualHubConnectionRouting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "associatedRouteTableId":
            suggest = "associated_route_table_id"
        elif key == "propagatedRouteTable":
            suggest = "propagated_route_table"
        elif key == "staticVnetRoutes":
            suggest = "static_vnet_routes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualHubConnectionRouting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualHubConnectionRouting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualHubConnectionRouting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 associated_route_table_id: Optional[str] = None,
                 propagated_route_table: Optional['outputs.VirtualHubConnectionRoutingPropagatedRouteTable'] = None,
                 static_vnet_routes: Optional[Sequence['outputs.VirtualHubConnectionRoutingStaticVnetRoute']] = None):
        """
        :param str associated_route_table_id: The ID of the route table associated with this Virtual Hub connection.
        :param 'VirtualHubConnectionRoutingPropagatedRouteTableArgs' propagated_route_table: A `propagated_route_table` block as defined below.
        :param Sequence['VirtualHubConnectionRoutingStaticVnetRouteArgs'] static_vnet_routes: A `static_vnet_route` block as defined below.
        """
        if associated_route_table_id is not None:
            pulumi.set(__self__, "associated_route_table_id", associated_route_table_id)
        if propagated_route_table is not None:
            pulumi.set(__self__, "propagated_route_table", propagated_route_table)
        if static_vnet_routes is not None:
            pulumi.set(__self__, "static_vnet_routes", static_vnet_routes)

    @property
    @pulumi.getter(name="associatedRouteTableId")
    def associated_route_table_id(self) -> Optional[str]:
        """
        The ID of the route table associated with this Virtual Hub connection.
        """
        return pulumi.get(self, "associated_route_table_id")

    @property
    @pulumi.getter(name="propagatedRouteTable")
    def propagated_route_table(self) -> Optional['outputs.VirtualHubConnectionRoutingPropagatedRouteTable']:
        """
        A `propagated_route_table` block as defined below.
        """
        return pulumi.get(self, "propagated_route_table")

    @property
    @pulumi.getter(name="staticVnetRoutes")
    def static_vnet_routes(self) -> Optional[Sequence['outputs.VirtualHubConnectionRoutingStaticVnetRoute']]:
        """
        A `static_vnet_route` block as defined below.
        """
        return pulumi.get(self, "static_vnet_routes")


@pulumi.output_type
class VirtualHubConnectionRoutingPropagatedRouteTable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "routeTableIds":
            suggest = "route_table_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualHubConnectionRoutingPropagatedRouteTable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualHubConnectionRoutingPropagatedRouteTable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualHubConnectionRoutingPropagatedRouteTable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 labels: Optional[Sequence[str]] = None,
                 route_table_ids: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] labels: The list of labels to assign to this route table.
        :param Sequence[str] route_table_ids: A list of Route Table ID's to associated with this Virtual Hub Connection.
        """
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if route_table_ids is not None:
            pulumi.set(__self__, "route_table_ids", route_table_ids)

    @property
    @pulumi.getter
    def labels(self) -> Optional[Sequence[str]]:
        """
        The list of labels to assign to this route table.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="routeTableIds")
    def route_table_ids(self) -> Optional[Sequence[str]]:
        """
        A list of Route Table ID's to associated with this Virtual Hub Connection.
        """
        return pulumi.get(self, "route_table_ids")


@pulumi.output_type
class VirtualHubConnectionRoutingStaticVnetRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressPrefixes":
            suggest = "address_prefixes"
        elif key == "nextHopIpAddress":
            suggest = "next_hop_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualHubConnectionRoutingStaticVnetRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualHubConnectionRoutingStaticVnetRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualHubConnectionRoutingStaticVnetRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address_prefixes: Optional[Sequence[str]] = None,
                 name: Optional[str] = None,
                 next_hop_ip_address: Optional[str] = None):
        """
        :param Sequence[str] address_prefixes: A list of CIDR Ranges which should be used as Address Prefixes.
        :param str name: The name which should be used for this Static Route.
        :param str next_hop_ip_address: The IP Address which should be used for the Next Hop.
        """
        if address_prefixes is not None:
            pulumi.set(__self__, "address_prefixes", address_prefixes)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if next_hop_ip_address is not None:
            pulumi.set(__self__, "next_hop_ip_address", next_hop_ip_address)

    @property
    @pulumi.getter(name="addressPrefixes")
    def address_prefixes(self) -> Optional[Sequence[str]]:
        """
        A list of CIDR Ranges which should be used as Address Prefixes.
        """
        return pulumi.get(self, "address_prefixes")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name which should be used for this Static Route.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nextHopIpAddress")
    def next_hop_ip_address(self) -> Optional[str]:
        """
        The IP Address which should be used for the Next Hop.
        """
        return pulumi.get(self, "next_hop_ip_address")


@pulumi.output_type
class VirtualHubRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressPrefixes":
            suggest = "address_prefixes"
        elif key == "nextHopIpAddress":
            suggest = "next_hop_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualHubRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualHubRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualHubRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address_prefixes: Sequence[str],
                 next_hop_ip_address: str):
        """
        :param Sequence[str] address_prefixes: A list of Address Prefixes.
        :param str next_hop_ip_address: The IP Address that Packets should be forwarded to as the Next Hop.
        """
        pulumi.set(__self__, "address_prefixes", address_prefixes)
        pulumi.set(__self__, "next_hop_ip_address", next_hop_ip_address)

    @property
    @pulumi.getter(name="addressPrefixes")
    def address_prefixes(self) -> Sequence[str]:
        """
        A list of Address Prefixes.
        """
        return pulumi.get(self, "address_prefixes")

    @property
    @pulumi.getter(name="nextHopIpAddress")
    def next_hop_ip_address(self) -> str:
        """
        The IP Address that Packets should be forwarded to as the Next Hop.
        """
        return pulumi.get(self, "next_hop_ip_address")


@pulumi.output_type
class VirtualHubRouteTableRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationsType":
            suggest = "destinations_type"
        elif key == "nextHop":
            suggest = "next_hop"
        elif key == "nextHopType":
            suggest = "next_hop_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualHubRouteTableRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualHubRouteTableRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualHubRouteTableRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destinations: Sequence[str],
                 destinations_type: str,
                 name: str,
                 next_hop: str,
                 next_hop_type: Optional[str] = None):
        """
        :param Sequence[str] destinations: A list of destination addresses for this route.
        :param str destinations_type: The type of destinations. Possible values are `CIDR`, `ResourceId` and `Service`.
        :param str name: The name which should be used for this route.
        :param str next_hop: The next hop's resource ID.
        :param str next_hop_type: The type of next hop. Currently the only possible value is `ResourceId`. Defaults to `ResourceId`.
        """
        pulumi.set(__self__, "destinations", destinations)
        pulumi.set(__self__, "destinations_type", destinations_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "next_hop", next_hop)
        if next_hop_type is not None:
            pulumi.set(__self__, "next_hop_type", next_hop_type)

    @property
    @pulumi.getter
    def destinations(self) -> Sequence[str]:
        """
        A list of destination addresses for this route.
        """
        return pulumi.get(self, "destinations")

    @property
    @pulumi.getter(name="destinationsType")
    def destinations_type(self) -> str:
        """
        The type of destinations. Possible values are `CIDR`, `ResourceId` and `Service`.
        """
        return pulumi.get(self, "destinations_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this route.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nextHop")
    def next_hop(self) -> str:
        """
        The next hop's resource ID.
        """
        return pulumi.get(self, "next_hop")

    @property
    @pulumi.getter(name="nextHopType")
    def next_hop_type(self) -> Optional[str]:
        """
        The type of next hop. Currently the only possible value is `ResourceId`. Defaults to `ResourceId`.
        """
        return pulumi.get(self, "next_hop_type")


@pulumi.output_type
class VirtualNetworkDdosProtectionPlan(dict):
    def __init__(__self__, *,
                 enable: bool,
                 id: str):
        """
        :param bool enable: Enable/disable DDoS Protection Plan on Virtual Network.
        :param str id: The ID of DDoS Protection Plan.
        """
        pulumi.set(__self__, "enable", enable)
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def enable(self) -> bool:
        """
        Enable/disable DDoS Protection Plan on Virtual Network.
        """
        return pulumi.get(self, "enable")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of DDoS Protection Plan.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class VirtualNetworkGatewayBgpSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "peerWeight":
            suggest = "peer_weight"
        elif key == "peeringAddress":
            suggest = "peering_address"
        elif key == "peeringAddresses":
            suggest = "peering_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNetworkGatewayBgpSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNetworkGatewayBgpSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNetworkGatewayBgpSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 asn: Optional[int] = None,
                 peer_weight: Optional[int] = None,
                 peering_address: Optional[str] = None,
                 peering_addresses: Optional[Sequence['outputs.VirtualNetworkGatewayBgpSettingsPeeringAddress']] = None):
        """
        :param int asn: The Autonomous System Number (ASN) to use as part of the BGP.
        :param int peer_weight: The weight added to routes which have been learned
               through BGP peering. Valid values can be between `0` and `100`.
        :param Sequence['VirtualNetworkGatewayBgpSettingsPeeringAddressArgs'] peering_addresses: A list of `peering_addresses` as defined below. Only one `peering_addresses` block can be specified except when `active_active` of this Virtual Network Gateway is `true`.
        """
        if asn is not None:
            pulumi.set(__self__, "asn", asn)
        if peer_weight is not None:
            pulumi.set(__self__, "peer_weight", peer_weight)
        if peering_address is not None:
            pulumi.set(__self__, "peering_address", peering_address)
        if peering_addresses is not None:
            pulumi.set(__self__, "peering_addresses", peering_addresses)

    @property
    @pulumi.getter
    def asn(self) -> Optional[int]:
        """
        The Autonomous System Number (ASN) to use as part of the BGP.
        """
        return pulumi.get(self, "asn")

    @property
    @pulumi.getter(name="peerWeight")
    def peer_weight(self) -> Optional[int]:
        """
        The weight added to routes which have been learned
        through BGP peering. Valid values can be between `0` and `100`.
        """
        return pulumi.get(self, "peer_weight")

    @property
    @pulumi.getter(name="peeringAddress")
    def peering_address(self) -> Optional[str]:
        return pulumi.get(self, "peering_address")

    @property
    @pulumi.getter(name="peeringAddresses")
    def peering_addresses(self) -> Optional[Sequence['outputs.VirtualNetworkGatewayBgpSettingsPeeringAddress']]:
        """
        A list of `peering_addresses` as defined below. Only one `peering_addresses` block can be specified except when `active_active` of this Virtual Network Gateway is `true`.
        """
        return pulumi.get(self, "peering_addresses")


@pulumi.output_type
class VirtualNetworkGatewayBgpSettingsPeeringAddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apipaAddresses":
            suggest = "apipa_addresses"
        elif key == "defaultAddresses":
            suggest = "default_addresses"
        elif key == "ipConfigurationName":
            suggest = "ip_configuration_name"
        elif key == "tunnelIpAddresses":
            suggest = "tunnel_ip_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNetworkGatewayBgpSettingsPeeringAddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNetworkGatewayBgpSettingsPeeringAddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNetworkGatewayBgpSettingsPeeringAddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apipa_addresses: Optional[Sequence[str]] = None,
                 default_addresses: Optional[Sequence[str]] = None,
                 ip_configuration_name: Optional[str] = None,
                 tunnel_ip_addresses: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] apipa_addresses: A list of Azure custom APIPA addresses assigned to the BGP peer of the Virtual Network Gateway.
        :param Sequence[str] default_addresses: A list of peering address assigned to the BGP peer of the Virtual Network Gateway.
        :param str ip_configuration_name: The name of the IP configuration of this Virtual Network Gateway. In case there are multiple `ip_configuration` blocks defined, this property is **required** to specify.
        :param Sequence[str] tunnel_ip_addresses: A list of tunnel IP addresses assigned to the BGP peer of the Virtual Network Gateway.
        """
        if apipa_addresses is not None:
            pulumi.set(__self__, "apipa_addresses", apipa_addresses)
        if default_addresses is not None:
            pulumi.set(__self__, "default_addresses", default_addresses)
        if ip_configuration_name is not None:
            pulumi.set(__self__, "ip_configuration_name", ip_configuration_name)
        if tunnel_ip_addresses is not None:
            pulumi.set(__self__, "tunnel_ip_addresses", tunnel_ip_addresses)

    @property
    @pulumi.getter(name="apipaAddresses")
    def apipa_addresses(self) -> Optional[Sequence[str]]:
        """
        A list of Azure custom APIPA addresses assigned to the BGP peer of the Virtual Network Gateway.
        """
        return pulumi.get(self, "apipa_addresses")

    @property
    @pulumi.getter(name="defaultAddresses")
    def default_addresses(self) -> Optional[Sequence[str]]:
        """
        A list of peering address assigned to the BGP peer of the Virtual Network Gateway.
        """
        return pulumi.get(self, "default_addresses")

    @property
    @pulumi.getter(name="ipConfigurationName")
    def ip_configuration_name(self) -> Optional[str]:
        """
        The name of the IP configuration of this Virtual Network Gateway. In case there are multiple `ip_configuration` blocks defined, this property is **required** to specify.
        """
        return pulumi.get(self, "ip_configuration_name")

    @property
    @pulumi.getter(name="tunnelIpAddresses")
    def tunnel_ip_addresses(self) -> Optional[Sequence[str]]:
        """
        A list of tunnel IP addresses assigned to the BGP peer of the Virtual Network Gateway.
        """
        return pulumi.get(self, "tunnel_ip_addresses")


@pulumi.output_type
class VirtualNetworkGatewayConnectionIpsecPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dhGroup":
            suggest = "dh_group"
        elif key == "ikeEncryption":
            suggest = "ike_encryption"
        elif key == "ikeIntegrity":
            suggest = "ike_integrity"
        elif key == "ipsecEncryption":
            suggest = "ipsec_encryption"
        elif key == "ipsecIntegrity":
            suggest = "ipsec_integrity"
        elif key == "pfsGroup":
            suggest = "pfs_group"
        elif key == "saDatasize":
            suggest = "sa_datasize"
        elif key == "saLifetime":
            suggest = "sa_lifetime"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNetworkGatewayConnectionIpsecPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNetworkGatewayConnectionIpsecPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNetworkGatewayConnectionIpsecPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dh_group: str,
                 ike_encryption: str,
                 ike_integrity: str,
                 ipsec_encryption: str,
                 ipsec_integrity: str,
                 pfs_group: str,
                 sa_datasize: Optional[int] = None,
                 sa_lifetime: Optional[int] = None):
        """
        :param str dh_group: The DH group used in IKE phase 1 for initial SA. Valid
               options are `DHGroup1`, `DHGroup14`, `DHGroup2`, `DHGroup2048`, `DHGroup24`,
               `ECP256`, `ECP384`, or `None`.
        :param str ike_encryption: The IKE encryption algorithm. Valid
               options are `AES128`, `AES192`, `AES256`, `DES`, `DES3`, `GCMAES128`, or `GCMAES256`.
        :param str ike_integrity: The IKE integrity algorithm. Valid
               options are `GCMAES128`, `GCMAES256`, `MD5`, `SHA1`, `SHA256`, or `SHA384`.
        :param str ipsec_encryption: The IPSec encryption algorithm. Valid
               options are `AES128`, `AES192`, `AES256`, `DES`, `DES3`, `GCMAES128`, `GCMAES192`, `GCMAES256`, or `None`.
        :param str ipsec_integrity: The IPSec integrity algorithm. Valid
               options are `GCMAES128`, `GCMAES192`, `GCMAES256`, `MD5`, `SHA1`, or `SHA256`.
        :param str pfs_group: The DH group used in IKE phase 2 for new child SA.
               Valid options are `ECP256`, `ECP384`, `PFS1`, `PFS14`, `PFS2`, `PFS2048`, `PFS24`, `PFSMM`,
               or `None`.
        :param int sa_datasize: The IPSec SA payload size in KB. Must be at least
               `1024` KB. Defaults to `102400000` KB.
        :param int sa_lifetime: The IPSec SA lifetime in seconds. Must be at least
               `300` seconds. Defaults to `27000` seconds.
        """
        pulumi.set(__self__, "dh_group", dh_group)
        pulumi.set(__self__, "ike_encryption", ike_encryption)
        pulumi.set(__self__, "ike_integrity", ike_integrity)
        pulumi.set(__self__, "ipsec_encryption", ipsec_encryption)
        pulumi.set(__self__, "ipsec_integrity", ipsec_integrity)
        pulumi.set(__self__, "pfs_group", pfs_group)
        if sa_datasize is not None:
            pulumi.set(__self__, "sa_datasize", sa_datasize)
        if sa_lifetime is not None:
            pulumi.set(__self__, "sa_lifetime", sa_lifetime)

    @property
    @pulumi.getter(name="dhGroup")
    def dh_group(self) -> str:
        """
        The DH group used in IKE phase 1 for initial SA. Valid
        options are `DHGroup1`, `DHGroup14`, `DHGroup2`, `DHGroup2048`, `DHGroup24`,
        `ECP256`, `ECP384`, or `None`.
        """
        return pulumi.get(self, "dh_group")

    @property
    @pulumi.getter(name="ikeEncryption")
    def ike_encryption(self) -> str:
        """
        The IKE encryption algorithm. Valid
        options are `AES128`, `AES192`, `AES256`, `DES`, `DES3`, `GCMAES128`, or `GCMAES256`.
        """
        return pulumi.get(self, "ike_encryption")

    @property
    @pulumi.getter(name="ikeIntegrity")
    def ike_integrity(self) -> str:
        """
        The IKE integrity algorithm. Valid
        options are `GCMAES128`, `GCMAES256`, `MD5`, `SHA1`, `SHA256`, or `SHA384`.
        """
        return pulumi.get(self, "ike_integrity")

    @property
    @pulumi.getter(name="ipsecEncryption")
    def ipsec_encryption(self) -> str:
        """
        The IPSec encryption algorithm. Valid
        options are `AES128`, `AES192`, `AES256`, `DES`, `DES3`, `GCMAES128`, `GCMAES192`, `GCMAES256`, or `None`.
        """
        return pulumi.get(self, "ipsec_encryption")

    @property
    @pulumi.getter(name="ipsecIntegrity")
    def ipsec_integrity(self) -> str:
        """
        The IPSec integrity algorithm. Valid
        options are `GCMAES128`, `GCMAES192`, `GCMAES256`, `MD5`, `SHA1`, or `SHA256`.
        """
        return pulumi.get(self, "ipsec_integrity")

    @property
    @pulumi.getter(name="pfsGroup")
    def pfs_group(self) -> str:
        """
        The DH group used in IKE phase 2 for new child SA.
        Valid options are `ECP256`, `ECP384`, `PFS1`, `PFS14`, `PFS2`, `PFS2048`, `PFS24`, `PFSMM`,
        or `None`.
        """
        return pulumi.get(self, "pfs_group")

    @property
    @pulumi.getter(name="saDatasize")
    def sa_datasize(self) -> Optional[int]:
        """
        The IPSec SA payload size in KB. Must be at least
        `1024` KB. Defaults to `102400000` KB.
        """
        return pulumi.get(self, "sa_datasize")

    @property
    @pulumi.getter(name="saLifetime")
    def sa_lifetime(self) -> Optional[int]:
        """
        The IPSec SA lifetime in seconds. Must be at least
        `300` seconds. Defaults to `27000` seconds.
        """
        return pulumi.get(self, "sa_lifetime")


@pulumi.output_type
class VirtualNetworkGatewayConnectionTrafficSelectorPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localAddressCidrs":
            suggest = "local_address_cidrs"
        elif key == "remoteAddressCidrs":
            suggest = "remote_address_cidrs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNetworkGatewayConnectionTrafficSelectorPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNetworkGatewayConnectionTrafficSelectorPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNetworkGatewayConnectionTrafficSelectorPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 local_address_cidrs: Sequence[str],
                 remote_address_cidrs: Sequence[str]):
        pulumi.set(__self__, "local_address_cidrs", local_address_cidrs)
        pulumi.set(__self__, "remote_address_cidrs", remote_address_cidrs)

    @property
    @pulumi.getter(name="localAddressCidrs")
    def local_address_cidrs(self) -> Sequence[str]:
        return pulumi.get(self, "local_address_cidrs")

    @property
    @pulumi.getter(name="remoteAddressCidrs")
    def remote_address_cidrs(self) -> Sequence[str]:
        return pulumi.get(self, "remote_address_cidrs")


@pulumi.output_type
class VirtualNetworkGatewayCustomRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressPrefixes":
            suggest = "address_prefixes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNetworkGatewayCustomRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNetworkGatewayCustomRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNetworkGatewayCustomRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address_prefixes: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] address_prefixes: A list of address blocks reserved for this virtual network in CIDR notation.
        """
        if address_prefixes is not None:
            pulumi.set(__self__, "address_prefixes", address_prefixes)

    @property
    @pulumi.getter(name="addressPrefixes")
    def address_prefixes(self) -> Optional[Sequence[str]]:
        """
        A list of address blocks reserved for this virtual network in CIDR notation.
        """
        return pulumi.get(self, "address_prefixes")


@pulumi.output_type
class VirtualNetworkGatewayIpConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicIpAddressId":
            suggest = "public_ip_address_id"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "privateIpAddressAllocation":
            suggest = "private_ip_address_allocation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNetworkGatewayIpConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNetworkGatewayIpConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNetworkGatewayIpConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 public_ip_address_id: str,
                 subnet_id: str,
                 name: Optional[str] = None,
                 private_ip_address_allocation: Optional[str] = None):
        """
        :param str public_ip_address_id: The ID of the public ip address to associate
               with the Virtual Network Gateway.
        :param str subnet_id: The ID of the gateway subnet of a virtual network in
               which the virtual network gateway will be created. It is mandatory that
               the associated subnet is named `GatewaySubnet`. Therefore, each virtual
               network can contain at most a single Virtual Network Gateway.
        :param str name: A user-defined name of the IP configuration. Defaults to
               `vnetGatewayConfig`.
        :param str private_ip_address_allocation: Defines how the private IP address
               of the gateways virtual interface is assigned. Valid options are `Static` or
               `Dynamic`. Defaults to `Dynamic`.
        """
        pulumi.set(__self__, "public_ip_address_id", public_ip_address_id)
        pulumi.set(__self__, "subnet_id", subnet_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if private_ip_address_allocation is not None:
            pulumi.set(__self__, "private_ip_address_allocation", private_ip_address_allocation)

    @property
    @pulumi.getter(name="publicIpAddressId")
    def public_ip_address_id(self) -> str:
        """
        The ID of the public ip address to associate
        with the Virtual Network Gateway.
        """
        return pulumi.get(self, "public_ip_address_id")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The ID of the gateway subnet of a virtual network in
        which the virtual network gateway will be created. It is mandatory that
        the associated subnet is named `GatewaySubnet`. Therefore, each virtual
        network can contain at most a single Virtual Network Gateway.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A user-defined name of the IP configuration. Defaults to
        `vnetGatewayConfig`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateIpAddressAllocation")
    def private_ip_address_allocation(self) -> Optional[str]:
        """
        Defines how the private IP address
        of the gateways virtual interface is assigned. Valid options are `Static` or
        `Dynamic`. Defaults to `Dynamic`.
        """
        return pulumi.get(self, "private_ip_address_allocation")


@pulumi.output_type
class VirtualNetworkGatewayVpnClientConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressSpaces":
            suggest = "address_spaces"
        elif key == "aadAudience":
            suggest = "aad_audience"
        elif key == "aadIssuer":
            suggest = "aad_issuer"
        elif key == "aadTenant":
            suggest = "aad_tenant"
        elif key == "radiusServerAddress":
            suggest = "radius_server_address"
        elif key == "radiusServerSecret":
            suggest = "radius_server_secret"
        elif key == "revokedCertificates":
            suggest = "revoked_certificates"
        elif key == "rootCertificates":
            suggest = "root_certificates"
        elif key == "vpnClientProtocols":
            suggest = "vpn_client_protocols"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNetworkGatewayVpnClientConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNetworkGatewayVpnClientConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNetworkGatewayVpnClientConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address_spaces: Sequence[str],
                 aad_audience: Optional[str] = None,
                 aad_issuer: Optional[str] = None,
                 aad_tenant: Optional[str] = None,
                 radius_server_address: Optional[str] = None,
                 radius_server_secret: Optional[str] = None,
                 revoked_certificates: Optional[Sequence['outputs.VirtualNetworkGatewayVpnClientConfigurationRevokedCertificate']] = None,
                 root_certificates: Optional[Sequence['outputs.VirtualNetworkGatewayVpnClientConfigurationRootCertificate']] = None,
                 vpn_client_protocols: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] address_spaces: The address space out of which ip addresses for
               vpn clients will be taken. You can provide more than one address space, e.g.
               in CIDR notation.
        :param str aad_audience: The client id of the Azure VPN application.
               See [Create an Active Directory (AD) tenant for P2S OpenVPN protocol connections](https://docs.microsoft.com/en-gb/azure/vpn-gateway/openvpn-azure-ad-tenant-multi-app) for values
               This setting is incompatible with the use of
               `root_certificate` and `revoked_certificate`, `radius_server_address`, and `radius_server_secret`.
        :param str aad_issuer: The STS url for your tenant
               This setting is incompatible with the use of
               `root_certificate` and `revoked_certificate`, `radius_server_address`, and `radius_server_secret`.
        :param str aad_tenant: AzureAD Tenant URL
               This setting is incompatible with the use of
               `root_certificate` and `revoked_certificate`, `radius_server_address`, and `radius_server_secret`.
        :param str radius_server_address: The address of the Radius server.
               This setting is incompatible with the use of
               `aad_tenant`, `aad_audience`, `aad_issuer`, `root_certificate` and `revoked_certificate`.
        :param str radius_server_secret: The secret used by the Radius server.
               This setting is incompatible with the use of
               `aad_tenant`, `aad_audience`, `aad_issuer`, `root_certificate` and `revoked_certificate`.
        :param Sequence['VirtualNetworkGatewayVpnClientConfigurationRevokedCertificateArgs'] revoked_certificates: One or more `revoked_certificate` blocks which
               are defined below.
               This setting is incompatible with the use of
               `aad_tenant`, `aad_audience`, `aad_issuer`, `radius_server_address`, and `radius_server_secret`.
        :param Sequence['VirtualNetworkGatewayVpnClientConfigurationRootCertificateArgs'] root_certificates: One or more `root_certificate` blocks which are
               defined below. These root certificates are used to sign the client certificate
               used by the VPN clients to connect to the gateway.
               This setting is incompatible with the use of
               `aad_tenant`, `aad_audience`, `aad_issuer`, `radius_server_address`, and `radius_server_secret`.
        :param Sequence[str] vpn_client_protocols: List of the protocols supported by the vpn client.
               The supported values are `SSTP`, `IkeV2` and `OpenVPN`.
               Values `SSTP` and `IkeV2` are incompatible with the use of
               `aad_tenant`, `aad_audience` and `aad_issuer`.
        """
        pulumi.set(__self__, "address_spaces", address_spaces)
        if aad_audience is not None:
            pulumi.set(__self__, "aad_audience", aad_audience)
        if aad_issuer is not None:
            pulumi.set(__self__, "aad_issuer", aad_issuer)
        if aad_tenant is not None:
            pulumi.set(__self__, "aad_tenant", aad_tenant)
        if radius_server_address is not None:
            pulumi.set(__self__, "radius_server_address", radius_server_address)
        if radius_server_secret is not None:
            pulumi.set(__self__, "radius_server_secret", radius_server_secret)
        if revoked_certificates is not None:
            pulumi.set(__self__, "revoked_certificates", revoked_certificates)
        if root_certificates is not None:
            pulumi.set(__self__, "root_certificates", root_certificates)
        if vpn_client_protocols is not None:
            pulumi.set(__self__, "vpn_client_protocols", vpn_client_protocols)

    @property
    @pulumi.getter(name="addressSpaces")
    def address_spaces(self) -> Sequence[str]:
        """
        The address space out of which ip addresses for
        vpn clients will be taken. You can provide more than one address space, e.g.
        in CIDR notation.
        """
        return pulumi.get(self, "address_spaces")

    @property
    @pulumi.getter(name="aadAudience")
    def aad_audience(self) -> Optional[str]:
        """
        The client id of the Azure VPN application.
        See [Create an Active Directory (AD) tenant for P2S OpenVPN protocol connections](https://docs.microsoft.com/en-gb/azure/vpn-gateway/openvpn-azure-ad-tenant-multi-app) for values
        This setting is incompatible with the use of
        `root_certificate` and `revoked_certificate`, `radius_server_address`, and `radius_server_secret`.
        """
        return pulumi.get(self, "aad_audience")

    @property
    @pulumi.getter(name="aadIssuer")
    def aad_issuer(self) -> Optional[str]:
        """
        The STS url for your tenant
        This setting is incompatible with the use of
        `root_certificate` and `revoked_certificate`, `radius_server_address`, and `radius_server_secret`.
        """
        return pulumi.get(self, "aad_issuer")

    @property
    @pulumi.getter(name="aadTenant")
    def aad_tenant(self) -> Optional[str]:
        """
        AzureAD Tenant URL
        This setting is incompatible with the use of
        `root_certificate` and `revoked_certificate`, `radius_server_address`, and `radius_server_secret`.
        """
        return pulumi.get(self, "aad_tenant")

    @property
    @pulumi.getter(name="radiusServerAddress")
    def radius_server_address(self) -> Optional[str]:
        """
        The address of the Radius server.
        This setting is incompatible with the use of
        `aad_tenant`, `aad_audience`, `aad_issuer`, `root_certificate` and `revoked_certificate`.
        """
        return pulumi.get(self, "radius_server_address")

    @property
    @pulumi.getter(name="radiusServerSecret")
    def radius_server_secret(self) -> Optional[str]:
        """
        The secret used by the Radius server.
        This setting is incompatible with the use of
        `aad_tenant`, `aad_audience`, `aad_issuer`, `root_certificate` and `revoked_certificate`.
        """
        return pulumi.get(self, "radius_server_secret")

    @property
    @pulumi.getter(name="revokedCertificates")
    def revoked_certificates(self) -> Optional[Sequence['outputs.VirtualNetworkGatewayVpnClientConfigurationRevokedCertificate']]:
        """
        One or more `revoked_certificate` blocks which
        are defined below.
        This setting is incompatible with the use of
        `aad_tenant`, `aad_audience`, `aad_issuer`, `radius_server_address`, and `radius_server_secret`.
        """
        return pulumi.get(self, "revoked_certificates")

    @property
    @pulumi.getter(name="rootCertificates")
    def root_certificates(self) -> Optional[Sequence['outputs.VirtualNetworkGatewayVpnClientConfigurationRootCertificate']]:
        """
        One or more `root_certificate` blocks which are
        defined below. These root certificates are used to sign the client certificate
        used by the VPN clients to connect to the gateway.
        This setting is incompatible with the use of
        `aad_tenant`, `aad_audience`, `aad_issuer`, `radius_server_address`, and `radius_server_secret`.
        """
        return pulumi.get(self, "root_certificates")

    @property
    @pulumi.getter(name="vpnClientProtocols")
    def vpn_client_protocols(self) -> Optional[Sequence[str]]:
        """
        List of the protocols supported by the vpn client.
        The supported values are `SSTP`, `IkeV2` and `OpenVPN`.
        Values `SSTP` and `IkeV2` are incompatible with the use of
        `aad_tenant`, `aad_audience` and `aad_issuer`.
        """
        return pulumi.get(self, "vpn_client_protocols")


@pulumi.output_type
class VirtualNetworkGatewayVpnClientConfigurationRevokedCertificate(dict):
    def __init__(__self__, *,
                 name: str,
                 thumbprint: str):
        """
        :param str name: A user-defined name of the IP configuration. Defaults to
               `vnetGatewayConfig`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "thumbprint", thumbprint)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A user-defined name of the IP configuration. Defaults to
        `vnetGatewayConfig`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def thumbprint(self) -> str:
        return pulumi.get(self, "thumbprint")


@pulumi.output_type
class VirtualNetworkGatewayVpnClientConfigurationRootCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicCertData":
            suggest = "public_cert_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNetworkGatewayVpnClientConfigurationRootCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNetworkGatewayVpnClientConfigurationRootCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNetworkGatewayVpnClientConfigurationRootCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 public_cert_data: str):
        """
        :param str name: A user-defined name of the IP configuration. Defaults to
               `vnetGatewayConfig`.
        :param str public_cert_data: The public certificate of the root certificate
               authority. The certificate must be provided in Base-64 encoded X.509 format
               (PEM). In particular, this argument *must not* include the
               `-----BEGIN CERTIFICATE-----` or `-----END CERTIFICATE-----` markers.
               revoked.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "public_cert_data", public_cert_data)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A user-defined name of the IP configuration. Defaults to
        `vnetGatewayConfig`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="publicCertData")
    def public_cert_data(self) -> str:
        """
        The public certificate of the root certificate
        authority. The certificate must be provided in Base-64 encoded X.509 format
        (PEM). In particular, this argument *must not* include the
        `-----BEGIN CERTIFICATE-----` or `-----END CERTIFICATE-----` markers.
        revoked.
        """
        return pulumi.get(self, "public_cert_data")


@pulumi.output_type
class VirtualNetworkSubnet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressPrefix":
            suggest = "address_prefix"
        elif key == "securityGroup":
            suggest = "security_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNetworkSubnet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNetworkSubnet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNetworkSubnet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address_prefix: str,
                 name: str,
                 id: Optional[str] = None,
                 security_group: Optional[str] = None):
        """
        :param str address_prefix: The address prefix to use for the subnet.
        :param str name: The name of the virtual network. Changing this forces a new resource to be created.
        :param str id: The ID of DDoS Protection Plan.
        :param str security_group: The Network Security Group to associate with the subnet. (Referenced by `id`, ie. `azurerm_network_security_group.example.id`)
        """
        pulumi.set(__self__, "address_prefix", address_prefix)
        pulumi.set(__self__, "name", name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if security_group is not None:
            pulumi.set(__self__, "security_group", security_group)

    @property
    @pulumi.getter(name="addressPrefix")
    def address_prefix(self) -> str:
        """
        The address prefix to use for the subnet.
        """
        return pulumi.get(self, "address_prefix")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the virtual network. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of DDoS Protection Plan.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="securityGroup")
    def security_group(self) -> Optional[str]:
        """
        The Network Security Group to associate with the subnet. (Referenced by `id`, ie. `azurerm_network_security_group.example.id`)
        """
        return pulumi.get(self, "security_group")


@pulumi.output_type
class VpnGatewayBgpSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "peerWeight":
            suggest = "peer_weight"
        elif key == "bgpPeeringAddress":
            suggest = "bgp_peering_address"
        elif key == "instance0BgpPeeringAddress":
            suggest = "instance0_bgp_peering_address"
        elif key == "instance1BgpPeeringAddress":
            suggest = "instance1_bgp_peering_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnGatewayBgpSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnGatewayBgpSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnGatewayBgpSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 asn: int,
                 peer_weight: int,
                 bgp_peering_address: Optional[str] = None,
                 instance0_bgp_peering_address: Optional['outputs.VpnGatewayBgpSettingsInstance0BgpPeeringAddress'] = None,
                 instance1_bgp_peering_address: Optional['outputs.VpnGatewayBgpSettingsInstance1BgpPeeringAddress'] = None):
        """
        :param int asn: The ASN of the BGP Speaker. Changing this forces a new resource to be created.
        :param int peer_weight: The weight added to Routes learned from this BGP Speaker. Changing this forces a new resource to be created.
        :param str bgp_peering_address: The Address which should be used for the BGP Peering.
        :param 'VpnGatewayBgpSettingsInstance0BgpPeeringAddressArgs' instance0_bgp_peering_address: An `instance_bgp_peering_address` block as defined below.
        :param 'VpnGatewayBgpSettingsInstance1BgpPeeringAddressArgs' instance1_bgp_peering_address: An `instance_bgp_peering_address` block as defined below.
        """
        pulumi.set(__self__, "asn", asn)
        pulumi.set(__self__, "peer_weight", peer_weight)
        if bgp_peering_address is not None:
            pulumi.set(__self__, "bgp_peering_address", bgp_peering_address)
        if instance0_bgp_peering_address is not None:
            pulumi.set(__self__, "instance0_bgp_peering_address", instance0_bgp_peering_address)
        if instance1_bgp_peering_address is not None:
            pulumi.set(__self__, "instance1_bgp_peering_address", instance1_bgp_peering_address)

    @property
    @pulumi.getter
    def asn(self) -> int:
        """
        The ASN of the BGP Speaker. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "asn")

    @property
    @pulumi.getter(name="peerWeight")
    def peer_weight(self) -> int:
        """
        The weight added to Routes learned from this BGP Speaker. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "peer_weight")

    @property
    @pulumi.getter(name="bgpPeeringAddress")
    def bgp_peering_address(self) -> Optional[str]:
        """
        The Address which should be used for the BGP Peering.
        """
        return pulumi.get(self, "bgp_peering_address")

    @property
    @pulumi.getter(name="instance0BgpPeeringAddress")
    def instance0_bgp_peering_address(self) -> Optional['outputs.VpnGatewayBgpSettingsInstance0BgpPeeringAddress']:
        """
        An `instance_bgp_peering_address` block as defined below.
        """
        return pulumi.get(self, "instance0_bgp_peering_address")

    @property
    @pulumi.getter(name="instance1BgpPeeringAddress")
    def instance1_bgp_peering_address(self) -> Optional['outputs.VpnGatewayBgpSettingsInstance1BgpPeeringAddress']:
        """
        An `instance_bgp_peering_address` block as defined below.
        """
        return pulumi.get(self, "instance1_bgp_peering_address")


@pulumi.output_type
class VpnGatewayBgpSettingsInstance0BgpPeeringAddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customIps":
            suggest = "custom_ips"
        elif key == "defaultIps":
            suggest = "default_ips"
        elif key == "ipConfigurationId":
            suggest = "ip_configuration_id"
        elif key == "tunnelIps":
            suggest = "tunnel_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnGatewayBgpSettingsInstance0BgpPeeringAddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnGatewayBgpSettingsInstance0BgpPeeringAddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnGatewayBgpSettingsInstance0BgpPeeringAddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_ips: Sequence[str],
                 default_ips: Optional[Sequence[str]] = None,
                 ip_configuration_id: Optional[str] = None,
                 tunnel_ips: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] custom_ips: A list of custom BGP peering addresses to assign to this instance.
        :param Sequence[str] default_ips: The list of default BGP peering addresses which belong to the pre-defined VPN Gateway IP configuration.
        :param str ip_configuration_id: The pre-defined id of VPN Gateway Ip Configuration.
        :param Sequence[str] tunnel_ips: The list of tunnel public IP addresses which belong to the pre-defined VPN Gateway IP configuration.
        """
        pulumi.set(__self__, "custom_ips", custom_ips)
        if default_ips is not None:
            pulumi.set(__self__, "default_ips", default_ips)
        if ip_configuration_id is not None:
            pulumi.set(__self__, "ip_configuration_id", ip_configuration_id)
        if tunnel_ips is not None:
            pulumi.set(__self__, "tunnel_ips", tunnel_ips)

    @property
    @pulumi.getter(name="customIps")
    def custom_ips(self) -> Sequence[str]:
        """
        A list of custom BGP peering addresses to assign to this instance.
        """
        return pulumi.get(self, "custom_ips")

    @property
    @pulumi.getter(name="defaultIps")
    def default_ips(self) -> Optional[Sequence[str]]:
        """
        The list of default BGP peering addresses which belong to the pre-defined VPN Gateway IP configuration.
        """
        return pulumi.get(self, "default_ips")

    @property
    @pulumi.getter(name="ipConfigurationId")
    def ip_configuration_id(self) -> Optional[str]:
        """
        The pre-defined id of VPN Gateway Ip Configuration.
        """
        return pulumi.get(self, "ip_configuration_id")

    @property
    @pulumi.getter(name="tunnelIps")
    def tunnel_ips(self) -> Optional[Sequence[str]]:
        """
        The list of tunnel public IP addresses which belong to the pre-defined VPN Gateway IP configuration.
        """
        return pulumi.get(self, "tunnel_ips")


@pulumi.output_type
class VpnGatewayBgpSettingsInstance1BgpPeeringAddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customIps":
            suggest = "custom_ips"
        elif key == "defaultIps":
            suggest = "default_ips"
        elif key == "ipConfigurationId":
            suggest = "ip_configuration_id"
        elif key == "tunnelIps":
            suggest = "tunnel_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnGatewayBgpSettingsInstance1BgpPeeringAddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnGatewayBgpSettingsInstance1BgpPeeringAddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnGatewayBgpSettingsInstance1BgpPeeringAddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_ips: Sequence[str],
                 default_ips: Optional[Sequence[str]] = None,
                 ip_configuration_id: Optional[str] = None,
                 tunnel_ips: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] custom_ips: A list of custom BGP peering addresses to assign to this instance.
        :param Sequence[str] default_ips: The list of default BGP peering addresses which belong to the pre-defined VPN Gateway IP configuration.
        :param str ip_configuration_id: The pre-defined id of VPN Gateway Ip Configuration.
        :param Sequence[str] tunnel_ips: The list of tunnel public IP addresses which belong to the pre-defined VPN Gateway IP configuration.
        """
        pulumi.set(__self__, "custom_ips", custom_ips)
        if default_ips is not None:
            pulumi.set(__self__, "default_ips", default_ips)
        if ip_configuration_id is not None:
            pulumi.set(__self__, "ip_configuration_id", ip_configuration_id)
        if tunnel_ips is not None:
            pulumi.set(__self__, "tunnel_ips", tunnel_ips)

    @property
    @pulumi.getter(name="customIps")
    def custom_ips(self) -> Sequence[str]:
        """
        A list of custom BGP peering addresses to assign to this instance.
        """
        return pulumi.get(self, "custom_ips")

    @property
    @pulumi.getter(name="defaultIps")
    def default_ips(self) -> Optional[Sequence[str]]:
        """
        The list of default BGP peering addresses which belong to the pre-defined VPN Gateway IP configuration.
        """
        return pulumi.get(self, "default_ips")

    @property
    @pulumi.getter(name="ipConfigurationId")
    def ip_configuration_id(self) -> Optional[str]:
        """
        The pre-defined id of VPN Gateway Ip Configuration.
        """
        return pulumi.get(self, "ip_configuration_id")

    @property
    @pulumi.getter(name="tunnelIps")
    def tunnel_ips(self) -> Optional[Sequence[str]]:
        """
        The list of tunnel public IP addresses which belong to the pre-defined VPN Gateway IP configuration.
        """
        return pulumi.get(self, "tunnel_ips")


@pulumi.output_type
class VpnGatewayConnectionRouting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "associatedRouteTable":
            suggest = "associated_route_table"
        elif key == "propagatedRouteTables":
            suggest = "propagated_route_tables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnGatewayConnectionRouting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnGatewayConnectionRouting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnGatewayConnectionRouting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 associated_route_table: str,
                 propagated_route_tables: Sequence[str]):
        """
        :param str associated_route_table: The ID of the Route Table associated with this VPN Connection.
        :param Sequence[str] propagated_route_tables: The list IDs of Route Tables to advertise the routes of this VPN Connection.
        """
        pulumi.set(__self__, "associated_route_table", associated_route_table)
        pulumi.set(__self__, "propagated_route_tables", propagated_route_tables)

    @property
    @pulumi.getter(name="associatedRouteTable")
    def associated_route_table(self) -> str:
        """
        The ID of the Route Table associated with this VPN Connection.
        """
        return pulumi.get(self, "associated_route_table")

    @property
    @pulumi.getter(name="propagatedRouteTables")
    def propagated_route_tables(self) -> Sequence[str]:
        """
        The list IDs of Route Tables to advertise the routes of this VPN Connection.
        """
        return pulumi.get(self, "propagated_route_tables")


@pulumi.output_type
class VpnGatewayConnectionVpnLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vpnSiteLinkId":
            suggest = "vpn_site_link_id"
        elif key == "bandwidthMbps":
            suggest = "bandwidth_mbps"
        elif key == "bgpEnabled":
            suggest = "bgp_enabled"
        elif key == "ipsecPolicies":
            suggest = "ipsec_policies"
        elif key == "localAzureIpAddressEnabled":
            suggest = "local_azure_ip_address_enabled"
        elif key == "policyBasedTrafficSelectorEnabled":
            suggest = "policy_based_traffic_selector_enabled"
        elif key == "ratelimitEnabled":
            suggest = "ratelimit_enabled"
        elif key == "routeWeight":
            suggest = "route_weight"
        elif key == "sharedKey":
            suggest = "shared_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnGatewayConnectionVpnLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnGatewayConnectionVpnLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnGatewayConnectionVpnLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 vpn_site_link_id: str,
                 bandwidth_mbps: Optional[int] = None,
                 bgp_enabled: Optional[bool] = None,
                 ipsec_policies: Optional[Sequence['outputs.VpnGatewayConnectionVpnLinkIpsecPolicy']] = None,
                 local_azure_ip_address_enabled: Optional[bool] = None,
                 policy_based_traffic_selector_enabled: Optional[bool] = None,
                 protocol: Optional[str] = None,
                 ratelimit_enabled: Optional[bool] = None,
                 route_weight: Optional[int] = None,
                 shared_key: Optional[str] = None):
        """
        :param str name: The name which should be used for this VPN Link Connection.
        :param str vpn_site_link_id: The ID of the connected VPN Site Link. Changing this forces a new VPN Gateway Connection to be created.
        :param int bandwidth_mbps: The expected connection bandwidth in MBPS. Defaults to `10`.
        :param bool bgp_enabled: Should the BGP be enabled? Defaults to `false`. Changing this forces a new VPN Gateway Connection to be created.
        :param Sequence['VpnGatewayConnectionVpnLinkIpsecPolicyArgs'] ipsec_policies: One or more `ipsec_policy` blocks as defined above.
        :param bool local_azure_ip_address_enabled: Whether to use local azure ip to initiate connection? Defaults to `false`.
        :param bool policy_based_traffic_selector_enabled: Whether to enable policy-based traffic selectors? Defaults to `false`.
        :param str protocol: The protocol used for this VPN Link Connection. Possible values are `IKEv1` and `IKEv2`. Defaults to `IKEv2`.
        :param bool ratelimit_enabled: Should the rate limit be enabled? Defaults to `false`.
        :param int route_weight: Routing weight for this VPN Link Connection. Defaults to `0`.
        :param str shared_key: SharedKey for this VPN Link Connection.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "vpn_site_link_id", vpn_site_link_id)
        if bandwidth_mbps is not None:
            pulumi.set(__self__, "bandwidth_mbps", bandwidth_mbps)
        if bgp_enabled is not None:
            pulumi.set(__self__, "bgp_enabled", bgp_enabled)
        if ipsec_policies is not None:
            pulumi.set(__self__, "ipsec_policies", ipsec_policies)
        if local_azure_ip_address_enabled is not None:
            pulumi.set(__self__, "local_azure_ip_address_enabled", local_azure_ip_address_enabled)
        if policy_based_traffic_selector_enabled is not None:
            pulumi.set(__self__, "policy_based_traffic_selector_enabled", policy_based_traffic_selector_enabled)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if ratelimit_enabled is not None:
            pulumi.set(__self__, "ratelimit_enabled", ratelimit_enabled)
        if route_weight is not None:
            pulumi.set(__self__, "route_weight", route_weight)
        if shared_key is not None:
            pulumi.set(__self__, "shared_key", shared_key)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this VPN Link Connection.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="vpnSiteLinkId")
    def vpn_site_link_id(self) -> str:
        """
        The ID of the connected VPN Site Link. Changing this forces a new VPN Gateway Connection to be created.
        """
        return pulumi.get(self, "vpn_site_link_id")

    @property
    @pulumi.getter(name="bandwidthMbps")
    def bandwidth_mbps(self) -> Optional[int]:
        """
        The expected connection bandwidth in MBPS. Defaults to `10`.
        """
        return pulumi.get(self, "bandwidth_mbps")

    @property
    @pulumi.getter(name="bgpEnabled")
    def bgp_enabled(self) -> Optional[bool]:
        """
        Should the BGP be enabled? Defaults to `false`. Changing this forces a new VPN Gateway Connection to be created.
        """
        return pulumi.get(self, "bgp_enabled")

    @property
    @pulumi.getter(name="ipsecPolicies")
    def ipsec_policies(self) -> Optional[Sequence['outputs.VpnGatewayConnectionVpnLinkIpsecPolicy']]:
        """
        One or more `ipsec_policy` blocks as defined above.
        """
        return pulumi.get(self, "ipsec_policies")

    @property
    @pulumi.getter(name="localAzureIpAddressEnabled")
    def local_azure_ip_address_enabled(self) -> Optional[bool]:
        """
        Whether to use local azure ip to initiate connection? Defaults to `false`.
        """
        return pulumi.get(self, "local_azure_ip_address_enabled")

    @property
    @pulumi.getter(name="policyBasedTrafficSelectorEnabled")
    def policy_based_traffic_selector_enabled(self) -> Optional[bool]:
        """
        Whether to enable policy-based traffic selectors? Defaults to `false`.
        """
        return pulumi.get(self, "policy_based_traffic_selector_enabled")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        The protocol used for this VPN Link Connection. Possible values are `IKEv1` and `IKEv2`. Defaults to `IKEv2`.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="ratelimitEnabled")
    def ratelimit_enabled(self) -> Optional[bool]:
        """
        Should the rate limit be enabled? Defaults to `false`.
        """
        return pulumi.get(self, "ratelimit_enabled")

    @property
    @pulumi.getter(name="routeWeight")
    def route_weight(self) -> Optional[int]:
        """
        Routing weight for this VPN Link Connection. Defaults to `0`.
        """
        return pulumi.get(self, "route_weight")

    @property
    @pulumi.getter(name="sharedKey")
    def shared_key(self) -> Optional[str]:
        """
        SharedKey for this VPN Link Connection.
        """
        return pulumi.get(self, "shared_key")


@pulumi.output_type
class VpnGatewayConnectionVpnLinkIpsecPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dhGroup":
            suggest = "dh_group"
        elif key == "encryptionAlgorithm":
            suggest = "encryption_algorithm"
        elif key == "ikeEncryptionAlgorithm":
            suggest = "ike_encryption_algorithm"
        elif key == "ikeIntegrityAlgorithm":
            suggest = "ike_integrity_algorithm"
        elif key == "integrityAlgorithm":
            suggest = "integrity_algorithm"
        elif key == "pfsGroup":
            suggest = "pfs_group"
        elif key == "saDataSizeKb":
            suggest = "sa_data_size_kb"
        elif key == "saLifetimeSec":
            suggest = "sa_lifetime_sec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnGatewayConnectionVpnLinkIpsecPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnGatewayConnectionVpnLinkIpsecPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnGatewayConnectionVpnLinkIpsecPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dh_group: str,
                 encryption_algorithm: str,
                 ike_encryption_algorithm: str,
                 ike_integrity_algorithm: str,
                 integrity_algorithm: str,
                 pfs_group: str,
                 sa_data_size_kb: int,
                 sa_lifetime_sec: int):
        """
        :param str dh_group: The DH Group used in IKE Phase 1 for initial SA. Possible values are `None`, `DHGroup1`, `DHGroup2`, `DHGroup14`, `DHGroup24`, `DHGroup2048`, `ECP256`, `ECP384`.
        :param str encryption_algorithm: The IPSec encryption algorithm (IKE phase 1). Possible values are `AES128`, `AES192`, `AES256`, `DES`, `DES3`, `GCMAES128`, `GCMAES192`, `GCMAES256`, `None`.
        :param str ike_encryption_algorithm: The IKE encryption algorithm (IKE phase 2). Possible values are `DES`, `DES3`, `AES128`, `AES192`, `AES256`, `GCMAES128`, `GCMAES256`.
        :param str ike_integrity_algorithm: The IKE integrity algorithm (IKE phase 2). Possible values are `MD5`, `SHA1`, `SHA256`, `SHA384`, `GCMAES128`, `GCMAES256`.
        :param str integrity_algorithm: The IPSec integrity algorithm (IKE phase 1). Possible values are `MD5`, `SHA1`, `SHA256`, `GCMAES128`, `GCMAES192`, `GCMAES256`.
        :param str pfs_group: The Pfs Group used in IKE Phase 2 for the new child SA. Possible values are `None`, `PFS1`, `PFS2`, `PFS14`, `PFS24`, `PFS2048`, `PFSMM`, `ECP256`, `ECP384`.
        :param int sa_data_size_kb: The IPSec Security Association (also called Quick Mode or Phase 2 SA) payload size in KB for the site to site VPN tunnel.
        :param int sa_lifetime_sec: The IPSec Security Association (also called Quick Mode or Phase 2 SA) lifetime in seconds for the site to site VPN tunnel.
        """
        pulumi.set(__self__, "dh_group", dh_group)
        pulumi.set(__self__, "encryption_algorithm", encryption_algorithm)
        pulumi.set(__self__, "ike_encryption_algorithm", ike_encryption_algorithm)
        pulumi.set(__self__, "ike_integrity_algorithm", ike_integrity_algorithm)
        pulumi.set(__self__, "integrity_algorithm", integrity_algorithm)
        pulumi.set(__self__, "pfs_group", pfs_group)
        pulumi.set(__self__, "sa_data_size_kb", sa_data_size_kb)
        pulumi.set(__self__, "sa_lifetime_sec", sa_lifetime_sec)

    @property
    @pulumi.getter(name="dhGroup")
    def dh_group(self) -> str:
        """
        The DH Group used in IKE Phase 1 for initial SA. Possible values are `None`, `DHGroup1`, `DHGroup2`, `DHGroup14`, `DHGroup24`, `DHGroup2048`, `ECP256`, `ECP384`.
        """
        return pulumi.get(self, "dh_group")

    @property
    @pulumi.getter(name="encryptionAlgorithm")
    def encryption_algorithm(self) -> str:
        """
        The IPSec encryption algorithm (IKE phase 1). Possible values are `AES128`, `AES192`, `AES256`, `DES`, `DES3`, `GCMAES128`, `GCMAES192`, `GCMAES256`, `None`.
        """
        return pulumi.get(self, "encryption_algorithm")

    @property
    @pulumi.getter(name="ikeEncryptionAlgorithm")
    def ike_encryption_algorithm(self) -> str:
        """
        The IKE encryption algorithm (IKE phase 2). Possible values are `DES`, `DES3`, `AES128`, `AES192`, `AES256`, `GCMAES128`, `GCMAES256`.
        """
        return pulumi.get(self, "ike_encryption_algorithm")

    @property
    @pulumi.getter(name="ikeIntegrityAlgorithm")
    def ike_integrity_algorithm(self) -> str:
        """
        The IKE integrity algorithm (IKE phase 2). Possible values are `MD5`, `SHA1`, `SHA256`, `SHA384`, `GCMAES128`, `GCMAES256`.
        """
        return pulumi.get(self, "ike_integrity_algorithm")

    @property
    @pulumi.getter(name="integrityAlgorithm")
    def integrity_algorithm(self) -> str:
        """
        The IPSec integrity algorithm (IKE phase 1). Possible values are `MD5`, `SHA1`, `SHA256`, `GCMAES128`, `GCMAES192`, `GCMAES256`.
        """
        return pulumi.get(self, "integrity_algorithm")

    @property
    @pulumi.getter(name="pfsGroup")
    def pfs_group(self) -> str:
        """
        The Pfs Group used in IKE Phase 2 for the new child SA. Possible values are `None`, `PFS1`, `PFS2`, `PFS14`, `PFS24`, `PFS2048`, `PFSMM`, `ECP256`, `ECP384`.
        """
        return pulumi.get(self, "pfs_group")

    @property
    @pulumi.getter(name="saDataSizeKb")
    def sa_data_size_kb(self) -> int:
        """
        The IPSec Security Association (also called Quick Mode or Phase 2 SA) payload size in KB for the site to site VPN tunnel.
        """
        return pulumi.get(self, "sa_data_size_kb")

    @property
    @pulumi.getter(name="saLifetimeSec")
    def sa_lifetime_sec(self) -> int:
        """
        The IPSec Security Association (also called Quick Mode or Phase 2 SA) lifetime in seconds for the site to site VPN tunnel.
        """
        return pulumi.get(self, "sa_lifetime_sec")


@pulumi.output_type
class VpnServerConfigurationAzureActiveDirectoryAuthentication(dict):
    def __init__(__self__, *,
                 audience: str,
                 issuer: str,
                 tenant: str):
        """
        :param str audience: The Audience which should be used for authentication.
        :param str issuer: The Issuer which should be used for authentication.
        :param str tenant: The Tenant which should be used for authentication.
        """
        pulumi.set(__self__, "audience", audience)
        pulumi.set(__self__, "issuer", issuer)
        pulumi.set(__self__, "tenant", tenant)

    @property
    @pulumi.getter
    def audience(self) -> str:
        """
        The Audience which should be used for authentication.
        """
        return pulumi.get(self, "audience")

    @property
    @pulumi.getter
    def issuer(self) -> str:
        """
        The Issuer which should be used for authentication.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def tenant(self) -> str:
        """
        The Tenant which should be used for authentication.
        """
        return pulumi.get(self, "tenant")


@pulumi.output_type
class VpnServerConfigurationClientRevokedCertificate(dict):
    def __init__(__self__, *,
                 name: str,
                 thumbprint: str):
        """
        :param str name: A name used to uniquely identify this certificate.
        :param str thumbprint: The Thumbprint of the Certificate.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "thumbprint", thumbprint)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A name used to uniquely identify this certificate.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def thumbprint(self) -> str:
        """
        The Thumbprint of the Certificate.
        """
        return pulumi.get(self, "thumbprint")


@pulumi.output_type
class VpnServerConfigurationClientRootCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicCertData":
            suggest = "public_cert_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnServerConfigurationClientRootCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnServerConfigurationClientRootCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnServerConfigurationClientRootCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 public_cert_data: str):
        """
        :param str name: A name used to uniquely identify this certificate.
        :param str public_cert_data: The Public Key Data associated with the Certificate.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "public_cert_data", public_cert_data)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A name used to uniquely identify this certificate.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="publicCertData")
    def public_cert_data(self) -> str:
        """
        The Public Key Data associated with the Certificate.
        """
        return pulumi.get(self, "public_cert_data")


@pulumi.output_type
class VpnServerConfigurationIpsecPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dhGroup":
            suggest = "dh_group"
        elif key == "ikeEncryption":
            suggest = "ike_encryption"
        elif key == "ikeIntegrity":
            suggest = "ike_integrity"
        elif key == "ipsecEncryption":
            suggest = "ipsec_encryption"
        elif key == "ipsecIntegrity":
            suggest = "ipsec_integrity"
        elif key == "pfsGroup":
            suggest = "pfs_group"
        elif key == "saDataSizeKilobytes":
            suggest = "sa_data_size_kilobytes"
        elif key == "saLifetimeSeconds":
            suggest = "sa_lifetime_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnServerConfigurationIpsecPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnServerConfigurationIpsecPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnServerConfigurationIpsecPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dh_group: str,
                 ike_encryption: str,
                 ike_integrity: str,
                 ipsec_encryption: str,
                 ipsec_integrity: str,
                 pfs_group: str,
                 sa_data_size_kilobytes: int,
                 sa_lifetime_seconds: int):
        """
        :param str dh_group: The DH Group, used in IKE Phase 1. Possible values include `DHGroup1`, `DHGroup2`, `DHGroup14`, `DHGroup24`, `DHGroup2048`, `ECP256`, `ECP384` and `None`.
        :param str ike_encryption: The IKE encryption algorithm, used for IKE Phase 2. Possible values include `AES128`, `AES192`, `AES256`, `DES`, `DES3`, `GCMAES128` and `GCMAES256`.
        :param str ike_integrity: The IKE encryption integrity algorithm, used for IKE Phase 2. Possible values include `GCMAES128`, `GCMAES256`, `MD5`, `SHA1`, `SHA256` and `SHA384`.
        :param str ipsec_encryption: The IPSec encryption algorithm, used for IKE phase 1. Possible values include `AES128`, `AES192`, `AES256`, `DES`, `DES3`, `GCMAES128`, `GCMAES192`, `GCMAES256` and `None`.
        :param str ipsec_integrity: The IPSec integrity algorithm, used for IKE phase 1. Possible values include `GCMAES128`, `GCMAES192`, `GCMAES256`, `MD5`, `SHA1` and `SHA256`.
        :param str pfs_group: The Pfs Group, used in IKE Phase 2. Possible values include `ECP256`, `ECP384`, `PFS1`, `PFS2`, `PFS14`, `PFS24`, `PFS2048`, `PFSMM` and `None`.
        :param int sa_data_size_kilobytes: The IPSec Security Association payload size in KB for a Site-to-Site VPN tunnel.
        :param int sa_lifetime_seconds: The IPSec Security Association lifetime in seconds for a Site-to-Site VPN tunnel.
        """
        pulumi.set(__self__, "dh_group", dh_group)
        pulumi.set(__self__, "ike_encryption", ike_encryption)
        pulumi.set(__self__, "ike_integrity", ike_integrity)
        pulumi.set(__self__, "ipsec_encryption", ipsec_encryption)
        pulumi.set(__self__, "ipsec_integrity", ipsec_integrity)
        pulumi.set(__self__, "pfs_group", pfs_group)
        pulumi.set(__self__, "sa_data_size_kilobytes", sa_data_size_kilobytes)
        pulumi.set(__self__, "sa_lifetime_seconds", sa_lifetime_seconds)

    @property
    @pulumi.getter(name="dhGroup")
    def dh_group(self) -> str:
        """
        The DH Group, used in IKE Phase 1. Possible values include `DHGroup1`, `DHGroup2`, `DHGroup14`, `DHGroup24`, `DHGroup2048`, `ECP256`, `ECP384` and `None`.
        """
        return pulumi.get(self, "dh_group")

    @property
    @pulumi.getter(name="ikeEncryption")
    def ike_encryption(self) -> str:
        """
        The IKE encryption algorithm, used for IKE Phase 2. Possible values include `AES128`, `AES192`, `AES256`, `DES`, `DES3`, `GCMAES128` and `GCMAES256`.
        """
        return pulumi.get(self, "ike_encryption")

    @property
    @pulumi.getter(name="ikeIntegrity")
    def ike_integrity(self) -> str:
        """
        The IKE encryption integrity algorithm, used for IKE Phase 2. Possible values include `GCMAES128`, `GCMAES256`, `MD5`, `SHA1`, `SHA256` and `SHA384`.
        """
        return pulumi.get(self, "ike_integrity")

    @property
    @pulumi.getter(name="ipsecEncryption")
    def ipsec_encryption(self) -> str:
        """
        The IPSec encryption algorithm, used for IKE phase 1. Possible values include `AES128`, `AES192`, `AES256`, `DES`, `DES3`, `GCMAES128`, `GCMAES192`, `GCMAES256` and `None`.
        """
        return pulumi.get(self, "ipsec_encryption")

    @property
    @pulumi.getter(name="ipsecIntegrity")
    def ipsec_integrity(self) -> str:
        """
        The IPSec integrity algorithm, used for IKE phase 1. Possible values include `GCMAES128`, `GCMAES192`, `GCMAES256`, `MD5`, `SHA1` and `SHA256`.
        """
        return pulumi.get(self, "ipsec_integrity")

    @property
    @pulumi.getter(name="pfsGroup")
    def pfs_group(self) -> str:
        """
        The Pfs Group, used in IKE Phase 2. Possible values include `ECP256`, `ECP384`, `PFS1`, `PFS2`, `PFS14`, `PFS24`, `PFS2048`, `PFSMM` and `None`.
        """
        return pulumi.get(self, "pfs_group")

    @property
    @pulumi.getter(name="saDataSizeKilobytes")
    def sa_data_size_kilobytes(self) -> int:
        """
        The IPSec Security Association payload size in KB for a Site-to-Site VPN tunnel.
        """
        return pulumi.get(self, "sa_data_size_kilobytes")

    @property
    @pulumi.getter(name="saLifetimeSeconds")
    def sa_lifetime_seconds(self) -> int:
        """
        The IPSec Security Association lifetime in seconds for a Site-to-Site VPN tunnel.
        """
        return pulumi.get(self, "sa_lifetime_seconds")


@pulumi.output_type
class VpnServerConfigurationRadius(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverRootCertificates":
            suggest = "server_root_certificates"
        elif key == "clientRootCertificates":
            suggest = "client_root_certificates"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnServerConfigurationRadius. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnServerConfigurationRadius.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnServerConfigurationRadius.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 server_root_certificates: Sequence['outputs.VpnServerConfigurationRadiusServerRootCertificate'],
                 client_root_certificates: Optional[Sequence['outputs.VpnServerConfigurationRadiusClientRootCertificate']] = None,
                 servers: Optional[Sequence['outputs.VpnServerConfigurationRadiusServer']] = None):
        """
        :param Sequence['VpnServerConfigurationRadiusServerRootCertificateArgs'] server_root_certificates: One or more `server_root_certificate` blocks as defined below.
        :param Sequence['VpnServerConfigurationRadiusClientRootCertificateArgs'] client_root_certificates: One or more `client_root_certificate` blocks as defined above.
        :param Sequence['VpnServerConfigurationRadiusServerArgs'] servers: One or more `server` blocks as defined below.
        """
        pulumi.set(__self__, "server_root_certificates", server_root_certificates)
        if client_root_certificates is not None:
            pulumi.set(__self__, "client_root_certificates", client_root_certificates)
        if servers is not None:
            pulumi.set(__self__, "servers", servers)

    @property
    @pulumi.getter(name="serverRootCertificates")
    def server_root_certificates(self) -> Sequence['outputs.VpnServerConfigurationRadiusServerRootCertificate']:
        """
        One or more `server_root_certificate` blocks as defined below.
        """
        return pulumi.get(self, "server_root_certificates")

    @property
    @pulumi.getter(name="clientRootCertificates")
    def client_root_certificates(self) -> Optional[Sequence['outputs.VpnServerConfigurationRadiusClientRootCertificate']]:
        """
        One or more `client_root_certificate` blocks as defined above.
        """
        return pulumi.get(self, "client_root_certificates")

    @property
    @pulumi.getter
    def servers(self) -> Optional[Sequence['outputs.VpnServerConfigurationRadiusServer']]:
        """
        One or more `server` blocks as defined below.
        """
        return pulumi.get(self, "servers")


@pulumi.output_type
class VpnServerConfigurationRadiusClientRootCertificate(dict):
    def __init__(__self__, *,
                 name: str,
                 thumbprint: str):
        """
        :param str name: A name used to uniquely identify this certificate.
        :param str thumbprint: The Thumbprint of the Certificate.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "thumbprint", thumbprint)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A name used to uniquely identify this certificate.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def thumbprint(self) -> str:
        """
        The Thumbprint of the Certificate.
        """
        return pulumi.get(self, "thumbprint")


@pulumi.output_type
class VpnServerConfigurationRadiusServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverRootCertificates":
            suggest = "server_root_certificates"
        elif key == "clientRootCertificates":
            suggest = "client_root_certificates"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnServerConfigurationRadiusServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnServerConfigurationRadiusServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnServerConfigurationRadiusServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: str,
                 secret: str,
                 server_root_certificates: Sequence['outputs.VpnServerConfigurationRadiusServerServerRootCertificate'],
                 client_root_certificates: Optional[Sequence['outputs.VpnServerConfigurationRadiusServerClientRootCertificate']] = None):
        """
        :param str address: The Address of the Radius Server.
        :param str secret: The Secret used to communicate with the Radius Server.
        :param Sequence['VpnServerConfigurationRadiusServerServerRootCertificateArgs'] server_root_certificates: One or more `server_root_certificate` blocks as defined below.
        :param Sequence['VpnServerConfigurationRadiusServerClientRootCertificateArgs'] client_root_certificates: One or more `client_root_certificate` blocks as defined above.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "secret", secret)
        pulumi.set(__self__, "server_root_certificates", server_root_certificates)
        if client_root_certificates is not None:
            pulumi.set(__self__, "client_root_certificates", client_root_certificates)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        The Address of the Radius Server.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def secret(self) -> str:
        """
        The Secret used to communicate with the Radius Server.
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter(name="serverRootCertificates")
    def server_root_certificates(self) -> Sequence['outputs.VpnServerConfigurationRadiusServerServerRootCertificate']:
        """
        One or more `server_root_certificate` blocks as defined below.
        """
        return pulumi.get(self, "server_root_certificates")

    @property
    @pulumi.getter(name="clientRootCertificates")
    def client_root_certificates(self) -> Optional[Sequence['outputs.VpnServerConfigurationRadiusServerClientRootCertificate']]:
        """
        One or more `client_root_certificate` blocks as defined above.
        """
        return pulumi.get(self, "client_root_certificates")


@pulumi.output_type
class VpnServerConfigurationRadiusServerClientRootCertificate(dict):
    def __init__(__self__, *,
                 name: str,
                 thumbprint: str):
        """
        :param str name: A name used to uniquely identify this certificate.
        :param str thumbprint: The Thumbprint of the Certificate.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "thumbprint", thumbprint)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A name used to uniquely identify this certificate.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def thumbprint(self) -> str:
        """
        The Thumbprint of the Certificate.
        """
        return pulumi.get(self, "thumbprint")


@pulumi.output_type
class VpnServerConfigurationRadiusServerRootCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicCertData":
            suggest = "public_cert_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnServerConfigurationRadiusServerRootCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnServerConfigurationRadiusServerRootCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnServerConfigurationRadiusServerRootCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 public_cert_data: str):
        """
        :param str name: A name used to uniquely identify this certificate.
        :param str public_cert_data: The Public Key Data associated with the Certificate.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "public_cert_data", public_cert_data)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A name used to uniquely identify this certificate.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="publicCertData")
    def public_cert_data(self) -> str:
        """
        The Public Key Data associated with the Certificate.
        """
        return pulumi.get(self, "public_cert_data")


@pulumi.output_type
class VpnServerConfigurationRadiusServerServerRootCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicCertData":
            suggest = "public_cert_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnServerConfigurationRadiusServerServerRootCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnServerConfigurationRadiusServerServerRootCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnServerConfigurationRadiusServerServerRootCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 public_cert_data: str):
        """
        :param str name: A name used to uniquely identify this certificate.
        :param str public_cert_data: The Public Key Data associated with the Certificate.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "public_cert_data", public_cert_data)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A name used to uniquely identify this certificate.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="publicCertData")
    def public_cert_data(self) -> str:
        """
        The Public Key Data associated with the Certificate.
        """
        return pulumi.get(self, "public_cert_data")


@pulumi.output_type
class VpnSiteLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "providerName":
            suggest = "provider_name"
        elif key == "speedInMbps":
            suggest = "speed_in_mbps"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnSiteLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnSiteLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnSiteLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 bgp: Optional['outputs.VpnSiteLinkBgp'] = None,
                 fqdn: Optional[str] = None,
                 id: Optional[str] = None,
                 ip_address: Optional[str] = None,
                 provider_name: Optional[str] = None,
                 speed_in_mbps: Optional[int] = None):
        """
        :param str name: The name which should be used for this VPN Site Link.
        :param 'VpnSiteLinkBgpArgs' bgp: A `bgp` block as defined above.
        :param str fqdn: The FQDN of this VPN Site Link.
        :param str id: The ID of the VPN Site Link.
        :param str ip_address: The IP address of this VPN Site Link.
        :param str provider_name: The name of the physical link at the VPN Site. Example: `ATT`, `Verizon`.
        :param int speed_in_mbps: The speed of the VPN device at the branch location in unit of mbps.
        """
        pulumi.set(__self__, "name", name)
        if bgp is not None:
            pulumi.set(__self__, "bgp", bgp)
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if provider_name is not None:
            pulumi.set(__self__, "provider_name", provider_name)
        if speed_in_mbps is not None:
            pulumi.set(__self__, "speed_in_mbps", speed_in_mbps)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this VPN Site Link.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def bgp(self) -> Optional['outputs.VpnSiteLinkBgp']:
        """
        A `bgp` block as defined above.
        """
        return pulumi.get(self, "bgp")

    @property
    @pulumi.getter
    def fqdn(self) -> Optional[str]:
        """
        The FQDN of this VPN Site Link.
        """
        return pulumi.get(self, "fqdn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the VPN Site Link.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The IP address of this VPN Site Link.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> Optional[str]:
        """
        The name of the physical link at the VPN Site. Example: `ATT`, `Verizon`.
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter(name="speedInMbps")
    def speed_in_mbps(self) -> Optional[int]:
        """
        The speed of the VPN device at the branch location in unit of mbps.
        """
        return pulumi.get(self, "speed_in_mbps")


@pulumi.output_type
class VpnSiteLinkBgp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "peeringAddress":
            suggest = "peering_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnSiteLinkBgp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnSiteLinkBgp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnSiteLinkBgp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 asn: int,
                 peering_address: str):
        """
        :param int asn: The BGP speaker's ASN.
        :param str peering_address: The BGP peering ip address.
        """
        pulumi.set(__self__, "asn", asn)
        pulumi.set(__self__, "peering_address", peering_address)

    @property
    @pulumi.getter
    def asn(self) -> int:
        """
        The BGP speaker's ASN.
        """
        return pulumi.get(self, "asn")

    @property
    @pulumi.getter(name="peeringAddress")
    def peering_address(self) -> str:
        """
        The BGP peering ip address.
        """
        return pulumi.get(self, "peering_address")


@pulumi.output_type
class GetApplicationGatewayIdentityResult(dict):
    def __init__(__self__, *,
                 identity_ids: Sequence[str],
                 type: str):
        """
        :param Sequence[str] identity_ids: A list of Managed Identity ID's assigned to this Application Gateway.
        :param str type: The type of Managed Identity assigned to this Application Gateway.
        """
        pulumi.set(__self__, "identity_ids", identity_ids)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Sequence[str]:
        """
        A list of Managed Identity ID's assigned to this Application Gateway.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of Managed Identity assigned to this Application Gateway.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetExpressRouteCircuitPeeringResult(dict):
    def __init__(__self__, *,
                 azure_asn: int,
                 peer_asn: int,
                 peering_type: str,
                 primary_peer_address_prefix: str,
                 secondary_peer_address_prefix: str,
                 shared_key: str,
                 vlan_id: int):
        """
        :param int azure_asn: The Either a 16-bit or a 32-bit ASN for Azure.
        :param int peer_asn: The Either a 16-bit or a 32-bit ASN. Can either be public or private.
        :param str peering_type: The type of the ExpressRoute Circuit Peering. Acceptable values include `AzurePrivatePeering`, `AzurePublicPeering` and `MicrosoftPeering`. Changing this forces a new resource to be created.
        :param str primary_peer_address_prefix: A `/30` subnet for the primary link.
        :param str secondary_peer_address_prefix: A `/30` subnet for the secondary link.
        :param str shared_key: The shared key. Can be a maximum of 25 characters.
        :param int vlan_id: A valid VLAN ID to establish this peering on.
        """
        pulumi.set(__self__, "azure_asn", azure_asn)
        pulumi.set(__self__, "peer_asn", peer_asn)
        pulumi.set(__self__, "peering_type", peering_type)
        pulumi.set(__self__, "primary_peer_address_prefix", primary_peer_address_prefix)
        pulumi.set(__self__, "secondary_peer_address_prefix", secondary_peer_address_prefix)
        pulumi.set(__self__, "shared_key", shared_key)
        pulumi.set(__self__, "vlan_id", vlan_id)

    @property
    @pulumi.getter(name="azureAsn")
    def azure_asn(self) -> int:
        """
        The Either a 16-bit or a 32-bit ASN for Azure.
        """
        return pulumi.get(self, "azure_asn")

    @property
    @pulumi.getter(name="peerAsn")
    def peer_asn(self) -> int:
        """
        The Either a 16-bit or a 32-bit ASN. Can either be public or private.
        """
        return pulumi.get(self, "peer_asn")

    @property
    @pulumi.getter(name="peeringType")
    def peering_type(self) -> str:
        """
        The type of the ExpressRoute Circuit Peering. Acceptable values include `AzurePrivatePeering`, `AzurePublicPeering` and `MicrosoftPeering`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "peering_type")

    @property
    @pulumi.getter(name="primaryPeerAddressPrefix")
    def primary_peer_address_prefix(self) -> str:
        """
        A `/30` subnet for the primary link.
        """
        return pulumi.get(self, "primary_peer_address_prefix")

    @property
    @pulumi.getter(name="secondaryPeerAddressPrefix")
    def secondary_peer_address_prefix(self) -> str:
        """
        A `/30` subnet for the secondary link.
        """
        return pulumi.get(self, "secondary_peer_address_prefix")

    @property
    @pulumi.getter(name="sharedKey")
    def shared_key(self) -> str:
        """
        The shared key. Can be a maximum of 25 characters.
        """
        return pulumi.get(self, "shared_key")

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> int:
        """
        A valid VLAN ID to establish this peering on.
        """
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class GetExpressRouteCircuitServiceProviderPropertyResult(dict):
    def __init__(__self__, *,
                 bandwidth_in_mbps: int,
                 peering_location: str,
                 service_provider_name: str):
        """
        :param int bandwidth_in_mbps: The bandwidth in Mbps of the ExpressRoute circuit.
        :param str peering_location: The name of the peering location and **not** the Azure resource location.
        :param str service_provider_name: The name of the ExpressRoute Service Provider.
        """
        pulumi.set(__self__, "bandwidth_in_mbps", bandwidth_in_mbps)
        pulumi.set(__self__, "peering_location", peering_location)
        pulumi.set(__self__, "service_provider_name", service_provider_name)

    @property
    @pulumi.getter(name="bandwidthInMbps")
    def bandwidth_in_mbps(self) -> int:
        """
        The bandwidth in Mbps of the ExpressRoute circuit.
        """
        return pulumi.get(self, "bandwidth_in_mbps")

    @property
    @pulumi.getter(name="peeringLocation")
    def peering_location(self) -> str:
        """
        The name of the peering location and **not** the Azure resource location.
        """
        return pulumi.get(self, "peering_location")

    @property
    @pulumi.getter(name="serviceProviderName")
    def service_provider_name(self) -> str:
        """
        The name of the ExpressRoute Service Provider.
        """
        return pulumi.get(self, "service_provider_name")


@pulumi.output_type
class GetExpressRouteCircuitSkuResult(dict):
    def __init__(__self__, *,
                 family: str,
                 tier: str):
        """
        :param str family: The billing mode for bandwidth. Possible values are `MeteredData` or `UnlimitedData`.
        :param str tier: The service tier. Possible values are `Basic`, `Local`, `Standard` or `Premium`.
        """
        pulumi.set(__self__, "family", family)
        pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter
    def family(self) -> str:
        """
        The billing mode for bandwidth. Possible values are `MeteredData` or `UnlimitedData`.
        """
        return pulumi.get(self, "family")

    @property
    @pulumi.getter
    def tier(self) -> str:
        """
        The service tier. Possible values are `Basic`, `Local`, `Standard` or `Premium`.
        """
        return pulumi.get(self, "tier")


@pulumi.output_type
class GetFirewallIpConfigurationResult(dict):
    def __init__(__self__, *,
                 name: str,
                 private_ip_address: str,
                 public_ip_address_id: str,
                 subnet_id: str):
        """
        :param str name: The name of the Azure Firewall.
        :param str private_ip_address: The private IP address associated with the Azure Firewall.
        :param str subnet_id: The ID of the Subnet where the Azure Firewall is deployed.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "private_ip_address", private_ip_address)
        pulumi.set(__self__, "public_ip_address_id", public_ip_address_id)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Azure Firewall.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> str:
        """
        The private IP address associated with the Azure Firewall.
        """
        return pulumi.get(self, "private_ip_address")

    @property
    @pulumi.getter(name="publicIpAddressId")
    def public_ip_address_id(self) -> str:
        return pulumi.get(self, "public_ip_address_id")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The ID of the Subnet where the Azure Firewall is deployed.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetFirewallManagementIpConfigurationResult(dict):
    def __init__(__self__, *,
                 name: str,
                 private_ip_address: str,
                 public_ip_address_id: str,
                 subnet_id: str):
        """
        :param str name: The name of the Azure Firewall.
        :param str private_ip_address: The private IP address associated with the Azure Firewall.
        :param str subnet_id: The ID of the Subnet where the Azure Firewall is deployed.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "private_ip_address", private_ip_address)
        pulumi.set(__self__, "public_ip_address_id", public_ip_address_id)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Azure Firewall.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> str:
        """
        The private IP address associated with the Azure Firewall.
        """
        return pulumi.get(self, "private_ip_address")

    @property
    @pulumi.getter(name="publicIpAddressId")
    def public_ip_address_id(self) -> str:
        return pulumi.get(self, "public_ip_address_id")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The ID of the Subnet where the Azure Firewall is deployed.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetFirewallPolicyDnResult(dict):
    def __init__(__self__, *,
                 network_rule_fqdn_enabled: bool,
                 proxy_enabled: bool,
                 servers: Sequence[str]):
        pulumi.set(__self__, "network_rule_fqdn_enabled", network_rule_fqdn_enabled)
        pulumi.set(__self__, "proxy_enabled", proxy_enabled)
        pulumi.set(__self__, "servers", servers)

    @property
    @pulumi.getter(name="networkRuleFqdnEnabled")
    def network_rule_fqdn_enabled(self) -> bool:
        return pulumi.get(self, "network_rule_fqdn_enabled")

    @property
    @pulumi.getter(name="proxyEnabled")
    def proxy_enabled(self) -> bool:
        return pulumi.get(self, "proxy_enabled")

    @property
    @pulumi.getter
    def servers(self) -> Sequence[str]:
        return pulumi.get(self, "servers")


@pulumi.output_type
class GetFirewallPolicyThreatIntelligenceAllowlistResult(dict):
    def __init__(__self__, *,
                 fqdns: Sequence[str],
                 ip_addresses: Sequence[str]):
        pulumi.set(__self__, "fqdns", fqdns)
        pulumi.set(__self__, "ip_addresses", ip_addresses)

    @property
    @pulumi.getter
    def fqdns(self) -> Sequence[str]:
        return pulumi.get(self, "fqdns")

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Sequence[str]:
        return pulumi.get(self, "ip_addresses")


@pulumi.output_type
class GetFirewallVirtualHubResult(dict):
    def __init__(__self__, *,
                 private_ip_address: str,
                 public_ip_addresses: Sequence[str],
                 public_ip_count: int,
                 virtual_hub_id: str):
        """
        :param str private_ip_address: The private IP address associated with the Azure Firewall.
        :param Sequence[str] public_ip_addresses: The list of public IP addresses associated with the Azure Firewall.
        :param int public_ip_count: The number of public IPs assigned to the Azure Firewall.
        :param str virtual_hub_id: The ID of the Virtual Hub where the Azure Firewall resides in.
        """
        pulumi.set(__self__, "private_ip_address", private_ip_address)
        pulumi.set(__self__, "public_ip_addresses", public_ip_addresses)
        pulumi.set(__self__, "public_ip_count", public_ip_count)
        pulumi.set(__self__, "virtual_hub_id", virtual_hub_id)

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> str:
        """
        The private IP address associated with the Azure Firewall.
        """
        return pulumi.get(self, "private_ip_address")

    @property
    @pulumi.getter(name="publicIpAddresses")
    def public_ip_addresses(self) -> Sequence[str]:
        """
        The list of public IP addresses associated with the Azure Firewall.
        """
        return pulumi.get(self, "public_ip_addresses")

    @property
    @pulumi.getter(name="publicIpCount")
    def public_ip_count(self) -> int:
        """
        The number of public IPs assigned to the Azure Firewall.
        """
        return pulumi.get(self, "public_ip_count")

    @property
    @pulumi.getter(name="virtualHubId")
    def virtual_hub_id(self) -> str:
        """
        The ID of the Virtual Hub where the Azure Firewall resides in.
        """
        return pulumi.get(self, "virtual_hub_id")


@pulumi.output_type
class GetGatewayConnectionIpsecPolicyResult(dict):
    def __init__(__self__, *,
                 dh_group: str,
                 ike_encryption: str,
                 ike_integrity: str,
                 ipsec_encryption: str,
                 ipsec_integrity: str,
                 pfs_group: str,
                 sa_datasize: int,
                 sa_lifetime: int):
        """
        :param str dh_group: The DH group used in IKE phase 1 for initial SA. Valid
               options are `DHGroup1`, `DHGroup14`, `DHGroup2`, `DHGroup2048`, `DHGroup24`,
               `ECP256`, `ECP384`, or `None`.
        :param str ike_encryption: The IKE encryption algorithm. Valid
               options are `AES128`, `AES192`, `AES256`, `DES`, or `DES3`.
        :param str ike_integrity: The IKE integrity algorithm. Valid
               options are `MD5`, `SHA1`, `SHA256`, or `SHA384`.
        :param str ipsec_encryption: The IPSec encryption algorithm. Valid
               options are `AES128`, `AES192`, `AES256`, `DES`, `DES3`, `GCMAES128`, `GCMAES192`, `GCMAES256`, or `None`.
        :param str ipsec_integrity: The IPSec integrity algorithm. Valid
               options are `GCMAES128`, `GCMAES192`, `GCMAES256`, `MD5`, `SHA1`, or `SHA256`.
        :param str pfs_group: The DH group used in IKE phase 2 for new child SA.
               Valid options are `ECP256`, `ECP384`, `PFS1`, `PFS2`, `PFS2048`, `PFS24`,
               or `None`.
        :param int sa_datasize: The IPSec SA payload size in KB. Must be at least
               `1024` KB.
        :param int sa_lifetime: The IPSec SA lifetime in seconds. Must be at least
               `300` seconds.
        """
        pulumi.set(__self__, "dh_group", dh_group)
        pulumi.set(__self__, "ike_encryption", ike_encryption)
        pulumi.set(__self__, "ike_integrity", ike_integrity)
        pulumi.set(__self__, "ipsec_encryption", ipsec_encryption)
        pulumi.set(__self__, "ipsec_integrity", ipsec_integrity)
        pulumi.set(__self__, "pfs_group", pfs_group)
        pulumi.set(__self__, "sa_datasize", sa_datasize)
        pulumi.set(__self__, "sa_lifetime", sa_lifetime)

    @property
    @pulumi.getter(name="dhGroup")
    def dh_group(self) -> str:
        """
        The DH group used in IKE phase 1 for initial SA. Valid
        options are `DHGroup1`, `DHGroup14`, `DHGroup2`, `DHGroup2048`, `DHGroup24`,
        `ECP256`, `ECP384`, or `None`.
        """
        return pulumi.get(self, "dh_group")

    @property
    @pulumi.getter(name="ikeEncryption")
    def ike_encryption(self) -> str:
        """
        The IKE encryption algorithm. Valid
        options are `AES128`, `AES192`, `AES256`, `DES`, or `DES3`.
        """
        return pulumi.get(self, "ike_encryption")

    @property
    @pulumi.getter(name="ikeIntegrity")
    def ike_integrity(self) -> str:
        """
        The IKE integrity algorithm. Valid
        options are `MD5`, `SHA1`, `SHA256`, or `SHA384`.
        """
        return pulumi.get(self, "ike_integrity")

    @property
    @pulumi.getter(name="ipsecEncryption")
    def ipsec_encryption(self) -> str:
        """
        The IPSec encryption algorithm. Valid
        options are `AES128`, `AES192`, `AES256`, `DES`, `DES3`, `GCMAES128`, `GCMAES192`, `GCMAES256`, or `None`.
        """
        return pulumi.get(self, "ipsec_encryption")

    @property
    @pulumi.getter(name="ipsecIntegrity")
    def ipsec_integrity(self) -> str:
        """
        The IPSec integrity algorithm. Valid
        options are `GCMAES128`, `GCMAES192`, `GCMAES256`, `MD5`, `SHA1`, or `SHA256`.
        """
        return pulumi.get(self, "ipsec_integrity")

    @property
    @pulumi.getter(name="pfsGroup")
    def pfs_group(self) -> str:
        """
        The DH group used in IKE phase 2 for new child SA.
        Valid options are `ECP256`, `ECP384`, `PFS1`, `PFS2`, `PFS2048`, `PFS24`,
        or `None`.
        """
        return pulumi.get(self, "pfs_group")

    @property
    @pulumi.getter(name="saDatasize")
    def sa_datasize(self) -> int:
        """
        The IPSec SA payload size in KB. Must be at least
        `1024` KB.
        """
        return pulumi.get(self, "sa_datasize")

    @property
    @pulumi.getter(name="saLifetime")
    def sa_lifetime(self) -> int:
        """
        The IPSec SA lifetime in seconds. Must be at least
        `300` seconds.
        """
        return pulumi.get(self, "sa_lifetime")


@pulumi.output_type
class GetGatewayConnectionTrafficSelectorPolicyResult(dict):
    def __init__(__self__, *,
                 local_address_cidrs: Sequence[str],
                 remote_address_cidrs: Sequence[str]):
        """
        :param Sequence[str] local_address_cidrs: List of local CIDRs.
        :param Sequence[str] remote_address_cidrs: List of remote CIDRs.
        """
        pulumi.set(__self__, "local_address_cidrs", local_address_cidrs)
        pulumi.set(__self__, "remote_address_cidrs", remote_address_cidrs)

    @property
    @pulumi.getter(name="localAddressCidrs")
    def local_address_cidrs(self) -> Sequence[str]:
        """
        List of local CIDRs.
        """
        return pulumi.get(self, "local_address_cidrs")

    @property
    @pulumi.getter(name="remoteAddressCidrs")
    def remote_address_cidrs(self) -> Sequence[str]:
        """
        List of remote CIDRs.
        """
        return pulumi.get(self, "remote_address_cidrs")


@pulumi.output_type
class GetNetworkInterfaceIpConfigurationResult(dict):
    def __init__(__self__, *,
                 application_gateway_backend_address_pools_ids: Sequence[str],
                 application_security_group_ids: Sequence[str],
                 load_balancer_backend_address_pools_ids: Sequence[str],
                 load_balancer_inbound_nat_rules_ids: Sequence[str],
                 name: str,
                 primary: bool,
                 private_ip_address: str,
                 private_ip_address_allocation: str,
                 private_ip_address_version: str,
                 public_ip_address_id: str,
                 subnet_id: str):
        """
        :param Sequence[str] application_gateway_backend_address_pools_ids: A list of Backend Address Pool ID's within a Application Gateway that this Network Interface is connected to.
        :param Sequence[str] load_balancer_backend_address_pools_ids: A list of Backend Address Pool ID's within a Load Balancer that this Network Interface is connected to.
        :param Sequence[str] load_balancer_inbound_nat_rules_ids: A list of Inbound NAT Rule ID's within a Load Balancer that this Network Interface is connected to.
        :param str name: Specifies the name of the Network Interface.
        :param bool primary: is this the Primary IP Configuration for this Network Interface?
        :param str private_ip_address: The Private IP Address assigned to this Network Interface.
        :param str private_ip_address_allocation: The IP Address allocation type for the Private address, such as `Dynamic` or `Static`.
        :param str public_ip_address_id: The ID of the Public IP Address which is connected to this Network Interface.
        :param str subnet_id: The ID of the Subnet which the Network Interface is connected to.
        """
        pulumi.set(__self__, "application_gateway_backend_address_pools_ids", application_gateway_backend_address_pools_ids)
        pulumi.set(__self__, "application_security_group_ids", application_security_group_ids)
        pulumi.set(__self__, "load_balancer_backend_address_pools_ids", load_balancer_backend_address_pools_ids)
        pulumi.set(__self__, "load_balancer_inbound_nat_rules_ids", load_balancer_inbound_nat_rules_ids)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "primary", primary)
        pulumi.set(__self__, "private_ip_address", private_ip_address)
        pulumi.set(__self__, "private_ip_address_allocation", private_ip_address_allocation)
        pulumi.set(__self__, "private_ip_address_version", private_ip_address_version)
        pulumi.set(__self__, "public_ip_address_id", public_ip_address_id)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="applicationGatewayBackendAddressPoolsIds")
    def application_gateway_backend_address_pools_ids(self) -> Sequence[str]:
        """
        A list of Backend Address Pool ID's within a Application Gateway that this Network Interface is connected to.
        """
        return pulumi.get(self, "application_gateway_backend_address_pools_ids")

    @property
    @pulumi.getter(name="applicationSecurityGroupIds")
    def application_security_group_ids(self) -> Sequence[str]:
        return pulumi.get(self, "application_security_group_ids")

    @property
    @pulumi.getter(name="loadBalancerBackendAddressPoolsIds")
    def load_balancer_backend_address_pools_ids(self) -> Sequence[str]:
        """
        A list of Backend Address Pool ID's within a Load Balancer that this Network Interface is connected to.
        """
        return pulumi.get(self, "load_balancer_backend_address_pools_ids")

    @property
    @pulumi.getter(name="loadBalancerInboundNatRulesIds")
    def load_balancer_inbound_nat_rules_ids(self) -> Sequence[str]:
        """
        A list of Inbound NAT Rule ID's within a Load Balancer that this Network Interface is connected to.
        """
        return pulumi.get(self, "load_balancer_inbound_nat_rules_ids")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Network Interface.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def primary(self) -> bool:
        """
        is this the Primary IP Configuration for this Network Interface?
        """
        return pulumi.get(self, "primary")

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> str:
        """
        The Private IP Address assigned to this Network Interface.
        """
        return pulumi.get(self, "private_ip_address")

    @property
    @pulumi.getter(name="privateIpAddressAllocation")
    def private_ip_address_allocation(self) -> str:
        """
        The IP Address allocation type for the Private address, such as `Dynamic` or `Static`.
        """
        return pulumi.get(self, "private_ip_address_allocation")

    @property
    @pulumi.getter(name="privateIpAddressVersion")
    def private_ip_address_version(self) -> str:
        return pulumi.get(self, "private_ip_address_version")

    @property
    @pulumi.getter(name="publicIpAddressId")
    def public_ip_address_id(self) -> str:
        """
        The ID of the Public IP Address which is connected to this Network Interface.
        """
        return pulumi.get(self, "public_ip_address_id")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The ID of the Subnet which the Network Interface is connected to.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetNetworkSecurityGroupSecurityRuleResult(dict):
    def __init__(__self__, *,
                 access: str,
                 description: str,
                 destination_address_prefix: str,
                 destination_address_prefixes: Sequence[str],
                 destination_port_range: str,
                 destination_port_ranges: Sequence[str],
                 direction: str,
                 name: str,
                 priority: int,
                 protocol: str,
                 source_address_prefix: str,
                 source_address_prefixes: Sequence[str],
                 source_port_range: str,
                 source_port_ranges: Sequence[str],
                 destination_application_security_group_ids: Optional[Sequence[str]] = None,
                 source_application_security_group_ids: Optional[Sequence[str]] = None):
        """
        :param str access: Is network traffic is allowed or denied?
        :param str description: The description for this rule.
        :param str destination_address_prefix: CIDR or destination IP range or * to match any IP.
        :param Sequence[str] destination_address_prefixes: A list of CIDRs or destination IP ranges.
        :param str destination_port_range: The Destination Port or Range.
        :param str direction: The direction specifies if rule will be evaluated on incoming or outgoing traffic.
        :param str name: Specifies the Name of the Network Security Group.
        :param int priority: The priority of the rule
        :param str protocol: The network protocol this rule applies to.
        :param str source_address_prefix: CIDR or source IP range or * to match any IP.
        :param Sequence[str] source_address_prefixes: A list of CIDRs or source IP ranges.
        :param str source_port_range: The Source Port or Range.
        :param Sequence[str] destination_application_security_group_ids: A List of destination Application Security Group ID's
        :param Sequence[str] source_application_security_group_ids: A List of source Application Security Group ID's
        """
        pulumi.set(__self__, "access", access)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "destination_address_prefix", destination_address_prefix)
        pulumi.set(__self__, "destination_address_prefixes", destination_address_prefixes)
        pulumi.set(__self__, "destination_port_range", destination_port_range)
        pulumi.set(__self__, "destination_port_ranges", destination_port_ranges)
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "source_address_prefix", source_address_prefix)
        pulumi.set(__self__, "source_address_prefixes", source_address_prefixes)
        pulumi.set(__self__, "source_port_range", source_port_range)
        pulumi.set(__self__, "source_port_ranges", source_port_ranges)
        if destination_application_security_group_ids is not None:
            pulumi.set(__self__, "destination_application_security_group_ids", destination_application_security_group_ids)
        if source_application_security_group_ids is not None:
            pulumi.set(__self__, "source_application_security_group_ids", source_application_security_group_ids)

    @property
    @pulumi.getter
    def access(self) -> str:
        """
        Is network traffic is allowed or denied?
        """
        return pulumi.get(self, "access")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description for this rule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="destinationAddressPrefix")
    def destination_address_prefix(self) -> str:
        """
        CIDR or destination IP range or * to match any IP.
        """
        return pulumi.get(self, "destination_address_prefix")

    @property
    @pulumi.getter(name="destinationAddressPrefixes")
    def destination_address_prefixes(self) -> Sequence[str]:
        """
        A list of CIDRs or destination IP ranges.
        """
        return pulumi.get(self, "destination_address_prefixes")

    @property
    @pulumi.getter(name="destinationPortRange")
    def destination_port_range(self) -> str:
        """
        The Destination Port or Range.
        """
        return pulumi.get(self, "destination_port_range")

    @property
    @pulumi.getter(name="destinationPortRanges")
    def destination_port_ranges(self) -> Sequence[str]:
        return pulumi.get(self, "destination_port_ranges")

    @property
    @pulumi.getter
    def direction(self) -> str:
        """
        The direction specifies if rule will be evaluated on incoming or outgoing traffic.
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the Name of the Network Security Group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        The priority of the rule
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The network protocol this rule applies to.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="sourceAddressPrefix")
    def source_address_prefix(self) -> str:
        """
        CIDR or source IP range or * to match any IP.
        """
        return pulumi.get(self, "source_address_prefix")

    @property
    @pulumi.getter(name="sourceAddressPrefixes")
    def source_address_prefixes(self) -> Sequence[str]:
        """
        A list of CIDRs or source IP ranges.
        """
        return pulumi.get(self, "source_address_prefixes")

    @property
    @pulumi.getter(name="sourcePortRange")
    def source_port_range(self) -> str:
        """
        The Source Port or Range.
        """
        return pulumi.get(self, "source_port_range")

    @property
    @pulumi.getter(name="sourcePortRanges")
    def source_port_ranges(self) -> Sequence[str]:
        return pulumi.get(self, "source_port_ranges")

    @property
    @pulumi.getter(name="destinationApplicationSecurityGroupIds")
    def destination_application_security_group_ids(self) -> Optional[Sequence[str]]:
        """
        A List of destination Application Security Group ID's
        """
        return pulumi.get(self, "destination_application_security_group_ids")

    @property
    @pulumi.getter(name="sourceApplicationSecurityGroupIds")
    def source_application_security_group_ids(self) -> Optional[Sequence[str]]:
        """
        A List of source Application Security Group ID's
        """
        return pulumi.get(self, "source_application_security_group_ids")


@pulumi.output_type
class GetPublicIPsPublicIpResult(dict):
    def __init__(__self__, *,
                 domain_name_label: str,
                 fqdn: str,
                 id: str,
                 ip_address: str,
                 name: str):
        """
        :param str domain_name_label: The Domain Name Label of the Public IP Address
        :param str fqdn: The FQDN of the Public IP Address
        :param str id: The ID of the Public IP Address
        :param str ip_address: The IP address of the Public IP Address
        :param str name: The Name of the Public IP Address
        """
        pulumi.set(__self__, "domain_name_label", domain_name_label)
        pulumi.set(__self__, "fqdn", fqdn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="domainNameLabel")
    def domain_name_label(self) -> str:
        """
        The Domain Name Label of the Public IP Address
        """
        return pulumi.get(self, "domain_name_label")

    @property
    @pulumi.getter
    def fqdn(self) -> str:
        """
        The FQDN of the Public IP Address
        """
        return pulumi.get(self, "fqdn")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Public IP Address
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The IP address of the Public IP Address
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Name of the Public IP Address
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetRouteFilterRuleResult(dict):
    def __init__(__self__, *,
                 access: str,
                 communities: Sequence[str],
                 name: str,
                 rule_type: str):
        """
        :param str access: The access type of the rule
        :param Sequence[str] communities: The collection for bgp community values.
        :param str name: The Name of this Route Filter.
        :param str rule_type: The Route Filter Rule Type.
        """
        pulumi.set(__self__, "access", access)
        pulumi.set(__self__, "communities", communities)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "rule_type", rule_type)

    @property
    @pulumi.getter
    def access(self) -> str:
        """
        The access type of the rule
        """
        return pulumi.get(self, "access")

    @property
    @pulumi.getter
    def communities(self) -> Sequence[str]:
        """
        The collection for bgp community values.
        """
        return pulumi.get(self, "communities")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Name of this Route Filter.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> str:
        """
        The Route Filter Rule Type.
        """
        return pulumi.get(self, "rule_type")


@pulumi.output_type
class GetRouteTableRouteResult(dict):
    def __init__(__self__, *,
                 address_prefix: str,
                 name: str,
                 next_hop_in_ip_address: str,
                 next_hop_type: str):
        """
        :param str address_prefix: The destination CIDR to which the route applies.
        :param str name: The name of the Route Table.
        :param str next_hop_in_ip_address: Contains the IP address packets should be forwarded to.
        :param str next_hop_type: The type of Azure hop the packet should be sent to.
        """
        pulumi.set(__self__, "address_prefix", address_prefix)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "next_hop_in_ip_address", next_hop_in_ip_address)
        pulumi.set(__self__, "next_hop_type", next_hop_type)

    @property
    @pulumi.getter(name="addressPrefix")
    def address_prefix(self) -> str:
        """
        The destination CIDR to which the route applies.
        """
        return pulumi.get(self, "address_prefix")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Route Table.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nextHopInIpAddress")
    def next_hop_in_ip_address(self) -> str:
        """
        Contains the IP address packets should be forwarded to.
        """
        return pulumi.get(self, "next_hop_in_ip_address")

    @property
    @pulumi.getter(name="nextHopType")
    def next_hop_type(self) -> str:
        """
        The type of Azure hop the packet should be sent to.
        """
        return pulumi.get(self, "next_hop_type")


@pulumi.output_type
class GetTrafficManagerProfileDnsConfigResult(dict):
    def __init__(__self__, *,
                 relative_name: str,
                 ttl: int):
        """
        :param str relative_name: The relative domain name, this is combined with the domain name used by Traffic Manager to form the FQDN which is exported as documented below.
        :param int ttl: The TTL value of the Profile used by Local DNS resolvers and clients.
        """
        pulumi.set(__self__, "relative_name", relative_name)
        pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter(name="relativeName")
    def relative_name(self) -> str:
        """
        The relative domain name, this is combined with the domain name used by Traffic Manager to form the FQDN which is exported as documented below.
        """
        return pulumi.get(self, "relative_name")

    @property
    @pulumi.getter
    def ttl(self) -> int:
        """
        The TTL value of the Profile used by Local DNS resolvers and clients.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class GetTrafficManagerProfileMonitorConfigResult(dict):
    def __init__(__self__, *,
                 custom_headers: Sequence['outputs.GetTrafficManagerProfileMonitorConfigCustomHeaderResult'],
                 expected_status_code_ranges: Sequence[str],
                 interval_in_seconds: int,
                 path: str,
                 port: int,
                 protocol: str,
                 timeout_in_seconds: int,
                 tolerated_number_of_failures: int):
        """
        :param Sequence['GetTrafficManagerProfileMonitorConfigCustomHeaderArgs'] custom_headers: One or more `custom_header` blocks as defined below.
        :param Sequence[str] expected_status_code_ranges: A list of status code ranges.
        :param int interval_in_seconds: The interval used to check the endpoint health from a Traffic Manager probing agent.
        :param str path: The path used by the monitoring checks.
        :param int port: The port number used by the monitoring checks.
        :param str protocol: The protocol used by the monitoring checks.
        :param int timeout_in_seconds: The amount of time the Traffic Manager probing agent should wait before considering that check a failure when a health check probe is sent to the endpoint.
        :param int tolerated_number_of_failures: The number of failures a Traffic Manager probing agent tolerates before marking that endpoint as unhealthy.
        """
        pulumi.set(__self__, "custom_headers", custom_headers)
        pulumi.set(__self__, "expected_status_code_ranges", expected_status_code_ranges)
        pulumi.set(__self__, "interval_in_seconds", interval_in_seconds)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "timeout_in_seconds", timeout_in_seconds)
        pulumi.set(__self__, "tolerated_number_of_failures", tolerated_number_of_failures)

    @property
    @pulumi.getter(name="customHeaders")
    def custom_headers(self) -> Sequence['outputs.GetTrafficManagerProfileMonitorConfigCustomHeaderResult']:
        """
        One or more `custom_header` blocks as defined below.
        """
        return pulumi.get(self, "custom_headers")

    @property
    @pulumi.getter(name="expectedStatusCodeRanges")
    def expected_status_code_ranges(self) -> Sequence[str]:
        """
        A list of status code ranges.
        """
        return pulumi.get(self, "expected_status_code_ranges")

    @property
    @pulumi.getter(name="intervalInSeconds")
    def interval_in_seconds(self) -> int:
        """
        The interval used to check the endpoint health from a Traffic Manager probing agent.
        """
        return pulumi.get(self, "interval_in_seconds")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The path used by the monitoring checks.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port number used by the monitoring checks.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The protocol used by the monitoring checks.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> int:
        """
        The amount of time the Traffic Manager probing agent should wait before considering that check a failure when a health check probe is sent to the endpoint.
        """
        return pulumi.get(self, "timeout_in_seconds")

    @property
    @pulumi.getter(name="toleratedNumberOfFailures")
    def tolerated_number_of_failures(self) -> int:
        """
        The number of failures a Traffic Manager probing agent tolerates before marking that endpoint as unhealthy.
        """
        return pulumi.get(self, "tolerated_number_of_failures")


@pulumi.output_type
class GetTrafficManagerProfileMonitorConfigCustomHeaderResult(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: Specifies the name of the Traffic Manager Profile.
        :param str value: The value of custom header. Applicable for Http and Https protocol.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Traffic Manager Profile.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of custom header. Applicable for Http and Https protocol.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetVirtualNetworkGatewayBgpSettingResult(dict):
    def __init__(__self__, *,
                 asn: int,
                 peer_weight: int,
                 peering_address: str):
        """
        :param int asn: The Autonomous System Number (ASN) to use as part of the BGP.
        :param int peer_weight: The weight added to routes which have been learned
               through BGP peering.
        :param str peering_address: The BGP peer IP address of the virtual network
               gateway. This address is needed to configure the created gateway as a BGP Peer
               on the on-premises VPN devices.
        """
        pulumi.set(__self__, "asn", asn)
        pulumi.set(__self__, "peer_weight", peer_weight)
        pulumi.set(__self__, "peering_address", peering_address)

    @property
    @pulumi.getter
    def asn(self) -> int:
        """
        The Autonomous System Number (ASN) to use as part of the BGP.
        """
        return pulumi.get(self, "asn")

    @property
    @pulumi.getter(name="peerWeight")
    def peer_weight(self) -> int:
        """
        The weight added to routes which have been learned
        through BGP peering.
        """
        return pulumi.get(self, "peer_weight")

    @property
    @pulumi.getter(name="peeringAddress")
    def peering_address(self) -> str:
        """
        The BGP peer IP address of the virtual network
        gateway. This address is needed to configure the created gateway as a BGP Peer
        on the on-premises VPN devices.
        """
        return pulumi.get(self, "peering_address")


@pulumi.output_type
class GetVirtualNetworkGatewayCustomRouteResult(dict):
    def __init__(__self__, *,
                 address_prefixes: Sequence[str]):
        """
        :param Sequence[str] address_prefixes: A list of address blocks reserved for this virtual network in CIDR notation.
        """
        pulumi.set(__self__, "address_prefixes", address_prefixes)

    @property
    @pulumi.getter(name="addressPrefixes")
    def address_prefixes(self) -> Sequence[str]:
        """
        A list of address blocks reserved for this virtual network in CIDR notation.
        """
        return pulumi.get(self, "address_prefixes")


@pulumi.output_type
class GetVirtualNetworkGatewayIpConfigurationResult(dict):
    def __init__(__self__, *,
                 name: str,
                 private_ip_address_allocation: str,
                 public_ip_address_id: str,
                 subnet_id: str):
        """
        :param str name: Specifies the name of the Virtual Network Gateway.
        :param str private_ip_address_allocation: Defines how the private IP address
               of the gateways virtual interface is assigned.
        :param str public_ip_address_id: The ID of the Public IP Address associated
               with the Virtual Network Gateway.
        :param str subnet_id: The ID of the gateway subnet of a virtual network in
               which the virtual network gateway will be created. It is mandatory that
               the associated subnet is named `GatewaySubnet`. Therefore, each virtual
               network can contain at most a single Virtual Network Gateway.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "private_ip_address_allocation", private_ip_address_allocation)
        pulumi.set(__self__, "public_ip_address_id", public_ip_address_id)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Virtual Network Gateway.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateIpAddressAllocation")
    def private_ip_address_allocation(self) -> str:
        """
        Defines how the private IP address
        of the gateways virtual interface is assigned.
        """
        return pulumi.get(self, "private_ip_address_allocation")

    @property
    @pulumi.getter(name="publicIpAddressId")
    def public_ip_address_id(self) -> str:
        """
        The ID of the Public IP Address associated
        with the Virtual Network Gateway.
        """
        return pulumi.get(self, "public_ip_address_id")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The ID of the gateway subnet of a virtual network in
        which the virtual network gateway will be created. It is mandatory that
        the associated subnet is named `GatewaySubnet`. Therefore, each virtual
        network can contain at most a single Virtual Network Gateway.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetVirtualNetworkGatewayVpnClientConfigurationResult(dict):
    def __init__(__self__, *,
                 aad_audience: str,
                 aad_issuer: str,
                 aad_tenant: str,
                 address_spaces: Sequence[str],
                 radius_server_address: str,
                 radius_server_secret: str,
                 revoked_certificates: Sequence['outputs.GetVirtualNetworkGatewayVpnClientConfigurationRevokedCertificateResult'],
                 root_certificates: Sequence['outputs.GetVirtualNetworkGatewayVpnClientConfigurationRootCertificateResult'],
                 vpn_client_protocols: Sequence[str]):
        """
        :param str aad_audience: The client id of the Azure VPN application.
               See [Create an Active Directory (AD) tenant for P2S OpenVPN protocol connections](https://docs.microsoft.com/en-gb/azure/vpn-gateway/openvpn-azure-ad-tenant-multi-app) for values
               This setting is incompatible with the use of
               `root_certificate` and `revoked_certificate`, `radius_server_address`, and `radius_server_secret`.
        :param str aad_issuer: The STS url for your tenant
               This setting is incompatible with the use of
               `root_certificate` and `revoked_certificate`, `radius_server_address`, and `radius_server_secret`.
        :param str aad_tenant: AzureAD Tenant URL
               This setting is incompatible with the use of
               `root_certificate` and `revoked_certificate`, `radius_server_address`, and `radius_server_secret`.
        :param Sequence[str] address_spaces: The address space out of which ip addresses for
               vpn clients will be taken. You can provide more than one address space, e.g.
               in CIDR notation.
        :param str radius_server_address: The address of the Radius server.
               This setting is incompatible with the use of
               `aad_tenant`, `aad_audience`, `aad_issuer`, `root_certificate` and `revoked_certificate`.
        :param str radius_server_secret: The secret used by the Radius server.
               This setting is incompatible with the use of
               `aad_tenant`, `aad_audience`, `aad_issuer`, `root_certificate` and `revoked_certificate`.
        :param Sequence['GetVirtualNetworkGatewayVpnClientConfigurationRevokedCertificateArgs'] revoked_certificates: One or more `revoked_certificate` blocks which
               are defined below.
               This setting is incompatible with the use of
               `aad_tenant`, `aad_audience`, `aad_issuer`, `radius_server_address`, and `radius_server_secret`.
        :param Sequence['GetVirtualNetworkGatewayVpnClientConfigurationRootCertificateArgs'] root_certificates: One or more `root_certificate` blocks which are
               defined below. These root certificates are used to sign the client certificate
               used by the VPN clients to connect to the gateway.
               This setting is incompatible with the use of
               `aad_tenant`, `aad_audience`, `aad_issuer`, `radius_server_address`, and `radius_server_secret`.
        :param Sequence[str] vpn_client_protocols: List of the protocols supported by the vpn client.
               The supported values are `SSTP`, `IkeV2` and `OpenVPN`.
        """
        pulumi.set(__self__, "aad_audience", aad_audience)
        pulumi.set(__self__, "aad_issuer", aad_issuer)
        pulumi.set(__self__, "aad_tenant", aad_tenant)
        pulumi.set(__self__, "address_spaces", address_spaces)
        pulumi.set(__self__, "radius_server_address", radius_server_address)
        pulumi.set(__self__, "radius_server_secret", radius_server_secret)
        pulumi.set(__self__, "revoked_certificates", revoked_certificates)
        pulumi.set(__self__, "root_certificates", root_certificates)
        pulumi.set(__self__, "vpn_client_protocols", vpn_client_protocols)

    @property
    @pulumi.getter(name="aadAudience")
    def aad_audience(self) -> str:
        """
        The client id of the Azure VPN application.
        See [Create an Active Directory (AD) tenant for P2S OpenVPN protocol connections](https://docs.microsoft.com/en-gb/azure/vpn-gateway/openvpn-azure-ad-tenant-multi-app) for values
        This setting is incompatible with the use of
        `root_certificate` and `revoked_certificate`, `radius_server_address`, and `radius_server_secret`.
        """
        return pulumi.get(self, "aad_audience")

    @property
    @pulumi.getter(name="aadIssuer")
    def aad_issuer(self) -> str:
        """
        The STS url for your tenant
        This setting is incompatible with the use of
        `root_certificate` and `revoked_certificate`, `radius_server_address`, and `radius_server_secret`.
        """
        return pulumi.get(self, "aad_issuer")

    @property
    @pulumi.getter(name="aadTenant")
    def aad_tenant(self) -> str:
        """
        AzureAD Tenant URL
        This setting is incompatible with the use of
        `root_certificate` and `revoked_certificate`, `radius_server_address`, and `radius_server_secret`.
        """
        return pulumi.get(self, "aad_tenant")

    @property
    @pulumi.getter(name="addressSpaces")
    def address_spaces(self) -> Sequence[str]:
        """
        The address space out of which ip addresses for
        vpn clients will be taken. You can provide more than one address space, e.g.
        in CIDR notation.
        """
        return pulumi.get(self, "address_spaces")

    @property
    @pulumi.getter(name="radiusServerAddress")
    def radius_server_address(self) -> str:
        """
        The address of the Radius server.
        This setting is incompatible with the use of
        `aad_tenant`, `aad_audience`, `aad_issuer`, `root_certificate` and `revoked_certificate`.
        """
        return pulumi.get(self, "radius_server_address")

    @property
    @pulumi.getter(name="radiusServerSecret")
    def radius_server_secret(self) -> str:
        """
        The secret used by the Radius server.
        This setting is incompatible with the use of
        `aad_tenant`, `aad_audience`, `aad_issuer`, `root_certificate` and `revoked_certificate`.
        """
        return pulumi.get(self, "radius_server_secret")

    @property
    @pulumi.getter(name="revokedCertificates")
    def revoked_certificates(self) -> Sequence['outputs.GetVirtualNetworkGatewayVpnClientConfigurationRevokedCertificateResult']:
        """
        One or more `revoked_certificate` blocks which
        are defined below.
        This setting is incompatible with the use of
        `aad_tenant`, `aad_audience`, `aad_issuer`, `radius_server_address`, and `radius_server_secret`.
        """
        return pulumi.get(self, "revoked_certificates")

    @property
    @pulumi.getter(name="rootCertificates")
    def root_certificates(self) -> Sequence['outputs.GetVirtualNetworkGatewayVpnClientConfigurationRootCertificateResult']:
        """
        One or more `root_certificate` blocks which are
        defined below. These root certificates are used to sign the client certificate
        used by the VPN clients to connect to the gateway.
        This setting is incompatible with the use of
        `aad_tenant`, `aad_audience`, `aad_issuer`, `radius_server_address`, and `radius_server_secret`.
        """
        return pulumi.get(self, "root_certificates")

    @property
    @pulumi.getter(name="vpnClientProtocols")
    def vpn_client_protocols(self) -> Sequence[str]:
        """
        List of the protocols supported by the vpn client.
        The supported values are `SSTP`, `IkeV2` and `OpenVPN`.
        """
        return pulumi.get(self, "vpn_client_protocols")


@pulumi.output_type
class GetVirtualNetworkGatewayVpnClientConfigurationRevokedCertificateResult(dict):
    def __init__(__self__, *,
                 name: str,
                 thumbprint: str):
        """
        :param str name: Specifies the name of the Virtual Network Gateway.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "thumbprint", thumbprint)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Virtual Network Gateway.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def thumbprint(self) -> str:
        return pulumi.get(self, "thumbprint")


@pulumi.output_type
class GetVirtualNetworkGatewayVpnClientConfigurationRootCertificateResult(dict):
    def __init__(__self__, *,
                 name: str,
                 public_cert_data: str):
        """
        :param str name: Specifies the name of the Virtual Network Gateway.
        :param str public_cert_data: The SHA1 thumbprint of the certificate to be revoked.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "public_cert_data", public_cert_data)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Virtual Network Gateway.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="publicCertData")
    def public_cert_data(self) -> str:
        """
        The SHA1 thumbprint of the certificate to be revoked.
        """
        return pulumi.get(self, "public_cert_data")


