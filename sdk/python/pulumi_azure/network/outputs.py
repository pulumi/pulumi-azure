# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'ApplicationGatewayAuthenticationCertificate',
    'ApplicationGatewayAutoscaleConfiguration',
    'ApplicationGatewayBackendAddressPool',
    'ApplicationGatewayBackendHttpSetting',
    'ApplicationGatewayBackendHttpSettingAuthenticationCertificate',
    'ApplicationGatewayBackendHttpSettingConnectionDraining',
    'ApplicationGatewayCustomErrorConfiguration',
    'ApplicationGatewayFrontendIpConfiguration',
    'ApplicationGatewayFrontendPort',
    'ApplicationGatewayGatewayIpConfiguration',
    'ApplicationGatewayGlobal',
    'ApplicationGatewayHttpListener',
    'ApplicationGatewayHttpListenerCustomErrorConfiguration',
    'ApplicationGatewayIdentity',
    'ApplicationGatewayPrivateEndpointConnection',
    'ApplicationGatewayPrivateLinkConfiguration',
    'ApplicationGatewayPrivateLinkConfigurationIpConfiguration',
    'ApplicationGatewayProbe',
    'ApplicationGatewayProbeMatch',
    'ApplicationGatewayRedirectConfiguration',
    'ApplicationGatewayRequestRoutingRule',
    'ApplicationGatewayRewriteRuleSet',
    'ApplicationGatewayRewriteRuleSetRewriteRule',
    'ApplicationGatewayRewriteRuleSetRewriteRuleCondition',
    'ApplicationGatewayRewriteRuleSetRewriteRuleRequestHeaderConfiguration',
    'ApplicationGatewayRewriteRuleSetRewriteRuleResponseHeaderConfiguration',
    'ApplicationGatewayRewriteRuleSetRewriteRuleUrl',
    'ApplicationGatewaySku',
    'ApplicationGatewaySslCertificate',
    'ApplicationGatewaySslPolicy',
    'ApplicationGatewaySslProfile',
    'ApplicationGatewaySslProfileSslPolicy',
    'ApplicationGatewayTrustedClientCertificate',
    'ApplicationGatewayTrustedRootCertificate',
    'ApplicationGatewayUrlPathMap',
    'ApplicationGatewayUrlPathMapPathRule',
    'ApplicationGatewayWafConfiguration',
    'ApplicationGatewayWafConfigurationDisabledRuleGroup',
    'ApplicationGatewayWafConfigurationExclusion',
    'ExpressRouteCircuitPeeringIpv6',
    'ExpressRouteCircuitPeeringIpv6MicrosoftPeering',
    'ExpressRouteCircuitPeeringMicrosoftPeeringConfig',
    'ExpressRouteCircuitSku',
    'ExpressRouteConnectionRouting',
    'ExpressRouteConnectionRoutingPropagatedRouteTable',
    'ExpressRoutePortIdentity',
    'ExpressRoutePortLink1',
    'ExpressRoutePortLink2',
    'FirewallApplicationRuleCollectionRule',
    'FirewallApplicationRuleCollectionRuleProtocol',
    'FirewallIpConfiguration',
    'FirewallManagementIpConfiguration',
    'FirewallNatRuleCollectionRule',
    'FirewallNetworkRuleCollectionRule',
    'FirewallPolicyDns',
    'FirewallPolicyExplicitProxy',
    'FirewallPolicyIdentity',
    'FirewallPolicyInsights',
    'FirewallPolicyInsightsLogAnalyticsWorkspace',
    'FirewallPolicyIntrusionDetection',
    'FirewallPolicyIntrusionDetectionSignatureOverride',
    'FirewallPolicyIntrusionDetectionTrafficBypass',
    'FirewallPolicyRuleCollectionGroupApplicationRuleCollection',
    'FirewallPolicyRuleCollectionGroupApplicationRuleCollectionRule',
    'FirewallPolicyRuleCollectionGroupApplicationRuleCollectionRuleProtocol',
    'FirewallPolicyRuleCollectionGroupNatRuleCollection',
    'FirewallPolicyRuleCollectionGroupNatRuleCollectionRule',
    'FirewallPolicyRuleCollectionGroupNetworkRuleCollection',
    'FirewallPolicyRuleCollectionGroupNetworkRuleCollectionRule',
    'FirewallPolicyThreatIntelligenceAllowlist',
    'FirewallPolicyTlsCertificate',
    'FirewallVirtualHub',
    'LocalNetworkGatewayBgpSettings',
    'NetworkConnectionMonitorEndpoint',
    'NetworkConnectionMonitorEndpointFilter',
    'NetworkConnectionMonitorEndpointFilterItem',
    'NetworkConnectionMonitorTestConfiguration',
    'NetworkConnectionMonitorTestConfigurationHttpConfiguration',
    'NetworkConnectionMonitorTestConfigurationHttpConfigurationRequestHeader',
    'NetworkConnectionMonitorTestConfigurationIcmpConfiguration',
    'NetworkConnectionMonitorTestConfigurationSuccessThreshold',
    'NetworkConnectionMonitorTestConfigurationTcpConfiguration',
    'NetworkConnectionMonitorTestGroup',
    'NetworkInterfaceIpConfiguration',
    'NetworkManagerAdminRuleDestination',
    'NetworkManagerAdminRuleSource',
    'NetworkManagerConnectivityConfigurationAppliesToGroup',
    'NetworkManagerConnectivityConfigurationHub',
    'NetworkManagerCrossTenantScope',
    'NetworkManagerScope',
    'NetworkPacketCaptureFilter',
    'NetworkPacketCaptureStorageLocation',
    'NetworkSecurityGroupSecurityRule',
    'NetworkWatcherFlowLogRetentionPolicy',
    'NetworkWatcherFlowLogTrafficAnalytics',
    'PointToPointVpnGatewayConnectionConfiguration',
    'PointToPointVpnGatewayConnectionConfigurationRoute',
    'PointToPointVpnGatewayConnectionConfigurationRoutePropagatedRouteTable',
    'PointToPointVpnGatewayConnectionConfigurationVpnClientAddressPool',
    'ProfileContainerNetworkInterface',
    'ProfileContainerNetworkInterfaceIpConfiguration',
    'RouteFilterRule',
    'RouteMapRule',
    'RouteMapRuleAction',
    'RouteMapRuleActionParameter',
    'RouteMapRuleMatchCriterion',
    'RouteTableRoute',
    'RoutingIntentRoutingPolicy',
    'SubnetDelegation',
    'SubnetDelegationServiceDelegation',
    'SubnetServiceEndpointStoragePolicyDefinition',
    'TrafficManagerAzureEndpointCustomHeader',
    'TrafficManagerAzureEndpointSubnet',
    'TrafficManagerExternalEndpointCustomHeader',
    'TrafficManagerExternalEndpointSubnet',
    'TrafficManagerNestedEndpointCustomHeader',
    'TrafficManagerNestedEndpointSubnet',
    'TrafficManagerProfileDnsConfig',
    'TrafficManagerProfileMonitorConfig',
    'TrafficManagerProfileMonitorConfigCustomHeader',
    'VirtualHubConnectionRouting',
    'VirtualHubConnectionRoutingPropagatedRouteTable',
    'VirtualHubConnectionRoutingStaticVnetRoute',
    'VirtualHubRoute',
    'VirtualHubRouteTableRoute',
    'VirtualNetworkDdosProtectionPlan',
    'VirtualNetworkEncryption',
    'VirtualNetworkGatewayBgpSettings',
    'VirtualNetworkGatewayBgpSettingsPeeringAddress',
    'VirtualNetworkGatewayConnectionCustomBgpAddresses',
    'VirtualNetworkGatewayConnectionIpsecPolicy',
    'VirtualNetworkGatewayConnectionTrafficSelectorPolicy',
    'VirtualNetworkGatewayCustomRoute',
    'VirtualNetworkGatewayIpConfiguration',
    'VirtualNetworkGatewayNatRuleExternalMapping',
    'VirtualNetworkGatewayNatRuleInternalMapping',
    'VirtualNetworkGatewayVpnClientConfiguration',
    'VirtualNetworkGatewayVpnClientConfigurationRevokedCertificate',
    'VirtualNetworkGatewayVpnClientConfigurationRootCertificate',
    'VirtualNetworkSubnet',
    'VnpGatewayNatRuleExternalMapping',
    'VnpGatewayNatRuleInternalMapping',
    'VpnGatewayBgpSettings',
    'VpnGatewayBgpSettingsInstance0BgpPeeringAddress',
    'VpnGatewayBgpSettingsInstance1BgpPeeringAddress',
    'VpnGatewayConnectionRouting',
    'VpnGatewayConnectionRoutingPropagatedRouteTable',
    'VpnGatewayConnectionTrafficSelectorPolicy',
    'VpnGatewayConnectionVpnLink',
    'VpnGatewayConnectionVpnLinkCustomBgpAddress',
    'VpnGatewayConnectionVpnLinkIpsecPolicy',
    'VpnServerConfigurationAzureActiveDirectoryAuthentication',
    'VpnServerConfigurationClientRevokedCertificate',
    'VpnServerConfigurationClientRootCertificate',
    'VpnServerConfigurationIpsecPolicy',
    'VpnServerConfigurationPolicyGroupPolicy',
    'VpnServerConfigurationRadius',
    'VpnServerConfigurationRadiusClientRootCertificate',
    'VpnServerConfigurationRadiusServer',
    'VpnServerConfigurationRadiusServerRootCertificate',
    'VpnSiteLink',
    'VpnSiteLinkBgp',
    'VpnSiteO365Policy',
    'VpnSiteO365PolicyTrafficCategory',
    'GetApplicationGatewayBackendAddressPoolResult',
    'GetApplicationGatewayIdentityResult',
    'GetExpressRouteCircuitPeeringResult',
    'GetExpressRouteCircuitServiceProviderPropertyResult',
    'GetExpressRouteCircuitSkuResult',
    'GetFirewallIpConfigurationResult',
    'GetFirewallManagementIpConfigurationResult',
    'GetFirewallPolicyDnResult',
    'GetFirewallPolicyThreatIntelligenceAllowlistResult',
    'GetFirewallVirtualHubResult',
    'GetGatewayConnectionIpsecPolicyResult',
    'GetGatewayConnectionTrafficSelectorPolicyResult',
    'GetLocalNetworkGatewayBgpSettingResult',
    'GetNetworkInterfaceIpConfigurationResult',
    'GetNetworkSecurityGroupSecurityRuleResult',
    'GetPublicIPsPublicIpResult',
    'GetRouteFilterRuleResult',
    'GetRouteTableRouteResult',
    'GetTrafficManagerProfileDnsConfigResult',
    'GetTrafficManagerProfileMonitorConfigResult',
    'GetTrafficManagerProfileMonitorConfigCustomHeaderResult',
    'GetVirtualHubConnectionRoutingResult',
    'GetVirtualHubConnectionRoutingPropagatedRouteTableResult',
    'GetVirtualHubConnectionRoutingStaticVnetRouteResult',
    'GetVirtualHubRouteTableRouteResult',
    'GetVirtualNetworkGatewayBgpSettingResult',
    'GetVirtualNetworkGatewayCustomRouteResult',
    'GetVirtualNetworkGatewayIpConfigurationResult',
    'GetVirtualNetworkGatewayVpnClientConfigurationResult',
    'GetVirtualNetworkGatewayVpnClientConfigurationRevokedCertificateResult',
    'GetVirtualNetworkGatewayVpnClientConfigurationRootCertificateResult',
    'GetVpnGatewayBgpSettingResult',
    'GetVpnGatewayBgpSettingInstance0BgpPeeringAddressResult',
    'GetVpnGatewayBgpSettingInstance1BgpPeeringAddressResult',
]

@pulumi.output_type
class ApplicationGatewayAuthenticationCertificate(dict):
    def __init__(__self__, *,
                 data: str,
                 name: str,
                 id: Optional[str] = None):
        """
        :param str data: The contents of the Authentication Certificate which should be used.
        :param str name: The name of the Authentication Certificate.
        :param str id: The ID of the Rewrite Rule Set
        """
        pulumi.set(__self__, "data", data)
        pulumi.set(__self__, "name", name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def data(self) -> str:
        """
        The contents of the Authentication Certificate which should be used.
        """
        return pulumi.get(self, "data")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Authentication Certificate.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Rewrite Rule Set
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ApplicationGatewayAutoscaleConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minCapacity":
            suggest = "min_capacity"
        elif key == "maxCapacity":
            suggest = "max_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayAutoscaleConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayAutoscaleConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayAutoscaleConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 min_capacity: int,
                 max_capacity: Optional[int] = None):
        """
        :param int min_capacity: Minimum capacity for autoscaling. Accepted values are in the range `0` to `100`.
        :param int max_capacity: Maximum capacity for autoscaling. Accepted values are in the range `2` to `125`.
        """
        pulumi.set(__self__, "min_capacity", min_capacity)
        if max_capacity is not None:
            pulumi.set(__self__, "max_capacity", max_capacity)

    @property
    @pulumi.getter(name="minCapacity")
    def min_capacity(self) -> int:
        """
        Minimum capacity for autoscaling. Accepted values are in the range `0` to `100`.
        """
        return pulumi.get(self, "min_capacity")

    @property
    @pulumi.getter(name="maxCapacity")
    def max_capacity(self) -> Optional[int]:
        """
        Maximum capacity for autoscaling. Accepted values are in the range `2` to `125`.
        """
        return pulumi.get(self, "max_capacity")


@pulumi.output_type
class ApplicationGatewayBackendAddressPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddresses":
            suggest = "ip_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayBackendAddressPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayBackendAddressPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayBackendAddressPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 fqdns: Optional[Sequence[str]] = None,
                 id: Optional[str] = None,
                 ip_addresses: Optional[Sequence[str]] = None):
        """
        :param str name: The name of the Backend Address Pool.
        :param Sequence[str] fqdns: A list of FQDN's which should be part of the Backend Address Pool.
        :param str id: The ID of the Rewrite Rule Set
        :param Sequence[str] ip_addresses: A list of IP Addresses which should be part of the Backend Address Pool.
        """
        pulumi.set(__self__, "name", name)
        if fqdns is not None:
            pulumi.set(__self__, "fqdns", fqdns)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Backend Address Pool.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def fqdns(self) -> Optional[Sequence[str]]:
        """
        A list of FQDN's which should be part of the Backend Address Pool.
        """
        return pulumi.get(self, "fqdns")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Rewrite Rule Set
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[Sequence[str]]:
        """
        A list of IP Addresses which should be part of the Backend Address Pool.
        """
        return pulumi.get(self, "ip_addresses")


@pulumi.output_type
class ApplicationGatewayBackendHttpSetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cookieBasedAffinity":
            suggest = "cookie_based_affinity"
        elif key == "affinityCookieName":
            suggest = "affinity_cookie_name"
        elif key == "authenticationCertificates":
            suggest = "authentication_certificates"
        elif key == "connectionDraining":
            suggest = "connection_draining"
        elif key == "hostName":
            suggest = "host_name"
        elif key == "pickHostNameFromBackendAddress":
            suggest = "pick_host_name_from_backend_address"
        elif key == "probeId":
            suggest = "probe_id"
        elif key == "probeName":
            suggest = "probe_name"
        elif key == "requestTimeout":
            suggest = "request_timeout"
        elif key == "trustedRootCertificateNames":
            suggest = "trusted_root_certificate_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayBackendHttpSetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayBackendHttpSetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayBackendHttpSetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cookie_based_affinity: str,
                 name: str,
                 port: int,
                 protocol: str,
                 affinity_cookie_name: Optional[str] = None,
                 authentication_certificates: Optional[Sequence['outputs.ApplicationGatewayBackendHttpSettingAuthenticationCertificate']] = None,
                 connection_draining: Optional['outputs.ApplicationGatewayBackendHttpSettingConnectionDraining'] = None,
                 host_name: Optional[str] = None,
                 id: Optional[str] = None,
                 path: Optional[str] = None,
                 pick_host_name_from_backend_address: Optional[bool] = None,
                 probe_id: Optional[str] = None,
                 probe_name: Optional[str] = None,
                 request_timeout: Optional[int] = None,
                 trusted_root_certificate_names: Optional[Sequence[str]] = None):
        """
        :param str cookie_based_affinity: Is Cookie-Based Affinity enabled? Possible values are `Enabled` and `Disabled`.
        :param str name: The name of the Backend HTTP Settings Collection.
        :param int port: The port which should be used for this Backend HTTP Settings Collection.
        :param str protocol: The Protocol which should be used. Possible values are `Http` and `Https`.
        :param str affinity_cookie_name: The name of the affinity cookie.
        :param Sequence['ApplicationGatewayBackendHttpSettingAuthenticationCertificateArgs'] authentication_certificates: One or more `authentication_certificate` blocks as defined below.
        :param 'ApplicationGatewayBackendHttpSettingConnectionDrainingArgs' connection_draining: A `connection_draining` block as defined below.
        :param str host_name: Host header to be sent to the backend servers. Cannot be set if `pick_host_name_from_backend_address` is set to `true`.
        :param str id: The ID of the Rewrite Rule Set
        :param str path: The Path which should be used as a prefix for all HTTP requests.
        :param bool pick_host_name_from_backend_address: Whether host header should be picked from the host name of the backend server. Defaults to `false`.
        :param str probe_id: The ID of the associated Probe.
        :param str probe_name: The name of an associated HTTP Probe.
        :param int request_timeout: The request timeout in seconds, which must be between 1 and 86400 seconds. Defaults to `30`.
        :param Sequence[str] trusted_root_certificate_names: A list of `trusted_root_certificate` names.
        """
        pulumi.set(__self__, "cookie_based_affinity", cookie_based_affinity)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        if affinity_cookie_name is not None:
            pulumi.set(__self__, "affinity_cookie_name", affinity_cookie_name)
        if authentication_certificates is not None:
            pulumi.set(__self__, "authentication_certificates", authentication_certificates)
        if connection_draining is not None:
            pulumi.set(__self__, "connection_draining", connection_draining)
        if host_name is not None:
            pulumi.set(__self__, "host_name", host_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if pick_host_name_from_backend_address is not None:
            pulumi.set(__self__, "pick_host_name_from_backend_address", pick_host_name_from_backend_address)
        if probe_id is not None:
            pulumi.set(__self__, "probe_id", probe_id)
        if probe_name is not None:
            pulumi.set(__self__, "probe_name", probe_name)
        if request_timeout is not None:
            pulumi.set(__self__, "request_timeout", request_timeout)
        if trusted_root_certificate_names is not None:
            pulumi.set(__self__, "trusted_root_certificate_names", trusted_root_certificate_names)

    @property
    @pulumi.getter(name="cookieBasedAffinity")
    def cookie_based_affinity(self) -> str:
        """
        Is Cookie-Based Affinity enabled? Possible values are `Enabled` and `Disabled`.
        """
        return pulumi.get(self, "cookie_based_affinity")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Backend HTTP Settings Collection.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port which should be used for this Backend HTTP Settings Collection.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The Protocol which should be used. Possible values are `Http` and `Https`.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="affinityCookieName")
    def affinity_cookie_name(self) -> Optional[str]:
        """
        The name of the affinity cookie.
        """
        return pulumi.get(self, "affinity_cookie_name")

    @property
    @pulumi.getter(name="authenticationCertificates")
    def authentication_certificates(self) -> Optional[Sequence['outputs.ApplicationGatewayBackendHttpSettingAuthenticationCertificate']]:
        """
        One or more `authentication_certificate` blocks as defined below.
        """
        return pulumi.get(self, "authentication_certificates")

    @property
    @pulumi.getter(name="connectionDraining")
    def connection_draining(self) -> Optional['outputs.ApplicationGatewayBackendHttpSettingConnectionDraining']:
        """
        A `connection_draining` block as defined below.
        """
        return pulumi.get(self, "connection_draining")

    @property
    @pulumi.getter(name="hostName")
    def host_name(self) -> Optional[str]:
        """
        Host header to be sent to the backend servers. Cannot be set if `pick_host_name_from_backend_address` is set to `true`.
        """
        return pulumi.get(self, "host_name")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Rewrite Rule Set
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The Path which should be used as a prefix for all HTTP requests.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="pickHostNameFromBackendAddress")
    def pick_host_name_from_backend_address(self) -> Optional[bool]:
        """
        Whether host header should be picked from the host name of the backend server. Defaults to `false`.
        """
        return pulumi.get(self, "pick_host_name_from_backend_address")

    @property
    @pulumi.getter(name="probeId")
    def probe_id(self) -> Optional[str]:
        """
        The ID of the associated Probe.
        """
        return pulumi.get(self, "probe_id")

    @property
    @pulumi.getter(name="probeName")
    def probe_name(self) -> Optional[str]:
        """
        The name of an associated HTTP Probe.
        """
        return pulumi.get(self, "probe_name")

    @property
    @pulumi.getter(name="requestTimeout")
    def request_timeout(self) -> Optional[int]:
        """
        The request timeout in seconds, which must be between 1 and 86400 seconds. Defaults to `30`.
        """
        return pulumi.get(self, "request_timeout")

    @property
    @pulumi.getter(name="trustedRootCertificateNames")
    def trusted_root_certificate_names(self) -> Optional[Sequence[str]]:
        """
        A list of `trusted_root_certificate` names.
        """
        return pulumi.get(self, "trusted_root_certificate_names")


@pulumi.output_type
class ApplicationGatewayBackendHttpSettingAuthenticationCertificate(dict):
    def __init__(__self__, *,
                 name: str,
                 id: Optional[str] = None):
        """
        :param str name: The name of the Authentication Certificate.
        :param str id: The ID of the Rewrite Rule Set
        """
        pulumi.set(__self__, "name", name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Authentication Certificate.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Rewrite Rule Set
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ApplicationGatewayBackendHttpSettingConnectionDraining(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "drainTimeoutSec":
            suggest = "drain_timeout_sec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayBackendHttpSettingConnectionDraining. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayBackendHttpSettingConnectionDraining.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayBackendHttpSettingConnectionDraining.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 drain_timeout_sec: int,
                 enabled: bool):
        """
        :param int drain_timeout_sec: The number of seconds connection draining is active. Acceptable values are from `1` second to `3600` seconds.
        :param bool enabled: If connection draining is enabled or not.
        """
        pulumi.set(__self__, "drain_timeout_sec", drain_timeout_sec)
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="drainTimeoutSec")
    def drain_timeout_sec(self) -> int:
        """
        The number of seconds connection draining is active. Acceptable values are from `1` second to `3600` seconds.
        """
        return pulumi.get(self, "drain_timeout_sec")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        If connection draining is enabled or not.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ApplicationGatewayCustomErrorConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customErrorPageUrl":
            suggest = "custom_error_page_url"
        elif key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayCustomErrorConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayCustomErrorConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayCustomErrorConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_error_page_url: str,
                 status_code: str,
                 id: Optional[str] = None):
        """
        :param str custom_error_page_url: Error page URL of the application gateway customer error.
        :param str status_code: Status code of the application gateway customer error. Possible values are `HttpStatus403` and `HttpStatus502`
        :param str id: The ID of the Rewrite Rule Set
        """
        pulumi.set(__self__, "custom_error_page_url", custom_error_page_url)
        pulumi.set(__self__, "status_code", status_code)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="customErrorPageUrl")
    def custom_error_page_url(self) -> str:
        """
        Error page URL of the application gateway customer error.
        """
        return pulumi.get(self, "custom_error_page_url")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> str:
        """
        Status code of the application gateway customer error. Possible values are `HttpStatus403` and `HttpStatus502`
        """
        return pulumi.get(self, "status_code")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Rewrite Rule Set
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ApplicationGatewayFrontendIpConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateIpAddress":
            suggest = "private_ip_address"
        elif key == "privateIpAddressAllocation":
            suggest = "private_ip_address_allocation"
        elif key == "privateLinkConfigurationId":
            suggest = "private_link_configuration_id"
        elif key == "privateLinkConfigurationName":
            suggest = "private_link_configuration_name"
        elif key == "publicIpAddressId":
            suggest = "public_ip_address_id"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayFrontendIpConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayFrontendIpConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayFrontendIpConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 id: Optional[str] = None,
                 private_ip_address: Optional[str] = None,
                 private_ip_address_allocation: Optional[str] = None,
                 private_link_configuration_id: Optional[str] = None,
                 private_link_configuration_name: Optional[str] = None,
                 public_ip_address_id: Optional[str] = None,
                 subnet_id: Optional[str] = None):
        """
        :param str name: The name of the Frontend IP Configuration.
        :param str id: The ID of the Rewrite Rule Set
        :param str private_ip_address: The Private IP Address to use for the Application Gateway.
        :param str private_ip_address_allocation: The Allocation Method for the Private IP Address. Possible values are `Dynamic` and `Static`.
        :param str private_link_configuration_id: The ID of the associated private link configuration.
        :param str private_link_configuration_name: The name of the private link configuration to use for this frontend IP configuration.
        :param str public_ip_address_id: The ID of a Public IP Address which the Application Gateway should use. The allocation method for the Public IP Address depends on the `sku` of this Application Gateway. Please refer to the [Azure documentation for public IP addresses](https://docs.microsoft.com/azure/virtual-network/public-ip-addresses#application-gateways) for details.
        :param str subnet_id: The ID of the Subnet.
        """
        pulumi.set(__self__, "name", name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)
        if private_ip_address_allocation is not None:
            pulumi.set(__self__, "private_ip_address_allocation", private_ip_address_allocation)
        if private_link_configuration_id is not None:
            pulumi.set(__self__, "private_link_configuration_id", private_link_configuration_id)
        if private_link_configuration_name is not None:
            pulumi.set(__self__, "private_link_configuration_name", private_link_configuration_name)
        if public_ip_address_id is not None:
            pulumi.set(__self__, "public_ip_address_id", public_ip_address_id)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Frontend IP Configuration.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Rewrite Rule Set
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> Optional[str]:
        """
        The Private IP Address to use for the Application Gateway.
        """
        return pulumi.get(self, "private_ip_address")

    @property
    @pulumi.getter(name="privateIpAddressAllocation")
    def private_ip_address_allocation(self) -> Optional[str]:
        """
        The Allocation Method for the Private IP Address. Possible values are `Dynamic` and `Static`.
        """
        return pulumi.get(self, "private_ip_address_allocation")

    @property
    @pulumi.getter(name="privateLinkConfigurationId")
    def private_link_configuration_id(self) -> Optional[str]:
        """
        The ID of the associated private link configuration.
        """
        return pulumi.get(self, "private_link_configuration_id")

    @property
    @pulumi.getter(name="privateLinkConfigurationName")
    def private_link_configuration_name(self) -> Optional[str]:
        """
        The name of the private link configuration to use for this frontend IP configuration.
        """
        return pulumi.get(self, "private_link_configuration_name")

    @property
    @pulumi.getter(name="publicIpAddressId")
    def public_ip_address_id(self) -> Optional[str]:
        """
        The ID of a Public IP Address which the Application Gateway should use. The allocation method for the Public IP Address depends on the `sku` of this Application Gateway. Please refer to the [Azure documentation for public IP addresses](https://docs.microsoft.com/azure/virtual-network/public-ip-addresses#application-gateways) for details.
        """
        return pulumi.get(self, "public_ip_address_id")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The ID of the Subnet.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class ApplicationGatewayFrontendPort(dict):
    def __init__(__self__, *,
                 name: str,
                 port: int,
                 id: Optional[str] = None):
        """
        :param str name: The name of the Frontend Port.
        :param int port: The port used for this Frontend Port.
        :param str id: The ID of the Rewrite Rule Set
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Frontend Port.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port used for this Frontend Port.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Rewrite Rule Set
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ApplicationGatewayGatewayIpConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayGatewayIpConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayGatewayIpConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayGatewayIpConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 subnet_id: str,
                 id: Optional[str] = None):
        """
        :param str name: The Name of this Gateway IP Configuration.
        :param str subnet_id: The ID of the Subnet which the Application Gateway should be connected to.
        :param str id: The ID of the Rewrite Rule Set
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subnet_id", subnet_id)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Name of this Gateway IP Configuration.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The ID of the Subnet which the Application Gateway should be connected to.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Rewrite Rule Set
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ApplicationGatewayGlobal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestBufferingEnabled":
            suggest = "request_buffering_enabled"
        elif key == "responseBufferingEnabled":
            suggest = "response_buffering_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayGlobal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayGlobal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayGlobal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_buffering_enabled: bool,
                 response_buffering_enabled: bool):
        """
        :param bool request_buffering_enabled: Whether Application Gateway's Request buffer is enabled.
        :param bool response_buffering_enabled: Whether Application Gateway's Response buffer is enabled.
        """
        pulumi.set(__self__, "request_buffering_enabled", request_buffering_enabled)
        pulumi.set(__self__, "response_buffering_enabled", response_buffering_enabled)

    @property
    @pulumi.getter(name="requestBufferingEnabled")
    def request_buffering_enabled(self) -> bool:
        """
        Whether Application Gateway's Request buffer is enabled.
        """
        return pulumi.get(self, "request_buffering_enabled")

    @property
    @pulumi.getter(name="responseBufferingEnabled")
    def response_buffering_enabled(self) -> bool:
        """
        Whether Application Gateway's Response buffer is enabled.
        """
        return pulumi.get(self, "response_buffering_enabled")


@pulumi.output_type
class ApplicationGatewayHttpListener(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frontendIpConfigurationName":
            suggest = "frontend_ip_configuration_name"
        elif key == "frontendPortName":
            suggest = "frontend_port_name"
        elif key == "customErrorConfigurations":
            suggest = "custom_error_configurations"
        elif key == "firewallPolicyId":
            suggest = "firewall_policy_id"
        elif key == "frontendIpConfigurationId":
            suggest = "frontend_ip_configuration_id"
        elif key == "frontendPortId":
            suggest = "frontend_port_id"
        elif key == "hostName":
            suggest = "host_name"
        elif key == "hostNames":
            suggest = "host_names"
        elif key == "requireSni":
            suggest = "require_sni"
        elif key == "sslCertificateId":
            suggest = "ssl_certificate_id"
        elif key == "sslCertificateName":
            suggest = "ssl_certificate_name"
        elif key == "sslProfileId":
            suggest = "ssl_profile_id"
        elif key == "sslProfileName":
            suggest = "ssl_profile_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayHttpListener. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayHttpListener.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayHttpListener.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frontend_ip_configuration_name: str,
                 frontend_port_name: str,
                 name: str,
                 protocol: str,
                 custom_error_configurations: Optional[Sequence['outputs.ApplicationGatewayHttpListenerCustomErrorConfiguration']] = None,
                 firewall_policy_id: Optional[str] = None,
                 frontend_ip_configuration_id: Optional[str] = None,
                 frontend_port_id: Optional[str] = None,
                 host_name: Optional[str] = None,
                 host_names: Optional[Sequence[str]] = None,
                 id: Optional[str] = None,
                 require_sni: Optional[bool] = None,
                 ssl_certificate_id: Optional[str] = None,
                 ssl_certificate_name: Optional[str] = None,
                 ssl_profile_id: Optional[str] = None,
                 ssl_profile_name: Optional[str] = None):
        """
        :param str frontend_ip_configuration_name: The Name of the Frontend IP Configuration used for this HTTP Listener.
        :param str frontend_port_name: The Name of the Frontend Port use for this HTTP Listener.
        :param str name: The Name of the HTTP Listener.
        :param str protocol: The Protocol to use for this HTTP Listener. Possible values are `Http` and `Https`.
        :param Sequence['ApplicationGatewayHttpListenerCustomErrorConfigurationArgs'] custom_error_configurations: One or more `custom_error_configuration` blocks as defined below.
        :param str firewall_policy_id: The ID of the Web Application Firewall Policy which should be used for this HTTP Listener.
        :param str frontend_ip_configuration_id: The ID of the associated Frontend Configuration.
        :param str frontend_port_id: The ID of the associated Frontend Port.
        :param str host_name: The Hostname which should be used for this HTTP Listener. Setting this value changes Listener Type to 'Multi site'.
        :param Sequence[str] host_names: A list of Hostname(s) should be used for this HTTP Listener. It allows special wildcard characters.
               
               > **NOTE** The `host_names` and `host_name` are mutually exclusive and cannot both be set.
        :param str id: The ID of the Rewrite Rule Set
        :param bool require_sni: Should Server Name Indication be Required? Defaults to `false`.
        :param str ssl_certificate_id: The ID of the associated SSL Certificate.
        :param str ssl_certificate_name: The name of the associated SSL Certificate which should be used for this HTTP Listener.
        :param str ssl_profile_id: The ID of the associated SSL Profile.
        :param str ssl_profile_name: The name of the associated SSL Profile which should be used for this HTTP Listener.
        """
        pulumi.set(__self__, "frontend_ip_configuration_name", frontend_ip_configuration_name)
        pulumi.set(__self__, "frontend_port_name", frontend_port_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "protocol", protocol)
        if custom_error_configurations is not None:
            pulumi.set(__self__, "custom_error_configurations", custom_error_configurations)
        if firewall_policy_id is not None:
            pulumi.set(__self__, "firewall_policy_id", firewall_policy_id)
        if frontend_ip_configuration_id is not None:
            pulumi.set(__self__, "frontend_ip_configuration_id", frontend_ip_configuration_id)
        if frontend_port_id is not None:
            pulumi.set(__self__, "frontend_port_id", frontend_port_id)
        if host_name is not None:
            pulumi.set(__self__, "host_name", host_name)
        if host_names is not None:
            pulumi.set(__self__, "host_names", host_names)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if require_sni is not None:
            pulumi.set(__self__, "require_sni", require_sni)
        if ssl_certificate_id is not None:
            pulumi.set(__self__, "ssl_certificate_id", ssl_certificate_id)
        if ssl_certificate_name is not None:
            pulumi.set(__self__, "ssl_certificate_name", ssl_certificate_name)
        if ssl_profile_id is not None:
            pulumi.set(__self__, "ssl_profile_id", ssl_profile_id)
        if ssl_profile_name is not None:
            pulumi.set(__self__, "ssl_profile_name", ssl_profile_name)

    @property
    @pulumi.getter(name="frontendIpConfigurationName")
    def frontend_ip_configuration_name(self) -> str:
        """
        The Name of the Frontend IP Configuration used for this HTTP Listener.
        """
        return pulumi.get(self, "frontend_ip_configuration_name")

    @property
    @pulumi.getter(name="frontendPortName")
    def frontend_port_name(self) -> str:
        """
        The Name of the Frontend Port use for this HTTP Listener.
        """
        return pulumi.get(self, "frontend_port_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Name of the HTTP Listener.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The Protocol to use for this HTTP Listener. Possible values are `Http` and `Https`.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="customErrorConfigurations")
    def custom_error_configurations(self) -> Optional[Sequence['outputs.ApplicationGatewayHttpListenerCustomErrorConfiguration']]:
        """
        One or more `custom_error_configuration` blocks as defined below.
        """
        return pulumi.get(self, "custom_error_configurations")

    @property
    @pulumi.getter(name="firewallPolicyId")
    def firewall_policy_id(self) -> Optional[str]:
        """
        The ID of the Web Application Firewall Policy which should be used for this HTTP Listener.
        """
        return pulumi.get(self, "firewall_policy_id")

    @property
    @pulumi.getter(name="frontendIpConfigurationId")
    def frontend_ip_configuration_id(self) -> Optional[str]:
        """
        The ID of the associated Frontend Configuration.
        """
        return pulumi.get(self, "frontend_ip_configuration_id")

    @property
    @pulumi.getter(name="frontendPortId")
    def frontend_port_id(self) -> Optional[str]:
        """
        The ID of the associated Frontend Port.
        """
        return pulumi.get(self, "frontend_port_id")

    @property
    @pulumi.getter(name="hostName")
    def host_name(self) -> Optional[str]:
        """
        The Hostname which should be used for this HTTP Listener. Setting this value changes Listener Type to 'Multi site'.
        """
        return pulumi.get(self, "host_name")

    @property
    @pulumi.getter(name="hostNames")
    def host_names(self) -> Optional[Sequence[str]]:
        """
        A list of Hostname(s) should be used for this HTTP Listener. It allows special wildcard characters.

        > **NOTE** The `host_names` and `host_name` are mutually exclusive and cannot both be set.
        """
        return pulumi.get(self, "host_names")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Rewrite Rule Set
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="requireSni")
    def require_sni(self) -> Optional[bool]:
        """
        Should Server Name Indication be Required? Defaults to `false`.
        """
        return pulumi.get(self, "require_sni")

    @property
    @pulumi.getter(name="sslCertificateId")
    def ssl_certificate_id(self) -> Optional[str]:
        """
        The ID of the associated SSL Certificate.
        """
        return pulumi.get(self, "ssl_certificate_id")

    @property
    @pulumi.getter(name="sslCertificateName")
    def ssl_certificate_name(self) -> Optional[str]:
        """
        The name of the associated SSL Certificate which should be used for this HTTP Listener.
        """
        return pulumi.get(self, "ssl_certificate_name")

    @property
    @pulumi.getter(name="sslProfileId")
    def ssl_profile_id(self) -> Optional[str]:
        """
        The ID of the associated SSL Profile.
        """
        return pulumi.get(self, "ssl_profile_id")

    @property
    @pulumi.getter(name="sslProfileName")
    def ssl_profile_name(self) -> Optional[str]:
        """
        The name of the associated SSL Profile which should be used for this HTTP Listener.
        """
        return pulumi.get(self, "ssl_profile_name")


@pulumi.output_type
class ApplicationGatewayHttpListenerCustomErrorConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customErrorPageUrl":
            suggest = "custom_error_page_url"
        elif key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayHttpListenerCustomErrorConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayHttpListenerCustomErrorConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayHttpListenerCustomErrorConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_error_page_url: str,
                 status_code: str,
                 id: Optional[str] = None):
        """
        :param str custom_error_page_url: Error page URL of the application gateway customer error.
        :param str status_code: Status code of the application gateway customer error. Possible values are `HttpStatus403` and `HttpStatus502`
        :param str id: The ID of the Rewrite Rule Set
        """
        pulumi.set(__self__, "custom_error_page_url", custom_error_page_url)
        pulumi.set(__self__, "status_code", status_code)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="customErrorPageUrl")
    def custom_error_page_url(self) -> str:
        """
        Error page URL of the application gateway customer error.
        """
        return pulumi.get(self, "custom_error_page_url")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> str:
        """
        Status code of the application gateway customer error. Possible values are `HttpStatus403` and `HttpStatus502`
        """
        return pulumi.get(self, "status_code")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Rewrite Rule Set
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ApplicationGatewayIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_ids: Sequence[str],
                 type: str):
        """
        :param Sequence[str] identity_ids: Specifies a list of User Assigned Managed Identity IDs to be assigned to this Application Gateway.
        :param str type: Specifies the type of Managed Service Identity that should be configured on this Application Gateway. Only possible value is `UserAssigned`.
        """
        pulumi.set(__self__, "identity_ids", identity_ids)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Sequence[str]:
        """
        Specifies a list of User Assigned Managed Identity IDs to be assigned to this Application Gateway.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the type of Managed Service Identity that should be configured on this Application Gateway. Only possible value is `UserAssigned`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ApplicationGatewayPrivateEndpointConnection(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str id: The ID of the Rewrite Rule Set
        :param str name: The name of the Application Gateway. Changing this forces a new resource to be created.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Rewrite Rule Set
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the Application Gateway. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ApplicationGatewayPrivateLinkConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipConfigurations":
            suggest = "ip_configurations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayPrivateLinkConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayPrivateLinkConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayPrivateLinkConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_configurations: Sequence['outputs.ApplicationGatewayPrivateLinkConfigurationIpConfiguration'],
                 name: str,
                 id: Optional[str] = None):
        """
        :param Sequence['ApplicationGatewayPrivateLinkConfigurationIpConfigurationArgs'] ip_configurations: One or more `ip_configuration` blocks as defined below.
               
               > **Please Note**: The `AllowApplicationGatewayPrivateLink` feature must be registered on the subscription before enabling private link
               
               ```python
               import pulumi
               ```
        :param str name: The name of the private link configuration.
        :param str id: The ID of the Rewrite Rule Set
        """
        pulumi.set(__self__, "ip_configurations", ip_configurations)
        pulumi.set(__self__, "name", name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="ipConfigurations")
    def ip_configurations(self) -> Sequence['outputs.ApplicationGatewayPrivateLinkConfigurationIpConfiguration']:
        """
        One or more `ip_configuration` blocks as defined below.

        > **Please Note**: The `AllowApplicationGatewayPrivateLink` feature must be registered on the subscription before enabling private link

        ```python
        import pulumi
        ```
        """
        return pulumi.get(self, "ip_configurations")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the private link configuration.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Rewrite Rule Set
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ApplicationGatewayPrivateLinkConfigurationIpConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateIpAddressAllocation":
            suggest = "private_ip_address_allocation"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "privateIpAddress":
            suggest = "private_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayPrivateLinkConfigurationIpConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayPrivateLinkConfigurationIpConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayPrivateLinkConfigurationIpConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 primary: bool,
                 private_ip_address_allocation: str,
                 subnet_id: str,
                 private_ip_address: Optional[str] = None):
        """
        :param str name: The name of the IP configuration.
        :param bool primary: Is this the Primary IP Configuration?
        :param str private_ip_address_allocation: The allocation method used for the Private IP Address. Possible values are `Dynamic` and `Static`.
        :param str subnet_id: The ID of the subnet the private link configuration should connect to.
        :param str private_ip_address: The Static IP Address which should be used.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "primary", primary)
        pulumi.set(__self__, "private_ip_address_allocation", private_ip_address_allocation)
        pulumi.set(__self__, "subnet_id", subnet_id)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the IP configuration.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def primary(self) -> bool:
        """
        Is this the Primary IP Configuration?
        """
        return pulumi.get(self, "primary")

    @property
    @pulumi.getter(name="privateIpAddressAllocation")
    def private_ip_address_allocation(self) -> str:
        """
        The allocation method used for the Private IP Address. Possible values are `Dynamic` and `Static`.
        """
        return pulumi.get(self, "private_ip_address_allocation")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The ID of the subnet the private link configuration should connect to.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> Optional[str]:
        """
        The Static IP Address which should be used.
        """
        return pulumi.get(self, "private_ip_address")


@pulumi.output_type
class ApplicationGatewayProbe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "unhealthyThreshold":
            suggest = "unhealthy_threshold"
        elif key == "minimumServers":
            suggest = "minimum_servers"
        elif key == "pickHostNameFromBackendHttpSettings":
            suggest = "pick_host_name_from_backend_http_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayProbe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayProbe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayProbe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interval: int,
                 name: str,
                 path: str,
                 protocol: str,
                 timeout: int,
                 unhealthy_threshold: int,
                 host: Optional[str] = None,
                 id: Optional[str] = None,
                 match: Optional['outputs.ApplicationGatewayProbeMatch'] = None,
                 minimum_servers: Optional[int] = None,
                 pick_host_name_from_backend_http_settings: Optional[bool] = None,
                 port: Optional[int] = None):
        """
        :param int interval: The Interval between two consecutive probes in seconds. Possible values range from 1 second to a maximum of 86,400 seconds.
        :param str name: The Name of the Probe.
        :param str path: The Path used for this Probe.
        :param str protocol: The Protocol used for this Probe. Possible values are `Http` and `Https`.
        :param int timeout: The Timeout used for this Probe, which indicates when a probe becomes unhealthy. Possible values range from 1 second to a maximum of 86,400 seconds.
        :param int unhealthy_threshold: The Unhealthy Threshold for this Probe, which indicates the amount of retries which should be attempted before a node is deemed unhealthy. Possible values are from 1 to 20.
        :param str host: The Hostname used for this Probe. If the Application Gateway is configured for a single site, by default the Host name should be specified as `127.0.0.1`, unless otherwise configured in custom probe. Cannot be set if `pick_host_name_from_backend_http_settings` is set to `true`.
        :param str id: The ID of the Rewrite Rule Set
        :param 'ApplicationGatewayProbeMatchArgs' match: A `match` block as defined above.
        :param int minimum_servers: The minimum number of servers that are always marked as healthy. Defaults to `0`.
        :param bool pick_host_name_from_backend_http_settings: Whether the host header should be picked from the backend HTTP settings. Defaults to `false`.
        :param int port: Custom port which will be used for probing the backend servers. The valid value ranges from 1 to 65535. In case not set, port from HTTP settings will be used. This property is valid for Standard_v2 and WAF_v2 only.
        """
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if minimum_servers is not None:
            pulumi.set(__self__, "minimum_servers", minimum_servers)
        if pick_host_name_from_backend_http_settings is not None:
            pulumi.set(__self__, "pick_host_name_from_backend_http_settings", pick_host_name_from_backend_http_settings)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def interval(self) -> int:
        """
        The Interval between two consecutive probes in seconds. Possible values range from 1 second to a maximum of 86,400 seconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Name of the Probe.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The Path used for this Probe.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The Protocol used for this Probe. Possible values are `Http` and `Https`.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def timeout(self) -> int:
        """
        The Timeout used for this Probe, which indicates when a probe becomes unhealthy. Possible values range from 1 second to a maximum of 86,400 seconds.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> int:
        """
        The Unhealthy Threshold for this Probe, which indicates the amount of retries which should be attempted before a node is deemed unhealthy. Possible values are from 1 to 20.
        """
        return pulumi.get(self, "unhealthy_threshold")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The Hostname used for this Probe. If the Application Gateway is configured for a single site, by default the Host name should be specified as `127.0.0.1`, unless otherwise configured in custom probe. Cannot be set if `pick_host_name_from_backend_http_settings` is set to `true`.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Rewrite Rule Set
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def match(self) -> Optional['outputs.ApplicationGatewayProbeMatch']:
        """
        A `match` block as defined above.
        """
        return pulumi.get(self, "match")

    @property
    @pulumi.getter(name="minimumServers")
    def minimum_servers(self) -> Optional[int]:
        """
        The minimum number of servers that are always marked as healthy. Defaults to `0`.
        """
        return pulumi.get(self, "minimum_servers")

    @property
    @pulumi.getter(name="pickHostNameFromBackendHttpSettings")
    def pick_host_name_from_backend_http_settings(self) -> Optional[bool]:
        """
        Whether the host header should be picked from the backend HTTP settings. Defaults to `false`.
        """
        return pulumi.get(self, "pick_host_name_from_backend_http_settings")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Custom port which will be used for probing the backend servers. The valid value ranges from 1 to 65535. In case not set, port from HTTP settings will be used. This property is valid for Standard_v2 and WAF_v2 only.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class ApplicationGatewayProbeMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusCodes":
            suggest = "status_codes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayProbeMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayProbeMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayProbeMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status_codes: Sequence[str],
                 body: Optional[str] = None):
        """
        :param Sequence[str] status_codes: A list of allowed status codes for this Health Probe.
        :param str body: A snippet from the Response Body which must be present in the Response.
        """
        pulumi.set(__self__, "status_codes", status_codes)
        if body is not None:
            pulumi.set(__self__, "body", body)

    @property
    @pulumi.getter(name="statusCodes")
    def status_codes(self) -> Sequence[str]:
        """
        A list of allowed status codes for this Health Probe.
        """
        return pulumi.get(self, "status_codes")

    @property
    @pulumi.getter
    def body(self) -> Optional[str]:
        """
        A snippet from the Response Body which must be present in the Response.
        """
        return pulumi.get(self, "body")


@pulumi.output_type
class ApplicationGatewayRedirectConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "redirectType":
            suggest = "redirect_type"
        elif key == "includePath":
            suggest = "include_path"
        elif key == "includeQueryString":
            suggest = "include_query_string"
        elif key == "targetListenerId":
            suggest = "target_listener_id"
        elif key == "targetListenerName":
            suggest = "target_listener_name"
        elif key == "targetUrl":
            suggest = "target_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayRedirectConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayRedirectConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayRedirectConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 redirect_type: str,
                 id: Optional[str] = None,
                 include_path: Optional[bool] = None,
                 include_query_string: Optional[bool] = None,
                 target_listener_id: Optional[str] = None,
                 target_listener_name: Optional[str] = None,
                 target_url: Optional[str] = None):
        """
        :param str name: Unique name of the redirect configuration block
        :param str redirect_type: The type of redirect. Possible values are `Permanent`, `Temporary`, `Found` and `SeeOther`
        :param str id: The ID of the Rewrite Rule Set
        :param bool include_path: Whether or not to include the path in the redirected Url. Defaults to `false`
        :param bool include_query_string: Whether or not to include the query string in the redirected Url. Default to `false`
        :param str target_listener_name: The name of the listener to redirect to. Cannot be set if `target_url` is set.
        :param str target_url: The Url to redirect the request to. Cannot be set if `target_listener_name` is set.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "redirect_type", redirect_type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if include_path is not None:
            pulumi.set(__self__, "include_path", include_path)
        if include_query_string is not None:
            pulumi.set(__self__, "include_query_string", include_query_string)
        if target_listener_id is not None:
            pulumi.set(__self__, "target_listener_id", target_listener_id)
        if target_listener_name is not None:
            pulumi.set(__self__, "target_listener_name", target_listener_name)
        if target_url is not None:
            pulumi.set(__self__, "target_url", target_url)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique name of the redirect configuration block
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="redirectType")
    def redirect_type(self) -> str:
        """
        The type of redirect. Possible values are `Permanent`, `Temporary`, `Found` and `SeeOther`
        """
        return pulumi.get(self, "redirect_type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Rewrite Rule Set
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="includePath")
    def include_path(self) -> Optional[bool]:
        """
        Whether or not to include the path in the redirected Url. Defaults to `false`
        """
        return pulumi.get(self, "include_path")

    @property
    @pulumi.getter(name="includeQueryString")
    def include_query_string(self) -> Optional[bool]:
        """
        Whether or not to include the query string in the redirected Url. Default to `false`
        """
        return pulumi.get(self, "include_query_string")

    @property
    @pulumi.getter(name="targetListenerId")
    def target_listener_id(self) -> Optional[str]:
        return pulumi.get(self, "target_listener_id")

    @property
    @pulumi.getter(name="targetListenerName")
    def target_listener_name(self) -> Optional[str]:
        """
        The name of the listener to redirect to. Cannot be set if `target_url` is set.
        """
        return pulumi.get(self, "target_listener_name")

    @property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> Optional[str]:
        """
        The Url to redirect the request to. Cannot be set if `target_listener_name` is set.
        """
        return pulumi.get(self, "target_url")


@pulumi.output_type
class ApplicationGatewayRequestRoutingRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpListenerName":
            suggest = "http_listener_name"
        elif key == "ruleType":
            suggest = "rule_type"
        elif key == "backendAddressPoolId":
            suggest = "backend_address_pool_id"
        elif key == "backendAddressPoolName":
            suggest = "backend_address_pool_name"
        elif key == "backendHttpSettingsId":
            suggest = "backend_http_settings_id"
        elif key == "backendHttpSettingsName":
            suggest = "backend_http_settings_name"
        elif key == "httpListenerId":
            suggest = "http_listener_id"
        elif key == "redirectConfigurationId":
            suggest = "redirect_configuration_id"
        elif key == "redirectConfigurationName":
            suggest = "redirect_configuration_name"
        elif key == "rewriteRuleSetId":
            suggest = "rewrite_rule_set_id"
        elif key == "rewriteRuleSetName":
            suggest = "rewrite_rule_set_name"
        elif key == "urlPathMapId":
            suggest = "url_path_map_id"
        elif key == "urlPathMapName":
            suggest = "url_path_map_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayRequestRoutingRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayRequestRoutingRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayRequestRoutingRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_listener_name: str,
                 name: str,
                 rule_type: str,
                 backend_address_pool_id: Optional[str] = None,
                 backend_address_pool_name: Optional[str] = None,
                 backend_http_settings_id: Optional[str] = None,
                 backend_http_settings_name: Optional[str] = None,
                 http_listener_id: Optional[str] = None,
                 id: Optional[str] = None,
                 priority: Optional[int] = None,
                 redirect_configuration_id: Optional[str] = None,
                 redirect_configuration_name: Optional[str] = None,
                 rewrite_rule_set_id: Optional[str] = None,
                 rewrite_rule_set_name: Optional[str] = None,
                 url_path_map_id: Optional[str] = None,
                 url_path_map_name: Optional[str] = None):
        """
        :param str http_listener_name: The Name of the HTTP Listener which should be used for this Routing Rule.
        :param str name: The Name of this Request Routing Rule.
        :param str rule_type: The Type of Routing that should be used for this Rule. Possible values are `Basic` and `PathBasedRouting`.
        :param str backend_address_pool_id: The ID of the associated Backend Address Pool.
        :param str backend_address_pool_name: The Name of the Backend Address Pool which should be used for this Routing Rule. Cannot be set if `redirect_configuration_name` is set.
        :param str backend_http_settings_id: The ID of the associated Backend HTTP Settings Configuration.
        :param str backend_http_settings_name: The Name of the Backend HTTP Settings Collection which should be used for this Routing Rule. Cannot be set if `redirect_configuration_name` is set.
        :param str http_listener_id: The ID of the associated HTTP Listener.
        :param str id: The ID of the Rewrite Rule Set
        :param int priority: Rule evaluation order can be dictated by specifying an integer value from `1` to `20000` with `1` being the highest priority and `20000` being the lowest priority.
               
               > **NOTE:** `priority` is required when `sku.0.tier` is set to `*_v2`.
        :param str redirect_configuration_id: The ID of the associated Redirect Configuration.
        :param str redirect_configuration_name: The Name of the Redirect Configuration which should be used for this Routing Rule. Cannot be set if either `backend_address_pool_name` or `backend_http_settings_name` is set.
        :param str rewrite_rule_set_id: The ID of the associated Rewrite Rule Set.
        :param str rewrite_rule_set_name: The Name of the Rewrite Rule Set which should be used for this Routing Rule. Only valid for v2 SKUs.
               
               > **NOTE:** `backend_address_pool_name`, `backend_http_settings_name`, `redirect_configuration_name`, and `rewrite_rule_set_name` are applicable only when `rule_type` is `Basic`.
        :param str url_path_map_id: The ID of the associated URL Path Map.
        :param str url_path_map_name: The Name of the URL Path Map which should be associated with this Routing Rule.
        """
        pulumi.set(__self__, "http_listener_name", http_listener_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "rule_type", rule_type)
        if backend_address_pool_id is not None:
            pulumi.set(__self__, "backend_address_pool_id", backend_address_pool_id)
        if backend_address_pool_name is not None:
            pulumi.set(__self__, "backend_address_pool_name", backend_address_pool_name)
        if backend_http_settings_id is not None:
            pulumi.set(__self__, "backend_http_settings_id", backend_http_settings_id)
        if backend_http_settings_name is not None:
            pulumi.set(__self__, "backend_http_settings_name", backend_http_settings_name)
        if http_listener_id is not None:
            pulumi.set(__self__, "http_listener_id", http_listener_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if redirect_configuration_id is not None:
            pulumi.set(__self__, "redirect_configuration_id", redirect_configuration_id)
        if redirect_configuration_name is not None:
            pulumi.set(__self__, "redirect_configuration_name", redirect_configuration_name)
        if rewrite_rule_set_id is not None:
            pulumi.set(__self__, "rewrite_rule_set_id", rewrite_rule_set_id)
        if rewrite_rule_set_name is not None:
            pulumi.set(__self__, "rewrite_rule_set_name", rewrite_rule_set_name)
        if url_path_map_id is not None:
            pulumi.set(__self__, "url_path_map_id", url_path_map_id)
        if url_path_map_name is not None:
            pulumi.set(__self__, "url_path_map_name", url_path_map_name)

    @property
    @pulumi.getter(name="httpListenerName")
    def http_listener_name(self) -> str:
        """
        The Name of the HTTP Listener which should be used for this Routing Rule.
        """
        return pulumi.get(self, "http_listener_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Name of this Request Routing Rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> str:
        """
        The Type of Routing that should be used for this Rule. Possible values are `Basic` and `PathBasedRouting`.
        """
        return pulumi.get(self, "rule_type")

    @property
    @pulumi.getter(name="backendAddressPoolId")
    def backend_address_pool_id(self) -> Optional[str]:
        """
        The ID of the associated Backend Address Pool.
        """
        return pulumi.get(self, "backend_address_pool_id")

    @property
    @pulumi.getter(name="backendAddressPoolName")
    def backend_address_pool_name(self) -> Optional[str]:
        """
        The Name of the Backend Address Pool which should be used for this Routing Rule. Cannot be set if `redirect_configuration_name` is set.
        """
        return pulumi.get(self, "backend_address_pool_name")

    @property
    @pulumi.getter(name="backendHttpSettingsId")
    def backend_http_settings_id(self) -> Optional[str]:
        """
        The ID of the associated Backend HTTP Settings Configuration.
        """
        return pulumi.get(self, "backend_http_settings_id")

    @property
    @pulumi.getter(name="backendHttpSettingsName")
    def backend_http_settings_name(self) -> Optional[str]:
        """
        The Name of the Backend HTTP Settings Collection which should be used for this Routing Rule. Cannot be set if `redirect_configuration_name` is set.
        """
        return pulumi.get(self, "backend_http_settings_name")

    @property
    @pulumi.getter(name="httpListenerId")
    def http_listener_id(self) -> Optional[str]:
        """
        The ID of the associated HTTP Listener.
        """
        return pulumi.get(self, "http_listener_id")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Rewrite Rule Set
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        Rule evaluation order can be dictated by specifying an integer value from `1` to `20000` with `1` being the highest priority and `20000` being the lowest priority.

        > **NOTE:** `priority` is required when `sku.0.tier` is set to `*_v2`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="redirectConfigurationId")
    def redirect_configuration_id(self) -> Optional[str]:
        """
        The ID of the associated Redirect Configuration.
        """
        return pulumi.get(self, "redirect_configuration_id")

    @property
    @pulumi.getter(name="redirectConfigurationName")
    def redirect_configuration_name(self) -> Optional[str]:
        """
        The Name of the Redirect Configuration which should be used for this Routing Rule. Cannot be set if either `backend_address_pool_name` or `backend_http_settings_name` is set.
        """
        return pulumi.get(self, "redirect_configuration_name")

    @property
    @pulumi.getter(name="rewriteRuleSetId")
    def rewrite_rule_set_id(self) -> Optional[str]:
        """
        The ID of the associated Rewrite Rule Set.
        """
        return pulumi.get(self, "rewrite_rule_set_id")

    @property
    @pulumi.getter(name="rewriteRuleSetName")
    def rewrite_rule_set_name(self) -> Optional[str]:
        """
        The Name of the Rewrite Rule Set which should be used for this Routing Rule. Only valid for v2 SKUs.

        > **NOTE:** `backend_address_pool_name`, `backend_http_settings_name`, `redirect_configuration_name`, and `rewrite_rule_set_name` are applicable only when `rule_type` is `Basic`.
        """
        return pulumi.get(self, "rewrite_rule_set_name")

    @property
    @pulumi.getter(name="urlPathMapId")
    def url_path_map_id(self) -> Optional[str]:
        """
        The ID of the associated URL Path Map.
        """
        return pulumi.get(self, "url_path_map_id")

    @property
    @pulumi.getter(name="urlPathMapName")
    def url_path_map_name(self) -> Optional[str]:
        """
        The Name of the URL Path Map which should be associated with this Routing Rule.
        """
        return pulumi.get(self, "url_path_map_name")


@pulumi.output_type
class ApplicationGatewayRewriteRuleSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rewriteRules":
            suggest = "rewrite_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayRewriteRuleSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayRewriteRuleSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayRewriteRuleSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 id: Optional[str] = None,
                 rewrite_rules: Optional[Sequence['outputs.ApplicationGatewayRewriteRuleSetRewriteRule']] = None):
        """
        :param str name: Unique name of the rewrite rule set block
        :param str id: The ID of the Rewrite Rule Set
        :param Sequence['ApplicationGatewayRewriteRuleSetRewriteRuleArgs'] rewrite_rules: One or more `rewrite_rule` blocks as defined above.
        """
        pulumi.set(__self__, "name", name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if rewrite_rules is not None:
            pulumi.set(__self__, "rewrite_rules", rewrite_rules)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique name of the rewrite rule set block
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Rewrite Rule Set
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="rewriteRules")
    def rewrite_rules(self) -> Optional[Sequence['outputs.ApplicationGatewayRewriteRuleSetRewriteRule']]:
        """
        One or more `rewrite_rule` blocks as defined above.
        """
        return pulumi.get(self, "rewrite_rules")


@pulumi.output_type
class ApplicationGatewayRewriteRuleSetRewriteRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleSequence":
            suggest = "rule_sequence"
        elif key == "requestHeaderConfigurations":
            suggest = "request_header_configurations"
        elif key == "responseHeaderConfigurations":
            suggest = "response_header_configurations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayRewriteRuleSetRewriteRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayRewriteRuleSetRewriteRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayRewriteRuleSetRewriteRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 rule_sequence: int,
                 conditions: Optional[Sequence['outputs.ApplicationGatewayRewriteRuleSetRewriteRuleCondition']] = None,
                 request_header_configurations: Optional[Sequence['outputs.ApplicationGatewayRewriteRuleSetRewriteRuleRequestHeaderConfiguration']] = None,
                 response_header_configurations: Optional[Sequence['outputs.ApplicationGatewayRewriteRuleSetRewriteRuleResponseHeaderConfiguration']] = None,
                 url: Optional['outputs.ApplicationGatewayRewriteRuleSetRewriteRuleUrl'] = None):
        """
        :param str name: Unique name of the rewrite rule block
        :param int rule_sequence: Rule sequence of the rewrite rule that determines the order of execution in a set.
        :param Sequence['ApplicationGatewayRewriteRuleSetRewriteRuleConditionArgs'] conditions: One or more `condition` blocks as defined above.
        :param Sequence['ApplicationGatewayRewriteRuleSetRewriteRuleRequestHeaderConfigurationArgs'] request_header_configurations: One or more `request_header_configuration` blocks as defined above.
        :param Sequence['ApplicationGatewayRewriteRuleSetRewriteRuleResponseHeaderConfigurationArgs'] response_header_configurations: One or more `response_header_configuration` blocks as defined above.
        :param 'ApplicationGatewayRewriteRuleSetRewriteRuleUrlArgs' url: One `url` block as defined below
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "rule_sequence", rule_sequence)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if request_header_configurations is not None:
            pulumi.set(__self__, "request_header_configurations", request_header_configurations)
        if response_header_configurations is not None:
            pulumi.set(__self__, "response_header_configurations", response_header_configurations)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique name of the rewrite rule block
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="ruleSequence")
    def rule_sequence(self) -> int:
        """
        Rule sequence of the rewrite rule that determines the order of execution in a set.
        """
        return pulumi.get(self, "rule_sequence")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.ApplicationGatewayRewriteRuleSetRewriteRuleCondition']]:
        """
        One or more `condition` blocks as defined above.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="requestHeaderConfigurations")
    def request_header_configurations(self) -> Optional[Sequence['outputs.ApplicationGatewayRewriteRuleSetRewriteRuleRequestHeaderConfiguration']]:
        """
        One or more `request_header_configuration` blocks as defined above.
        """
        return pulumi.get(self, "request_header_configurations")

    @property
    @pulumi.getter(name="responseHeaderConfigurations")
    def response_header_configurations(self) -> Optional[Sequence['outputs.ApplicationGatewayRewriteRuleSetRewriteRuleResponseHeaderConfiguration']]:
        """
        One or more `response_header_configuration` blocks as defined above.
        """
        return pulumi.get(self, "response_header_configurations")

    @property
    @pulumi.getter
    def url(self) -> Optional['outputs.ApplicationGatewayRewriteRuleSetRewriteRuleUrl']:
        """
        One `url` block as defined below
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class ApplicationGatewayRewriteRuleSetRewriteRuleCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ignoreCase":
            suggest = "ignore_case"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayRewriteRuleSetRewriteRuleCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayRewriteRuleSetRewriteRuleCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayRewriteRuleSetRewriteRuleCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pattern: str,
                 variable: str,
                 ignore_case: Optional[bool] = None,
                 negate: Optional[bool] = None):
        """
        :param str pattern: The pattern, either fixed string or regular expression, that evaluates the truthfulness of the condition.
        :param str variable: The [variable](https://docs.microsoft.com/azure/application-gateway/rewrite-http-headers#server-variables) of the condition.
        :param bool ignore_case: Perform a case in-sensitive comparison. Defaults to `false`
        :param bool negate: Negate the result of the condition evaluation. Defaults to `false`
        """
        pulumi.set(__self__, "pattern", pattern)
        pulumi.set(__self__, "variable", variable)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)

    @property
    @pulumi.getter
    def pattern(self) -> str:
        """
        The pattern, either fixed string or regular expression, that evaluates the truthfulness of the condition.
        """
        return pulumi.get(self, "pattern")

    @property
    @pulumi.getter
    def variable(self) -> str:
        """
        The [variable](https://docs.microsoft.com/azure/application-gateway/rewrite-http-headers#server-variables) of the condition.
        """
        return pulumi.get(self, "variable")

    @property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[bool]:
        """
        Perform a case in-sensitive comparison. Defaults to `false`
        """
        return pulumi.get(self, "ignore_case")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Negate the result of the condition evaluation. Defaults to `false`
        """
        return pulumi.get(self, "negate")


@pulumi.output_type
class ApplicationGatewayRewriteRuleSetRewriteRuleRequestHeaderConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerName":
            suggest = "header_name"
        elif key == "headerValue":
            suggest = "header_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayRewriteRuleSetRewriteRuleRequestHeaderConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayRewriteRuleSetRewriteRuleRequestHeaderConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayRewriteRuleSetRewriteRuleRequestHeaderConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_name: str,
                 header_value: str):
        """
        :param str header_name: Header name of the header configuration.
        :param str header_value: Header value of the header configuration. To delete a request header set this property to an empty string.
        """
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "header_value", header_value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        Header name of the header configuration.
        """
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> str:
        """
        Header value of the header configuration. To delete a request header set this property to an empty string.
        """
        return pulumi.get(self, "header_value")


@pulumi.output_type
class ApplicationGatewayRewriteRuleSetRewriteRuleResponseHeaderConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerName":
            suggest = "header_name"
        elif key == "headerValue":
            suggest = "header_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayRewriteRuleSetRewriteRuleResponseHeaderConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayRewriteRuleSetRewriteRuleResponseHeaderConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayRewriteRuleSetRewriteRuleResponseHeaderConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_name: str,
                 header_value: str):
        """
        :param str header_name: Header name of the header configuration.
        :param str header_value: Header value of the header configuration. To delete a response header set this property to an empty string.
        """
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "header_value", header_value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        Header name of the header configuration.
        """
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> str:
        """
        Header value of the header configuration. To delete a response header set this property to an empty string.
        """
        return pulumi.get(self, "header_value")


@pulumi.output_type
class ApplicationGatewayRewriteRuleSetRewriteRuleUrl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryString":
            suggest = "query_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayRewriteRuleSetRewriteRuleUrl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayRewriteRuleSetRewriteRuleUrl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayRewriteRuleSetRewriteRuleUrl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 components: Optional[str] = None,
                 path: Optional[str] = None,
                 query_string: Optional[str] = None,
                 reroute: Optional[bool] = None):
        """
        :param str components: The components used to rewrite the URL. Possible values are `path_only` and `query_string_only` to limit the rewrite to the URL Path or URL Query String only.
               
               > **Note:** One or both of `path` and `query_string` must be specified. If one of these is not specified, it means the value  will be empty. If you only want to rewrite `path` or `query_string`, use `components`.
        :param str path: The URL path to rewrite.
        :param str query_string: The query string to rewrite.
        :param bool reroute: Whether the URL path map should be reevaluated after this rewrite has been applied. [More info on rewrite configutation](https://docs.microsoft.com/azure/application-gateway/rewrite-http-headers-url#rewrite-configuration)
        """
        if components is not None:
            pulumi.set(__self__, "components", components)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if reroute is not None:
            pulumi.set(__self__, "reroute", reroute)

    @property
    @pulumi.getter
    def components(self) -> Optional[str]:
        """
        The components used to rewrite the URL. Possible values are `path_only` and `query_string_only` to limit the rewrite to the URL Path or URL Query String only.

        > **Note:** One or both of `path` and `query_string` must be specified. If one of these is not specified, it means the value  will be empty. If you only want to rewrite `path` or `query_string`, use `components`.
        """
        return pulumi.get(self, "components")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The URL path to rewrite.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[str]:
        """
        The query string to rewrite.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter
    def reroute(self) -> Optional[bool]:
        """
        Whether the URL path map should be reevaluated after this rewrite has been applied. [More info on rewrite configutation](https://docs.microsoft.com/azure/application-gateway/rewrite-http-headers-url#rewrite-configuration)
        """
        return pulumi.get(self, "reroute")


@pulumi.output_type
class ApplicationGatewaySku(dict):
    def __init__(__self__, *,
                 name: str,
                 tier: str,
                 capacity: Optional[int] = None):
        """
        :param str name: The Name of the SKU to use for this Application Gateway. Possible values are `Standard_Small`, `Standard_Medium`, `Standard_Large`, `Standard_v2`, `WAF_Medium`, `WAF_Large`, and `WAF_v2`.
        :param str tier: The Tier of the SKU to use for this Application Gateway. Possible values are `Standard`, `Standard_v2`, `WAF` and `WAF_v2`.
               
               !> **NOTE:** The `Standard` and `WAF` SKU have been deprecated in favour of the `Standard_v2` and `WAF_v2` SKU. Please see the [Azure documentation](https://aka.ms/V1retirement) for more details.
        :param int capacity: The Capacity of the SKU to use for this Application Gateway. When using a V1 SKU this value must be between 1 and 32, and 1 to 125 for a V2 SKU. This property is optional if `autoscale_configuration` is set.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "tier", tier)
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Name of the SKU to use for this Application Gateway. Possible values are `Standard_Small`, `Standard_Medium`, `Standard_Large`, `Standard_v2`, `WAF_Medium`, `WAF_Large`, and `WAF_v2`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tier(self) -> str:
        """
        The Tier of the SKU to use for this Application Gateway. Possible values are `Standard`, `Standard_v2`, `WAF` and `WAF_v2`.

        !> **NOTE:** The `Standard` and `WAF` SKU have been deprecated in favour of the `Standard_v2` and `WAF_v2` SKU. Please see the [Azure documentation](https://aka.ms/V1retirement) for more details.
        """
        return pulumi.get(self, "tier")

    @property
    @pulumi.getter
    def capacity(self) -> Optional[int]:
        """
        The Capacity of the SKU to use for this Application Gateway. When using a V1 SKU this value must be between 1 and 32, and 1 to 125 for a V2 SKU. This property is optional if `autoscale_configuration` is set.
        """
        return pulumi.get(self, "capacity")


@pulumi.output_type
class ApplicationGatewaySslCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVaultSecretId":
            suggest = "key_vault_secret_id"
        elif key == "publicCertData":
            suggest = "public_cert_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewaySslCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewaySslCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewaySslCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 data: Optional[str] = None,
                 id: Optional[str] = None,
                 key_vault_secret_id: Optional[str] = None,
                 password: Optional[str] = None,
                 public_cert_data: Optional[str] = None):
        """
        :param str name: The Name of the SSL certificate that is unique within this Application Gateway
        :param str data: The base64-encoded PFX certificate data. Required if `key_vault_secret_id` is not set.
               
               > **NOTE:** When specifying a file, use `data = filebase64("path/to/file")` to encode the contents of that file.
        :param str id: The ID of the Rewrite Rule Set
        :param str key_vault_secret_id: Secret Id of (base-64 encoded unencrypted pfx) `Secret` or `Certificate` object stored in Azure KeyVault. You need to enable soft delete for keyvault to use this feature. Required if `data` is not set.
               
               > **NOTE:** TLS termination with Key Vault certificates is limited to the [v2 SKUs](https://docs.microsoft.com/azure/application-gateway/key-vault-certs).
               
               > **NOTE:** For TLS termination with Key Vault certificates to work properly existing user-assigned managed identity, which Application Gateway uses to retrieve certificates from Key Vault, should be defined via `identity` block. Additionally, access policies in the Key Vault to allow the identity to be granted *get* access to the secret should be defined.
        :param str password: Password for the pfx file specified in data. Required if `data` is set.
        :param str public_cert_data: The Public Certificate Data associated with the SSL Certificate.
        """
        pulumi.set(__self__, "name", name)
        if data is not None:
            pulumi.set(__self__, "data", data)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if key_vault_secret_id is not None:
            pulumi.set(__self__, "key_vault_secret_id", key_vault_secret_id)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if public_cert_data is not None:
            pulumi.set(__self__, "public_cert_data", public_cert_data)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Name of the SSL certificate that is unique within this Application Gateway
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def data(self) -> Optional[str]:
        """
        The base64-encoded PFX certificate data. Required if `key_vault_secret_id` is not set.

        > **NOTE:** When specifying a file, use `data = filebase64("path/to/file")` to encode the contents of that file.
        """
        return pulumi.get(self, "data")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Rewrite Rule Set
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="keyVaultSecretId")
    def key_vault_secret_id(self) -> Optional[str]:
        """
        Secret Id of (base-64 encoded unencrypted pfx) `Secret` or `Certificate` object stored in Azure KeyVault. You need to enable soft delete for keyvault to use this feature. Required if `data` is not set.

        > **NOTE:** TLS termination with Key Vault certificates is limited to the [v2 SKUs](https://docs.microsoft.com/azure/application-gateway/key-vault-certs).

        > **NOTE:** For TLS termination with Key Vault certificates to work properly existing user-assigned managed identity, which Application Gateway uses to retrieve certificates from Key Vault, should be defined via `identity` block. Additionally, access policies in the Key Vault to allow the identity to be granted *get* access to the secret should be defined.
        """
        return pulumi.get(self, "key_vault_secret_id")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Password for the pfx file specified in data. Required if `data` is set.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="publicCertData")
    def public_cert_data(self) -> Optional[str]:
        """
        The Public Certificate Data associated with the SSL Certificate.
        """
        return pulumi.get(self, "public_cert_data")


@pulumi.output_type
class ApplicationGatewaySslPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cipherSuites":
            suggest = "cipher_suites"
        elif key == "disabledProtocols":
            suggest = "disabled_protocols"
        elif key == "minProtocolVersion":
            suggest = "min_protocol_version"
        elif key == "policyName":
            suggest = "policy_name"
        elif key == "policyType":
            suggest = "policy_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewaySslPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewaySslPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewaySslPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cipher_suites: Optional[Sequence[str]] = None,
                 disabled_protocols: Optional[Sequence[str]] = None,
                 min_protocol_version: Optional[str] = None,
                 policy_name: Optional[str] = None,
                 policy_type: Optional[str] = None):
        """
        :param Sequence[str] cipher_suites: A List of accepted cipher suites. Possible values are: `TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA`, `TLS_DHE_DSS_WITH_AES_128_CBC_SHA`, `TLS_DHE_DSS_WITH_AES_128_CBC_SHA256`, `TLS_DHE_DSS_WITH_AES_256_CBC_SHA`, `TLS_DHE_DSS_WITH_AES_256_CBC_SHA256`, `TLS_DHE_RSA_WITH_AES_128_CBC_SHA`, `TLS_DHE_RSA_WITH_AES_128_GCM_SHA256`, `TLS_DHE_RSA_WITH_AES_256_CBC_SHA`, `TLS_DHE_RSA_WITH_AES_256_GCM_SHA384`, `TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA`, `TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256`, `TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256`, `TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA`, `TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384`, `TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384`, `TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA`, `TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256`, `TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256`, `TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA`, `TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384`, `TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384`, `TLS_RSA_WITH_3DES_EDE_CBC_SHA`, `TLS_RSA_WITH_AES_128_CBC_SHA`, `TLS_RSA_WITH_AES_128_CBC_SHA256`, `TLS_RSA_WITH_AES_128_GCM_SHA256`, `TLS_RSA_WITH_AES_256_CBC_SHA`, `TLS_RSA_WITH_AES_256_CBC_SHA256` and `TLS_RSA_WITH_AES_256_GCM_SHA384`.
        :param Sequence[str] disabled_protocols: A list of SSL Protocols which should be disabled on this Application Gateway. Possible values are `TLSv1_0`, `TLSv1_1`, `TLSv1_2` and `TLSv1_3`.
               
               > **NOTE:** `disabled_protocols` cannot be set when `policy_name` or `policy_type` are set.
        :param str min_protocol_version: The minimal TLS version. Possible values are `TLSv1_0`, `TLSv1_1`, `TLSv1_2` and `TLSv1_3`.
        :param str policy_name: The Name of the Policy e.g AppGwSslPolicy20170401S. Required if `policy_type` is set to `Predefined`. Possible values can change over time and are published here <https://docs.microsoft.com/azure/application-gateway/application-gateway-ssl-policy-overview>. Not compatible with `disabled_protocols`.
        :param str policy_type: The Type of the Policy. Possible values are `Predefined`, `Custom` and `CustomV2`.
               
               > **NOTE:** `policy_type` is Required when `policy_name` is set - cannot be set if `disabled_protocols` is set.
        """
        if cipher_suites is not None:
            pulumi.set(__self__, "cipher_suites", cipher_suites)
        if disabled_protocols is not None:
            pulumi.set(__self__, "disabled_protocols", disabled_protocols)
        if min_protocol_version is not None:
            pulumi.set(__self__, "min_protocol_version", min_protocol_version)
        if policy_name is not None:
            pulumi.set(__self__, "policy_name", policy_name)
        if policy_type is not None:
            pulumi.set(__self__, "policy_type", policy_type)

    @property
    @pulumi.getter(name="cipherSuites")
    def cipher_suites(self) -> Optional[Sequence[str]]:
        """
        A List of accepted cipher suites. Possible values are: `TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA`, `TLS_DHE_DSS_WITH_AES_128_CBC_SHA`, `TLS_DHE_DSS_WITH_AES_128_CBC_SHA256`, `TLS_DHE_DSS_WITH_AES_256_CBC_SHA`, `TLS_DHE_DSS_WITH_AES_256_CBC_SHA256`, `TLS_DHE_RSA_WITH_AES_128_CBC_SHA`, `TLS_DHE_RSA_WITH_AES_128_GCM_SHA256`, `TLS_DHE_RSA_WITH_AES_256_CBC_SHA`, `TLS_DHE_RSA_WITH_AES_256_GCM_SHA384`, `TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA`, `TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256`, `TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256`, `TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA`, `TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384`, `TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384`, `TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA`, `TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256`, `TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256`, `TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA`, `TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384`, `TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384`, `TLS_RSA_WITH_3DES_EDE_CBC_SHA`, `TLS_RSA_WITH_AES_128_CBC_SHA`, `TLS_RSA_WITH_AES_128_CBC_SHA256`, `TLS_RSA_WITH_AES_128_GCM_SHA256`, `TLS_RSA_WITH_AES_256_CBC_SHA`, `TLS_RSA_WITH_AES_256_CBC_SHA256` and `TLS_RSA_WITH_AES_256_GCM_SHA384`.
        """
        return pulumi.get(self, "cipher_suites")

    @property
    @pulumi.getter(name="disabledProtocols")
    def disabled_protocols(self) -> Optional[Sequence[str]]:
        """
        A list of SSL Protocols which should be disabled on this Application Gateway. Possible values are `TLSv1_0`, `TLSv1_1`, `TLSv1_2` and `TLSv1_3`.

        > **NOTE:** `disabled_protocols` cannot be set when `policy_name` or `policy_type` are set.
        """
        return pulumi.get(self, "disabled_protocols")

    @property
    @pulumi.getter(name="minProtocolVersion")
    def min_protocol_version(self) -> Optional[str]:
        """
        The minimal TLS version. Possible values are `TLSv1_0`, `TLSv1_1`, `TLSv1_2` and `TLSv1_3`.
        """
        return pulumi.get(self, "min_protocol_version")

    @property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> Optional[str]:
        """
        The Name of the Policy e.g AppGwSslPolicy20170401S. Required if `policy_type` is set to `Predefined`. Possible values can change over time and are published here <https://docs.microsoft.com/azure/application-gateway/application-gateway-ssl-policy-overview>. Not compatible with `disabled_protocols`.
        """
        return pulumi.get(self, "policy_name")

    @property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> Optional[str]:
        """
        The Type of the Policy. Possible values are `Predefined`, `Custom` and `CustomV2`.

        > **NOTE:** `policy_type` is Required when `policy_name` is set - cannot be set if `disabled_protocols` is set.
        """
        return pulumi.get(self, "policy_type")


@pulumi.output_type
class ApplicationGatewaySslProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sslPolicy":
            suggest = "ssl_policy"
        elif key == "trustedClientCertificateNames":
            suggest = "trusted_client_certificate_names"
        elif key == "verifyClientCertIssuerDn":
            suggest = "verify_client_cert_issuer_dn"
        elif key == "verifyClientCertificateRevocation":
            suggest = "verify_client_certificate_revocation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewaySslProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewaySslProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewaySslProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 id: Optional[str] = None,
                 ssl_policy: Optional['outputs.ApplicationGatewaySslProfileSslPolicy'] = None,
                 trusted_client_certificate_names: Optional[Sequence[str]] = None,
                 verify_client_cert_issuer_dn: Optional[bool] = None,
                 verify_client_certificate_revocation: Optional[str] = None):
        """
        :param str name: The name of the SSL Profile that is unique within this Application Gateway.
        :param str id: The ID of the Rewrite Rule Set
        :param 'ApplicationGatewaySslProfileSslPolicyArgs' ssl_policy: a `ssl_policy` block as defined below.
        :param Sequence[str] trusted_client_certificate_names: The name of the Trusted Client Certificate that will be used to authenticate requests from clients.
        :param bool verify_client_cert_issuer_dn: Should client certificate issuer DN be verified? Defaults to `false`.
        :param str verify_client_certificate_revocation: Specify the method to check client certificate revocation status. Possible value is `OCSP`.
        """
        pulumi.set(__self__, "name", name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ssl_policy is not None:
            pulumi.set(__self__, "ssl_policy", ssl_policy)
        if trusted_client_certificate_names is not None:
            pulumi.set(__self__, "trusted_client_certificate_names", trusted_client_certificate_names)
        if verify_client_cert_issuer_dn is not None:
            pulumi.set(__self__, "verify_client_cert_issuer_dn", verify_client_cert_issuer_dn)
        if verify_client_certificate_revocation is not None:
            pulumi.set(__self__, "verify_client_certificate_revocation", verify_client_certificate_revocation)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the SSL Profile that is unique within this Application Gateway.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Rewrite Rule Set
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="sslPolicy")
    def ssl_policy(self) -> Optional['outputs.ApplicationGatewaySslProfileSslPolicy']:
        """
        a `ssl_policy` block as defined below.
        """
        return pulumi.get(self, "ssl_policy")

    @property
    @pulumi.getter(name="trustedClientCertificateNames")
    def trusted_client_certificate_names(self) -> Optional[Sequence[str]]:
        """
        The name of the Trusted Client Certificate that will be used to authenticate requests from clients.
        """
        return pulumi.get(self, "trusted_client_certificate_names")

    @property
    @pulumi.getter(name="verifyClientCertIssuerDn")
    def verify_client_cert_issuer_dn(self) -> Optional[bool]:
        """
        Should client certificate issuer DN be verified? Defaults to `false`.
        """
        return pulumi.get(self, "verify_client_cert_issuer_dn")

    @property
    @pulumi.getter(name="verifyClientCertificateRevocation")
    def verify_client_certificate_revocation(self) -> Optional[str]:
        """
        Specify the method to check client certificate revocation status. Possible value is `OCSP`.
        """
        return pulumi.get(self, "verify_client_certificate_revocation")


@pulumi.output_type
class ApplicationGatewaySslProfileSslPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cipherSuites":
            suggest = "cipher_suites"
        elif key == "disabledProtocols":
            suggest = "disabled_protocols"
        elif key == "minProtocolVersion":
            suggest = "min_protocol_version"
        elif key == "policyName":
            suggest = "policy_name"
        elif key == "policyType":
            suggest = "policy_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewaySslProfileSslPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewaySslProfileSslPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewaySslProfileSslPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cipher_suites: Optional[Sequence[str]] = None,
                 disabled_protocols: Optional[Sequence[str]] = None,
                 min_protocol_version: Optional[str] = None,
                 policy_name: Optional[str] = None,
                 policy_type: Optional[str] = None):
        """
        :param Sequence[str] cipher_suites: A List of accepted cipher suites. Possible values are: `TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA`, `TLS_DHE_DSS_WITH_AES_128_CBC_SHA`, `TLS_DHE_DSS_WITH_AES_128_CBC_SHA256`, `TLS_DHE_DSS_WITH_AES_256_CBC_SHA`, `TLS_DHE_DSS_WITH_AES_256_CBC_SHA256`, `TLS_DHE_RSA_WITH_AES_128_CBC_SHA`, `TLS_DHE_RSA_WITH_AES_128_GCM_SHA256`, `TLS_DHE_RSA_WITH_AES_256_CBC_SHA`, `TLS_DHE_RSA_WITH_AES_256_GCM_SHA384`, `TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA`, `TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256`, `TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256`, `TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA`, `TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384`, `TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384`, `TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA`, `TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256`, `TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256`, `TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA`, `TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384`, `TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384`, `TLS_RSA_WITH_3DES_EDE_CBC_SHA`, `TLS_RSA_WITH_AES_128_CBC_SHA`, `TLS_RSA_WITH_AES_128_CBC_SHA256`, `TLS_RSA_WITH_AES_128_GCM_SHA256`, `TLS_RSA_WITH_AES_256_CBC_SHA`, `TLS_RSA_WITH_AES_256_CBC_SHA256` and `TLS_RSA_WITH_AES_256_GCM_SHA384`.
        :param Sequence[str] disabled_protocols: A list of SSL Protocols which should be disabled on this Application Gateway. Possible values are `TLSv1_0`, `TLSv1_1`, `TLSv1_2` and `TLSv1_3`.
               
               > **NOTE:** `disabled_protocols` cannot be set when `policy_name` or `policy_type` are set.
        :param str min_protocol_version: The minimal TLS version. Possible values are `TLSv1_0`, `TLSv1_1`, `TLSv1_2` and `TLSv1_3`.
        :param str policy_name: The Name of the Policy e.g AppGwSslPolicy20170401S. Required if `policy_type` is set to `Predefined`. Possible values can change over time and are published here <https://docs.microsoft.com/azure/application-gateway/application-gateway-ssl-policy-overview>. Not compatible with `disabled_protocols`.
        :param str policy_type: The Type of the Policy. Possible values are `Predefined`, `Custom` and `CustomV2`.
               
               > **NOTE:** `policy_type` is Required when `policy_name` is set - cannot be set if `disabled_protocols` is set.
        """
        if cipher_suites is not None:
            pulumi.set(__self__, "cipher_suites", cipher_suites)
        if disabled_protocols is not None:
            pulumi.set(__self__, "disabled_protocols", disabled_protocols)
        if min_protocol_version is not None:
            pulumi.set(__self__, "min_protocol_version", min_protocol_version)
        if policy_name is not None:
            pulumi.set(__self__, "policy_name", policy_name)
        if policy_type is not None:
            pulumi.set(__self__, "policy_type", policy_type)

    @property
    @pulumi.getter(name="cipherSuites")
    def cipher_suites(self) -> Optional[Sequence[str]]:
        """
        A List of accepted cipher suites. Possible values are: `TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA`, `TLS_DHE_DSS_WITH_AES_128_CBC_SHA`, `TLS_DHE_DSS_WITH_AES_128_CBC_SHA256`, `TLS_DHE_DSS_WITH_AES_256_CBC_SHA`, `TLS_DHE_DSS_WITH_AES_256_CBC_SHA256`, `TLS_DHE_RSA_WITH_AES_128_CBC_SHA`, `TLS_DHE_RSA_WITH_AES_128_GCM_SHA256`, `TLS_DHE_RSA_WITH_AES_256_CBC_SHA`, `TLS_DHE_RSA_WITH_AES_256_GCM_SHA384`, `TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA`, `TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256`, `TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256`, `TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA`, `TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384`, `TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384`, `TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA`, `TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256`, `TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256`, `TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA`, `TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384`, `TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384`, `TLS_RSA_WITH_3DES_EDE_CBC_SHA`, `TLS_RSA_WITH_AES_128_CBC_SHA`, `TLS_RSA_WITH_AES_128_CBC_SHA256`, `TLS_RSA_WITH_AES_128_GCM_SHA256`, `TLS_RSA_WITH_AES_256_CBC_SHA`, `TLS_RSA_WITH_AES_256_CBC_SHA256` and `TLS_RSA_WITH_AES_256_GCM_SHA384`.
        """
        return pulumi.get(self, "cipher_suites")

    @property
    @pulumi.getter(name="disabledProtocols")
    def disabled_protocols(self) -> Optional[Sequence[str]]:
        """
        A list of SSL Protocols which should be disabled on this Application Gateway. Possible values are `TLSv1_0`, `TLSv1_1`, `TLSv1_2` and `TLSv1_3`.

        > **NOTE:** `disabled_protocols` cannot be set when `policy_name` or `policy_type` are set.
        """
        return pulumi.get(self, "disabled_protocols")

    @property
    @pulumi.getter(name="minProtocolVersion")
    def min_protocol_version(self) -> Optional[str]:
        """
        The minimal TLS version. Possible values are `TLSv1_0`, `TLSv1_1`, `TLSv1_2` and `TLSv1_3`.
        """
        return pulumi.get(self, "min_protocol_version")

    @property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> Optional[str]:
        """
        The Name of the Policy e.g AppGwSslPolicy20170401S. Required if `policy_type` is set to `Predefined`. Possible values can change over time and are published here <https://docs.microsoft.com/azure/application-gateway/application-gateway-ssl-policy-overview>. Not compatible with `disabled_protocols`.
        """
        return pulumi.get(self, "policy_name")

    @property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> Optional[str]:
        """
        The Type of the Policy. Possible values are `Predefined`, `Custom` and `CustomV2`.

        > **NOTE:** `policy_type` is Required when `policy_name` is set - cannot be set if `disabled_protocols` is set.
        """
        return pulumi.get(self, "policy_type")


@pulumi.output_type
class ApplicationGatewayTrustedClientCertificate(dict):
    def __init__(__self__, *,
                 data: str,
                 name: str,
                 id: Optional[str] = None):
        """
        :param str data: The base-64 encoded certificate.
        :param str name: The name of the Trusted Client Certificate that is unique within this Application Gateway.
        :param str id: The ID of the Rewrite Rule Set
        """
        pulumi.set(__self__, "data", data)
        pulumi.set(__self__, "name", name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def data(self) -> str:
        """
        The base-64 encoded certificate.
        """
        return pulumi.get(self, "data")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Trusted Client Certificate that is unique within this Application Gateway.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Rewrite Rule Set
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ApplicationGatewayTrustedRootCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVaultSecretId":
            suggest = "key_vault_secret_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayTrustedRootCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayTrustedRootCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayTrustedRootCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 data: Optional[str] = None,
                 id: Optional[str] = None,
                 key_vault_secret_id: Optional[str] = None):
        """
        :param str name: The Name of the Trusted Root Certificate to use.
        :param str data: The contents of the Trusted Root Certificate which should be used. Required if `key_vault_secret_id` is not set.
        :param str id: The ID of the Rewrite Rule Set
        :param str key_vault_secret_id: The Secret ID of (base-64 encoded unencrypted pfx) `Secret` or `Certificate` object stored in Azure KeyVault. You need to enable soft delete for the Key Vault to use this feature. Required if `data` is not set.
               
               > **NOTE:** TLS termination with Key Vault certificates is limited to the [v2 SKUs](https://docs.microsoft.com/azure/application-gateway/key-vault-certs).
               
               > **NOTE:** For TLS termination with Key Vault certificates to work properly existing user-assigned managed identity, which Application Gateway uses to retrieve certificates from Key Vault, should be defined via `identity` block. Additionally, access policies in the Key Vault to allow the identity to be granted *get* access to the secret should be defined.
        """
        pulumi.set(__self__, "name", name)
        if data is not None:
            pulumi.set(__self__, "data", data)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if key_vault_secret_id is not None:
            pulumi.set(__self__, "key_vault_secret_id", key_vault_secret_id)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Name of the Trusted Root Certificate to use.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def data(self) -> Optional[str]:
        """
        The contents of the Trusted Root Certificate which should be used. Required if `key_vault_secret_id` is not set.
        """
        return pulumi.get(self, "data")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Rewrite Rule Set
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="keyVaultSecretId")
    def key_vault_secret_id(self) -> Optional[str]:
        """
        The Secret ID of (base-64 encoded unencrypted pfx) `Secret` or `Certificate` object stored in Azure KeyVault. You need to enable soft delete for the Key Vault to use this feature. Required if `data` is not set.

        > **NOTE:** TLS termination with Key Vault certificates is limited to the [v2 SKUs](https://docs.microsoft.com/azure/application-gateway/key-vault-certs).

        > **NOTE:** For TLS termination with Key Vault certificates to work properly existing user-assigned managed identity, which Application Gateway uses to retrieve certificates from Key Vault, should be defined via `identity` block. Additionally, access policies in the Key Vault to allow the identity to be granted *get* access to the secret should be defined.
        """
        return pulumi.get(self, "key_vault_secret_id")


@pulumi.output_type
class ApplicationGatewayUrlPathMap(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pathRules":
            suggest = "path_rules"
        elif key == "defaultBackendAddressPoolId":
            suggest = "default_backend_address_pool_id"
        elif key == "defaultBackendAddressPoolName":
            suggest = "default_backend_address_pool_name"
        elif key == "defaultBackendHttpSettingsId":
            suggest = "default_backend_http_settings_id"
        elif key == "defaultBackendHttpSettingsName":
            suggest = "default_backend_http_settings_name"
        elif key == "defaultRedirectConfigurationId":
            suggest = "default_redirect_configuration_id"
        elif key == "defaultRedirectConfigurationName":
            suggest = "default_redirect_configuration_name"
        elif key == "defaultRewriteRuleSetId":
            suggest = "default_rewrite_rule_set_id"
        elif key == "defaultRewriteRuleSetName":
            suggest = "default_rewrite_rule_set_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayUrlPathMap. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayUrlPathMap.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayUrlPathMap.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 path_rules: Sequence['outputs.ApplicationGatewayUrlPathMapPathRule'],
                 default_backend_address_pool_id: Optional[str] = None,
                 default_backend_address_pool_name: Optional[str] = None,
                 default_backend_http_settings_id: Optional[str] = None,
                 default_backend_http_settings_name: Optional[str] = None,
                 default_redirect_configuration_id: Optional[str] = None,
                 default_redirect_configuration_name: Optional[str] = None,
                 default_rewrite_rule_set_id: Optional[str] = None,
                 default_rewrite_rule_set_name: Optional[str] = None,
                 id: Optional[str] = None):
        """
        :param str name: The Name of the URL Path Map.
        :param Sequence['ApplicationGatewayUrlPathMapPathRuleArgs'] path_rules: One or more `path_rule` blocks as defined above.
        :param str default_backend_address_pool_id: The ID of the Default Backend Address Pool.
        :param str default_backend_address_pool_name: The Name of the Default Backend Address Pool which should be used for this URL Path Map. Cannot be set if `default_redirect_configuration_name` is set.
        :param str default_backend_http_settings_id: The ID of the Default Backend HTTP Settings Collection.
        :param str default_backend_http_settings_name: The Name of the Default Backend HTTP Settings Collection which should be used for this URL Path Map. Cannot be set if `default_redirect_configuration_name` is set.
        :param str default_redirect_configuration_id: The ID of the Default Redirect Configuration.
        :param str default_redirect_configuration_name: The Name of the Default Redirect Configuration which should be used for this URL Path Map. Cannot be set if either `default_backend_address_pool_name` or `default_backend_http_settings_name` is set.
               
               > **NOTE:** Both `default_backend_address_pool_name` and `default_backend_http_settings_name` or `default_redirect_configuration_name` should be specified.
        :param str default_rewrite_rule_set_name: The Name of the Default Rewrite Rule Set which should be used for this URL Path Map. Only valid for v2 SKUs.
        :param str id: The ID of the Rewrite Rule Set
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path_rules", path_rules)
        if default_backend_address_pool_id is not None:
            pulumi.set(__self__, "default_backend_address_pool_id", default_backend_address_pool_id)
        if default_backend_address_pool_name is not None:
            pulumi.set(__self__, "default_backend_address_pool_name", default_backend_address_pool_name)
        if default_backend_http_settings_id is not None:
            pulumi.set(__self__, "default_backend_http_settings_id", default_backend_http_settings_id)
        if default_backend_http_settings_name is not None:
            pulumi.set(__self__, "default_backend_http_settings_name", default_backend_http_settings_name)
        if default_redirect_configuration_id is not None:
            pulumi.set(__self__, "default_redirect_configuration_id", default_redirect_configuration_id)
        if default_redirect_configuration_name is not None:
            pulumi.set(__self__, "default_redirect_configuration_name", default_redirect_configuration_name)
        if default_rewrite_rule_set_id is not None:
            pulumi.set(__self__, "default_rewrite_rule_set_id", default_rewrite_rule_set_id)
        if default_rewrite_rule_set_name is not None:
            pulumi.set(__self__, "default_rewrite_rule_set_name", default_rewrite_rule_set_name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Name of the URL Path Map.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="pathRules")
    def path_rules(self) -> Sequence['outputs.ApplicationGatewayUrlPathMapPathRule']:
        """
        One or more `path_rule` blocks as defined above.
        """
        return pulumi.get(self, "path_rules")

    @property
    @pulumi.getter(name="defaultBackendAddressPoolId")
    def default_backend_address_pool_id(self) -> Optional[str]:
        """
        The ID of the Default Backend Address Pool.
        """
        return pulumi.get(self, "default_backend_address_pool_id")

    @property
    @pulumi.getter(name="defaultBackendAddressPoolName")
    def default_backend_address_pool_name(self) -> Optional[str]:
        """
        The Name of the Default Backend Address Pool which should be used for this URL Path Map. Cannot be set if `default_redirect_configuration_name` is set.
        """
        return pulumi.get(self, "default_backend_address_pool_name")

    @property
    @pulumi.getter(name="defaultBackendHttpSettingsId")
    def default_backend_http_settings_id(self) -> Optional[str]:
        """
        The ID of the Default Backend HTTP Settings Collection.
        """
        return pulumi.get(self, "default_backend_http_settings_id")

    @property
    @pulumi.getter(name="defaultBackendHttpSettingsName")
    def default_backend_http_settings_name(self) -> Optional[str]:
        """
        The Name of the Default Backend HTTP Settings Collection which should be used for this URL Path Map. Cannot be set if `default_redirect_configuration_name` is set.
        """
        return pulumi.get(self, "default_backend_http_settings_name")

    @property
    @pulumi.getter(name="defaultRedirectConfigurationId")
    def default_redirect_configuration_id(self) -> Optional[str]:
        """
        The ID of the Default Redirect Configuration.
        """
        return pulumi.get(self, "default_redirect_configuration_id")

    @property
    @pulumi.getter(name="defaultRedirectConfigurationName")
    def default_redirect_configuration_name(self) -> Optional[str]:
        """
        The Name of the Default Redirect Configuration which should be used for this URL Path Map. Cannot be set if either `default_backend_address_pool_name` or `default_backend_http_settings_name` is set.

        > **NOTE:** Both `default_backend_address_pool_name` and `default_backend_http_settings_name` or `default_redirect_configuration_name` should be specified.
        """
        return pulumi.get(self, "default_redirect_configuration_name")

    @property
    @pulumi.getter(name="defaultRewriteRuleSetId")
    def default_rewrite_rule_set_id(self) -> Optional[str]:
        return pulumi.get(self, "default_rewrite_rule_set_id")

    @property
    @pulumi.getter(name="defaultRewriteRuleSetName")
    def default_rewrite_rule_set_name(self) -> Optional[str]:
        """
        The Name of the Default Rewrite Rule Set which should be used for this URL Path Map. Only valid for v2 SKUs.
        """
        return pulumi.get(self, "default_rewrite_rule_set_name")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Rewrite Rule Set
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ApplicationGatewayUrlPathMapPathRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendAddressPoolId":
            suggest = "backend_address_pool_id"
        elif key == "backendAddressPoolName":
            suggest = "backend_address_pool_name"
        elif key == "backendHttpSettingsId":
            suggest = "backend_http_settings_id"
        elif key == "backendHttpSettingsName":
            suggest = "backend_http_settings_name"
        elif key == "firewallPolicyId":
            suggest = "firewall_policy_id"
        elif key == "redirectConfigurationId":
            suggest = "redirect_configuration_id"
        elif key == "redirectConfigurationName":
            suggest = "redirect_configuration_name"
        elif key == "rewriteRuleSetId":
            suggest = "rewrite_rule_set_id"
        elif key == "rewriteRuleSetName":
            suggest = "rewrite_rule_set_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayUrlPathMapPathRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayUrlPathMapPathRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayUrlPathMapPathRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 paths: Sequence[str],
                 backend_address_pool_id: Optional[str] = None,
                 backend_address_pool_name: Optional[str] = None,
                 backend_http_settings_id: Optional[str] = None,
                 backend_http_settings_name: Optional[str] = None,
                 firewall_policy_id: Optional[str] = None,
                 id: Optional[str] = None,
                 redirect_configuration_id: Optional[str] = None,
                 redirect_configuration_name: Optional[str] = None,
                 rewrite_rule_set_id: Optional[str] = None,
                 rewrite_rule_set_name: Optional[str] = None):
        """
        :param str name: The Name of the Path Rule.
        :param Sequence[str] paths: A list of Paths used in this Path Rule.
        :param str backend_address_pool_id: The ID of the associated Backend Address Pool.
        :param str backend_address_pool_name: The Name of the Backend Address Pool to use for this Path Rule. Cannot be set if `redirect_configuration_name` is set.
        :param str backend_http_settings_id: The ID of the associated Backend HTTP Settings Configuration.
        :param str backend_http_settings_name: The Name of the Backend HTTP Settings Collection to use for this Path Rule. Cannot be set if `redirect_configuration_name` is set.
        :param str firewall_policy_id: The ID of the Web Application Firewall Policy which should be used as a HTTP Listener.
        :param str id: The ID of the Rewrite Rule Set
        :param str redirect_configuration_id: The ID of the associated Redirect Configuration.
        :param str redirect_configuration_name: The Name of a Redirect Configuration to use for this Path Rule. Cannot be set if `backend_address_pool_name` or `backend_http_settings_name` is set.
        :param str rewrite_rule_set_id: The ID of the associated Rewrite Rule Set.
        :param str rewrite_rule_set_name: The Name of the Rewrite Rule Set which should be used for this URL Path Map. Only valid for v2 SKUs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "paths", paths)
        if backend_address_pool_id is not None:
            pulumi.set(__self__, "backend_address_pool_id", backend_address_pool_id)
        if backend_address_pool_name is not None:
            pulumi.set(__self__, "backend_address_pool_name", backend_address_pool_name)
        if backend_http_settings_id is not None:
            pulumi.set(__self__, "backend_http_settings_id", backend_http_settings_id)
        if backend_http_settings_name is not None:
            pulumi.set(__self__, "backend_http_settings_name", backend_http_settings_name)
        if firewall_policy_id is not None:
            pulumi.set(__self__, "firewall_policy_id", firewall_policy_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if redirect_configuration_id is not None:
            pulumi.set(__self__, "redirect_configuration_id", redirect_configuration_id)
        if redirect_configuration_name is not None:
            pulumi.set(__self__, "redirect_configuration_name", redirect_configuration_name)
        if rewrite_rule_set_id is not None:
            pulumi.set(__self__, "rewrite_rule_set_id", rewrite_rule_set_id)
        if rewrite_rule_set_name is not None:
            pulumi.set(__self__, "rewrite_rule_set_name", rewrite_rule_set_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Name of the Path Rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def paths(self) -> Sequence[str]:
        """
        A list of Paths used in this Path Rule.
        """
        return pulumi.get(self, "paths")

    @property
    @pulumi.getter(name="backendAddressPoolId")
    def backend_address_pool_id(self) -> Optional[str]:
        """
        The ID of the associated Backend Address Pool.
        """
        return pulumi.get(self, "backend_address_pool_id")

    @property
    @pulumi.getter(name="backendAddressPoolName")
    def backend_address_pool_name(self) -> Optional[str]:
        """
        The Name of the Backend Address Pool to use for this Path Rule. Cannot be set if `redirect_configuration_name` is set.
        """
        return pulumi.get(self, "backend_address_pool_name")

    @property
    @pulumi.getter(name="backendHttpSettingsId")
    def backend_http_settings_id(self) -> Optional[str]:
        """
        The ID of the associated Backend HTTP Settings Configuration.
        """
        return pulumi.get(self, "backend_http_settings_id")

    @property
    @pulumi.getter(name="backendHttpSettingsName")
    def backend_http_settings_name(self) -> Optional[str]:
        """
        The Name of the Backend HTTP Settings Collection to use for this Path Rule. Cannot be set if `redirect_configuration_name` is set.
        """
        return pulumi.get(self, "backend_http_settings_name")

    @property
    @pulumi.getter(name="firewallPolicyId")
    def firewall_policy_id(self) -> Optional[str]:
        """
        The ID of the Web Application Firewall Policy which should be used as a HTTP Listener.
        """
        return pulumi.get(self, "firewall_policy_id")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the Rewrite Rule Set
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="redirectConfigurationId")
    def redirect_configuration_id(self) -> Optional[str]:
        """
        The ID of the associated Redirect Configuration.
        """
        return pulumi.get(self, "redirect_configuration_id")

    @property
    @pulumi.getter(name="redirectConfigurationName")
    def redirect_configuration_name(self) -> Optional[str]:
        """
        The Name of a Redirect Configuration to use for this Path Rule. Cannot be set if `backend_address_pool_name` or `backend_http_settings_name` is set.
        """
        return pulumi.get(self, "redirect_configuration_name")

    @property
    @pulumi.getter(name="rewriteRuleSetId")
    def rewrite_rule_set_id(self) -> Optional[str]:
        """
        The ID of the associated Rewrite Rule Set.
        """
        return pulumi.get(self, "rewrite_rule_set_id")

    @property
    @pulumi.getter(name="rewriteRuleSetName")
    def rewrite_rule_set_name(self) -> Optional[str]:
        """
        The Name of the Rewrite Rule Set which should be used for this URL Path Map. Only valid for v2 SKUs.
        """
        return pulumi.get(self, "rewrite_rule_set_name")


@pulumi.output_type
class ApplicationGatewayWafConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "firewallMode":
            suggest = "firewall_mode"
        elif key == "ruleSetVersion":
            suggest = "rule_set_version"
        elif key == "disabledRuleGroups":
            suggest = "disabled_rule_groups"
        elif key == "fileUploadLimitMb":
            suggest = "file_upload_limit_mb"
        elif key == "maxRequestBodySizeKb":
            suggest = "max_request_body_size_kb"
        elif key == "requestBodyCheck":
            suggest = "request_body_check"
        elif key == "ruleSetType":
            suggest = "rule_set_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayWafConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayWafConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayWafConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 firewall_mode: str,
                 rule_set_version: str,
                 disabled_rule_groups: Optional[Sequence['outputs.ApplicationGatewayWafConfigurationDisabledRuleGroup']] = None,
                 exclusions: Optional[Sequence['outputs.ApplicationGatewayWafConfigurationExclusion']] = None,
                 file_upload_limit_mb: Optional[int] = None,
                 max_request_body_size_kb: Optional[int] = None,
                 request_body_check: Optional[bool] = None,
                 rule_set_type: Optional[str] = None):
        """
        :param bool enabled: Is the Web Application Firewall enabled?
        :param str firewall_mode: The Web Application Firewall Mode. Possible values are `Detection` and `Prevention`.
        :param str rule_set_version: The Version of the Rule Set used for this Web Application Firewall. Possible values are `0.1`, `1.0`, `2.2.9`, `3.0`, `3.1` and `3.2`.
        :param Sequence['ApplicationGatewayWafConfigurationDisabledRuleGroupArgs'] disabled_rule_groups: one or more `disabled_rule_group` blocks as defined below.
        :param Sequence['ApplicationGatewayWafConfigurationExclusionArgs'] exclusions: one or more `exclusion` blocks as defined below.
        :param int file_upload_limit_mb: The File Upload Limit in MB. Accepted values are in the range `1`MB to `750`MB for the `WAF_v2` SKU, and `1`MB to `500`MB for all other SKUs. Defaults to `100`MB.
        :param int max_request_body_size_kb: The Maximum Request Body Size in KB. Accepted values are in the range `1`KB to `128`KB. Defaults to `128`KB.
        :param bool request_body_check: Is Request Body Inspection enabled? Defaults to `true`.
        :param str rule_set_type: The Type of the Rule Set used for this Web Application Firewall. Possible values are `OWASP` and `Microsoft_BotManagerRuleSet`.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "firewall_mode", firewall_mode)
        pulumi.set(__self__, "rule_set_version", rule_set_version)
        if disabled_rule_groups is not None:
            pulumi.set(__self__, "disabled_rule_groups", disabled_rule_groups)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if file_upload_limit_mb is not None:
            pulumi.set(__self__, "file_upload_limit_mb", file_upload_limit_mb)
        if max_request_body_size_kb is not None:
            pulumi.set(__self__, "max_request_body_size_kb", max_request_body_size_kb)
        if request_body_check is not None:
            pulumi.set(__self__, "request_body_check", request_body_check)
        if rule_set_type is not None:
            pulumi.set(__self__, "rule_set_type", rule_set_type)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is the Web Application Firewall enabled?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="firewallMode")
    def firewall_mode(self) -> str:
        """
        The Web Application Firewall Mode. Possible values are `Detection` and `Prevention`.
        """
        return pulumi.get(self, "firewall_mode")

    @property
    @pulumi.getter(name="ruleSetVersion")
    def rule_set_version(self) -> str:
        """
        The Version of the Rule Set used for this Web Application Firewall. Possible values are `0.1`, `1.0`, `2.2.9`, `3.0`, `3.1` and `3.2`.
        """
        return pulumi.get(self, "rule_set_version")

    @property
    @pulumi.getter(name="disabledRuleGroups")
    def disabled_rule_groups(self) -> Optional[Sequence['outputs.ApplicationGatewayWafConfigurationDisabledRuleGroup']]:
        """
        one or more `disabled_rule_group` blocks as defined below.
        """
        return pulumi.get(self, "disabled_rule_groups")

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence['outputs.ApplicationGatewayWafConfigurationExclusion']]:
        """
        one or more `exclusion` blocks as defined below.
        """
        return pulumi.get(self, "exclusions")

    @property
    @pulumi.getter(name="fileUploadLimitMb")
    def file_upload_limit_mb(self) -> Optional[int]:
        """
        The File Upload Limit in MB. Accepted values are in the range `1`MB to `750`MB for the `WAF_v2` SKU, and `1`MB to `500`MB for all other SKUs. Defaults to `100`MB.
        """
        return pulumi.get(self, "file_upload_limit_mb")

    @property
    @pulumi.getter(name="maxRequestBodySizeKb")
    def max_request_body_size_kb(self) -> Optional[int]:
        """
        The Maximum Request Body Size in KB. Accepted values are in the range `1`KB to `128`KB. Defaults to `128`KB.
        """
        return pulumi.get(self, "max_request_body_size_kb")

    @property
    @pulumi.getter(name="requestBodyCheck")
    def request_body_check(self) -> Optional[bool]:
        """
        Is Request Body Inspection enabled? Defaults to `true`.
        """
        return pulumi.get(self, "request_body_check")

    @property
    @pulumi.getter(name="ruleSetType")
    def rule_set_type(self) -> Optional[str]:
        """
        The Type of the Rule Set used for this Web Application Firewall. Possible values are `OWASP` and `Microsoft_BotManagerRuleSet`.
        """
        return pulumi.get(self, "rule_set_type")


@pulumi.output_type
class ApplicationGatewayWafConfigurationDisabledRuleGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleGroupName":
            suggest = "rule_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayWafConfigurationDisabledRuleGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayWafConfigurationDisabledRuleGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayWafConfigurationDisabledRuleGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rule_group_name: str,
                 rules: Optional[Sequence[int]] = None):
        """
        :param str rule_group_name: The rule group where specific rules should be disabled. Possible values are `BadBots`, `crs_20_protocol_violations`, `crs_21_protocol_anomalies`, `crs_23_request_limits`, `crs_30_http_policy`, `crs_35_bad_robots`, `crs_40_generic_attacks`, `crs_41_sql_injection_attacks`, `crs_41_xss_attacks`, `crs_42_tight_security`, `crs_45_trojans`, `General`, `GoodBots`, `Known-CVEs`, `REQUEST-911-METHOD-ENFORCEMENT`, `REQUEST-913-SCANNER-DETECTION`, `REQUEST-920-PROTOCOL-ENFORCEMENT`, `REQUEST-921-PROTOCOL-ATTACK`, `REQUEST-930-APPLICATION-ATTACK-LFI`, `REQUEST-931-APPLICATION-ATTACK-RFI`, `REQUEST-932-APPLICATION-ATTACK-RCE`, `REQUEST-933-APPLICATION-ATTACK-PHP`, `REQUEST-941-APPLICATION-ATTACK-XSS`, `REQUEST-942-APPLICATION-ATTACK-SQLI`, `REQUEST-943-APPLICATION-ATTACK-SESSION-FIXATION`, `REQUEST-944-APPLICATION-ATTACK-JAVA` and `UnknownBots`.
        :param Sequence[int] rules: A list of rules which should be disabled in that group. Disables all rules in the specified group if `rules` is not specified.
        """
        pulumi.set(__self__, "rule_group_name", rule_group_name)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter(name="ruleGroupName")
    def rule_group_name(self) -> str:
        """
        The rule group where specific rules should be disabled. Possible values are `BadBots`, `crs_20_protocol_violations`, `crs_21_protocol_anomalies`, `crs_23_request_limits`, `crs_30_http_policy`, `crs_35_bad_robots`, `crs_40_generic_attacks`, `crs_41_sql_injection_attacks`, `crs_41_xss_attacks`, `crs_42_tight_security`, `crs_45_trojans`, `General`, `GoodBots`, `Known-CVEs`, `REQUEST-911-METHOD-ENFORCEMENT`, `REQUEST-913-SCANNER-DETECTION`, `REQUEST-920-PROTOCOL-ENFORCEMENT`, `REQUEST-921-PROTOCOL-ATTACK`, `REQUEST-930-APPLICATION-ATTACK-LFI`, `REQUEST-931-APPLICATION-ATTACK-RFI`, `REQUEST-932-APPLICATION-ATTACK-RCE`, `REQUEST-933-APPLICATION-ATTACK-PHP`, `REQUEST-941-APPLICATION-ATTACK-XSS`, `REQUEST-942-APPLICATION-ATTACK-SQLI`, `REQUEST-943-APPLICATION-ATTACK-SESSION-FIXATION`, `REQUEST-944-APPLICATION-ATTACK-JAVA` and `UnknownBots`.
        """
        return pulumi.get(self, "rule_group_name")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence[int]]:
        """
        A list of rules which should be disabled in that group. Disables all rules in the specified group if `rules` is not specified.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class ApplicationGatewayWafConfigurationExclusion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchVariable":
            suggest = "match_variable"
        elif key == "selectorMatchOperator":
            suggest = "selector_match_operator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayWafConfigurationExclusion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayWafConfigurationExclusion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayWafConfigurationExclusion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_variable: str,
                 selector: Optional[str] = None,
                 selector_match_operator: Optional[str] = None):
        """
        :param str match_variable: Match variable of the exclusion rule to exclude header, cookie or GET arguments. Possible values are `RequestArgKeys`, `RequestArgNames`, `RequestArgValues`, `RequestCookieKeys`, `RequestCookieNames`, `RequestCookieValues`, `RequestHeaderKeys`, `RequestHeaderNames` and `RequestHeaderValues`
        :param str selector: String value which will be used for the filter operation. If empty will exclude all traffic on this `match_variable`
        :param str selector_match_operator: Operator which will be used to search in the variable content. Possible values are `Contains`, `EndsWith`, `Equals`, `EqualsAny` and `StartsWith`. If empty will exclude all traffic on this `match_variable`
        """
        pulumi.set(__self__, "match_variable", match_variable)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if selector_match_operator is not None:
            pulumi.set(__self__, "selector_match_operator", selector_match_operator)

    @property
    @pulumi.getter(name="matchVariable")
    def match_variable(self) -> str:
        """
        Match variable of the exclusion rule to exclude header, cookie or GET arguments. Possible values are `RequestArgKeys`, `RequestArgNames`, `RequestArgValues`, `RequestCookieKeys`, `RequestCookieNames`, `RequestCookieValues`, `RequestHeaderKeys`, `RequestHeaderNames` and `RequestHeaderValues`
        """
        return pulumi.get(self, "match_variable")

    @property
    @pulumi.getter
    def selector(self) -> Optional[str]:
        """
        String value which will be used for the filter operation. If empty will exclude all traffic on this `match_variable`
        """
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter(name="selectorMatchOperator")
    def selector_match_operator(self) -> Optional[str]:
        """
        Operator which will be used to search in the variable content. Possible values are `Contains`, `EndsWith`, `Equals`, `EqualsAny` and `StartsWith`. If empty will exclude all traffic on this `match_variable`
        """
        return pulumi.get(self, "selector_match_operator")


@pulumi.output_type
class ExpressRouteCircuitPeeringIpv6(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "primaryPeerAddressPrefix":
            suggest = "primary_peer_address_prefix"
        elif key == "secondaryPeerAddressPrefix":
            suggest = "secondary_peer_address_prefix"
        elif key == "microsoftPeering":
            suggest = "microsoft_peering"
        elif key == "routeFilterId":
            suggest = "route_filter_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExpressRouteCircuitPeeringIpv6. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExpressRouteCircuitPeeringIpv6.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExpressRouteCircuitPeeringIpv6.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 primary_peer_address_prefix: str,
                 secondary_peer_address_prefix: str,
                 enabled: Optional[bool] = None,
                 microsoft_peering: Optional['outputs.ExpressRouteCircuitPeeringIpv6MicrosoftPeering'] = None,
                 route_filter_id: Optional[str] = None):
        """
        :param str primary_peer_address_prefix: A subnet for the primary link.
        :param str secondary_peer_address_prefix: A subnet for the secondary link.
        :param bool enabled: A boolean value indicating whether the IPv6 peering is enabled. Defaults to `true`.
        :param 'ExpressRouteCircuitPeeringIpv6MicrosoftPeeringArgs' microsoft_peering: A `microsoft_peering` block as defined below.
        :param str route_filter_id: The ID of the Route Filter. Only available when `peering_type` is set to `MicrosoftPeering`.
               
               > **NOTE:** `ipv6` can be specified when `peering_type` is `MicrosoftPeering` or `AzurePrivatePeering`
        """
        pulumi.set(__self__, "primary_peer_address_prefix", primary_peer_address_prefix)
        pulumi.set(__self__, "secondary_peer_address_prefix", secondary_peer_address_prefix)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if microsoft_peering is not None:
            pulumi.set(__self__, "microsoft_peering", microsoft_peering)
        if route_filter_id is not None:
            pulumi.set(__self__, "route_filter_id", route_filter_id)

    @property
    @pulumi.getter(name="primaryPeerAddressPrefix")
    def primary_peer_address_prefix(self) -> str:
        """
        A subnet for the primary link.
        """
        return pulumi.get(self, "primary_peer_address_prefix")

    @property
    @pulumi.getter(name="secondaryPeerAddressPrefix")
    def secondary_peer_address_prefix(self) -> str:
        """
        A subnet for the secondary link.
        """
        return pulumi.get(self, "secondary_peer_address_prefix")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        A boolean value indicating whether the IPv6 peering is enabled. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="microsoftPeering")
    def microsoft_peering(self) -> Optional['outputs.ExpressRouteCircuitPeeringIpv6MicrosoftPeering']:
        """
        A `microsoft_peering` block as defined below.
        """
        return pulumi.get(self, "microsoft_peering")

    @property
    @pulumi.getter(name="routeFilterId")
    def route_filter_id(self) -> Optional[str]:
        """
        The ID of the Route Filter. Only available when `peering_type` is set to `MicrosoftPeering`.

        > **NOTE:** `ipv6` can be specified when `peering_type` is `MicrosoftPeering` or `AzurePrivatePeering`
        """
        return pulumi.get(self, "route_filter_id")


@pulumi.output_type
class ExpressRouteCircuitPeeringIpv6MicrosoftPeering(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "advertisedCommunities":
            suggest = "advertised_communities"
        elif key == "advertisedPublicPrefixes":
            suggest = "advertised_public_prefixes"
        elif key == "customerAsn":
            suggest = "customer_asn"
        elif key == "routingRegistryName":
            suggest = "routing_registry_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExpressRouteCircuitPeeringIpv6MicrosoftPeering. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExpressRouteCircuitPeeringIpv6MicrosoftPeering.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExpressRouteCircuitPeeringIpv6MicrosoftPeering.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 advertised_communities: Optional[Sequence[str]] = None,
                 advertised_public_prefixes: Optional[Sequence[str]] = None,
                 customer_asn: Optional[int] = None,
                 routing_registry_name: Optional[str] = None):
        """
        :param Sequence[str] advertised_communities: The communities of Bgp Peering specified for microsoft peering.
        :param Sequence[str] advertised_public_prefixes: A list of Advertised Public Prefixes.
        :param int customer_asn: The CustomerASN of the peering. Defaults to `0`.
        :param str routing_registry_name: The Routing Registry against which the AS number and prefixes are registered. For example: `ARIN`, `RIPE`, `AFRINIC` etc. Defaults to `NONE`.
        """
        if advertised_communities is not None:
            pulumi.set(__self__, "advertised_communities", advertised_communities)
        if advertised_public_prefixes is not None:
            pulumi.set(__self__, "advertised_public_prefixes", advertised_public_prefixes)
        if customer_asn is not None:
            pulumi.set(__self__, "customer_asn", customer_asn)
        if routing_registry_name is not None:
            pulumi.set(__self__, "routing_registry_name", routing_registry_name)

    @property
    @pulumi.getter(name="advertisedCommunities")
    def advertised_communities(self) -> Optional[Sequence[str]]:
        """
        The communities of Bgp Peering specified for microsoft peering.
        """
        return pulumi.get(self, "advertised_communities")

    @property
    @pulumi.getter(name="advertisedPublicPrefixes")
    def advertised_public_prefixes(self) -> Optional[Sequence[str]]:
        """
        A list of Advertised Public Prefixes.
        """
        return pulumi.get(self, "advertised_public_prefixes")

    @property
    @pulumi.getter(name="customerAsn")
    def customer_asn(self) -> Optional[int]:
        """
        The CustomerASN of the peering. Defaults to `0`.
        """
        return pulumi.get(self, "customer_asn")

    @property
    @pulumi.getter(name="routingRegistryName")
    def routing_registry_name(self) -> Optional[str]:
        """
        The Routing Registry against which the AS number and prefixes are registered. For example: `ARIN`, `RIPE`, `AFRINIC` etc. Defaults to `NONE`.
        """
        return pulumi.get(self, "routing_registry_name")


@pulumi.output_type
class ExpressRouteCircuitPeeringMicrosoftPeeringConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "advertisedPublicPrefixes":
            suggest = "advertised_public_prefixes"
        elif key == "advertisedCommunities":
            suggest = "advertised_communities"
        elif key == "customerAsn":
            suggest = "customer_asn"
        elif key == "routingRegistryName":
            suggest = "routing_registry_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExpressRouteCircuitPeeringMicrosoftPeeringConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExpressRouteCircuitPeeringMicrosoftPeeringConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExpressRouteCircuitPeeringMicrosoftPeeringConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 advertised_public_prefixes: Sequence[str],
                 advertised_communities: Optional[Sequence[str]] = None,
                 customer_asn: Optional[int] = None,
                 routing_registry_name: Optional[str] = None):
        """
        :param Sequence[str] advertised_public_prefixes: A list of Advertised Public Prefixes.
        :param Sequence[str] advertised_communities: The communities of Bgp Peering specified for microsoft peering.
        :param int customer_asn: The CustomerASN of the peering. Defaults to `0`.
        :param str routing_registry_name: The Routing Registry against which the AS number and prefixes are registered. For example: `ARIN`, `RIPE`, `AFRINIC` etc. Defaults to `NONE`.
        """
        pulumi.set(__self__, "advertised_public_prefixes", advertised_public_prefixes)
        if advertised_communities is not None:
            pulumi.set(__self__, "advertised_communities", advertised_communities)
        if customer_asn is not None:
            pulumi.set(__self__, "customer_asn", customer_asn)
        if routing_registry_name is not None:
            pulumi.set(__self__, "routing_registry_name", routing_registry_name)

    @property
    @pulumi.getter(name="advertisedPublicPrefixes")
    def advertised_public_prefixes(self) -> Sequence[str]:
        """
        A list of Advertised Public Prefixes.
        """
        return pulumi.get(self, "advertised_public_prefixes")

    @property
    @pulumi.getter(name="advertisedCommunities")
    def advertised_communities(self) -> Optional[Sequence[str]]:
        """
        The communities of Bgp Peering specified for microsoft peering.
        """
        return pulumi.get(self, "advertised_communities")

    @property
    @pulumi.getter(name="customerAsn")
    def customer_asn(self) -> Optional[int]:
        """
        The CustomerASN of the peering. Defaults to `0`.
        """
        return pulumi.get(self, "customer_asn")

    @property
    @pulumi.getter(name="routingRegistryName")
    def routing_registry_name(self) -> Optional[str]:
        """
        The Routing Registry against which the AS number and prefixes are registered. For example: `ARIN`, `RIPE`, `AFRINIC` etc. Defaults to `NONE`.
        """
        return pulumi.get(self, "routing_registry_name")


@pulumi.output_type
class ExpressRouteCircuitSku(dict):
    def __init__(__self__, *,
                 family: str,
                 tier: str):
        """
        :param str family: The billing mode for bandwidth. Possible values are `MeteredData` or `UnlimitedData`.
               
               > **NOTE:** You can migrate from `MeteredData` to `UnlimitedData`, but not the other way around.
        :param str tier: The service tier. Possible values are `Basic`, `Local`, `Standard` or `Premium`.
        """
        pulumi.set(__self__, "family", family)
        pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter
    def family(self) -> str:
        """
        The billing mode for bandwidth. Possible values are `MeteredData` or `UnlimitedData`.

        > **NOTE:** You can migrate from `MeteredData` to `UnlimitedData`, but not the other way around.
        """
        return pulumi.get(self, "family")

    @property
    @pulumi.getter
    def tier(self) -> str:
        """
        The service tier. Possible values are `Basic`, `Local`, `Standard` or `Premium`.
        """
        return pulumi.get(self, "tier")


@pulumi.output_type
class ExpressRouteConnectionRouting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "associatedRouteTableId":
            suggest = "associated_route_table_id"
        elif key == "inboundRouteMapId":
            suggest = "inbound_route_map_id"
        elif key == "outboundRouteMapId":
            suggest = "outbound_route_map_id"
        elif key == "propagatedRouteTable":
            suggest = "propagated_route_table"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExpressRouteConnectionRouting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExpressRouteConnectionRouting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExpressRouteConnectionRouting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 associated_route_table_id: Optional[str] = None,
                 inbound_route_map_id: Optional[str] = None,
                 outbound_route_map_id: Optional[str] = None,
                 propagated_route_table: Optional['outputs.ExpressRouteConnectionRoutingPropagatedRouteTable'] = None):
        """
        :param str associated_route_table_id: The ID of the Virtual Hub Route Table associated with this Express Route Connection.
        :param str inbound_route_map_id: The ID of the Route Map associated with this Express Route Connection for inbound routes.
        :param str outbound_route_map_id: The ID of the Route Map associated with this Express Route Connection for outbound routes.
        :param 'ExpressRouteConnectionRoutingPropagatedRouteTableArgs' propagated_route_table: A `propagated_route_table` block as defined below.
        """
        if associated_route_table_id is not None:
            pulumi.set(__self__, "associated_route_table_id", associated_route_table_id)
        if inbound_route_map_id is not None:
            pulumi.set(__self__, "inbound_route_map_id", inbound_route_map_id)
        if outbound_route_map_id is not None:
            pulumi.set(__self__, "outbound_route_map_id", outbound_route_map_id)
        if propagated_route_table is not None:
            pulumi.set(__self__, "propagated_route_table", propagated_route_table)

    @property
    @pulumi.getter(name="associatedRouteTableId")
    def associated_route_table_id(self) -> Optional[str]:
        """
        The ID of the Virtual Hub Route Table associated with this Express Route Connection.
        """
        return pulumi.get(self, "associated_route_table_id")

    @property
    @pulumi.getter(name="inboundRouteMapId")
    def inbound_route_map_id(self) -> Optional[str]:
        """
        The ID of the Route Map associated with this Express Route Connection for inbound routes.
        """
        return pulumi.get(self, "inbound_route_map_id")

    @property
    @pulumi.getter(name="outboundRouteMapId")
    def outbound_route_map_id(self) -> Optional[str]:
        """
        The ID of the Route Map associated with this Express Route Connection for outbound routes.
        """
        return pulumi.get(self, "outbound_route_map_id")

    @property
    @pulumi.getter(name="propagatedRouteTable")
    def propagated_route_table(self) -> Optional['outputs.ExpressRouteConnectionRoutingPropagatedRouteTable']:
        """
        A `propagated_route_table` block as defined below.
        """
        return pulumi.get(self, "propagated_route_table")


@pulumi.output_type
class ExpressRouteConnectionRoutingPropagatedRouteTable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "routeTableIds":
            suggest = "route_table_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExpressRouteConnectionRoutingPropagatedRouteTable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExpressRouteConnectionRoutingPropagatedRouteTable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExpressRouteConnectionRoutingPropagatedRouteTable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 labels: Optional[Sequence[str]] = None,
                 route_table_ids: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] labels: The list of labels to logically group route tables.
        :param Sequence[str] route_table_ids: A list of IDs of the Virtual Hub Route Table to propagate routes from Express Route Connection to the route table.
        """
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if route_table_ids is not None:
            pulumi.set(__self__, "route_table_ids", route_table_ids)

    @property
    @pulumi.getter
    def labels(self) -> Optional[Sequence[str]]:
        """
        The list of labels to logically group route tables.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="routeTableIds")
    def route_table_ids(self) -> Optional[Sequence[str]]:
        """
        A list of IDs of the Virtual Hub Route Table to propagate routes from Express Route Connection to the route table.
        """
        return pulumi.get(self, "route_table_ids")


@pulumi.output_type
class ExpressRoutePortIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExpressRoutePortIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExpressRoutePortIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExpressRoutePortIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_ids: Sequence[str],
                 type: str):
        """
        :param Sequence[str] identity_ids: Specifies a list of User Assigned Managed Identity IDs to be assigned to this Express Route Port.
        :param str type: Specifies the type of Managed Service Identity that should be configured on this Express Route Port. Only possible value is `UserAssigned`.
        """
        pulumi.set(__self__, "identity_ids", identity_ids)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Sequence[str]:
        """
        Specifies a list of User Assigned Managed Identity IDs to be assigned to this Express Route Port.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the type of Managed Service Identity that should be configured on this Express Route Port. Only possible value is `UserAssigned`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ExpressRoutePortLink1(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminEnabled":
            suggest = "admin_enabled"
        elif key == "connectorType":
            suggest = "connector_type"
        elif key == "interfaceName":
            suggest = "interface_name"
        elif key == "macsecCakKeyvaultSecretId":
            suggest = "macsec_cak_keyvault_secret_id"
        elif key == "macsecCipher":
            suggest = "macsec_cipher"
        elif key == "macsecCknKeyvaultSecretId":
            suggest = "macsec_ckn_keyvault_secret_id"
        elif key == "patchPanelId":
            suggest = "patch_panel_id"
        elif key == "rackId":
            suggest = "rack_id"
        elif key == "routerName":
            suggest = "router_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExpressRoutePortLink1. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExpressRoutePortLink1.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExpressRoutePortLink1.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_enabled: Optional[bool] = None,
                 connector_type: Optional[str] = None,
                 id: Optional[str] = None,
                 interface_name: Optional[str] = None,
                 macsec_cak_keyvault_secret_id: Optional[str] = None,
                 macsec_cipher: Optional[str] = None,
                 macsec_ckn_keyvault_secret_id: Optional[str] = None,
                 patch_panel_id: Optional[str] = None,
                 rack_id: Optional[str] = None,
                 router_name: Optional[str] = None):
        """
        :param bool admin_enabled: Whether enable administration state on the Express Route Port Link? Defaults to `false`.
        :param str connector_type: The connector type of the Express Route Port Link.
        :param str id: The ID of this Express Route Port Link.
        :param str interface_name: The interface name of the Azure router associated with the Express Route Port Link.
        :param str macsec_cak_keyvault_secret_id: The ID of the Key Vault Secret that contains the Mac security CAK key for this Express Route Port Link.
               
               > **NOTE** `macsec_ckn_keyvault_secret_id` and `macsec_cak_keyvault_secret_id` should be used together with `identity`, so that the Express Route Port instance have the right permission to access the Key Vault.
        :param str macsec_cipher: The MACSec cipher used for this Express Route Port Link. Possible values are `GcmAes128` and `GcmAes256`. Defaults to `GcmAes128`.
        :param str macsec_ckn_keyvault_secret_id: The ID of the Key Vault Secret that contains the MACSec CKN key for this Express Route Port Link.
        :param str patch_panel_id: The ID that maps from the Express Route Port Link to the patch panel port.
        :param str rack_id: The ID that maps from the patch panel port to the rack.
        :param str router_name: The name of the Azure router associated with the Express Route Port Link.
        """
        if admin_enabled is not None:
            pulumi.set(__self__, "admin_enabled", admin_enabled)
        if connector_type is not None:
            pulumi.set(__self__, "connector_type", connector_type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if interface_name is not None:
            pulumi.set(__self__, "interface_name", interface_name)
        if macsec_cak_keyvault_secret_id is not None:
            pulumi.set(__self__, "macsec_cak_keyvault_secret_id", macsec_cak_keyvault_secret_id)
        if macsec_cipher is not None:
            pulumi.set(__self__, "macsec_cipher", macsec_cipher)
        if macsec_ckn_keyvault_secret_id is not None:
            pulumi.set(__self__, "macsec_ckn_keyvault_secret_id", macsec_ckn_keyvault_secret_id)
        if patch_panel_id is not None:
            pulumi.set(__self__, "patch_panel_id", patch_panel_id)
        if rack_id is not None:
            pulumi.set(__self__, "rack_id", rack_id)
        if router_name is not None:
            pulumi.set(__self__, "router_name", router_name)

    @property
    @pulumi.getter(name="adminEnabled")
    def admin_enabled(self) -> Optional[bool]:
        """
        Whether enable administration state on the Express Route Port Link? Defaults to `false`.
        """
        return pulumi.get(self, "admin_enabled")

    @property
    @pulumi.getter(name="connectorType")
    def connector_type(self) -> Optional[str]:
        """
        The connector type of the Express Route Port Link.
        """
        return pulumi.get(self, "connector_type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of this Express Route Port Link.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="interfaceName")
    def interface_name(self) -> Optional[str]:
        """
        The interface name of the Azure router associated with the Express Route Port Link.
        """
        return pulumi.get(self, "interface_name")

    @property
    @pulumi.getter(name="macsecCakKeyvaultSecretId")
    def macsec_cak_keyvault_secret_id(self) -> Optional[str]:
        """
        The ID of the Key Vault Secret that contains the Mac security CAK key for this Express Route Port Link.

        > **NOTE** `macsec_ckn_keyvault_secret_id` and `macsec_cak_keyvault_secret_id` should be used together with `identity`, so that the Express Route Port instance have the right permission to access the Key Vault.
        """
        return pulumi.get(self, "macsec_cak_keyvault_secret_id")

    @property
    @pulumi.getter(name="macsecCipher")
    def macsec_cipher(self) -> Optional[str]:
        """
        The MACSec cipher used for this Express Route Port Link. Possible values are `GcmAes128` and `GcmAes256`. Defaults to `GcmAes128`.
        """
        return pulumi.get(self, "macsec_cipher")

    @property
    @pulumi.getter(name="macsecCknKeyvaultSecretId")
    def macsec_ckn_keyvault_secret_id(self) -> Optional[str]:
        """
        The ID of the Key Vault Secret that contains the MACSec CKN key for this Express Route Port Link.
        """
        return pulumi.get(self, "macsec_ckn_keyvault_secret_id")

    @property
    @pulumi.getter(name="patchPanelId")
    def patch_panel_id(self) -> Optional[str]:
        """
        The ID that maps from the Express Route Port Link to the patch panel port.
        """
        return pulumi.get(self, "patch_panel_id")

    @property
    @pulumi.getter(name="rackId")
    def rack_id(self) -> Optional[str]:
        """
        The ID that maps from the patch panel port to the rack.
        """
        return pulumi.get(self, "rack_id")

    @property
    @pulumi.getter(name="routerName")
    def router_name(self) -> Optional[str]:
        """
        The name of the Azure router associated with the Express Route Port Link.
        """
        return pulumi.get(self, "router_name")


@pulumi.output_type
class ExpressRoutePortLink2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminEnabled":
            suggest = "admin_enabled"
        elif key == "connectorType":
            suggest = "connector_type"
        elif key == "interfaceName":
            suggest = "interface_name"
        elif key == "macsecCakKeyvaultSecretId":
            suggest = "macsec_cak_keyvault_secret_id"
        elif key == "macsecCipher":
            suggest = "macsec_cipher"
        elif key == "macsecCknKeyvaultSecretId":
            suggest = "macsec_ckn_keyvault_secret_id"
        elif key == "patchPanelId":
            suggest = "patch_panel_id"
        elif key == "rackId":
            suggest = "rack_id"
        elif key == "routerName":
            suggest = "router_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExpressRoutePortLink2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExpressRoutePortLink2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExpressRoutePortLink2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_enabled: Optional[bool] = None,
                 connector_type: Optional[str] = None,
                 id: Optional[str] = None,
                 interface_name: Optional[str] = None,
                 macsec_cak_keyvault_secret_id: Optional[str] = None,
                 macsec_cipher: Optional[str] = None,
                 macsec_ckn_keyvault_secret_id: Optional[str] = None,
                 patch_panel_id: Optional[str] = None,
                 rack_id: Optional[str] = None,
                 router_name: Optional[str] = None):
        """
        :param bool admin_enabled: Whether enable administration state on the Express Route Port Link? Defaults to `false`.
        :param str connector_type: The connector type of the Express Route Port Link.
        :param str id: The ID of this Express Route Port Link.
        :param str interface_name: The interface name of the Azure router associated with the Express Route Port Link.
        :param str macsec_cak_keyvault_secret_id: The ID of the Key Vault Secret that contains the Mac security CAK key for this Express Route Port Link.
               
               > **NOTE** `macsec_ckn_keyvault_secret_id` and `macsec_cak_keyvault_secret_id` should be used together with `identity`, so that the Express Route Port instance have the right permission to access the Key Vault.
        :param str macsec_cipher: The MACSec cipher used for this Express Route Port Link. Possible values are `GcmAes128` and `GcmAes256`. Defaults to `GcmAes128`.
        :param str macsec_ckn_keyvault_secret_id: The ID of the Key Vault Secret that contains the MACSec CKN key for this Express Route Port Link.
        :param str patch_panel_id: The ID that maps from the Express Route Port Link to the patch panel port.
        :param str rack_id: The ID that maps from the patch panel port to the rack.
        :param str router_name: The name of the Azure router associated with the Express Route Port Link.
        """
        if admin_enabled is not None:
            pulumi.set(__self__, "admin_enabled", admin_enabled)
        if connector_type is not None:
            pulumi.set(__self__, "connector_type", connector_type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if interface_name is not None:
            pulumi.set(__self__, "interface_name", interface_name)
        if macsec_cak_keyvault_secret_id is not None:
            pulumi.set(__self__, "macsec_cak_keyvault_secret_id", macsec_cak_keyvault_secret_id)
        if macsec_cipher is not None:
            pulumi.set(__self__, "macsec_cipher", macsec_cipher)
        if macsec_ckn_keyvault_secret_id is not None:
            pulumi.set(__self__, "macsec_ckn_keyvault_secret_id", macsec_ckn_keyvault_secret_id)
        if patch_panel_id is not None:
            pulumi.set(__self__, "patch_panel_id", patch_panel_id)
        if rack_id is not None:
            pulumi.set(__self__, "rack_id", rack_id)
        if router_name is not None:
            pulumi.set(__self__, "router_name", router_name)

    @property
    @pulumi.getter(name="adminEnabled")
    def admin_enabled(self) -> Optional[bool]:
        """
        Whether enable administration state on the Express Route Port Link? Defaults to `false`.
        """
        return pulumi.get(self, "admin_enabled")

    @property
    @pulumi.getter(name="connectorType")
    def connector_type(self) -> Optional[str]:
        """
        The connector type of the Express Route Port Link.
        """
        return pulumi.get(self, "connector_type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of this Express Route Port Link.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="interfaceName")
    def interface_name(self) -> Optional[str]:
        """
        The interface name of the Azure router associated with the Express Route Port Link.
        """
        return pulumi.get(self, "interface_name")

    @property
    @pulumi.getter(name="macsecCakKeyvaultSecretId")
    def macsec_cak_keyvault_secret_id(self) -> Optional[str]:
        """
        The ID of the Key Vault Secret that contains the Mac security CAK key for this Express Route Port Link.

        > **NOTE** `macsec_ckn_keyvault_secret_id` and `macsec_cak_keyvault_secret_id` should be used together with `identity`, so that the Express Route Port instance have the right permission to access the Key Vault.
        """
        return pulumi.get(self, "macsec_cak_keyvault_secret_id")

    @property
    @pulumi.getter(name="macsecCipher")
    def macsec_cipher(self) -> Optional[str]:
        """
        The MACSec cipher used for this Express Route Port Link. Possible values are `GcmAes128` and `GcmAes256`. Defaults to `GcmAes128`.
        """
        return pulumi.get(self, "macsec_cipher")

    @property
    @pulumi.getter(name="macsecCknKeyvaultSecretId")
    def macsec_ckn_keyvault_secret_id(self) -> Optional[str]:
        """
        The ID of the Key Vault Secret that contains the MACSec CKN key for this Express Route Port Link.
        """
        return pulumi.get(self, "macsec_ckn_keyvault_secret_id")

    @property
    @pulumi.getter(name="patchPanelId")
    def patch_panel_id(self) -> Optional[str]:
        """
        The ID that maps from the Express Route Port Link to the patch panel port.
        """
        return pulumi.get(self, "patch_panel_id")

    @property
    @pulumi.getter(name="rackId")
    def rack_id(self) -> Optional[str]:
        """
        The ID that maps from the patch panel port to the rack.
        """
        return pulumi.get(self, "rack_id")

    @property
    @pulumi.getter(name="routerName")
    def router_name(self) -> Optional[str]:
        """
        The name of the Azure router associated with the Express Route Port Link.
        """
        return pulumi.get(self, "router_name")


@pulumi.output_type
class FirewallApplicationRuleCollectionRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fqdnTags":
            suggest = "fqdn_tags"
        elif key == "sourceAddresses":
            suggest = "source_addresses"
        elif key == "sourceIpGroups":
            suggest = "source_ip_groups"
        elif key == "targetFqdns":
            suggest = "target_fqdns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallApplicationRuleCollectionRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallApplicationRuleCollectionRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallApplicationRuleCollectionRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 description: Optional[str] = None,
                 fqdn_tags: Optional[Sequence[str]] = None,
                 protocols: Optional[Sequence['outputs.FirewallApplicationRuleCollectionRuleProtocol']] = None,
                 source_addresses: Optional[Sequence[str]] = None,
                 source_ip_groups: Optional[Sequence[str]] = None,
                 target_fqdns: Optional[Sequence[str]] = None):
        """
        :param str name: Specifies the name of the rule.
        :param str description: Specifies a description for the rule.
        :param Sequence[str] fqdn_tags: A list of FQDN tags. Possible values are `AppServiceEnvironment`, `AzureBackup`, `AzureKubernetesService`, `HDInsight`, `MicrosoftActiveProtectionService`, `WindowsDiagnostics`, `WindowsUpdate` and `WindowsVirtualDesktop`.
        :param Sequence['FirewallApplicationRuleCollectionRuleProtocolArgs'] protocols: One or more `protocol` blocks as defined below.
        :param Sequence[str] source_addresses: A list of source IP addresses and/or IP ranges.
        :param Sequence[str] source_ip_groups: A list of source IP Group IDs for the rule.
               
               > **NOTE** At least one of `source_addresses` and `source_ip_groups` must be specified for a rule.
        :param Sequence[str] target_fqdns: A list of FQDNs.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if fqdn_tags is not None:
            pulumi.set(__self__, "fqdn_tags", fqdn_tags)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_ip_groups is not None:
            pulumi.set(__self__, "source_ip_groups", source_ip_groups)
        if target_fqdns is not None:
            pulumi.set(__self__, "target_fqdns", target_fqdns)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Specifies a description for the rule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="fqdnTags")
    def fqdn_tags(self) -> Optional[Sequence[str]]:
        """
        A list of FQDN tags. Possible values are `AppServiceEnvironment`, `AzureBackup`, `AzureKubernetesService`, `HDInsight`, `MicrosoftActiveProtectionService`, `WindowsDiagnostics`, `WindowsUpdate` and `WindowsVirtualDesktop`.
        """
        return pulumi.get(self, "fqdn_tags")

    @property
    @pulumi.getter
    def protocols(self) -> Optional[Sequence['outputs.FirewallApplicationRuleCollectionRuleProtocol']]:
        """
        One or more `protocol` blocks as defined below.
        """
        return pulumi.get(self, "protocols")

    @property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[str]]:
        """
        A list of source IP addresses and/or IP ranges.
        """
        return pulumi.get(self, "source_addresses")

    @property
    @pulumi.getter(name="sourceIpGroups")
    def source_ip_groups(self) -> Optional[Sequence[str]]:
        """
        A list of source IP Group IDs for the rule.

        > **NOTE** At least one of `source_addresses` and `source_ip_groups` must be specified for a rule.
        """
        return pulumi.get(self, "source_ip_groups")

    @property
    @pulumi.getter(name="targetFqdns")
    def target_fqdns(self) -> Optional[Sequence[str]]:
        """
        A list of FQDNs.
        """
        return pulumi.get(self, "target_fqdns")


@pulumi.output_type
class FirewallApplicationRuleCollectionRuleProtocol(dict):
    def __init__(__self__, *,
                 port: int,
                 type: str):
        """
        :param int port: Specify a port for the connection.
        :param str type: Specifies the type of connection. Possible values are `Http`, `Https` and `Mssql`.
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Specify a port for the connection.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the type of connection. Possible values are `Http`, `Https` and `Mssql`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class FirewallIpConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateIpAddress":
            suggest = "private_ip_address"
        elif key == "publicIpAddressId":
            suggest = "public_ip_address_id"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallIpConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallIpConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallIpConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 private_ip_address: Optional[str] = None,
                 public_ip_address_id: Optional[str] = None,
                 subnet_id: Optional[str] = None):
        """
        :param str name: Specifies the name of the IP Configuration.
        :param str private_ip_address: The private IP address associated with the Firewall.
        :param str subnet_id: Reference to the subnet associated with the IP Configuration. Changing this forces a new resource to be created.
               
               > **NOTE** The Subnet used for the Firewall must have the name `AzureFirewallSubnet` and the subnet mask must be at least a `/26`.
               
               > **NOTE** At least one and only one `ip_configuration` block may contain a `subnet_id`.
        """
        pulumi.set(__self__, "name", name)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)
        if public_ip_address_id is not None:
            pulumi.set(__self__, "public_ip_address_id", public_ip_address_id)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the IP Configuration.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> Optional[str]:
        """
        The private IP address associated with the Firewall.
        """
        return pulumi.get(self, "private_ip_address")

    @property
    @pulumi.getter(name="publicIpAddressId")
    def public_ip_address_id(self) -> Optional[str]:
        return pulumi.get(self, "public_ip_address_id")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        Reference to the subnet associated with the IP Configuration. Changing this forces a new resource to be created.

        > **NOTE** The Subnet used for the Firewall must have the name `AzureFirewallSubnet` and the subnet mask must be at least a `/26`.

        > **NOTE** At least one and only one `ip_configuration` block may contain a `subnet_id`.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class FirewallManagementIpConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicIpAddressId":
            suggest = "public_ip_address_id"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "privateIpAddress":
            suggest = "private_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallManagementIpConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallManagementIpConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallManagementIpConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 public_ip_address_id: str,
                 subnet_id: str,
                 private_ip_address: Optional[str] = None):
        """
        :param str name: Specifies the name of the IP Configuration.
        :param str public_ip_address_id: The ID of the Public IP Address associated with the firewall.
               
               > **NOTE** The Public IP must have a `Static` allocation and `Standard` SKU.
        :param str subnet_id: Reference to the subnet associated with the IP Configuration. Changing this forces a new resource to be created.
               
               > **NOTE** The Management Subnet used for the Firewall must have the name `AzureFirewallManagementSubnet` and the subnet mask must be at least a `/26`.
        :param str private_ip_address: The private IP address associated with the Firewall.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "public_ip_address_id", public_ip_address_id)
        pulumi.set(__self__, "subnet_id", subnet_id)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the IP Configuration.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="publicIpAddressId")
    def public_ip_address_id(self) -> str:
        """
        The ID of the Public IP Address associated with the firewall.

        > **NOTE** The Public IP must have a `Static` allocation and `Standard` SKU.
        """
        return pulumi.get(self, "public_ip_address_id")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        Reference to the subnet associated with the IP Configuration. Changing this forces a new resource to be created.

        > **NOTE** The Management Subnet used for the Firewall must have the name `AzureFirewallManagementSubnet` and the subnet mask must be at least a `/26`.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> Optional[str]:
        """
        The private IP address associated with the Firewall.
        """
        return pulumi.get(self, "private_ip_address")


@pulumi.output_type
class FirewallNatRuleCollectionRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationAddresses":
            suggest = "destination_addresses"
        elif key == "destinationPorts":
            suggest = "destination_ports"
        elif key == "translatedAddress":
            suggest = "translated_address"
        elif key == "translatedPort":
            suggest = "translated_port"
        elif key == "sourceAddresses":
            suggest = "source_addresses"
        elif key == "sourceIpGroups":
            suggest = "source_ip_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallNatRuleCollectionRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallNatRuleCollectionRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallNatRuleCollectionRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_addresses: Sequence[str],
                 destination_ports: Sequence[str],
                 name: str,
                 protocols: Sequence[str],
                 translated_address: str,
                 translated_port: str,
                 description: Optional[str] = None,
                 source_addresses: Optional[Sequence[str]] = None,
                 source_ip_groups: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] destination_addresses: A list of destination IP addresses and/or IP ranges.
        :param Sequence[str] destination_ports: A list of destination ports.
        :param str name: Specifies the name of the rule.
        :param Sequence[str] protocols: A list of protocols. Possible values are `Any`, `ICMP`, `TCP` and `UDP`. If `action` is `Dnat`, protocols can only be `TCP` and `UDP`.
        :param str translated_address: The address of the service behind the Firewall.
        :param str translated_port: The port of the service behind the Firewall.
        :param str description: Specifies a description for the rule.
        :param Sequence[str] source_addresses: A list of source IP addresses and/or IP ranges.
        :param Sequence[str] source_ip_groups: A list of source IP Group IDs for the rule.
               
               > **NOTE** At least one of `source_addresses` and `source_ip_groups` must be specified for a rule.
        """
        pulumi.set(__self__, "destination_addresses", destination_addresses)
        pulumi.set(__self__, "destination_ports", destination_ports)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "protocols", protocols)
        pulumi.set(__self__, "translated_address", translated_address)
        pulumi.set(__self__, "translated_port", translated_port)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_ip_groups is not None:
            pulumi.set(__self__, "source_ip_groups", source_ip_groups)

    @property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Sequence[str]:
        """
        A list of destination IP addresses and/or IP ranges.
        """
        return pulumi.get(self, "destination_addresses")

    @property
    @pulumi.getter(name="destinationPorts")
    def destination_ports(self) -> Sequence[str]:
        """
        A list of destination ports.
        """
        return pulumi.get(self, "destination_ports")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def protocols(self) -> Sequence[str]:
        """
        A list of protocols. Possible values are `Any`, `ICMP`, `TCP` and `UDP`. If `action` is `Dnat`, protocols can only be `TCP` and `UDP`.
        """
        return pulumi.get(self, "protocols")

    @property
    @pulumi.getter(name="translatedAddress")
    def translated_address(self) -> str:
        """
        The address of the service behind the Firewall.
        """
        return pulumi.get(self, "translated_address")

    @property
    @pulumi.getter(name="translatedPort")
    def translated_port(self) -> str:
        """
        The port of the service behind the Firewall.
        """
        return pulumi.get(self, "translated_port")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Specifies a description for the rule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[str]]:
        """
        A list of source IP addresses and/or IP ranges.
        """
        return pulumi.get(self, "source_addresses")

    @property
    @pulumi.getter(name="sourceIpGroups")
    def source_ip_groups(self) -> Optional[Sequence[str]]:
        """
        A list of source IP Group IDs for the rule.

        > **NOTE** At least one of `source_addresses` and `source_ip_groups` must be specified for a rule.
        """
        return pulumi.get(self, "source_ip_groups")


@pulumi.output_type
class FirewallNetworkRuleCollectionRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationPorts":
            suggest = "destination_ports"
        elif key == "destinationAddresses":
            suggest = "destination_addresses"
        elif key == "destinationFqdns":
            suggest = "destination_fqdns"
        elif key == "destinationIpGroups":
            suggest = "destination_ip_groups"
        elif key == "sourceAddresses":
            suggest = "source_addresses"
        elif key == "sourceIpGroups":
            suggest = "source_ip_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallNetworkRuleCollectionRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallNetworkRuleCollectionRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallNetworkRuleCollectionRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_ports: Sequence[str],
                 name: str,
                 protocols: Sequence[str],
                 description: Optional[str] = None,
                 destination_addresses: Optional[Sequence[str]] = None,
                 destination_fqdns: Optional[Sequence[str]] = None,
                 destination_ip_groups: Optional[Sequence[str]] = None,
                 source_addresses: Optional[Sequence[str]] = None,
                 source_ip_groups: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] destination_ports: A list of destination ports.
        :param str name: Specifies the name of the rule.
        :param Sequence[str] protocols: A list of protocols. Possible values are `Any`, `ICMP`, `TCP` and `UDP`.
        :param str description: Specifies a description for the rule.
        :param Sequence[str] destination_addresses: Either a list of destination IP addresses and/or IP ranges, or a list of destination [Service Tags](https://docs.microsoft.com/azure/virtual-network/service-tags-overview#available-service-tags).
        :param Sequence[str] destination_fqdns: A list of destination FQDNS for the rule.
               
               > **NOTE** [You must enable DNS Proxy to use FQDNs in your network rules](https://docs.microsoft.com/azure/firewall/fqdn-filtering-network-rules).
               
               > **NOTE** At least one of `destination_addresses`, `destination_ip_groups` and `destination_fqdns` must be specified for a rule.
        :param Sequence[str] destination_ip_groups: A list of destination IP Group IDs for the rule.
        :param Sequence[str] source_addresses: A list of source IP addresses and/or IP ranges.
        :param Sequence[str] source_ip_groups: A list of IP Group IDs for the rule.
               
               > **NOTE** At least one of `source_addresses` and `source_ip_groups` must be specified for a rule.
        """
        pulumi.set(__self__, "destination_ports", destination_ports)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "protocols", protocols)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if destination_fqdns is not None:
            pulumi.set(__self__, "destination_fqdns", destination_fqdns)
        if destination_ip_groups is not None:
            pulumi.set(__self__, "destination_ip_groups", destination_ip_groups)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_ip_groups is not None:
            pulumi.set(__self__, "source_ip_groups", source_ip_groups)

    @property
    @pulumi.getter(name="destinationPorts")
    def destination_ports(self) -> Sequence[str]:
        """
        A list of destination ports.
        """
        return pulumi.get(self, "destination_ports")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def protocols(self) -> Sequence[str]:
        """
        A list of protocols. Possible values are `Any`, `ICMP`, `TCP` and `UDP`.
        """
        return pulumi.get(self, "protocols")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Specifies a description for the rule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[Sequence[str]]:
        """
        Either a list of destination IP addresses and/or IP ranges, or a list of destination [Service Tags](https://docs.microsoft.com/azure/virtual-network/service-tags-overview#available-service-tags).
        """
        return pulumi.get(self, "destination_addresses")

    @property
    @pulumi.getter(name="destinationFqdns")
    def destination_fqdns(self) -> Optional[Sequence[str]]:
        """
        A list of destination FQDNS for the rule.

        > **NOTE** [You must enable DNS Proxy to use FQDNs in your network rules](https://docs.microsoft.com/azure/firewall/fqdn-filtering-network-rules).

        > **NOTE** At least one of `destination_addresses`, `destination_ip_groups` and `destination_fqdns` must be specified for a rule.
        """
        return pulumi.get(self, "destination_fqdns")

    @property
    @pulumi.getter(name="destinationIpGroups")
    def destination_ip_groups(self) -> Optional[Sequence[str]]:
        """
        A list of destination IP Group IDs for the rule.
        """
        return pulumi.get(self, "destination_ip_groups")

    @property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[str]]:
        """
        A list of source IP addresses and/or IP ranges.
        """
        return pulumi.get(self, "source_addresses")

    @property
    @pulumi.getter(name="sourceIpGroups")
    def source_ip_groups(self) -> Optional[Sequence[str]]:
        """
        A list of IP Group IDs for the rule.

        > **NOTE** At least one of `source_addresses` and `source_ip_groups` must be specified for a rule.
        """
        return pulumi.get(self, "source_ip_groups")


@pulumi.output_type
class FirewallPolicyDns(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "proxyEnabled":
            suggest = "proxy_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyDns. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyDns.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyDns.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 proxy_enabled: Optional[bool] = None,
                 servers: Optional[Sequence[str]] = None):
        """
        :param bool proxy_enabled: Whether to enable DNS proxy on Firewalls attached to this Firewall Policy? Defaults to `false`.
        :param Sequence[str] servers: A list of custom DNS servers' IP addresses.
        """
        if proxy_enabled is not None:
            pulumi.set(__self__, "proxy_enabled", proxy_enabled)
        if servers is not None:
            pulumi.set(__self__, "servers", servers)

    @property
    @pulumi.getter(name="proxyEnabled")
    def proxy_enabled(self) -> Optional[bool]:
        """
        Whether to enable DNS proxy on Firewalls attached to this Firewall Policy? Defaults to `false`.
        """
        return pulumi.get(self, "proxy_enabled")

    @property
    @pulumi.getter
    def servers(self) -> Optional[Sequence[str]]:
        """
        A list of custom DNS servers' IP addresses.
        """
        return pulumi.get(self, "servers")


@pulumi.output_type
class FirewallPolicyExplicitProxy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enablePacFile":
            suggest = "enable_pac_file"
        elif key == "httpPort":
            suggest = "http_port"
        elif key == "httpsPort":
            suggest = "https_port"
        elif key == "pacFile":
            suggest = "pac_file"
        elif key == "pacFilePort":
            suggest = "pac_file_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyExplicitProxy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyExplicitProxy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyExplicitProxy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_pac_file: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 http_port: Optional[int] = None,
                 https_port: Optional[int] = None,
                 pac_file: Optional[str] = None,
                 pac_file_port: Optional[int] = None):
        """
        :param bool enable_pac_file: Whether the pac file port and url need to be provided.
        :param bool enabled: Whether the explicit proxy is enabled for this Firewall Policy.
        :param int http_port: The port number for explicit http protocol.
        :param int https_port: The port number for explicit proxy https protocol.
        :param str pac_file: Specifies a SAS URL for PAC file.
        :param int pac_file_port: Specifies a port number for firewall to serve PAC file.
        """
        if enable_pac_file is not None:
            pulumi.set(__self__, "enable_pac_file", enable_pac_file)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if http_port is not None:
            pulumi.set(__self__, "http_port", http_port)
        if https_port is not None:
            pulumi.set(__self__, "https_port", https_port)
        if pac_file is not None:
            pulumi.set(__self__, "pac_file", pac_file)
        if pac_file_port is not None:
            pulumi.set(__self__, "pac_file_port", pac_file_port)

    @property
    @pulumi.getter(name="enablePacFile")
    def enable_pac_file(self) -> Optional[bool]:
        """
        Whether the pac file port and url need to be provided.
        """
        return pulumi.get(self, "enable_pac_file")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether the explicit proxy is enabled for this Firewall Policy.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> Optional[int]:
        """
        The port number for explicit http protocol.
        """
        return pulumi.get(self, "http_port")

    @property
    @pulumi.getter(name="httpsPort")
    def https_port(self) -> Optional[int]:
        """
        The port number for explicit proxy https protocol.
        """
        return pulumi.get(self, "https_port")

    @property
    @pulumi.getter(name="pacFile")
    def pac_file(self) -> Optional[str]:
        """
        Specifies a SAS URL for PAC file.
        """
        return pulumi.get(self, "pac_file")

    @property
    @pulumi.getter(name="pacFilePort")
    def pac_file_port(self) -> Optional[int]:
        """
        Specifies a port number for firewall to serve PAC file.
        """
        return pulumi.get(self, "pac_file_port")


@pulumi.output_type
class FirewallPolicyIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 identity_ids: Optional[Sequence[str]] = None,
                 principal_id: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str type: Specifies the type of Managed Service Identity that should be configured on this Firewall Policy. Only possible value is `UserAssigned`.
        :param Sequence[str] identity_ids: Specifies a list of User Assigned Managed Identity IDs to be assigned to this Firewall Policy.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the type of Managed Service Identity that should be configured on this Firewall Policy. Only possible value is `UserAssigned`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of User Assigned Managed Identity IDs to be assigned to this Firewall Policy.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class FirewallPolicyInsights(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultLogAnalyticsWorkspaceId":
            suggest = "default_log_analytics_workspace_id"
        elif key == "logAnalyticsWorkspaces":
            suggest = "log_analytics_workspaces"
        elif key == "retentionInDays":
            suggest = "retention_in_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyInsights. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyInsights.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyInsights.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_log_analytics_workspace_id: str,
                 enabled: bool,
                 log_analytics_workspaces: Optional[Sequence['outputs.FirewallPolicyInsightsLogAnalyticsWorkspace']] = None,
                 retention_in_days: Optional[int] = None):
        """
        :param str default_log_analytics_workspace_id: The ID of the default Log Analytics Workspace that the Firewalls associated with this Firewall Policy will send their logs to, when there is no location matches in the `log_analytics_workspace`.
        :param bool enabled: Whether the insights functionality is enabled for this Firewall Policy.
        :param Sequence['FirewallPolicyInsightsLogAnalyticsWorkspaceArgs'] log_analytics_workspaces: A list of `log_analytics_workspace` block as defined below.
        :param int retention_in_days: The log retention period in days.
        """
        pulumi.set(__self__, "default_log_analytics_workspace_id", default_log_analytics_workspace_id)
        pulumi.set(__self__, "enabled", enabled)
        if log_analytics_workspaces is not None:
            pulumi.set(__self__, "log_analytics_workspaces", log_analytics_workspaces)
        if retention_in_days is not None:
            pulumi.set(__self__, "retention_in_days", retention_in_days)

    @property
    @pulumi.getter(name="defaultLogAnalyticsWorkspaceId")
    def default_log_analytics_workspace_id(self) -> str:
        """
        The ID of the default Log Analytics Workspace that the Firewalls associated with this Firewall Policy will send their logs to, when there is no location matches in the `log_analytics_workspace`.
        """
        return pulumi.get(self, "default_log_analytics_workspace_id")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether the insights functionality is enabled for this Firewall Policy.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="logAnalyticsWorkspaces")
    def log_analytics_workspaces(self) -> Optional[Sequence['outputs.FirewallPolicyInsightsLogAnalyticsWorkspace']]:
        """
        A list of `log_analytics_workspace` block as defined below.
        """
        return pulumi.get(self, "log_analytics_workspaces")

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> Optional[int]:
        """
        The log retention period in days.
        """
        return pulumi.get(self, "retention_in_days")


@pulumi.output_type
class FirewallPolicyInsightsLogAnalyticsWorkspace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "firewallLocation":
            suggest = "firewall_location"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyInsightsLogAnalyticsWorkspace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyInsightsLogAnalyticsWorkspace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyInsightsLogAnalyticsWorkspace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 firewall_location: str,
                 id: str):
        """
        :param str firewall_location: The location of the Firewalls, that when matches this Log Analytics Workspace will be used to consume their logs.
        :param str id: The ID of the Log Analytics Workspace that the Firewalls associated with this Firewall Policy will send their logs to when their locations match the `firewall_location`.
        """
        pulumi.set(__self__, "firewall_location", firewall_location)
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="firewallLocation")
    def firewall_location(self) -> str:
        """
        The location of the Firewalls, that when matches this Log Analytics Workspace will be used to consume their logs.
        """
        return pulumi.get(self, "firewall_location")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Log Analytics Workspace that the Firewalls associated with this Firewall Policy will send their logs to when their locations match the `firewall_location`.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class FirewallPolicyIntrusionDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateRanges":
            suggest = "private_ranges"
        elif key == "signatureOverrides":
            suggest = "signature_overrides"
        elif key == "trafficBypasses":
            suggest = "traffic_bypasses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyIntrusionDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyIntrusionDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyIntrusionDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: Optional[str] = None,
                 private_ranges: Optional[Sequence[str]] = None,
                 signature_overrides: Optional[Sequence['outputs.FirewallPolicyIntrusionDetectionSignatureOverride']] = None,
                 traffic_bypasses: Optional[Sequence['outputs.FirewallPolicyIntrusionDetectionTrafficBypass']] = None):
        """
        :param str mode: In which mode you want to run intrusion detection: `Off`, `Alert` or `Deny`.
        :param Sequence[str] private_ranges: A list of Private IP address ranges to identify traffic direction. By default, only ranges defined by IANA RFC 1918 are considered private IP addresses.
        :param Sequence['FirewallPolicyIntrusionDetectionSignatureOverrideArgs'] signature_overrides: One or more `signature_overrides` blocks as defined below.
        :param Sequence['FirewallPolicyIntrusionDetectionTrafficBypassArgs'] traffic_bypasses: One or more `traffic_bypass` blocks as defined below.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if private_ranges is not None:
            pulumi.set(__self__, "private_ranges", private_ranges)
        if signature_overrides is not None:
            pulumi.set(__self__, "signature_overrides", signature_overrides)
        if traffic_bypasses is not None:
            pulumi.set(__self__, "traffic_bypasses", traffic_bypasses)

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        In which mode you want to run intrusion detection: `Off`, `Alert` or `Deny`.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="privateRanges")
    def private_ranges(self) -> Optional[Sequence[str]]:
        """
        A list of Private IP address ranges to identify traffic direction. By default, only ranges defined by IANA RFC 1918 are considered private IP addresses.
        """
        return pulumi.get(self, "private_ranges")

    @property
    @pulumi.getter(name="signatureOverrides")
    def signature_overrides(self) -> Optional[Sequence['outputs.FirewallPolicyIntrusionDetectionSignatureOverride']]:
        """
        One or more `signature_overrides` blocks as defined below.
        """
        return pulumi.get(self, "signature_overrides")

    @property
    @pulumi.getter(name="trafficBypasses")
    def traffic_bypasses(self) -> Optional[Sequence['outputs.FirewallPolicyIntrusionDetectionTrafficBypass']]:
        """
        One or more `traffic_bypass` blocks as defined below.
        """
        return pulumi.get(self, "traffic_bypasses")


@pulumi.output_type
class FirewallPolicyIntrusionDetectionSignatureOverride(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 state: Optional[str] = None):
        """
        :param str id: 12-digit number (id) which identifies your signature.
        :param str state: state can be any of `Off`, `Alert` or `Deny`.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        12-digit number (id) which identifies your signature.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        state can be any of `Off`, `Alert` or `Deny`.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class FirewallPolicyIntrusionDetectionTrafficBypass(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationAddresses":
            suggest = "destination_addresses"
        elif key == "destinationIpGroups":
            suggest = "destination_ip_groups"
        elif key == "destinationPorts":
            suggest = "destination_ports"
        elif key == "sourceAddresses":
            suggest = "source_addresses"
        elif key == "sourceIpGroups":
            suggest = "source_ip_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyIntrusionDetectionTrafficBypass. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyIntrusionDetectionTrafficBypass.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyIntrusionDetectionTrafficBypass.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 protocol: str,
                 description: Optional[str] = None,
                 destination_addresses: Optional[Sequence[str]] = None,
                 destination_ip_groups: Optional[Sequence[str]] = None,
                 destination_ports: Optional[Sequence[str]] = None,
                 source_addresses: Optional[Sequence[str]] = None,
                 source_ip_groups: Optional[Sequence[str]] = None):
        """
        :param str name: The name which should be used for this bypass traffic setting.
        :param str protocol: The protocols any of `ANY`, `TCP`, `ICMP`, `UDP` that shall be bypassed by intrusion detection.
        :param str description: The description for this bypass traffic setting.
        :param Sequence[str] destination_addresses: Specifies a list of destination IP addresses that shall be bypassed by intrusion detection.
        :param Sequence[str] destination_ip_groups: Specifies a list of destination IP groups that shall be bypassed by intrusion detection.
        :param Sequence[str] destination_ports: Specifies a list of destination IP ports that shall be bypassed by intrusion detection.
        :param Sequence[str] source_addresses: Specifies a list of source addresses that shall be bypassed by intrusion detection.
        :param Sequence[str] source_ip_groups: Specifies a list of source IP groups that shall be bypassed by intrusion detection.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "protocol", protocol)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if destination_ip_groups is not None:
            pulumi.set(__self__, "destination_ip_groups", destination_ip_groups)
        if destination_ports is not None:
            pulumi.set(__self__, "destination_ports", destination_ports)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_ip_groups is not None:
            pulumi.set(__self__, "source_ip_groups", source_ip_groups)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this bypass traffic setting.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The protocols any of `ANY`, `TCP`, `ICMP`, `UDP` that shall be bypassed by intrusion detection.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description for this bypass traffic setting.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of destination IP addresses that shall be bypassed by intrusion detection.
        """
        return pulumi.get(self, "destination_addresses")

    @property
    @pulumi.getter(name="destinationIpGroups")
    def destination_ip_groups(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of destination IP groups that shall be bypassed by intrusion detection.
        """
        return pulumi.get(self, "destination_ip_groups")

    @property
    @pulumi.getter(name="destinationPorts")
    def destination_ports(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of destination IP ports that shall be bypassed by intrusion detection.
        """
        return pulumi.get(self, "destination_ports")

    @property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of source addresses that shall be bypassed by intrusion detection.
        """
        return pulumi.get(self, "source_addresses")

    @property
    @pulumi.getter(name="sourceIpGroups")
    def source_ip_groups(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of source IP groups that shall be bypassed by intrusion detection.
        """
        return pulumi.get(self, "source_ip_groups")


@pulumi.output_type
class FirewallPolicyRuleCollectionGroupApplicationRuleCollection(dict):
    def __init__(__self__, *,
                 action: str,
                 name: str,
                 priority: int,
                 rules: Sequence['outputs.FirewallPolicyRuleCollectionGroupApplicationRuleCollectionRule']):
        """
        :param str action: The action to take for the application rules in this collection. Possible values are `Allow` and `Deny`.
        :param str name: The name which should be used for this application rule collection.
        :param int priority: The priority of the application rule collection. The range is `100` - `65000`.
        :param Sequence['FirewallPolicyRuleCollectionGroupApplicationRuleCollectionRuleArgs'] rules: One or more `application_rule` (application rule) blocks as defined below.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action to take for the application rules in this collection. Possible values are `Allow` and `Deny`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this application rule collection.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        The priority of the application rule collection. The range is `100` - `65000`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.FirewallPolicyRuleCollectionGroupApplicationRuleCollectionRule']:
        """
        One or more `application_rule` (application rule) blocks as defined below.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class FirewallPolicyRuleCollectionGroupApplicationRuleCollectionRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationAddresses":
            suggest = "destination_addresses"
        elif key == "destinationFqdnTags":
            suggest = "destination_fqdn_tags"
        elif key == "destinationFqdns":
            suggest = "destination_fqdns"
        elif key == "destinationUrls":
            suggest = "destination_urls"
        elif key == "sourceAddresses":
            suggest = "source_addresses"
        elif key == "sourceIpGroups":
            suggest = "source_ip_groups"
        elif key == "terminateTls":
            suggest = "terminate_tls"
        elif key == "webCategories":
            suggest = "web_categories"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyRuleCollectionGroupApplicationRuleCollectionRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyRuleCollectionGroupApplicationRuleCollectionRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyRuleCollectionGroupApplicationRuleCollectionRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 description: Optional[str] = None,
                 destination_addresses: Optional[Sequence[str]] = None,
                 destination_fqdn_tags: Optional[Sequence[str]] = None,
                 destination_fqdns: Optional[Sequence[str]] = None,
                 destination_urls: Optional[Sequence[str]] = None,
                 protocols: Optional[Sequence['outputs.FirewallPolicyRuleCollectionGroupApplicationRuleCollectionRuleProtocol']] = None,
                 source_addresses: Optional[Sequence[str]] = None,
                 source_ip_groups: Optional[Sequence[str]] = None,
                 terminate_tls: Optional[bool] = None,
                 web_categories: Optional[Sequence[str]] = None):
        """
        :param str name: The name which should be used for this Firewall Policy Rule Collection Group. Changing this forces a new Firewall Policy Rule Collection Group to be created.
        :param str description: The description which should be used for this rule.
        :param Sequence[str] destination_addresses: Specifies a list of destination IP addresses (including CIDR, IP range and `*`).
        :param Sequence[str] destination_fqdn_tags: Specifies a list of destination FQDN tags.
        :param Sequence[str] destination_fqdns: Specifies a list of destination FQDNs. Conflicts with `destination_urls`.
        :param Sequence[str] destination_urls: Specifies a list of destination URLs for which policy should hold. Needs Premium SKU for Firewall Policy. Conflicts with `destination_fqdns`.
        :param Sequence['FirewallPolicyRuleCollectionGroupApplicationRuleCollectionRuleProtocolArgs'] protocols: One or more `protocols` blocks as defined below.
        :param Sequence[str] source_addresses: Specifies a list of source IP addresses (including CIDR, IP range and `*`).
        :param Sequence[str] source_ip_groups: Specifies a list of source IP groups.
        :param bool terminate_tls: Boolean specifying if TLS shall be terminated (true) or not (false). Must be `true` when using `destination_urls`. Needs Premium SKU for Firewall Policy.
        :param Sequence[str] web_categories: Specifies a list of web categories to which access is denied or allowed depending on the value of `action` above. Needs Premium SKU for Firewall Policy.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if destination_fqdn_tags is not None:
            pulumi.set(__self__, "destination_fqdn_tags", destination_fqdn_tags)
        if destination_fqdns is not None:
            pulumi.set(__self__, "destination_fqdns", destination_fqdns)
        if destination_urls is not None:
            pulumi.set(__self__, "destination_urls", destination_urls)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_ip_groups is not None:
            pulumi.set(__self__, "source_ip_groups", source_ip_groups)
        if terminate_tls is not None:
            pulumi.set(__self__, "terminate_tls", terminate_tls)
        if web_categories is not None:
            pulumi.set(__self__, "web_categories", web_categories)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Firewall Policy Rule Collection Group. Changing this forces a new Firewall Policy Rule Collection Group to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description which should be used for this rule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of destination IP addresses (including CIDR, IP range and `*`).
        """
        return pulumi.get(self, "destination_addresses")

    @property
    @pulumi.getter(name="destinationFqdnTags")
    def destination_fqdn_tags(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of destination FQDN tags.
        """
        return pulumi.get(self, "destination_fqdn_tags")

    @property
    @pulumi.getter(name="destinationFqdns")
    def destination_fqdns(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of destination FQDNs. Conflicts with `destination_urls`.
        """
        return pulumi.get(self, "destination_fqdns")

    @property
    @pulumi.getter(name="destinationUrls")
    def destination_urls(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of destination URLs for which policy should hold. Needs Premium SKU for Firewall Policy. Conflicts with `destination_fqdns`.
        """
        return pulumi.get(self, "destination_urls")

    @property
    @pulumi.getter
    def protocols(self) -> Optional[Sequence['outputs.FirewallPolicyRuleCollectionGroupApplicationRuleCollectionRuleProtocol']]:
        """
        One or more `protocols` blocks as defined below.
        """
        return pulumi.get(self, "protocols")

    @property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of source IP addresses (including CIDR, IP range and `*`).
        """
        return pulumi.get(self, "source_addresses")

    @property
    @pulumi.getter(name="sourceIpGroups")
    def source_ip_groups(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of source IP groups.
        """
        return pulumi.get(self, "source_ip_groups")

    @property
    @pulumi.getter(name="terminateTls")
    def terminate_tls(self) -> Optional[bool]:
        """
        Boolean specifying if TLS shall be terminated (true) or not (false). Must be `true` when using `destination_urls`. Needs Premium SKU for Firewall Policy.
        """
        return pulumi.get(self, "terminate_tls")

    @property
    @pulumi.getter(name="webCategories")
    def web_categories(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of web categories to which access is denied or allowed depending on the value of `action` above. Needs Premium SKU for Firewall Policy.
        """
        return pulumi.get(self, "web_categories")


@pulumi.output_type
class FirewallPolicyRuleCollectionGroupApplicationRuleCollectionRuleProtocol(dict):
    def __init__(__self__, *,
                 port: int,
                 type: str):
        """
        :param int port: Port number of the protocol. Range is 0-64000.
        :param str type: Protocol type. Possible values are `Http` and `Https`.
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Port number of the protocol. Range is 0-64000.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Protocol type. Possible values are `Http` and `Https`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class FirewallPolicyRuleCollectionGroupNatRuleCollection(dict):
    def __init__(__self__, *,
                 action: str,
                 name: str,
                 priority: int,
                 rules: Sequence['outputs.FirewallPolicyRuleCollectionGroupNatRuleCollectionRule']):
        """
        :param str action: The action to take for the NAT rules in this collection. Currently, the only possible value is `Dnat`.
        :param str name: The name which should be used for this NAT rule collection.
        :param int priority: The priority of the NAT rule collection. The range is `100` - `65000`.
        :param Sequence['FirewallPolicyRuleCollectionGroupNatRuleCollectionRuleArgs'] rules: A `nat_rule` (NAT rule) block as defined below.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action to take for the NAT rules in this collection. Currently, the only possible value is `Dnat`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this NAT rule collection.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        The priority of the NAT rule collection. The range is `100` - `65000`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.FirewallPolicyRuleCollectionGroupNatRuleCollectionRule']:
        """
        A `nat_rule` (NAT rule) block as defined below.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class FirewallPolicyRuleCollectionGroupNatRuleCollectionRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "translatedPort":
            suggest = "translated_port"
        elif key == "destinationAddress":
            suggest = "destination_address"
        elif key == "destinationPorts":
            suggest = "destination_ports"
        elif key == "sourceAddresses":
            suggest = "source_addresses"
        elif key == "sourceIpGroups":
            suggest = "source_ip_groups"
        elif key == "translatedAddress":
            suggest = "translated_address"
        elif key == "translatedFqdn":
            suggest = "translated_fqdn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyRuleCollectionGroupNatRuleCollectionRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyRuleCollectionGroupNatRuleCollectionRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyRuleCollectionGroupNatRuleCollectionRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 protocols: Sequence[str],
                 translated_port: int,
                 description: Optional[str] = None,
                 destination_address: Optional[str] = None,
                 destination_ports: Optional[str] = None,
                 source_addresses: Optional[Sequence[str]] = None,
                 source_ip_groups: Optional[Sequence[str]] = None,
                 translated_address: Optional[str] = None,
                 translated_fqdn: Optional[str] = None):
        """
        :param str name: The name which should be used for this Firewall Policy Rule Collection Group. Changing this forces a new Firewall Policy Rule Collection Group to be created.
        :param Sequence[str] protocols: One or more `protocols` blocks as defined below.
        :param int translated_port: Specifies the translated port.
        :param str description: The description which should be used for this rule.
        :param str destination_address: The destination IP address (including CIDR).
        :param str destination_ports: Specifies a list of destination ports.
        :param Sequence[str] source_addresses: Specifies a list of source IP addresses (including CIDR, IP range and `*`).
        :param Sequence[str] source_ip_groups: Specifies a list of source IP groups.
        :param str translated_address: Specifies the translated address.
        :param str translated_fqdn: Specifies the translated FQDN.
               
               > **NOTE:** Exactly one of `translated_address` and `translated_fqdn` should be set.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "protocols", protocols)
        pulumi.set(__self__, "translated_port", translated_port)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if destination_address is not None:
            pulumi.set(__self__, "destination_address", destination_address)
        if destination_ports is not None:
            pulumi.set(__self__, "destination_ports", destination_ports)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_ip_groups is not None:
            pulumi.set(__self__, "source_ip_groups", source_ip_groups)
        if translated_address is not None:
            pulumi.set(__self__, "translated_address", translated_address)
        if translated_fqdn is not None:
            pulumi.set(__self__, "translated_fqdn", translated_fqdn)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Firewall Policy Rule Collection Group. Changing this forces a new Firewall Policy Rule Collection Group to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def protocols(self) -> Sequence[str]:
        """
        One or more `protocols` blocks as defined below.
        """
        return pulumi.get(self, "protocols")

    @property
    @pulumi.getter(name="translatedPort")
    def translated_port(self) -> int:
        """
        Specifies the translated port.
        """
        return pulumi.get(self, "translated_port")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description which should be used for this rule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="destinationAddress")
    def destination_address(self) -> Optional[str]:
        """
        The destination IP address (including CIDR).
        """
        return pulumi.get(self, "destination_address")

    @property
    @pulumi.getter(name="destinationPorts")
    def destination_ports(self) -> Optional[str]:
        """
        Specifies a list of destination ports.
        """
        return pulumi.get(self, "destination_ports")

    @property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of source IP addresses (including CIDR, IP range and `*`).
        """
        return pulumi.get(self, "source_addresses")

    @property
    @pulumi.getter(name="sourceIpGroups")
    def source_ip_groups(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of source IP groups.
        """
        return pulumi.get(self, "source_ip_groups")

    @property
    @pulumi.getter(name="translatedAddress")
    def translated_address(self) -> Optional[str]:
        """
        Specifies the translated address.
        """
        return pulumi.get(self, "translated_address")

    @property
    @pulumi.getter(name="translatedFqdn")
    def translated_fqdn(self) -> Optional[str]:
        """
        Specifies the translated FQDN.

        > **NOTE:** Exactly one of `translated_address` and `translated_fqdn` should be set.
        """
        return pulumi.get(self, "translated_fqdn")


@pulumi.output_type
class FirewallPolicyRuleCollectionGroupNetworkRuleCollection(dict):
    def __init__(__self__, *,
                 action: str,
                 name: str,
                 priority: int,
                 rules: Sequence['outputs.FirewallPolicyRuleCollectionGroupNetworkRuleCollectionRule']):
        """
        :param str action: The action to take for the network rules in this collection. Possible values are `Allow` and `Deny`.
        :param str name: The name which should be used for this network rule collection.
        :param int priority: The priority of the network rule collection. The range is `100` - `65000`.
        :param Sequence['FirewallPolicyRuleCollectionGroupNetworkRuleCollectionRuleArgs'] rules: One or more `network_rule` (network rule) blocks as defined below.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action to take for the network rules in this collection. Possible values are `Allow` and `Deny`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this network rule collection.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        The priority of the network rule collection. The range is `100` - `65000`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.FirewallPolicyRuleCollectionGroupNetworkRuleCollectionRule']:
        """
        One or more `network_rule` (network rule) blocks as defined below.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class FirewallPolicyRuleCollectionGroupNetworkRuleCollectionRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationPorts":
            suggest = "destination_ports"
        elif key == "destinationAddresses":
            suggest = "destination_addresses"
        elif key == "destinationFqdns":
            suggest = "destination_fqdns"
        elif key == "destinationIpGroups":
            suggest = "destination_ip_groups"
        elif key == "sourceAddresses":
            suggest = "source_addresses"
        elif key == "sourceIpGroups":
            suggest = "source_ip_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyRuleCollectionGroupNetworkRuleCollectionRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyRuleCollectionGroupNetworkRuleCollectionRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyRuleCollectionGroupNetworkRuleCollectionRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_ports: Sequence[str],
                 name: str,
                 protocols: Sequence[str],
                 description: Optional[str] = None,
                 destination_addresses: Optional[Sequence[str]] = None,
                 destination_fqdns: Optional[Sequence[str]] = None,
                 destination_ip_groups: Optional[Sequence[str]] = None,
                 source_addresses: Optional[Sequence[str]] = None,
                 source_ip_groups: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] destination_ports: Specifies a list of destination ports.
        :param str name: The name which should be used for this Firewall Policy Rule Collection Group. Changing this forces a new Firewall Policy Rule Collection Group to be created.
        :param Sequence[str] protocols: One or more `protocols` blocks as defined below.
        :param str description: The description which should be used for this rule.
        :param Sequence[str] destination_addresses: Specifies a list of destination IP addresses (including CIDR, IP range and `*`).
        :param Sequence[str] destination_fqdns: Specifies a list of destination FQDNs. Conflicts with `destination_urls`.
        :param Sequence[str] destination_ip_groups: Specifies a list of destination IP groups.
        :param Sequence[str] source_addresses: Specifies a list of source IP addresses (including CIDR, IP range and `*`).
        :param Sequence[str] source_ip_groups: Specifies a list of source IP groups.
        """
        pulumi.set(__self__, "destination_ports", destination_ports)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "protocols", protocols)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if destination_fqdns is not None:
            pulumi.set(__self__, "destination_fqdns", destination_fqdns)
        if destination_ip_groups is not None:
            pulumi.set(__self__, "destination_ip_groups", destination_ip_groups)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_ip_groups is not None:
            pulumi.set(__self__, "source_ip_groups", source_ip_groups)

    @property
    @pulumi.getter(name="destinationPorts")
    def destination_ports(self) -> Sequence[str]:
        """
        Specifies a list of destination ports.
        """
        return pulumi.get(self, "destination_ports")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Firewall Policy Rule Collection Group. Changing this forces a new Firewall Policy Rule Collection Group to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def protocols(self) -> Sequence[str]:
        """
        One or more `protocols` blocks as defined below.
        """
        return pulumi.get(self, "protocols")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description which should be used for this rule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of destination IP addresses (including CIDR, IP range and `*`).
        """
        return pulumi.get(self, "destination_addresses")

    @property
    @pulumi.getter(name="destinationFqdns")
    def destination_fqdns(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of destination FQDNs. Conflicts with `destination_urls`.
        """
        return pulumi.get(self, "destination_fqdns")

    @property
    @pulumi.getter(name="destinationIpGroups")
    def destination_ip_groups(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of destination IP groups.
        """
        return pulumi.get(self, "destination_ip_groups")

    @property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of source IP addresses (including CIDR, IP range and `*`).
        """
        return pulumi.get(self, "source_addresses")

    @property
    @pulumi.getter(name="sourceIpGroups")
    def source_ip_groups(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of source IP groups.
        """
        return pulumi.get(self, "source_ip_groups")


@pulumi.output_type
class FirewallPolicyThreatIntelligenceAllowlist(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddresses":
            suggest = "ip_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyThreatIntelligenceAllowlist. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyThreatIntelligenceAllowlist.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyThreatIntelligenceAllowlist.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fqdns: Optional[Sequence[str]] = None,
                 ip_addresses: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] fqdns: A list of FQDNs that will be skipped for threat detection.
        :param Sequence[str] ip_addresses: A list of IP addresses or CIDR ranges that will be skipped for threat detection.
        """
        if fqdns is not None:
            pulumi.set(__self__, "fqdns", fqdns)
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)

    @property
    @pulumi.getter
    def fqdns(self) -> Optional[Sequence[str]]:
        """
        A list of FQDNs that will be skipped for threat detection.
        """
        return pulumi.get(self, "fqdns")

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[Sequence[str]]:
        """
        A list of IP addresses or CIDR ranges that will be skipped for threat detection.
        """
        return pulumi.get(self, "ip_addresses")


@pulumi.output_type
class FirewallPolicyTlsCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVaultSecretId":
            suggest = "key_vault_secret_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyTlsCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyTlsCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyTlsCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_vault_secret_id: str,
                 name: str):
        """
        :param str key_vault_secret_id: The ID of the Key Vault, where the secret or certificate is stored.
        :param str name: The name of the certificate.
        """
        pulumi.set(__self__, "key_vault_secret_id", key_vault_secret_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="keyVaultSecretId")
    def key_vault_secret_id(self) -> str:
        """
        The ID of the Key Vault, where the secret or certificate is stored.
        """
        return pulumi.get(self, "key_vault_secret_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the certificate.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class FirewallVirtualHub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "virtualHubId":
            suggest = "virtual_hub_id"
        elif key == "privateIpAddress":
            suggest = "private_ip_address"
        elif key == "publicIpAddresses":
            suggest = "public_ip_addresses"
        elif key == "publicIpCount":
            suggest = "public_ip_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallVirtualHub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallVirtualHub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallVirtualHub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 virtual_hub_id: str,
                 private_ip_address: Optional[str] = None,
                 public_ip_addresses: Optional[Sequence[str]] = None,
                 public_ip_count: Optional[int] = None):
        """
        :param str virtual_hub_id: Specifies the ID of the Virtual Hub where the Firewall resides in.
        :param str private_ip_address: The private IP address associated with the Firewall.
        :param Sequence[str] public_ip_addresses: The list of public IP addresses associated with the Firewall.
        :param int public_ip_count: Specifies the number of public IPs to assign to the Firewall. Defaults to `1`.
        """
        pulumi.set(__self__, "virtual_hub_id", virtual_hub_id)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)
        if public_ip_addresses is not None:
            pulumi.set(__self__, "public_ip_addresses", public_ip_addresses)
        if public_ip_count is not None:
            pulumi.set(__self__, "public_ip_count", public_ip_count)

    @property
    @pulumi.getter(name="virtualHubId")
    def virtual_hub_id(self) -> str:
        """
        Specifies the ID of the Virtual Hub where the Firewall resides in.
        """
        return pulumi.get(self, "virtual_hub_id")

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> Optional[str]:
        """
        The private IP address associated with the Firewall.
        """
        return pulumi.get(self, "private_ip_address")

    @property
    @pulumi.getter(name="publicIpAddresses")
    def public_ip_addresses(self) -> Optional[Sequence[str]]:
        """
        The list of public IP addresses associated with the Firewall.
        """
        return pulumi.get(self, "public_ip_addresses")

    @property
    @pulumi.getter(name="publicIpCount")
    def public_ip_count(self) -> Optional[int]:
        """
        Specifies the number of public IPs to assign to the Firewall. Defaults to `1`.
        """
        return pulumi.get(self, "public_ip_count")


@pulumi.output_type
class LocalNetworkGatewayBgpSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bgpPeeringAddress":
            suggest = "bgp_peering_address"
        elif key == "peerWeight":
            suggest = "peer_weight"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LocalNetworkGatewayBgpSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LocalNetworkGatewayBgpSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LocalNetworkGatewayBgpSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 asn: int,
                 bgp_peering_address: str,
                 peer_weight: Optional[int] = None):
        """
        :param int asn: The BGP speaker's ASN.
        :param str bgp_peering_address: The BGP peering address and BGP identifier of this BGP speaker.
        :param int peer_weight: The weight added to routes learned from this BGP speaker.
        """
        pulumi.set(__self__, "asn", asn)
        pulumi.set(__self__, "bgp_peering_address", bgp_peering_address)
        if peer_weight is not None:
            pulumi.set(__self__, "peer_weight", peer_weight)

    @property
    @pulumi.getter
    def asn(self) -> int:
        """
        The BGP speaker's ASN.
        """
        return pulumi.get(self, "asn")

    @property
    @pulumi.getter(name="bgpPeeringAddress")
    def bgp_peering_address(self) -> str:
        """
        The BGP peering address and BGP identifier of this BGP speaker.
        """
        return pulumi.get(self, "bgp_peering_address")

    @property
    @pulumi.getter(name="peerWeight")
    def peer_weight(self) -> Optional[int]:
        """
        The weight added to routes learned from this BGP speaker.
        """
        return pulumi.get(self, "peer_weight")


@pulumi.output_type
class NetworkConnectionMonitorEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "coverageLevel":
            suggest = "coverage_level"
        elif key == "excludedIpAddresses":
            suggest = "excluded_ip_addresses"
        elif key == "includedIpAddresses":
            suggest = "included_ip_addresses"
        elif key == "targetResourceId":
            suggest = "target_resource_id"
        elif key == "targetResourceType":
            suggest = "target_resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkConnectionMonitorEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkConnectionMonitorEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkConnectionMonitorEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 address: Optional[str] = None,
                 coverage_level: Optional[str] = None,
                 excluded_ip_addresses: Optional[Sequence[str]] = None,
                 filter: Optional['outputs.NetworkConnectionMonitorEndpointFilter'] = None,
                 included_ip_addresses: Optional[Sequence[str]] = None,
                 target_resource_id: Optional[str] = None,
                 target_resource_type: Optional[str] = None):
        """
        :param str name: The name of the endpoint for the Network Connection Monitor .
        :param str address: The IP address or domain name of the Network Connection Monitor endpoint.
        :param str coverage_level: The test coverage for the Network Connection Monitor endpoint. Possible values are `AboveAverage`, `Average`, `BelowAverage`, `Default`, `Full` and `Low`.
        :param Sequence[str] excluded_ip_addresses: A list of IPv4/IPv6 subnet masks or IPv4/IPv6 IP addresses to be excluded to the Network Connection Monitor endpoint.
        :param 'NetworkConnectionMonitorEndpointFilterArgs' filter: A `filter` block as defined below.
        :param Sequence[str] included_ip_addresses: A list of IPv4/IPv6 subnet masks or IPv4/IPv6 IP addresses to be included to the Network Connection Monitor endpoint.
        :param str target_resource_id: The resource ID which is used as the endpoint by the Network Connection Monitor.
        :param str target_resource_type: The endpoint type of the Network Connection Monitor. Possible values are `AzureSubnet`, `AzureVM`, `AzureVNet`, `ExternalAddress`, `MMAWorkspaceMachine` and `MMAWorkspaceNetwork`.
        """
        pulumi.set(__self__, "name", name)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if coverage_level is not None:
            pulumi.set(__self__, "coverage_level", coverage_level)
        if excluded_ip_addresses is not None:
            pulumi.set(__self__, "excluded_ip_addresses", excluded_ip_addresses)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if included_ip_addresses is not None:
            pulumi.set(__self__, "included_ip_addresses", included_ip_addresses)
        if target_resource_id is not None:
            pulumi.set(__self__, "target_resource_id", target_resource_id)
        if target_resource_type is not None:
            pulumi.set(__self__, "target_resource_type", target_resource_type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the endpoint for the Network Connection Monitor .
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        The IP address or domain name of the Network Connection Monitor endpoint.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="coverageLevel")
    def coverage_level(self) -> Optional[str]:
        """
        The test coverage for the Network Connection Monitor endpoint. Possible values are `AboveAverage`, `Average`, `BelowAverage`, `Default`, `Full` and `Low`.
        """
        return pulumi.get(self, "coverage_level")

    @property
    @pulumi.getter(name="excludedIpAddresses")
    def excluded_ip_addresses(self) -> Optional[Sequence[str]]:
        """
        A list of IPv4/IPv6 subnet masks or IPv4/IPv6 IP addresses to be excluded to the Network Connection Monitor endpoint.
        """
        return pulumi.get(self, "excluded_ip_addresses")

    @property
    @pulumi.getter
    def filter(self) -> Optional['outputs.NetworkConnectionMonitorEndpointFilter']:
        """
        A `filter` block as defined below.
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter(name="includedIpAddresses")
    def included_ip_addresses(self) -> Optional[Sequence[str]]:
        """
        A list of IPv4/IPv6 subnet masks or IPv4/IPv6 IP addresses to be included to the Network Connection Monitor endpoint.
        """
        return pulumi.get(self, "included_ip_addresses")

    @property
    @pulumi.getter(name="targetResourceId")
    def target_resource_id(self) -> Optional[str]:
        """
        The resource ID which is used as the endpoint by the Network Connection Monitor.
        """
        return pulumi.get(self, "target_resource_id")

    @property
    @pulumi.getter(name="targetResourceType")
    def target_resource_type(self) -> Optional[str]:
        """
        The endpoint type of the Network Connection Monitor. Possible values are `AzureSubnet`, `AzureVM`, `AzureVNet`, `ExternalAddress`, `MMAWorkspaceMachine` and `MMAWorkspaceNetwork`.
        """
        return pulumi.get(self, "target_resource_type")


@pulumi.output_type
class NetworkConnectionMonitorEndpointFilter(dict):
    def __init__(__self__, *,
                 items: Optional[Sequence['outputs.NetworkConnectionMonitorEndpointFilterItem']] = None,
                 type: Optional[str] = None):
        """
        :param Sequence['NetworkConnectionMonitorEndpointFilterItemArgs'] items: A `item` block as defined below.
        :param str type: The behaviour type of this endpoint filter. Currently the only allowed value is `Include`. Defaults to `Include`.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.NetworkConnectionMonitorEndpointFilterItem']]:
        """
        A `item` block as defined below.
        """
        return pulumi.get(self, "items")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The behaviour type of this endpoint filter. Currently the only allowed value is `Include`. Defaults to `Include`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class NetworkConnectionMonitorEndpointFilterItem(dict):
    def __init__(__self__, *,
                 address: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str address: The address of the filter item.
        :param str type: The type of items included in the filter. Possible values are `AgentAddress`. Defaults to `AgentAddress`.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        The address of the filter item.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of items included in the filter. Possible values are `AgentAddress`. Defaults to `AgentAddress`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class NetworkConnectionMonitorTestConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpConfiguration":
            suggest = "http_configuration"
        elif key == "icmpConfiguration":
            suggest = "icmp_configuration"
        elif key == "preferredIpVersion":
            suggest = "preferred_ip_version"
        elif key == "successThreshold":
            suggest = "success_threshold"
        elif key == "tcpConfiguration":
            suggest = "tcp_configuration"
        elif key == "testFrequencyInSeconds":
            suggest = "test_frequency_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkConnectionMonitorTestConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkConnectionMonitorTestConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkConnectionMonitorTestConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 protocol: str,
                 http_configuration: Optional['outputs.NetworkConnectionMonitorTestConfigurationHttpConfiguration'] = None,
                 icmp_configuration: Optional['outputs.NetworkConnectionMonitorTestConfigurationIcmpConfiguration'] = None,
                 preferred_ip_version: Optional[str] = None,
                 success_threshold: Optional['outputs.NetworkConnectionMonitorTestConfigurationSuccessThreshold'] = None,
                 tcp_configuration: Optional['outputs.NetworkConnectionMonitorTestConfigurationTcpConfiguration'] = None,
                 test_frequency_in_seconds: Optional[int] = None):
        """
        :param str name: The name of test configuration for the Network Connection Monitor.
        :param str protocol: The protocol used to evaluate tests. Possible values are `Tcp`, `Http` and `Icmp`.
        :param 'NetworkConnectionMonitorTestConfigurationHttpConfigurationArgs' http_configuration: A `http_configuration` block as defined below.
        :param 'NetworkConnectionMonitorTestConfigurationIcmpConfigurationArgs' icmp_configuration: A `icmp_configuration` block as defined below.
        :param str preferred_ip_version: The preferred IP version which is used in the test evaluation. Possible values are `IPv4` and `IPv6`.
        :param 'NetworkConnectionMonitorTestConfigurationSuccessThresholdArgs' success_threshold: A `success_threshold` block as defined below.
        :param 'NetworkConnectionMonitorTestConfigurationTcpConfigurationArgs' tcp_configuration: A `tcp_configuration` block as defined below.
        :param int test_frequency_in_seconds: The time interval in seconds at which the test evaluation will happen. Defaults to `60`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "protocol", protocol)
        if http_configuration is not None:
            pulumi.set(__self__, "http_configuration", http_configuration)
        if icmp_configuration is not None:
            pulumi.set(__self__, "icmp_configuration", icmp_configuration)
        if preferred_ip_version is not None:
            pulumi.set(__self__, "preferred_ip_version", preferred_ip_version)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if tcp_configuration is not None:
            pulumi.set(__self__, "tcp_configuration", tcp_configuration)
        if test_frequency_in_seconds is not None:
            pulumi.set(__self__, "test_frequency_in_seconds", test_frequency_in_seconds)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of test configuration for the Network Connection Monitor.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The protocol used to evaluate tests. Possible values are `Tcp`, `Http` and `Icmp`.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="httpConfiguration")
    def http_configuration(self) -> Optional['outputs.NetworkConnectionMonitorTestConfigurationHttpConfiguration']:
        """
        A `http_configuration` block as defined below.
        """
        return pulumi.get(self, "http_configuration")

    @property
    @pulumi.getter(name="icmpConfiguration")
    def icmp_configuration(self) -> Optional['outputs.NetworkConnectionMonitorTestConfigurationIcmpConfiguration']:
        """
        A `icmp_configuration` block as defined below.
        """
        return pulumi.get(self, "icmp_configuration")

    @property
    @pulumi.getter(name="preferredIpVersion")
    def preferred_ip_version(self) -> Optional[str]:
        """
        The preferred IP version which is used in the test evaluation. Possible values are `IPv4` and `IPv6`.
        """
        return pulumi.get(self, "preferred_ip_version")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional['outputs.NetworkConnectionMonitorTestConfigurationSuccessThreshold']:
        """
        A `success_threshold` block as defined below.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="tcpConfiguration")
    def tcp_configuration(self) -> Optional['outputs.NetworkConnectionMonitorTestConfigurationTcpConfiguration']:
        """
        A `tcp_configuration` block as defined below.
        """
        return pulumi.get(self, "tcp_configuration")

    @property
    @pulumi.getter(name="testFrequencyInSeconds")
    def test_frequency_in_seconds(self) -> Optional[int]:
        """
        The time interval in seconds at which the test evaluation will happen. Defaults to `60`.
        """
        return pulumi.get(self, "test_frequency_in_seconds")


@pulumi.output_type
class NetworkConnectionMonitorTestConfigurationHttpConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "preferHttps":
            suggest = "prefer_https"
        elif key == "requestHeaders":
            suggest = "request_headers"
        elif key == "validStatusCodeRanges":
            suggest = "valid_status_code_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkConnectionMonitorTestConfigurationHttpConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkConnectionMonitorTestConfigurationHttpConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkConnectionMonitorTestConfigurationHttpConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: Optional[str] = None,
                 path: Optional[str] = None,
                 port: Optional[int] = None,
                 prefer_https: Optional[bool] = None,
                 request_headers: Optional[Sequence['outputs.NetworkConnectionMonitorTestConfigurationHttpConfigurationRequestHeader']] = None,
                 valid_status_code_ranges: Optional[Sequence[str]] = None):
        """
        :param str method: The HTTP method for the HTTP request. Possible values are `Get` and `Post`. Defaults to `Get`.
        :param str path: The path component of the URI. It only accepts the absolute path.
        :param int port: The port for the HTTP connection.
        :param bool prefer_https: Should HTTPS be preferred over HTTP in cases where the choice is not explicit? Defaults to `false`.
        :param Sequence['NetworkConnectionMonitorTestConfigurationHttpConfigurationRequestHeaderArgs'] request_headers: A `request_header` block as defined below.
        :param Sequence[str] valid_status_code_ranges: The HTTP status codes to consider successful. For instance, `2xx`, `301-304` and `418`.
        """
        if method is not None:
            pulumi.set(__self__, "method", method)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if prefer_https is not None:
            pulumi.set(__self__, "prefer_https", prefer_https)
        if request_headers is not None:
            pulumi.set(__self__, "request_headers", request_headers)
        if valid_status_code_ranges is not None:
            pulumi.set(__self__, "valid_status_code_ranges", valid_status_code_ranges)

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        """
        The HTTP method for the HTTP request. Possible values are `Get` and `Post`. Defaults to `Get`.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path component of the URI. It only accepts the absolute path.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port for the HTTP connection.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="preferHttps")
    def prefer_https(self) -> Optional[bool]:
        """
        Should HTTPS be preferred over HTTP in cases where the choice is not explicit? Defaults to `false`.
        """
        return pulumi.get(self, "prefer_https")

    @property
    @pulumi.getter(name="requestHeaders")
    def request_headers(self) -> Optional[Sequence['outputs.NetworkConnectionMonitorTestConfigurationHttpConfigurationRequestHeader']]:
        """
        A `request_header` block as defined below.
        """
        return pulumi.get(self, "request_headers")

    @property
    @pulumi.getter(name="validStatusCodeRanges")
    def valid_status_code_ranges(self) -> Optional[Sequence[str]]:
        """
        The HTTP status codes to consider successful. For instance, `2xx`, `301-304` and `418`.
        """
        return pulumi.get(self, "valid_status_code_ranges")


@pulumi.output_type
class NetworkConnectionMonitorTestConfigurationHttpConfigurationRequestHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: The name of the HTTP header.
        :param str value: The value of the HTTP header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the HTTP header.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the HTTP header.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NetworkConnectionMonitorTestConfigurationIcmpConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "traceRouteEnabled":
            suggest = "trace_route_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkConnectionMonitorTestConfigurationIcmpConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkConnectionMonitorTestConfigurationIcmpConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkConnectionMonitorTestConfigurationIcmpConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 trace_route_enabled: Optional[bool] = None):
        """
        :param bool trace_route_enabled: Should path evaluation with trace route be enabled? Defaults to `true`.
        """
        if trace_route_enabled is not None:
            pulumi.set(__self__, "trace_route_enabled", trace_route_enabled)

    @property
    @pulumi.getter(name="traceRouteEnabled")
    def trace_route_enabled(self) -> Optional[bool]:
        """
        Should path evaluation with trace route be enabled? Defaults to `true`.
        """
        return pulumi.get(self, "trace_route_enabled")


@pulumi.output_type
class NetworkConnectionMonitorTestConfigurationSuccessThreshold(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checksFailedPercent":
            suggest = "checks_failed_percent"
        elif key == "roundTripTimeMs":
            suggest = "round_trip_time_ms"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkConnectionMonitorTestConfigurationSuccessThreshold. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkConnectionMonitorTestConfigurationSuccessThreshold.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkConnectionMonitorTestConfigurationSuccessThreshold.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 checks_failed_percent: Optional[int] = None,
                 round_trip_time_ms: Optional[float] = None):
        """
        :param int checks_failed_percent: The maximum percentage of failed checks permitted for a test to be successful.
        :param float round_trip_time_ms: The maximum round-trip time in milliseconds permitted for a test to be successful.
        """
        if checks_failed_percent is not None:
            pulumi.set(__self__, "checks_failed_percent", checks_failed_percent)
        if round_trip_time_ms is not None:
            pulumi.set(__self__, "round_trip_time_ms", round_trip_time_ms)

    @property
    @pulumi.getter(name="checksFailedPercent")
    def checks_failed_percent(self) -> Optional[int]:
        """
        The maximum percentage of failed checks permitted for a test to be successful.
        """
        return pulumi.get(self, "checks_failed_percent")

    @property
    @pulumi.getter(name="roundTripTimeMs")
    def round_trip_time_ms(self) -> Optional[float]:
        """
        The maximum round-trip time in milliseconds permitted for a test to be successful.
        """
        return pulumi.get(self, "round_trip_time_ms")


@pulumi.output_type
class NetworkConnectionMonitorTestConfigurationTcpConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationPortBehavior":
            suggest = "destination_port_behavior"
        elif key == "traceRouteEnabled":
            suggest = "trace_route_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkConnectionMonitorTestConfigurationTcpConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkConnectionMonitorTestConfigurationTcpConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkConnectionMonitorTestConfigurationTcpConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port: int,
                 destination_port_behavior: Optional[str] = None,
                 trace_route_enabled: Optional[bool] = None):
        """
        :param int port: The port for the TCP connection.
        :param str destination_port_behavior: The destination port behavior for the TCP connection. Possible values are `None` and `ListenIfAvailable`.
        :param bool trace_route_enabled: Should path evaluation with trace route be enabled? Defaults to `true`.
        """
        pulumi.set(__self__, "port", port)
        if destination_port_behavior is not None:
            pulumi.set(__self__, "destination_port_behavior", destination_port_behavior)
        if trace_route_enabled is not None:
            pulumi.set(__self__, "trace_route_enabled", trace_route_enabled)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port for the TCP connection.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="destinationPortBehavior")
    def destination_port_behavior(self) -> Optional[str]:
        """
        The destination port behavior for the TCP connection. Possible values are `None` and `ListenIfAvailable`.
        """
        return pulumi.get(self, "destination_port_behavior")

    @property
    @pulumi.getter(name="traceRouteEnabled")
    def trace_route_enabled(self) -> Optional[bool]:
        """
        Should path evaluation with trace route be enabled? Defaults to `true`.
        """
        return pulumi.get(self, "trace_route_enabled")


@pulumi.output_type
class NetworkConnectionMonitorTestGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationEndpoints":
            suggest = "destination_endpoints"
        elif key == "sourceEndpoints":
            suggest = "source_endpoints"
        elif key == "testConfigurationNames":
            suggest = "test_configuration_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkConnectionMonitorTestGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkConnectionMonitorTestGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkConnectionMonitorTestGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_endpoints: Sequence[str],
                 name: str,
                 source_endpoints: Sequence[str],
                 test_configuration_names: Sequence[str],
                 enabled: Optional[bool] = None):
        """
        :param Sequence[str] destination_endpoints: A list of destination endpoint names.
        :param str name: The name of the test group for the Network Connection Monitor.
        :param Sequence[str] source_endpoints: A list of source endpoint names.
        :param Sequence[str] test_configuration_names: A list of test configuration names.
        :param bool enabled: Should the test group be enabled? Defaults to `true`.
        """
        pulumi.set(__self__, "destination_endpoints", destination_endpoints)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "source_endpoints", source_endpoints)
        pulumi.set(__self__, "test_configuration_names", test_configuration_names)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="destinationEndpoints")
    def destination_endpoints(self) -> Sequence[str]:
        """
        A list of destination endpoint names.
        """
        return pulumi.get(self, "destination_endpoints")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the test group for the Network Connection Monitor.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sourceEndpoints")
    def source_endpoints(self) -> Sequence[str]:
        """
        A list of source endpoint names.
        """
        return pulumi.get(self, "source_endpoints")

    @property
    @pulumi.getter(name="testConfigurationNames")
    def test_configuration_names(self) -> Sequence[str]:
        """
        A list of test configuration names.
        """
        return pulumi.get(self, "test_configuration_names")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Should the test group be enabled? Defaults to `true`.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class NetworkInterfaceIpConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateIpAddressAllocation":
            suggest = "private_ip_address_allocation"
        elif key == "gatewayLoadBalancerFrontendIpConfigurationId":
            suggest = "gateway_load_balancer_frontend_ip_configuration_id"
        elif key == "privateIpAddress":
            suggest = "private_ip_address"
        elif key == "privateIpAddressVersion":
            suggest = "private_ip_address_version"
        elif key == "publicIpAddressId":
            suggest = "public_ip_address_id"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInterfaceIpConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInterfaceIpConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInterfaceIpConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 private_ip_address_allocation: str,
                 gateway_load_balancer_frontend_ip_configuration_id: Optional[str] = None,
                 primary: Optional[bool] = None,
                 private_ip_address: Optional[str] = None,
                 private_ip_address_version: Optional[str] = None,
                 public_ip_address_id: Optional[str] = None,
                 subnet_id: Optional[str] = None):
        """
        :param str name: A name used for this IP Configuration.
        :param str private_ip_address_allocation: The allocation method used for the Private IP Address. Possible values are `Dynamic` and `Static`.
               
               > **Note:** `Dynamic` means "An IP is automatically assigned during creation of this Network Interface"; `Static` means "User supplied IP address will be used"
        :param str gateway_load_balancer_frontend_ip_configuration_id: The Frontend IP Configuration ID of a Gateway SKU Load Balancer.
        :param bool primary: Is this the Primary IP Configuration? Must be `true` for the first `ip_configuration` when multiple are specified. Defaults to `false`.
        :param str private_ip_address: The Static IP Address which should be used.
        :param str private_ip_address_version: The IP Version to use. Possible values are `IPv4` or `IPv6`. Defaults to `IPv4`.
        :param str public_ip_address_id: Reference to a Public IP Address to associate with this NIC
        :param str subnet_id: The ID of the Subnet where this Network Interface should be located in.
               
               > **Note:** This is required when `private_ip_address_version` is set to `IPv4`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "private_ip_address_allocation", private_ip_address_allocation)
        if gateway_load_balancer_frontend_ip_configuration_id is not None:
            pulumi.set(__self__, "gateway_load_balancer_frontend_ip_configuration_id", gateway_load_balancer_frontend_ip_configuration_id)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)
        if private_ip_address_version is not None:
            pulumi.set(__self__, "private_ip_address_version", private_ip_address_version)
        if public_ip_address_id is not None:
            pulumi.set(__self__, "public_ip_address_id", public_ip_address_id)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A name used for this IP Configuration.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateIpAddressAllocation")
    def private_ip_address_allocation(self) -> str:
        """
        The allocation method used for the Private IP Address. Possible values are `Dynamic` and `Static`.

        > **Note:** `Dynamic` means "An IP is automatically assigned during creation of this Network Interface"; `Static` means "User supplied IP address will be used"
        """
        return pulumi.get(self, "private_ip_address_allocation")

    @property
    @pulumi.getter(name="gatewayLoadBalancerFrontendIpConfigurationId")
    def gateway_load_balancer_frontend_ip_configuration_id(self) -> Optional[str]:
        """
        The Frontend IP Configuration ID of a Gateway SKU Load Balancer.
        """
        return pulumi.get(self, "gateway_load_balancer_frontend_ip_configuration_id")

    @property
    @pulumi.getter
    def primary(self) -> Optional[bool]:
        """
        Is this the Primary IP Configuration? Must be `true` for the first `ip_configuration` when multiple are specified. Defaults to `false`.
        """
        return pulumi.get(self, "primary")

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> Optional[str]:
        """
        The Static IP Address which should be used.
        """
        return pulumi.get(self, "private_ip_address")

    @property
    @pulumi.getter(name="privateIpAddressVersion")
    def private_ip_address_version(self) -> Optional[str]:
        """
        The IP Version to use. Possible values are `IPv4` or `IPv6`. Defaults to `IPv4`.
        """
        return pulumi.get(self, "private_ip_address_version")

    @property
    @pulumi.getter(name="publicIpAddressId")
    def public_ip_address_id(self) -> Optional[str]:
        """
        Reference to a Public IP Address to associate with this NIC
        """
        return pulumi.get(self, "public_ip_address_id")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The ID of the Subnet where this Network Interface should be located in.

        > **Note:** This is required when `private_ip_address_version` is set to `IPv4`.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class NetworkManagerAdminRuleDestination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressPrefix":
            suggest = "address_prefix"
        elif key == "addressPrefixType":
            suggest = "address_prefix_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkManagerAdminRuleDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkManagerAdminRuleDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkManagerAdminRuleDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address_prefix: str,
                 address_prefix_type: str):
        """
        :param str address_prefix: Specifies the address prefix.
        :param str address_prefix_type: Specifies the address prefix type. Possible values are `IPPrefix` and `ServiceTag`. For more information, please see [this document](https://learn.microsoft.com/en-us/azure/virtual-network-manager/concept-security-admins#source-and-destination-types).
        """
        pulumi.set(__self__, "address_prefix", address_prefix)
        pulumi.set(__self__, "address_prefix_type", address_prefix_type)

    @property
    @pulumi.getter(name="addressPrefix")
    def address_prefix(self) -> str:
        """
        Specifies the address prefix.
        """
        return pulumi.get(self, "address_prefix")

    @property
    @pulumi.getter(name="addressPrefixType")
    def address_prefix_type(self) -> str:
        """
        Specifies the address prefix type. Possible values are `IPPrefix` and `ServiceTag`. For more information, please see [this document](https://learn.microsoft.com/en-us/azure/virtual-network-manager/concept-security-admins#source-and-destination-types).
        """
        return pulumi.get(self, "address_prefix_type")


@pulumi.output_type
class NetworkManagerAdminRuleSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressPrefix":
            suggest = "address_prefix"
        elif key == "addressPrefixType":
            suggest = "address_prefix_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkManagerAdminRuleSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkManagerAdminRuleSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkManagerAdminRuleSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address_prefix: str,
                 address_prefix_type: str):
        """
        :param str address_prefix: Specifies the address prefix.
        :param str address_prefix_type: Specifies the address prefix type. Possible values are `IPPrefix` and `ServiceTag`. For more information, please see [this document](https://learn.microsoft.com/en-us/azure/virtual-network-manager/concept-security-admins#source-and-destination-types).
        """
        pulumi.set(__self__, "address_prefix", address_prefix)
        pulumi.set(__self__, "address_prefix_type", address_prefix_type)

    @property
    @pulumi.getter(name="addressPrefix")
    def address_prefix(self) -> str:
        """
        Specifies the address prefix.
        """
        return pulumi.get(self, "address_prefix")

    @property
    @pulumi.getter(name="addressPrefixType")
    def address_prefix_type(self) -> str:
        """
        Specifies the address prefix type. Possible values are `IPPrefix` and `ServiceTag`. For more information, please see [this document](https://learn.microsoft.com/en-us/azure/virtual-network-manager/concept-security-admins#source-and-destination-types).
        """
        return pulumi.get(self, "address_prefix_type")


@pulumi.output_type
class NetworkManagerConnectivityConfigurationAppliesToGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupConnectivity":
            suggest = "group_connectivity"
        elif key == "networkGroupId":
            suggest = "network_group_id"
        elif key == "globalMeshEnabled":
            suggest = "global_mesh_enabled"
        elif key == "useHubGateway":
            suggest = "use_hub_gateway"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkManagerConnectivityConfigurationAppliesToGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkManagerConnectivityConfigurationAppliesToGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkManagerConnectivityConfigurationAppliesToGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_connectivity: str,
                 network_group_id: str,
                 global_mesh_enabled: Optional[bool] = None,
                 use_hub_gateway: Optional[bool] = None):
        """
        :param str group_connectivity: Specifies the group connectivity type. Possible values are `None` and `DirectlyConnected`.
        :param str network_group_id: Specifies the resource ID of Network Group which the configuration applies to.
        :param bool global_mesh_enabled: Indicates whether to global mesh is supported for this group. Possible values are `true` and `false`.
               
               > **NOTE:** A group can be global only if the `group_connectivity` is `DirectlyConnected`.
        :param bool use_hub_gateway: Indicates whether the hub gateway is used. Possible values are `true` and `false`.
        """
        pulumi.set(__self__, "group_connectivity", group_connectivity)
        pulumi.set(__self__, "network_group_id", network_group_id)
        if global_mesh_enabled is not None:
            pulumi.set(__self__, "global_mesh_enabled", global_mesh_enabled)
        if use_hub_gateway is not None:
            pulumi.set(__self__, "use_hub_gateway", use_hub_gateway)

    @property
    @pulumi.getter(name="groupConnectivity")
    def group_connectivity(self) -> str:
        """
        Specifies the group connectivity type. Possible values are `None` and `DirectlyConnected`.
        """
        return pulumi.get(self, "group_connectivity")

    @property
    @pulumi.getter(name="networkGroupId")
    def network_group_id(self) -> str:
        """
        Specifies the resource ID of Network Group which the configuration applies to.
        """
        return pulumi.get(self, "network_group_id")

    @property
    @pulumi.getter(name="globalMeshEnabled")
    def global_mesh_enabled(self) -> Optional[bool]:
        """
        Indicates whether to global mesh is supported for this group. Possible values are `true` and `false`.

        > **NOTE:** A group can be global only if the `group_connectivity` is `DirectlyConnected`.
        """
        return pulumi.get(self, "global_mesh_enabled")

    @property
    @pulumi.getter(name="useHubGateway")
    def use_hub_gateway(self) -> Optional[bool]:
        """
        Indicates whether the hub gateway is used. Possible values are `true` and `false`.
        """
        return pulumi.get(self, "use_hub_gateway")


@pulumi.output_type
class NetworkManagerConnectivityConfigurationHub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceId":
            suggest = "resource_id"
        elif key == "resourceType":
            suggest = "resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkManagerConnectivityConfigurationHub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkManagerConnectivityConfigurationHub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkManagerConnectivityConfigurationHub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_id: str,
                 resource_type: str):
        """
        :param str resource_id: Specifies the resource ID used as hub in Hub And Spoke topology.
        :param str resource_type: Specifies the resource Type used as hub in Hub And Spoke topology.
        """
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "resource_type", resource_type)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> str:
        """
        Specifies the resource ID used as hub in Hub And Spoke topology.
        """
        return pulumi.get(self, "resource_id")

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> str:
        """
        Specifies the resource Type used as hub in Hub And Spoke topology.
        """
        return pulumi.get(self, "resource_type")


@pulumi.output_type
class NetworkManagerCrossTenantScope(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managementGroups":
            suggest = "management_groups"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkManagerCrossTenantScope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkManagerCrossTenantScope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkManagerCrossTenantScope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 management_groups: Optional[Sequence[str]] = None,
                 subscriptions: Optional[Sequence[str]] = None,
                 tenant_id: Optional[str] = None):
        """
        :param Sequence[str] management_groups: List of management groups.
        :param Sequence[str] subscriptions: List of subscriptions.
        :param str tenant_id: Tenant ID.
        """
        if management_groups is not None:
            pulumi.set(__self__, "management_groups", management_groups)
        if subscriptions is not None:
            pulumi.set(__self__, "subscriptions", subscriptions)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="managementGroups")
    def management_groups(self) -> Optional[Sequence[str]]:
        """
        List of management groups.
        """
        return pulumi.get(self, "management_groups")

    @property
    @pulumi.getter
    def subscriptions(self) -> Optional[Sequence[str]]:
        """
        List of subscriptions.
        """
        return pulumi.get(self, "subscriptions")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        Tenant ID.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class NetworkManagerScope(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managementGroupIds":
            suggest = "management_group_ids"
        elif key == "subscriptionIds":
            suggest = "subscription_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkManagerScope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkManagerScope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkManagerScope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 management_group_ids: Optional[Sequence[str]] = None,
                 subscription_ids: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] management_group_ids: A list of management group IDs.
        :param Sequence[str] subscription_ids: A list of subscription IDs.
        """
        if management_group_ids is not None:
            pulumi.set(__self__, "management_group_ids", management_group_ids)
        if subscription_ids is not None:
            pulumi.set(__self__, "subscription_ids", subscription_ids)

    @property
    @pulumi.getter(name="managementGroupIds")
    def management_group_ids(self) -> Optional[Sequence[str]]:
        """
        A list of management group IDs.
        """
        return pulumi.get(self, "management_group_ids")

    @property
    @pulumi.getter(name="subscriptionIds")
    def subscription_ids(self) -> Optional[Sequence[str]]:
        """
        A list of subscription IDs.
        """
        return pulumi.get(self, "subscription_ids")


@pulumi.output_type
class NetworkPacketCaptureFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localIpAddress":
            suggest = "local_ip_address"
        elif key == "localPort":
            suggest = "local_port"
        elif key == "remoteIpAddress":
            suggest = "remote_ip_address"
        elif key == "remotePort":
            suggest = "remote_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkPacketCaptureFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkPacketCaptureFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkPacketCaptureFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 protocol: str,
                 local_ip_address: Optional[str] = None,
                 local_port: Optional[str] = None,
                 remote_ip_address: Optional[str] = None,
                 remote_port: Optional[str] = None):
        """
        :param str protocol: The Protocol to be filtered on. Possible values include `Any`, `TCP` and `UDP`. Changing this forces a new resource to be created.
        :param str local_ip_address: The local IP Address to be filtered on. Notation: "127.0.0.1" for single address entry. "127.0.0.1-127.0.0.255" for range. "127.0.0.1;127.0.0.5" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported. Changing this forces a new resource to be created.
        :param str local_port: The local port to be filtered on. Notation: "80" for single port entry."80-85" for range. "80;443;" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported. Changing this forces a new resource to be created.
        :param str remote_ip_address: The remote IP Address to be filtered on. Notation: "127.0.0.1" for single address entry. "127.0.0.1-127.0.0.255" for range. "127.0.0.1;127.0.0.5;" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported.. Changing this forces a new resource to be created.
        :param str remote_port: The remote port to be filtered on. Notation: "80" for single port entry."80-85" for range. "80;443;" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "protocol", protocol)
        if local_ip_address is not None:
            pulumi.set(__self__, "local_ip_address", local_ip_address)
        if local_port is not None:
            pulumi.set(__self__, "local_port", local_port)
        if remote_ip_address is not None:
            pulumi.set(__self__, "remote_ip_address", remote_ip_address)
        if remote_port is not None:
            pulumi.set(__self__, "remote_port", remote_port)

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The Protocol to be filtered on. Possible values include `Any`, `TCP` and `UDP`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="localIpAddress")
    def local_ip_address(self) -> Optional[str]:
        """
        The local IP Address to be filtered on. Notation: "127.0.0.1" for single address entry. "127.0.0.1-127.0.0.255" for range. "127.0.0.1;127.0.0.5" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "local_ip_address")

    @property
    @pulumi.getter(name="localPort")
    def local_port(self) -> Optional[str]:
        """
        The local port to be filtered on. Notation: "80" for single port entry."80-85" for range. "80;443;" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "local_port")

    @property
    @pulumi.getter(name="remoteIpAddress")
    def remote_ip_address(self) -> Optional[str]:
        """
        The remote IP Address to be filtered on. Notation: "127.0.0.1" for single address entry. "127.0.0.1-127.0.0.255" for range. "127.0.0.1;127.0.0.5;" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported.. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "remote_ip_address")

    @property
    @pulumi.getter(name="remotePort")
    def remote_port(self) -> Optional[str]:
        """
        The remote port to be filtered on. Notation: "80" for single port entry."80-85" for range. "80;443;" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "remote_port")


@pulumi.output_type
class NetworkPacketCaptureStorageLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filePath":
            suggest = "file_path"
        elif key == "storageAccountId":
            suggest = "storage_account_id"
        elif key == "storagePath":
            suggest = "storage_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkPacketCaptureStorageLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkPacketCaptureStorageLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkPacketCaptureStorageLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_path: Optional[str] = None,
                 storage_account_id: Optional[str] = None,
                 storage_path: Optional[str] = None):
        """
        :param str file_path: A valid local path on the targeting VM. Must include the name of the capture file (*.cap). For Linux virtual machine it must start with `/var/captures`.
        :param str storage_account_id: The ID of the storage account to save the packet capture session
               
               > **NOTE:** At least one of `file_path` or `storage_account_id` must be specified.
        :param str storage_path: The URI of the storage path to save the packet capture.
        """
        if file_path is not None:
            pulumi.set(__self__, "file_path", file_path)
        if storage_account_id is not None:
            pulumi.set(__self__, "storage_account_id", storage_account_id)
        if storage_path is not None:
            pulumi.set(__self__, "storage_path", storage_path)

    @property
    @pulumi.getter(name="filePath")
    def file_path(self) -> Optional[str]:
        """
        A valid local path on the targeting VM. Must include the name of the capture file (*.cap). For Linux virtual machine it must start with `/var/captures`.
        """
        return pulumi.get(self, "file_path")

    @property
    @pulumi.getter(name="storageAccountId")
    def storage_account_id(self) -> Optional[str]:
        """
        The ID of the storage account to save the packet capture session

        > **NOTE:** At least one of `file_path` or `storage_account_id` must be specified.
        """
        return pulumi.get(self, "storage_account_id")

    @property
    @pulumi.getter(name="storagePath")
    def storage_path(self) -> Optional[str]:
        """
        The URI of the storage path to save the packet capture.
        """
        return pulumi.get(self, "storage_path")


@pulumi.output_type
class NetworkSecurityGroupSecurityRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationAddressPrefix":
            suggest = "destination_address_prefix"
        elif key == "destinationAddressPrefixes":
            suggest = "destination_address_prefixes"
        elif key == "destinationApplicationSecurityGroupIds":
            suggest = "destination_application_security_group_ids"
        elif key == "destinationPortRange":
            suggest = "destination_port_range"
        elif key == "destinationPortRanges":
            suggest = "destination_port_ranges"
        elif key == "sourceAddressPrefix":
            suggest = "source_address_prefix"
        elif key == "sourceAddressPrefixes":
            suggest = "source_address_prefixes"
        elif key == "sourceApplicationSecurityGroupIds":
            suggest = "source_application_security_group_ids"
        elif key == "sourcePortRange":
            suggest = "source_port_range"
        elif key == "sourcePortRanges":
            suggest = "source_port_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkSecurityGroupSecurityRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkSecurityGroupSecurityRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkSecurityGroupSecurityRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access: str,
                 direction: str,
                 name: str,
                 priority: int,
                 protocol: str,
                 description: Optional[str] = None,
                 destination_address_prefix: Optional[str] = None,
                 destination_address_prefixes: Optional[Sequence[str]] = None,
                 destination_application_security_group_ids: Optional[Sequence[str]] = None,
                 destination_port_range: Optional[str] = None,
                 destination_port_ranges: Optional[Sequence[str]] = None,
                 source_address_prefix: Optional[str] = None,
                 source_address_prefixes: Optional[Sequence[str]] = None,
                 source_application_security_group_ids: Optional[Sequence[str]] = None,
                 source_port_range: Optional[str] = None,
                 source_port_ranges: Optional[Sequence[str]] = None):
        """
        :param str access: Specifies whether network traffic is allowed or denied. Possible values are `Allow` and `Deny`.
        :param str direction: The direction specifies if rule will be evaluated on incoming or outgoing traffic. Possible values are `Inbound` and `Outbound`.
        :param str name: The name of the security rule.
        :param int priority: Specifies the priority of the rule. The value can be between 100 and 4096. The priority number must be unique for each rule in the collection. The lower the priority number, the higher the priority of the rule.
        :param str protocol: Network protocol this rule applies to. Possible values include `Tcp`, `Udp`, `Icmp`, `Esp`, `Ah` or `*` (which matches all).
        :param str description: A description for this rule. Restricted to 140 characters.
        :param str destination_address_prefix: CIDR or destination IP range or * to match any IP. Tags such as `VirtualNetwork`, `AzureLoadBalancer` and `Internet` can also be used. This is required if `destination_address_prefixes` is not specified.
        :param Sequence[str] destination_address_prefixes: List of destination address prefixes. Tags may not be used. This is required if `destination_address_prefix` is not specified.
        :param Sequence[str] destination_application_security_group_ids: A List of destination Application Security Group IDs
        :param str destination_port_range: Destination Port or Range. Integer or range between `0` and `65535` or `*` to match any. This is required if `destination_port_ranges` is not specified.
        :param Sequence[str] destination_port_ranges: List of destination ports or port ranges. This is required if `destination_port_range` is not specified.
        :param str source_address_prefix: CIDR or source IP range or * to match any IP. Tags such as `VirtualNetwork`, `AzureLoadBalancer` and `Internet` can also be used. This is required if `source_address_prefixes` is not specified.
        :param Sequence[str] source_address_prefixes: List of source address prefixes. Tags may not be used. This is required if `source_address_prefix` is not specified.
        :param Sequence[str] source_application_security_group_ids: A List of source Application Security Group IDs
        :param str source_port_range: Source Port or Range. Integer or range between `0` and `65535` or `*` to match any. This is required if `source_port_ranges` is not specified.
        :param Sequence[str] source_port_ranges: List of source ports or port ranges. This is required if `source_port_range` is not specified.
        """
        pulumi.set(__self__, "access", access)
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "protocol", protocol)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if destination_address_prefix is not None:
            pulumi.set(__self__, "destination_address_prefix", destination_address_prefix)
        if destination_address_prefixes is not None:
            pulumi.set(__self__, "destination_address_prefixes", destination_address_prefixes)
        if destination_application_security_group_ids is not None:
            pulumi.set(__self__, "destination_application_security_group_ids", destination_application_security_group_ids)
        if destination_port_range is not None:
            pulumi.set(__self__, "destination_port_range", destination_port_range)
        if destination_port_ranges is not None:
            pulumi.set(__self__, "destination_port_ranges", destination_port_ranges)
        if source_address_prefix is not None:
            pulumi.set(__self__, "source_address_prefix", source_address_prefix)
        if source_address_prefixes is not None:
            pulumi.set(__self__, "source_address_prefixes", source_address_prefixes)
        if source_application_security_group_ids is not None:
            pulumi.set(__self__, "source_application_security_group_ids", source_application_security_group_ids)
        if source_port_range is not None:
            pulumi.set(__self__, "source_port_range", source_port_range)
        if source_port_ranges is not None:
            pulumi.set(__self__, "source_port_ranges", source_port_ranges)

    @property
    @pulumi.getter
    def access(self) -> str:
        """
        Specifies whether network traffic is allowed or denied. Possible values are `Allow` and `Deny`.
        """
        return pulumi.get(self, "access")

    @property
    @pulumi.getter
    def direction(self) -> str:
        """
        The direction specifies if rule will be evaluated on incoming or outgoing traffic. Possible values are `Inbound` and `Outbound`.
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the security rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Specifies the priority of the rule. The value can be between 100 and 4096. The priority number must be unique for each rule in the collection. The lower the priority number, the higher the priority of the rule.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Network protocol this rule applies to. Possible values include `Tcp`, `Udp`, `Icmp`, `Esp`, `Ah` or `*` (which matches all).
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A description for this rule. Restricted to 140 characters.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="destinationAddressPrefix")
    def destination_address_prefix(self) -> Optional[str]:
        """
        CIDR or destination IP range or * to match any IP. Tags such as `VirtualNetwork`, `AzureLoadBalancer` and `Internet` can also be used. This is required if `destination_address_prefixes` is not specified.
        """
        return pulumi.get(self, "destination_address_prefix")

    @property
    @pulumi.getter(name="destinationAddressPrefixes")
    def destination_address_prefixes(self) -> Optional[Sequence[str]]:
        """
        List of destination address prefixes. Tags may not be used. This is required if `destination_address_prefix` is not specified.
        """
        return pulumi.get(self, "destination_address_prefixes")

    @property
    @pulumi.getter(name="destinationApplicationSecurityGroupIds")
    def destination_application_security_group_ids(self) -> Optional[Sequence[str]]:
        """
        A List of destination Application Security Group IDs
        """
        return pulumi.get(self, "destination_application_security_group_ids")

    @property
    @pulumi.getter(name="destinationPortRange")
    def destination_port_range(self) -> Optional[str]:
        """
        Destination Port or Range. Integer or range between `0` and `65535` or `*` to match any. This is required if `destination_port_ranges` is not specified.
        """
        return pulumi.get(self, "destination_port_range")

    @property
    @pulumi.getter(name="destinationPortRanges")
    def destination_port_ranges(self) -> Optional[Sequence[str]]:
        """
        List of destination ports or port ranges. This is required if `destination_port_range` is not specified.
        """
        return pulumi.get(self, "destination_port_ranges")

    @property
    @pulumi.getter(name="sourceAddressPrefix")
    def source_address_prefix(self) -> Optional[str]:
        """
        CIDR or source IP range or * to match any IP. Tags such as `VirtualNetwork`, `AzureLoadBalancer` and `Internet` can also be used. This is required if `source_address_prefixes` is not specified.
        """
        return pulumi.get(self, "source_address_prefix")

    @property
    @pulumi.getter(name="sourceAddressPrefixes")
    def source_address_prefixes(self) -> Optional[Sequence[str]]:
        """
        List of source address prefixes. Tags may not be used. This is required if `source_address_prefix` is not specified.
        """
        return pulumi.get(self, "source_address_prefixes")

    @property
    @pulumi.getter(name="sourceApplicationSecurityGroupIds")
    def source_application_security_group_ids(self) -> Optional[Sequence[str]]:
        """
        A List of source Application Security Group IDs
        """
        return pulumi.get(self, "source_application_security_group_ids")

    @property
    @pulumi.getter(name="sourcePortRange")
    def source_port_range(self) -> Optional[str]:
        """
        Source Port or Range. Integer or range between `0` and `65535` or `*` to match any. This is required if `source_port_ranges` is not specified.
        """
        return pulumi.get(self, "source_port_range")

    @property
    @pulumi.getter(name="sourcePortRanges")
    def source_port_ranges(self) -> Optional[Sequence[str]]:
        """
        List of source ports or port ranges. This is required if `source_port_range` is not specified.
        """
        return pulumi.get(self, "source_port_ranges")


@pulumi.output_type
class NetworkWatcherFlowLogRetentionPolicy(dict):
    def __init__(__self__, *,
                 days: int,
                 enabled: bool):
        """
        :param int days: The number of days to retain flow log records.
        :param bool enabled: Boolean flag to enable/disable retention.
        """
        pulumi.set(__self__, "days", days)
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def days(self) -> int:
        """
        The number of days to retain flow log records.
        """
        return pulumi.get(self, "days")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Boolean flag to enable/disable retention.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class NetworkWatcherFlowLogTrafficAnalytics(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workspaceId":
            suggest = "workspace_id"
        elif key == "workspaceRegion":
            suggest = "workspace_region"
        elif key == "workspaceResourceId":
            suggest = "workspace_resource_id"
        elif key == "intervalInMinutes":
            suggest = "interval_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkWatcherFlowLogTrafficAnalytics. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkWatcherFlowLogTrafficAnalytics.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkWatcherFlowLogTrafficAnalytics.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 workspace_id: str,
                 workspace_region: str,
                 workspace_resource_id: str,
                 interval_in_minutes: Optional[int] = None):
        """
        :param bool enabled: Boolean flag to enable/disable traffic analytics.
        :param str workspace_id: The resource GUID of the attached workspace.
        :param str workspace_region: The location of the attached workspace.
        :param str workspace_resource_id: The resource ID of the attached workspace.
        :param int interval_in_minutes: How frequently service should do flow analytics in minutes. Defaults to `60`.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "workspace_id", workspace_id)
        pulumi.set(__self__, "workspace_region", workspace_region)
        pulumi.set(__self__, "workspace_resource_id", workspace_resource_id)
        if interval_in_minutes is not None:
            pulumi.set(__self__, "interval_in_minutes", interval_in_minutes)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Boolean flag to enable/disable traffic analytics.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> str:
        """
        The resource GUID of the attached workspace.
        """
        return pulumi.get(self, "workspace_id")

    @property
    @pulumi.getter(name="workspaceRegion")
    def workspace_region(self) -> str:
        """
        The location of the attached workspace.
        """
        return pulumi.get(self, "workspace_region")

    @property
    @pulumi.getter(name="workspaceResourceId")
    def workspace_resource_id(self) -> str:
        """
        The resource ID of the attached workspace.
        """
        return pulumi.get(self, "workspace_resource_id")

    @property
    @pulumi.getter(name="intervalInMinutes")
    def interval_in_minutes(self) -> Optional[int]:
        """
        How frequently service should do flow analytics in minutes. Defaults to `60`.
        """
        return pulumi.get(self, "interval_in_minutes")


@pulumi.output_type
class PointToPointVpnGatewayConnectionConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vpnClientAddressPool":
            suggest = "vpn_client_address_pool"
        elif key == "internetSecurityEnabled":
            suggest = "internet_security_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PointToPointVpnGatewayConnectionConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PointToPointVpnGatewayConnectionConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PointToPointVpnGatewayConnectionConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 vpn_client_address_pool: 'outputs.PointToPointVpnGatewayConnectionConfigurationVpnClientAddressPool',
                 internet_security_enabled: Optional[bool] = None,
                 route: Optional['outputs.PointToPointVpnGatewayConnectionConfigurationRoute'] = None):
        """
        :param str name: The Name which should be used for this Connection Configuration.
        :param 'PointToPointVpnGatewayConnectionConfigurationVpnClientAddressPoolArgs' vpn_client_address_pool: A `vpn_client_address_pool` block as defined below.
        :param bool internet_security_enabled: Should Internet Security be enabled to secure internet traffic? Changing this forces a new resource to be created. Defaults to `false`.
        :param 'PointToPointVpnGatewayConnectionConfigurationRouteArgs' route: A `route` block as defined below.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "vpn_client_address_pool", vpn_client_address_pool)
        if internet_security_enabled is not None:
            pulumi.set(__self__, "internet_security_enabled", internet_security_enabled)
        if route is not None:
            pulumi.set(__self__, "route", route)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Name which should be used for this Connection Configuration.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="vpnClientAddressPool")
    def vpn_client_address_pool(self) -> 'outputs.PointToPointVpnGatewayConnectionConfigurationVpnClientAddressPool':
        """
        A `vpn_client_address_pool` block as defined below.
        """
        return pulumi.get(self, "vpn_client_address_pool")

    @property
    @pulumi.getter(name="internetSecurityEnabled")
    def internet_security_enabled(self) -> Optional[bool]:
        """
        Should Internet Security be enabled to secure internet traffic? Changing this forces a new resource to be created. Defaults to `false`.
        """
        return pulumi.get(self, "internet_security_enabled")

    @property
    @pulumi.getter
    def route(self) -> Optional['outputs.PointToPointVpnGatewayConnectionConfigurationRoute']:
        """
        A `route` block as defined below.
        """
        return pulumi.get(self, "route")


@pulumi.output_type
class PointToPointVpnGatewayConnectionConfigurationRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "associatedRouteTableId":
            suggest = "associated_route_table_id"
        elif key == "inboundRouteMapId":
            suggest = "inbound_route_map_id"
        elif key == "outboundRouteMapId":
            suggest = "outbound_route_map_id"
        elif key == "propagatedRouteTable":
            suggest = "propagated_route_table"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PointToPointVpnGatewayConnectionConfigurationRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PointToPointVpnGatewayConnectionConfigurationRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PointToPointVpnGatewayConnectionConfigurationRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 associated_route_table_id: str,
                 inbound_route_map_id: Optional[str] = None,
                 outbound_route_map_id: Optional[str] = None,
                 propagated_route_table: Optional['outputs.PointToPointVpnGatewayConnectionConfigurationRoutePropagatedRouteTable'] = None):
        """
        :param str associated_route_table_id: The Virtual Hub Route Table resource id associated with this Routing Configuration.
        :param str inbound_route_map_id: The resource ID of the Route Map associated with this Routing Configuration for inbound learned routes.
        :param str outbound_route_map_id: The resource ID of the Route Map associated with this Routing Configuration for outbound advertised routes.
        :param 'PointToPointVpnGatewayConnectionConfigurationRoutePropagatedRouteTableArgs' propagated_route_table: A `propagated_route_table` block as defined below.
        """
        pulumi.set(__self__, "associated_route_table_id", associated_route_table_id)
        if inbound_route_map_id is not None:
            pulumi.set(__self__, "inbound_route_map_id", inbound_route_map_id)
        if outbound_route_map_id is not None:
            pulumi.set(__self__, "outbound_route_map_id", outbound_route_map_id)
        if propagated_route_table is not None:
            pulumi.set(__self__, "propagated_route_table", propagated_route_table)

    @property
    @pulumi.getter(name="associatedRouteTableId")
    def associated_route_table_id(self) -> str:
        """
        The Virtual Hub Route Table resource id associated with this Routing Configuration.
        """
        return pulumi.get(self, "associated_route_table_id")

    @property
    @pulumi.getter(name="inboundRouteMapId")
    def inbound_route_map_id(self) -> Optional[str]:
        """
        The resource ID of the Route Map associated with this Routing Configuration for inbound learned routes.
        """
        return pulumi.get(self, "inbound_route_map_id")

    @property
    @pulumi.getter(name="outboundRouteMapId")
    def outbound_route_map_id(self) -> Optional[str]:
        """
        The resource ID of the Route Map associated with this Routing Configuration for outbound advertised routes.
        """
        return pulumi.get(self, "outbound_route_map_id")

    @property
    @pulumi.getter(name="propagatedRouteTable")
    def propagated_route_table(self) -> Optional['outputs.PointToPointVpnGatewayConnectionConfigurationRoutePropagatedRouteTable']:
        """
        A `propagated_route_table` block as defined below.
        """
        return pulumi.get(self, "propagated_route_table")


@pulumi.output_type
class PointToPointVpnGatewayConnectionConfigurationRoutePropagatedRouteTable(dict):
    def __init__(__self__, *,
                 ids: Sequence[str],
                 labels: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] ids: The list of Virtual Hub Route Table resource id which the routes will be propagated to.
        :param Sequence[str] labels: The list of labels to logically group Virtual Hub Route Tables which the routes will be propagated to.
        """
        pulumi.set(__self__, "ids", ids)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def ids(self) -> Sequence[str]:
        """
        The list of Virtual Hub Route Table resource id which the routes will be propagated to.
        """
        return pulumi.get(self, "ids")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Sequence[str]]:
        """
        The list of labels to logically group Virtual Hub Route Tables which the routes will be propagated to.
        """
        return pulumi.get(self, "labels")


@pulumi.output_type
class PointToPointVpnGatewayConnectionConfigurationVpnClientAddressPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressPrefixes":
            suggest = "address_prefixes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PointToPointVpnGatewayConnectionConfigurationVpnClientAddressPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PointToPointVpnGatewayConnectionConfigurationVpnClientAddressPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PointToPointVpnGatewayConnectionConfigurationVpnClientAddressPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address_prefixes: Sequence[str]):
        """
        :param Sequence[str] address_prefixes: A list of CIDR Ranges which should be used as Address Prefixes.
        """
        pulumi.set(__self__, "address_prefixes", address_prefixes)

    @property
    @pulumi.getter(name="addressPrefixes")
    def address_prefixes(self) -> Sequence[str]:
        """
        A list of CIDR Ranges which should be used as Address Prefixes.
        """
        return pulumi.get(self, "address_prefixes")


@pulumi.output_type
class ProfileContainerNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipConfigurations":
            suggest = "ip_configurations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProfileContainerNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProfileContainerNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProfileContainerNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_configurations: Sequence['outputs.ProfileContainerNetworkInterfaceIpConfiguration'],
                 name: str):
        """
        :param Sequence['ProfileContainerNetworkInterfaceIpConfigurationArgs'] ip_configurations: One or more `ip_configuration` blocks as documented below.
        :param str name: Specifies the name of the IP Configuration.
        """
        pulumi.set(__self__, "ip_configurations", ip_configurations)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="ipConfigurations")
    def ip_configurations(self) -> Sequence['outputs.ProfileContainerNetworkInterfaceIpConfiguration']:
        """
        One or more `ip_configuration` blocks as documented below.
        """
        return pulumi.get(self, "ip_configurations")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the IP Configuration.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ProfileContainerNetworkInterfaceIpConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProfileContainerNetworkInterfaceIpConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProfileContainerNetworkInterfaceIpConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProfileContainerNetworkInterfaceIpConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 subnet_id: str):
        """
        :param str name: Specifies the name of the IP Configuration.
        :param str subnet_id: Reference to the subnet associated with the IP Configuration.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the IP Configuration.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        Reference to the subnet associated with the IP Configuration.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class RouteFilterRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleType":
            suggest = "rule_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouteFilterRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouteFilterRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouteFilterRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access: str,
                 communities: Sequence[str],
                 name: str,
                 rule_type: str):
        """
        :param str access: The access type of the rule. The only possible value is `Allow`.
        :param Sequence[str] communities: The collection for bgp community values to filter on. e.g. ['12076:5010','12076:5020'].
        :param str name: The name of the route filter rule.
        :param str rule_type: The rule type of the rule. The only possible value is `Community`.
        """
        pulumi.set(__self__, "access", access)
        pulumi.set(__self__, "communities", communities)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "rule_type", rule_type)

    @property
    @pulumi.getter
    def access(self) -> str:
        """
        The access type of the rule. The only possible value is `Allow`.
        """
        return pulumi.get(self, "access")

    @property
    @pulumi.getter
    def communities(self) -> Sequence[str]:
        """
        The collection for bgp community values to filter on. e.g. ['12076:5010','12076:5020'].
        """
        return pulumi.get(self, "communities")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the route filter rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> str:
        """
        The rule type of the rule. The only possible value is `Community`.
        """
        return pulumi.get(self, "rule_type")


@pulumi.output_type
class RouteMapRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchCriterions":
            suggest = "match_criterions"
        elif key == "nextStepIfMatched":
            suggest = "next_step_if_matched"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouteMapRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouteMapRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouteMapRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 actions: Optional[Sequence['outputs.RouteMapRuleAction']] = None,
                 match_criterions: Optional[Sequence['outputs.RouteMapRuleMatchCriterion']] = None,
                 next_step_if_matched: Optional[str] = None):
        """
        :param str name: The unique name for the rule.
        :param Sequence['RouteMapRuleActionArgs'] actions: An `action` block as defined below.
        :param Sequence['RouteMapRuleMatchCriterionArgs'] match_criterions: A `match_criterion` block as defined below.
        :param str next_step_if_matched: The next step after the rule is evaluated. Possible values are `Continue`, `Terminate` and `Unknown`. Defaults to `Unknown`.
        """
        pulumi.set(__self__, "name", name)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if match_criterions is not None:
            pulumi.set(__self__, "match_criterions", match_criterions)
        if next_step_if_matched is not None:
            pulumi.set(__self__, "next_step_if_matched", next_step_if_matched)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The unique name for the rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.RouteMapRuleAction']]:
        """
        An `action` block as defined below.
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="matchCriterions")
    def match_criterions(self) -> Optional[Sequence['outputs.RouteMapRuleMatchCriterion']]:
        """
        A `match_criterion` block as defined below.
        """
        return pulumi.get(self, "match_criterions")

    @property
    @pulumi.getter(name="nextStepIfMatched")
    def next_step_if_matched(self) -> Optional[str]:
        """
        The next step after the rule is evaluated. Possible values are `Continue`, `Terminate` and `Unknown`. Defaults to `Unknown`.
        """
        return pulumi.get(self, "next_step_if_matched")


@pulumi.output_type
class RouteMapRuleAction(dict):
    def __init__(__self__, *,
                 parameters: Sequence['outputs.RouteMapRuleActionParameter'],
                 type: str):
        """
        :param Sequence['RouteMapRuleActionParameterArgs'] parameters: A `parameter` block as defined below.
        :param str type: The type of the action to be taken. Possible values are `Add`, `Drop`, `Remove`, `Replace` and `Unknown`.
        """
        pulumi.set(__self__, "parameters", parameters)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def parameters(self) -> Sequence['outputs.RouteMapRuleActionParameter']:
        """
        A `parameter` block as defined below.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the action to be taken. Possible values are `Add`, `Drop`, `Remove`, `Replace` and `Unknown`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class RouteMapRuleActionParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "asPaths":
            suggest = "as_paths"
        elif key == "routePrefixes":
            suggest = "route_prefixes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouteMapRuleActionParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouteMapRuleActionParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouteMapRuleActionParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 as_paths: Optional[Sequence[str]] = None,
                 communities: Optional[Sequence[str]] = None,
                 route_prefixes: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] as_paths: A list of AS paths.
        :param Sequence[str] communities: A list of BGP communities.
        :param Sequence[str] route_prefixes: A list of route prefixes.
        """
        if as_paths is not None:
            pulumi.set(__self__, "as_paths", as_paths)
        if communities is not None:
            pulumi.set(__self__, "communities", communities)
        if route_prefixes is not None:
            pulumi.set(__self__, "route_prefixes", route_prefixes)

    @property
    @pulumi.getter(name="asPaths")
    def as_paths(self) -> Optional[Sequence[str]]:
        """
        A list of AS paths.
        """
        return pulumi.get(self, "as_paths")

    @property
    @pulumi.getter
    def communities(self) -> Optional[Sequence[str]]:
        """
        A list of BGP communities.
        """
        return pulumi.get(self, "communities")

    @property
    @pulumi.getter(name="routePrefixes")
    def route_prefixes(self) -> Optional[Sequence[str]]:
        """
        A list of route prefixes.
        """
        return pulumi.get(self, "route_prefixes")


@pulumi.output_type
class RouteMapRuleMatchCriterion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchCondition":
            suggest = "match_condition"
        elif key == "asPaths":
            suggest = "as_paths"
        elif key == "routePrefixes":
            suggest = "route_prefixes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouteMapRuleMatchCriterion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouteMapRuleMatchCriterion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouteMapRuleMatchCriterion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_condition: str,
                 as_paths: Optional[Sequence[str]] = None,
                 communities: Optional[Sequence[str]] = None,
                 route_prefixes: Optional[Sequence[str]] = None):
        """
        :param str match_condition: The match condition to apply the rule of the Route Map. Possible values are `Contains`, `Equals`, `NotContains`, `NotEquals` and `Unknown`.
        :param Sequence[str] as_paths: A list of AS paths which this criterion matches.
        :param Sequence[str] communities: A list of BGP communities which this criterion matches.
        :param Sequence[str] route_prefixes: A list of route prefixes which this criterion matches.
        """
        pulumi.set(__self__, "match_condition", match_condition)
        if as_paths is not None:
            pulumi.set(__self__, "as_paths", as_paths)
        if communities is not None:
            pulumi.set(__self__, "communities", communities)
        if route_prefixes is not None:
            pulumi.set(__self__, "route_prefixes", route_prefixes)

    @property
    @pulumi.getter(name="matchCondition")
    def match_condition(self) -> str:
        """
        The match condition to apply the rule of the Route Map. Possible values are `Contains`, `Equals`, `NotContains`, `NotEquals` and `Unknown`.
        """
        return pulumi.get(self, "match_condition")

    @property
    @pulumi.getter(name="asPaths")
    def as_paths(self) -> Optional[Sequence[str]]:
        """
        A list of AS paths which this criterion matches.
        """
        return pulumi.get(self, "as_paths")

    @property
    @pulumi.getter
    def communities(self) -> Optional[Sequence[str]]:
        """
        A list of BGP communities which this criterion matches.
        """
        return pulumi.get(self, "communities")

    @property
    @pulumi.getter(name="routePrefixes")
    def route_prefixes(self) -> Optional[Sequence[str]]:
        """
        A list of route prefixes which this criterion matches.
        """
        return pulumi.get(self, "route_prefixes")


@pulumi.output_type
class RouteTableRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressPrefix":
            suggest = "address_prefix"
        elif key == "nextHopType":
            suggest = "next_hop_type"
        elif key == "nextHopInIpAddress":
            suggest = "next_hop_in_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouteTableRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouteTableRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouteTableRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address_prefix: str,
                 name: str,
                 next_hop_type: str,
                 next_hop_in_ip_address: Optional[str] = None):
        """
        :param str address_prefix: The destination to which the route applies. Can be CIDR (such as `10.1.0.0/16`) or [Azure Service Tag](https://docs.microsoft.com/azure/virtual-network/service-tags-overview) (such as `ApiManagement`, `AzureBackup` or `AzureMonitor`) format.
        :param str name: The name of the route.
        :param str next_hop_type: The type of Azure hop the packet should be sent to. Possible values are `VirtualNetworkGateway`, `VnetLocal`, `Internet`, `VirtualAppliance` and `None`.
        :param str next_hop_in_ip_address: Contains the IP address packets should be forwarded to. Next hop values are only allowed in routes where the next hop type is `VirtualAppliance`.
        """
        pulumi.set(__self__, "address_prefix", address_prefix)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "next_hop_type", next_hop_type)
        if next_hop_in_ip_address is not None:
            pulumi.set(__self__, "next_hop_in_ip_address", next_hop_in_ip_address)

    @property
    @pulumi.getter(name="addressPrefix")
    def address_prefix(self) -> str:
        """
        The destination to which the route applies. Can be CIDR (such as `10.1.0.0/16`) or [Azure Service Tag](https://docs.microsoft.com/azure/virtual-network/service-tags-overview) (such as `ApiManagement`, `AzureBackup` or `AzureMonitor`) format.
        """
        return pulumi.get(self, "address_prefix")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the route.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nextHopType")
    def next_hop_type(self) -> str:
        """
        The type of Azure hop the packet should be sent to. Possible values are `VirtualNetworkGateway`, `VnetLocal`, `Internet`, `VirtualAppliance` and `None`.
        """
        return pulumi.get(self, "next_hop_type")

    @property
    @pulumi.getter(name="nextHopInIpAddress")
    def next_hop_in_ip_address(self) -> Optional[str]:
        """
        Contains the IP address packets should be forwarded to. Next hop values are only allowed in routes where the next hop type is `VirtualAppliance`.
        """
        return pulumi.get(self, "next_hop_in_ip_address")


@pulumi.output_type
class RoutingIntentRoutingPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nextHop":
            suggest = "next_hop"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RoutingIntentRoutingPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RoutingIntentRoutingPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RoutingIntentRoutingPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destinations: Sequence[str],
                 name: str,
                 next_hop: str):
        """
        :param Sequence[str] destinations: A list of destinations which this routing policy is applicable to. Possible values are `Internet` and `PrivateTraffic`.
        :param str name: The unique name for the routing policy.
        :param str next_hop: The resource ID of the next hop on which this routing policy is applicable to.
        """
        pulumi.set(__self__, "destinations", destinations)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "next_hop", next_hop)

    @property
    @pulumi.getter
    def destinations(self) -> Sequence[str]:
        """
        A list of destinations which this routing policy is applicable to. Possible values are `Internet` and `PrivateTraffic`.
        """
        return pulumi.get(self, "destinations")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The unique name for the routing policy.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nextHop")
    def next_hop(self) -> str:
        """
        The resource ID of the next hop on which this routing policy is applicable to.
        """
        return pulumi.get(self, "next_hop")


@pulumi.output_type
class SubnetDelegation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceDelegation":
            suggest = "service_delegation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SubnetDelegation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SubnetDelegation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SubnetDelegation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 service_delegation: 'outputs.SubnetDelegationServiceDelegation'):
        """
        :param str name: A name for this delegation.
        :param 'SubnetDelegationServiceDelegationArgs' service_delegation: A `service_delegation` block as defined below.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service_delegation", service_delegation)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A name for this delegation.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="serviceDelegation")
    def service_delegation(self) -> 'outputs.SubnetDelegationServiceDelegation':
        """
        A `service_delegation` block as defined below.
        """
        return pulumi.get(self, "service_delegation")


@pulumi.output_type
class SubnetDelegationServiceDelegation(dict):
    def __init__(__self__, *,
                 name: str,
                 actions: Optional[Sequence[str]] = None):
        """
        :param str name: The name of service to delegate to. Possible values are `GitHub.Network/networkSettings`, `Microsoft.ApiManagement/service`, `Microsoft.Apollo/npu`, `Microsoft.App/environments`, `Microsoft.App/testClients`, `Microsoft.AVS/PrivateClouds`, `Microsoft.AzureCosmosDB/clusters`, `Microsoft.BareMetal/AzureHostedService`, `Microsoft.BareMetal/AzureHPC`, `Microsoft.BareMetal/AzurePaymentHSM`, `Microsoft.BareMetal/AzureVMware`, `Microsoft.BareMetal/CrayServers`, `Microsoft.BareMetal/MonitoringServers`, `Microsoft.Batch/batchAccounts`, `Microsoft.CloudTest/hostedpools`, `Microsoft.CloudTest/images`, `Microsoft.CloudTest/pools`, `Microsoft.Codespaces/plans`, `Microsoft.ContainerInstance/containerGroups`, `Microsoft.ContainerService/managedClusters`, `Microsoft.ContainerService/TestClients`, `Microsoft.Databricks/workspaces`, `Microsoft.DBforMySQL/flexibleServers`, `Microsoft.DBforMySQL/servers`, `Microsoft.DBforMySQL/serversv2`, `Microsoft.DBforPostgreSQL/flexibleServers`, `Microsoft.DBforPostgreSQL/serversv2`, `Microsoft.DBforPostgreSQL/singleServers`, `Microsoft.DelegatedNetwork/controller`, `Microsoft.DevCenter/networkConnection`, `Microsoft.DocumentDB/cassandraClusters`, `Microsoft.Fidalgo/networkSettings`, `Microsoft.HardwareSecurityModules/dedicatedHSMs`, `Microsoft.Kusto/clusters`, `Microsoft.LabServices/labplans`, `Microsoft.Logic/integrationServiceEnvironments`, `Microsoft.MachineLearningServices/workspaces`, `Microsoft.Netapp/volumes`, `Microsoft.Network/dnsResolvers`, `Microsoft.Network/fpgaNetworkInterfaces`, `Microsoft.Network/networkWatchers.`, `Microsoft.Network/virtualNetworkGateways`, `Microsoft.Orbital/orbitalGateways`, `Microsoft.PowerPlatform/enterprisePolicies`, `Microsoft.PowerPlatform/vnetaccesslinks`, `Microsoft.ServiceFabricMesh/networks`, `Microsoft.ServiceNetworking/trafficControllers`, `Microsoft.Singularity/accounts/networks`, `Microsoft.Singularity/accounts/npu`, `Microsoft.Sql/managedInstances`, `Microsoft.Sql/managedInstancesOnebox`, `Microsoft.Sql/managedInstancesStage`, `Microsoft.Sql/managedInstancesTest`, `Microsoft.StoragePool/diskPools`, `Microsoft.StreamAnalytics/streamingJobs`, `Microsoft.Synapse/workspaces`, `Microsoft.Web/hostingEnvironments`, `Microsoft.Web/serverFarms`, `NGINX.NGINXPLUS/nginxDeployments`, `PaloAltoNetworks.Cloudngfw/firewalls`, and `Qumulo.Storage/fileSystems`.
        :param Sequence[str] actions: A list of Actions which should be delegated. This list is specific to the service to delegate to. Possible values are `Microsoft.Network/networkinterfaces/*`, `Microsoft.Network/publicIPAddresses/join/action`, `Microsoft.Network/publicIPAddresses/read`, `Microsoft.Network/virtualNetworks/read`, `Microsoft.Network/virtualNetworks/subnets/action`, `Microsoft.Network/virtualNetworks/subnets/join/action`, `Microsoft.Network/virtualNetworks/subnets/prepareNetworkPolicies/action`, and `Microsoft.Network/virtualNetworks/subnets/unprepareNetworkPolicies/action`.
               
               > **NOTE:** Azure may add default actions depending on the service delegation name and they can't be changed.
        """
        pulumi.set(__self__, "name", name)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of service to delegate to. Possible values are `GitHub.Network/networkSettings`, `Microsoft.ApiManagement/service`, `Microsoft.Apollo/npu`, `Microsoft.App/environments`, `Microsoft.App/testClients`, `Microsoft.AVS/PrivateClouds`, `Microsoft.AzureCosmosDB/clusters`, `Microsoft.BareMetal/AzureHostedService`, `Microsoft.BareMetal/AzureHPC`, `Microsoft.BareMetal/AzurePaymentHSM`, `Microsoft.BareMetal/AzureVMware`, `Microsoft.BareMetal/CrayServers`, `Microsoft.BareMetal/MonitoringServers`, `Microsoft.Batch/batchAccounts`, `Microsoft.CloudTest/hostedpools`, `Microsoft.CloudTest/images`, `Microsoft.CloudTest/pools`, `Microsoft.Codespaces/plans`, `Microsoft.ContainerInstance/containerGroups`, `Microsoft.ContainerService/managedClusters`, `Microsoft.ContainerService/TestClients`, `Microsoft.Databricks/workspaces`, `Microsoft.DBforMySQL/flexibleServers`, `Microsoft.DBforMySQL/servers`, `Microsoft.DBforMySQL/serversv2`, `Microsoft.DBforPostgreSQL/flexibleServers`, `Microsoft.DBforPostgreSQL/serversv2`, `Microsoft.DBforPostgreSQL/singleServers`, `Microsoft.DelegatedNetwork/controller`, `Microsoft.DevCenter/networkConnection`, `Microsoft.DocumentDB/cassandraClusters`, `Microsoft.Fidalgo/networkSettings`, `Microsoft.HardwareSecurityModules/dedicatedHSMs`, `Microsoft.Kusto/clusters`, `Microsoft.LabServices/labplans`, `Microsoft.Logic/integrationServiceEnvironments`, `Microsoft.MachineLearningServices/workspaces`, `Microsoft.Netapp/volumes`, `Microsoft.Network/dnsResolvers`, `Microsoft.Network/fpgaNetworkInterfaces`, `Microsoft.Network/networkWatchers.`, `Microsoft.Network/virtualNetworkGateways`, `Microsoft.Orbital/orbitalGateways`, `Microsoft.PowerPlatform/enterprisePolicies`, `Microsoft.PowerPlatform/vnetaccesslinks`, `Microsoft.ServiceFabricMesh/networks`, `Microsoft.ServiceNetworking/trafficControllers`, `Microsoft.Singularity/accounts/networks`, `Microsoft.Singularity/accounts/npu`, `Microsoft.Sql/managedInstances`, `Microsoft.Sql/managedInstancesOnebox`, `Microsoft.Sql/managedInstancesStage`, `Microsoft.Sql/managedInstancesTest`, `Microsoft.StoragePool/diskPools`, `Microsoft.StreamAnalytics/streamingJobs`, `Microsoft.Synapse/workspaces`, `Microsoft.Web/hostingEnvironments`, `Microsoft.Web/serverFarms`, `NGINX.NGINXPLUS/nginxDeployments`, `PaloAltoNetworks.Cloudngfw/firewalls`, and `Qumulo.Storage/fileSystems`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence[str]]:
        """
        A list of Actions which should be delegated. This list is specific to the service to delegate to. Possible values are `Microsoft.Network/networkinterfaces/*`, `Microsoft.Network/publicIPAddresses/join/action`, `Microsoft.Network/publicIPAddresses/read`, `Microsoft.Network/virtualNetworks/read`, `Microsoft.Network/virtualNetworks/subnets/action`, `Microsoft.Network/virtualNetworks/subnets/join/action`, `Microsoft.Network/virtualNetworks/subnets/prepareNetworkPolicies/action`, and `Microsoft.Network/virtualNetworks/subnets/unprepareNetworkPolicies/action`.

        > **NOTE:** Azure may add default actions depending on the service delegation name and they can't be changed.
        """
        return pulumi.get(self, "actions")


@pulumi.output_type
class SubnetServiceEndpointStoragePolicyDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceResources":
            suggest = "service_resources"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SubnetServiceEndpointStoragePolicyDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SubnetServiceEndpointStoragePolicyDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SubnetServiceEndpointStoragePolicyDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 service_resources: Sequence[str],
                 description: Optional[str] = None,
                 service: Optional[str] = None):
        """
        :param str name: The name which should be used for this Subnet Service Endpoint Storage Policy Definition.
        :param Sequence[str] service_resources: Specifies a list of resources or aliases that this Subnet Service Endpoint Storage Policy Definition applies to.
               
               > **NOTE** The `service_resources` property must contain either Aliases or Resource IDs, but not both.
        :param str description: The description of this Subnet Service Endpoint Storage Policy Definition.
        :param str service: The type of service resources. Valid values are `Microsoft.Storage` or `Global`. When the `service_resources` property contains resource IDs, this property must be `Microsoft.Storage`. When the `service_resources` property contains Aliases, this property must be `Global`. Defaults to `Microsoft.Storage`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service_resources", service_resources)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this Subnet Service Endpoint Storage Policy Definition.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="serviceResources")
    def service_resources(self) -> Sequence[str]:
        """
        Specifies a list of resources or aliases that this Subnet Service Endpoint Storage Policy Definition applies to.

        > **NOTE** The `service_resources` property must contain either Aliases or Resource IDs, but not both.
        """
        return pulumi.get(self, "service_resources")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of this Subnet Service Endpoint Storage Policy Definition.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        The type of service resources. Valid values are `Microsoft.Storage` or `Global`. When the `service_resources` property contains resource IDs, this property must be `Microsoft.Storage`. When the `service_resources` property contains Aliases, this property must be `Global`. Defaults to `Microsoft.Storage`.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class TrafficManagerAzureEndpointCustomHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: The name of the custom header.
        :param str value: The value of custom header. Applicable for HTTP and HTTPS protocol.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the custom header.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of custom header. Applicable for HTTP and HTTPS protocol.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class TrafficManagerAzureEndpointSubnet(dict):
    def __init__(__self__, *,
                 first: str,
                 last: Optional[str] = None,
                 scope: Optional[int] = None):
        """
        :param str first: The first IP Address in this subnet.
        :param str last: The last IP Address in this subnet.
        :param int scope: The block size (number of leading bits in the subnet mask).
        """
        pulumi.set(__self__, "first", first)
        if last is not None:
            pulumi.set(__self__, "last", last)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter
    def first(self) -> str:
        """
        The first IP Address in this subnet.
        """
        return pulumi.get(self, "first")

    @property
    @pulumi.getter
    def last(self) -> Optional[str]:
        """
        The last IP Address in this subnet.
        """
        return pulumi.get(self, "last")

    @property
    @pulumi.getter
    def scope(self) -> Optional[int]:
        """
        The block size (number of leading bits in the subnet mask).
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class TrafficManagerExternalEndpointCustomHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: The name of the custom header.
        :param str value: The value of custom header. Applicable for HTTP and HTTPS protocol.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the custom header.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of custom header. Applicable for HTTP and HTTPS protocol.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class TrafficManagerExternalEndpointSubnet(dict):
    def __init__(__self__, *,
                 first: str,
                 last: Optional[str] = None,
                 scope: Optional[int] = None):
        """
        :param str first: The first IP Address in this subnet.
        :param str last: The last IP Address in this subnet.
        :param int scope: The block size (number of leading bits in the subnet mask).
        """
        pulumi.set(__self__, "first", first)
        if last is not None:
            pulumi.set(__self__, "last", last)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter
    def first(self) -> str:
        """
        The first IP Address in this subnet.
        """
        return pulumi.get(self, "first")

    @property
    @pulumi.getter
    def last(self) -> Optional[str]:
        """
        The last IP Address in this subnet.
        """
        return pulumi.get(self, "last")

    @property
    @pulumi.getter
    def scope(self) -> Optional[int]:
        """
        The block size (number of leading bits in the subnet mask).
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class TrafficManagerNestedEndpointCustomHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: The name of the custom header.
        :param str value: The value of custom header. Applicable for HTTP and HTTPS protocol.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the custom header.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of custom header. Applicable for HTTP and HTTPS protocol.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class TrafficManagerNestedEndpointSubnet(dict):
    def __init__(__self__, *,
                 first: str,
                 last: Optional[str] = None,
                 scope: Optional[int] = None):
        """
        :param str first: The first IP Address in this subnet.
        :param str last: The last IP Address in this subnet.
        :param int scope: The block size (number of leading bits in the subnet mask).
        """
        pulumi.set(__self__, "first", first)
        if last is not None:
            pulumi.set(__self__, "last", last)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter
    def first(self) -> str:
        """
        The first IP Address in this subnet.
        """
        return pulumi.get(self, "first")

    @property
    @pulumi.getter
    def last(self) -> Optional[str]:
        """
        The last IP Address in this subnet.
        """
        return pulumi.get(self, "last")

    @property
    @pulumi.getter
    def scope(self) -> Optional[int]:
        """
        The block size (number of leading bits in the subnet mask).
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class TrafficManagerProfileDnsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "relativeName":
            suggest = "relative_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TrafficManagerProfileDnsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TrafficManagerProfileDnsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TrafficManagerProfileDnsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 relative_name: str,
                 ttl: int):
        """
        :param str relative_name: The relative domain name, this is combined with the domain name used by Traffic Manager to form the FQDN which is exported as documented below. Changing this forces a new resource to be created.
        :param int ttl: The TTL value of the Profile used by Local DNS resolvers and clients.
        """
        pulumi.set(__self__, "relative_name", relative_name)
        pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter(name="relativeName")
    def relative_name(self) -> str:
        """
        The relative domain name, this is combined with the domain name used by Traffic Manager to form the FQDN which is exported as documented below. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "relative_name")

    @property
    @pulumi.getter
    def ttl(self) -> int:
        """
        The TTL value of the Profile used by Local DNS resolvers and clients.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class TrafficManagerProfileMonitorConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHeaders":
            suggest = "custom_headers"
        elif key == "expectedStatusCodeRanges":
            suggest = "expected_status_code_ranges"
        elif key == "intervalInSeconds":
            suggest = "interval_in_seconds"
        elif key == "timeoutInSeconds":
            suggest = "timeout_in_seconds"
        elif key == "toleratedNumberOfFailures":
            suggest = "tolerated_number_of_failures"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TrafficManagerProfileMonitorConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TrafficManagerProfileMonitorConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TrafficManagerProfileMonitorConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port: int,
                 protocol: str,
                 custom_headers: Optional[Sequence['outputs.TrafficManagerProfileMonitorConfigCustomHeader']] = None,
                 expected_status_code_ranges: Optional[Sequence[str]] = None,
                 interval_in_seconds: Optional[int] = None,
                 path: Optional[str] = None,
                 timeout_in_seconds: Optional[int] = None,
                 tolerated_number_of_failures: Optional[int] = None):
        """
        :param int port: The port number used by the monitoring checks.
        :param str protocol: The protocol used by the monitoring checks, supported values are `HTTP`, `HTTPS` and `TCP`.
        :param Sequence['TrafficManagerProfileMonitorConfigCustomHeaderArgs'] custom_headers: One or more `custom_header` blocks as defined below.
        :param Sequence[str] expected_status_code_ranges: A list of status code ranges in the format of `100-101`.
        :param int interval_in_seconds: The interval used to check the endpoint health from a Traffic Manager probing agent. You can specify two values here: `30` (normal probing) and `10` (fast probing). The default value is `30`.
        :param str path: The path used by the monitoring checks. Required when `protocol` is set to `HTTP` or `HTTPS` - cannot be set when `protocol` is set to `TCP`.
        :param int timeout_in_seconds: The amount of time the Traffic Manager probing agent should wait before considering that check a failure when a health check probe is sent to the endpoint. If `interval_in_seconds` is set to `30`, then `timeout_in_seconds` can be between `5` and `10`. The default value is `10`. If `interval_in_seconds` is set to `10`, then valid values are between `5` and `9` and `timeout_in_seconds` is required.
        :param int tolerated_number_of_failures: The number of failures a Traffic Manager probing agent tolerates before marking that endpoint as unhealthy. Valid values are between `0` and `9`. The default value is `3`
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        if custom_headers is not None:
            pulumi.set(__self__, "custom_headers", custom_headers)
        if expected_status_code_ranges is not None:
            pulumi.set(__self__, "expected_status_code_ranges", expected_status_code_ranges)
        if interval_in_seconds is not None:
            pulumi.set(__self__, "interval_in_seconds", interval_in_seconds)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if timeout_in_seconds is not None:
            pulumi.set(__self__, "timeout_in_seconds", timeout_in_seconds)
        if tolerated_number_of_failures is not None:
            pulumi.set(__self__, "tolerated_number_of_failures", tolerated_number_of_failures)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port number used by the monitoring checks.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The protocol used by the monitoring checks, supported values are `HTTP`, `HTTPS` and `TCP`.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="customHeaders")
    def custom_headers(self) -> Optional[Sequence['outputs.TrafficManagerProfileMonitorConfigCustomHeader']]:
        """
        One or more `custom_header` blocks as defined below.
        """
        return pulumi.get(self, "custom_headers")

    @property
    @pulumi.getter(name="expectedStatusCodeRanges")
    def expected_status_code_ranges(self) -> Optional[Sequence[str]]:
        """
        A list of status code ranges in the format of `100-101`.
        """
        return pulumi.get(self, "expected_status_code_ranges")

    @property
    @pulumi.getter(name="intervalInSeconds")
    def interval_in_seconds(self) -> Optional[int]:
        """
        The interval used to check the endpoint health from a Traffic Manager probing agent. You can specify two values here: `30` (normal probing) and `10` (fast probing). The default value is `30`.
        """
        return pulumi.get(self, "interval_in_seconds")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path used by the monitoring checks. Required when `protocol` is set to `HTTP` or `HTTPS` - cannot be set when `protocol` is set to `TCP`.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> Optional[int]:
        """
        The amount of time the Traffic Manager probing agent should wait before considering that check a failure when a health check probe is sent to the endpoint. If `interval_in_seconds` is set to `30`, then `timeout_in_seconds` can be between `5` and `10`. The default value is `10`. If `interval_in_seconds` is set to `10`, then valid values are between `5` and `9` and `timeout_in_seconds` is required.
        """
        return pulumi.get(self, "timeout_in_seconds")

    @property
    @pulumi.getter(name="toleratedNumberOfFailures")
    def tolerated_number_of_failures(self) -> Optional[int]:
        """
        The number of failures a Traffic Manager probing agent tolerates before marking that endpoint as unhealthy. Valid values are between `0` and `9`. The default value is `3`
        """
        return pulumi.get(self, "tolerated_number_of_failures")


@pulumi.output_type
class TrafficManagerProfileMonitorConfigCustomHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: The name of the custom header.
        :param str value: The value of custom header. Applicable for HTTP and HTTPS protocol.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the custom header.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of custom header. Applicable for HTTP and HTTPS protocol.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class VirtualHubConnectionRouting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "associatedRouteTableId":
            suggest = "associated_route_table_id"
        elif key == "inboundRouteMapId":
            suggest = "inbound_route_map_id"
        elif key == "outboundRouteMapId":
            suggest = "outbound_route_map_id"
        elif key == "propagatedRouteTable":
            suggest = "propagated_route_table"
        elif key == "staticVnetLocalRouteOverrideCriteria":
            suggest = "static_vnet_local_route_override_criteria"
        elif key == "staticVnetRoutes":
            suggest = "static_vnet_routes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualHubConnectionRouting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualHubConnectionRouting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualHubConnectionRouting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 associated_route_table_id: Optional[str] = None,
                 inbound_route_map_id: Optional[str] = None,
                 outbound_route_map_id: Optional[str] = None,
                 propagated_route_table: Optional['outputs.VirtualHubConnectionRoutingPropagatedRouteTable'] = None,
                 static_vnet_local_route_override_criteria: Optional[str] = None,
                 static_vnet_routes: Optional[Sequence['outputs.VirtualHubConnectionRoutingStaticVnetRoute']] = None):
        """
        :param str associated_route_table_id: The ID of the route table associated with this Virtual Hub connection.
        :param str inbound_route_map_id: The resource ID of the Route Map associated with this Routing Configuration for inbound learned routes.
        :param str outbound_route_map_id: The resource ID of the Route Map associated with this Routing Configuration for outbound advertised routes.
        :param 'VirtualHubConnectionRoutingPropagatedRouteTableArgs' propagated_route_table: A `propagated_route_table` block as defined below.
        :param str static_vnet_local_route_override_criteria: The static VNet local route override criteria that is used to determine whether NVA in spoke VNet is bypassed for traffic with destination in spoke VNet. Possible values are `Contains` and `Equal`. Defaults to `Contains`. Changing this forces a new resource to be created.
        :param Sequence['VirtualHubConnectionRoutingStaticVnetRouteArgs'] static_vnet_routes: A `static_vnet_route` block as defined below.
        """
        if associated_route_table_id is not None:
            pulumi.set(__self__, "associated_route_table_id", associated_route_table_id)
        if inbound_route_map_id is not None:
            pulumi.set(__self__, "inbound_route_map_id", inbound_route_map_id)
        if outbound_route_map_id is not None:
            pulumi.set(__self__, "outbound_route_map_id", outbound_route_map_id)
        if propagated_route_table is not None:
            pulumi.set(__self__, "propagated_route_table", propagated_route_table)
        if static_vnet_local_route_override_criteria is not None:
            pulumi.set(__self__, "static_vnet_local_route_override_criteria", static_vnet_local_route_override_criteria)
        if static_vnet_routes is not None:
            pulumi.set(__self__, "static_vnet_routes", static_vnet_routes)

    @property
    @pulumi.getter(name="associatedRouteTableId")
    def associated_route_table_id(self) -> Optional[str]:
        """
        The ID of the route table associated with this Virtual Hub connection.
        """
        return pulumi.get(self, "associated_route_table_id")

    @property
    @pulumi.getter(name="inboundRouteMapId")
    def inbound_route_map_id(self) -> Optional[str]:
        """
        The resource ID of the Route Map associated with this Routing Configuration for inbound learned routes.
        """
        return pulumi.get(self, "inbound_route_map_id")

    @property
    @pulumi.getter(name="outboundRouteMapId")
    def outbound_route_map_id(self) -> Optional[str]:
        """
        The resource ID of the Route Map associated with this Routing Configuration for outbound advertised routes.
        """
        return pulumi.get(self, "outbound_route_map_id")

    @property
    @pulumi.getter(name="propagatedRouteTable")
    def propagated_route_table(self) -> Optional['outputs.VirtualHubConnectionRoutingPropagatedRouteTable']:
        """
        A `propagated_route_table` block as defined below.
        """
        return pulumi.get(self, "propagated_route_table")

    @property
    @pulumi.getter(name="staticVnetLocalRouteOverrideCriteria")
    def static_vnet_local_route_override_criteria(self) -> Optional[str]:
        """
        The static VNet local route override criteria that is used to determine whether NVA in spoke VNet is bypassed for traffic with destination in spoke VNet. Possible values are `Contains` and `Equal`. Defaults to `Contains`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "static_vnet_local_route_override_criteria")

    @property
    @pulumi.getter(name="staticVnetRoutes")
    def static_vnet_routes(self) -> Optional[Sequence['outputs.VirtualHubConnectionRoutingStaticVnetRoute']]:
        """
        A `static_vnet_route` block as defined below.
        """
        return pulumi.get(self, "static_vnet_routes")


@pulumi.output_type
class VirtualHubConnectionRoutingPropagatedRouteTable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "routeTableIds":
            suggest = "route_table_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualHubConnectionRoutingPropagatedRouteTable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualHubConnectionRoutingPropagatedRouteTable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualHubConnectionRoutingPropagatedRouteTable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 labels: Optional[Sequence[str]] = None,
                 route_table_ids: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] labels: The list of labels to assign to this route table.
        :param Sequence[str] route_table_ids: A list of Route Table IDs to associated with this Virtual Hub Connection.
        """
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if route_table_ids is not None:
            pulumi.set(__self__, "route_table_ids", route_table_ids)

    @property
    @pulumi.getter
    def labels(self) -> Optional[Sequence[str]]:
        """
        The list of labels to assign to this route table.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="routeTableIds")
    def route_table_ids(self) -> Optional[Sequence[str]]:
        """
        A list of Route Table IDs to associated with this Virtual Hub Connection.
        """
        return pulumi.get(self, "route_table_ids")


@pulumi.output_type
class VirtualHubConnectionRoutingStaticVnetRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressPrefixes":
            suggest = "address_prefixes"
        elif key == "nextHopIpAddress":
            suggest = "next_hop_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualHubConnectionRoutingStaticVnetRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualHubConnectionRoutingStaticVnetRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualHubConnectionRoutingStaticVnetRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address_prefixes: Optional[Sequence[str]] = None,
                 name: Optional[str] = None,
                 next_hop_ip_address: Optional[str] = None):
        """
        :param Sequence[str] address_prefixes: A list of CIDR Ranges which should be used as Address Prefixes.
        :param str name: The name which should be used for this Static Route.
        :param str next_hop_ip_address: The IP Address which should be used for the Next Hop.
        """
        if address_prefixes is not None:
            pulumi.set(__self__, "address_prefixes", address_prefixes)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if next_hop_ip_address is not None:
            pulumi.set(__self__, "next_hop_ip_address", next_hop_ip_address)

    @property
    @pulumi.getter(name="addressPrefixes")
    def address_prefixes(self) -> Optional[Sequence[str]]:
        """
        A list of CIDR Ranges which should be used as Address Prefixes.
        """
        return pulumi.get(self, "address_prefixes")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name which should be used for this Static Route.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nextHopIpAddress")
    def next_hop_ip_address(self) -> Optional[str]:
        """
        The IP Address which should be used for the Next Hop.
        """
        return pulumi.get(self, "next_hop_ip_address")


@pulumi.output_type
class VirtualHubRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressPrefixes":
            suggest = "address_prefixes"
        elif key == "nextHopIpAddress":
            suggest = "next_hop_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualHubRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualHubRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualHubRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address_prefixes: Sequence[str],
                 next_hop_ip_address: str):
        """
        :param Sequence[str] address_prefixes: A list of Address Prefixes.
        :param str next_hop_ip_address: The IP Address that Packets should be forwarded to as the Next Hop.
        """
        pulumi.set(__self__, "address_prefixes", address_prefixes)
        pulumi.set(__self__, "next_hop_ip_address", next_hop_ip_address)

    @property
    @pulumi.getter(name="addressPrefixes")
    def address_prefixes(self) -> Sequence[str]:
        """
        A list of Address Prefixes.
        """
        return pulumi.get(self, "address_prefixes")

    @property
    @pulumi.getter(name="nextHopIpAddress")
    def next_hop_ip_address(self) -> str:
        """
        The IP Address that Packets should be forwarded to as the Next Hop.
        """
        return pulumi.get(self, "next_hop_ip_address")


@pulumi.output_type
class VirtualHubRouteTableRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationsType":
            suggest = "destinations_type"
        elif key == "nextHop":
            suggest = "next_hop"
        elif key == "nextHopType":
            suggest = "next_hop_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualHubRouteTableRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualHubRouteTableRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualHubRouteTableRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destinations: Sequence[str],
                 destinations_type: str,
                 name: str,
                 next_hop: str,
                 next_hop_type: Optional[str] = None):
        """
        :param Sequence[str] destinations: A list of destination addresses for this route.
        :param str destinations_type: The type of destinations. Possible values are `CIDR`, `ResourceId` and `Service`.
        :param str name: The name which should be used for this route.
        :param str next_hop: The next hop's resource ID.
        :param str next_hop_type: The type of next hop. Currently the only possible value is `ResourceId`. Defaults to `ResourceId`.
               
               > **Note:** The Routes can alternatively be created using the virtual_hub_route_table_route resource. Using both inline and external routes is not supported and may result in unexpected configuration.
        """
        pulumi.set(__self__, "destinations", destinations)
        pulumi.set(__self__, "destinations_type", destinations_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "next_hop", next_hop)
        if next_hop_type is not None:
            pulumi.set(__self__, "next_hop_type", next_hop_type)

    @property
    @pulumi.getter
    def destinations(self) -> Sequence[str]:
        """
        A list of destination addresses for this route.
        """
        return pulumi.get(self, "destinations")

    @property
    @pulumi.getter(name="destinationsType")
    def destinations_type(self) -> str:
        """
        The type of destinations. Possible values are `CIDR`, `ResourceId` and `Service`.
        """
        return pulumi.get(self, "destinations_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this route.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nextHop")
    def next_hop(self) -> str:
        """
        The next hop's resource ID.
        """
        return pulumi.get(self, "next_hop")

    @property
    @pulumi.getter(name="nextHopType")
    def next_hop_type(self) -> Optional[str]:
        """
        The type of next hop. Currently the only possible value is `ResourceId`. Defaults to `ResourceId`.

        > **Note:** The Routes can alternatively be created using the virtual_hub_route_table_route resource. Using both inline and external routes is not supported and may result in unexpected configuration.
        """
        return pulumi.get(self, "next_hop_type")


@pulumi.output_type
class VirtualNetworkDdosProtectionPlan(dict):
    def __init__(__self__, *,
                 enable: bool,
                 id: str):
        """
        :param bool enable: Enable/disable DDoS Protection Plan on Virtual Network.
        :param str id: The ID of DDoS Protection Plan.
        """
        pulumi.set(__self__, "enable", enable)
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def enable(self) -> bool:
        """
        Enable/disable DDoS Protection Plan on Virtual Network.
        """
        return pulumi.get(self, "enable")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of DDoS Protection Plan.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class VirtualNetworkEncryption(dict):
    def __init__(__self__, *,
                 enforcement: str):
        """
        :param str enforcement: Specifies if the encrypted Virtual Network allows VM that does not support encryption. Possible values are `DropUnencrypted` and `AllowUnencrypted`.
        """
        pulumi.set(__self__, "enforcement", enforcement)

    @property
    @pulumi.getter
    def enforcement(self) -> str:
        """
        Specifies if the encrypted Virtual Network allows VM that does not support encryption. Possible values are `DropUnencrypted` and `AllowUnencrypted`.
        """
        return pulumi.get(self, "enforcement")


@pulumi.output_type
class VirtualNetworkGatewayBgpSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "peerWeight":
            suggest = "peer_weight"
        elif key == "peeringAddresses":
            suggest = "peering_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNetworkGatewayBgpSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNetworkGatewayBgpSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNetworkGatewayBgpSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 asn: Optional[int] = None,
                 peer_weight: Optional[int] = None,
                 peering_addresses: Optional[Sequence['outputs.VirtualNetworkGatewayBgpSettingsPeeringAddress']] = None):
        """
        :param int asn: The Autonomous System Number (ASN) to use as part of the BGP.
        :param int peer_weight: The weight added to routes which have been learned through BGP peering. Valid values can be between `0` and `100`.
        :param Sequence['VirtualNetworkGatewayBgpSettingsPeeringAddressArgs'] peering_addresses: A list of `peering_addresses` as defined below. Only one `peering_addresses` block can be specified except when `active_active` of this Virtual Network Gateway is `true`.
        """
        if asn is not None:
            pulumi.set(__self__, "asn", asn)
        if peer_weight is not None:
            pulumi.set(__self__, "peer_weight", peer_weight)
        if peering_addresses is not None:
            pulumi.set(__self__, "peering_addresses", peering_addresses)

    @property
    @pulumi.getter
    def asn(self) -> Optional[int]:
        """
        The Autonomous System Number (ASN) to use as part of the BGP.
        """
        return pulumi.get(self, "asn")

    @property
    @pulumi.getter(name="peerWeight")
    def peer_weight(self) -> Optional[int]:
        """
        The weight added to routes which have been learned through BGP peering. Valid values can be between `0` and `100`.
        """
        return pulumi.get(self, "peer_weight")

    @property
    @pulumi.getter(name="peeringAddresses")
    def peering_addresses(self) -> Optional[Sequence['outputs.VirtualNetworkGatewayBgpSettingsPeeringAddress']]:
        """
        A list of `peering_addresses` as defined below. Only one `peering_addresses` block can be specified except when `active_active` of this Virtual Network Gateway is `true`.
        """
        return pulumi.get(self, "peering_addresses")


@pulumi.output_type
class VirtualNetworkGatewayBgpSettingsPeeringAddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apipaAddresses":
            suggest = "apipa_addresses"
        elif key == "defaultAddresses":
            suggest = "default_addresses"
        elif key == "ipConfigurationName":
            suggest = "ip_configuration_name"
        elif key == "tunnelIpAddresses":
            suggest = "tunnel_ip_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNetworkGatewayBgpSettingsPeeringAddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNetworkGatewayBgpSettingsPeeringAddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNetworkGatewayBgpSettingsPeeringAddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apipa_addresses: Optional[Sequence[str]] = None,
                 default_addresses: Optional[Sequence[str]] = None,
                 ip_configuration_name: Optional[str] = None,
                 tunnel_ip_addresses: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] apipa_addresses: A list of Azure custom APIPA addresses assigned to the BGP peer of the Virtual Network Gateway.
               
               > **Note:** The valid range for the reserved APIPA address in Azure Public is from `169.254.21.0` to `169.254.22.255`.
        :param Sequence[str] default_addresses: A list of peering address assigned to the BGP peer of the Virtual Network Gateway.
        :param str ip_configuration_name: The name of the IP configuration of this Virtual Network Gateway. In case there are multiple `ip_configuration` blocks defined, this property is **required** to specify.
        :param Sequence[str] tunnel_ip_addresses: A list of tunnel IP addresses assigned to the BGP peer of the Virtual Network Gateway.
        """
        if apipa_addresses is not None:
            pulumi.set(__self__, "apipa_addresses", apipa_addresses)
        if default_addresses is not None:
            pulumi.set(__self__, "default_addresses", default_addresses)
        if ip_configuration_name is not None:
            pulumi.set(__self__, "ip_configuration_name", ip_configuration_name)
        if tunnel_ip_addresses is not None:
            pulumi.set(__self__, "tunnel_ip_addresses", tunnel_ip_addresses)

    @property
    @pulumi.getter(name="apipaAddresses")
    def apipa_addresses(self) -> Optional[Sequence[str]]:
        """
        A list of Azure custom APIPA addresses assigned to the BGP peer of the Virtual Network Gateway.

        > **Note:** The valid range for the reserved APIPA address in Azure Public is from `169.254.21.0` to `169.254.22.255`.
        """
        return pulumi.get(self, "apipa_addresses")

    @property
    @pulumi.getter(name="defaultAddresses")
    def default_addresses(self) -> Optional[Sequence[str]]:
        """
        A list of peering address assigned to the BGP peer of the Virtual Network Gateway.
        """
        return pulumi.get(self, "default_addresses")

    @property
    @pulumi.getter(name="ipConfigurationName")
    def ip_configuration_name(self) -> Optional[str]:
        """
        The name of the IP configuration of this Virtual Network Gateway. In case there are multiple `ip_configuration` blocks defined, this property is **required** to specify.
        """
        return pulumi.get(self, "ip_configuration_name")

    @property
    @pulumi.getter(name="tunnelIpAddresses")
    def tunnel_ip_addresses(self) -> Optional[Sequence[str]]:
        """
        A list of tunnel IP addresses assigned to the BGP peer of the Virtual Network Gateway.
        """
        return pulumi.get(self, "tunnel_ip_addresses")


@pulumi.output_type
class VirtualNetworkGatewayConnectionCustomBgpAddresses(dict):
    def __init__(__self__, *,
                 primary: str,
                 secondary: Optional[str] = None):
        """
        :param str primary: single IP address that is part of the `network.VirtualNetworkGateway` ip_configuration (first one)
        :param str secondary: single IP address that is part of the `network.VirtualNetworkGateway` ip_configuration (second one)
        """
        pulumi.set(__self__, "primary", primary)
        if secondary is not None:
            pulumi.set(__self__, "secondary", secondary)

    @property
    @pulumi.getter
    def primary(self) -> str:
        """
        single IP address that is part of the `network.VirtualNetworkGateway` ip_configuration (first one)
        """
        return pulumi.get(self, "primary")

    @property
    @pulumi.getter
    def secondary(self) -> Optional[str]:
        """
        single IP address that is part of the `network.VirtualNetworkGateway` ip_configuration (second one)
        """
        return pulumi.get(self, "secondary")


@pulumi.output_type
class VirtualNetworkGatewayConnectionIpsecPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dhGroup":
            suggest = "dh_group"
        elif key == "ikeEncryption":
            suggest = "ike_encryption"
        elif key == "ikeIntegrity":
            suggest = "ike_integrity"
        elif key == "ipsecEncryption":
            suggest = "ipsec_encryption"
        elif key == "ipsecIntegrity":
            suggest = "ipsec_integrity"
        elif key == "pfsGroup":
            suggest = "pfs_group"
        elif key == "saDatasize":
            suggest = "sa_datasize"
        elif key == "saLifetime":
            suggest = "sa_lifetime"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNetworkGatewayConnectionIpsecPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNetworkGatewayConnectionIpsecPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNetworkGatewayConnectionIpsecPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dh_group: str,
                 ike_encryption: str,
                 ike_integrity: str,
                 ipsec_encryption: str,
                 ipsec_integrity: str,
                 pfs_group: str,
                 sa_datasize: Optional[int] = None,
                 sa_lifetime: Optional[int] = None):
        """
        :param str dh_group: The DH group used in IKE phase 1 for initial SA. Valid options are `DHGroup1`, `DHGroup14`, `DHGroup2`, `DHGroup2048`, `DHGroup24`, `ECP256`, `ECP384`, or `None`.
        :param str ike_encryption: The IKE encryption algorithm. Valid options are `AES128`, `AES192`, `AES256`, `DES`, `DES3`, `GCMAES128`, or `GCMAES256`.
        :param str ike_integrity: The IKE integrity algorithm. Valid options are `GCMAES128`, `GCMAES256`, `MD5`, `SHA1`, `SHA256`, or `SHA384`.
        :param str ipsec_encryption: The IPSec encryption algorithm. Valid options are `AES128`, `AES192`, `AES256`, `DES`, `DES3`, `GCMAES128`, `GCMAES192`, `GCMAES256`, or `None`.
        :param str ipsec_integrity: The IPSec integrity algorithm. Valid options are `GCMAES128`, `GCMAES192`, `GCMAES256`, `MD5`, `SHA1`, or `SHA256`.
        :param str pfs_group: The DH group used in IKE phase 2 for new child SA.
               Valid options are `ECP256`, `ECP384`, `PFS1`, `PFS14`, `PFS2`, `PFS2048`, `PFS24`, `PFSMM`,
               or `None`.
        :param int sa_datasize: The IPSec SA payload size in KB. Must be at least `1024` KB. Defaults to `102400000` KB.
        :param int sa_lifetime: The IPSec SA lifetime in seconds. Must be at least `300` seconds. Defaults to `27000` seconds.
        """
        pulumi.set(__self__, "dh_group", dh_group)
        pulumi.set(__self__, "ike_encryption", ike_encryption)
        pulumi.set(__self__, "ike_integrity", ike_integrity)
        pulumi.set(__self__, "ipsec_encryption", ipsec_encryption)
        pulumi.set(__self__, "ipsec_integrity", ipsec_integrity)
        pulumi.set(__self__, "pfs_group", pfs_group)
        if sa_datasize is not None:
            pulumi.set(__self__, "sa_datasize", sa_datasize)
        if sa_lifetime is not None:
            pulumi.set(__self__, "sa_lifetime", sa_lifetime)

    @property
    @pulumi.getter(name="dhGroup")
    def dh_group(self) -> str:
        """
        The DH group used in IKE phase 1 for initial SA. Valid options are `DHGroup1`, `DHGroup14`, `DHGroup2`, `DHGroup2048`, `DHGroup24`, `ECP256`, `ECP384`, or `None`.
        """
        return pulumi.get(self, "dh_group")

    @property
    @pulumi.getter(name="ikeEncryption")
    def ike_encryption(self) -> str:
        """
        The IKE encryption algorithm. Valid options are `AES128`, `AES192`, `AES256`, `DES`, `DES3`, `GCMAES128`, or `GCMAES256`.
        """
        return pulumi.get(self, "ike_encryption")

    @property
    @pulumi.getter(name="ikeIntegrity")
    def ike_integrity(self) -> str:
        """
        The IKE integrity algorithm. Valid options are `GCMAES128`, `GCMAES256`, `MD5`, `SHA1`, `SHA256`, or `SHA384`.
        """
        return pulumi.get(self, "ike_integrity")

    @property
    @pulumi.getter(name="ipsecEncryption")
    def ipsec_encryption(self) -> str:
        """
        The IPSec encryption algorithm. Valid options are `AES128`, `AES192`, `AES256`, `DES`, `DES3`, `GCMAES128`, `GCMAES192`, `GCMAES256`, or `None`.
        """
        return pulumi.get(self, "ipsec_encryption")

    @property
    @pulumi.getter(name="ipsecIntegrity")
    def ipsec_integrity(self) -> str:
        """
        The IPSec integrity algorithm. Valid options are `GCMAES128`, `GCMAES192`, `GCMAES256`, `MD5`, `SHA1`, or `SHA256`.
        """
        return pulumi.get(self, "ipsec_integrity")

    @property
    @pulumi.getter(name="pfsGroup")
    def pfs_group(self) -> str:
        """
        The DH group used in IKE phase 2 for new child SA.
        Valid options are `ECP256`, `ECP384`, `PFS1`, `PFS14`, `PFS2`, `PFS2048`, `PFS24`, `PFSMM`,
        or `None`.
        """
        return pulumi.get(self, "pfs_group")

    @property
    @pulumi.getter(name="saDatasize")
    def sa_datasize(self) -> Optional[int]:
        """
        The IPSec SA payload size in KB. Must be at least `1024` KB. Defaults to `102400000` KB.
        """
        return pulumi.get(self, "sa_datasize")

    @property
    @pulumi.getter(name="saLifetime")
    def sa_lifetime(self) -> Optional[int]:
        """
        The IPSec SA lifetime in seconds. Must be at least `300` seconds. Defaults to `27000` seconds.
        """
        return pulumi.get(self, "sa_lifetime")


@pulumi.output_type
class VirtualNetworkGatewayConnectionTrafficSelectorPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localAddressCidrs":
            suggest = "local_address_cidrs"
        elif key == "remoteAddressCidrs":
            suggest = "remote_address_cidrs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNetworkGatewayConnectionTrafficSelectorPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNetworkGatewayConnectionTrafficSelectorPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNetworkGatewayConnectionTrafficSelectorPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 local_address_cidrs: Sequence[str],
                 remote_address_cidrs: Sequence[str]):
        """
        :param Sequence[str] local_address_cidrs: List of local CIDRs.
        :param Sequence[str] remote_address_cidrs: List of remote CIDRs.
        """
        pulumi.set(__self__, "local_address_cidrs", local_address_cidrs)
        pulumi.set(__self__, "remote_address_cidrs", remote_address_cidrs)

    @property
    @pulumi.getter(name="localAddressCidrs")
    def local_address_cidrs(self) -> Sequence[str]:
        """
        List of local CIDRs.
        """
        return pulumi.get(self, "local_address_cidrs")

    @property
    @pulumi.getter(name="remoteAddressCidrs")
    def remote_address_cidrs(self) -> Sequence[str]:
        """
        List of remote CIDRs.
        """
        return pulumi.get(self, "remote_address_cidrs")


@pulumi.output_type
class VirtualNetworkGatewayCustomRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressPrefixes":
            suggest = "address_prefixes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNetworkGatewayCustomRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNetworkGatewayCustomRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNetworkGatewayCustomRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address_prefixes: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] address_prefixes: A list of address blocks reserved for this virtual network in CIDR notation as defined below.
        """
        if address_prefixes is not None:
            pulumi.set(__self__, "address_prefixes", address_prefixes)

    @property
    @pulumi.getter(name="addressPrefixes")
    def address_prefixes(self) -> Optional[Sequence[str]]:
        """
        A list of address blocks reserved for this virtual network in CIDR notation as defined below.
        """
        return pulumi.get(self, "address_prefixes")


@pulumi.output_type
class VirtualNetworkGatewayIpConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicIpAddressId":
            suggest = "public_ip_address_id"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "privateIpAddressAllocation":
            suggest = "private_ip_address_allocation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNetworkGatewayIpConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNetworkGatewayIpConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNetworkGatewayIpConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 public_ip_address_id: str,
                 subnet_id: str,
                 name: Optional[str] = None,
                 private_ip_address_allocation: Optional[str] = None):
        """
        :param str public_ip_address_id: The ID of the public IP address to associate with the Virtual Network Gateway.
        :param str subnet_id: The ID of the gateway subnet of a virtual network in which the virtual network gateway will be created. It is mandatory that the associated subnet is named `GatewaySubnet`. Therefore, each virtual network can contain at most a single Virtual Network Gateway.
        :param str name: A user-defined name of the IP configuration. Defaults to `vnetGatewayConfig`.
        :param str private_ip_address_allocation: Defines how the private IP address of the gateways virtual interface is assigned. Valid options are `Static` or `Dynamic`. Defaults to `Dynamic`.
        """
        pulumi.set(__self__, "public_ip_address_id", public_ip_address_id)
        pulumi.set(__self__, "subnet_id", subnet_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if private_ip_address_allocation is not None:
            pulumi.set(__self__, "private_ip_address_allocation", private_ip_address_allocation)

    @property
    @pulumi.getter(name="publicIpAddressId")
    def public_ip_address_id(self) -> str:
        """
        The ID of the public IP address to associate with the Virtual Network Gateway.
        """
        return pulumi.get(self, "public_ip_address_id")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The ID of the gateway subnet of a virtual network in which the virtual network gateway will be created. It is mandatory that the associated subnet is named `GatewaySubnet`. Therefore, each virtual network can contain at most a single Virtual Network Gateway.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A user-defined name of the IP configuration. Defaults to `vnetGatewayConfig`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateIpAddressAllocation")
    def private_ip_address_allocation(self) -> Optional[str]:
        """
        Defines how the private IP address of the gateways virtual interface is assigned. Valid options are `Static` or `Dynamic`. Defaults to `Dynamic`.
        """
        return pulumi.get(self, "private_ip_address_allocation")


@pulumi.output_type
class VirtualNetworkGatewayNatRuleExternalMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressSpace":
            suggest = "address_space"
        elif key == "portRange":
            suggest = "port_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNetworkGatewayNatRuleExternalMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNetworkGatewayNatRuleExternalMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNetworkGatewayNatRuleExternalMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address_space: str,
                 port_range: Optional[str] = None):
        """
        :param str address_space: The string CIDR representing the address space for the Virtual Network Gateway Nat Rule external mapping.
        :param str port_range: The single port range for the Virtual Network Gateway Nat Rule external mapping.
        """
        pulumi.set(__self__, "address_space", address_space)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)

    @property
    @pulumi.getter(name="addressSpace")
    def address_space(self) -> str:
        """
        The string CIDR representing the address space for the Virtual Network Gateway Nat Rule external mapping.
        """
        return pulumi.get(self, "address_space")

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[str]:
        """
        The single port range for the Virtual Network Gateway Nat Rule external mapping.
        """
        return pulumi.get(self, "port_range")


@pulumi.output_type
class VirtualNetworkGatewayNatRuleInternalMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressSpace":
            suggest = "address_space"
        elif key == "portRange":
            suggest = "port_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNetworkGatewayNatRuleInternalMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNetworkGatewayNatRuleInternalMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNetworkGatewayNatRuleInternalMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address_space: str,
                 port_range: Optional[str] = None):
        """
        :param str address_space: The string CIDR representing the address space for the Virtual Network Gateway Nat Rule internal mapping.
        :param str port_range: The single port range for the Virtual Network Gateway Nat Rule internal mapping.
        """
        pulumi.set(__self__, "address_space", address_space)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)

    @property
    @pulumi.getter(name="addressSpace")
    def address_space(self) -> str:
        """
        The string CIDR representing the address space for the Virtual Network Gateway Nat Rule internal mapping.
        """
        return pulumi.get(self, "address_space")

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[str]:
        """
        The single port range for the Virtual Network Gateway Nat Rule internal mapping.
        """
        return pulumi.get(self, "port_range")


@pulumi.output_type
class VirtualNetworkGatewayVpnClientConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressSpaces":
            suggest = "address_spaces"
        elif key == "aadAudience":
            suggest = "aad_audience"
        elif key == "aadIssuer":
            suggest = "aad_issuer"
        elif key == "aadTenant":
            suggest = "aad_tenant"
        elif key == "radiusServerAddress":
            suggest = "radius_server_address"
        elif key == "radiusServerSecret":
            suggest = "radius_server_secret"
        elif key == "revokedCertificates":
            suggest = "revoked_certificates"
        elif key == "rootCertificates":
            suggest = "root_certificates"
        elif key == "vpnAuthTypes":
            suggest = "vpn_auth_types"
        elif key == "vpnClientProtocols":
            suggest = "vpn_client_protocols"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNetworkGatewayVpnClientConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNetworkGatewayVpnClientConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNetworkGatewayVpnClientConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address_spaces: Sequence[str],
                 aad_audience: Optional[str] = None,
                 aad_issuer: Optional[str] = None,
                 aad_tenant: Optional[str] = None,
                 radius_server_address: Optional[str] = None,
                 radius_server_secret: Optional[str] = None,
                 revoked_certificates: Optional[Sequence['outputs.VirtualNetworkGatewayVpnClientConfigurationRevokedCertificate']] = None,
                 root_certificates: Optional[Sequence['outputs.VirtualNetworkGatewayVpnClientConfigurationRootCertificate']] = None,
                 vpn_auth_types: Optional[Sequence[str]] = None,
                 vpn_client_protocols: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] address_spaces: The address space out of which IP addresses for vpn clients will be taken. You can provide more than one address space, e.g. in CIDR notation.
        :param str aad_audience: The client id of the Azure VPN application.
               See [Create an Active Directory (AD) tenant for P2S OpenVPN protocol connections](https://docs.microsoft.com/en-gb/azure/vpn-gateway/openvpn-azure-ad-tenant-multi-app) for values
        :param str aad_issuer: The STS url for your tenant
        :param str aad_tenant: AzureAD Tenant URL
        :param str radius_server_address: The address of the Radius server.
        :param str radius_server_secret: The secret used by the Radius server.
        :param Sequence['VirtualNetworkGatewayVpnClientConfigurationRevokedCertificateArgs'] revoked_certificates: One or more `revoked_certificate` blocks which are defined below.
        :param Sequence['VirtualNetworkGatewayVpnClientConfigurationRootCertificateArgs'] root_certificates: One or more `root_certificate` blocks which are defined below. These root certificates are used to sign the client certificate used by the VPN clients to connect to the gateway.
        :param Sequence[str] vpn_auth_types: List of the vpn authentication types for the virtual network gateway.
               The supported values are `AAD`, `Radius` and `Certificate`.
               
               > **NOTE:** `vpn_auth_types` must be set when using multiple vpn authentication types.
        :param Sequence[str] vpn_client_protocols: List of the protocols supported by the vpn client.
               The supported values are `SSTP`, `IkeV2` and `OpenVPN`.
               Values `SSTP` and `IkeV2` are incompatible with the use of
               `aad_tenant`, `aad_audience` and `aad_issuer`.
        """
        pulumi.set(__self__, "address_spaces", address_spaces)
        if aad_audience is not None:
            pulumi.set(__self__, "aad_audience", aad_audience)
        if aad_issuer is not None:
            pulumi.set(__self__, "aad_issuer", aad_issuer)
        if aad_tenant is not None:
            pulumi.set(__self__, "aad_tenant", aad_tenant)
        if radius_server_address is not None:
            pulumi.set(__self__, "radius_server_address", radius_server_address)
        if radius_server_secret is not None:
            pulumi.set(__self__, "radius_server_secret", radius_server_secret)
        if revoked_certificates is not None:
            pulumi.set(__self__, "revoked_certificates", revoked_certificates)
        if root_certificates is not None:
            pulumi.set(__self__, "root_certificates", root_certificates)
        if vpn_auth_types is not None:
            pulumi.set(__self__, "vpn_auth_types", vpn_auth_types)
        if vpn_client_protocols is not None:
            pulumi.set(__self__, "vpn_client_protocols", vpn_client_protocols)

    @property
    @pulumi.getter(name="addressSpaces")
    def address_spaces(self) -> Sequence[str]:
        """
        The address space out of which IP addresses for vpn clients will be taken. You can provide more than one address space, e.g. in CIDR notation.
        """
        return pulumi.get(self, "address_spaces")

    @property
    @pulumi.getter(name="aadAudience")
    def aad_audience(self) -> Optional[str]:
        """
        The client id of the Azure VPN application.
        See [Create an Active Directory (AD) tenant for P2S OpenVPN protocol connections](https://docs.microsoft.com/en-gb/azure/vpn-gateway/openvpn-azure-ad-tenant-multi-app) for values
        """
        return pulumi.get(self, "aad_audience")

    @property
    @pulumi.getter(name="aadIssuer")
    def aad_issuer(self) -> Optional[str]:
        """
        The STS url for your tenant
        """
        return pulumi.get(self, "aad_issuer")

    @property
    @pulumi.getter(name="aadTenant")
    def aad_tenant(self) -> Optional[str]:
        """
        AzureAD Tenant URL
        """
        return pulumi.get(self, "aad_tenant")

    @property
    @pulumi.getter(name="radiusServerAddress")
    def radius_server_address(self) -> Optional[str]:
        """
        The address of the Radius server.
        """
        return pulumi.get(self, "radius_server_address")

    @property
    @pulumi.getter(name="radiusServerSecret")
    def radius_server_secret(self) -> Optional[str]:
        """
        The secret used by the Radius server.
        """
        return pulumi.get(self, "radius_server_secret")

    @property
    @pulumi.getter(name="revokedCertificates")
    def revoked_certificates(self) -> Optional[Sequence['outputs.VirtualNetworkGatewayVpnClientConfigurationRevokedCertificate']]:
        """
        One or more `revoked_certificate` blocks which are defined below.
        """
        return pulumi.get(self, "revoked_certificates")

    @property
    @pulumi.getter(name="rootCertificates")
    def root_certificates(self) -> Optional[Sequence['outputs.VirtualNetworkGatewayVpnClientConfigurationRootCertificate']]:
        """
        One or more `root_certificate` blocks which are defined below. These root certificates are used to sign the client certificate used by the VPN clients to connect to the gateway.
        """
        return pulumi.get(self, "root_certificates")

    @property
    @pulumi.getter(name="vpnAuthTypes")
    def vpn_auth_types(self) -> Optional[Sequence[str]]:
        """
        List of the vpn authentication types for the virtual network gateway.
        The supported values are `AAD`, `Radius` and `Certificate`.

        > **NOTE:** `vpn_auth_types` must be set when using multiple vpn authentication types.
        """
        return pulumi.get(self, "vpn_auth_types")

    @property
    @pulumi.getter(name="vpnClientProtocols")
    def vpn_client_protocols(self) -> Optional[Sequence[str]]:
        """
        List of the protocols supported by the vpn client.
        The supported values are `SSTP`, `IkeV2` and `OpenVPN`.
        Values `SSTP` and `IkeV2` are incompatible with the use of
        `aad_tenant`, `aad_audience` and `aad_issuer`.
        """
        return pulumi.get(self, "vpn_client_protocols")


@pulumi.output_type
class VirtualNetworkGatewayVpnClientConfigurationRevokedCertificate(dict):
    def __init__(__self__, *,
                 name: str,
                 thumbprint: str):
        """
        :param str name: Specifies the name of the certificate resource.
        :param str thumbprint: Specifies the public data of the certificate.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "thumbprint", thumbprint)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the certificate resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def thumbprint(self) -> str:
        """
        Specifies the public data of the certificate.
        """
        return pulumi.get(self, "thumbprint")


@pulumi.output_type
class VirtualNetworkGatewayVpnClientConfigurationRootCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicCertData":
            suggest = "public_cert_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNetworkGatewayVpnClientConfigurationRootCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNetworkGatewayVpnClientConfigurationRootCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNetworkGatewayVpnClientConfigurationRootCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 public_cert_data: str):
        """
        :param str name: A user-defined name of the root certificate.
        :param str public_cert_data: The public certificate of the root certificate authority. The certificate must be provided in Base-64 encoded X.509 format (PEM). In particular, this argument *must not* include the `-----BEGIN CERTIFICATE-----` or `-----END CERTIFICATE-----` markers.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "public_cert_data", public_cert_data)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A user-defined name of the root certificate.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="publicCertData")
    def public_cert_data(self) -> str:
        """
        The public certificate of the root certificate authority. The certificate must be provided in Base-64 encoded X.509 format (PEM). In particular, this argument *must not* include the `-----BEGIN CERTIFICATE-----` or `-----END CERTIFICATE-----` markers.
        """
        return pulumi.get(self, "public_cert_data")


@pulumi.output_type
class VirtualNetworkSubnet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressPrefix":
            suggest = "address_prefix"
        elif key == "securityGroup":
            suggest = "security_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNetworkSubnet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNetworkSubnet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNetworkSubnet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address_prefix: str,
                 name: str,
                 id: Optional[str] = None,
                 security_group: Optional[str] = None):
        """
        :param str address_prefix: The address prefix to use for the subnet.
        :param str name: The name of the subnet.
        :param str id: The ID of DDoS Protection Plan.
        :param str security_group: The Network Security Group to associate with the subnet. (Referenced by `id`, ie. `azurerm_network_security_group.example.id`)
        """
        pulumi.set(__self__, "address_prefix", address_prefix)
        pulumi.set(__self__, "name", name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if security_group is not None:
            pulumi.set(__self__, "security_group", security_group)

    @property
    @pulumi.getter(name="addressPrefix")
    def address_prefix(self) -> str:
        """
        The address prefix to use for the subnet.
        """
        return pulumi.get(self, "address_prefix")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the subnet.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of DDoS Protection Plan.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="securityGroup")
    def security_group(self) -> Optional[str]:
        """
        The Network Security Group to associate with the subnet. (Referenced by `id`, ie. `azurerm_network_security_group.example.id`)
        """
        return pulumi.get(self, "security_group")


@pulumi.output_type
class VnpGatewayNatRuleExternalMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressSpace":
            suggest = "address_space"
        elif key == "portRange":
            suggest = "port_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VnpGatewayNatRuleExternalMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VnpGatewayNatRuleExternalMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VnpGatewayNatRuleExternalMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address_space: str,
                 port_range: Optional[str] = None):
        """
        :param str address_space: The string CIDR representing the address space for the VPN Gateway Nat Rule external mapping.
        :param str port_range: The single port range for the VPN Gateway Nat Rule external mapping.
        """
        pulumi.set(__self__, "address_space", address_space)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)

    @property
    @pulumi.getter(name="addressSpace")
    def address_space(self) -> str:
        """
        The string CIDR representing the address space for the VPN Gateway Nat Rule external mapping.
        """
        return pulumi.get(self, "address_space")

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[str]:
        """
        The single port range for the VPN Gateway Nat Rule external mapping.
        """
        return pulumi.get(self, "port_range")


@pulumi.output_type
class VnpGatewayNatRuleInternalMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressSpace":
            suggest = "address_space"
        elif key == "portRange":
            suggest = "port_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VnpGatewayNatRuleInternalMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VnpGatewayNatRuleInternalMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VnpGatewayNatRuleInternalMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address_space: str,
                 port_range: Optional[str] = None):
        """
        :param str address_space: The string CIDR representing the address space for the VPN Gateway Nat Rule internal mapping.
        :param str port_range: The single port range for the VPN Gateway Nat Rule internal mapping.
        """
        pulumi.set(__self__, "address_space", address_space)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)

    @property
    @pulumi.getter(name="addressSpace")
    def address_space(self) -> str:
        """
        The string CIDR representing the address space for the VPN Gateway Nat Rule internal mapping.
        """
        return pulumi.get(self, "address_space")

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[str]:
        """
        The single port range for the VPN Gateway Nat Rule internal mapping.
        """
        return pulumi.get(self, "port_range")


@pulumi.output_type
class VpnGatewayBgpSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "peerWeight":
            suggest = "peer_weight"
        elif key == "bgpPeeringAddress":
            suggest = "bgp_peering_address"
        elif key == "instance0BgpPeeringAddress":
            suggest = "instance0_bgp_peering_address"
        elif key == "instance1BgpPeeringAddress":
            suggest = "instance1_bgp_peering_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnGatewayBgpSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnGatewayBgpSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnGatewayBgpSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 asn: int,
                 peer_weight: int,
                 bgp_peering_address: Optional[str] = None,
                 instance0_bgp_peering_address: Optional['outputs.VpnGatewayBgpSettingsInstance0BgpPeeringAddress'] = None,
                 instance1_bgp_peering_address: Optional['outputs.VpnGatewayBgpSettingsInstance1BgpPeeringAddress'] = None):
        """
        :param int asn: The ASN of the BGP Speaker. Changing this forces a new resource to be created.
        :param int peer_weight: The weight added to Routes learned from this BGP Speaker. Changing this forces a new resource to be created.
        :param str bgp_peering_address: The Address which should be used for the BGP Peering.
        :param 'VpnGatewayBgpSettingsInstance0BgpPeeringAddressArgs' instance0_bgp_peering_address: An `instance_bgp_peering_address` block as defined below.
        :param 'VpnGatewayBgpSettingsInstance1BgpPeeringAddressArgs' instance1_bgp_peering_address: An `instance_bgp_peering_address` block as defined below.
        """
        pulumi.set(__self__, "asn", asn)
        pulumi.set(__self__, "peer_weight", peer_weight)
        if bgp_peering_address is not None:
            pulumi.set(__self__, "bgp_peering_address", bgp_peering_address)
        if instance0_bgp_peering_address is not None:
            pulumi.set(__self__, "instance0_bgp_peering_address", instance0_bgp_peering_address)
        if instance1_bgp_peering_address is not None:
            pulumi.set(__self__, "instance1_bgp_peering_address", instance1_bgp_peering_address)

    @property
    @pulumi.getter
    def asn(self) -> int:
        """
        The ASN of the BGP Speaker. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "asn")

    @property
    @pulumi.getter(name="peerWeight")
    def peer_weight(self) -> int:
        """
        The weight added to Routes learned from this BGP Speaker. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "peer_weight")

    @property
    @pulumi.getter(name="bgpPeeringAddress")
    def bgp_peering_address(self) -> Optional[str]:
        """
        The Address which should be used for the BGP Peering.
        """
        return pulumi.get(self, "bgp_peering_address")

    @property
    @pulumi.getter(name="instance0BgpPeeringAddress")
    def instance0_bgp_peering_address(self) -> Optional['outputs.VpnGatewayBgpSettingsInstance0BgpPeeringAddress']:
        """
        An `instance_bgp_peering_address` block as defined below.
        """
        return pulumi.get(self, "instance0_bgp_peering_address")

    @property
    @pulumi.getter(name="instance1BgpPeeringAddress")
    def instance1_bgp_peering_address(self) -> Optional['outputs.VpnGatewayBgpSettingsInstance1BgpPeeringAddress']:
        """
        An `instance_bgp_peering_address` block as defined below.
        """
        return pulumi.get(self, "instance1_bgp_peering_address")


@pulumi.output_type
class VpnGatewayBgpSettingsInstance0BgpPeeringAddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customIps":
            suggest = "custom_ips"
        elif key == "defaultIps":
            suggest = "default_ips"
        elif key == "ipConfigurationId":
            suggest = "ip_configuration_id"
        elif key == "tunnelIps":
            suggest = "tunnel_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnGatewayBgpSettingsInstance0BgpPeeringAddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnGatewayBgpSettingsInstance0BgpPeeringAddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnGatewayBgpSettingsInstance0BgpPeeringAddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_ips: Sequence[str],
                 default_ips: Optional[Sequence[str]] = None,
                 ip_configuration_id: Optional[str] = None,
                 tunnel_ips: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] custom_ips: A list of custom BGP peering addresses to assign to this instance.
        :param Sequence[str] default_ips: The list of default BGP peering addresses which belong to the pre-defined VPN Gateway IP configuration.
        :param str ip_configuration_id: The pre-defined id of VPN Gateway IP Configuration.
        :param Sequence[str] tunnel_ips: The list of tunnel public IP addresses which belong to the pre-defined VPN Gateway IP configuration.
        """
        pulumi.set(__self__, "custom_ips", custom_ips)
        if default_ips is not None:
            pulumi.set(__self__, "default_ips", default_ips)
        if ip_configuration_id is not None:
            pulumi.set(__self__, "ip_configuration_id", ip_configuration_id)
        if tunnel_ips is not None:
            pulumi.set(__self__, "tunnel_ips", tunnel_ips)

    @property
    @pulumi.getter(name="customIps")
    def custom_ips(self) -> Sequence[str]:
        """
        A list of custom BGP peering addresses to assign to this instance.
        """
        return pulumi.get(self, "custom_ips")

    @property
    @pulumi.getter(name="defaultIps")
    def default_ips(self) -> Optional[Sequence[str]]:
        """
        The list of default BGP peering addresses which belong to the pre-defined VPN Gateway IP configuration.
        """
        return pulumi.get(self, "default_ips")

    @property
    @pulumi.getter(name="ipConfigurationId")
    def ip_configuration_id(self) -> Optional[str]:
        """
        The pre-defined id of VPN Gateway IP Configuration.
        """
        return pulumi.get(self, "ip_configuration_id")

    @property
    @pulumi.getter(name="tunnelIps")
    def tunnel_ips(self) -> Optional[Sequence[str]]:
        """
        The list of tunnel public IP addresses which belong to the pre-defined VPN Gateway IP configuration.
        """
        return pulumi.get(self, "tunnel_ips")


@pulumi.output_type
class VpnGatewayBgpSettingsInstance1BgpPeeringAddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customIps":
            suggest = "custom_ips"
        elif key == "defaultIps":
            suggest = "default_ips"
        elif key == "ipConfigurationId":
            suggest = "ip_configuration_id"
        elif key == "tunnelIps":
            suggest = "tunnel_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnGatewayBgpSettingsInstance1BgpPeeringAddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnGatewayBgpSettingsInstance1BgpPeeringAddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnGatewayBgpSettingsInstance1BgpPeeringAddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_ips: Sequence[str],
                 default_ips: Optional[Sequence[str]] = None,
                 ip_configuration_id: Optional[str] = None,
                 tunnel_ips: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] custom_ips: A list of custom BGP peering addresses to assign to this instance.
        :param Sequence[str] default_ips: The list of default BGP peering addresses which belong to the pre-defined VPN Gateway IP configuration.
        :param str ip_configuration_id: The pre-defined id of VPN Gateway IP Configuration.
        :param Sequence[str] tunnel_ips: The list of tunnel public IP addresses which belong to the pre-defined VPN Gateway IP configuration.
        """
        pulumi.set(__self__, "custom_ips", custom_ips)
        if default_ips is not None:
            pulumi.set(__self__, "default_ips", default_ips)
        if ip_configuration_id is not None:
            pulumi.set(__self__, "ip_configuration_id", ip_configuration_id)
        if tunnel_ips is not None:
            pulumi.set(__self__, "tunnel_ips", tunnel_ips)

    @property
    @pulumi.getter(name="customIps")
    def custom_ips(self) -> Sequence[str]:
        """
        A list of custom BGP peering addresses to assign to this instance.
        """
        return pulumi.get(self, "custom_ips")

    @property
    @pulumi.getter(name="defaultIps")
    def default_ips(self) -> Optional[Sequence[str]]:
        """
        The list of default BGP peering addresses which belong to the pre-defined VPN Gateway IP configuration.
        """
        return pulumi.get(self, "default_ips")

    @property
    @pulumi.getter(name="ipConfigurationId")
    def ip_configuration_id(self) -> Optional[str]:
        """
        The pre-defined id of VPN Gateway IP Configuration.
        """
        return pulumi.get(self, "ip_configuration_id")

    @property
    @pulumi.getter(name="tunnelIps")
    def tunnel_ips(self) -> Optional[Sequence[str]]:
        """
        The list of tunnel public IP addresses which belong to the pre-defined VPN Gateway IP configuration.
        """
        return pulumi.get(self, "tunnel_ips")


@pulumi.output_type
class VpnGatewayConnectionRouting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "associatedRouteTable":
            suggest = "associated_route_table"
        elif key == "inboundRouteMapId":
            suggest = "inbound_route_map_id"
        elif key == "outboundRouteMapId":
            suggest = "outbound_route_map_id"
        elif key == "propagatedRouteTable":
            suggest = "propagated_route_table"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnGatewayConnectionRouting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnGatewayConnectionRouting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnGatewayConnectionRouting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 associated_route_table: str,
                 inbound_route_map_id: Optional[str] = None,
                 outbound_route_map_id: Optional[str] = None,
                 propagated_route_table: Optional['outputs.VpnGatewayConnectionRoutingPropagatedRouteTable'] = None):
        """
        :param str associated_route_table: The ID of the Route Table associated with this VPN Connection.
        :param str inbound_route_map_id: The resource ID of the Route Map associated with this Routing Configuration for inbound learned routes.
        :param str outbound_route_map_id: The resource ID of the Route Map associated with this Routing Configuration for outbound advertised routes.
        :param 'VpnGatewayConnectionRoutingPropagatedRouteTableArgs' propagated_route_table: A `propagated_route_table` block as defined below.
        """
        pulumi.set(__self__, "associated_route_table", associated_route_table)
        if inbound_route_map_id is not None:
            pulumi.set(__self__, "inbound_route_map_id", inbound_route_map_id)
        if outbound_route_map_id is not None:
            pulumi.set(__self__, "outbound_route_map_id", outbound_route_map_id)
        if propagated_route_table is not None:
            pulumi.set(__self__, "propagated_route_table", propagated_route_table)

    @property
    @pulumi.getter(name="associatedRouteTable")
    def associated_route_table(self) -> str:
        """
        The ID of the Route Table associated with this VPN Connection.
        """
        return pulumi.get(self, "associated_route_table")

    @property
    @pulumi.getter(name="inboundRouteMapId")
    def inbound_route_map_id(self) -> Optional[str]:
        """
        The resource ID of the Route Map associated with this Routing Configuration for inbound learned routes.
        """
        return pulumi.get(self, "inbound_route_map_id")

    @property
    @pulumi.getter(name="outboundRouteMapId")
    def outbound_route_map_id(self) -> Optional[str]:
        """
        The resource ID of the Route Map associated with this Routing Configuration for outbound advertised routes.
        """
        return pulumi.get(self, "outbound_route_map_id")

    @property
    @pulumi.getter(name="propagatedRouteTable")
    def propagated_route_table(self) -> Optional['outputs.VpnGatewayConnectionRoutingPropagatedRouteTable']:
        """
        A `propagated_route_table` block as defined below.
        """
        return pulumi.get(self, "propagated_route_table")


@pulumi.output_type
class VpnGatewayConnectionRoutingPropagatedRouteTable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "routeTableIds":
            suggest = "route_table_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnGatewayConnectionRoutingPropagatedRouteTable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnGatewayConnectionRoutingPropagatedRouteTable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnGatewayConnectionRoutingPropagatedRouteTable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 route_table_ids: Sequence[str],
                 labels: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] route_table_ids: A list of Route Table IDs to associated with this VPN Gateway Connection.
        :param Sequence[str] labels: A list of labels to assign to this route table.
        """
        pulumi.set(__self__, "route_table_ids", route_table_ids)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter(name="routeTableIds")
    def route_table_ids(self) -> Sequence[str]:
        """
        A list of Route Table IDs to associated with this VPN Gateway Connection.
        """
        return pulumi.get(self, "route_table_ids")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Sequence[str]]:
        """
        A list of labels to assign to this route table.
        """
        return pulumi.get(self, "labels")


@pulumi.output_type
class VpnGatewayConnectionTrafficSelectorPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localAddressRanges":
            suggest = "local_address_ranges"
        elif key == "remoteAddressRanges":
            suggest = "remote_address_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnGatewayConnectionTrafficSelectorPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnGatewayConnectionTrafficSelectorPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnGatewayConnectionTrafficSelectorPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 local_address_ranges: Sequence[str],
                 remote_address_ranges: Sequence[str]):
        """
        :param Sequence[str] local_address_ranges: A list of local address spaces in CIDR format for this VPN Gateway Connection.
        :param Sequence[str] remote_address_ranges: A list of remote address spaces in CIDR format for this VPN Gateway Connection.
        """
        pulumi.set(__self__, "local_address_ranges", local_address_ranges)
        pulumi.set(__self__, "remote_address_ranges", remote_address_ranges)

    @property
    @pulumi.getter(name="localAddressRanges")
    def local_address_ranges(self) -> Sequence[str]:
        """
        A list of local address spaces in CIDR format for this VPN Gateway Connection.
        """
        return pulumi.get(self, "local_address_ranges")

    @property
    @pulumi.getter(name="remoteAddressRanges")
    def remote_address_ranges(self) -> Sequence[str]:
        """
        A list of remote address spaces in CIDR format for this VPN Gateway Connection.
        """
        return pulumi.get(self, "remote_address_ranges")


@pulumi.output_type
class VpnGatewayConnectionVpnLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vpnSiteLinkId":
            suggest = "vpn_site_link_id"
        elif key == "bandwidthMbps":
            suggest = "bandwidth_mbps"
        elif key == "bgpEnabled":
            suggest = "bgp_enabled"
        elif key == "connectionMode":
            suggest = "connection_mode"
        elif key == "customBgpAddresses":
            suggest = "custom_bgp_addresses"
        elif key == "egressNatRuleIds":
            suggest = "egress_nat_rule_ids"
        elif key == "ingressNatRuleIds":
            suggest = "ingress_nat_rule_ids"
        elif key == "ipsecPolicies":
            suggest = "ipsec_policies"
        elif key == "localAzureIpAddressEnabled":
            suggest = "local_azure_ip_address_enabled"
        elif key == "policyBasedTrafficSelectorEnabled":
            suggest = "policy_based_traffic_selector_enabled"
        elif key == "ratelimitEnabled":
            suggest = "ratelimit_enabled"
        elif key == "routeWeight":
            suggest = "route_weight"
        elif key == "sharedKey":
            suggest = "shared_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnGatewayConnectionVpnLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnGatewayConnectionVpnLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnGatewayConnectionVpnLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 vpn_site_link_id: str,
                 bandwidth_mbps: Optional[int] = None,
                 bgp_enabled: Optional[bool] = None,
                 connection_mode: Optional[str] = None,
                 custom_bgp_addresses: Optional[Sequence['outputs.VpnGatewayConnectionVpnLinkCustomBgpAddress']] = None,
                 egress_nat_rule_ids: Optional[Sequence[str]] = None,
                 ingress_nat_rule_ids: Optional[Sequence[str]] = None,
                 ipsec_policies: Optional[Sequence['outputs.VpnGatewayConnectionVpnLinkIpsecPolicy']] = None,
                 local_azure_ip_address_enabled: Optional[bool] = None,
                 policy_based_traffic_selector_enabled: Optional[bool] = None,
                 protocol: Optional[str] = None,
                 ratelimit_enabled: Optional[bool] = None,
                 route_weight: Optional[int] = None,
                 shared_key: Optional[str] = None):
        """
        :param str name: The name which should be used for this VPN Link Connection.
        :param str vpn_site_link_id: The ID of the connected VPN Site Link. Changing this forces a new VPN Gateway Connection to be created.
        :param int bandwidth_mbps: The expected connection bandwidth in MBPS. Defaults to `10`.
        :param bool bgp_enabled: Should the BGP be enabled? Defaults to `false`. Changing this forces a new VPN Gateway Connection to be created.
        :param str connection_mode: The connection mode of this VPN Link. Possible values are `Default`, `InitiatorOnly` and `ResponderOnly`. Defaults to `Default`.
        :param Sequence['VpnGatewayConnectionVpnLinkCustomBgpAddressArgs'] custom_bgp_addresses: One or more `custom_bgp_address` blocks as defined below.
        :param Sequence[str] egress_nat_rule_ids: A list of the egress NAT Rule Ids.
        :param Sequence[str] ingress_nat_rule_ids: A list of the ingress NAT Rule Ids.
        :param Sequence['VpnGatewayConnectionVpnLinkIpsecPolicyArgs'] ipsec_policies: One or more `ipsec_policy` blocks as defined above.
        :param bool local_azure_ip_address_enabled: Whether to use local Azure IP to initiate connection? Defaults to `false`.
        :param bool policy_based_traffic_selector_enabled: Whether to enable policy-based traffic selectors? Defaults to `false`.
        :param str protocol: The protocol used for this VPN Link Connection. Possible values are `IKEv1` and `IKEv2`. Defaults to `IKEv2`.
        :param bool ratelimit_enabled: Should the rate limit be enabled? Defaults to `false`.
        :param int route_weight: Routing weight for this VPN Link Connection. Defaults to `0`.
        :param str shared_key: SharedKey for this VPN Link Connection.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "vpn_site_link_id", vpn_site_link_id)
        if bandwidth_mbps is not None:
            pulumi.set(__self__, "bandwidth_mbps", bandwidth_mbps)
        if bgp_enabled is not None:
            pulumi.set(__self__, "bgp_enabled", bgp_enabled)
        if connection_mode is not None:
            pulumi.set(__self__, "connection_mode", connection_mode)
        if custom_bgp_addresses is not None:
            pulumi.set(__self__, "custom_bgp_addresses", custom_bgp_addresses)
        if egress_nat_rule_ids is not None:
            pulumi.set(__self__, "egress_nat_rule_ids", egress_nat_rule_ids)
        if ingress_nat_rule_ids is not None:
            pulumi.set(__self__, "ingress_nat_rule_ids", ingress_nat_rule_ids)
        if ipsec_policies is not None:
            pulumi.set(__self__, "ipsec_policies", ipsec_policies)
        if local_azure_ip_address_enabled is not None:
            pulumi.set(__self__, "local_azure_ip_address_enabled", local_azure_ip_address_enabled)
        if policy_based_traffic_selector_enabled is not None:
            pulumi.set(__self__, "policy_based_traffic_selector_enabled", policy_based_traffic_selector_enabled)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if ratelimit_enabled is not None:
            pulumi.set(__self__, "ratelimit_enabled", ratelimit_enabled)
        if route_weight is not None:
            pulumi.set(__self__, "route_weight", route_weight)
        if shared_key is not None:
            pulumi.set(__self__, "shared_key", shared_key)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this VPN Link Connection.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="vpnSiteLinkId")
    def vpn_site_link_id(self) -> str:
        """
        The ID of the connected VPN Site Link. Changing this forces a new VPN Gateway Connection to be created.
        """
        return pulumi.get(self, "vpn_site_link_id")

    @property
    @pulumi.getter(name="bandwidthMbps")
    def bandwidth_mbps(self) -> Optional[int]:
        """
        The expected connection bandwidth in MBPS. Defaults to `10`.
        """
        return pulumi.get(self, "bandwidth_mbps")

    @property
    @pulumi.getter(name="bgpEnabled")
    def bgp_enabled(self) -> Optional[bool]:
        """
        Should the BGP be enabled? Defaults to `false`. Changing this forces a new VPN Gateway Connection to be created.
        """
        return pulumi.get(self, "bgp_enabled")

    @property
    @pulumi.getter(name="connectionMode")
    def connection_mode(self) -> Optional[str]:
        """
        The connection mode of this VPN Link. Possible values are `Default`, `InitiatorOnly` and `ResponderOnly`. Defaults to `Default`.
        """
        return pulumi.get(self, "connection_mode")

    @property
    @pulumi.getter(name="customBgpAddresses")
    def custom_bgp_addresses(self) -> Optional[Sequence['outputs.VpnGatewayConnectionVpnLinkCustomBgpAddress']]:
        """
        One or more `custom_bgp_address` blocks as defined below.
        """
        return pulumi.get(self, "custom_bgp_addresses")

    @property
    @pulumi.getter(name="egressNatRuleIds")
    def egress_nat_rule_ids(self) -> Optional[Sequence[str]]:
        """
        A list of the egress NAT Rule Ids.
        """
        return pulumi.get(self, "egress_nat_rule_ids")

    @property
    @pulumi.getter(name="ingressNatRuleIds")
    def ingress_nat_rule_ids(self) -> Optional[Sequence[str]]:
        """
        A list of the ingress NAT Rule Ids.
        """
        return pulumi.get(self, "ingress_nat_rule_ids")

    @property
    @pulumi.getter(name="ipsecPolicies")
    def ipsec_policies(self) -> Optional[Sequence['outputs.VpnGatewayConnectionVpnLinkIpsecPolicy']]:
        """
        One or more `ipsec_policy` blocks as defined above.
        """
        return pulumi.get(self, "ipsec_policies")

    @property
    @pulumi.getter(name="localAzureIpAddressEnabled")
    def local_azure_ip_address_enabled(self) -> Optional[bool]:
        """
        Whether to use local Azure IP to initiate connection? Defaults to `false`.
        """
        return pulumi.get(self, "local_azure_ip_address_enabled")

    @property
    @pulumi.getter(name="policyBasedTrafficSelectorEnabled")
    def policy_based_traffic_selector_enabled(self) -> Optional[bool]:
        """
        Whether to enable policy-based traffic selectors? Defaults to `false`.
        """
        return pulumi.get(self, "policy_based_traffic_selector_enabled")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        The protocol used for this VPN Link Connection. Possible values are `IKEv1` and `IKEv2`. Defaults to `IKEv2`.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="ratelimitEnabled")
    def ratelimit_enabled(self) -> Optional[bool]:
        """
        Should the rate limit be enabled? Defaults to `false`.
        """
        return pulumi.get(self, "ratelimit_enabled")

    @property
    @pulumi.getter(name="routeWeight")
    def route_weight(self) -> Optional[int]:
        """
        Routing weight for this VPN Link Connection. Defaults to `0`.
        """
        return pulumi.get(self, "route_weight")

    @property
    @pulumi.getter(name="sharedKey")
    def shared_key(self) -> Optional[str]:
        """
        SharedKey for this VPN Link Connection.
        """
        return pulumi.get(self, "shared_key")


@pulumi.output_type
class VpnGatewayConnectionVpnLinkCustomBgpAddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "ipConfigurationId":
            suggest = "ip_configuration_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnGatewayConnectionVpnLinkCustomBgpAddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnGatewayConnectionVpnLinkCustomBgpAddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnGatewayConnectionVpnLinkCustomBgpAddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_address: str,
                 ip_configuration_id: str):
        """
        :param str ip_address: The custom bgp ip address which belongs to the IP Configuration.
        :param str ip_configuration_id: The ID of the IP Configuration which belongs to the VPN Gateway.
        """
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "ip_configuration_id", ip_configuration_id)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The custom bgp ip address which belongs to the IP Configuration.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="ipConfigurationId")
    def ip_configuration_id(self) -> str:
        """
        The ID of the IP Configuration which belongs to the VPN Gateway.
        """
        return pulumi.get(self, "ip_configuration_id")


@pulumi.output_type
class VpnGatewayConnectionVpnLinkIpsecPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dhGroup":
            suggest = "dh_group"
        elif key == "encryptionAlgorithm":
            suggest = "encryption_algorithm"
        elif key == "ikeEncryptionAlgorithm":
            suggest = "ike_encryption_algorithm"
        elif key == "ikeIntegrityAlgorithm":
            suggest = "ike_integrity_algorithm"
        elif key == "integrityAlgorithm":
            suggest = "integrity_algorithm"
        elif key == "pfsGroup":
            suggest = "pfs_group"
        elif key == "saDataSizeKb":
            suggest = "sa_data_size_kb"
        elif key == "saLifetimeSec":
            suggest = "sa_lifetime_sec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnGatewayConnectionVpnLinkIpsecPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnGatewayConnectionVpnLinkIpsecPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnGatewayConnectionVpnLinkIpsecPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dh_group: str,
                 encryption_algorithm: str,
                 ike_encryption_algorithm: str,
                 ike_integrity_algorithm: str,
                 integrity_algorithm: str,
                 pfs_group: str,
                 sa_data_size_kb: int,
                 sa_lifetime_sec: int):
        """
        :param str dh_group: The DH Group used in IKE Phase 1 for initial SA. Possible values are `None`, `DHGroup1`, `DHGroup2`, `DHGroup14`, `DHGroup24`, `DHGroup2048`, `ECP256`, `ECP384`.
        :param str encryption_algorithm: The IPSec encryption algorithm (IKE phase 1). Possible values are `AES128`, `AES192`, `AES256`, `DES`, `DES3`, `GCMAES128`, `GCMAES192`, `GCMAES256`, `None`.
        :param str ike_encryption_algorithm: The IKE encryption algorithm (IKE phase 2). Possible values are `DES`, `DES3`, `AES128`, `AES192`, `AES256`, `GCMAES128`, `GCMAES256`.
        :param str ike_integrity_algorithm: The IKE integrity algorithm (IKE phase 2). Possible values are `MD5`, `SHA1`, `SHA256`, `SHA384`, `GCMAES128`, `GCMAES256`.
        :param str integrity_algorithm: The IPSec integrity algorithm (IKE phase 1). Possible values are `MD5`, `SHA1`, `SHA256`, `GCMAES128`, `GCMAES192`, `GCMAES256`.
        :param str pfs_group: The Pfs Group used in IKE Phase 2 for the new child SA. Possible values are `None`, `PFS1`, `PFS2`, `PFS14`, `PFS24`, `PFS2048`, `PFSMM`, `ECP256`, `ECP384`.
        :param int sa_data_size_kb: The IPSec Security Association (also called Quick Mode or Phase 2 SA) payload size in KB for the site to site VPN tunnel.
        :param int sa_lifetime_sec: The IPSec Security Association (also called Quick Mode or Phase 2 SA) lifetime in seconds for the site to site VPN tunnel.
        """
        pulumi.set(__self__, "dh_group", dh_group)
        pulumi.set(__self__, "encryption_algorithm", encryption_algorithm)
        pulumi.set(__self__, "ike_encryption_algorithm", ike_encryption_algorithm)
        pulumi.set(__self__, "ike_integrity_algorithm", ike_integrity_algorithm)
        pulumi.set(__self__, "integrity_algorithm", integrity_algorithm)
        pulumi.set(__self__, "pfs_group", pfs_group)
        pulumi.set(__self__, "sa_data_size_kb", sa_data_size_kb)
        pulumi.set(__self__, "sa_lifetime_sec", sa_lifetime_sec)

    @property
    @pulumi.getter(name="dhGroup")
    def dh_group(self) -> str:
        """
        The DH Group used in IKE Phase 1 for initial SA. Possible values are `None`, `DHGroup1`, `DHGroup2`, `DHGroup14`, `DHGroup24`, `DHGroup2048`, `ECP256`, `ECP384`.
        """
        return pulumi.get(self, "dh_group")

    @property
    @pulumi.getter(name="encryptionAlgorithm")
    def encryption_algorithm(self) -> str:
        """
        The IPSec encryption algorithm (IKE phase 1). Possible values are `AES128`, `AES192`, `AES256`, `DES`, `DES3`, `GCMAES128`, `GCMAES192`, `GCMAES256`, `None`.
        """
        return pulumi.get(self, "encryption_algorithm")

    @property
    @pulumi.getter(name="ikeEncryptionAlgorithm")
    def ike_encryption_algorithm(self) -> str:
        """
        The IKE encryption algorithm (IKE phase 2). Possible values are `DES`, `DES3`, `AES128`, `AES192`, `AES256`, `GCMAES128`, `GCMAES256`.
        """
        return pulumi.get(self, "ike_encryption_algorithm")

    @property
    @pulumi.getter(name="ikeIntegrityAlgorithm")
    def ike_integrity_algorithm(self) -> str:
        """
        The IKE integrity algorithm (IKE phase 2). Possible values are `MD5`, `SHA1`, `SHA256`, `SHA384`, `GCMAES128`, `GCMAES256`.
        """
        return pulumi.get(self, "ike_integrity_algorithm")

    @property
    @pulumi.getter(name="integrityAlgorithm")
    def integrity_algorithm(self) -> str:
        """
        The IPSec integrity algorithm (IKE phase 1). Possible values are `MD5`, `SHA1`, `SHA256`, `GCMAES128`, `GCMAES192`, `GCMAES256`.
        """
        return pulumi.get(self, "integrity_algorithm")

    @property
    @pulumi.getter(name="pfsGroup")
    def pfs_group(self) -> str:
        """
        The Pfs Group used in IKE Phase 2 for the new child SA. Possible values are `None`, `PFS1`, `PFS2`, `PFS14`, `PFS24`, `PFS2048`, `PFSMM`, `ECP256`, `ECP384`.
        """
        return pulumi.get(self, "pfs_group")

    @property
    @pulumi.getter(name="saDataSizeKb")
    def sa_data_size_kb(self) -> int:
        """
        The IPSec Security Association (also called Quick Mode or Phase 2 SA) payload size in KB for the site to site VPN tunnel.
        """
        return pulumi.get(self, "sa_data_size_kb")

    @property
    @pulumi.getter(name="saLifetimeSec")
    def sa_lifetime_sec(self) -> int:
        """
        The IPSec Security Association (also called Quick Mode or Phase 2 SA) lifetime in seconds for the site to site VPN tunnel.
        """
        return pulumi.get(self, "sa_lifetime_sec")


@pulumi.output_type
class VpnServerConfigurationAzureActiveDirectoryAuthentication(dict):
    def __init__(__self__, *,
                 audience: str,
                 issuer: str,
                 tenant: str):
        """
        :param str audience: The Audience which should be used for authentication.
        :param str issuer: The Issuer which should be used for authentication.
        :param str tenant: The Tenant which should be used for authentication.
        """
        pulumi.set(__self__, "audience", audience)
        pulumi.set(__self__, "issuer", issuer)
        pulumi.set(__self__, "tenant", tenant)

    @property
    @pulumi.getter
    def audience(self) -> str:
        """
        The Audience which should be used for authentication.
        """
        return pulumi.get(self, "audience")

    @property
    @pulumi.getter
    def issuer(self) -> str:
        """
        The Issuer which should be used for authentication.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def tenant(self) -> str:
        """
        The Tenant which should be used for authentication.
        """
        return pulumi.get(self, "tenant")


@pulumi.output_type
class VpnServerConfigurationClientRevokedCertificate(dict):
    def __init__(__self__, *,
                 name: str,
                 thumbprint: str):
        """
        :param str name: A name used to uniquely identify this certificate.
        :param str thumbprint: The Thumbprint of the Certificate.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "thumbprint", thumbprint)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A name used to uniquely identify this certificate.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def thumbprint(self) -> str:
        """
        The Thumbprint of the Certificate.
        """
        return pulumi.get(self, "thumbprint")


@pulumi.output_type
class VpnServerConfigurationClientRootCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicCertData":
            suggest = "public_cert_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnServerConfigurationClientRootCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnServerConfigurationClientRootCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnServerConfigurationClientRootCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 public_cert_data: str):
        """
        :param str name: A name used to uniquely identify this certificate.
        :param str public_cert_data: The Public Key Data associated with the Certificate.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "public_cert_data", public_cert_data)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A name used to uniquely identify this certificate.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="publicCertData")
    def public_cert_data(self) -> str:
        """
        The Public Key Data associated with the Certificate.
        """
        return pulumi.get(self, "public_cert_data")


@pulumi.output_type
class VpnServerConfigurationIpsecPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dhGroup":
            suggest = "dh_group"
        elif key == "ikeEncryption":
            suggest = "ike_encryption"
        elif key == "ikeIntegrity":
            suggest = "ike_integrity"
        elif key == "ipsecEncryption":
            suggest = "ipsec_encryption"
        elif key == "ipsecIntegrity":
            suggest = "ipsec_integrity"
        elif key == "pfsGroup":
            suggest = "pfs_group"
        elif key == "saDataSizeKilobytes":
            suggest = "sa_data_size_kilobytes"
        elif key == "saLifetimeSeconds":
            suggest = "sa_lifetime_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnServerConfigurationIpsecPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnServerConfigurationIpsecPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnServerConfigurationIpsecPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dh_group: str,
                 ike_encryption: str,
                 ike_integrity: str,
                 ipsec_encryption: str,
                 ipsec_integrity: str,
                 pfs_group: str,
                 sa_data_size_kilobytes: int,
                 sa_lifetime_seconds: int):
        """
        :param str dh_group: The DH Group, used in IKE Phase 1. Possible values include `DHGroup1`, `DHGroup2`, `DHGroup14`, `DHGroup24`, `DHGroup2048`, `ECP256`, `ECP384` and `None`.
        :param str ike_encryption: The IKE encryption algorithm, used for IKE Phase 2. Possible values include `AES128`, `AES192`, `AES256`, `DES`, `DES3`, `GCMAES128` and `GCMAES256`.
        :param str ike_integrity: The IKE encryption integrity algorithm, used for IKE Phase 2. Possible values include `GCMAES128`, `GCMAES256`, `MD5`, `SHA1`, `SHA256` and `SHA384`.
        :param str ipsec_encryption: The IPSec encryption algorithm, used for IKE phase 1. Possible values include `AES128`, `AES192`, `AES256`, `DES`, `DES3`, `GCMAES128`, `GCMAES192`, `GCMAES256` and `None`.
        :param str ipsec_integrity: The IPSec integrity algorithm, used for IKE phase 1. Possible values include `GCMAES128`, `GCMAES192`, `GCMAES256`, `MD5`, `SHA1` and `SHA256`.
        :param str pfs_group: The Pfs Group, used in IKE Phase 2. Possible values include `ECP256`, `ECP384`, `PFS1`, `PFS2`, `PFS14`, `PFS24`, `PFS2048`, `PFSMM` and `None`.
        :param int sa_data_size_kilobytes: The IPSec Security Association payload size in KB for a Site-to-Site VPN tunnel.
        :param int sa_lifetime_seconds: The IPSec Security Association lifetime in seconds for a Site-to-Site VPN tunnel.
        """
        pulumi.set(__self__, "dh_group", dh_group)
        pulumi.set(__self__, "ike_encryption", ike_encryption)
        pulumi.set(__self__, "ike_integrity", ike_integrity)
        pulumi.set(__self__, "ipsec_encryption", ipsec_encryption)
        pulumi.set(__self__, "ipsec_integrity", ipsec_integrity)
        pulumi.set(__self__, "pfs_group", pfs_group)
        pulumi.set(__self__, "sa_data_size_kilobytes", sa_data_size_kilobytes)
        pulumi.set(__self__, "sa_lifetime_seconds", sa_lifetime_seconds)

    @property
    @pulumi.getter(name="dhGroup")
    def dh_group(self) -> str:
        """
        The DH Group, used in IKE Phase 1. Possible values include `DHGroup1`, `DHGroup2`, `DHGroup14`, `DHGroup24`, `DHGroup2048`, `ECP256`, `ECP384` and `None`.
        """
        return pulumi.get(self, "dh_group")

    @property
    @pulumi.getter(name="ikeEncryption")
    def ike_encryption(self) -> str:
        """
        The IKE encryption algorithm, used for IKE Phase 2. Possible values include `AES128`, `AES192`, `AES256`, `DES`, `DES3`, `GCMAES128` and `GCMAES256`.
        """
        return pulumi.get(self, "ike_encryption")

    @property
    @pulumi.getter(name="ikeIntegrity")
    def ike_integrity(self) -> str:
        """
        The IKE encryption integrity algorithm, used for IKE Phase 2. Possible values include `GCMAES128`, `GCMAES256`, `MD5`, `SHA1`, `SHA256` and `SHA384`.
        """
        return pulumi.get(self, "ike_integrity")

    @property
    @pulumi.getter(name="ipsecEncryption")
    def ipsec_encryption(self) -> str:
        """
        The IPSec encryption algorithm, used for IKE phase 1. Possible values include `AES128`, `AES192`, `AES256`, `DES`, `DES3`, `GCMAES128`, `GCMAES192`, `GCMAES256` and `None`.
        """
        return pulumi.get(self, "ipsec_encryption")

    @property
    @pulumi.getter(name="ipsecIntegrity")
    def ipsec_integrity(self) -> str:
        """
        The IPSec integrity algorithm, used for IKE phase 1. Possible values include `GCMAES128`, `GCMAES192`, `GCMAES256`, `MD5`, `SHA1` and `SHA256`.
        """
        return pulumi.get(self, "ipsec_integrity")

    @property
    @pulumi.getter(name="pfsGroup")
    def pfs_group(self) -> str:
        """
        The Pfs Group, used in IKE Phase 2. Possible values include `ECP256`, `ECP384`, `PFS1`, `PFS2`, `PFS14`, `PFS24`, `PFS2048`, `PFSMM` and `None`.
        """
        return pulumi.get(self, "pfs_group")

    @property
    @pulumi.getter(name="saDataSizeKilobytes")
    def sa_data_size_kilobytes(self) -> int:
        """
        The IPSec Security Association payload size in KB for a Site-to-Site VPN tunnel.
        """
        return pulumi.get(self, "sa_data_size_kilobytes")

    @property
    @pulumi.getter(name="saLifetimeSeconds")
    def sa_lifetime_seconds(self) -> int:
        """
        The IPSec Security Association lifetime in seconds for a Site-to-Site VPN tunnel.
        """
        return pulumi.get(self, "sa_lifetime_seconds")


@pulumi.output_type
class VpnServerConfigurationPolicyGroupPolicy(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: The name of the VPN Server Configuration Policy member.
        :param str type: The attribute type of the VPN Server Configuration Policy member. Possible values are `AADGroupId`, `CertificateGroupId` and `RadiusAzureGroupId`.
        :param str value: The value of the attribute that is used for the VPN Server Configuration Policy member.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the VPN Server Configuration Policy member.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The attribute type of the VPN Server Configuration Policy member. Possible values are `AADGroupId`, `CertificateGroupId` and `RadiusAzureGroupId`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the attribute that is used for the VPN Server Configuration Policy member.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class VpnServerConfigurationRadius(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientRootCertificates":
            suggest = "client_root_certificates"
        elif key == "serverRootCertificates":
            suggest = "server_root_certificates"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnServerConfigurationRadius. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnServerConfigurationRadius.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnServerConfigurationRadius.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_root_certificates: Optional[Sequence['outputs.VpnServerConfigurationRadiusClientRootCertificate']] = None,
                 server_root_certificates: Optional[Sequence['outputs.VpnServerConfigurationRadiusServerRootCertificate']] = None,
                 servers: Optional[Sequence['outputs.VpnServerConfigurationRadiusServer']] = None):
        """
        :param Sequence['VpnServerConfigurationRadiusClientRootCertificateArgs'] client_root_certificates: One or more `client_root_certificate` blocks as defined below.
        :param Sequence['VpnServerConfigurationRadiusServerRootCertificateArgs'] server_root_certificates: One or more `server_root_certificate` blocks as defined below.
        :param Sequence['VpnServerConfigurationRadiusServerArgs'] servers: One or more `server` blocks as defined below.
        """
        if client_root_certificates is not None:
            pulumi.set(__self__, "client_root_certificates", client_root_certificates)
        if server_root_certificates is not None:
            pulumi.set(__self__, "server_root_certificates", server_root_certificates)
        if servers is not None:
            pulumi.set(__self__, "servers", servers)

    @property
    @pulumi.getter(name="clientRootCertificates")
    def client_root_certificates(self) -> Optional[Sequence['outputs.VpnServerConfigurationRadiusClientRootCertificate']]:
        """
        One or more `client_root_certificate` blocks as defined below.
        """
        return pulumi.get(self, "client_root_certificates")

    @property
    @pulumi.getter(name="serverRootCertificates")
    def server_root_certificates(self) -> Optional[Sequence['outputs.VpnServerConfigurationRadiusServerRootCertificate']]:
        """
        One or more `server_root_certificate` blocks as defined below.
        """
        return pulumi.get(self, "server_root_certificates")

    @property
    @pulumi.getter
    def servers(self) -> Optional[Sequence['outputs.VpnServerConfigurationRadiusServer']]:
        """
        One or more `server` blocks as defined below.
        """
        return pulumi.get(self, "servers")


@pulumi.output_type
class VpnServerConfigurationRadiusClientRootCertificate(dict):
    def __init__(__self__, *,
                 name: str,
                 thumbprint: str):
        """
        :param str name: A name used to uniquely identify this certificate.
        :param str thumbprint: The Thumbprint of the Certificate.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "thumbprint", thumbprint)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A name used to uniquely identify this certificate.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def thumbprint(self) -> str:
        """
        The Thumbprint of the Certificate.
        """
        return pulumi.get(self, "thumbprint")


@pulumi.output_type
class VpnServerConfigurationRadiusServer(dict):
    def __init__(__self__, *,
                 address: str,
                 score: int,
                 secret: str):
        """
        :param str address: The Address of the Radius Server.
        :param int score: The Score of the Radius Server determines the priority of the server. Ranges from 1 to 30.
        :param str secret: The Secret used to communicate with the Radius Server.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "score", score)
        pulumi.set(__self__, "secret", secret)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        The Address of the Radius Server.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def score(self) -> int:
        """
        The Score of the Radius Server determines the priority of the server. Ranges from 1 to 30.
        """
        return pulumi.get(self, "score")

    @property
    @pulumi.getter
    def secret(self) -> str:
        """
        The Secret used to communicate with the Radius Server.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class VpnServerConfigurationRadiusServerRootCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicCertData":
            suggest = "public_cert_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnServerConfigurationRadiusServerRootCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnServerConfigurationRadiusServerRootCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnServerConfigurationRadiusServerRootCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 public_cert_data: str):
        """
        :param str name: A name used to uniquely identify this certificate.
        :param str public_cert_data: The Public Key Data associated with the Certificate.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "public_cert_data", public_cert_data)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A name used to uniquely identify this certificate.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="publicCertData")
    def public_cert_data(self) -> str:
        """
        The Public Key Data associated with the Certificate.
        """
        return pulumi.get(self, "public_cert_data")


@pulumi.output_type
class VpnSiteLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "providerName":
            suggest = "provider_name"
        elif key == "speedInMbps":
            suggest = "speed_in_mbps"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnSiteLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnSiteLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnSiteLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 bgp: Optional['outputs.VpnSiteLinkBgp'] = None,
                 fqdn: Optional[str] = None,
                 id: Optional[str] = None,
                 ip_address: Optional[str] = None,
                 provider_name: Optional[str] = None,
                 speed_in_mbps: Optional[int] = None):
        """
        :param str name: The name which should be used for this VPN Site Link.
        :param 'VpnSiteLinkBgpArgs' bgp: A `bgp` block as defined above.
               
               > **NOTE:** The `link.bgp` has to be set when the `address_cidrs` isn't specified.
        :param str fqdn: The FQDN of this VPN Site Link.
        :param str id: The ID of the VPN Site Link.
        :param str ip_address: The IP address of this VPN Site Link.
               
               > **NOTE:** Either `fqdn` or `ip_address` should be specified.
        :param str provider_name: The name of the physical link at the VPN Site. Example: `ATT`, `Verizon`.
        :param int speed_in_mbps: The speed of the VPN device at the branch location in unit of mbps. Defaults to `0`.
        """
        pulumi.set(__self__, "name", name)
        if bgp is not None:
            pulumi.set(__self__, "bgp", bgp)
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if provider_name is not None:
            pulumi.set(__self__, "provider_name", provider_name)
        if speed_in_mbps is not None:
            pulumi.set(__self__, "speed_in_mbps", speed_in_mbps)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this VPN Site Link.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def bgp(self) -> Optional['outputs.VpnSiteLinkBgp']:
        """
        A `bgp` block as defined above.

        > **NOTE:** The `link.bgp` has to be set when the `address_cidrs` isn't specified.
        """
        return pulumi.get(self, "bgp")

    @property
    @pulumi.getter
    def fqdn(self) -> Optional[str]:
        """
        The FQDN of this VPN Site Link.
        """
        return pulumi.get(self, "fqdn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the VPN Site Link.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The IP address of this VPN Site Link.

        > **NOTE:** Either `fqdn` or `ip_address` should be specified.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> Optional[str]:
        """
        The name of the physical link at the VPN Site. Example: `ATT`, `Verizon`.
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter(name="speedInMbps")
    def speed_in_mbps(self) -> Optional[int]:
        """
        The speed of the VPN device at the branch location in unit of mbps. Defaults to `0`.
        """
        return pulumi.get(self, "speed_in_mbps")


@pulumi.output_type
class VpnSiteLinkBgp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "peeringAddress":
            suggest = "peering_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnSiteLinkBgp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnSiteLinkBgp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnSiteLinkBgp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 asn: int,
                 peering_address: str):
        """
        :param int asn: The BGP speaker's ASN.
        :param str peering_address: The BGP peering IP address.
        """
        pulumi.set(__self__, "asn", asn)
        pulumi.set(__self__, "peering_address", peering_address)

    @property
    @pulumi.getter
    def asn(self) -> int:
        """
        The BGP speaker's ASN.
        """
        return pulumi.get(self, "asn")

    @property
    @pulumi.getter(name="peeringAddress")
    def peering_address(self) -> str:
        """
        The BGP peering IP address.
        """
        return pulumi.get(self, "peering_address")


@pulumi.output_type
class VpnSiteO365Policy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trafficCategory":
            suggest = "traffic_category"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnSiteO365Policy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnSiteO365Policy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnSiteO365Policy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 traffic_category: Optional['outputs.VpnSiteO365PolicyTrafficCategory'] = None):
        """
        :param 'VpnSiteO365PolicyTrafficCategoryArgs' traffic_category: A `traffic_category` block as defined above.
        """
        if traffic_category is not None:
            pulumi.set(__self__, "traffic_category", traffic_category)

    @property
    @pulumi.getter(name="trafficCategory")
    def traffic_category(self) -> Optional['outputs.VpnSiteO365PolicyTrafficCategory']:
        """
        A `traffic_category` block as defined above.
        """
        return pulumi.get(self, "traffic_category")


@pulumi.output_type
class VpnSiteO365PolicyTrafficCategory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowEndpointEnabled":
            suggest = "allow_endpoint_enabled"
        elif key == "defaultEndpointEnabled":
            suggest = "default_endpoint_enabled"
        elif key == "optimizeEndpointEnabled":
            suggest = "optimize_endpoint_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnSiteO365PolicyTrafficCategory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnSiteO365PolicyTrafficCategory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnSiteO365PolicyTrafficCategory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_endpoint_enabled: Optional[bool] = None,
                 default_endpoint_enabled: Optional[bool] = None,
                 optimize_endpoint_enabled: Optional[bool] = None):
        """
        :param bool allow_endpoint_enabled: Is allow endpoint enabled? The `Allow` endpoint is required for connectivity to specific O365 services and features, but are not as sensitive to network performance and latency as other endpoint types. Defaults to `false`.
        :param bool default_endpoint_enabled: Is default endpoint enabled? The `Default` endpoint represents O365 services and dependencies that do not require any optimization, and can be treated by customer networks as normal Internet bound traffic. Defaults to `false`.
        :param bool optimize_endpoint_enabled: Is optimize endpoint enabled? The `Optimize` endpoint is required for connectivity to every O365 service and represents the O365 scenario that is the most sensitive to network performance, latency, and availability. Defaults to `false`.
        """
        if allow_endpoint_enabled is not None:
            pulumi.set(__self__, "allow_endpoint_enabled", allow_endpoint_enabled)
        if default_endpoint_enabled is not None:
            pulumi.set(__self__, "default_endpoint_enabled", default_endpoint_enabled)
        if optimize_endpoint_enabled is not None:
            pulumi.set(__self__, "optimize_endpoint_enabled", optimize_endpoint_enabled)

    @property
    @pulumi.getter(name="allowEndpointEnabled")
    def allow_endpoint_enabled(self) -> Optional[bool]:
        """
        Is allow endpoint enabled? The `Allow` endpoint is required for connectivity to specific O365 services and features, but are not as sensitive to network performance and latency as other endpoint types. Defaults to `false`.
        """
        return pulumi.get(self, "allow_endpoint_enabled")

    @property
    @pulumi.getter(name="defaultEndpointEnabled")
    def default_endpoint_enabled(self) -> Optional[bool]:
        """
        Is default endpoint enabled? The `Default` endpoint represents O365 services and dependencies that do not require any optimization, and can be treated by customer networks as normal Internet bound traffic. Defaults to `false`.
        """
        return pulumi.get(self, "default_endpoint_enabled")

    @property
    @pulumi.getter(name="optimizeEndpointEnabled")
    def optimize_endpoint_enabled(self) -> Optional[bool]:
        """
        Is optimize endpoint enabled? The `Optimize` endpoint is required for connectivity to every O365 service and represents the O365 scenario that is the most sensitive to network performance, latency, and availability. Defaults to `false`.
        """
        return pulumi.get(self, "optimize_endpoint_enabled")


@pulumi.output_type
class GetApplicationGatewayBackendAddressPoolResult(dict):
    def __init__(__self__, *,
                 fqdns: Sequence[str],
                 id: str,
                 ip_addresses: Sequence[str],
                 name: str):
        """
        :param Sequence[str] fqdns: A list of FQDN's that are included in the Backend Address Pool.
        :param str id: The ID of the Backend Address Pool.
        :param Sequence[str] ip_addresses: A list of IP Addresses that are included in the Backend Address Pool.
        :param str name: The name of this Application Gateway.
        """
        pulumi.set(__self__, "fqdns", fqdns)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ip_addresses", ip_addresses)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def fqdns(self) -> Sequence[str]:
        """
        A list of FQDN's that are included in the Backend Address Pool.
        """
        return pulumi.get(self, "fqdns")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Backend Address Pool.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Sequence[str]:
        """
        A list of IP Addresses that are included in the Backend Address Pool.
        """
        return pulumi.get(self, "ip_addresses")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this Application Gateway.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetApplicationGatewayIdentityResult(dict):
    def __init__(__self__, *,
                 identity_ids: Sequence[str],
                 type: str):
        """
        :param Sequence[str] identity_ids: A list of Managed Identity IDs assigned to this Application Gateway.
        :param str type: The type of Managed Identity assigned to this Application Gateway.
        """
        pulumi.set(__self__, "identity_ids", identity_ids)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Sequence[str]:
        """
        A list of Managed Identity IDs assigned to this Application Gateway.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of Managed Identity assigned to this Application Gateway.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetExpressRouteCircuitPeeringResult(dict):
    def __init__(__self__, *,
                 azure_asn: int,
                 peer_asn: int,
                 peering_type: str,
                 primary_peer_address_prefix: str,
                 secondary_peer_address_prefix: str,
                 shared_key: str,
                 vlan_id: int):
        """
        :param int azure_asn: The Either a 16-bit or a 32-bit ASN for Azure.
        :param int peer_asn: The Either a 16-bit or a 32-bit ASN. Can either be public or private.
        :param str peering_type: The type of the ExpressRoute Circuit Peering. Acceptable values include `AzurePrivatePeering`, `AzurePublicPeering` and `MicrosoftPeering`. Changing this forces a new resource to be created.
        :param str primary_peer_address_prefix: A `/30` subnet for the primary link.
        :param str secondary_peer_address_prefix: A `/30` subnet for the secondary link.
        :param str shared_key: The shared key. Can be a maximum of 25 characters.
        :param int vlan_id: A valid VLAN ID to establish this peering on.
        """
        pulumi.set(__self__, "azure_asn", azure_asn)
        pulumi.set(__self__, "peer_asn", peer_asn)
        pulumi.set(__self__, "peering_type", peering_type)
        pulumi.set(__self__, "primary_peer_address_prefix", primary_peer_address_prefix)
        pulumi.set(__self__, "secondary_peer_address_prefix", secondary_peer_address_prefix)
        pulumi.set(__self__, "shared_key", shared_key)
        pulumi.set(__self__, "vlan_id", vlan_id)

    @property
    @pulumi.getter(name="azureAsn")
    def azure_asn(self) -> int:
        """
        The Either a 16-bit or a 32-bit ASN for Azure.
        """
        return pulumi.get(self, "azure_asn")

    @property
    @pulumi.getter(name="peerAsn")
    def peer_asn(self) -> int:
        """
        The Either a 16-bit or a 32-bit ASN. Can either be public or private.
        """
        return pulumi.get(self, "peer_asn")

    @property
    @pulumi.getter(name="peeringType")
    def peering_type(self) -> str:
        """
        The type of the ExpressRoute Circuit Peering. Acceptable values include `AzurePrivatePeering`, `AzurePublicPeering` and `MicrosoftPeering`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "peering_type")

    @property
    @pulumi.getter(name="primaryPeerAddressPrefix")
    def primary_peer_address_prefix(self) -> str:
        """
        A `/30` subnet for the primary link.
        """
        return pulumi.get(self, "primary_peer_address_prefix")

    @property
    @pulumi.getter(name="secondaryPeerAddressPrefix")
    def secondary_peer_address_prefix(self) -> str:
        """
        A `/30` subnet for the secondary link.
        """
        return pulumi.get(self, "secondary_peer_address_prefix")

    @property
    @pulumi.getter(name="sharedKey")
    def shared_key(self) -> str:
        """
        The shared key. Can be a maximum of 25 characters.
        """
        return pulumi.get(self, "shared_key")

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> int:
        """
        A valid VLAN ID to establish this peering on.
        """
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class GetExpressRouteCircuitServiceProviderPropertyResult(dict):
    def __init__(__self__, *,
                 bandwidth_in_mbps: int,
                 peering_location: str,
                 service_provider_name: str):
        """
        :param int bandwidth_in_mbps: The bandwidth in Mbps of the ExpressRoute circuit.
        :param str peering_location: The name of the peering location and **not** the Azure resource location.
        :param str service_provider_name: The name of the ExpressRoute Service Provider.
        """
        pulumi.set(__self__, "bandwidth_in_mbps", bandwidth_in_mbps)
        pulumi.set(__self__, "peering_location", peering_location)
        pulumi.set(__self__, "service_provider_name", service_provider_name)

    @property
    @pulumi.getter(name="bandwidthInMbps")
    def bandwidth_in_mbps(self) -> int:
        """
        The bandwidth in Mbps of the ExpressRoute circuit.
        """
        return pulumi.get(self, "bandwidth_in_mbps")

    @property
    @pulumi.getter(name="peeringLocation")
    def peering_location(self) -> str:
        """
        The name of the peering location and **not** the Azure resource location.
        """
        return pulumi.get(self, "peering_location")

    @property
    @pulumi.getter(name="serviceProviderName")
    def service_provider_name(self) -> str:
        """
        The name of the ExpressRoute Service Provider.
        """
        return pulumi.get(self, "service_provider_name")


@pulumi.output_type
class GetExpressRouteCircuitSkuResult(dict):
    def __init__(__self__, *,
                 family: str,
                 tier: str):
        """
        :param str family: The billing mode for bandwidth. Possible values are `MeteredData` or `UnlimitedData`.
        :param str tier: The service tier. Possible values are `Basic`, `Local`, `Standard` or `Premium`.
        """
        pulumi.set(__self__, "family", family)
        pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter
    def family(self) -> str:
        """
        The billing mode for bandwidth. Possible values are `MeteredData` or `UnlimitedData`.
        """
        return pulumi.get(self, "family")

    @property
    @pulumi.getter
    def tier(self) -> str:
        """
        The service tier. Possible values are `Basic`, `Local`, `Standard` or `Premium`.
        """
        return pulumi.get(self, "tier")


@pulumi.output_type
class GetFirewallIpConfigurationResult(dict):
    def __init__(__self__, *,
                 name: str,
                 private_ip_address: str,
                 public_ip_address_id: str,
                 subnet_id: str):
        """
        :param str name: The name of the Azure Firewall.
        :param str private_ip_address: The private IP address associated with the Azure Firewall.
        :param str public_ip_address_id: The ID of the Public IP address of the Azure Firewall.
        :param str subnet_id: The ID of the Subnet where the Azure Firewall is deployed.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "private_ip_address", private_ip_address)
        pulumi.set(__self__, "public_ip_address_id", public_ip_address_id)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Azure Firewall.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> str:
        """
        The private IP address associated with the Azure Firewall.
        """
        return pulumi.get(self, "private_ip_address")

    @property
    @pulumi.getter(name="publicIpAddressId")
    def public_ip_address_id(self) -> str:
        """
        The ID of the Public IP address of the Azure Firewall.
        """
        return pulumi.get(self, "public_ip_address_id")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The ID of the Subnet where the Azure Firewall is deployed.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetFirewallManagementIpConfigurationResult(dict):
    def __init__(__self__, *,
                 name: str,
                 private_ip_address: str,
                 public_ip_address_id: str,
                 subnet_id: str):
        """
        :param str name: The name of the Azure Firewall.
        :param str private_ip_address: The private IP address associated with the Azure Firewall.
        :param str public_ip_address_id: The ID of the Public IP address of the Azure Firewall.
        :param str subnet_id: The ID of the Subnet where the Azure Firewall is deployed.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "private_ip_address", private_ip_address)
        pulumi.set(__self__, "public_ip_address_id", public_ip_address_id)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Azure Firewall.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> str:
        """
        The private IP address associated with the Azure Firewall.
        """
        return pulumi.get(self, "private_ip_address")

    @property
    @pulumi.getter(name="publicIpAddressId")
    def public_ip_address_id(self) -> str:
        """
        The ID of the Public IP address of the Azure Firewall.
        """
        return pulumi.get(self, "public_ip_address_id")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The ID of the Subnet where the Azure Firewall is deployed.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetFirewallPolicyDnResult(dict):
    def __init__(__self__, *,
                 network_rule_fqdn_enabled: bool,
                 proxy_enabled: bool,
                 servers: Sequence[str]):
        pulumi.set(__self__, "network_rule_fqdn_enabled", network_rule_fqdn_enabled)
        pulumi.set(__self__, "proxy_enabled", proxy_enabled)
        pulumi.set(__self__, "servers", servers)

    @property
    @pulumi.getter(name="networkRuleFqdnEnabled")
    def network_rule_fqdn_enabled(self) -> bool:
        return pulumi.get(self, "network_rule_fqdn_enabled")

    @property
    @pulumi.getter(name="proxyEnabled")
    def proxy_enabled(self) -> bool:
        return pulumi.get(self, "proxy_enabled")

    @property
    @pulumi.getter
    def servers(self) -> Sequence[str]:
        return pulumi.get(self, "servers")


@pulumi.output_type
class GetFirewallPolicyThreatIntelligenceAllowlistResult(dict):
    def __init__(__self__, *,
                 fqdns: Sequence[str],
                 ip_addresses: Sequence[str]):
        pulumi.set(__self__, "fqdns", fqdns)
        pulumi.set(__self__, "ip_addresses", ip_addresses)

    @property
    @pulumi.getter
    def fqdns(self) -> Sequence[str]:
        return pulumi.get(self, "fqdns")

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Sequence[str]:
        return pulumi.get(self, "ip_addresses")


@pulumi.output_type
class GetFirewallVirtualHubResult(dict):
    def __init__(__self__, *,
                 private_ip_address: str,
                 public_ip_addresses: Sequence[str],
                 public_ip_count: int,
                 virtual_hub_id: str):
        """
        :param str private_ip_address: The private IP address associated with the Azure Firewall.
        :param Sequence[str] public_ip_addresses: The list of public IP addresses associated with the Azure Firewall.
        :param int public_ip_count: The number of public IPs assigned to the Azure Firewall.
        :param str virtual_hub_id: The ID of the Virtual Hub where the Azure Firewall resides in.
        """
        pulumi.set(__self__, "private_ip_address", private_ip_address)
        pulumi.set(__self__, "public_ip_addresses", public_ip_addresses)
        pulumi.set(__self__, "public_ip_count", public_ip_count)
        pulumi.set(__self__, "virtual_hub_id", virtual_hub_id)

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> str:
        """
        The private IP address associated with the Azure Firewall.
        """
        return pulumi.get(self, "private_ip_address")

    @property
    @pulumi.getter(name="publicIpAddresses")
    def public_ip_addresses(self) -> Sequence[str]:
        """
        The list of public IP addresses associated with the Azure Firewall.
        """
        return pulumi.get(self, "public_ip_addresses")

    @property
    @pulumi.getter(name="publicIpCount")
    def public_ip_count(self) -> int:
        """
        The number of public IPs assigned to the Azure Firewall.
        """
        return pulumi.get(self, "public_ip_count")

    @property
    @pulumi.getter(name="virtualHubId")
    def virtual_hub_id(self) -> str:
        """
        The ID of the Virtual Hub where the Azure Firewall resides in.
        """
        return pulumi.get(self, "virtual_hub_id")


@pulumi.output_type
class GetGatewayConnectionIpsecPolicyResult(dict):
    def __init__(__self__, *,
                 dh_group: str,
                 ike_encryption: str,
                 ike_integrity: str,
                 ipsec_encryption: str,
                 ipsec_integrity: str,
                 pfs_group: str,
                 sa_datasize: int,
                 sa_lifetime: int):
        """
        :param str dh_group: The DH group used in IKE phase 1 for initial SA. Valid
               options are `DHGroup1`, `DHGroup14`, `DHGroup2`, `DHGroup2048`, `DHGroup24`,
               `ECP256`, `ECP384`, or `None`.
        :param str ike_encryption: The IKE encryption algorithm. Valid
               options are `AES128`, `AES192`, `AES256`, `DES`, or `DES3`.
        :param str ike_integrity: The IKE integrity algorithm. Valid
               options are `MD5`, `SHA1`, `SHA256`, or `SHA384`.
        :param str ipsec_encryption: The IPSec encryption algorithm. Valid
               options are `AES128`, `AES192`, `AES256`, `DES`, `DES3`, `GCMAES128`, `GCMAES192`, `GCMAES256`, or `None`.
        :param str ipsec_integrity: The IPSec integrity algorithm. Valid
               options are `GCMAES128`, `GCMAES192`, `GCMAES256`, `MD5`, `SHA1`, or `SHA256`.
        :param str pfs_group: The DH group used in IKE phase 2 for new child SA.
               Valid options are `ECP256`, `ECP384`, `PFS1`, `PFS2`, `PFS2048`, `PFS24`,
               or `None`.
        :param int sa_datasize: The IPSec SA payload size in KB. Must be at least
               `1024` KB.
        :param int sa_lifetime: The IPSec SA lifetime in seconds. Must be at least
               `300` seconds.
        """
        pulumi.set(__self__, "dh_group", dh_group)
        pulumi.set(__self__, "ike_encryption", ike_encryption)
        pulumi.set(__self__, "ike_integrity", ike_integrity)
        pulumi.set(__self__, "ipsec_encryption", ipsec_encryption)
        pulumi.set(__self__, "ipsec_integrity", ipsec_integrity)
        pulumi.set(__self__, "pfs_group", pfs_group)
        pulumi.set(__self__, "sa_datasize", sa_datasize)
        pulumi.set(__self__, "sa_lifetime", sa_lifetime)

    @property
    @pulumi.getter(name="dhGroup")
    def dh_group(self) -> str:
        """
        The DH group used in IKE phase 1 for initial SA. Valid
        options are `DHGroup1`, `DHGroup14`, `DHGroup2`, `DHGroup2048`, `DHGroup24`,
        `ECP256`, `ECP384`, or `None`.
        """
        return pulumi.get(self, "dh_group")

    @property
    @pulumi.getter(name="ikeEncryption")
    def ike_encryption(self) -> str:
        """
        The IKE encryption algorithm. Valid
        options are `AES128`, `AES192`, `AES256`, `DES`, or `DES3`.
        """
        return pulumi.get(self, "ike_encryption")

    @property
    @pulumi.getter(name="ikeIntegrity")
    def ike_integrity(self) -> str:
        """
        The IKE integrity algorithm. Valid
        options are `MD5`, `SHA1`, `SHA256`, or `SHA384`.
        """
        return pulumi.get(self, "ike_integrity")

    @property
    @pulumi.getter(name="ipsecEncryption")
    def ipsec_encryption(self) -> str:
        """
        The IPSec encryption algorithm. Valid
        options are `AES128`, `AES192`, `AES256`, `DES`, `DES3`, `GCMAES128`, `GCMAES192`, `GCMAES256`, or `None`.
        """
        return pulumi.get(self, "ipsec_encryption")

    @property
    @pulumi.getter(name="ipsecIntegrity")
    def ipsec_integrity(self) -> str:
        """
        The IPSec integrity algorithm. Valid
        options are `GCMAES128`, `GCMAES192`, `GCMAES256`, `MD5`, `SHA1`, or `SHA256`.
        """
        return pulumi.get(self, "ipsec_integrity")

    @property
    @pulumi.getter(name="pfsGroup")
    def pfs_group(self) -> str:
        """
        The DH group used in IKE phase 2 for new child SA.
        Valid options are `ECP256`, `ECP384`, `PFS1`, `PFS2`, `PFS2048`, `PFS24`,
        or `None`.
        """
        return pulumi.get(self, "pfs_group")

    @property
    @pulumi.getter(name="saDatasize")
    def sa_datasize(self) -> int:
        """
        The IPSec SA payload size in KB. Must be at least
        `1024` KB.
        """
        return pulumi.get(self, "sa_datasize")

    @property
    @pulumi.getter(name="saLifetime")
    def sa_lifetime(self) -> int:
        """
        The IPSec SA lifetime in seconds. Must be at least
        `300` seconds.
        """
        return pulumi.get(self, "sa_lifetime")


@pulumi.output_type
class GetGatewayConnectionTrafficSelectorPolicyResult(dict):
    def __init__(__self__, *,
                 local_address_cidrs: Sequence[str],
                 remote_address_cidrs: Sequence[str]):
        """
        :param Sequence[str] local_address_cidrs: List of local CIDRs.
        :param Sequence[str] remote_address_cidrs: List of remote CIDRs.
        """
        pulumi.set(__self__, "local_address_cidrs", local_address_cidrs)
        pulumi.set(__self__, "remote_address_cidrs", remote_address_cidrs)

    @property
    @pulumi.getter(name="localAddressCidrs")
    def local_address_cidrs(self) -> Sequence[str]:
        """
        List of local CIDRs.
        """
        return pulumi.get(self, "local_address_cidrs")

    @property
    @pulumi.getter(name="remoteAddressCidrs")
    def remote_address_cidrs(self) -> Sequence[str]:
        """
        List of remote CIDRs.
        """
        return pulumi.get(self, "remote_address_cidrs")


@pulumi.output_type
class GetLocalNetworkGatewayBgpSettingResult(dict):
    def __init__(__self__, *,
                 asn: int,
                 bgp_peering_address: str,
                 peer_weight: int):
        """
        :param int asn: The BGP speaker's ASN.
        :param str bgp_peering_address: The BGP peering address and BGP identifier of this BGP speaker.
        :param int peer_weight: The weight added to routes learned from this BGP speaker.
        """
        pulumi.set(__self__, "asn", asn)
        pulumi.set(__self__, "bgp_peering_address", bgp_peering_address)
        pulumi.set(__self__, "peer_weight", peer_weight)

    @property
    @pulumi.getter
    def asn(self) -> int:
        """
        The BGP speaker's ASN.
        """
        return pulumi.get(self, "asn")

    @property
    @pulumi.getter(name="bgpPeeringAddress")
    def bgp_peering_address(self) -> str:
        """
        The BGP peering address and BGP identifier of this BGP speaker.
        """
        return pulumi.get(self, "bgp_peering_address")

    @property
    @pulumi.getter(name="peerWeight")
    def peer_weight(self) -> int:
        """
        The weight added to routes learned from this BGP speaker.
        """
        return pulumi.get(self, "peer_weight")


@pulumi.output_type
class GetNetworkInterfaceIpConfigurationResult(dict):
    def __init__(__self__, *,
                 application_gateway_backend_address_pools_ids: Sequence[str],
                 application_security_group_ids: Sequence[str],
                 gateway_load_balancer_frontend_ip_configuration_id: str,
                 load_balancer_backend_address_pools_ids: Sequence[str],
                 load_balancer_inbound_nat_rules_ids: Sequence[str],
                 name: str,
                 primary: bool,
                 private_ip_address: str,
                 private_ip_address_allocation: str,
                 private_ip_address_version: str,
                 public_ip_address_id: str,
                 subnet_id: str):
        """
        :param Sequence[str] application_gateway_backend_address_pools_ids: A list of Backend Address Pool IDs within a Application Gateway that this Network Interface is connected to.
        :param str gateway_load_balancer_frontend_ip_configuration_id: The Frontend IP Configuration ID of a Gateway SKU Load Balancer the Network Interface is consuming.
        :param Sequence[str] load_balancer_backend_address_pools_ids: A list of Backend Address Pool IDs within a Load Balancer that this Network Interface is connected to.
        :param Sequence[str] load_balancer_inbound_nat_rules_ids: A list of Inbound NAT Rule IDs within a Load Balancer that this Network Interface is connected to.
        :param str name: Specifies the name of the Network Interface.
        :param bool primary: is this the Primary IP Configuration for this Network Interface?
        :param str private_ip_address: The Private IP Address assigned to this Network Interface.
        :param str private_ip_address_allocation: The IP Address allocation type for the Private address, such as `Dynamic` or `Static`.
        :param str public_ip_address_id: The ID of the Public IP Address which is connected to this Network Interface.
        :param str subnet_id: The ID of the Subnet which the Network Interface is connected to.
        """
        pulumi.set(__self__, "application_gateway_backend_address_pools_ids", application_gateway_backend_address_pools_ids)
        pulumi.set(__self__, "application_security_group_ids", application_security_group_ids)
        pulumi.set(__self__, "gateway_load_balancer_frontend_ip_configuration_id", gateway_load_balancer_frontend_ip_configuration_id)
        pulumi.set(__self__, "load_balancer_backend_address_pools_ids", load_balancer_backend_address_pools_ids)
        pulumi.set(__self__, "load_balancer_inbound_nat_rules_ids", load_balancer_inbound_nat_rules_ids)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "primary", primary)
        pulumi.set(__self__, "private_ip_address", private_ip_address)
        pulumi.set(__self__, "private_ip_address_allocation", private_ip_address_allocation)
        pulumi.set(__self__, "private_ip_address_version", private_ip_address_version)
        pulumi.set(__self__, "public_ip_address_id", public_ip_address_id)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="applicationGatewayBackendAddressPoolsIds")
    def application_gateway_backend_address_pools_ids(self) -> Sequence[str]:
        """
        A list of Backend Address Pool IDs within a Application Gateway that this Network Interface is connected to.
        """
        return pulumi.get(self, "application_gateway_backend_address_pools_ids")

    @property
    @pulumi.getter(name="applicationSecurityGroupIds")
    def application_security_group_ids(self) -> Sequence[str]:
        return pulumi.get(self, "application_security_group_ids")

    @property
    @pulumi.getter(name="gatewayLoadBalancerFrontendIpConfigurationId")
    def gateway_load_balancer_frontend_ip_configuration_id(self) -> str:
        """
        The Frontend IP Configuration ID of a Gateway SKU Load Balancer the Network Interface is consuming.
        """
        return pulumi.get(self, "gateway_load_balancer_frontend_ip_configuration_id")

    @property
    @pulumi.getter(name="loadBalancerBackendAddressPoolsIds")
    def load_balancer_backend_address_pools_ids(self) -> Sequence[str]:
        """
        A list of Backend Address Pool IDs within a Load Balancer that this Network Interface is connected to.
        """
        return pulumi.get(self, "load_balancer_backend_address_pools_ids")

    @property
    @pulumi.getter(name="loadBalancerInboundNatRulesIds")
    def load_balancer_inbound_nat_rules_ids(self) -> Sequence[str]:
        """
        A list of Inbound NAT Rule IDs within a Load Balancer that this Network Interface is connected to.
        """
        return pulumi.get(self, "load_balancer_inbound_nat_rules_ids")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Network Interface.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def primary(self) -> bool:
        """
        is this the Primary IP Configuration for this Network Interface?
        """
        return pulumi.get(self, "primary")

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> str:
        """
        The Private IP Address assigned to this Network Interface.
        """
        return pulumi.get(self, "private_ip_address")

    @property
    @pulumi.getter(name="privateIpAddressAllocation")
    def private_ip_address_allocation(self) -> str:
        """
        The IP Address allocation type for the Private address, such as `Dynamic` or `Static`.
        """
        return pulumi.get(self, "private_ip_address_allocation")

    @property
    @pulumi.getter(name="privateIpAddressVersion")
    def private_ip_address_version(self) -> str:
        return pulumi.get(self, "private_ip_address_version")

    @property
    @pulumi.getter(name="publicIpAddressId")
    def public_ip_address_id(self) -> str:
        """
        The ID of the Public IP Address which is connected to this Network Interface.
        """
        return pulumi.get(self, "public_ip_address_id")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The ID of the Subnet which the Network Interface is connected to.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetNetworkSecurityGroupSecurityRuleResult(dict):
    def __init__(__self__, *,
                 access: str,
                 description: str,
                 destination_address_prefix: str,
                 destination_address_prefixes: Sequence[str],
                 destination_port_range: str,
                 destination_port_ranges: Sequence[str],
                 direction: str,
                 name: str,
                 priority: int,
                 protocol: str,
                 source_address_prefix: str,
                 source_address_prefixes: Sequence[str],
                 source_port_range: str,
                 source_port_ranges: Sequence[str],
                 destination_application_security_group_ids: Optional[Sequence[str]] = None,
                 source_application_security_group_ids: Optional[Sequence[str]] = None):
        """
        :param str access: Is network traffic is allowed or denied?
        :param str description: The description for this rule.
        :param str destination_address_prefix: CIDR or destination IP range or * to match any IP.
        :param Sequence[str] destination_address_prefixes: A list of CIDRs or destination IP ranges.
        :param str destination_port_range: The Destination Port or Range.
        :param str direction: The direction specifies if rule will be evaluated on incoming or outgoing traffic.
        :param str name: Specifies the Name of the Network Security Group.
        :param int priority: The priority of the rule
        :param str protocol: The network protocol this rule applies to.
        :param str source_address_prefix: CIDR or source IP range or * to match any IP.
        :param Sequence[str] source_address_prefixes: A list of CIDRs or source IP ranges.
        :param str source_port_range: The Source Port or Range.
        :param Sequence[str] destination_application_security_group_ids: A List of destination Application Security Group IDs
        :param Sequence[str] source_application_security_group_ids: A List of source Application Security Group IDs
        """
        pulumi.set(__self__, "access", access)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "destination_address_prefix", destination_address_prefix)
        pulumi.set(__self__, "destination_address_prefixes", destination_address_prefixes)
        pulumi.set(__self__, "destination_port_range", destination_port_range)
        pulumi.set(__self__, "destination_port_ranges", destination_port_ranges)
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "source_address_prefix", source_address_prefix)
        pulumi.set(__self__, "source_address_prefixes", source_address_prefixes)
        pulumi.set(__self__, "source_port_range", source_port_range)
        pulumi.set(__self__, "source_port_ranges", source_port_ranges)
        if destination_application_security_group_ids is not None:
            pulumi.set(__self__, "destination_application_security_group_ids", destination_application_security_group_ids)
        if source_application_security_group_ids is not None:
            pulumi.set(__self__, "source_application_security_group_ids", source_application_security_group_ids)

    @property
    @pulumi.getter
    def access(self) -> str:
        """
        Is network traffic is allowed or denied?
        """
        return pulumi.get(self, "access")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description for this rule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="destinationAddressPrefix")
    def destination_address_prefix(self) -> str:
        """
        CIDR or destination IP range or * to match any IP.
        """
        return pulumi.get(self, "destination_address_prefix")

    @property
    @pulumi.getter(name="destinationAddressPrefixes")
    def destination_address_prefixes(self) -> Sequence[str]:
        """
        A list of CIDRs or destination IP ranges.
        """
        return pulumi.get(self, "destination_address_prefixes")

    @property
    @pulumi.getter(name="destinationPortRange")
    def destination_port_range(self) -> str:
        """
        The Destination Port or Range.
        """
        return pulumi.get(self, "destination_port_range")

    @property
    @pulumi.getter(name="destinationPortRanges")
    def destination_port_ranges(self) -> Sequence[str]:
        return pulumi.get(self, "destination_port_ranges")

    @property
    @pulumi.getter
    def direction(self) -> str:
        """
        The direction specifies if rule will be evaluated on incoming or outgoing traffic.
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the Name of the Network Security Group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        The priority of the rule
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The network protocol this rule applies to.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="sourceAddressPrefix")
    def source_address_prefix(self) -> str:
        """
        CIDR or source IP range or * to match any IP.
        """
        return pulumi.get(self, "source_address_prefix")

    @property
    @pulumi.getter(name="sourceAddressPrefixes")
    def source_address_prefixes(self) -> Sequence[str]:
        """
        A list of CIDRs or source IP ranges.
        """
        return pulumi.get(self, "source_address_prefixes")

    @property
    @pulumi.getter(name="sourcePortRange")
    def source_port_range(self) -> str:
        """
        The Source Port or Range.
        """
        return pulumi.get(self, "source_port_range")

    @property
    @pulumi.getter(name="sourcePortRanges")
    def source_port_ranges(self) -> Sequence[str]:
        return pulumi.get(self, "source_port_ranges")

    @property
    @pulumi.getter(name="destinationApplicationSecurityGroupIds")
    def destination_application_security_group_ids(self) -> Optional[Sequence[str]]:
        """
        A List of destination Application Security Group IDs
        """
        return pulumi.get(self, "destination_application_security_group_ids")

    @property
    @pulumi.getter(name="sourceApplicationSecurityGroupIds")
    def source_application_security_group_ids(self) -> Optional[Sequence[str]]:
        """
        A List of source Application Security Group IDs
        """
        return pulumi.get(self, "source_application_security_group_ids")


@pulumi.output_type
class GetPublicIPsPublicIpResult(dict):
    def __init__(__self__, *,
                 domain_name_label: str,
                 fqdn: str,
                 id: str,
                 ip_address: str,
                 name: str):
        """
        :param str domain_name_label: The Domain Name Label of the Public IP Address
        :param str fqdn: The FQDN of the Public IP Address
        :param str id: The ID of the Public IP Address
        :param str ip_address: The IP address of the Public IP Address
        :param str name: The Name of the Public IP Address
        """
        pulumi.set(__self__, "domain_name_label", domain_name_label)
        pulumi.set(__self__, "fqdn", fqdn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="domainNameLabel")
    def domain_name_label(self) -> str:
        """
        The Domain Name Label of the Public IP Address
        """
        return pulumi.get(self, "domain_name_label")

    @property
    @pulumi.getter
    def fqdn(self) -> str:
        """
        The FQDN of the Public IP Address
        """
        return pulumi.get(self, "fqdn")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Public IP Address
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The IP address of the Public IP Address
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Name of the Public IP Address
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetRouteFilterRuleResult(dict):
    def __init__(__self__, *,
                 access: str,
                 communities: Sequence[str],
                 name: str,
                 rule_type: str):
        """
        :param str access: The access type of the rule
        :param Sequence[str] communities: The collection for bgp community values.
        :param str name: The Name of this Route Filter.
        :param str rule_type: The Route Filter Rule Type.
        """
        pulumi.set(__self__, "access", access)
        pulumi.set(__self__, "communities", communities)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "rule_type", rule_type)

    @property
    @pulumi.getter
    def access(self) -> str:
        """
        The access type of the rule
        """
        return pulumi.get(self, "access")

    @property
    @pulumi.getter
    def communities(self) -> Sequence[str]:
        """
        The collection for bgp community values.
        """
        return pulumi.get(self, "communities")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Name of this Route Filter.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> str:
        """
        The Route Filter Rule Type.
        """
        return pulumi.get(self, "rule_type")


@pulumi.output_type
class GetRouteTableRouteResult(dict):
    def __init__(__self__, *,
                 address_prefix: str,
                 name: str,
                 next_hop_in_ip_address: str,
                 next_hop_type: str):
        """
        :param str address_prefix: The destination CIDR to which the route applies.
        :param str name: The name of the Route Table.
        :param str next_hop_in_ip_address: Contains the IP address packets should be forwarded to.
        :param str next_hop_type: The type of Azure hop the packet should be sent to.
        """
        pulumi.set(__self__, "address_prefix", address_prefix)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "next_hop_in_ip_address", next_hop_in_ip_address)
        pulumi.set(__self__, "next_hop_type", next_hop_type)

    @property
    @pulumi.getter(name="addressPrefix")
    def address_prefix(self) -> str:
        """
        The destination CIDR to which the route applies.
        """
        return pulumi.get(self, "address_prefix")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Route Table.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nextHopInIpAddress")
    def next_hop_in_ip_address(self) -> str:
        """
        Contains the IP address packets should be forwarded to.
        """
        return pulumi.get(self, "next_hop_in_ip_address")

    @property
    @pulumi.getter(name="nextHopType")
    def next_hop_type(self) -> str:
        """
        The type of Azure hop the packet should be sent to.
        """
        return pulumi.get(self, "next_hop_type")


@pulumi.output_type
class GetTrafficManagerProfileDnsConfigResult(dict):
    def __init__(__self__, *,
                 relative_name: str,
                 ttl: int):
        """
        :param str relative_name: The relative domain name, this is combined with the domain name used by Traffic Manager to form the FQDN which is exported as documented below.
        :param int ttl: The TTL value of the Profile used by Local DNS resolvers and clients.
        """
        pulumi.set(__self__, "relative_name", relative_name)
        pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter(name="relativeName")
    def relative_name(self) -> str:
        """
        The relative domain name, this is combined with the domain name used by Traffic Manager to form the FQDN which is exported as documented below.
        """
        return pulumi.get(self, "relative_name")

    @property
    @pulumi.getter
    def ttl(self) -> int:
        """
        The TTL value of the Profile used by Local DNS resolvers and clients.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class GetTrafficManagerProfileMonitorConfigResult(dict):
    def __init__(__self__, *,
                 custom_headers: Sequence['outputs.GetTrafficManagerProfileMonitorConfigCustomHeaderResult'],
                 expected_status_code_ranges: Sequence[str],
                 interval_in_seconds: int,
                 path: str,
                 port: int,
                 protocol: str,
                 timeout_in_seconds: int,
                 tolerated_number_of_failures: int):
        """
        :param Sequence['GetTrafficManagerProfileMonitorConfigCustomHeaderArgs'] custom_headers: One or more `custom_header` blocks as defined below.
        :param Sequence[str] expected_status_code_ranges: A list of status code ranges.
        :param int interval_in_seconds: The interval used to check the endpoint health from a Traffic Manager probing agent.
        :param str path: The path used by the monitoring checks.
        :param int port: The port number used by the monitoring checks.
        :param str protocol: The protocol used by the monitoring checks.
        :param int timeout_in_seconds: The amount of time the Traffic Manager probing agent should wait before considering that check a failure when a health check probe is sent to the endpoint.
        :param int tolerated_number_of_failures: The number of failures a Traffic Manager probing agent tolerates before marking that endpoint as unhealthy.
        """
        pulumi.set(__self__, "custom_headers", custom_headers)
        pulumi.set(__self__, "expected_status_code_ranges", expected_status_code_ranges)
        pulumi.set(__self__, "interval_in_seconds", interval_in_seconds)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "timeout_in_seconds", timeout_in_seconds)
        pulumi.set(__self__, "tolerated_number_of_failures", tolerated_number_of_failures)

    @property
    @pulumi.getter(name="customHeaders")
    def custom_headers(self) -> Sequence['outputs.GetTrafficManagerProfileMonitorConfigCustomHeaderResult']:
        """
        One or more `custom_header` blocks as defined below.
        """
        return pulumi.get(self, "custom_headers")

    @property
    @pulumi.getter(name="expectedStatusCodeRanges")
    def expected_status_code_ranges(self) -> Sequence[str]:
        """
        A list of status code ranges.
        """
        return pulumi.get(self, "expected_status_code_ranges")

    @property
    @pulumi.getter(name="intervalInSeconds")
    def interval_in_seconds(self) -> int:
        """
        The interval used to check the endpoint health from a Traffic Manager probing agent.
        """
        return pulumi.get(self, "interval_in_seconds")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The path used by the monitoring checks.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port number used by the monitoring checks.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The protocol used by the monitoring checks.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> int:
        """
        The amount of time the Traffic Manager probing agent should wait before considering that check a failure when a health check probe is sent to the endpoint.
        """
        return pulumi.get(self, "timeout_in_seconds")

    @property
    @pulumi.getter(name="toleratedNumberOfFailures")
    def tolerated_number_of_failures(self) -> int:
        """
        The number of failures a Traffic Manager probing agent tolerates before marking that endpoint as unhealthy.
        """
        return pulumi.get(self, "tolerated_number_of_failures")


@pulumi.output_type
class GetTrafficManagerProfileMonitorConfigCustomHeaderResult(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: Specifies the name of the Traffic Manager Profile.
        :param str value: The value of custom header. Applicable for HTTP and HTTPS protocol.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Traffic Manager Profile.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of custom header. Applicable for HTTP and HTTPS protocol.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetVirtualHubConnectionRoutingResult(dict):
    def __init__(__self__, *,
                 associated_route_table_id: str,
                 propagated_route_tables: Sequence['outputs.GetVirtualHubConnectionRoutingPropagatedRouteTableResult'],
                 static_vnet_routes: Sequence['outputs.GetVirtualHubConnectionRoutingStaticVnetRouteResult']):
        """
        :param str associated_route_table_id: The ID of the route table associated with this Virtual Hub connection.
        :param Sequence['GetVirtualHubConnectionRoutingPropagatedRouteTableArgs'] propagated_route_tables: A `propagated_route_table` block as defined below.
        :param Sequence['GetVirtualHubConnectionRoutingStaticVnetRouteArgs'] static_vnet_routes: A `static_vnet_route` block as defined below.
        """
        pulumi.set(__self__, "associated_route_table_id", associated_route_table_id)
        pulumi.set(__self__, "propagated_route_tables", propagated_route_tables)
        pulumi.set(__self__, "static_vnet_routes", static_vnet_routes)

    @property
    @pulumi.getter(name="associatedRouteTableId")
    def associated_route_table_id(self) -> str:
        """
        The ID of the route table associated with this Virtual Hub connection.
        """
        return pulumi.get(self, "associated_route_table_id")

    @property
    @pulumi.getter(name="propagatedRouteTables")
    def propagated_route_tables(self) -> Sequence['outputs.GetVirtualHubConnectionRoutingPropagatedRouteTableResult']:
        """
        A `propagated_route_table` block as defined below.
        """
        return pulumi.get(self, "propagated_route_tables")

    @property
    @pulumi.getter(name="staticVnetRoutes")
    def static_vnet_routes(self) -> Sequence['outputs.GetVirtualHubConnectionRoutingStaticVnetRouteResult']:
        """
        A `static_vnet_route` block as defined below.
        """
        return pulumi.get(self, "static_vnet_routes")


@pulumi.output_type
class GetVirtualHubConnectionRoutingPropagatedRouteTableResult(dict):
    def __init__(__self__, *,
                 labels: Sequence[str],
                 route_table_ids: Sequence[str]):
        """
        :param Sequence[str] labels: The list of labels assigned to this route table.
        :param Sequence[str] route_table_ids: A list of Route Table IDs associated with this Virtual Hub Connection.
        """
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "route_table_ids", route_table_ids)

    @property
    @pulumi.getter
    def labels(self) -> Sequence[str]:
        """
        The list of labels assigned to this route table.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="routeTableIds")
    def route_table_ids(self) -> Sequence[str]:
        """
        A list of Route Table IDs associated with this Virtual Hub Connection.
        """
        return pulumi.get(self, "route_table_ids")


@pulumi.output_type
class GetVirtualHubConnectionRoutingStaticVnetRouteResult(dict):
    def __init__(__self__, *,
                 address_prefixes: Sequence[str],
                 name: str,
                 next_hop_ip_address: str):
        """
        :param Sequence[str] address_prefixes: A list of CIDR Ranges which is used as Address Prefixes.
        :param str name: The name of the Connection which should be retrieved.
        :param str next_hop_ip_address: The IP Address which is used for the Next Hop.
        """
        pulumi.set(__self__, "address_prefixes", address_prefixes)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "next_hop_ip_address", next_hop_ip_address)

    @property
    @pulumi.getter(name="addressPrefixes")
    def address_prefixes(self) -> Sequence[str]:
        """
        A list of CIDR Ranges which is used as Address Prefixes.
        """
        return pulumi.get(self, "address_prefixes")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Connection which should be retrieved.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nextHopIpAddress")
    def next_hop_ip_address(self) -> str:
        """
        The IP Address which is used for the Next Hop.
        """
        return pulumi.get(self, "next_hop_ip_address")


@pulumi.output_type
class GetVirtualHubRouteTableRouteResult(dict):
    def __init__(__self__, *,
                 destinations: Sequence[str],
                 destinations_type: str,
                 name: str,
                 next_hop: str,
                 next_hop_type: str):
        """
        :param Sequence[str] destinations: A list of destination addresses for this route.
        :param str destinations_type: The type of destinations.
        :param str name: The name of the Virtual Hub Route Table.
        :param str next_hop: The next hop's resource ID.
        :param str next_hop_type: The type of next hop.
        """
        pulumi.set(__self__, "destinations", destinations)
        pulumi.set(__self__, "destinations_type", destinations_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "next_hop", next_hop)
        pulumi.set(__self__, "next_hop_type", next_hop_type)

    @property
    @pulumi.getter
    def destinations(self) -> Sequence[str]:
        """
        A list of destination addresses for this route.
        """
        return pulumi.get(self, "destinations")

    @property
    @pulumi.getter(name="destinationsType")
    def destinations_type(self) -> str:
        """
        The type of destinations.
        """
        return pulumi.get(self, "destinations_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Virtual Hub Route Table.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nextHop")
    def next_hop(self) -> str:
        """
        The next hop's resource ID.
        """
        return pulumi.get(self, "next_hop")

    @property
    @pulumi.getter(name="nextHopType")
    def next_hop_type(self) -> str:
        """
        The type of next hop.
        """
        return pulumi.get(self, "next_hop_type")


@pulumi.output_type
class GetVirtualNetworkGatewayBgpSettingResult(dict):
    def __init__(__self__, *,
                 asn: int,
                 peer_weight: int,
                 peering_address: str):
        """
        :param int asn: The Autonomous System Number (ASN) to use as part of the BGP.
        :param int peer_weight: The weight added to routes which have been learned
               through BGP peering.
        :param str peering_address: The BGP peer IP address of the virtual network
               gateway. This address is needed to configure the created gateway as a BGP Peer
               on the on-premises VPN devices.
        """
        pulumi.set(__self__, "asn", asn)
        pulumi.set(__self__, "peer_weight", peer_weight)
        pulumi.set(__self__, "peering_address", peering_address)

    @property
    @pulumi.getter
    def asn(self) -> int:
        """
        The Autonomous System Number (ASN) to use as part of the BGP.
        """
        return pulumi.get(self, "asn")

    @property
    @pulumi.getter(name="peerWeight")
    def peer_weight(self) -> int:
        """
        The weight added to routes which have been learned
        through BGP peering.
        """
        return pulumi.get(self, "peer_weight")

    @property
    @pulumi.getter(name="peeringAddress")
    def peering_address(self) -> str:
        """
        The BGP peer IP address of the virtual network
        gateway. This address is needed to configure the created gateway as a BGP Peer
        on the on-premises VPN devices.
        """
        return pulumi.get(self, "peering_address")


@pulumi.output_type
class GetVirtualNetworkGatewayCustomRouteResult(dict):
    def __init__(__self__, *,
                 address_prefixes: Sequence[str]):
        """
        :param Sequence[str] address_prefixes: A list of address blocks reserved for this virtual network in CIDR notation.
        """
        pulumi.set(__self__, "address_prefixes", address_prefixes)

    @property
    @pulumi.getter(name="addressPrefixes")
    def address_prefixes(self) -> Sequence[str]:
        """
        A list of address blocks reserved for this virtual network in CIDR notation.
        """
        return pulumi.get(self, "address_prefixes")


@pulumi.output_type
class GetVirtualNetworkGatewayIpConfigurationResult(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str,
                 private_ip_address: str,
                 private_ip_address_allocation: str,
                 public_ip_address_id: str,
                 subnet_id: str):
        """
        :param str id: The resource ID of the IP configuration.
        :param str name: Specifies the name of the Virtual Network Gateway.
        :param str private_ip_address: The Private IP Address associated with the Virtual Network Gateway.
        :param str private_ip_address_allocation: Defines how the private IP address
               of the gateways virtual interface is assigned.
        :param str public_ip_address_id: The ID of the Public IP Address associated
               with the Virtual Network Gateway.
        :param str subnet_id: The ID of the gateway subnet of a virtual network in
               which the virtual network gateway will be created. It is mandatory that
               the associated subnet is named `GatewaySubnet`. Therefore, each virtual
               network can contain at most a single Virtual Network Gateway.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "private_ip_address", private_ip_address)
        pulumi.set(__self__, "private_ip_address_allocation", private_ip_address_allocation)
        pulumi.set(__self__, "public_ip_address_id", public_ip_address_id)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The resource ID of the IP configuration.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Virtual Network Gateway.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> str:
        """
        The Private IP Address associated with the Virtual Network Gateway.
        """
        return pulumi.get(self, "private_ip_address")

    @property
    @pulumi.getter(name="privateIpAddressAllocation")
    def private_ip_address_allocation(self) -> str:
        """
        Defines how the private IP address
        of the gateways virtual interface is assigned.
        """
        return pulumi.get(self, "private_ip_address_allocation")

    @property
    @pulumi.getter(name="publicIpAddressId")
    def public_ip_address_id(self) -> str:
        """
        The ID of the Public IP Address associated
        with the Virtual Network Gateway.
        """
        return pulumi.get(self, "public_ip_address_id")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The ID of the gateway subnet of a virtual network in
        which the virtual network gateway will be created. It is mandatory that
        the associated subnet is named `GatewaySubnet`. Therefore, each virtual
        network can contain at most a single Virtual Network Gateway.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetVirtualNetworkGatewayVpnClientConfigurationResult(dict):
    def __init__(__self__, *,
                 aad_audience: str,
                 aad_issuer: str,
                 aad_tenant: str,
                 address_spaces: Sequence[str],
                 radius_server_address: str,
                 radius_server_secret: str,
                 revoked_certificates: Sequence['outputs.GetVirtualNetworkGatewayVpnClientConfigurationRevokedCertificateResult'],
                 root_certificates: Sequence['outputs.GetVirtualNetworkGatewayVpnClientConfigurationRootCertificateResult'],
                 vpn_client_protocols: Sequence[str]):
        """
        :param str aad_audience: The client id of the Azure VPN application.
               See [Create an Active Directory (AD) tenant for P2S OpenVPN protocol connections](https://docs.microsoft.com/en-gb/azure/vpn-gateway/openvpn-azure-ad-tenant-multi-app) for values
               This setting is incompatible with the use of
               `root_certificate` and `revoked_certificate`, `radius_server_address`, and `radius_server_secret`.
        :param str aad_issuer: The STS url for your tenant
               This setting is incompatible with the use of
               `root_certificate` and `revoked_certificate`, `radius_server_address`, and `radius_server_secret`.
        :param str aad_tenant: AzureAD Tenant URL
               This setting is incompatible with the use of
               `root_certificate` and `revoked_certificate`, `radius_server_address`, and `radius_server_secret`.
        :param Sequence[str] address_spaces: The address space out of which IP addresses for
               vpn clients will be taken. You can provide more than one address space, e.g.
               in CIDR notation.
        :param str radius_server_address: The address of the Radius server.
               This setting is incompatible with the use of
               `aad_tenant`, `aad_audience`, `aad_issuer`, `root_certificate` and `revoked_certificate`.
        :param str radius_server_secret: The secret used by the Radius server.
               This setting is incompatible with the use of
               `aad_tenant`, `aad_audience`, `aad_issuer`, `root_certificate` and `revoked_certificate`.
        :param Sequence['GetVirtualNetworkGatewayVpnClientConfigurationRevokedCertificateArgs'] revoked_certificates: One or more `revoked_certificate` blocks which
               are defined below.
               This setting is incompatible with the use of
               `aad_tenant`, `aad_audience`, `aad_issuer`, `radius_server_address`, and `radius_server_secret`.
        :param Sequence['GetVirtualNetworkGatewayVpnClientConfigurationRootCertificateArgs'] root_certificates: One or more `root_certificate` blocks which are
               defined below. These root certificates are used to sign the client certificate
               used by the VPN clients to connect to the gateway.
               This setting is incompatible with the use of
               `aad_tenant`, `aad_audience`, `aad_issuer`, `radius_server_address`, and `radius_server_secret`.
        :param Sequence[str] vpn_client_protocols: List of the protocols supported by the vpn client.
               The supported values are `SSTP`, `IkeV2` and `OpenVPN`.
        """
        pulumi.set(__self__, "aad_audience", aad_audience)
        pulumi.set(__self__, "aad_issuer", aad_issuer)
        pulumi.set(__self__, "aad_tenant", aad_tenant)
        pulumi.set(__self__, "address_spaces", address_spaces)
        pulumi.set(__self__, "radius_server_address", radius_server_address)
        pulumi.set(__self__, "radius_server_secret", radius_server_secret)
        pulumi.set(__self__, "revoked_certificates", revoked_certificates)
        pulumi.set(__self__, "root_certificates", root_certificates)
        pulumi.set(__self__, "vpn_client_protocols", vpn_client_protocols)

    @property
    @pulumi.getter(name="aadAudience")
    def aad_audience(self) -> str:
        """
        The client id of the Azure VPN application.
        See [Create an Active Directory (AD) tenant for P2S OpenVPN protocol connections](https://docs.microsoft.com/en-gb/azure/vpn-gateway/openvpn-azure-ad-tenant-multi-app) for values
        This setting is incompatible with the use of
        `root_certificate` and `revoked_certificate`, `radius_server_address`, and `radius_server_secret`.
        """
        return pulumi.get(self, "aad_audience")

    @property
    @pulumi.getter(name="aadIssuer")
    def aad_issuer(self) -> str:
        """
        The STS url for your tenant
        This setting is incompatible with the use of
        `root_certificate` and `revoked_certificate`, `radius_server_address`, and `radius_server_secret`.
        """
        return pulumi.get(self, "aad_issuer")

    @property
    @pulumi.getter(name="aadTenant")
    def aad_tenant(self) -> str:
        """
        AzureAD Tenant URL
        This setting is incompatible with the use of
        `root_certificate` and `revoked_certificate`, `radius_server_address`, and `radius_server_secret`.
        """
        return pulumi.get(self, "aad_tenant")

    @property
    @pulumi.getter(name="addressSpaces")
    def address_spaces(self) -> Sequence[str]:
        """
        The address space out of which IP addresses for
        vpn clients will be taken. You can provide more than one address space, e.g.
        in CIDR notation.
        """
        return pulumi.get(self, "address_spaces")

    @property
    @pulumi.getter(name="radiusServerAddress")
    def radius_server_address(self) -> str:
        """
        The address of the Radius server.
        This setting is incompatible with the use of
        `aad_tenant`, `aad_audience`, `aad_issuer`, `root_certificate` and `revoked_certificate`.
        """
        return pulumi.get(self, "radius_server_address")

    @property
    @pulumi.getter(name="radiusServerSecret")
    def radius_server_secret(self) -> str:
        """
        The secret used by the Radius server.
        This setting is incompatible with the use of
        `aad_tenant`, `aad_audience`, `aad_issuer`, `root_certificate` and `revoked_certificate`.
        """
        return pulumi.get(self, "radius_server_secret")

    @property
    @pulumi.getter(name="revokedCertificates")
    def revoked_certificates(self) -> Sequence['outputs.GetVirtualNetworkGatewayVpnClientConfigurationRevokedCertificateResult']:
        """
        One or more `revoked_certificate` blocks which
        are defined below.
        This setting is incompatible with the use of
        `aad_tenant`, `aad_audience`, `aad_issuer`, `radius_server_address`, and `radius_server_secret`.
        """
        return pulumi.get(self, "revoked_certificates")

    @property
    @pulumi.getter(name="rootCertificates")
    def root_certificates(self) -> Sequence['outputs.GetVirtualNetworkGatewayVpnClientConfigurationRootCertificateResult']:
        """
        One or more `root_certificate` blocks which are
        defined below. These root certificates are used to sign the client certificate
        used by the VPN clients to connect to the gateway.
        This setting is incompatible with the use of
        `aad_tenant`, `aad_audience`, `aad_issuer`, `radius_server_address`, and `radius_server_secret`.
        """
        return pulumi.get(self, "root_certificates")

    @property
    @pulumi.getter(name="vpnClientProtocols")
    def vpn_client_protocols(self) -> Sequence[str]:
        """
        List of the protocols supported by the vpn client.
        The supported values are `SSTP`, `IkeV2` and `OpenVPN`.
        """
        return pulumi.get(self, "vpn_client_protocols")


@pulumi.output_type
class GetVirtualNetworkGatewayVpnClientConfigurationRevokedCertificateResult(dict):
    def __init__(__self__, *,
                 name: str,
                 thumbprint: str):
        """
        :param str name: Specifies the name of the Virtual Network Gateway.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "thumbprint", thumbprint)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Virtual Network Gateway.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def thumbprint(self) -> str:
        return pulumi.get(self, "thumbprint")


@pulumi.output_type
class GetVirtualNetworkGatewayVpnClientConfigurationRootCertificateResult(dict):
    def __init__(__self__, *,
                 name: str,
                 public_cert_data: str):
        """
        :param str name: Specifies the name of the Virtual Network Gateway.
        :param str public_cert_data: The public certificate of the root certificate
               authority. The certificate must be provided in Base-64 encoded X.509 format
               (PEM).
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "public_cert_data", public_cert_data)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Virtual Network Gateway.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="publicCertData")
    def public_cert_data(self) -> str:
        """
        The public certificate of the root certificate
        authority. The certificate must be provided in Base-64 encoded X.509 format
        (PEM).
        """
        return pulumi.get(self, "public_cert_data")


@pulumi.output_type
class GetVpnGatewayBgpSettingResult(dict):
    def __init__(__self__, *,
                 asn: int,
                 bgp_peering_address: str,
                 instance0_bgp_peering_addresses: Sequence['outputs.GetVpnGatewayBgpSettingInstance0BgpPeeringAddressResult'],
                 instance1_bgp_peering_addresses: Sequence['outputs.GetVpnGatewayBgpSettingInstance1BgpPeeringAddressResult'],
                 peer_weight: int):
        """
        :param int asn: The ASN of the BGP Speaker.
        :param str bgp_peering_address: The Address which should be used for the BGP Peering.
        :param Sequence['GetVpnGatewayBgpSettingInstance0BgpPeeringAddressArgs'] instance0_bgp_peering_addresses: an `instance_bgp_peering_address` block as defined below.
        :param Sequence['GetVpnGatewayBgpSettingInstance1BgpPeeringAddressArgs'] instance1_bgp_peering_addresses: an `instance_bgp_peering_address` block as defined below.
        :param int peer_weight: The weight added to Routes learned from this BGP Speaker.
        """
        pulumi.set(__self__, "asn", asn)
        pulumi.set(__self__, "bgp_peering_address", bgp_peering_address)
        pulumi.set(__self__, "instance0_bgp_peering_addresses", instance0_bgp_peering_addresses)
        pulumi.set(__self__, "instance1_bgp_peering_addresses", instance1_bgp_peering_addresses)
        pulumi.set(__self__, "peer_weight", peer_weight)

    @property
    @pulumi.getter
    def asn(self) -> int:
        """
        The ASN of the BGP Speaker.
        """
        return pulumi.get(self, "asn")

    @property
    @pulumi.getter(name="bgpPeeringAddress")
    def bgp_peering_address(self) -> str:
        """
        The Address which should be used for the BGP Peering.
        """
        return pulumi.get(self, "bgp_peering_address")

    @property
    @pulumi.getter(name="instance0BgpPeeringAddresses")
    def instance0_bgp_peering_addresses(self) -> Sequence['outputs.GetVpnGatewayBgpSettingInstance0BgpPeeringAddressResult']:
        """
        an `instance_bgp_peering_address` block as defined below.
        """
        return pulumi.get(self, "instance0_bgp_peering_addresses")

    @property
    @pulumi.getter(name="instance1BgpPeeringAddresses")
    def instance1_bgp_peering_addresses(self) -> Sequence['outputs.GetVpnGatewayBgpSettingInstance1BgpPeeringAddressResult']:
        """
        an `instance_bgp_peering_address` block as defined below.
        """
        return pulumi.get(self, "instance1_bgp_peering_addresses")

    @property
    @pulumi.getter(name="peerWeight")
    def peer_weight(self) -> int:
        """
        The weight added to Routes learned from this BGP Speaker.
        """
        return pulumi.get(self, "peer_weight")


@pulumi.output_type
class GetVpnGatewayBgpSettingInstance0BgpPeeringAddressResult(dict):
    def __init__(__self__, *,
                 custom_ips: Sequence[str],
                 default_ips: Sequence[str],
                 ip_configuration_id: str,
                 tunnel_ips: Sequence[str]):
        """
        :param Sequence[str] custom_ips: A list of custom BGP peering addresses to assigned to this instance.
        :param Sequence[str] default_ips: The list of default BGP peering addresses which belong to the pre-defined VPN Gateway IP configuration.
        :param str ip_configuration_id: The pre-defined id of VPN Gateway IP Configuration.
        :param Sequence[str] tunnel_ips: The list of tunnel public IP addresses which belong to the pre-defined VPN Gateway IP configuration.
        """
        pulumi.set(__self__, "custom_ips", custom_ips)
        pulumi.set(__self__, "default_ips", default_ips)
        pulumi.set(__self__, "ip_configuration_id", ip_configuration_id)
        pulumi.set(__self__, "tunnel_ips", tunnel_ips)

    @property
    @pulumi.getter(name="customIps")
    def custom_ips(self) -> Sequence[str]:
        """
        A list of custom BGP peering addresses to assigned to this instance.
        """
        return pulumi.get(self, "custom_ips")

    @property
    @pulumi.getter(name="defaultIps")
    def default_ips(self) -> Sequence[str]:
        """
        The list of default BGP peering addresses which belong to the pre-defined VPN Gateway IP configuration.
        """
        return pulumi.get(self, "default_ips")

    @property
    @pulumi.getter(name="ipConfigurationId")
    def ip_configuration_id(self) -> str:
        """
        The pre-defined id of VPN Gateway IP Configuration.
        """
        return pulumi.get(self, "ip_configuration_id")

    @property
    @pulumi.getter(name="tunnelIps")
    def tunnel_ips(self) -> Sequence[str]:
        """
        The list of tunnel public IP addresses which belong to the pre-defined VPN Gateway IP configuration.
        """
        return pulumi.get(self, "tunnel_ips")


@pulumi.output_type
class GetVpnGatewayBgpSettingInstance1BgpPeeringAddressResult(dict):
    def __init__(__self__, *,
                 custom_ips: Sequence[str],
                 default_ips: Sequence[str],
                 ip_configuration_id: str,
                 tunnel_ips: Sequence[str]):
        """
        :param Sequence[str] custom_ips: A list of custom BGP peering addresses to assigned to this instance.
        :param Sequence[str] default_ips: The list of default BGP peering addresses which belong to the pre-defined VPN Gateway IP configuration.
        :param str ip_configuration_id: The pre-defined id of VPN Gateway IP Configuration.
        :param Sequence[str] tunnel_ips: The list of tunnel public IP addresses which belong to the pre-defined VPN Gateway IP configuration.
        """
        pulumi.set(__self__, "custom_ips", custom_ips)
        pulumi.set(__self__, "default_ips", default_ips)
        pulumi.set(__self__, "ip_configuration_id", ip_configuration_id)
        pulumi.set(__self__, "tunnel_ips", tunnel_ips)

    @property
    @pulumi.getter(name="customIps")
    def custom_ips(self) -> Sequence[str]:
        """
        A list of custom BGP peering addresses to assigned to this instance.
        """
        return pulumi.get(self, "custom_ips")

    @property
    @pulumi.getter(name="defaultIps")
    def default_ips(self) -> Sequence[str]:
        """
        The list of default BGP peering addresses which belong to the pre-defined VPN Gateway IP configuration.
        """
        return pulumi.get(self, "default_ips")

    @property
    @pulumi.getter(name="ipConfigurationId")
    def ip_configuration_id(self) -> str:
        """
        The pre-defined id of VPN Gateway IP Configuration.
        """
        return pulumi.get(self, "ip_configuration_id")

    @property
    @pulumi.getter(name="tunnelIps")
    def tunnel_ips(self) -> Sequence[str]:
        """
        The list of tunnel public IP addresses which belong to the pre-defined VPN Gateway IP configuration.
        """
        return pulumi.get(self, "tunnel_ips")


