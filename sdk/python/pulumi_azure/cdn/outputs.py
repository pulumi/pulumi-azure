# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'EndpointCustomDomainCdnManagedHttps',
    'EndpointCustomDomainUserManagedHttps',
    'EndpointDeliveryRule',
    'EndpointDeliveryRuleCacheExpirationAction',
    'EndpointDeliveryRuleCacheKeyQueryStringAction',
    'EndpointDeliveryRuleCookiesCondition',
    'EndpointDeliveryRuleDeviceCondition',
    'EndpointDeliveryRuleHttpVersionCondition',
    'EndpointDeliveryRuleModifyRequestHeaderAction',
    'EndpointDeliveryRuleModifyResponseHeaderAction',
    'EndpointDeliveryRulePostArgCondition',
    'EndpointDeliveryRuleQueryStringCondition',
    'EndpointDeliveryRuleRemoteAddressCondition',
    'EndpointDeliveryRuleRequestBodyCondition',
    'EndpointDeliveryRuleRequestHeaderCondition',
    'EndpointDeliveryRuleRequestMethodCondition',
    'EndpointDeliveryRuleRequestSchemeCondition',
    'EndpointDeliveryRuleRequestUriCondition',
    'EndpointDeliveryRuleUrlFileExtensionCondition',
    'EndpointDeliveryRuleUrlFileNameCondition',
    'EndpointDeliveryRuleUrlPathCondition',
    'EndpointDeliveryRuleUrlRedirectAction',
    'EndpointDeliveryRuleUrlRewriteAction',
    'EndpointGeoFilter',
    'EndpointGlobalDeliveryRule',
    'EndpointGlobalDeliveryRuleCacheExpirationAction',
    'EndpointGlobalDeliveryRuleCacheKeyQueryStringAction',
    'EndpointGlobalDeliveryRuleModifyRequestHeaderAction',
    'EndpointGlobalDeliveryRuleModifyResponseHeaderAction',
    'EndpointGlobalDeliveryRuleUrlRedirectAction',
    'EndpointGlobalDeliveryRuleUrlRewriteAction',
    'EndpointOrigin',
    'FrontdoorFirewallPolicyCustomRule',
    'FrontdoorFirewallPolicyCustomRuleMatchCondition',
    'FrontdoorFirewallPolicyManagedRule',
    'FrontdoorFirewallPolicyManagedRuleExclusion',
    'FrontdoorFirewallPolicyManagedRuleOverride',
    'FrontdoorFirewallPolicyManagedRuleOverrideExclusion',
    'FrontdoorFirewallPolicyManagedRuleOverrideRule',
    'FrontdoorFirewallPolicyManagedRuleOverrideRuleExclusion',
    'FrontdoorOriginGroupHealthProbe',
    'FrontdoorOriginGroupLoadBalancing',
    'FrontdoorOriginPrivateLink',
    'FrontdoorSecurityPolicySecurityPolicies',
    'FrontdoorSecurityPolicySecurityPoliciesFirewall',
    'FrontdoorSecurityPolicySecurityPoliciesFirewallAssociation',
    'FrontdoorSecurityPolicySecurityPoliciesFirewallAssociationDomain',
    'GetFrontdoorOriginGroupHealthProbeResult',
    'GetFrontdoorOriginGroupLoadBalancingResult',
]

@pulumi.output_type
class EndpointCustomDomainCdnManagedHttps(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateType":
            suggest = "certificate_type"
        elif key == "protocolType":
            suggest = "protocol_type"
        elif key == "tlsVersion":
            suggest = "tls_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointCustomDomainCdnManagedHttps. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointCustomDomainCdnManagedHttps.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointCustomDomainCdnManagedHttps.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_type: str,
                 protocol_type: str,
                 tls_version: Optional[str] = None):
        """
        :param str certificate_type: The type of HTTPS certificate. Possible values are `Shared` and `Dedicated`.
        :param str protocol_type: The type of protocol. Possible values are `ServerNameIndication` and `IPBased`.
        :param str tls_version: The minimum TLS protocol version that is used for HTTPS. Possible values are `TLS10` (representing TLS 1.0/1.1), `TLS12` (representing TLS 1.2) and `None` (representing no minimums). Defaults to `TLS12`.
        """
        pulumi.set(__self__, "certificate_type", certificate_type)
        pulumi.set(__self__, "protocol_type", protocol_type)
        if tls_version is not None:
            pulumi.set(__self__, "tls_version", tls_version)

    @property
    @pulumi.getter(name="certificateType")
    def certificate_type(self) -> str:
        """
        The type of HTTPS certificate. Possible values are `Shared` and `Dedicated`.
        """
        return pulumi.get(self, "certificate_type")

    @property
    @pulumi.getter(name="protocolType")
    def protocol_type(self) -> str:
        """
        The type of protocol. Possible values are `ServerNameIndication` and `IPBased`.
        """
        return pulumi.get(self, "protocol_type")

    @property
    @pulumi.getter(name="tlsVersion")
    def tls_version(self) -> Optional[str]:
        """
        The minimum TLS protocol version that is used for HTTPS. Possible values are `TLS10` (representing TLS 1.0/1.1), `TLS12` (representing TLS 1.2) and `None` (representing no minimums). Defaults to `TLS12`.
        """
        return pulumi.get(self, "tls_version")


@pulumi.output_type
class EndpointCustomDomainUserManagedHttps(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVaultCertificateId":
            suggest = "key_vault_certificate_id"
        elif key == "keyVaultSecretId":
            suggest = "key_vault_secret_id"
        elif key == "tlsVersion":
            suggest = "tls_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointCustomDomainUserManagedHttps. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointCustomDomainUserManagedHttps.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointCustomDomainUserManagedHttps.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_vault_certificate_id: Optional[str] = None,
                 key_vault_secret_id: Optional[str] = None,
                 tls_version: Optional[str] = None):
        """
        :param str key_vault_certificate_id: The ID of the Key Vault Certificate that contains the HTTPS certificate. This is deprecated in favor of `key_vault_secret_id`.
        :param str key_vault_secret_id: The ID of the Key Vault Secret that contains the HTTPS certificate.
        :param str tls_version: The minimum TLS protocol version that is used for HTTPS. Possible values are `TLS10` (representing TLS 1.0/1.1), `TLS12` (representing TLS 1.2) and `None` (representing no minimums). Defaults to `TLS12`.
        """
        if key_vault_certificate_id is not None:
            pulumi.set(__self__, "key_vault_certificate_id", key_vault_certificate_id)
        if key_vault_secret_id is not None:
            pulumi.set(__self__, "key_vault_secret_id", key_vault_secret_id)
        if tls_version is not None:
            pulumi.set(__self__, "tls_version", tls_version)

    @property
    @pulumi.getter(name="keyVaultCertificateId")
    def key_vault_certificate_id(self) -> Optional[str]:
        """
        The ID of the Key Vault Certificate that contains the HTTPS certificate. This is deprecated in favor of `key_vault_secret_id`.
        """
        return pulumi.get(self, "key_vault_certificate_id")

    @property
    @pulumi.getter(name="keyVaultSecretId")
    def key_vault_secret_id(self) -> Optional[str]:
        """
        The ID of the Key Vault Secret that contains the HTTPS certificate.
        """
        return pulumi.get(self, "key_vault_secret_id")

    @property
    @pulumi.getter(name="tlsVersion")
    def tls_version(self) -> Optional[str]:
        """
        The minimum TLS protocol version that is used for HTTPS. Possible values are `TLS10` (representing TLS 1.0/1.1), `TLS12` (representing TLS 1.2) and `None` (representing no minimums). Defaults to `TLS12`.
        """
        return pulumi.get(self, "tls_version")


@pulumi.output_type
class EndpointDeliveryRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cacheExpirationAction":
            suggest = "cache_expiration_action"
        elif key == "cacheKeyQueryStringAction":
            suggest = "cache_key_query_string_action"
        elif key == "cookiesConditions":
            suggest = "cookies_conditions"
        elif key == "deviceCondition":
            suggest = "device_condition"
        elif key == "httpVersionConditions":
            suggest = "http_version_conditions"
        elif key == "modifyRequestHeaderActions":
            suggest = "modify_request_header_actions"
        elif key == "modifyResponseHeaderActions":
            suggest = "modify_response_header_actions"
        elif key == "postArgConditions":
            suggest = "post_arg_conditions"
        elif key == "queryStringConditions":
            suggest = "query_string_conditions"
        elif key == "remoteAddressConditions":
            suggest = "remote_address_conditions"
        elif key == "requestBodyConditions":
            suggest = "request_body_conditions"
        elif key == "requestHeaderConditions":
            suggest = "request_header_conditions"
        elif key == "requestMethodCondition":
            suggest = "request_method_condition"
        elif key == "requestSchemeCondition":
            suggest = "request_scheme_condition"
        elif key == "requestUriConditions":
            suggest = "request_uri_conditions"
        elif key == "urlFileExtensionConditions":
            suggest = "url_file_extension_conditions"
        elif key == "urlFileNameConditions":
            suggest = "url_file_name_conditions"
        elif key == "urlPathConditions":
            suggest = "url_path_conditions"
        elif key == "urlRedirectAction":
            suggest = "url_redirect_action"
        elif key == "urlRewriteAction":
            suggest = "url_rewrite_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointDeliveryRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointDeliveryRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointDeliveryRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 order: int,
                 cache_expiration_action: Optional['outputs.EndpointDeliveryRuleCacheExpirationAction'] = None,
                 cache_key_query_string_action: Optional['outputs.EndpointDeliveryRuleCacheKeyQueryStringAction'] = None,
                 cookies_conditions: Optional[Sequence['outputs.EndpointDeliveryRuleCookiesCondition']] = None,
                 device_condition: Optional['outputs.EndpointDeliveryRuleDeviceCondition'] = None,
                 http_version_conditions: Optional[Sequence['outputs.EndpointDeliveryRuleHttpVersionCondition']] = None,
                 modify_request_header_actions: Optional[Sequence['outputs.EndpointDeliveryRuleModifyRequestHeaderAction']] = None,
                 modify_response_header_actions: Optional[Sequence['outputs.EndpointDeliveryRuleModifyResponseHeaderAction']] = None,
                 post_arg_conditions: Optional[Sequence['outputs.EndpointDeliveryRulePostArgCondition']] = None,
                 query_string_conditions: Optional[Sequence['outputs.EndpointDeliveryRuleQueryStringCondition']] = None,
                 remote_address_conditions: Optional[Sequence['outputs.EndpointDeliveryRuleRemoteAddressCondition']] = None,
                 request_body_conditions: Optional[Sequence['outputs.EndpointDeliveryRuleRequestBodyCondition']] = None,
                 request_header_conditions: Optional[Sequence['outputs.EndpointDeliveryRuleRequestHeaderCondition']] = None,
                 request_method_condition: Optional['outputs.EndpointDeliveryRuleRequestMethodCondition'] = None,
                 request_scheme_condition: Optional['outputs.EndpointDeliveryRuleRequestSchemeCondition'] = None,
                 request_uri_conditions: Optional[Sequence['outputs.EndpointDeliveryRuleRequestUriCondition']] = None,
                 url_file_extension_conditions: Optional[Sequence['outputs.EndpointDeliveryRuleUrlFileExtensionCondition']] = None,
                 url_file_name_conditions: Optional[Sequence['outputs.EndpointDeliveryRuleUrlFileNameCondition']] = None,
                 url_path_conditions: Optional[Sequence['outputs.EndpointDeliveryRuleUrlPathCondition']] = None,
                 url_redirect_action: Optional['outputs.EndpointDeliveryRuleUrlRedirectAction'] = None,
                 url_rewrite_action: Optional['outputs.EndpointDeliveryRuleUrlRewriteAction'] = None):
        """
        :param str name: The Name which should be used for this Delivery Rule.
        :param int order: The order used for this rule. The order values should be sequential and begin at `1`.
        :param 'EndpointDeliveryRuleCacheExpirationActionArgs' cache_expiration_action: A `cache_expiration_action` block as defined above.
        :param 'EndpointDeliveryRuleCacheKeyQueryStringActionArgs' cache_key_query_string_action: A `cache_key_query_string_action` block as defined above.
        :param Sequence['EndpointDeliveryRuleCookiesConditionArgs'] cookies_conditions: A `cookies_condition` block as defined above.
        :param 'EndpointDeliveryRuleDeviceConditionArgs' device_condition: A `device_condition` block as defined below.
        :param Sequence['EndpointDeliveryRuleHttpVersionConditionArgs'] http_version_conditions: A `http_version_condition` block as defined below.
        :param Sequence['EndpointDeliveryRuleModifyRequestHeaderActionArgs'] modify_request_header_actions: A `modify_request_header_action` block as defined below.
        :param Sequence['EndpointDeliveryRuleModifyResponseHeaderActionArgs'] modify_response_header_actions: A `modify_response_header_action` block as defined below.
        :param Sequence['EndpointDeliveryRulePostArgConditionArgs'] post_arg_conditions: A `post_arg_condition` block as defined below.
        :param Sequence['EndpointDeliveryRuleQueryStringConditionArgs'] query_string_conditions: A `query_string_condition` block as defined below.
        :param Sequence['EndpointDeliveryRuleRemoteAddressConditionArgs'] remote_address_conditions: A `remote_address_condition` block as defined below.
        :param Sequence['EndpointDeliveryRuleRequestBodyConditionArgs'] request_body_conditions: A `request_body_condition` block as defined below.
        :param Sequence['EndpointDeliveryRuleRequestHeaderConditionArgs'] request_header_conditions: A `request_header_condition` block as defined below.
        :param 'EndpointDeliveryRuleRequestMethodConditionArgs' request_method_condition: A `request_method_condition` block as defined below.
        :param 'EndpointDeliveryRuleRequestSchemeConditionArgs' request_scheme_condition: A `request_scheme_condition` block as defined below.
        :param Sequence['EndpointDeliveryRuleRequestUriConditionArgs'] request_uri_conditions: A `request_uri_condition` block as defined below.
        :param Sequence['EndpointDeliveryRuleUrlFileExtensionConditionArgs'] url_file_extension_conditions: A `url_file_extension_condition` block as defined below.
        :param Sequence['EndpointDeliveryRuleUrlFileNameConditionArgs'] url_file_name_conditions: A `url_file_name_condition` block as defined below.
        :param Sequence['EndpointDeliveryRuleUrlPathConditionArgs'] url_path_conditions: A `url_path_condition` block as defined below.
        :param 'EndpointDeliveryRuleUrlRedirectActionArgs' url_redirect_action: A `url_redirect_action` block as defined below.
        :param 'EndpointDeliveryRuleUrlRewriteActionArgs' url_rewrite_action: A `url_rewrite_action` block as defined below.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "order", order)
        if cache_expiration_action is not None:
            pulumi.set(__self__, "cache_expiration_action", cache_expiration_action)
        if cache_key_query_string_action is not None:
            pulumi.set(__self__, "cache_key_query_string_action", cache_key_query_string_action)
        if cookies_conditions is not None:
            pulumi.set(__self__, "cookies_conditions", cookies_conditions)
        if device_condition is not None:
            pulumi.set(__self__, "device_condition", device_condition)
        if http_version_conditions is not None:
            pulumi.set(__self__, "http_version_conditions", http_version_conditions)
        if modify_request_header_actions is not None:
            pulumi.set(__self__, "modify_request_header_actions", modify_request_header_actions)
        if modify_response_header_actions is not None:
            pulumi.set(__self__, "modify_response_header_actions", modify_response_header_actions)
        if post_arg_conditions is not None:
            pulumi.set(__self__, "post_arg_conditions", post_arg_conditions)
        if query_string_conditions is not None:
            pulumi.set(__self__, "query_string_conditions", query_string_conditions)
        if remote_address_conditions is not None:
            pulumi.set(__self__, "remote_address_conditions", remote_address_conditions)
        if request_body_conditions is not None:
            pulumi.set(__self__, "request_body_conditions", request_body_conditions)
        if request_header_conditions is not None:
            pulumi.set(__self__, "request_header_conditions", request_header_conditions)
        if request_method_condition is not None:
            pulumi.set(__self__, "request_method_condition", request_method_condition)
        if request_scheme_condition is not None:
            pulumi.set(__self__, "request_scheme_condition", request_scheme_condition)
        if request_uri_conditions is not None:
            pulumi.set(__self__, "request_uri_conditions", request_uri_conditions)
        if url_file_extension_conditions is not None:
            pulumi.set(__self__, "url_file_extension_conditions", url_file_extension_conditions)
        if url_file_name_conditions is not None:
            pulumi.set(__self__, "url_file_name_conditions", url_file_name_conditions)
        if url_path_conditions is not None:
            pulumi.set(__self__, "url_path_conditions", url_path_conditions)
        if url_redirect_action is not None:
            pulumi.set(__self__, "url_redirect_action", url_redirect_action)
        if url_rewrite_action is not None:
            pulumi.set(__self__, "url_rewrite_action", url_rewrite_action)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Name which should be used for this Delivery Rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def order(self) -> int:
        """
        The order used for this rule. The order values should be sequential and begin at `1`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter(name="cacheExpirationAction")
    def cache_expiration_action(self) -> Optional['outputs.EndpointDeliveryRuleCacheExpirationAction']:
        """
        A `cache_expiration_action` block as defined above.
        """
        return pulumi.get(self, "cache_expiration_action")

    @property
    @pulumi.getter(name="cacheKeyQueryStringAction")
    def cache_key_query_string_action(self) -> Optional['outputs.EndpointDeliveryRuleCacheKeyQueryStringAction']:
        """
        A `cache_key_query_string_action` block as defined above.
        """
        return pulumi.get(self, "cache_key_query_string_action")

    @property
    @pulumi.getter(name="cookiesConditions")
    def cookies_conditions(self) -> Optional[Sequence['outputs.EndpointDeliveryRuleCookiesCondition']]:
        """
        A `cookies_condition` block as defined above.
        """
        return pulumi.get(self, "cookies_conditions")

    @property
    @pulumi.getter(name="deviceCondition")
    def device_condition(self) -> Optional['outputs.EndpointDeliveryRuleDeviceCondition']:
        """
        A `device_condition` block as defined below.
        """
        return pulumi.get(self, "device_condition")

    @property
    @pulumi.getter(name="httpVersionConditions")
    def http_version_conditions(self) -> Optional[Sequence['outputs.EndpointDeliveryRuleHttpVersionCondition']]:
        """
        A `http_version_condition` block as defined below.
        """
        return pulumi.get(self, "http_version_conditions")

    @property
    @pulumi.getter(name="modifyRequestHeaderActions")
    def modify_request_header_actions(self) -> Optional[Sequence['outputs.EndpointDeliveryRuleModifyRequestHeaderAction']]:
        """
        A `modify_request_header_action` block as defined below.
        """
        return pulumi.get(self, "modify_request_header_actions")

    @property
    @pulumi.getter(name="modifyResponseHeaderActions")
    def modify_response_header_actions(self) -> Optional[Sequence['outputs.EndpointDeliveryRuleModifyResponseHeaderAction']]:
        """
        A `modify_response_header_action` block as defined below.
        """
        return pulumi.get(self, "modify_response_header_actions")

    @property
    @pulumi.getter(name="postArgConditions")
    def post_arg_conditions(self) -> Optional[Sequence['outputs.EndpointDeliveryRulePostArgCondition']]:
        """
        A `post_arg_condition` block as defined below.
        """
        return pulumi.get(self, "post_arg_conditions")

    @property
    @pulumi.getter(name="queryStringConditions")
    def query_string_conditions(self) -> Optional[Sequence['outputs.EndpointDeliveryRuleQueryStringCondition']]:
        """
        A `query_string_condition` block as defined below.
        """
        return pulumi.get(self, "query_string_conditions")

    @property
    @pulumi.getter(name="remoteAddressConditions")
    def remote_address_conditions(self) -> Optional[Sequence['outputs.EndpointDeliveryRuleRemoteAddressCondition']]:
        """
        A `remote_address_condition` block as defined below.
        """
        return pulumi.get(self, "remote_address_conditions")

    @property
    @pulumi.getter(name="requestBodyConditions")
    def request_body_conditions(self) -> Optional[Sequence['outputs.EndpointDeliveryRuleRequestBodyCondition']]:
        """
        A `request_body_condition` block as defined below.
        """
        return pulumi.get(self, "request_body_conditions")

    @property
    @pulumi.getter(name="requestHeaderConditions")
    def request_header_conditions(self) -> Optional[Sequence['outputs.EndpointDeliveryRuleRequestHeaderCondition']]:
        """
        A `request_header_condition` block as defined below.
        """
        return pulumi.get(self, "request_header_conditions")

    @property
    @pulumi.getter(name="requestMethodCondition")
    def request_method_condition(self) -> Optional['outputs.EndpointDeliveryRuleRequestMethodCondition']:
        """
        A `request_method_condition` block as defined below.
        """
        return pulumi.get(self, "request_method_condition")

    @property
    @pulumi.getter(name="requestSchemeCondition")
    def request_scheme_condition(self) -> Optional['outputs.EndpointDeliveryRuleRequestSchemeCondition']:
        """
        A `request_scheme_condition` block as defined below.
        """
        return pulumi.get(self, "request_scheme_condition")

    @property
    @pulumi.getter(name="requestUriConditions")
    def request_uri_conditions(self) -> Optional[Sequence['outputs.EndpointDeliveryRuleRequestUriCondition']]:
        """
        A `request_uri_condition` block as defined below.
        """
        return pulumi.get(self, "request_uri_conditions")

    @property
    @pulumi.getter(name="urlFileExtensionConditions")
    def url_file_extension_conditions(self) -> Optional[Sequence['outputs.EndpointDeliveryRuleUrlFileExtensionCondition']]:
        """
        A `url_file_extension_condition` block as defined below.
        """
        return pulumi.get(self, "url_file_extension_conditions")

    @property
    @pulumi.getter(name="urlFileNameConditions")
    def url_file_name_conditions(self) -> Optional[Sequence['outputs.EndpointDeliveryRuleUrlFileNameCondition']]:
        """
        A `url_file_name_condition` block as defined below.
        """
        return pulumi.get(self, "url_file_name_conditions")

    @property
    @pulumi.getter(name="urlPathConditions")
    def url_path_conditions(self) -> Optional[Sequence['outputs.EndpointDeliveryRuleUrlPathCondition']]:
        """
        A `url_path_condition` block as defined below.
        """
        return pulumi.get(self, "url_path_conditions")

    @property
    @pulumi.getter(name="urlRedirectAction")
    def url_redirect_action(self) -> Optional['outputs.EndpointDeliveryRuleUrlRedirectAction']:
        """
        A `url_redirect_action` block as defined below.
        """
        return pulumi.get(self, "url_redirect_action")

    @property
    @pulumi.getter(name="urlRewriteAction")
    def url_rewrite_action(self) -> Optional['outputs.EndpointDeliveryRuleUrlRewriteAction']:
        """
        A `url_rewrite_action` block as defined below.
        """
        return pulumi.get(self, "url_rewrite_action")


@pulumi.output_type
class EndpointDeliveryRuleCacheExpirationAction(dict):
    def __init__(__self__, *,
                 behavior: str,
                 duration: Optional[str] = None):
        """
        :param str behavior: The behavior of the cache. Valid values are `BypassCache`, `Override` and `SetIfMissing`.
        :param str duration: Duration of the cache. Only allowed when `behavior` is set to `Override` or `SetIfMissing`. Format: `[d.]hh:mm:ss`
        """
        pulumi.set(__self__, "behavior", behavior)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)

    @property
    @pulumi.getter
    def behavior(self) -> str:
        """
        The behavior of the cache. Valid values are `BypassCache`, `Override` and `SetIfMissing`.
        """
        return pulumi.get(self, "behavior")

    @property
    @pulumi.getter
    def duration(self) -> Optional[str]:
        """
        Duration of the cache. Only allowed when `behavior` is set to `Override` or `SetIfMissing`. Format: `[d.]hh:mm:ss`
        """
        return pulumi.get(self, "duration")


@pulumi.output_type
class EndpointDeliveryRuleCacheKeyQueryStringAction(dict):
    def __init__(__self__, *,
                 behavior: str,
                 parameters: Optional[str] = None):
        """
        :param str behavior: The behavior of the cache key for query strings. Valid values are `Exclude`, `ExcludeAll`, `Include` and `IncludeAll`.
        :param str parameters: Comma separated list of parameter values.
        """
        pulumi.set(__self__, "behavior", behavior)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def behavior(self) -> str:
        """
        The behavior of the cache key for query strings. Valid values are `Exclude`, `ExcludeAll`, `Include` and `IncludeAll`.
        """
        return pulumi.get(self, "behavior")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[str]:
        """
        Comma separated list of parameter values.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class EndpointDeliveryRuleCookiesCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointDeliveryRuleCookiesCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointDeliveryRuleCookiesCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointDeliveryRuleCookiesCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 selector: str,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        :param str operator: Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        :param str selector: Name of the cookie.
        :param Sequence[str] match_values: List of values for the cookie. This is required if `operator` is not `Any`.
        :param bool negate_condition: Defaults to `false`.
        :param Sequence[str] transforms: A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "selector", selector)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def selector(self) -> str:
        """
        Name of the cookie.
        """
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        List of values for the cookie. This is required if `operator` is not `Any`.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class EndpointDeliveryRuleDeviceCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointDeliveryRuleDeviceCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointDeliveryRuleDeviceCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointDeliveryRuleDeviceCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_values: Sequence[str],
                 negate_condition: Optional[bool] = None,
                 operator: Optional[str] = None):
        """
        :param Sequence[str] match_values: Valid values are `Desktop` and `Mobile`.
        :param bool negate_condition: Defaults to `false`.
        :param str operator: Valid values are `Equal`.
        """
        pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Sequence[str]:
        """
        Valid values are `Desktop` and `Mobile`.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Valid values are `Equal`.
        """
        return pulumi.get(self, "operator")


@pulumi.output_type
class EndpointDeliveryRuleHttpVersionCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointDeliveryRuleHttpVersionCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointDeliveryRuleHttpVersionCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointDeliveryRuleHttpVersionCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_values: Sequence[str],
                 negate_condition: Optional[bool] = None,
                 operator: Optional[str] = None):
        """
        :param Sequence[str] match_values: Valid values are `0.9`, `1.0`, `1.1` and `2.0`.
        :param bool negate_condition: Defaults to `false`.
        :param str operator: Valid values are `Equal`.
        """
        pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Sequence[str]:
        """
        Valid values are `0.9`, `1.0`, `1.1` and `2.0`.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Valid values are `Equal`.
        """
        return pulumi.get(self, "operator")


@pulumi.output_type
class EndpointDeliveryRuleModifyRequestHeaderAction(dict):
    def __init__(__self__, *,
                 action: str,
                 name: str,
                 value: Optional[str] = None):
        """
        :param str action: Action to be executed on a header value. Valid values are `Append`, `Delete` and `Overwrite`.
        :param str name: The header name.
        :param str value: The value of the header. Only needed when `action` is set to `Append` or `overwrite`.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Action to be executed on a header value. Valid values are `Append`, `Delete` and `Overwrite`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The header name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the header. Only needed when `action` is set to `Append` or `overwrite`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EndpointDeliveryRuleModifyResponseHeaderAction(dict):
    def __init__(__self__, *,
                 action: str,
                 name: str,
                 value: Optional[str] = None):
        """
        :param str action: Action to be executed on a header value. Valid values are `Append`, `Delete` and `Overwrite`.
        :param str name: The header name.
        :param str value: The value of the header. Only needed when `action` is set to `Append` or `overwrite`.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Action to be executed on a header value. Valid values are `Append`, `Delete` and `Overwrite`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The header name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the header. Only needed when `action` is set to `Append` or `overwrite`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EndpointDeliveryRulePostArgCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointDeliveryRulePostArgCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointDeliveryRulePostArgCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointDeliveryRulePostArgCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 selector: str,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        :param str operator: Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        :param str selector: Name of the post arg.
        :param Sequence[str] match_values: List of string values. This is required if `operator` is not `Any`.
        :param bool negate_condition: Defaults to `false`.
        :param Sequence[str] transforms: A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "selector", selector)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def selector(self) -> str:
        """
        Name of the post arg.
        """
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        List of string values. This is required if `operator` is not `Any`.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class EndpointDeliveryRuleQueryStringCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointDeliveryRuleQueryStringCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointDeliveryRuleQueryStringCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointDeliveryRuleQueryStringCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        :param str operator: Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        :param Sequence[str] match_values: List of string values. This is required if `operator` is not `Any`.
        :param bool negate_condition: Defaults to `false`.
        :param Sequence[str] transforms: A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        pulumi.set(__self__, "operator", operator)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        List of string values. This is required if `operator` is not `Any`.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class EndpointDeliveryRuleRemoteAddressCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointDeliveryRuleRemoteAddressCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointDeliveryRuleRemoteAddressCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointDeliveryRuleRemoteAddressCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None):
        """
        :param str operator: Valid values are `Any`, `GeoMatch` and `IPMatch`.
        :param Sequence[str] match_values: List of string values. For `GeoMatch` `operator` this should be a list of country codes (e.g. `US` or `DE`). List of IP address if `operator` equals to `IPMatch`. This is required if `operator` is not `Any`.
        :param bool negate_condition: Defaults to `false`.
        """
        pulumi.set(__self__, "operator", operator)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Valid values are `Any`, `GeoMatch` and `IPMatch`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        List of string values. For `GeoMatch` `operator` this should be a list of country codes (e.g. `US` or `DE`). List of IP address if `operator` equals to `IPMatch`. This is required if `operator` is not `Any`.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "negate_condition")


@pulumi.output_type
class EndpointDeliveryRuleRequestBodyCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointDeliveryRuleRequestBodyCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointDeliveryRuleRequestBodyCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointDeliveryRuleRequestBodyCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        :param str operator: Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        :param Sequence[str] match_values: List of string values. This is required if `operator` is not `Any`.
        :param bool negate_condition: Defaults to `false`.
        :param Sequence[str] transforms: A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        pulumi.set(__self__, "operator", operator)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        List of string values. This is required if `operator` is not `Any`.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class EndpointDeliveryRuleRequestHeaderCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointDeliveryRuleRequestHeaderCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointDeliveryRuleRequestHeaderCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointDeliveryRuleRequestHeaderCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 selector: str,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        :param str operator: Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        :param str selector: Header name.
        :param Sequence[str] match_values: List of header values. This is required if `operator` is not `Any`.
        :param bool negate_condition: Defaults to `false`.
        :param Sequence[str] transforms: A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "selector", selector)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def selector(self) -> str:
        """
        Header name.
        """
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        List of header values. This is required if `operator` is not `Any`.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class EndpointDeliveryRuleRequestMethodCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointDeliveryRuleRequestMethodCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointDeliveryRuleRequestMethodCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointDeliveryRuleRequestMethodCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_values: Sequence[str],
                 negate_condition: Optional[bool] = None,
                 operator: Optional[str] = None):
        """
        :param Sequence[str] match_values: Valid values are `DELETE`, `GET`, `HEAD`, `OPTIONS`, `POST` and `PUT`.
        :param bool negate_condition: Defaults to `false`.
        :param str operator: Valid values are `Equal`.
        """
        pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Sequence[str]:
        """
        Valid values are `DELETE`, `GET`, `HEAD`, `OPTIONS`, `POST` and `PUT`.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Valid values are `Equal`.
        """
        return pulumi.get(self, "operator")


@pulumi.output_type
class EndpointDeliveryRuleRequestSchemeCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointDeliveryRuleRequestSchemeCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointDeliveryRuleRequestSchemeCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointDeliveryRuleRequestSchemeCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_values: Sequence[str],
                 negate_condition: Optional[bool] = None,
                 operator: Optional[str] = None):
        """
        :param Sequence[str] match_values: Valid values are `HTTP` and `HTTPS`.
        :param bool negate_condition: Defaults to `false`.
        :param str operator: Valid values are `Equal`.
        """
        pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Sequence[str]:
        """
        Valid values are `HTTP` and `HTTPS`.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Valid values are `Equal`.
        """
        return pulumi.get(self, "operator")


@pulumi.output_type
class EndpointDeliveryRuleRequestUriCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointDeliveryRuleRequestUriCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointDeliveryRuleRequestUriCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointDeliveryRuleRequestUriCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        :param str operator: Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        :param Sequence[str] match_values: List of string values. This is required if `operator` is not `Any`.
        :param bool negate_condition: Defaults to `false`.
        :param Sequence[str] transforms: A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        pulumi.set(__self__, "operator", operator)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        List of string values. This is required if `operator` is not `Any`.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class EndpointDeliveryRuleUrlFileExtensionCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointDeliveryRuleUrlFileExtensionCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointDeliveryRuleUrlFileExtensionCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointDeliveryRuleUrlFileExtensionCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        :param str operator: Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        :param Sequence[str] match_values: List of string values. This is required if `operator` is not `Any`.
        :param bool negate_condition: Defaults to `false`.
        :param Sequence[str] transforms: A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        pulumi.set(__self__, "operator", operator)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        List of string values. This is required if `operator` is not `Any`.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class EndpointDeliveryRuleUrlFileNameCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointDeliveryRuleUrlFileNameCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointDeliveryRuleUrlFileNameCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointDeliveryRuleUrlFileNameCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        :param str operator: Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        :param Sequence[str] match_values: List of string values. This is required if `operator` is not `Any`.
        :param bool negate_condition: Defaults to `false`.
        :param Sequence[str] transforms: A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        pulumi.set(__self__, "operator", operator)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        List of string values. This is required if `operator` is not `Any`.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class EndpointDeliveryRuleUrlPathCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointDeliveryRuleUrlPathCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointDeliveryRuleUrlPathCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointDeliveryRuleUrlPathCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        :param str operator: Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan`, `LessThanOrEqual`, `RegEx` and `Wildcard`.
        :param Sequence[str] match_values: List of string values. This is required if `operator` is not `Any`.
        :param bool negate_condition: Defaults to `false`.
        :param Sequence[str] transforms: A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        pulumi.set(__self__, "operator", operator)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan`, `LessThanOrEqual`, `RegEx` and `Wildcard`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        List of string values. This is required if `operator` is not `Any`.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class EndpointDeliveryRuleUrlRedirectAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "redirectType":
            suggest = "redirect_type"
        elif key == "queryString":
            suggest = "query_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointDeliveryRuleUrlRedirectAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointDeliveryRuleUrlRedirectAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointDeliveryRuleUrlRedirectAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 redirect_type: str,
                 fragment: Optional[str] = None,
                 hostname: Optional[str] = None,
                 path: Optional[str] = None,
                 protocol: Optional[str] = None,
                 query_string: Optional[str] = None):
        """
        :param str redirect_type: Type of the redirect. Valid values are `Found`, `Moved`, `PermanentRedirect` and `TemporaryRedirect`.
        :param str fragment: Specifies the fragment part of the URL. This value must not start with a `#`.
        :param str hostname: Specifies the hostname part of the URL.
        :param str path: Specifies the path part of the URL. This value must begin with a `/`.
        :param str protocol: Specifies the protocol part of the URL. Valid values are `Http` and `Https`.
        :param str query_string: Specifies the query string part of the URL. This value must not start with a `?` or `&` and must be in `<key>=<value>` format separated by `&`.
        """
        pulumi.set(__self__, "redirect_type", redirect_type)
        if fragment is not None:
            pulumi.set(__self__, "fragment", fragment)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)

    @property
    @pulumi.getter(name="redirectType")
    def redirect_type(self) -> str:
        """
        Type of the redirect. Valid values are `Found`, `Moved`, `PermanentRedirect` and `TemporaryRedirect`.
        """
        return pulumi.get(self, "redirect_type")

    @property
    @pulumi.getter
    def fragment(self) -> Optional[str]:
        """
        Specifies the fragment part of the URL. This value must not start with a `#`.
        """
        return pulumi.get(self, "fragment")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        Specifies the hostname part of the URL.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Specifies the path part of the URL. This value must begin with a `/`.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        Specifies the protocol part of the URL. Valid values are `Http` and `Https`.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[str]:
        """
        Specifies the query string part of the URL. This value must not start with a `?` or `&` and must be in `<key>=<value>` format separated by `&`.
        """
        return pulumi.get(self, "query_string")


@pulumi.output_type
class EndpointDeliveryRuleUrlRewriteAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourcePattern":
            suggest = "source_pattern"
        elif key == "preserveUnmatchedPath":
            suggest = "preserve_unmatched_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointDeliveryRuleUrlRewriteAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointDeliveryRuleUrlRewriteAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointDeliveryRuleUrlRewriteAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: str,
                 source_pattern: str,
                 preserve_unmatched_path: Optional[bool] = None):
        """
        :param str destination: This value must start with a `/` and can't be longer than 260 characters.
        :param str source_pattern: This value must start with a `/` and can't be longer than 260 characters.
        :param bool preserve_unmatched_path: Defaults to `true`.
        """
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "source_pattern", source_pattern)
        if preserve_unmatched_path is not None:
            pulumi.set(__self__, "preserve_unmatched_path", preserve_unmatched_path)

    @property
    @pulumi.getter
    def destination(self) -> str:
        """
        This value must start with a `/` and can't be longer than 260 characters.
        """
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter(name="sourcePattern")
    def source_pattern(self) -> str:
        """
        This value must start with a `/` and can't be longer than 260 characters.
        """
        return pulumi.get(self, "source_pattern")

    @property
    @pulumi.getter(name="preserveUnmatchedPath")
    def preserve_unmatched_path(self) -> Optional[bool]:
        """
        Defaults to `true`.
        """
        return pulumi.get(self, "preserve_unmatched_path")


@pulumi.output_type
class EndpointGeoFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "countryCodes":
            suggest = "country_codes"
        elif key == "relativePath":
            suggest = "relative_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointGeoFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointGeoFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointGeoFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 country_codes: Sequence[str],
                 relative_path: str):
        """
        :param str action: The Action of the Geo Filter. Possible values include `Allow` and `Block`.
        :param Sequence[str] country_codes: A List of two letter country codes (e.g. `US`, `GB`) to be associated with this Geo Filter.
        :param str relative_path: The relative path applicable to geo filter.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "country_codes", country_codes)
        pulumi.set(__self__, "relative_path", relative_path)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The Action of the Geo Filter. Possible values include `Allow` and `Block`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="countryCodes")
    def country_codes(self) -> Sequence[str]:
        """
        A List of two letter country codes (e.g. `US`, `GB`) to be associated with this Geo Filter.
        """
        return pulumi.get(self, "country_codes")

    @property
    @pulumi.getter(name="relativePath")
    def relative_path(self) -> str:
        """
        The relative path applicable to geo filter.
        """
        return pulumi.get(self, "relative_path")


@pulumi.output_type
class EndpointGlobalDeliveryRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cacheExpirationAction":
            suggest = "cache_expiration_action"
        elif key == "cacheKeyQueryStringAction":
            suggest = "cache_key_query_string_action"
        elif key == "modifyRequestHeaderActions":
            suggest = "modify_request_header_actions"
        elif key == "modifyResponseHeaderActions":
            suggest = "modify_response_header_actions"
        elif key == "urlRedirectAction":
            suggest = "url_redirect_action"
        elif key == "urlRewriteAction":
            suggest = "url_rewrite_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointGlobalDeliveryRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointGlobalDeliveryRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointGlobalDeliveryRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cache_expiration_action: Optional['outputs.EndpointGlobalDeliveryRuleCacheExpirationAction'] = None,
                 cache_key_query_string_action: Optional['outputs.EndpointGlobalDeliveryRuleCacheKeyQueryStringAction'] = None,
                 modify_request_header_actions: Optional[Sequence['outputs.EndpointGlobalDeliveryRuleModifyRequestHeaderAction']] = None,
                 modify_response_header_actions: Optional[Sequence['outputs.EndpointGlobalDeliveryRuleModifyResponseHeaderAction']] = None,
                 url_redirect_action: Optional['outputs.EndpointGlobalDeliveryRuleUrlRedirectAction'] = None,
                 url_rewrite_action: Optional['outputs.EndpointGlobalDeliveryRuleUrlRewriteAction'] = None):
        """
        :param 'EndpointGlobalDeliveryRuleCacheExpirationActionArgs' cache_expiration_action: A `cache_expiration_action` block as defined above.
        :param 'EndpointGlobalDeliveryRuleCacheKeyQueryStringActionArgs' cache_key_query_string_action: A `cache_key_query_string_action` block as defined above.
        :param Sequence['EndpointGlobalDeliveryRuleModifyRequestHeaderActionArgs'] modify_request_header_actions: A `modify_request_header_action` block as defined below.
        :param Sequence['EndpointGlobalDeliveryRuleModifyResponseHeaderActionArgs'] modify_response_header_actions: A `modify_response_header_action` block as defined below.
        :param 'EndpointGlobalDeliveryRuleUrlRedirectActionArgs' url_redirect_action: A `url_redirect_action` block as defined below.
        :param 'EndpointGlobalDeliveryRuleUrlRewriteActionArgs' url_rewrite_action: A `url_rewrite_action` block as defined below.
        """
        if cache_expiration_action is not None:
            pulumi.set(__self__, "cache_expiration_action", cache_expiration_action)
        if cache_key_query_string_action is not None:
            pulumi.set(__self__, "cache_key_query_string_action", cache_key_query_string_action)
        if modify_request_header_actions is not None:
            pulumi.set(__self__, "modify_request_header_actions", modify_request_header_actions)
        if modify_response_header_actions is not None:
            pulumi.set(__self__, "modify_response_header_actions", modify_response_header_actions)
        if url_redirect_action is not None:
            pulumi.set(__self__, "url_redirect_action", url_redirect_action)
        if url_rewrite_action is not None:
            pulumi.set(__self__, "url_rewrite_action", url_rewrite_action)

    @property
    @pulumi.getter(name="cacheExpirationAction")
    def cache_expiration_action(self) -> Optional['outputs.EndpointGlobalDeliveryRuleCacheExpirationAction']:
        """
        A `cache_expiration_action` block as defined above.
        """
        return pulumi.get(self, "cache_expiration_action")

    @property
    @pulumi.getter(name="cacheKeyQueryStringAction")
    def cache_key_query_string_action(self) -> Optional['outputs.EndpointGlobalDeliveryRuleCacheKeyQueryStringAction']:
        """
        A `cache_key_query_string_action` block as defined above.
        """
        return pulumi.get(self, "cache_key_query_string_action")

    @property
    @pulumi.getter(name="modifyRequestHeaderActions")
    def modify_request_header_actions(self) -> Optional[Sequence['outputs.EndpointGlobalDeliveryRuleModifyRequestHeaderAction']]:
        """
        A `modify_request_header_action` block as defined below.
        """
        return pulumi.get(self, "modify_request_header_actions")

    @property
    @pulumi.getter(name="modifyResponseHeaderActions")
    def modify_response_header_actions(self) -> Optional[Sequence['outputs.EndpointGlobalDeliveryRuleModifyResponseHeaderAction']]:
        """
        A `modify_response_header_action` block as defined below.
        """
        return pulumi.get(self, "modify_response_header_actions")

    @property
    @pulumi.getter(name="urlRedirectAction")
    def url_redirect_action(self) -> Optional['outputs.EndpointGlobalDeliveryRuleUrlRedirectAction']:
        """
        A `url_redirect_action` block as defined below.
        """
        return pulumi.get(self, "url_redirect_action")

    @property
    @pulumi.getter(name="urlRewriteAction")
    def url_rewrite_action(self) -> Optional['outputs.EndpointGlobalDeliveryRuleUrlRewriteAction']:
        """
        A `url_rewrite_action` block as defined below.
        """
        return pulumi.get(self, "url_rewrite_action")


@pulumi.output_type
class EndpointGlobalDeliveryRuleCacheExpirationAction(dict):
    def __init__(__self__, *,
                 behavior: str,
                 duration: Optional[str] = None):
        """
        :param str behavior: The behavior of the cache. Valid values are `BypassCache`, `Override` and `SetIfMissing`.
        :param str duration: Duration of the cache. Only allowed when `behavior` is set to `Override` or `SetIfMissing`. Format: `[d.]hh:mm:ss`
        """
        pulumi.set(__self__, "behavior", behavior)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)

    @property
    @pulumi.getter
    def behavior(self) -> str:
        """
        The behavior of the cache. Valid values are `BypassCache`, `Override` and `SetIfMissing`.
        """
        return pulumi.get(self, "behavior")

    @property
    @pulumi.getter
    def duration(self) -> Optional[str]:
        """
        Duration of the cache. Only allowed when `behavior` is set to `Override` or `SetIfMissing`. Format: `[d.]hh:mm:ss`
        """
        return pulumi.get(self, "duration")


@pulumi.output_type
class EndpointGlobalDeliveryRuleCacheKeyQueryStringAction(dict):
    def __init__(__self__, *,
                 behavior: str,
                 parameters: Optional[str] = None):
        """
        :param str behavior: The behavior of the cache key for query strings. Valid values are `Exclude`, `ExcludeAll`, `Include` and `IncludeAll`.
        :param str parameters: Comma separated list of parameter values.
        """
        pulumi.set(__self__, "behavior", behavior)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def behavior(self) -> str:
        """
        The behavior of the cache key for query strings. Valid values are `Exclude`, `ExcludeAll`, `Include` and `IncludeAll`.
        """
        return pulumi.get(self, "behavior")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[str]:
        """
        Comma separated list of parameter values.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class EndpointGlobalDeliveryRuleModifyRequestHeaderAction(dict):
    def __init__(__self__, *,
                 action: str,
                 name: str,
                 value: Optional[str] = None):
        """
        :param str action: Action to be executed on a header value. Valid values are `Append`, `Delete` and `Overwrite`.
        :param str name: The header name.
        :param str value: The value of the header. Only needed when `action` is set to `Append` or `overwrite`.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Action to be executed on a header value. Valid values are `Append`, `Delete` and `Overwrite`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The header name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the header. Only needed when `action` is set to `Append` or `overwrite`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EndpointGlobalDeliveryRuleModifyResponseHeaderAction(dict):
    def __init__(__self__, *,
                 action: str,
                 name: str,
                 value: Optional[str] = None):
        """
        :param str action: Action to be executed on a header value. Valid values are `Append`, `Delete` and `Overwrite`.
        :param str name: The header name.
        :param str value: The value of the header. Only needed when `action` is set to `Append` or `overwrite`.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Action to be executed on a header value. Valid values are `Append`, `Delete` and `Overwrite`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The header name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the header. Only needed when `action` is set to `Append` or `overwrite`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EndpointGlobalDeliveryRuleUrlRedirectAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "redirectType":
            suggest = "redirect_type"
        elif key == "queryString":
            suggest = "query_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointGlobalDeliveryRuleUrlRedirectAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointGlobalDeliveryRuleUrlRedirectAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointGlobalDeliveryRuleUrlRedirectAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 redirect_type: str,
                 fragment: Optional[str] = None,
                 hostname: Optional[str] = None,
                 path: Optional[str] = None,
                 protocol: Optional[str] = None,
                 query_string: Optional[str] = None):
        """
        :param str redirect_type: Type of the redirect. Valid values are `Found`, `Moved`, `PermanentRedirect` and `TemporaryRedirect`.
        :param str fragment: Specifies the fragment part of the URL. This value must not start with a `#`.
        :param str hostname: Specifies the hostname part of the URL.
        :param str path: Specifies the path part of the URL. This value must begin with a `/`.
        :param str protocol: Specifies the protocol part of the URL. Valid values are `Http` and `Https`.
        :param str query_string: Specifies the query string part of the URL. This value must not start with a `?` or `&` and must be in `<key>=<value>` format separated by `&`.
        """
        pulumi.set(__self__, "redirect_type", redirect_type)
        if fragment is not None:
            pulumi.set(__self__, "fragment", fragment)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)

    @property
    @pulumi.getter(name="redirectType")
    def redirect_type(self) -> str:
        """
        Type of the redirect. Valid values are `Found`, `Moved`, `PermanentRedirect` and `TemporaryRedirect`.
        """
        return pulumi.get(self, "redirect_type")

    @property
    @pulumi.getter
    def fragment(self) -> Optional[str]:
        """
        Specifies the fragment part of the URL. This value must not start with a `#`.
        """
        return pulumi.get(self, "fragment")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        Specifies the hostname part of the URL.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Specifies the path part of the URL. This value must begin with a `/`.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        Specifies the protocol part of the URL. Valid values are `Http` and `Https`.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[str]:
        """
        Specifies the query string part of the URL. This value must not start with a `?` or `&` and must be in `<key>=<value>` format separated by `&`.
        """
        return pulumi.get(self, "query_string")


@pulumi.output_type
class EndpointGlobalDeliveryRuleUrlRewriteAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourcePattern":
            suggest = "source_pattern"
        elif key == "preserveUnmatchedPath":
            suggest = "preserve_unmatched_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointGlobalDeliveryRuleUrlRewriteAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointGlobalDeliveryRuleUrlRewriteAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointGlobalDeliveryRuleUrlRewriteAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: str,
                 source_pattern: str,
                 preserve_unmatched_path: Optional[bool] = None):
        """
        :param str destination: This value must start with a `/` and can't be longer than 260 characters.
        :param str source_pattern: This value must start with a `/` and can't be longer than 260 characters.
        :param bool preserve_unmatched_path: Defaults to `true`.
        """
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "source_pattern", source_pattern)
        if preserve_unmatched_path is not None:
            pulumi.set(__self__, "preserve_unmatched_path", preserve_unmatched_path)

    @property
    @pulumi.getter
    def destination(self) -> str:
        """
        This value must start with a `/` and can't be longer than 260 characters.
        """
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter(name="sourcePattern")
    def source_pattern(self) -> str:
        """
        This value must start with a `/` and can't be longer than 260 characters.
        """
        return pulumi.get(self, "source_pattern")

    @property
    @pulumi.getter(name="preserveUnmatchedPath")
    def preserve_unmatched_path(self) -> Optional[bool]:
        """
        Defaults to `true`.
        """
        return pulumi.get(self, "preserve_unmatched_path")


@pulumi.output_type
class EndpointOrigin(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostName":
            suggest = "host_name"
        elif key == "httpPort":
            suggest = "http_port"
        elif key == "httpsPort":
            suggest = "https_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointOrigin. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointOrigin.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointOrigin.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host_name: str,
                 name: str,
                 http_port: Optional[int] = None,
                 https_port: Optional[int] = None):
        """
        :param str host_name: A string that determines the hostname/IP address of the origin server. This string can be a domain name, Storage Account endpoint, Web App endpoint, IPv4 address or IPv6 address. Changing this forces a new resource to be created.
        :param str name: The name of the origin. This is an arbitrary value. However, this value needs to be unique under the endpoint. Changing this forces a new resource to be created.
        :param int http_port: The HTTP port of the origin. Defaults to `80`. Changing this forces a new resource to be created.
        :param int https_port: The HTTPS port of the origin. Defaults to `443`. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "host_name", host_name)
        pulumi.set(__self__, "name", name)
        if http_port is not None:
            pulumi.set(__self__, "http_port", http_port)
        if https_port is not None:
            pulumi.set(__self__, "https_port", https_port)

    @property
    @pulumi.getter(name="hostName")
    def host_name(self) -> str:
        """
        A string that determines the hostname/IP address of the origin server. This string can be a domain name, Storage Account endpoint, Web App endpoint, IPv4 address or IPv6 address. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "host_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the origin. This is an arbitrary value. However, this value needs to be unique under the endpoint. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> Optional[int]:
        """
        The HTTP port of the origin. Defaults to `80`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "http_port")

    @property
    @pulumi.getter(name="httpsPort")
    def https_port(self) -> Optional[int]:
        """
        The HTTPS port of the origin. Defaults to `443`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "https_port")


@pulumi.output_type
class FrontdoorFirewallPolicyCustomRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchConditions":
            suggest = "match_conditions"
        elif key == "rateLimitDurationInMinutes":
            suggest = "rate_limit_duration_in_minutes"
        elif key == "rateLimitThreshold":
            suggest = "rate_limit_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorFirewallPolicyCustomRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorFirewallPolicyCustomRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorFirewallPolicyCustomRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 name: str,
                 type: str,
                 enabled: Optional[bool] = None,
                 match_conditions: Optional[Sequence['outputs.FrontdoorFirewallPolicyCustomRuleMatchCondition']] = None,
                 priority: Optional[int] = None,
                 rate_limit_duration_in_minutes: Optional[int] = None,
                 rate_limit_threshold: Optional[int] = None):
        """
        :param str action: The action to perform when the rule is matched. Possible values are `Allow`, `Block`, `Log`, or `Redirect`.
        :param str name: Gets name of the resource that is unique within a policy. This name can be used to access the resource.
        :param str type: The type of rule. Possible values are `MatchRule` or `RateLimitRule`.
        :param bool enabled: Is the rule is enabled or disabled? Defaults to `true`.
        :param Sequence['FrontdoorFirewallPolicyCustomRuleMatchConditionArgs'] match_conditions: One or more `match_condition` block defined below. Can support up to `10` `match_condition` blocks.
        :param int priority: The priority of the rule. Rules with a lower value will be evaluated before rules with a higher value. Defaults to `1`.
        :param int rate_limit_duration_in_minutes: The rate limit duration in minutes. Defaults to `1`.
        :param int rate_limit_threshold: The rate limit threshold. Defaults to `10`.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if match_conditions is not None:
            pulumi.set(__self__, "match_conditions", match_conditions)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if rate_limit_duration_in_minutes is not None:
            pulumi.set(__self__, "rate_limit_duration_in_minutes", rate_limit_duration_in_minutes)
        if rate_limit_threshold is not None:
            pulumi.set(__self__, "rate_limit_threshold", rate_limit_threshold)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action to perform when the rule is matched. Possible values are `Allow`, `Block`, `Log`, or `Redirect`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Gets name of the resource that is unique within a policy. This name can be used to access the resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of rule. Possible values are `MatchRule` or `RateLimitRule`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Is the rule is enabled or disabled? Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="matchConditions")
    def match_conditions(self) -> Optional[Sequence['outputs.FrontdoorFirewallPolicyCustomRuleMatchCondition']]:
        """
        One or more `match_condition` block defined below. Can support up to `10` `match_condition` blocks.
        """
        return pulumi.get(self, "match_conditions")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority of the rule. Rules with a lower value will be evaluated before rules with a higher value. Defaults to `1`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="rateLimitDurationInMinutes")
    def rate_limit_duration_in_minutes(self) -> Optional[int]:
        """
        The rate limit duration in minutes. Defaults to `1`.
        """
        return pulumi.get(self, "rate_limit_duration_in_minutes")

    @property
    @pulumi.getter(name="rateLimitThreshold")
    def rate_limit_threshold(self) -> Optional[int]:
        """
        The rate limit threshold. Defaults to `10`.
        """
        return pulumi.get(self, "rate_limit_threshold")


@pulumi.output_type
class FrontdoorFirewallPolicyCustomRuleMatchCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValues":
            suggest = "match_values"
        elif key == "matchVariable":
            suggest = "match_variable"
        elif key == "negationCondition":
            suggest = "negation_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorFirewallPolicyCustomRuleMatchCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorFirewallPolicyCustomRuleMatchCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorFirewallPolicyCustomRuleMatchCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_values: Sequence[str],
                 match_variable: str,
                 operator: str,
                 negation_condition: Optional[bool] = None,
                 selector: Optional[str] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] match_values: Up to `600` possible values to match. Limit is in total across all `match_condition` blocks and `match_values` arguments. String value itself can be up to `256` characters in length.
        :param str match_variable: The request variable to compare with. Possible values are `Cookies`, `PostArgs`, `QueryString`, `RemoteAddr`, `RequestBody`, `RequestHeader`, `RequestMethod`, `RequestUri`, or `SocketAddr`.
        :param str operator: Comparison type to use for matching with the variable value. Possible values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GeoMatch`, `GreaterThan`, `GreaterThanOrEqual`, `IPMatch`, `LessThan`, `LessThanOrEqual` or `RegEx`.
        :param bool negation_condition: Should the result of the condition be negated.
        :param str selector: Match against a specific key if the `match_variable` is `QueryString`, `PostArgs`, `RequestHeader` or `Cookies`.
        :param Sequence[str] transforms: Up to `5` transforms to apply. Possible values are `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `URLDecode` or `URLEncode`.
        """
        pulumi.set(__self__, "match_values", match_values)
        pulumi.set(__self__, "match_variable", match_variable)
        pulumi.set(__self__, "operator", operator)
        if negation_condition is not None:
            pulumi.set(__self__, "negation_condition", negation_condition)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Sequence[str]:
        """
        Up to `600` possible values to match. Limit is in total across all `match_condition` blocks and `match_values` arguments. String value itself can be up to `256` characters in length.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="matchVariable")
    def match_variable(self) -> str:
        """
        The request variable to compare with. Possible values are `Cookies`, `PostArgs`, `QueryString`, `RemoteAddr`, `RequestBody`, `RequestHeader`, `RequestMethod`, `RequestUri`, or `SocketAddr`.
        """
        return pulumi.get(self, "match_variable")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Comparison type to use for matching with the variable value. Possible values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GeoMatch`, `GreaterThan`, `GreaterThanOrEqual`, `IPMatch`, `LessThan`, `LessThanOrEqual` or `RegEx`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="negationCondition")
    def negation_condition(self) -> Optional[bool]:
        """
        Should the result of the condition be negated.
        """
        return pulumi.get(self, "negation_condition")

    @property
    @pulumi.getter
    def selector(self) -> Optional[str]:
        """
        Match against a specific key if the `match_variable` is `QueryString`, `PostArgs`, `RequestHeader` or `Cookies`.
        """
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        Up to `5` transforms to apply. Possible values are `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `URLDecode` or `URLEncode`.
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class FrontdoorFirewallPolicyManagedRule(dict):
    def __init__(__self__, *,
                 action: str,
                 type: str,
                 version: str,
                 exclusions: Optional[Sequence['outputs.FrontdoorFirewallPolicyManagedRuleExclusion']] = None,
                 overrides: Optional[Sequence['outputs.FrontdoorFirewallPolicyManagedRuleOverride']] = None):
        """
        :param str action: The action to perform when the managed rule is matched. Possible values are `Allow`, `Block`, `Log`, or `Redirect`.
        :param str type: The name of the managed rule to use with this resource.
        :param str version: The version on the managed rule to use with this resource.
        :param Sequence['FrontdoorFirewallPolicyManagedRuleExclusionArgs'] exclusions: One or more `exclusion` blocks as defined below.
        :param Sequence['FrontdoorFirewallPolicyManagedRuleOverrideArgs'] overrides: One or more `override` blocks as defined below.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "version", version)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action to perform when the managed rule is matched. Possible values are `Allow`, `Block`, `Log`, or `Redirect`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The name of the managed rule to use with this resource.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        The version on the managed rule to use with this resource.
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence['outputs.FrontdoorFirewallPolicyManagedRuleExclusion']]:
        """
        One or more `exclusion` blocks as defined below.
        """
        return pulumi.get(self, "exclusions")

    @property
    @pulumi.getter
    def overrides(self) -> Optional[Sequence['outputs.FrontdoorFirewallPolicyManagedRuleOverride']]:
        """
        One or more `override` blocks as defined below.
        """
        return pulumi.get(self, "overrides")


@pulumi.output_type
class FrontdoorFirewallPolicyManagedRuleExclusion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchVariable":
            suggest = "match_variable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorFirewallPolicyManagedRuleExclusion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorFirewallPolicyManagedRuleExclusion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorFirewallPolicyManagedRuleExclusion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_variable: str,
                 operator: str,
                 selector: str):
        """
        :param str match_variable: The variable type to be excluded. Possible values are `QueryStringArgNames`, `RequestBodyPostArgNames`, `RequestCookieNames`, `RequestHeaderNames`.
        :param str operator: Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to. Possible values are: `Equals`, `Contains`, `StartsWith`, `EndsWith`, `EqualsAny`.
        :param str selector: Selector for the value in the `match_variable` attribute this exclusion applies to.
        """
        pulumi.set(__self__, "match_variable", match_variable)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "selector", selector)

    @property
    @pulumi.getter(name="matchVariable")
    def match_variable(self) -> str:
        """
        The variable type to be excluded. Possible values are `QueryStringArgNames`, `RequestBodyPostArgNames`, `RequestCookieNames`, `RequestHeaderNames`.
        """
        return pulumi.get(self, "match_variable")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to. Possible values are: `Equals`, `Contains`, `StartsWith`, `EndsWith`, `EqualsAny`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def selector(self) -> str:
        """
        Selector for the value in the `match_variable` attribute this exclusion applies to.
        """
        return pulumi.get(self, "selector")


@pulumi.output_type
class FrontdoorFirewallPolicyManagedRuleOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleGroupName":
            suggest = "rule_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorFirewallPolicyManagedRuleOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorFirewallPolicyManagedRuleOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorFirewallPolicyManagedRuleOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rule_group_name: str,
                 exclusions: Optional[Sequence['outputs.FrontdoorFirewallPolicyManagedRuleOverrideExclusion']] = None,
                 rules: Optional[Sequence['outputs.FrontdoorFirewallPolicyManagedRuleOverrideRule']] = None):
        """
        :param str rule_group_name: The managed rule group to override.
        :param Sequence['FrontdoorFirewallPolicyManagedRuleOverrideExclusionArgs'] exclusions: One or more `exclusion` blocks as defined below.
        :param Sequence['FrontdoorFirewallPolicyManagedRuleOverrideRuleArgs'] rules: One or more `rule` blocks as defined below. If none are specified, all of the rules in the group will be disabled.
        """
        pulumi.set(__self__, "rule_group_name", rule_group_name)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter(name="ruleGroupName")
    def rule_group_name(self) -> str:
        """
        The managed rule group to override.
        """
        return pulumi.get(self, "rule_group_name")

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence['outputs.FrontdoorFirewallPolicyManagedRuleOverrideExclusion']]:
        """
        One or more `exclusion` blocks as defined below.
        """
        return pulumi.get(self, "exclusions")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.FrontdoorFirewallPolicyManagedRuleOverrideRule']]:
        """
        One or more `rule` blocks as defined below. If none are specified, all of the rules in the group will be disabled.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class FrontdoorFirewallPolicyManagedRuleOverrideExclusion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchVariable":
            suggest = "match_variable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorFirewallPolicyManagedRuleOverrideExclusion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorFirewallPolicyManagedRuleOverrideExclusion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorFirewallPolicyManagedRuleOverrideExclusion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_variable: str,
                 operator: str,
                 selector: str):
        """
        :param str match_variable: The variable type to be excluded. Possible values are `QueryStringArgNames`, `RequestBodyPostArgNames`, `RequestCookieNames`, `RequestHeaderNames`.
        :param str operator: Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to. Possible values are: `Equals`, `Contains`, `StartsWith`, `EndsWith`, `EqualsAny`.
        :param str selector: Selector for the value in the `match_variable` attribute this exclusion applies to.
        """
        pulumi.set(__self__, "match_variable", match_variable)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "selector", selector)

    @property
    @pulumi.getter(name="matchVariable")
    def match_variable(self) -> str:
        """
        The variable type to be excluded. Possible values are `QueryStringArgNames`, `RequestBodyPostArgNames`, `RequestCookieNames`, `RequestHeaderNames`.
        """
        return pulumi.get(self, "match_variable")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to. Possible values are: `Equals`, `Contains`, `StartsWith`, `EndsWith`, `EqualsAny`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def selector(self) -> str:
        """
        Selector for the value in the `match_variable` attribute this exclusion applies to.
        """
        return pulumi.get(self, "selector")


@pulumi.output_type
class FrontdoorFirewallPolicyManagedRuleOverrideRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleId":
            suggest = "rule_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorFirewallPolicyManagedRuleOverrideRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorFirewallPolicyManagedRuleOverrideRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorFirewallPolicyManagedRuleOverrideRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 rule_id: str,
                 enabled: Optional[bool] = None,
                 exclusions: Optional[Sequence['outputs.FrontdoorFirewallPolicyManagedRuleOverrideRuleExclusion']] = None):
        """
        :param str action: The action to be applied when the rule matches. Possible values are `Allow`, `Block`, `Log`, or `Redirect`.
        :param str rule_id: Identifier for the managed rule.
        :param bool enabled: Is the managed rule override enabled or disabled. Defaults to `false`
        :param Sequence['FrontdoorFirewallPolicyManagedRuleOverrideRuleExclusionArgs'] exclusions: One or more `exclusion` blocks as defined below.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "rule_id", rule_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action to be applied when the rule matches. Possible values are `Allow`, `Block`, `Log`, or `Redirect`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> str:
        """
        Identifier for the managed rule.
        """
        return pulumi.get(self, "rule_id")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Is the managed rule override enabled or disabled. Defaults to `false`
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence['outputs.FrontdoorFirewallPolicyManagedRuleOverrideRuleExclusion']]:
        """
        One or more `exclusion` blocks as defined below.
        """
        return pulumi.get(self, "exclusions")


@pulumi.output_type
class FrontdoorFirewallPolicyManagedRuleOverrideRuleExclusion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchVariable":
            suggest = "match_variable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorFirewallPolicyManagedRuleOverrideRuleExclusion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorFirewallPolicyManagedRuleOverrideRuleExclusion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorFirewallPolicyManagedRuleOverrideRuleExclusion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_variable: str,
                 operator: str,
                 selector: str):
        """
        :param str match_variable: The variable type to be excluded. Possible values are `QueryStringArgNames`, `RequestBodyPostArgNames`, `RequestCookieNames`, `RequestHeaderNames`.
        :param str operator: Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to. Possible values are: `Equals`, `Contains`, `StartsWith`, `EndsWith`, `EqualsAny`.
        :param str selector: Selector for the value in the `match_variable` attribute this exclusion applies to.
        """
        pulumi.set(__self__, "match_variable", match_variable)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "selector", selector)

    @property
    @pulumi.getter(name="matchVariable")
    def match_variable(self) -> str:
        """
        The variable type to be excluded. Possible values are `QueryStringArgNames`, `RequestBodyPostArgNames`, `RequestCookieNames`, `RequestHeaderNames`.
        """
        return pulumi.get(self, "match_variable")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to. Possible values are: `Equals`, `Contains`, `StartsWith`, `EndsWith`, `EqualsAny`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def selector(self) -> str:
        """
        Selector for the value in the `match_variable` attribute this exclusion applies to.
        """
        return pulumi.get(self, "selector")


@pulumi.output_type
class FrontdoorOriginGroupHealthProbe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "intervalInSeconds":
            suggest = "interval_in_seconds"
        elif key == "requestType":
            suggest = "request_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorOriginGroupHealthProbe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorOriginGroupHealthProbe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorOriginGroupHealthProbe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interval_in_seconds: int,
                 protocol: str,
                 path: Optional[str] = None,
                 request_type: Optional[str] = None):
        """
        :param int interval_in_seconds: Specifies the number of seconds between health probes. Possible values are between `5` and `31536000` seconds (inclusive).
        :param str protocol: Specifies the protocol to use for health probe. Possible values are `Http` and `Https`.
        :param str path: Specifies the path relative to the origin that is used to determine the health of the origin. Defaults to `/`.
        :param str request_type: Specifies the type of health probe request that is made. Possible values are `GET` and `HEAD`. Defaults to `HEAD`.
        """
        pulumi.set(__self__, "interval_in_seconds", interval_in_seconds)
        pulumi.set(__self__, "protocol", protocol)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if request_type is not None:
            pulumi.set(__self__, "request_type", request_type)

    @property
    @pulumi.getter(name="intervalInSeconds")
    def interval_in_seconds(self) -> int:
        """
        Specifies the number of seconds between health probes. Possible values are between `5` and `31536000` seconds (inclusive).
        """
        return pulumi.get(self, "interval_in_seconds")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Specifies the protocol to use for health probe. Possible values are `Http` and `Https`.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Specifies the path relative to the origin that is used to determine the health of the origin. Defaults to `/`.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="requestType")
    def request_type(self) -> Optional[str]:
        """
        Specifies the type of health probe request that is made. Possible values are `GET` and `HEAD`. Defaults to `HEAD`.
        """
        return pulumi.get(self, "request_type")


@pulumi.output_type
class FrontdoorOriginGroupLoadBalancing(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalLatencyInMilliseconds":
            suggest = "additional_latency_in_milliseconds"
        elif key == "sampleSize":
            suggest = "sample_size"
        elif key == "successfulSamplesRequired":
            suggest = "successful_samples_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorOriginGroupLoadBalancing. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorOriginGroupLoadBalancing.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorOriginGroupLoadBalancing.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_latency_in_milliseconds: Optional[int] = None,
                 sample_size: Optional[int] = None,
                 successful_samples_required: Optional[int] = None):
        """
        :param int additional_latency_in_milliseconds: Specifies the additional latency in milliseconds for probes to fall into the lowest latency bucket. Possible values are between `0` and `1000` seconds (inclusive). Defaults to `50`.
        :param int sample_size: Specifies the number of samples to consider for load balancing decisions. Possible values are between `0` and `255` (inclusive). Defaults to `4`.
        :param int successful_samples_required: Specifies the number of samples within the sample period that must succeed. Possible values are between `0` and `255` (inclusive). Defaults to `3`.
        """
        if additional_latency_in_milliseconds is not None:
            pulumi.set(__self__, "additional_latency_in_milliseconds", additional_latency_in_milliseconds)
        if sample_size is not None:
            pulumi.set(__self__, "sample_size", sample_size)
        if successful_samples_required is not None:
            pulumi.set(__self__, "successful_samples_required", successful_samples_required)

    @property
    @pulumi.getter(name="additionalLatencyInMilliseconds")
    def additional_latency_in_milliseconds(self) -> Optional[int]:
        """
        Specifies the additional latency in milliseconds for probes to fall into the lowest latency bucket. Possible values are between `0` and `1000` seconds (inclusive). Defaults to `50`.
        """
        return pulumi.get(self, "additional_latency_in_milliseconds")

    @property
    @pulumi.getter(name="sampleSize")
    def sample_size(self) -> Optional[int]:
        """
        Specifies the number of samples to consider for load balancing decisions. Possible values are between `0` and `255` (inclusive). Defaults to `4`.
        """
        return pulumi.get(self, "sample_size")

    @property
    @pulumi.getter(name="successfulSamplesRequired")
    def successful_samples_required(self) -> Optional[int]:
        """
        Specifies the number of samples within the sample period that must succeed. Possible values are between `0` and `255` (inclusive). Defaults to `3`.
        """
        return pulumi.get(self, "successful_samples_required")


@pulumi.output_type
class FrontdoorOriginPrivateLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateLinkTargetId":
            suggest = "private_link_target_id"
        elif key == "requestMessage":
            suggest = "request_message"
        elif key == "targetType":
            suggest = "target_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorOriginPrivateLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorOriginPrivateLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorOriginPrivateLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 location: str,
                 private_link_target_id: str,
                 request_message: Optional[str] = None,
                 target_type: Optional[str] = None):
        """
        :param str location: Specifies the location where the Private Link resource should exist.
        :param str private_link_target_id: The ID of the Azure Resource to connect to via the Private Link.
        :param str request_message: Specifies the request message that will be submitted to the `private_link_target_id` when requesting the private link endpoint connection. Values must be between `1` and `140` characters in length. Defaults to `Access request for CDN Frontdoor Private Link Origin`.
        :param str target_type: Specifies the type of target for this Private Link Endpoint. Possible values are `blob`, `blob_secondary`, `web` and `sites`.
        """
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "private_link_target_id", private_link_target_id)
        if request_message is not None:
            pulumi.set(__self__, "request_message", request_message)
        if target_type is not None:
            pulumi.set(__self__, "target_type", target_type)

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        Specifies the location where the Private Link resource should exist.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="privateLinkTargetId")
    def private_link_target_id(self) -> str:
        """
        The ID of the Azure Resource to connect to via the Private Link.
        """
        return pulumi.get(self, "private_link_target_id")

    @property
    @pulumi.getter(name="requestMessage")
    def request_message(self) -> Optional[str]:
        """
        Specifies the request message that will be submitted to the `private_link_target_id` when requesting the private link endpoint connection. Values must be between `1` and `140` characters in length. Defaults to `Access request for CDN Frontdoor Private Link Origin`.
        """
        return pulumi.get(self, "request_message")

    @property
    @pulumi.getter(name="targetType")
    def target_type(self) -> Optional[str]:
        """
        Specifies the type of target for this Private Link Endpoint. Possible values are `blob`, `blob_secondary`, `web` and `sites`.
        """
        return pulumi.get(self, "target_type")


@pulumi.output_type
class FrontdoorSecurityPolicySecurityPolicies(dict):
    def __init__(__self__, *,
                 firewall: 'outputs.FrontdoorSecurityPolicySecurityPoliciesFirewall'):
        """
        :param 'FrontdoorSecurityPolicySecurityPoliciesFirewallArgs' firewall: An `firewall` block as defined below. Changing this forces a new Frontdoor Security Policy to be created.
        """
        pulumi.set(__self__, "firewall", firewall)

    @property
    @pulumi.getter
    def firewall(self) -> 'outputs.FrontdoorSecurityPolicySecurityPoliciesFirewall':
        """
        An `firewall` block as defined below. Changing this forces a new Frontdoor Security Policy to be created.
        """
        return pulumi.get(self, "firewall")


@pulumi.output_type
class FrontdoorSecurityPolicySecurityPoliciesFirewall(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cdnFrontdoorFirewallPolicyId":
            suggest = "cdn_frontdoor_firewall_policy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorSecurityPolicySecurityPoliciesFirewall. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorSecurityPolicySecurityPoliciesFirewall.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorSecurityPolicySecurityPoliciesFirewall.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 association: 'outputs.FrontdoorSecurityPolicySecurityPoliciesFirewallAssociation',
                 cdn_frontdoor_firewall_policy_id: str):
        """
        :param 'FrontdoorSecurityPolicySecurityPoliciesFirewallAssociationArgs' association: An `association` block as defined below. Changing this forces a new Frontdoor Security Policy to be created.
        :param str cdn_frontdoor_firewall_policy_id: The Resource Id of the Frontdoor Firewall Policy that should be linked to this Frontdoor Security Policy. Changing this forces a new Frontdoor Security Policy to be created.
        """
        pulumi.set(__self__, "association", association)
        pulumi.set(__self__, "cdn_frontdoor_firewall_policy_id", cdn_frontdoor_firewall_policy_id)

    @property
    @pulumi.getter
    def association(self) -> 'outputs.FrontdoorSecurityPolicySecurityPoliciesFirewallAssociation':
        """
        An `association` block as defined below. Changing this forces a new Frontdoor Security Policy to be created.
        """
        return pulumi.get(self, "association")

    @property
    @pulumi.getter(name="cdnFrontdoorFirewallPolicyId")
    def cdn_frontdoor_firewall_policy_id(self) -> str:
        """
        The Resource Id of the Frontdoor Firewall Policy that should be linked to this Frontdoor Security Policy. Changing this forces a new Frontdoor Security Policy to be created.
        """
        return pulumi.get(self, "cdn_frontdoor_firewall_policy_id")


@pulumi.output_type
class FrontdoorSecurityPolicySecurityPoliciesFirewallAssociation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "patternsToMatch":
            suggest = "patterns_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorSecurityPolicySecurityPoliciesFirewallAssociation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorSecurityPolicySecurityPoliciesFirewallAssociation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorSecurityPolicySecurityPoliciesFirewallAssociation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domains: Sequence['outputs.FrontdoorSecurityPolicySecurityPoliciesFirewallAssociationDomain'],
                 patterns_to_match: str):
        """
        :param Sequence['FrontdoorSecurityPolicySecurityPoliciesFirewallAssociationDomainArgs'] domains: One or more `domain` blocks as defined below. Changing this forces a new Frontdoor Security Policy to be created.
        :param str patterns_to_match: The list of paths to match for this firewall policy. Possilbe value includes `/*`. Changing this forces a new Frontdoor Security Policy to be created.
        """
        pulumi.set(__self__, "domains", domains)
        pulumi.set(__self__, "patterns_to_match", patterns_to_match)

    @property
    @pulumi.getter
    def domains(self) -> Sequence['outputs.FrontdoorSecurityPolicySecurityPoliciesFirewallAssociationDomain']:
        """
        One or more `domain` blocks as defined below. Changing this forces a new Frontdoor Security Policy to be created.
        """
        return pulumi.get(self, "domains")

    @property
    @pulumi.getter(name="patternsToMatch")
    def patterns_to_match(self) -> str:
        """
        The list of paths to match for this firewall policy. Possilbe value includes `/*`. Changing this forces a new Frontdoor Security Policy to be created.
        """
        return pulumi.get(self, "patterns_to_match")


@pulumi.output_type
class FrontdoorSecurityPolicySecurityPoliciesFirewallAssociationDomain(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cdnFrontdoorDomainId":
            suggest = "cdn_frontdoor_domain_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorSecurityPolicySecurityPoliciesFirewallAssociationDomain. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorSecurityPolicySecurityPoliciesFirewallAssociationDomain.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorSecurityPolicySecurityPoliciesFirewallAssociationDomain.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cdn_frontdoor_domain_id: str,
                 active: Optional[bool] = None):
        """
        :param str cdn_frontdoor_domain_id: The Resource Id of the **Frontdoor Custom Domain** or **Frontdoor Endpoint** that should be bound to this Frontdoor Security Policy. Changing this forces a new Frontdoor Security Policy to be created.
        :param bool active: Is the Frontdoor Custom Domain/Endpoint activated?
        """
        pulumi.set(__self__, "cdn_frontdoor_domain_id", cdn_frontdoor_domain_id)
        if active is not None:
            pulumi.set(__self__, "active", active)

    @property
    @pulumi.getter(name="cdnFrontdoorDomainId")
    def cdn_frontdoor_domain_id(self) -> str:
        """
        The Resource Id of the **Frontdoor Custom Domain** or **Frontdoor Endpoint** that should be bound to this Frontdoor Security Policy. Changing this forces a new Frontdoor Security Policy to be created.
        """
        return pulumi.get(self, "cdn_frontdoor_domain_id")

    @property
    @pulumi.getter
    def active(self) -> Optional[bool]:
        """
        Is the Frontdoor Custom Domain/Endpoint activated?
        """
        return pulumi.get(self, "active")


@pulumi.output_type
class GetFrontdoorOriginGroupHealthProbeResult(dict):
    def __init__(__self__, *,
                 interval_in_seconds: int,
                 path: str,
                 protocol: str,
                 request_type: str):
        """
        :param int interval_in_seconds: Specifies the number of seconds between health probes.
        :param str path: Specifies the path relative to the origin that is used to determine the health of the origin.
        :param str protocol: Specifies the protocol to use for health probe.
        :param str request_type: Specifies the type of health probe request that is made.
        """
        pulumi.set(__self__, "interval_in_seconds", interval_in_seconds)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "request_type", request_type)

    @property
    @pulumi.getter(name="intervalInSeconds")
    def interval_in_seconds(self) -> int:
        """
        Specifies the number of seconds between health probes.
        """
        return pulumi.get(self, "interval_in_seconds")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        Specifies the path relative to the origin that is used to determine the health of the origin.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Specifies the protocol to use for health probe.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="requestType")
    def request_type(self) -> str:
        """
        Specifies the type of health probe request that is made.
        """
        return pulumi.get(self, "request_type")


@pulumi.output_type
class GetFrontdoorOriginGroupLoadBalancingResult(dict):
    def __init__(__self__, *,
                 additional_latency_in_milliseconds: int,
                 sample_size: int,
                 successful_samples_required: int):
        """
        :param int additional_latency_in_milliseconds: Specifies the additional latency in milliseconds for probes to fall into the lowest latency bucket.
        :param int sample_size: Specifies the number of samples to consider for load balancing decisions.
        :param int successful_samples_required: Specifies the number of samples within the sample period that must succeed.
        """
        pulumi.set(__self__, "additional_latency_in_milliseconds", additional_latency_in_milliseconds)
        pulumi.set(__self__, "sample_size", sample_size)
        pulumi.set(__self__, "successful_samples_required", successful_samples_required)

    @property
    @pulumi.getter(name="additionalLatencyInMilliseconds")
    def additional_latency_in_milliseconds(self) -> int:
        """
        Specifies the additional latency in milliseconds for probes to fall into the lowest latency bucket.
        """
        return pulumi.get(self, "additional_latency_in_milliseconds")

    @property
    @pulumi.getter(name="sampleSize")
    def sample_size(self) -> int:
        """
        Specifies the number of samples to consider for load balancing decisions.
        """
        return pulumi.get(self, "sample_size")

    @property
    @pulumi.getter(name="successfulSamplesRequired")
    def successful_samples_required(self) -> int:
        """
        Specifies the number of samples within the sample period that must succeed.
        """
        return pulumi.get(self, "successful_samples_required")


