# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'EndpointCustomDomainCdnManagedHttps',
    'EndpointCustomDomainUserManagedHttps',
    'EndpointDeliveryRule',
    'EndpointDeliveryRuleCacheExpirationAction',
    'EndpointDeliveryRuleCacheKeyQueryStringAction',
    'EndpointDeliveryRuleCookiesCondition',
    'EndpointDeliveryRuleDeviceCondition',
    'EndpointDeliveryRuleHttpVersionCondition',
    'EndpointDeliveryRuleModifyRequestHeaderAction',
    'EndpointDeliveryRuleModifyResponseHeaderAction',
    'EndpointDeliveryRulePostArgCondition',
    'EndpointDeliveryRuleQueryStringCondition',
    'EndpointDeliveryRuleRemoteAddressCondition',
    'EndpointDeliveryRuleRequestBodyCondition',
    'EndpointDeliveryRuleRequestHeaderCondition',
    'EndpointDeliveryRuleRequestMethodCondition',
    'EndpointDeliveryRuleRequestSchemeCondition',
    'EndpointDeliveryRuleRequestUriCondition',
    'EndpointDeliveryRuleUrlFileExtensionCondition',
    'EndpointDeliveryRuleUrlFileNameCondition',
    'EndpointDeliveryRuleUrlPathCondition',
    'EndpointDeliveryRuleUrlRedirectAction',
    'EndpointDeliveryRuleUrlRewriteAction',
    'EndpointGeoFilter',
    'EndpointGlobalDeliveryRule',
    'EndpointGlobalDeliveryRuleCacheExpirationAction',
    'EndpointGlobalDeliveryRuleCacheKeyQueryStringAction',
    'EndpointGlobalDeliveryRuleModifyRequestHeaderAction',
    'EndpointGlobalDeliveryRuleModifyResponseHeaderAction',
    'EndpointGlobalDeliveryRuleUrlRedirectAction',
    'EndpointGlobalDeliveryRuleUrlRewriteAction',
    'EndpointOrigin',
    'FrontdoorCustomDomainTls',
    'FrontdoorFirewallPolicyCustomRule',
    'FrontdoorFirewallPolicyCustomRuleMatchCondition',
    'FrontdoorFirewallPolicyManagedRule',
    'FrontdoorFirewallPolicyManagedRuleExclusion',
    'FrontdoorFirewallPolicyManagedRuleOverride',
    'FrontdoorFirewallPolicyManagedRuleOverrideExclusion',
    'FrontdoorFirewallPolicyManagedRuleOverrideRule',
    'FrontdoorFirewallPolicyManagedRuleOverrideRuleExclusion',
    'FrontdoorOriginGroupHealthProbe',
    'FrontdoorOriginGroupLoadBalancing',
    'FrontdoorOriginPrivateLink',
    'FrontdoorRouteCache',
    'FrontdoorRuleActions',
    'FrontdoorRuleActionsRequestHeaderAction',
    'FrontdoorRuleActionsResponseHeaderAction',
    'FrontdoorRuleActionsRouteConfigurationOverrideAction',
    'FrontdoorRuleActionsUrlRedirectAction',
    'FrontdoorRuleActionsUrlRewriteAction',
    'FrontdoorRuleConditions',
    'FrontdoorRuleConditionsClientPortCondition',
    'FrontdoorRuleConditionsCookiesCondition',
    'FrontdoorRuleConditionsHostNameCondition',
    'FrontdoorRuleConditionsHttpVersionCondition',
    'FrontdoorRuleConditionsIsDeviceCondition',
    'FrontdoorRuleConditionsPostArgsCondition',
    'FrontdoorRuleConditionsQueryStringCondition',
    'FrontdoorRuleConditionsRemoteAddressCondition',
    'FrontdoorRuleConditionsRequestBodyCondition',
    'FrontdoorRuleConditionsRequestHeaderCondition',
    'FrontdoorRuleConditionsRequestMethodCondition',
    'FrontdoorRuleConditionsRequestSchemeCondition',
    'FrontdoorRuleConditionsRequestUriCondition',
    'FrontdoorRuleConditionsServerPortCondition',
    'FrontdoorRuleConditionsSocketAddressCondition',
    'FrontdoorRuleConditionsSslProtocolCondition',
    'FrontdoorRuleConditionsUrlFileExtensionCondition',
    'FrontdoorRuleConditionsUrlFilenameCondition',
    'FrontdoorRuleConditionsUrlPathCondition',
    'FrontdoorSecretSecret',
    'FrontdoorSecretSecretCustomerCertificate',
    'FrontdoorSecurityPolicySecurityPolicies',
    'FrontdoorSecurityPolicySecurityPoliciesFirewall',
    'FrontdoorSecurityPolicySecurityPoliciesFirewallAssociation',
    'FrontdoorSecurityPolicySecurityPoliciesFirewallAssociationDomain',
    'GetFrontdoorOriginGroupHealthProbeResult',
    'GetFrontdoorOriginGroupLoadBalancingResult',
    'GetFrontdoorSecretSecretResult',
    'GetFrontdoorSecretSecretCustomerCertificateResult',
]

@pulumi.output_type
class EndpointCustomDomainCdnManagedHttps(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateType":
            suggest = "certificate_type"
        elif key == "protocolType":
            suggest = "protocol_type"
        elif key == "tlsVersion":
            suggest = "tls_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointCustomDomainCdnManagedHttps. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointCustomDomainCdnManagedHttps.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointCustomDomainCdnManagedHttps.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_type: str,
                 protocol_type: str,
                 tls_version: Optional[str] = None):
        """
        :param str certificate_type: The type of HTTPS certificate. Possible values are `Shared` and `Dedicated`.
        :param str protocol_type: The type of protocol. Possible values are `ServerNameIndication` and `IPBased`.
        :param str tls_version: The minimum TLS protocol version that is used for HTTPS. Possible values are `TLS10` (representing TLS 1.0/1.1), `TLS12` (representing TLS 1.2) and `None` (representing no minimums). Defaults to `TLS12`.
        """
        pulumi.set(__self__, "certificate_type", certificate_type)
        pulumi.set(__self__, "protocol_type", protocol_type)
        if tls_version is not None:
            pulumi.set(__self__, "tls_version", tls_version)

    @property
    @pulumi.getter(name="certificateType")
    def certificate_type(self) -> str:
        """
        The type of HTTPS certificate. Possible values are `Shared` and `Dedicated`.
        """
        return pulumi.get(self, "certificate_type")

    @property
    @pulumi.getter(name="protocolType")
    def protocol_type(self) -> str:
        """
        The type of protocol. Possible values are `ServerNameIndication` and `IPBased`.
        """
        return pulumi.get(self, "protocol_type")

    @property
    @pulumi.getter(name="tlsVersion")
    def tls_version(self) -> Optional[str]:
        """
        The minimum TLS protocol version that is used for HTTPS. Possible values are `TLS10` (representing TLS 1.0/1.1), `TLS12` (representing TLS 1.2) and `None` (representing no minimums). Defaults to `TLS12`.
        """
        return pulumi.get(self, "tls_version")


@pulumi.output_type
class EndpointCustomDomainUserManagedHttps(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVaultCertificateId":
            suggest = "key_vault_certificate_id"
        elif key == "keyVaultSecretId":
            suggest = "key_vault_secret_id"
        elif key == "tlsVersion":
            suggest = "tls_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointCustomDomainUserManagedHttps. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointCustomDomainUserManagedHttps.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointCustomDomainUserManagedHttps.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_vault_certificate_id: Optional[str] = None,
                 key_vault_secret_id: Optional[str] = None,
                 tls_version: Optional[str] = None):
        """
        :param str key_vault_certificate_id: The ID of the Key Vault Certificate that contains the HTTPS certificate. This is deprecated in favor of `key_vault_secret_id`.
        :param str key_vault_secret_id: The ID of the Key Vault Secret that contains the HTTPS certificate.
        :param str tls_version: The minimum TLS protocol version that is used for HTTPS. Possible values are `TLS10` (representing TLS 1.0/1.1), `TLS12` (representing TLS 1.2) and `None` (representing no minimums). Defaults to `TLS12`.
        """
        if key_vault_certificate_id is not None:
            pulumi.set(__self__, "key_vault_certificate_id", key_vault_certificate_id)
        if key_vault_secret_id is not None:
            pulumi.set(__self__, "key_vault_secret_id", key_vault_secret_id)
        if tls_version is not None:
            pulumi.set(__self__, "tls_version", tls_version)

    @property
    @pulumi.getter(name="keyVaultCertificateId")
    def key_vault_certificate_id(self) -> Optional[str]:
        """
        The ID of the Key Vault Certificate that contains the HTTPS certificate. This is deprecated in favor of `key_vault_secret_id`.
        """
        return pulumi.get(self, "key_vault_certificate_id")

    @property
    @pulumi.getter(name="keyVaultSecretId")
    def key_vault_secret_id(self) -> Optional[str]:
        """
        The ID of the Key Vault Secret that contains the HTTPS certificate.
        """
        return pulumi.get(self, "key_vault_secret_id")

    @property
    @pulumi.getter(name="tlsVersion")
    def tls_version(self) -> Optional[str]:
        """
        The minimum TLS protocol version that is used for HTTPS. Possible values are `TLS10` (representing TLS 1.0/1.1), `TLS12` (representing TLS 1.2) and `None` (representing no minimums). Defaults to `TLS12`.
        """
        return pulumi.get(self, "tls_version")


@pulumi.output_type
class EndpointDeliveryRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cacheExpirationAction":
            suggest = "cache_expiration_action"
        elif key == "cacheKeyQueryStringAction":
            suggest = "cache_key_query_string_action"
        elif key == "cookiesConditions":
            suggest = "cookies_conditions"
        elif key == "deviceCondition":
            suggest = "device_condition"
        elif key == "httpVersionConditions":
            suggest = "http_version_conditions"
        elif key == "modifyRequestHeaderActions":
            suggest = "modify_request_header_actions"
        elif key == "modifyResponseHeaderActions":
            suggest = "modify_response_header_actions"
        elif key == "postArgConditions":
            suggest = "post_arg_conditions"
        elif key == "queryStringConditions":
            suggest = "query_string_conditions"
        elif key == "remoteAddressConditions":
            suggest = "remote_address_conditions"
        elif key == "requestBodyConditions":
            suggest = "request_body_conditions"
        elif key == "requestHeaderConditions":
            suggest = "request_header_conditions"
        elif key == "requestMethodCondition":
            suggest = "request_method_condition"
        elif key == "requestSchemeCondition":
            suggest = "request_scheme_condition"
        elif key == "requestUriConditions":
            suggest = "request_uri_conditions"
        elif key == "urlFileExtensionConditions":
            suggest = "url_file_extension_conditions"
        elif key == "urlFileNameConditions":
            suggest = "url_file_name_conditions"
        elif key == "urlPathConditions":
            suggest = "url_path_conditions"
        elif key == "urlRedirectAction":
            suggest = "url_redirect_action"
        elif key == "urlRewriteAction":
            suggest = "url_rewrite_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointDeliveryRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointDeliveryRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointDeliveryRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 order: int,
                 cache_expiration_action: Optional['outputs.EndpointDeliveryRuleCacheExpirationAction'] = None,
                 cache_key_query_string_action: Optional['outputs.EndpointDeliveryRuleCacheKeyQueryStringAction'] = None,
                 cookies_conditions: Optional[Sequence['outputs.EndpointDeliveryRuleCookiesCondition']] = None,
                 device_condition: Optional['outputs.EndpointDeliveryRuleDeviceCondition'] = None,
                 http_version_conditions: Optional[Sequence['outputs.EndpointDeliveryRuleHttpVersionCondition']] = None,
                 modify_request_header_actions: Optional[Sequence['outputs.EndpointDeliveryRuleModifyRequestHeaderAction']] = None,
                 modify_response_header_actions: Optional[Sequence['outputs.EndpointDeliveryRuleModifyResponseHeaderAction']] = None,
                 post_arg_conditions: Optional[Sequence['outputs.EndpointDeliveryRulePostArgCondition']] = None,
                 query_string_conditions: Optional[Sequence['outputs.EndpointDeliveryRuleQueryStringCondition']] = None,
                 remote_address_conditions: Optional[Sequence['outputs.EndpointDeliveryRuleRemoteAddressCondition']] = None,
                 request_body_conditions: Optional[Sequence['outputs.EndpointDeliveryRuleRequestBodyCondition']] = None,
                 request_header_conditions: Optional[Sequence['outputs.EndpointDeliveryRuleRequestHeaderCondition']] = None,
                 request_method_condition: Optional['outputs.EndpointDeliveryRuleRequestMethodCondition'] = None,
                 request_scheme_condition: Optional['outputs.EndpointDeliveryRuleRequestSchemeCondition'] = None,
                 request_uri_conditions: Optional[Sequence['outputs.EndpointDeliveryRuleRequestUriCondition']] = None,
                 url_file_extension_conditions: Optional[Sequence['outputs.EndpointDeliveryRuleUrlFileExtensionCondition']] = None,
                 url_file_name_conditions: Optional[Sequence['outputs.EndpointDeliveryRuleUrlFileNameCondition']] = None,
                 url_path_conditions: Optional[Sequence['outputs.EndpointDeliveryRuleUrlPathCondition']] = None,
                 url_redirect_action: Optional['outputs.EndpointDeliveryRuleUrlRedirectAction'] = None,
                 url_rewrite_action: Optional['outputs.EndpointDeliveryRuleUrlRewriteAction'] = None):
        """
        :param str name: The Name which should be used for this Delivery Rule.
        :param int order: The order used for this rule. The order values should be sequential and begin at `1`.
        :param 'EndpointDeliveryRuleCacheExpirationActionArgs' cache_expiration_action: A `cache_expiration_action` block as defined above.
        :param 'EndpointDeliveryRuleCacheKeyQueryStringActionArgs' cache_key_query_string_action: A `cache_key_query_string_action` block as defined above.
        :param Sequence['EndpointDeliveryRuleCookiesConditionArgs'] cookies_conditions: A `cookies_condition` block as defined above.
        :param 'EndpointDeliveryRuleDeviceConditionArgs' device_condition: A `device_condition` block as defined below.
        :param Sequence['EndpointDeliveryRuleHttpVersionConditionArgs'] http_version_conditions: A `http_version_condition` block as defined below.
        :param Sequence['EndpointDeliveryRuleModifyRequestHeaderActionArgs'] modify_request_header_actions: A `modify_request_header_action` block as defined below.
        :param Sequence['EndpointDeliveryRuleModifyResponseHeaderActionArgs'] modify_response_header_actions: A `modify_response_header_action` block as defined below.
        :param Sequence['EndpointDeliveryRulePostArgConditionArgs'] post_arg_conditions: A `post_arg_condition` block as defined below.
        :param Sequence['EndpointDeliveryRuleQueryStringConditionArgs'] query_string_conditions: A `query_string_condition` block as defined below.
        :param Sequence['EndpointDeliveryRuleRemoteAddressConditionArgs'] remote_address_conditions: A `remote_address_condition` block as defined below.
        :param Sequence['EndpointDeliveryRuleRequestBodyConditionArgs'] request_body_conditions: A `request_body_condition` block as defined below.
        :param Sequence['EndpointDeliveryRuleRequestHeaderConditionArgs'] request_header_conditions: A `request_header_condition` block as defined below.
        :param 'EndpointDeliveryRuleRequestMethodConditionArgs' request_method_condition: A `request_method_condition` block as defined below.
        :param 'EndpointDeliveryRuleRequestSchemeConditionArgs' request_scheme_condition: A `request_scheme_condition` block as defined below.
        :param Sequence['EndpointDeliveryRuleRequestUriConditionArgs'] request_uri_conditions: A `request_uri_condition` block as defined below.
        :param Sequence['EndpointDeliveryRuleUrlFileExtensionConditionArgs'] url_file_extension_conditions: A `url_file_extension_condition` block as defined below.
        :param Sequence['EndpointDeliveryRuleUrlFileNameConditionArgs'] url_file_name_conditions: A `url_file_name_condition` block as defined below.
        :param Sequence['EndpointDeliveryRuleUrlPathConditionArgs'] url_path_conditions: A `url_path_condition` block as defined below.
        :param 'EndpointDeliveryRuleUrlRedirectActionArgs' url_redirect_action: A `url_redirect_action` block as defined below.
        :param 'EndpointDeliveryRuleUrlRewriteActionArgs' url_rewrite_action: A `url_rewrite_action` block as defined below.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "order", order)
        if cache_expiration_action is not None:
            pulumi.set(__self__, "cache_expiration_action", cache_expiration_action)
        if cache_key_query_string_action is not None:
            pulumi.set(__self__, "cache_key_query_string_action", cache_key_query_string_action)
        if cookies_conditions is not None:
            pulumi.set(__self__, "cookies_conditions", cookies_conditions)
        if device_condition is not None:
            pulumi.set(__self__, "device_condition", device_condition)
        if http_version_conditions is not None:
            pulumi.set(__self__, "http_version_conditions", http_version_conditions)
        if modify_request_header_actions is not None:
            pulumi.set(__self__, "modify_request_header_actions", modify_request_header_actions)
        if modify_response_header_actions is not None:
            pulumi.set(__self__, "modify_response_header_actions", modify_response_header_actions)
        if post_arg_conditions is not None:
            pulumi.set(__self__, "post_arg_conditions", post_arg_conditions)
        if query_string_conditions is not None:
            pulumi.set(__self__, "query_string_conditions", query_string_conditions)
        if remote_address_conditions is not None:
            pulumi.set(__self__, "remote_address_conditions", remote_address_conditions)
        if request_body_conditions is not None:
            pulumi.set(__self__, "request_body_conditions", request_body_conditions)
        if request_header_conditions is not None:
            pulumi.set(__self__, "request_header_conditions", request_header_conditions)
        if request_method_condition is not None:
            pulumi.set(__self__, "request_method_condition", request_method_condition)
        if request_scheme_condition is not None:
            pulumi.set(__self__, "request_scheme_condition", request_scheme_condition)
        if request_uri_conditions is not None:
            pulumi.set(__self__, "request_uri_conditions", request_uri_conditions)
        if url_file_extension_conditions is not None:
            pulumi.set(__self__, "url_file_extension_conditions", url_file_extension_conditions)
        if url_file_name_conditions is not None:
            pulumi.set(__self__, "url_file_name_conditions", url_file_name_conditions)
        if url_path_conditions is not None:
            pulumi.set(__self__, "url_path_conditions", url_path_conditions)
        if url_redirect_action is not None:
            pulumi.set(__self__, "url_redirect_action", url_redirect_action)
        if url_rewrite_action is not None:
            pulumi.set(__self__, "url_rewrite_action", url_rewrite_action)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Name which should be used for this Delivery Rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def order(self) -> int:
        """
        The order used for this rule. The order values should be sequential and begin at `1`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter(name="cacheExpirationAction")
    def cache_expiration_action(self) -> Optional['outputs.EndpointDeliveryRuleCacheExpirationAction']:
        """
        A `cache_expiration_action` block as defined above.
        """
        return pulumi.get(self, "cache_expiration_action")

    @property
    @pulumi.getter(name="cacheKeyQueryStringAction")
    def cache_key_query_string_action(self) -> Optional['outputs.EndpointDeliveryRuleCacheKeyQueryStringAction']:
        """
        A `cache_key_query_string_action` block as defined above.
        """
        return pulumi.get(self, "cache_key_query_string_action")

    @property
    @pulumi.getter(name="cookiesConditions")
    def cookies_conditions(self) -> Optional[Sequence['outputs.EndpointDeliveryRuleCookiesCondition']]:
        """
        A `cookies_condition` block as defined above.
        """
        return pulumi.get(self, "cookies_conditions")

    @property
    @pulumi.getter(name="deviceCondition")
    def device_condition(self) -> Optional['outputs.EndpointDeliveryRuleDeviceCondition']:
        """
        A `device_condition` block as defined below.
        """
        return pulumi.get(self, "device_condition")

    @property
    @pulumi.getter(name="httpVersionConditions")
    def http_version_conditions(self) -> Optional[Sequence['outputs.EndpointDeliveryRuleHttpVersionCondition']]:
        """
        A `http_version_condition` block as defined below.
        """
        return pulumi.get(self, "http_version_conditions")

    @property
    @pulumi.getter(name="modifyRequestHeaderActions")
    def modify_request_header_actions(self) -> Optional[Sequence['outputs.EndpointDeliveryRuleModifyRequestHeaderAction']]:
        """
        A `modify_request_header_action` block as defined below.
        """
        return pulumi.get(self, "modify_request_header_actions")

    @property
    @pulumi.getter(name="modifyResponseHeaderActions")
    def modify_response_header_actions(self) -> Optional[Sequence['outputs.EndpointDeliveryRuleModifyResponseHeaderAction']]:
        """
        A `modify_response_header_action` block as defined below.
        """
        return pulumi.get(self, "modify_response_header_actions")

    @property
    @pulumi.getter(name="postArgConditions")
    def post_arg_conditions(self) -> Optional[Sequence['outputs.EndpointDeliveryRulePostArgCondition']]:
        """
        A `post_arg_condition` block as defined below.
        """
        return pulumi.get(self, "post_arg_conditions")

    @property
    @pulumi.getter(name="queryStringConditions")
    def query_string_conditions(self) -> Optional[Sequence['outputs.EndpointDeliveryRuleQueryStringCondition']]:
        """
        A `query_string_condition` block as defined below.
        """
        return pulumi.get(self, "query_string_conditions")

    @property
    @pulumi.getter(name="remoteAddressConditions")
    def remote_address_conditions(self) -> Optional[Sequence['outputs.EndpointDeliveryRuleRemoteAddressCondition']]:
        """
        A `remote_address_condition` block as defined below.
        """
        return pulumi.get(self, "remote_address_conditions")

    @property
    @pulumi.getter(name="requestBodyConditions")
    def request_body_conditions(self) -> Optional[Sequence['outputs.EndpointDeliveryRuleRequestBodyCondition']]:
        """
        A `request_body_condition` block as defined below.
        """
        return pulumi.get(self, "request_body_conditions")

    @property
    @pulumi.getter(name="requestHeaderConditions")
    def request_header_conditions(self) -> Optional[Sequence['outputs.EndpointDeliveryRuleRequestHeaderCondition']]:
        """
        A `request_header_condition` block as defined below.
        """
        return pulumi.get(self, "request_header_conditions")

    @property
    @pulumi.getter(name="requestMethodCondition")
    def request_method_condition(self) -> Optional['outputs.EndpointDeliveryRuleRequestMethodCondition']:
        """
        A `request_method_condition` block as defined below.
        """
        return pulumi.get(self, "request_method_condition")

    @property
    @pulumi.getter(name="requestSchemeCondition")
    def request_scheme_condition(self) -> Optional['outputs.EndpointDeliveryRuleRequestSchemeCondition']:
        """
        A `request_scheme_condition` block as defined below.
        """
        return pulumi.get(self, "request_scheme_condition")

    @property
    @pulumi.getter(name="requestUriConditions")
    def request_uri_conditions(self) -> Optional[Sequence['outputs.EndpointDeliveryRuleRequestUriCondition']]:
        """
        A `request_uri_condition` block as defined below.
        """
        return pulumi.get(self, "request_uri_conditions")

    @property
    @pulumi.getter(name="urlFileExtensionConditions")
    def url_file_extension_conditions(self) -> Optional[Sequence['outputs.EndpointDeliveryRuleUrlFileExtensionCondition']]:
        """
        A `url_file_extension_condition` block as defined below.
        """
        return pulumi.get(self, "url_file_extension_conditions")

    @property
    @pulumi.getter(name="urlFileNameConditions")
    def url_file_name_conditions(self) -> Optional[Sequence['outputs.EndpointDeliveryRuleUrlFileNameCondition']]:
        """
        A `url_file_name_condition` block as defined below.
        """
        return pulumi.get(self, "url_file_name_conditions")

    @property
    @pulumi.getter(name="urlPathConditions")
    def url_path_conditions(self) -> Optional[Sequence['outputs.EndpointDeliveryRuleUrlPathCondition']]:
        """
        A `url_path_condition` block as defined below.
        """
        return pulumi.get(self, "url_path_conditions")

    @property
    @pulumi.getter(name="urlRedirectAction")
    def url_redirect_action(self) -> Optional['outputs.EndpointDeliveryRuleUrlRedirectAction']:
        """
        A `url_redirect_action` block as defined below.
        """
        return pulumi.get(self, "url_redirect_action")

    @property
    @pulumi.getter(name="urlRewriteAction")
    def url_rewrite_action(self) -> Optional['outputs.EndpointDeliveryRuleUrlRewriteAction']:
        """
        A `url_rewrite_action` block as defined below.
        """
        return pulumi.get(self, "url_rewrite_action")


@pulumi.output_type
class EndpointDeliveryRuleCacheExpirationAction(dict):
    def __init__(__self__, *,
                 behavior: str,
                 duration: Optional[str] = None):
        """
        :param str behavior: The behavior of the cache. Valid values are `BypassCache`, `Override` and `SetIfMissing`.
        :param str duration: Duration of the cache. Only allowed when `behavior` is set to `Override` or `SetIfMissing`. Format: `[d.]hh:mm:ss`
        """
        pulumi.set(__self__, "behavior", behavior)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)

    @property
    @pulumi.getter
    def behavior(self) -> str:
        """
        The behavior of the cache. Valid values are `BypassCache`, `Override` and `SetIfMissing`.
        """
        return pulumi.get(self, "behavior")

    @property
    @pulumi.getter
    def duration(self) -> Optional[str]:
        """
        Duration of the cache. Only allowed when `behavior` is set to `Override` or `SetIfMissing`. Format: `[d.]hh:mm:ss`
        """
        return pulumi.get(self, "duration")


@pulumi.output_type
class EndpointDeliveryRuleCacheKeyQueryStringAction(dict):
    def __init__(__self__, *,
                 behavior: str,
                 parameters: Optional[str] = None):
        """
        :param str behavior: The behavior of the cache key for query strings. Valid values are `Exclude`, `ExcludeAll`, `Include` and `IncludeAll`.
        :param str parameters: Comma separated list of parameter values.
        """
        pulumi.set(__self__, "behavior", behavior)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def behavior(self) -> str:
        """
        The behavior of the cache key for query strings. Valid values are `Exclude`, `ExcludeAll`, `Include` and `IncludeAll`.
        """
        return pulumi.get(self, "behavior")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[str]:
        """
        Comma separated list of parameter values.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class EndpointDeliveryRuleCookiesCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointDeliveryRuleCookiesCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointDeliveryRuleCookiesCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointDeliveryRuleCookiesCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 selector: str,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        :param str operator: Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        :param str selector: Name of the cookie.
        :param Sequence[str] match_values: List of values for the cookie. This is required if `operator` is not `Any`.
        :param bool negate_condition: Defaults to `false`.
        :param Sequence[str] transforms: A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "selector", selector)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def selector(self) -> str:
        """
        Name of the cookie.
        """
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        List of values for the cookie. This is required if `operator` is not `Any`.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class EndpointDeliveryRuleDeviceCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointDeliveryRuleDeviceCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointDeliveryRuleDeviceCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointDeliveryRuleDeviceCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_values: Sequence[str],
                 negate_condition: Optional[bool] = None,
                 operator: Optional[str] = None):
        """
        :param Sequence[str] match_values: Valid values are `Desktop` and `Mobile`.
        :param bool negate_condition: Defaults to `false`.
        :param str operator: Valid values are `Equal`.
        """
        pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Sequence[str]:
        """
        Valid values are `Desktop` and `Mobile`.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Valid values are `Equal`.
        """
        return pulumi.get(self, "operator")


@pulumi.output_type
class EndpointDeliveryRuleHttpVersionCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointDeliveryRuleHttpVersionCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointDeliveryRuleHttpVersionCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointDeliveryRuleHttpVersionCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_values: Sequence[str],
                 negate_condition: Optional[bool] = None,
                 operator: Optional[str] = None):
        """
        :param Sequence[str] match_values: Valid values are `0.9`, `1.0`, `1.1` and `2.0`.
        :param bool negate_condition: Defaults to `false`.
        :param str operator: Valid values are `Equal`.
        """
        pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Sequence[str]:
        """
        Valid values are `0.9`, `1.0`, `1.1` and `2.0`.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Valid values are `Equal`.
        """
        return pulumi.get(self, "operator")


@pulumi.output_type
class EndpointDeliveryRuleModifyRequestHeaderAction(dict):
    def __init__(__self__, *,
                 action: str,
                 name: str,
                 value: Optional[str] = None):
        """
        :param str action: Action to be executed on a header value. Valid values are `Append`, `Delete` and `Overwrite`.
        :param str name: The header name.
        :param str value: The value of the header. Only needed when `action` is set to `Append` or `overwrite`.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Action to be executed on a header value. Valid values are `Append`, `Delete` and `Overwrite`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The header name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the header. Only needed when `action` is set to `Append` or `overwrite`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EndpointDeliveryRuleModifyResponseHeaderAction(dict):
    def __init__(__self__, *,
                 action: str,
                 name: str,
                 value: Optional[str] = None):
        """
        :param str action: Action to be executed on a header value. Valid values are `Append`, `Delete` and `Overwrite`.
        :param str name: The header name.
        :param str value: The value of the header. Only needed when `action` is set to `Append` or `overwrite`.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Action to be executed on a header value. Valid values are `Append`, `Delete` and `Overwrite`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The header name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the header. Only needed when `action` is set to `Append` or `overwrite`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EndpointDeliveryRulePostArgCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointDeliveryRulePostArgCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointDeliveryRulePostArgCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointDeliveryRulePostArgCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 selector: str,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        :param str operator: Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        :param str selector: Name of the post arg.
        :param Sequence[str] match_values: List of string values. This is required if `operator` is not `Any`.
        :param bool negate_condition: Defaults to `false`.
        :param Sequence[str] transforms: A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "selector", selector)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def selector(self) -> str:
        """
        Name of the post arg.
        """
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        List of string values. This is required if `operator` is not `Any`.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class EndpointDeliveryRuleQueryStringCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointDeliveryRuleQueryStringCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointDeliveryRuleQueryStringCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointDeliveryRuleQueryStringCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        :param str operator: Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        :param Sequence[str] match_values: List of string values. This is required if `operator` is not `Any`.
        :param bool negate_condition: Defaults to `false`.
        :param Sequence[str] transforms: A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        pulumi.set(__self__, "operator", operator)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        List of string values. This is required if `operator` is not `Any`.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class EndpointDeliveryRuleRemoteAddressCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointDeliveryRuleRemoteAddressCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointDeliveryRuleRemoteAddressCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointDeliveryRuleRemoteAddressCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None):
        """
        :param str operator: Valid values are `Any`, `GeoMatch` and `IPMatch`.
        :param Sequence[str] match_values: List of string values. For `GeoMatch` `operator` this should be a list of country codes (e.g. `US` or `DE`). List of IP address if `operator` equals to `IPMatch`. This is required if `operator` is not `Any`.
        :param bool negate_condition: Defaults to `false`.
        """
        pulumi.set(__self__, "operator", operator)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Valid values are `Any`, `GeoMatch` and `IPMatch`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        List of string values. For `GeoMatch` `operator` this should be a list of country codes (e.g. `US` or `DE`). List of IP address if `operator` equals to `IPMatch`. This is required if `operator` is not `Any`.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "negate_condition")


@pulumi.output_type
class EndpointDeliveryRuleRequestBodyCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointDeliveryRuleRequestBodyCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointDeliveryRuleRequestBodyCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointDeliveryRuleRequestBodyCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        :param str operator: Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        :param Sequence[str] match_values: List of string values. This is required if `operator` is not `Any`.
        :param bool negate_condition: Defaults to `false`.
        :param Sequence[str] transforms: A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        pulumi.set(__self__, "operator", operator)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        List of string values. This is required if `operator` is not `Any`.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class EndpointDeliveryRuleRequestHeaderCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointDeliveryRuleRequestHeaderCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointDeliveryRuleRequestHeaderCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointDeliveryRuleRequestHeaderCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 selector: str,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        :param str operator: Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        :param str selector: Header name.
        :param Sequence[str] match_values: List of header values. This is required if `operator` is not `Any`.
        :param bool negate_condition: Defaults to `false`.
        :param Sequence[str] transforms: A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "selector", selector)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def selector(self) -> str:
        """
        Header name.
        """
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        List of header values. This is required if `operator` is not `Any`.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class EndpointDeliveryRuleRequestMethodCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointDeliveryRuleRequestMethodCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointDeliveryRuleRequestMethodCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointDeliveryRuleRequestMethodCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_values: Sequence[str],
                 negate_condition: Optional[bool] = None,
                 operator: Optional[str] = None):
        """
        :param Sequence[str] match_values: Valid values are `DELETE`, `GET`, `HEAD`, `OPTIONS`, `POST` and `PUT`.
        :param bool negate_condition: Defaults to `false`.
        :param str operator: Valid values are `Equal`.
        """
        pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Sequence[str]:
        """
        Valid values are `DELETE`, `GET`, `HEAD`, `OPTIONS`, `POST` and `PUT`.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Valid values are `Equal`.
        """
        return pulumi.get(self, "operator")


@pulumi.output_type
class EndpointDeliveryRuleRequestSchemeCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointDeliveryRuleRequestSchemeCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointDeliveryRuleRequestSchemeCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointDeliveryRuleRequestSchemeCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_values: Sequence[str],
                 negate_condition: Optional[bool] = None,
                 operator: Optional[str] = None):
        """
        :param Sequence[str] match_values: Valid values are `HTTP` and `HTTPS`.
        :param bool negate_condition: Defaults to `false`.
        :param str operator: Valid values are `Equal`.
        """
        pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Sequence[str]:
        """
        Valid values are `HTTP` and `HTTPS`.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Valid values are `Equal`.
        """
        return pulumi.get(self, "operator")


@pulumi.output_type
class EndpointDeliveryRuleRequestUriCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointDeliveryRuleRequestUriCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointDeliveryRuleRequestUriCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointDeliveryRuleRequestUriCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        :param str operator: Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        :param Sequence[str] match_values: List of string values. This is required if `operator` is not `Any`.
        :param bool negate_condition: Defaults to `false`.
        :param Sequence[str] transforms: A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        pulumi.set(__self__, "operator", operator)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        List of string values. This is required if `operator` is not `Any`.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class EndpointDeliveryRuleUrlFileExtensionCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointDeliveryRuleUrlFileExtensionCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointDeliveryRuleUrlFileExtensionCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointDeliveryRuleUrlFileExtensionCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        :param str operator: Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        :param Sequence[str] match_values: List of string values. This is required if `operator` is not `Any`.
        :param bool negate_condition: Defaults to `false`.
        :param Sequence[str] transforms: A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        pulumi.set(__self__, "operator", operator)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        List of string values. This is required if `operator` is not `Any`.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class EndpointDeliveryRuleUrlFileNameCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointDeliveryRuleUrlFileNameCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointDeliveryRuleUrlFileNameCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointDeliveryRuleUrlFileNameCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        :param str operator: Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        :param Sequence[str] match_values: List of string values. This is required if `operator` is not `Any`.
        :param bool negate_condition: Defaults to `false`.
        :param Sequence[str] transforms: A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        pulumi.set(__self__, "operator", operator)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        List of string values. This is required if `operator` is not `Any`.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class EndpointDeliveryRuleUrlPathCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointDeliveryRuleUrlPathCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointDeliveryRuleUrlPathCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointDeliveryRuleUrlPathCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        :param str operator: Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan`, `LessThanOrEqual`, `RegEx` and `Wildcard`.
        :param Sequence[str] match_values: List of string values. This is required if `operator` is not `Any`.
        :param bool negate_condition: Defaults to `false`.
        :param Sequence[str] transforms: A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        pulumi.set(__self__, "operator", operator)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan`, `LessThanOrEqual`, `RegEx` and `Wildcard`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        List of string values. This is required if `operator` is not `Any`.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class EndpointDeliveryRuleUrlRedirectAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "redirectType":
            suggest = "redirect_type"
        elif key == "queryString":
            suggest = "query_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointDeliveryRuleUrlRedirectAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointDeliveryRuleUrlRedirectAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointDeliveryRuleUrlRedirectAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 redirect_type: str,
                 fragment: Optional[str] = None,
                 hostname: Optional[str] = None,
                 path: Optional[str] = None,
                 protocol: Optional[str] = None,
                 query_string: Optional[str] = None):
        """
        :param str redirect_type: Type of the redirect. Valid values are `Found`, `Moved`, `PermanentRedirect` and `TemporaryRedirect`.
        :param str fragment: Specifies the fragment part of the URL. This value must not start with a `#`.
        :param str hostname: Specifies the hostname part of the URL.
        :param str path: Specifies the path part of the URL. This value must begin with a `/`.
        :param str protocol: Specifies the protocol part of the URL. Valid values are `MatchRequest`, `Http` and `Https`.
        :param str query_string: Specifies the query string part of the URL. This value must not start with a `?` or `&` and must be in `<key>=<value>` format separated by `&`.
        """
        pulumi.set(__self__, "redirect_type", redirect_type)
        if fragment is not None:
            pulumi.set(__self__, "fragment", fragment)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)

    @property
    @pulumi.getter(name="redirectType")
    def redirect_type(self) -> str:
        """
        Type of the redirect. Valid values are `Found`, `Moved`, `PermanentRedirect` and `TemporaryRedirect`.
        """
        return pulumi.get(self, "redirect_type")

    @property
    @pulumi.getter
    def fragment(self) -> Optional[str]:
        """
        Specifies the fragment part of the URL. This value must not start with a `#`.
        """
        return pulumi.get(self, "fragment")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        Specifies the hostname part of the URL.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Specifies the path part of the URL. This value must begin with a `/`.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        Specifies the protocol part of the URL. Valid values are `MatchRequest`, `Http` and `Https`.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[str]:
        """
        Specifies the query string part of the URL. This value must not start with a `?` or `&` and must be in `<key>=<value>` format separated by `&`.
        """
        return pulumi.get(self, "query_string")


@pulumi.output_type
class EndpointDeliveryRuleUrlRewriteAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourcePattern":
            suggest = "source_pattern"
        elif key == "preserveUnmatchedPath":
            suggest = "preserve_unmatched_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointDeliveryRuleUrlRewriteAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointDeliveryRuleUrlRewriteAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointDeliveryRuleUrlRewriteAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: str,
                 source_pattern: str,
                 preserve_unmatched_path: Optional[bool] = None):
        """
        :param str destination: This value must start with a `/` and can't be longer than 260 characters.
        :param str source_pattern: This value must start with a `/` and can't be longer than 260 characters.
        :param bool preserve_unmatched_path: Defaults to `true`.
        """
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "source_pattern", source_pattern)
        if preserve_unmatched_path is not None:
            pulumi.set(__self__, "preserve_unmatched_path", preserve_unmatched_path)

    @property
    @pulumi.getter
    def destination(self) -> str:
        """
        This value must start with a `/` and can't be longer than 260 characters.
        """
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter(name="sourcePattern")
    def source_pattern(self) -> str:
        """
        This value must start with a `/` and can't be longer than 260 characters.
        """
        return pulumi.get(self, "source_pattern")

    @property
    @pulumi.getter(name="preserveUnmatchedPath")
    def preserve_unmatched_path(self) -> Optional[bool]:
        """
        Defaults to `true`.
        """
        return pulumi.get(self, "preserve_unmatched_path")


@pulumi.output_type
class EndpointGeoFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "countryCodes":
            suggest = "country_codes"
        elif key == "relativePath":
            suggest = "relative_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointGeoFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointGeoFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointGeoFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 country_codes: Sequence[str],
                 relative_path: str):
        """
        :param str action: The Action of the Geo Filter. Possible values include `Allow` and `Block`.
        :param Sequence[str] country_codes: A List of two letter country codes (e.g. `US`, `GB`) to be associated with this Geo Filter.
        :param str relative_path: The relative path applicable to geo filter.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "country_codes", country_codes)
        pulumi.set(__self__, "relative_path", relative_path)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The Action of the Geo Filter. Possible values include `Allow` and `Block`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="countryCodes")
    def country_codes(self) -> Sequence[str]:
        """
        A List of two letter country codes (e.g. `US`, `GB`) to be associated with this Geo Filter.
        """
        return pulumi.get(self, "country_codes")

    @property
    @pulumi.getter(name="relativePath")
    def relative_path(self) -> str:
        """
        The relative path applicable to geo filter.
        """
        return pulumi.get(self, "relative_path")


@pulumi.output_type
class EndpointGlobalDeliveryRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cacheExpirationAction":
            suggest = "cache_expiration_action"
        elif key == "cacheKeyQueryStringAction":
            suggest = "cache_key_query_string_action"
        elif key == "modifyRequestHeaderActions":
            suggest = "modify_request_header_actions"
        elif key == "modifyResponseHeaderActions":
            suggest = "modify_response_header_actions"
        elif key == "urlRedirectAction":
            suggest = "url_redirect_action"
        elif key == "urlRewriteAction":
            suggest = "url_rewrite_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointGlobalDeliveryRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointGlobalDeliveryRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointGlobalDeliveryRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cache_expiration_action: Optional['outputs.EndpointGlobalDeliveryRuleCacheExpirationAction'] = None,
                 cache_key_query_string_action: Optional['outputs.EndpointGlobalDeliveryRuleCacheKeyQueryStringAction'] = None,
                 modify_request_header_actions: Optional[Sequence['outputs.EndpointGlobalDeliveryRuleModifyRequestHeaderAction']] = None,
                 modify_response_header_actions: Optional[Sequence['outputs.EndpointGlobalDeliveryRuleModifyResponseHeaderAction']] = None,
                 url_redirect_action: Optional['outputs.EndpointGlobalDeliveryRuleUrlRedirectAction'] = None,
                 url_rewrite_action: Optional['outputs.EndpointGlobalDeliveryRuleUrlRewriteAction'] = None):
        """
        :param 'EndpointGlobalDeliveryRuleCacheExpirationActionArgs' cache_expiration_action: A `cache_expiration_action` block as defined above.
        :param 'EndpointGlobalDeliveryRuleCacheKeyQueryStringActionArgs' cache_key_query_string_action: A `cache_key_query_string_action` block as defined above.
        :param Sequence['EndpointGlobalDeliveryRuleModifyRequestHeaderActionArgs'] modify_request_header_actions: A `modify_request_header_action` block as defined below.
        :param Sequence['EndpointGlobalDeliveryRuleModifyResponseHeaderActionArgs'] modify_response_header_actions: A `modify_response_header_action` block as defined below.
        :param 'EndpointGlobalDeliveryRuleUrlRedirectActionArgs' url_redirect_action: A `url_redirect_action` block as defined below.
        :param 'EndpointGlobalDeliveryRuleUrlRewriteActionArgs' url_rewrite_action: A `url_rewrite_action` block as defined below.
        """
        if cache_expiration_action is not None:
            pulumi.set(__self__, "cache_expiration_action", cache_expiration_action)
        if cache_key_query_string_action is not None:
            pulumi.set(__self__, "cache_key_query_string_action", cache_key_query_string_action)
        if modify_request_header_actions is not None:
            pulumi.set(__self__, "modify_request_header_actions", modify_request_header_actions)
        if modify_response_header_actions is not None:
            pulumi.set(__self__, "modify_response_header_actions", modify_response_header_actions)
        if url_redirect_action is not None:
            pulumi.set(__self__, "url_redirect_action", url_redirect_action)
        if url_rewrite_action is not None:
            pulumi.set(__self__, "url_rewrite_action", url_rewrite_action)

    @property
    @pulumi.getter(name="cacheExpirationAction")
    def cache_expiration_action(self) -> Optional['outputs.EndpointGlobalDeliveryRuleCacheExpirationAction']:
        """
        A `cache_expiration_action` block as defined above.
        """
        return pulumi.get(self, "cache_expiration_action")

    @property
    @pulumi.getter(name="cacheKeyQueryStringAction")
    def cache_key_query_string_action(self) -> Optional['outputs.EndpointGlobalDeliveryRuleCacheKeyQueryStringAction']:
        """
        A `cache_key_query_string_action` block as defined above.
        """
        return pulumi.get(self, "cache_key_query_string_action")

    @property
    @pulumi.getter(name="modifyRequestHeaderActions")
    def modify_request_header_actions(self) -> Optional[Sequence['outputs.EndpointGlobalDeliveryRuleModifyRequestHeaderAction']]:
        """
        A `modify_request_header_action` block as defined below.
        """
        return pulumi.get(self, "modify_request_header_actions")

    @property
    @pulumi.getter(name="modifyResponseHeaderActions")
    def modify_response_header_actions(self) -> Optional[Sequence['outputs.EndpointGlobalDeliveryRuleModifyResponseHeaderAction']]:
        """
        A `modify_response_header_action` block as defined below.
        """
        return pulumi.get(self, "modify_response_header_actions")

    @property
    @pulumi.getter(name="urlRedirectAction")
    def url_redirect_action(self) -> Optional['outputs.EndpointGlobalDeliveryRuleUrlRedirectAction']:
        """
        A `url_redirect_action` block as defined below.
        """
        return pulumi.get(self, "url_redirect_action")

    @property
    @pulumi.getter(name="urlRewriteAction")
    def url_rewrite_action(self) -> Optional['outputs.EndpointGlobalDeliveryRuleUrlRewriteAction']:
        """
        A `url_rewrite_action` block as defined below.
        """
        return pulumi.get(self, "url_rewrite_action")


@pulumi.output_type
class EndpointGlobalDeliveryRuleCacheExpirationAction(dict):
    def __init__(__self__, *,
                 behavior: str,
                 duration: Optional[str] = None):
        """
        :param str behavior: The behavior of the cache. Valid values are `BypassCache`, `Override` and `SetIfMissing`.
        :param str duration: Duration of the cache. Only allowed when `behavior` is set to `Override` or `SetIfMissing`. Format: `[d.]hh:mm:ss`
        """
        pulumi.set(__self__, "behavior", behavior)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)

    @property
    @pulumi.getter
    def behavior(self) -> str:
        """
        The behavior of the cache. Valid values are `BypassCache`, `Override` and `SetIfMissing`.
        """
        return pulumi.get(self, "behavior")

    @property
    @pulumi.getter
    def duration(self) -> Optional[str]:
        """
        Duration of the cache. Only allowed when `behavior` is set to `Override` or `SetIfMissing`. Format: `[d.]hh:mm:ss`
        """
        return pulumi.get(self, "duration")


@pulumi.output_type
class EndpointGlobalDeliveryRuleCacheKeyQueryStringAction(dict):
    def __init__(__self__, *,
                 behavior: str,
                 parameters: Optional[str] = None):
        """
        :param str behavior: The behavior of the cache key for query strings. Valid values are `Exclude`, `ExcludeAll`, `Include` and `IncludeAll`.
        :param str parameters: Comma separated list of parameter values.
        """
        pulumi.set(__self__, "behavior", behavior)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def behavior(self) -> str:
        """
        The behavior of the cache key for query strings. Valid values are `Exclude`, `ExcludeAll`, `Include` and `IncludeAll`.
        """
        return pulumi.get(self, "behavior")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[str]:
        """
        Comma separated list of parameter values.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class EndpointGlobalDeliveryRuleModifyRequestHeaderAction(dict):
    def __init__(__self__, *,
                 action: str,
                 name: str,
                 value: Optional[str] = None):
        """
        :param str action: Action to be executed on a header value. Valid values are `Append`, `Delete` and `Overwrite`.
        :param str name: The header name.
        :param str value: The value of the header. Only needed when `action` is set to `Append` or `overwrite`.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Action to be executed on a header value. Valid values are `Append`, `Delete` and `Overwrite`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The header name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the header. Only needed when `action` is set to `Append` or `overwrite`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EndpointGlobalDeliveryRuleModifyResponseHeaderAction(dict):
    def __init__(__self__, *,
                 action: str,
                 name: str,
                 value: Optional[str] = None):
        """
        :param str action: Action to be executed on a header value. Valid values are `Append`, `Delete` and `Overwrite`.
        :param str name: The header name.
        :param str value: The value of the header. Only needed when `action` is set to `Append` or `overwrite`.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Action to be executed on a header value. Valid values are `Append`, `Delete` and `Overwrite`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The header name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the header. Only needed when `action` is set to `Append` or `overwrite`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EndpointGlobalDeliveryRuleUrlRedirectAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "redirectType":
            suggest = "redirect_type"
        elif key == "queryString":
            suggest = "query_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointGlobalDeliveryRuleUrlRedirectAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointGlobalDeliveryRuleUrlRedirectAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointGlobalDeliveryRuleUrlRedirectAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 redirect_type: str,
                 fragment: Optional[str] = None,
                 hostname: Optional[str] = None,
                 path: Optional[str] = None,
                 protocol: Optional[str] = None,
                 query_string: Optional[str] = None):
        """
        :param str redirect_type: Type of the redirect. Valid values are `Found`, `Moved`, `PermanentRedirect` and `TemporaryRedirect`.
        :param str fragment: Specifies the fragment part of the URL. This value must not start with a `#`.
        :param str hostname: Specifies the hostname part of the URL.
        :param str path: Specifies the path part of the URL. This value must begin with a `/`.
        :param str protocol: Specifies the protocol part of the URL. Valid values are `MatchRequest`, `Http` and `Https`.
        :param str query_string: Specifies the query string part of the URL. This value must not start with a `?` or `&` and must be in `<key>=<value>` format separated by `&`.
        """
        pulumi.set(__self__, "redirect_type", redirect_type)
        if fragment is not None:
            pulumi.set(__self__, "fragment", fragment)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)

    @property
    @pulumi.getter(name="redirectType")
    def redirect_type(self) -> str:
        """
        Type of the redirect. Valid values are `Found`, `Moved`, `PermanentRedirect` and `TemporaryRedirect`.
        """
        return pulumi.get(self, "redirect_type")

    @property
    @pulumi.getter
    def fragment(self) -> Optional[str]:
        """
        Specifies the fragment part of the URL. This value must not start with a `#`.
        """
        return pulumi.get(self, "fragment")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        Specifies the hostname part of the URL.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Specifies the path part of the URL. This value must begin with a `/`.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        Specifies the protocol part of the URL. Valid values are `MatchRequest`, `Http` and `Https`.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[str]:
        """
        Specifies the query string part of the URL. This value must not start with a `?` or `&` and must be in `<key>=<value>` format separated by `&`.
        """
        return pulumi.get(self, "query_string")


@pulumi.output_type
class EndpointGlobalDeliveryRuleUrlRewriteAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourcePattern":
            suggest = "source_pattern"
        elif key == "preserveUnmatchedPath":
            suggest = "preserve_unmatched_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointGlobalDeliveryRuleUrlRewriteAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointGlobalDeliveryRuleUrlRewriteAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointGlobalDeliveryRuleUrlRewriteAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: str,
                 source_pattern: str,
                 preserve_unmatched_path: Optional[bool] = None):
        """
        :param str destination: This value must start with a `/` and can't be longer than 260 characters.
        :param str source_pattern: This value must start with a `/` and can't be longer than 260 characters.
        :param bool preserve_unmatched_path: Defaults to `true`.
        """
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "source_pattern", source_pattern)
        if preserve_unmatched_path is not None:
            pulumi.set(__self__, "preserve_unmatched_path", preserve_unmatched_path)

    @property
    @pulumi.getter
    def destination(self) -> str:
        """
        This value must start with a `/` and can't be longer than 260 characters.
        """
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter(name="sourcePattern")
    def source_pattern(self) -> str:
        """
        This value must start with a `/` and can't be longer than 260 characters.
        """
        return pulumi.get(self, "source_pattern")

    @property
    @pulumi.getter(name="preserveUnmatchedPath")
    def preserve_unmatched_path(self) -> Optional[bool]:
        """
        Defaults to `true`.
        """
        return pulumi.get(self, "preserve_unmatched_path")


@pulumi.output_type
class EndpointOrigin(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostName":
            suggest = "host_name"
        elif key == "httpPort":
            suggest = "http_port"
        elif key == "httpsPort":
            suggest = "https_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointOrigin. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointOrigin.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointOrigin.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host_name: str,
                 name: str,
                 http_port: Optional[int] = None,
                 https_port: Optional[int] = None):
        """
        :param str host_name: A string that determines the hostname/IP address of the origin server. This string can be a domain name, Storage Account endpoint, Web App endpoint, IPv4 address or IPv6 address. Changing this forces a new resource to be created.
        :param str name: The name of the origin. This is an arbitrary value. However, this value needs to be unique under the endpoint. Changing this forces a new resource to be created.
        :param int http_port: The HTTP port of the origin. Defaults to `80`. Changing this forces a new resource to be created.
        :param int https_port: The HTTPS port of the origin. Defaults to `443`. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "host_name", host_name)
        pulumi.set(__self__, "name", name)
        if http_port is not None:
            pulumi.set(__self__, "http_port", http_port)
        if https_port is not None:
            pulumi.set(__self__, "https_port", https_port)

    @property
    @pulumi.getter(name="hostName")
    def host_name(self) -> str:
        """
        A string that determines the hostname/IP address of the origin server. This string can be a domain name, Storage Account endpoint, Web App endpoint, IPv4 address or IPv6 address. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "host_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the origin. This is an arbitrary value. However, this value needs to be unique under the endpoint. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> Optional[int]:
        """
        The HTTP port of the origin. Defaults to `80`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "http_port")

    @property
    @pulumi.getter(name="httpsPort")
    def https_port(self) -> Optional[int]:
        """
        The HTTPS port of the origin. Defaults to `443`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "https_port")


@pulumi.output_type
class FrontdoorCustomDomainTls(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cdnFrontdoorSecretId":
            suggest = "cdn_frontdoor_secret_id"
        elif key == "certificateType":
            suggest = "certificate_type"
        elif key == "minimumTlsVersion":
            suggest = "minimum_tls_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorCustomDomainTls. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorCustomDomainTls.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorCustomDomainTls.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cdn_frontdoor_secret_id: Optional[str] = None,
                 certificate_type: Optional[str] = None,
                 minimum_tls_version: Optional[str] = None):
        """
        :param str cdn_frontdoor_secret_id: Resource ID of the Front Door Secret.
        :param str certificate_type: Defines the source of the SSL certificate. Possible values include `CustomerCertificate` and `ManagedCertificate`. Defaults to `ManagedCertificate`.
        :param str minimum_tls_version: TLS protocol version that will be used for Https. Possible values include `TLS10` and `TLS12`. Defaults to `TLS12`.
        """
        if cdn_frontdoor_secret_id is not None:
            pulumi.set(__self__, "cdn_frontdoor_secret_id", cdn_frontdoor_secret_id)
        if certificate_type is not None:
            pulumi.set(__self__, "certificate_type", certificate_type)
        if minimum_tls_version is not None:
            pulumi.set(__self__, "minimum_tls_version", minimum_tls_version)

    @property
    @pulumi.getter(name="cdnFrontdoorSecretId")
    def cdn_frontdoor_secret_id(self) -> Optional[str]:
        """
        Resource ID of the Front Door Secret.
        """
        return pulumi.get(self, "cdn_frontdoor_secret_id")

    @property
    @pulumi.getter(name="certificateType")
    def certificate_type(self) -> Optional[str]:
        """
        Defines the source of the SSL certificate. Possible values include `CustomerCertificate` and `ManagedCertificate`. Defaults to `ManagedCertificate`.
        """
        return pulumi.get(self, "certificate_type")

    @property
    @pulumi.getter(name="minimumTlsVersion")
    def minimum_tls_version(self) -> Optional[str]:
        """
        TLS protocol version that will be used for Https. Possible values include `TLS10` and `TLS12`. Defaults to `TLS12`.
        """
        return pulumi.get(self, "minimum_tls_version")


@pulumi.output_type
class FrontdoorFirewallPolicyCustomRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchConditions":
            suggest = "match_conditions"
        elif key == "rateLimitDurationInMinutes":
            suggest = "rate_limit_duration_in_minutes"
        elif key == "rateLimitThreshold":
            suggest = "rate_limit_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorFirewallPolicyCustomRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorFirewallPolicyCustomRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorFirewallPolicyCustomRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 name: str,
                 type: str,
                 enabled: Optional[bool] = None,
                 match_conditions: Optional[Sequence['outputs.FrontdoorFirewallPolicyCustomRuleMatchCondition']] = None,
                 priority: Optional[int] = None,
                 rate_limit_duration_in_minutes: Optional[int] = None,
                 rate_limit_threshold: Optional[int] = None):
        """
        :param str action: The action to perform when the rule is matched. Possible values are `Allow`, `Block`, `Log`, or `Redirect`.
        :param str name: Gets name of the resource that is unique within a policy. This name can be used to access the resource.
        :param str type: The type of rule. Possible values are `MatchRule` or `RateLimitRule`.
        :param bool enabled: Is the rule is enabled or disabled? Defaults to `true`.
        :param Sequence['FrontdoorFirewallPolicyCustomRuleMatchConditionArgs'] match_conditions: One or more `match_condition` block defined below. Can support up to `10` `match_condition` blocks.
        :param int priority: The priority of the rule. Rules with a lower value will be evaluated before rules with a higher value. Defaults to `1`.
        :param int rate_limit_duration_in_minutes: The rate limit duration in minutes. Defaults to `1`.
        :param int rate_limit_threshold: The rate limit threshold. Defaults to `10`.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if match_conditions is not None:
            pulumi.set(__self__, "match_conditions", match_conditions)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if rate_limit_duration_in_minutes is not None:
            pulumi.set(__self__, "rate_limit_duration_in_minutes", rate_limit_duration_in_minutes)
        if rate_limit_threshold is not None:
            pulumi.set(__self__, "rate_limit_threshold", rate_limit_threshold)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action to perform when the rule is matched. Possible values are `Allow`, `Block`, `Log`, or `Redirect`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Gets name of the resource that is unique within a policy. This name can be used to access the resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of rule. Possible values are `MatchRule` or `RateLimitRule`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Is the rule is enabled or disabled? Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="matchConditions")
    def match_conditions(self) -> Optional[Sequence['outputs.FrontdoorFirewallPolicyCustomRuleMatchCondition']]:
        """
        One or more `match_condition` block defined below. Can support up to `10` `match_condition` blocks.
        """
        return pulumi.get(self, "match_conditions")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority of the rule. Rules with a lower value will be evaluated before rules with a higher value. Defaults to `1`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="rateLimitDurationInMinutes")
    def rate_limit_duration_in_minutes(self) -> Optional[int]:
        """
        The rate limit duration in minutes. Defaults to `1`.
        """
        return pulumi.get(self, "rate_limit_duration_in_minutes")

    @property
    @pulumi.getter(name="rateLimitThreshold")
    def rate_limit_threshold(self) -> Optional[int]:
        """
        The rate limit threshold. Defaults to `10`.
        """
        return pulumi.get(self, "rate_limit_threshold")


@pulumi.output_type
class FrontdoorFirewallPolicyCustomRuleMatchCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValues":
            suggest = "match_values"
        elif key == "matchVariable":
            suggest = "match_variable"
        elif key == "negationCondition":
            suggest = "negation_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorFirewallPolicyCustomRuleMatchCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorFirewallPolicyCustomRuleMatchCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorFirewallPolicyCustomRuleMatchCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_values: Sequence[str],
                 match_variable: str,
                 operator: str,
                 negation_condition: Optional[bool] = None,
                 selector: Optional[str] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] match_values: Up to `600` possible values to match. Limit is in total across all `match_condition` blocks and `match_values` arguments. String value itself can be up to `256` characters in length.
        :param str match_variable: The request variable to compare with. Possible values are `Cookies`, `PostArgs`, `QueryString`, `RemoteAddr`, `RequestBody`, `RequestHeader`, `RequestMethod`, `RequestUri`, or `SocketAddr`.
        :param str operator: Comparison type to use for matching with the variable value. Possible values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GeoMatch`, `GreaterThan`, `GreaterThanOrEqual`, `IPMatch`, `LessThan`, `LessThanOrEqual` or `RegEx`.
        :param bool negation_condition: Should the result of the condition be negated.
        :param str selector: Match against a specific key if the `match_variable` is `QueryString`, `PostArgs`, `RequestHeader` or `Cookies`.
        :param Sequence[str] transforms: Up to `5` transforms to apply. Possible values are `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `URLDecode` or `URLEncode`.
        """
        pulumi.set(__self__, "match_values", match_values)
        pulumi.set(__self__, "match_variable", match_variable)
        pulumi.set(__self__, "operator", operator)
        if negation_condition is not None:
            pulumi.set(__self__, "negation_condition", negation_condition)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Sequence[str]:
        """
        Up to `600` possible values to match. Limit is in total across all `match_condition` blocks and `match_values` arguments. String value itself can be up to `256` characters in length.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="matchVariable")
    def match_variable(self) -> str:
        """
        The request variable to compare with. Possible values are `Cookies`, `PostArgs`, `QueryString`, `RemoteAddr`, `RequestBody`, `RequestHeader`, `RequestMethod`, `RequestUri`, or `SocketAddr`.
        """
        return pulumi.get(self, "match_variable")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Comparison type to use for matching with the variable value. Possible values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GeoMatch`, `GreaterThan`, `GreaterThanOrEqual`, `IPMatch`, `LessThan`, `LessThanOrEqual` or `RegEx`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="negationCondition")
    def negation_condition(self) -> Optional[bool]:
        """
        Should the result of the condition be negated.
        """
        return pulumi.get(self, "negation_condition")

    @property
    @pulumi.getter
    def selector(self) -> Optional[str]:
        """
        Match against a specific key if the `match_variable` is `QueryString`, `PostArgs`, `RequestHeader` or `Cookies`.
        """
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        Up to `5` transforms to apply. Possible values are `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `URLDecode` or `URLEncode`.
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class FrontdoorFirewallPolicyManagedRule(dict):
    def __init__(__self__, *,
                 action: str,
                 type: str,
                 version: str,
                 exclusions: Optional[Sequence['outputs.FrontdoorFirewallPolicyManagedRuleExclusion']] = None,
                 overrides: Optional[Sequence['outputs.FrontdoorFirewallPolicyManagedRuleOverride']] = None):
        """
        :param str action: The action to perform when the managed rule is matched. Possible values depends on which DRS version you are using, for DRS `1.0`, `1.1` and `preview-0.1` the possible values include `Allow`, `Block`, `Log`, or `Redirect`. For DRS `2.0` and `2.1` the value must be `AnomalyScoring`.
        :param str type: The name of the managed rule to use with this resource. Possible values include `DefaultRuleSet`, `Microsoft_DefaultRuleSet`, `BotProtection` or `Microsoft_BotManagerRuleSet`.
        :param str version: The version of the managed rule to use with this resource. Possible values depends on which DRS type you are using, for the `DefaultRuleSet` type the possible values include `1.0` or `preview-0.1`. For `Microsoft_DefaultRuleSet` the possible values include `1.1`, `2.0` or `2.1`. For `BotProtection` the value must be `preview-0.1` and for `Microsoft_BotManagerRuleSet` the value must be `1.0`.
        :param Sequence['FrontdoorFirewallPolicyManagedRuleExclusionArgs'] exclusions: One or more `exclusion` blocks as defined below.
        :param Sequence['FrontdoorFirewallPolicyManagedRuleOverrideArgs'] overrides: One or more `override` blocks as defined below.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "version", version)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action to perform when the managed rule is matched. Possible values depends on which DRS version you are using, for DRS `1.0`, `1.1` and `preview-0.1` the possible values include `Allow`, `Block`, `Log`, or `Redirect`. For DRS `2.0` and `2.1` the value must be `AnomalyScoring`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The name of the managed rule to use with this resource. Possible values include `DefaultRuleSet`, `Microsoft_DefaultRuleSet`, `BotProtection` or `Microsoft_BotManagerRuleSet`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        The version of the managed rule to use with this resource. Possible values depends on which DRS type you are using, for the `DefaultRuleSet` type the possible values include `1.0` or `preview-0.1`. For `Microsoft_DefaultRuleSet` the possible values include `1.1`, `2.0` or `2.1`. For `BotProtection` the value must be `preview-0.1` and for `Microsoft_BotManagerRuleSet` the value must be `1.0`.
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence['outputs.FrontdoorFirewallPolicyManagedRuleExclusion']]:
        """
        One or more `exclusion` blocks as defined below.
        """
        return pulumi.get(self, "exclusions")

    @property
    @pulumi.getter
    def overrides(self) -> Optional[Sequence['outputs.FrontdoorFirewallPolicyManagedRuleOverride']]:
        """
        One or more `override` blocks as defined below.
        """
        return pulumi.get(self, "overrides")


@pulumi.output_type
class FrontdoorFirewallPolicyManagedRuleExclusion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchVariable":
            suggest = "match_variable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorFirewallPolicyManagedRuleExclusion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorFirewallPolicyManagedRuleExclusion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorFirewallPolicyManagedRuleExclusion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_variable: str,
                 operator: str,
                 selector: str):
        """
        :param str match_variable: The variable type to be excluded. Possible values are `QueryStringArgNames`, `RequestBodyPostArgNames`, `RequestCookieNames`, `RequestHeaderNames`, `RequestBodyJsonArgNames`
        :param str operator: Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to. Possible values are: `Equals`, `Contains`, `StartsWith`, `EndsWith`, `EqualsAny`.
        :param str selector: Selector for the value in the `match_variable` attribute this exclusion applies to.
        """
        pulumi.set(__self__, "match_variable", match_variable)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "selector", selector)

    @property
    @pulumi.getter(name="matchVariable")
    def match_variable(self) -> str:
        """
        The variable type to be excluded. Possible values are `QueryStringArgNames`, `RequestBodyPostArgNames`, `RequestCookieNames`, `RequestHeaderNames`, `RequestBodyJsonArgNames`
        """
        return pulumi.get(self, "match_variable")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to. Possible values are: `Equals`, `Contains`, `StartsWith`, `EndsWith`, `EqualsAny`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def selector(self) -> str:
        """
        Selector for the value in the `match_variable` attribute this exclusion applies to.
        """
        return pulumi.get(self, "selector")


@pulumi.output_type
class FrontdoorFirewallPolicyManagedRuleOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleGroupName":
            suggest = "rule_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorFirewallPolicyManagedRuleOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorFirewallPolicyManagedRuleOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorFirewallPolicyManagedRuleOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rule_group_name: str,
                 exclusions: Optional[Sequence['outputs.FrontdoorFirewallPolicyManagedRuleOverrideExclusion']] = None,
                 rules: Optional[Sequence['outputs.FrontdoorFirewallPolicyManagedRuleOverrideRule']] = None):
        """
        :param str rule_group_name: The managed rule group to override.
        :param Sequence['FrontdoorFirewallPolicyManagedRuleOverrideExclusionArgs'] exclusions: One or more `exclusion` blocks as defined below.
        :param Sequence['FrontdoorFirewallPolicyManagedRuleOverrideRuleArgs'] rules: One or more `rule` blocks as defined below. If none are specified, all of the rules in the group will be disabled.
        """
        pulumi.set(__self__, "rule_group_name", rule_group_name)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter(name="ruleGroupName")
    def rule_group_name(self) -> str:
        """
        The managed rule group to override.
        """
        return pulumi.get(self, "rule_group_name")

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence['outputs.FrontdoorFirewallPolicyManagedRuleOverrideExclusion']]:
        """
        One or more `exclusion` blocks as defined below.
        """
        return pulumi.get(self, "exclusions")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.FrontdoorFirewallPolicyManagedRuleOverrideRule']]:
        """
        One or more `rule` blocks as defined below. If none are specified, all of the rules in the group will be disabled.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class FrontdoorFirewallPolicyManagedRuleOverrideExclusion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchVariable":
            suggest = "match_variable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorFirewallPolicyManagedRuleOverrideExclusion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorFirewallPolicyManagedRuleOverrideExclusion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorFirewallPolicyManagedRuleOverrideExclusion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_variable: str,
                 operator: str,
                 selector: str):
        """
        :param str match_variable: The variable type to be excluded. Possible values are `QueryStringArgNames`, `RequestBodyPostArgNames`, `RequestCookieNames`, `RequestHeaderNames`, `RequestBodyJsonArgNames`
        :param str operator: Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to. Possible values are: `Equals`, `Contains`, `StartsWith`, `EndsWith`, `EqualsAny`.
        :param str selector: Selector for the value in the `match_variable` attribute this exclusion applies to.
        """
        pulumi.set(__self__, "match_variable", match_variable)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "selector", selector)

    @property
    @pulumi.getter(name="matchVariable")
    def match_variable(self) -> str:
        """
        The variable type to be excluded. Possible values are `QueryStringArgNames`, `RequestBodyPostArgNames`, `RequestCookieNames`, `RequestHeaderNames`, `RequestBodyJsonArgNames`
        """
        return pulumi.get(self, "match_variable")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to. Possible values are: `Equals`, `Contains`, `StartsWith`, `EndsWith`, `EqualsAny`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def selector(self) -> str:
        """
        Selector for the value in the `match_variable` attribute this exclusion applies to.
        """
        return pulumi.get(self, "selector")


@pulumi.output_type
class FrontdoorFirewallPolicyManagedRuleOverrideRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleId":
            suggest = "rule_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorFirewallPolicyManagedRuleOverrideRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorFirewallPolicyManagedRuleOverrideRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorFirewallPolicyManagedRuleOverrideRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 rule_id: str,
                 enabled: Optional[bool] = None,
                 exclusions: Optional[Sequence['outputs.FrontdoorFirewallPolicyManagedRuleOverrideRuleExclusion']] = None):
        """
        :param str action: The action to be applied when the rule matches. Possible values are `Allow`, `Log`, `Block`, `Redirect` and `AnomalyScoring`.
        :param str rule_id: Identifier for the managed rule.
        :param bool enabled: Is the managed rule override enabled or disabled. Defaults to `false`
        :param Sequence['FrontdoorFirewallPolicyManagedRuleOverrideRuleExclusionArgs'] exclusions: One or more `exclusion` blocks as defined below.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "rule_id", rule_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action to be applied when the rule matches. Possible values are `Allow`, `Log`, `Block`, `Redirect` and `AnomalyScoring`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> str:
        """
        Identifier for the managed rule.
        """
        return pulumi.get(self, "rule_id")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Is the managed rule override enabled or disabled. Defaults to `false`
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence['outputs.FrontdoorFirewallPolicyManagedRuleOverrideRuleExclusion']]:
        """
        One or more `exclusion` blocks as defined below.
        """
        return pulumi.get(self, "exclusions")


@pulumi.output_type
class FrontdoorFirewallPolicyManagedRuleOverrideRuleExclusion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchVariable":
            suggest = "match_variable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorFirewallPolicyManagedRuleOverrideRuleExclusion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorFirewallPolicyManagedRuleOverrideRuleExclusion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorFirewallPolicyManagedRuleOverrideRuleExclusion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_variable: str,
                 operator: str,
                 selector: str):
        """
        :param str match_variable: The variable type to be excluded. Possible values are `QueryStringArgNames`, `RequestBodyPostArgNames`, `RequestCookieNames`, `RequestHeaderNames`, `RequestBodyJsonArgNames`
        :param str operator: Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to. Possible values are: `Equals`, `Contains`, `StartsWith`, `EndsWith`, `EqualsAny`.
        :param str selector: Selector for the value in the `match_variable` attribute this exclusion applies to.
        """
        pulumi.set(__self__, "match_variable", match_variable)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "selector", selector)

    @property
    @pulumi.getter(name="matchVariable")
    def match_variable(self) -> str:
        """
        The variable type to be excluded. Possible values are `QueryStringArgNames`, `RequestBodyPostArgNames`, `RequestCookieNames`, `RequestHeaderNames`, `RequestBodyJsonArgNames`
        """
        return pulumi.get(self, "match_variable")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to. Possible values are: `Equals`, `Contains`, `StartsWith`, `EndsWith`, `EqualsAny`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def selector(self) -> str:
        """
        Selector for the value in the `match_variable` attribute this exclusion applies to.
        """
        return pulumi.get(self, "selector")


@pulumi.output_type
class FrontdoorOriginGroupHealthProbe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "intervalInSeconds":
            suggest = "interval_in_seconds"
        elif key == "requestType":
            suggest = "request_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorOriginGroupHealthProbe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorOriginGroupHealthProbe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorOriginGroupHealthProbe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interval_in_seconds: int,
                 protocol: str,
                 path: Optional[str] = None,
                 request_type: Optional[str] = None):
        """
        :param int interval_in_seconds: Specifies the number of seconds between health probes. Possible values are between `5` and `31536000` seconds (inclusive).
        :param str protocol: Specifies the protocol to use for health probe. Possible values are `Http` and `Https`.
        :param str path: Specifies the path relative to the origin that is used to determine the health of the origin. Defaults to `/`.
        :param str request_type: Specifies the type of health probe request that is made. Possible values are `GET` and `HEAD`. Defaults to `HEAD`.
        """
        pulumi.set(__self__, "interval_in_seconds", interval_in_seconds)
        pulumi.set(__self__, "protocol", protocol)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if request_type is not None:
            pulumi.set(__self__, "request_type", request_type)

    @property
    @pulumi.getter(name="intervalInSeconds")
    def interval_in_seconds(self) -> int:
        """
        Specifies the number of seconds between health probes. Possible values are between `5` and `31536000` seconds (inclusive).
        """
        return pulumi.get(self, "interval_in_seconds")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Specifies the protocol to use for health probe. Possible values are `Http` and `Https`.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Specifies the path relative to the origin that is used to determine the health of the origin. Defaults to `/`.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="requestType")
    def request_type(self) -> Optional[str]:
        """
        Specifies the type of health probe request that is made. Possible values are `GET` and `HEAD`. Defaults to `HEAD`.
        """
        return pulumi.get(self, "request_type")


@pulumi.output_type
class FrontdoorOriginGroupLoadBalancing(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalLatencyInMilliseconds":
            suggest = "additional_latency_in_milliseconds"
        elif key == "sampleSize":
            suggest = "sample_size"
        elif key == "successfulSamplesRequired":
            suggest = "successful_samples_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorOriginGroupLoadBalancing. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorOriginGroupLoadBalancing.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorOriginGroupLoadBalancing.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_latency_in_milliseconds: Optional[int] = None,
                 sample_size: Optional[int] = None,
                 successful_samples_required: Optional[int] = None):
        """
        :param int additional_latency_in_milliseconds: Specifies the additional latency in milliseconds for probes to fall into the lowest latency bucket. Possible values are between `0` and `1000` seconds (inclusive). Defaults to `50`.
        :param int sample_size: Specifies the number of samples to consider for load balancing decisions. Possible values are between `0` and `255` (inclusive). Defaults to `4`.
        :param int successful_samples_required: Specifies the number of samples within the sample period that must succeed. Possible values are between `0` and `255` (inclusive). Defaults to `3`.
        """
        if additional_latency_in_milliseconds is not None:
            pulumi.set(__self__, "additional_latency_in_milliseconds", additional_latency_in_milliseconds)
        if sample_size is not None:
            pulumi.set(__self__, "sample_size", sample_size)
        if successful_samples_required is not None:
            pulumi.set(__self__, "successful_samples_required", successful_samples_required)

    @property
    @pulumi.getter(name="additionalLatencyInMilliseconds")
    def additional_latency_in_milliseconds(self) -> Optional[int]:
        """
        Specifies the additional latency in milliseconds for probes to fall into the lowest latency bucket. Possible values are between `0` and `1000` seconds (inclusive). Defaults to `50`.
        """
        return pulumi.get(self, "additional_latency_in_milliseconds")

    @property
    @pulumi.getter(name="sampleSize")
    def sample_size(self) -> Optional[int]:
        """
        Specifies the number of samples to consider for load balancing decisions. Possible values are between `0` and `255` (inclusive). Defaults to `4`.
        """
        return pulumi.get(self, "sample_size")

    @property
    @pulumi.getter(name="successfulSamplesRequired")
    def successful_samples_required(self) -> Optional[int]:
        """
        Specifies the number of samples within the sample period that must succeed. Possible values are between `0` and `255` (inclusive). Defaults to `3`.
        """
        return pulumi.get(self, "successful_samples_required")


@pulumi.output_type
class FrontdoorOriginPrivateLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateLinkTargetId":
            suggest = "private_link_target_id"
        elif key == "requestMessage":
            suggest = "request_message"
        elif key == "targetType":
            suggest = "target_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorOriginPrivateLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorOriginPrivateLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorOriginPrivateLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 location: str,
                 private_link_target_id: str,
                 request_message: Optional[str] = None,
                 target_type: Optional[str] = None):
        """
        :param str location: Specifies the location where the Private Link resource should exist.
        :param str private_link_target_id: The ID of the Azure Resource to connect to via the Private Link.
        :param str request_message: Specifies the request message that will be submitted to the `private_link_target_id` when requesting the private link endpoint connection. Values must be between `1` and `140` characters in length. Defaults to `Access request for Front Door Private Link Origin`.
        :param str target_type: Specifies the type of target for this Private Link Endpoint. Possible values are `blob`, `blob_secondary`, `web` and `sites`.
        """
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "private_link_target_id", private_link_target_id)
        if request_message is not None:
            pulumi.set(__self__, "request_message", request_message)
        if target_type is not None:
            pulumi.set(__self__, "target_type", target_type)

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        Specifies the location where the Private Link resource should exist.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="privateLinkTargetId")
    def private_link_target_id(self) -> str:
        """
        The ID of the Azure Resource to connect to via the Private Link.
        """
        return pulumi.get(self, "private_link_target_id")

    @property
    @pulumi.getter(name="requestMessage")
    def request_message(self) -> Optional[str]:
        """
        Specifies the request message that will be submitted to the `private_link_target_id` when requesting the private link endpoint connection. Values must be between `1` and `140` characters in length. Defaults to `Access request for Front Door Private Link Origin`.
        """
        return pulumi.get(self, "request_message")

    @property
    @pulumi.getter(name="targetType")
    def target_type(self) -> Optional[str]:
        """
        Specifies the type of target for this Private Link Endpoint. Possible values are `blob`, `blob_secondary`, `web` and `sites`.
        """
        return pulumi.get(self, "target_type")


@pulumi.output_type
class FrontdoorRouteCache(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compressionEnabled":
            suggest = "compression_enabled"
        elif key == "contentTypesToCompresses":
            suggest = "content_types_to_compresses"
        elif key == "queryStringCachingBehavior":
            suggest = "query_string_caching_behavior"
        elif key == "queryStrings":
            suggest = "query_strings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorRouteCache. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorRouteCache.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorRouteCache.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compression_enabled: Optional[bool] = None,
                 content_types_to_compresses: Optional[Sequence[str]] = None,
                 query_string_caching_behavior: Optional[str] = None,
                 query_strings: Optional[Sequence[str]] = None):
        """
        :param bool compression_enabled: Is content compression enabled? Possible values are `true` or `false`. Defaults to `false`.
        :param Sequence[str] content_types_to_compresses: A list of one or more `Content types` (formerly known as `MIME types`) to compress. Possible values include `application/eot`, `application/font`, `application/font-sfnt`, `application/javascript`, `application/json`, `application/opentype`, `application/otf`, `application/pkcs7-mime`, `application/truetype`, `application/ttf`, `application/vnd.ms-fontobject`, `application/xhtml+xml`, `application/xml`, `application/xml+rss`, `application/x-font-opentype`, `application/x-font-truetype`, `application/x-font-ttf`, `application/x-httpd-cgi`, `application/x-mpegurl`, `application/x-opentype`, `application/x-otf`, `application/x-perl`, `application/x-ttf`, `application/x-javascript`, `font/eot`, `font/ttf`, `font/otf`, `font/opentype`, `image/svg+xml`, `text/css`, `text/csv`, `text/html`, `text/javascript`, `text/js`, `text/plain`, `text/richtext`, `text/tab-separated-values`, `text/xml`, `text/x-script`, `text/x-component` or `text/x-java-source`.
        :param str query_string_caching_behavior: Defines how the Front Door Route will cache requests that include query strings. Possible values include `IgnoreQueryString`, `IgnoreSpecifiedQueryStrings`, `IncludeSpecifiedQueryStrings` or `UseQueryString`. Defaults it `IgnoreQueryString`.
        :param Sequence[str] query_strings: Query strings to include or ignore.
        """
        if compression_enabled is not None:
            pulumi.set(__self__, "compression_enabled", compression_enabled)
        if content_types_to_compresses is not None:
            pulumi.set(__self__, "content_types_to_compresses", content_types_to_compresses)
        if query_string_caching_behavior is not None:
            pulumi.set(__self__, "query_string_caching_behavior", query_string_caching_behavior)
        if query_strings is not None:
            pulumi.set(__self__, "query_strings", query_strings)

    @property
    @pulumi.getter(name="compressionEnabled")
    def compression_enabled(self) -> Optional[bool]:
        """
        Is content compression enabled? Possible values are `true` or `false`. Defaults to `false`.
        """
        return pulumi.get(self, "compression_enabled")

    @property
    @pulumi.getter(name="contentTypesToCompresses")
    def content_types_to_compresses(self) -> Optional[Sequence[str]]:
        """
        A list of one or more `Content types` (formerly known as `MIME types`) to compress. Possible values include `application/eot`, `application/font`, `application/font-sfnt`, `application/javascript`, `application/json`, `application/opentype`, `application/otf`, `application/pkcs7-mime`, `application/truetype`, `application/ttf`, `application/vnd.ms-fontobject`, `application/xhtml+xml`, `application/xml`, `application/xml+rss`, `application/x-font-opentype`, `application/x-font-truetype`, `application/x-font-ttf`, `application/x-httpd-cgi`, `application/x-mpegurl`, `application/x-opentype`, `application/x-otf`, `application/x-perl`, `application/x-ttf`, `application/x-javascript`, `font/eot`, `font/ttf`, `font/otf`, `font/opentype`, `image/svg+xml`, `text/css`, `text/csv`, `text/html`, `text/javascript`, `text/js`, `text/plain`, `text/richtext`, `text/tab-separated-values`, `text/xml`, `text/x-script`, `text/x-component` or `text/x-java-source`.
        """
        return pulumi.get(self, "content_types_to_compresses")

    @property
    @pulumi.getter(name="queryStringCachingBehavior")
    def query_string_caching_behavior(self) -> Optional[str]:
        """
        Defines how the Front Door Route will cache requests that include query strings. Possible values include `IgnoreQueryString`, `IgnoreSpecifiedQueryStrings`, `IncludeSpecifiedQueryStrings` or `UseQueryString`. Defaults it `IgnoreQueryString`.
        """
        return pulumi.get(self, "query_string_caching_behavior")

    @property
    @pulumi.getter(name="queryStrings")
    def query_strings(self) -> Optional[Sequence[str]]:
        """
        Query strings to include or ignore.
        """
        return pulumi.get(self, "query_strings")


@pulumi.output_type
class FrontdoorRuleActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestHeaderActions":
            suggest = "request_header_actions"
        elif key == "responseHeaderActions":
            suggest = "response_header_actions"
        elif key == "routeConfigurationOverrideAction":
            suggest = "route_configuration_override_action"
        elif key == "urlRedirectAction":
            suggest = "url_redirect_action"
        elif key == "urlRewriteAction":
            suggest = "url_rewrite_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorRuleActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorRuleActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorRuleActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_header_actions: Optional[Sequence['outputs.FrontdoorRuleActionsRequestHeaderAction']] = None,
                 response_header_actions: Optional[Sequence['outputs.FrontdoorRuleActionsResponseHeaderAction']] = None,
                 route_configuration_override_action: Optional['outputs.FrontdoorRuleActionsRouteConfigurationOverrideAction'] = None,
                 url_redirect_action: Optional['outputs.FrontdoorRuleActionsUrlRedirectAction'] = None,
                 url_rewrite_action: Optional['outputs.FrontdoorRuleActionsUrlRewriteAction'] = None):
        """
        :param Sequence['FrontdoorRuleActionsRequestHeaderActionArgs'] request_header_actions: A `request_header_action` block as defined below.
        :param Sequence['FrontdoorRuleActionsResponseHeaderActionArgs'] response_header_actions: A `response_header_action` block as defined below.
        :param 'FrontdoorRuleActionsRouteConfigurationOverrideActionArgs' route_configuration_override_action: A `route_configuration_override_action` block as defined below.
        :param 'FrontdoorRuleActionsUrlRedirectActionArgs' url_redirect_action: A `url_redirect_action` block as defined below. You may **not** have a `url_redirect_action` **and** a `url_rewrite_action` defined in the same `actions` block.
        :param 'FrontdoorRuleActionsUrlRewriteActionArgs' url_rewrite_action: A `url_rewrite_action` block as defined below. You may **not** have a `url_rewrite_action` **and** a `url_redirect_action` defined in the same `actions` block.
        """
        if request_header_actions is not None:
            pulumi.set(__self__, "request_header_actions", request_header_actions)
        if response_header_actions is not None:
            pulumi.set(__self__, "response_header_actions", response_header_actions)
        if route_configuration_override_action is not None:
            pulumi.set(__self__, "route_configuration_override_action", route_configuration_override_action)
        if url_redirect_action is not None:
            pulumi.set(__self__, "url_redirect_action", url_redirect_action)
        if url_rewrite_action is not None:
            pulumi.set(__self__, "url_rewrite_action", url_rewrite_action)

    @property
    @pulumi.getter(name="requestHeaderActions")
    def request_header_actions(self) -> Optional[Sequence['outputs.FrontdoorRuleActionsRequestHeaderAction']]:
        """
        A `request_header_action` block as defined below.
        """
        return pulumi.get(self, "request_header_actions")

    @property
    @pulumi.getter(name="responseHeaderActions")
    def response_header_actions(self) -> Optional[Sequence['outputs.FrontdoorRuleActionsResponseHeaderAction']]:
        """
        A `response_header_action` block as defined below.
        """
        return pulumi.get(self, "response_header_actions")

    @property
    @pulumi.getter(name="routeConfigurationOverrideAction")
    def route_configuration_override_action(self) -> Optional['outputs.FrontdoorRuleActionsRouteConfigurationOverrideAction']:
        """
        A `route_configuration_override_action` block as defined below.
        """
        return pulumi.get(self, "route_configuration_override_action")

    @property
    @pulumi.getter(name="urlRedirectAction")
    def url_redirect_action(self) -> Optional['outputs.FrontdoorRuleActionsUrlRedirectAction']:
        """
        A `url_redirect_action` block as defined below. You may **not** have a `url_redirect_action` **and** a `url_rewrite_action` defined in the same `actions` block.
        """
        return pulumi.get(self, "url_redirect_action")

    @property
    @pulumi.getter(name="urlRewriteAction")
    def url_rewrite_action(self) -> Optional['outputs.FrontdoorRuleActionsUrlRewriteAction']:
        """
        A `url_rewrite_action` block as defined below. You may **not** have a `url_rewrite_action` **and** a `url_redirect_action` defined in the same `actions` block.
        """
        return pulumi.get(self, "url_rewrite_action")


@pulumi.output_type
class FrontdoorRuleActionsRequestHeaderAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerAction":
            suggest = "header_action"
        elif key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorRuleActionsRequestHeaderAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorRuleActionsRequestHeaderAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorRuleActionsRequestHeaderAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_action: str,
                 header_name: str,
                 value: Optional[str] = None):
        """
        :param str header_action: The action to be taken on the specified `header_name`. Possible values include `Append`, `Overwrite` or `Delete`.
        :param str header_name: The name of the header to modify.
        :param str value: The value to append or overwrite.
        """
        pulumi.set(__self__, "header_action", header_action)
        pulumi.set(__self__, "header_name", header_name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="headerAction")
    def header_action(self) -> str:
        """
        The action to be taken on the specified `header_name`. Possible values include `Append`, `Overwrite` or `Delete`.
        """
        return pulumi.get(self, "header_action")

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        The name of the header to modify.
        """
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to append or overwrite.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class FrontdoorRuleActionsResponseHeaderAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerAction":
            suggest = "header_action"
        elif key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorRuleActionsResponseHeaderAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorRuleActionsResponseHeaderAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorRuleActionsResponseHeaderAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_action: str,
                 header_name: str,
                 value: Optional[str] = None):
        """
        :param str header_action: The action to be taken on the specified `header_name`. Possible values include `Append`, `Overwrite` or `Delete`.
        :param str header_name: The name of the header to modify.
        :param str value: The value to append or overwrite.
        """
        pulumi.set(__self__, "header_action", header_action)
        pulumi.set(__self__, "header_name", header_name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="headerAction")
    def header_action(self) -> str:
        """
        The action to be taken on the specified `header_name`. Possible values include `Append`, `Overwrite` or `Delete`.
        """
        return pulumi.get(self, "header_action")

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        The name of the header to modify.
        """
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to append or overwrite.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class FrontdoorRuleActionsRouteConfigurationOverrideAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cacheBehavior":
            suggest = "cache_behavior"
        elif key == "cacheDuration":
            suggest = "cache_duration"
        elif key == "cdnFrontdoorOriginGroupId":
            suggest = "cdn_frontdoor_origin_group_id"
        elif key == "compressionEnabled":
            suggest = "compression_enabled"
        elif key == "forwardingProtocol":
            suggest = "forwarding_protocol"
        elif key == "queryStringCachingBehavior":
            suggest = "query_string_caching_behavior"
        elif key == "queryStringParameters":
            suggest = "query_string_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorRuleActionsRouteConfigurationOverrideAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorRuleActionsRouteConfigurationOverrideAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorRuleActionsRouteConfigurationOverrideAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cache_behavior: Optional[str] = None,
                 cache_duration: Optional[str] = None,
                 cdn_frontdoor_origin_group_id: Optional[str] = None,
                 compression_enabled: Optional[bool] = None,
                 forwarding_protocol: Optional[str] = None,
                 query_string_caching_behavior: Optional[str] = None,
                 query_string_parameters: Optional[Sequence[str]] = None):
        """
        :param str cache_behavior: `HonorOrigin` the Front Door will always honor origin response header directive. If the origin directive is missing, Front Door will cache contents anywhere from `1` to `3` days. `OverrideAlways` the TTL value returned from your Front Door Origin is overwritten with the value specified in the action. This behavior will only be applied if the response is cacheable. `OverrideIfOriginMissing` if no TTL value gets returned from your Front Door Origin, the rule sets the TTL to the value specified in the action. This behavior will only be applied if the response is cacheable. `Disabled` the Front Door will not cache the response contents, irrespective of Front Door Origin response directives. Possible values include `HonorOrigin`, `OverrideAlways`, `OverrideIfOriginMissing` or `Disabled`. Defaults to `HonorOrigin`.
        :param str cache_duration: When Cache behavior is set to `Override` or `SetIfMissing`, this field specifies the cache duration to use. The maximum duration is 366 days specified in the `d.HH:MM:SS` format(e.g. `365.23:59:59`). If the desired maximum cache duration is less than 1 day then the maximum cache duration should be specified in the `HH:MM:SS` format(e.g. `23:59:59`). Defaults to `1.12:00:00`.
        :param str cdn_frontdoor_origin_group_id: The Front Door Origin Group resource ID that the request should be routed to. This overrides the configuration specified in the Front Door Endpoint route.
        :param bool compression_enabled: Should the Front Door dynamically compress the content? Possible values include `true` or `false`. Defaults to `false`.
        :param str forwarding_protocol: The forwarding protocol the request will be redirected as. This overrides the configuration specified in the route to be associated with. Possible values include `MatchRequest`, `HttpOnly` or `HttpsOnly`. Defaults to `MatchRequest`. Possible values include `HttpOnly`, `HttpsOnly` or `MatchRequest`. Defaults to `MatchRequest`.
        :param str query_string_caching_behavior: `IncludeSpecifiedQueryStrings` query strings specified in the `query_string_parameters` field get included when the cache key gets generated. `UseQueryString` cache every unique URL, each unique URL will have its own cache key. `IgnoreSpecifiedQueryStrings` query strings specified in the `query_string_parameters` field get excluded when the cache key gets generated. `IgnoreQueryString` query strings aren't considered when the cache key gets generated. Possible values include `IgnoreQueryString`, `UseQueryString`, `IgnoreSpecifiedQueryStrings` or `IncludeSpecifiedQueryStrings`. Defaults to `IgnoreQueryString`.
        :param Sequence[str] query_string_parameters: A list of query string parameter names.
        """
        if cache_behavior is not None:
            pulumi.set(__self__, "cache_behavior", cache_behavior)
        if cache_duration is not None:
            pulumi.set(__self__, "cache_duration", cache_duration)
        if cdn_frontdoor_origin_group_id is not None:
            pulumi.set(__self__, "cdn_frontdoor_origin_group_id", cdn_frontdoor_origin_group_id)
        if compression_enabled is not None:
            pulumi.set(__self__, "compression_enabled", compression_enabled)
        if forwarding_protocol is not None:
            pulumi.set(__self__, "forwarding_protocol", forwarding_protocol)
        if query_string_caching_behavior is not None:
            pulumi.set(__self__, "query_string_caching_behavior", query_string_caching_behavior)
        if query_string_parameters is not None:
            pulumi.set(__self__, "query_string_parameters", query_string_parameters)

    @property
    @pulumi.getter(name="cacheBehavior")
    def cache_behavior(self) -> Optional[str]:
        """
        `HonorOrigin` the Front Door will always honor origin response header directive. If the origin directive is missing, Front Door will cache contents anywhere from `1` to `3` days. `OverrideAlways` the TTL value returned from your Front Door Origin is overwritten with the value specified in the action. This behavior will only be applied if the response is cacheable. `OverrideIfOriginMissing` if no TTL value gets returned from your Front Door Origin, the rule sets the TTL to the value specified in the action. This behavior will only be applied if the response is cacheable. `Disabled` the Front Door will not cache the response contents, irrespective of Front Door Origin response directives. Possible values include `HonorOrigin`, `OverrideAlways`, `OverrideIfOriginMissing` or `Disabled`. Defaults to `HonorOrigin`.
        """
        return pulumi.get(self, "cache_behavior")

    @property
    @pulumi.getter(name="cacheDuration")
    def cache_duration(self) -> Optional[str]:
        """
        When Cache behavior is set to `Override` or `SetIfMissing`, this field specifies the cache duration to use. The maximum duration is 366 days specified in the `d.HH:MM:SS` format(e.g. `365.23:59:59`). If the desired maximum cache duration is less than 1 day then the maximum cache duration should be specified in the `HH:MM:SS` format(e.g. `23:59:59`). Defaults to `1.12:00:00`.
        """
        return pulumi.get(self, "cache_duration")

    @property
    @pulumi.getter(name="cdnFrontdoorOriginGroupId")
    def cdn_frontdoor_origin_group_id(self) -> Optional[str]:
        """
        The Front Door Origin Group resource ID that the request should be routed to. This overrides the configuration specified in the Front Door Endpoint route.
        """
        return pulumi.get(self, "cdn_frontdoor_origin_group_id")

    @property
    @pulumi.getter(name="compressionEnabled")
    def compression_enabled(self) -> Optional[bool]:
        """
        Should the Front Door dynamically compress the content? Possible values include `true` or `false`. Defaults to `false`.
        """
        return pulumi.get(self, "compression_enabled")

    @property
    @pulumi.getter(name="forwardingProtocol")
    def forwarding_protocol(self) -> Optional[str]:
        """
        The forwarding protocol the request will be redirected as. This overrides the configuration specified in the route to be associated with. Possible values include `MatchRequest`, `HttpOnly` or `HttpsOnly`. Defaults to `MatchRequest`. Possible values include `HttpOnly`, `HttpsOnly` or `MatchRequest`. Defaults to `MatchRequest`.
        """
        return pulumi.get(self, "forwarding_protocol")

    @property
    @pulumi.getter(name="queryStringCachingBehavior")
    def query_string_caching_behavior(self) -> Optional[str]:
        """
        `IncludeSpecifiedQueryStrings` query strings specified in the `query_string_parameters` field get included when the cache key gets generated. `UseQueryString` cache every unique URL, each unique URL will have its own cache key. `IgnoreSpecifiedQueryStrings` query strings specified in the `query_string_parameters` field get excluded when the cache key gets generated. `IgnoreQueryString` query strings aren't considered when the cache key gets generated. Possible values include `IgnoreQueryString`, `UseQueryString`, `IgnoreSpecifiedQueryStrings` or `IncludeSpecifiedQueryStrings`. Defaults to `IgnoreQueryString`.
        """
        return pulumi.get(self, "query_string_caching_behavior")

    @property
    @pulumi.getter(name="queryStringParameters")
    def query_string_parameters(self) -> Optional[Sequence[str]]:
        """
        A list of query string parameter names.
        """
        return pulumi.get(self, "query_string_parameters")


@pulumi.output_type
class FrontdoorRuleActionsUrlRedirectAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationHostname":
            suggest = "destination_hostname"
        elif key == "redirectType":
            suggest = "redirect_type"
        elif key == "destinationFragment":
            suggest = "destination_fragment"
        elif key == "destinationPath":
            suggest = "destination_path"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "redirectProtocol":
            suggest = "redirect_protocol"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorRuleActionsUrlRedirectAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorRuleActionsUrlRedirectAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorRuleActionsUrlRedirectAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_hostname: str,
                 redirect_type: str,
                 destination_fragment: Optional[str] = None,
                 destination_path: Optional[str] = None,
                 query_string: Optional[str] = None,
                 redirect_protocol: Optional[str] = None):
        """
        :param str destination_hostname: The host name you want the request to be redirected to. The value must be a string between `0` and `2048` characters in length, leave blank to preserve the incoming host.
        :param str redirect_type: The response type to return to the requestor. Possible values include `Moved`, `Found` , `TemporaryRedirect` or `PermanentRedirect`.
        :param str destination_fragment: The fragment to use in the redirect. The value must be a string between `0` and `1024` characters in length, leave blank to preserve the incoming fragment. Defaults to an empty string.
        :param str destination_path: The path to use in the redirect. The value must be a string and include the leading `/`, leave blank to preserve the incoming path. Defaults to an empty string.
        :param str query_string: The query string used in the redirect URL. The value must be in the &lt;key>=&lt;value> or &lt;key>={`action_server_variable`} format and must not include the leading `?`, leave blank to preserve the incoming query string. Maximum allowed length for this field is `2048` characters. Defaults to an empty string.
        :param str redirect_protocol: The protocol the request will be redirected as. Possible values include `MatchRequest`, `Http` or `Https`. Defaults to `MatchRequest`.
        """
        pulumi.set(__self__, "destination_hostname", destination_hostname)
        pulumi.set(__self__, "redirect_type", redirect_type)
        if destination_fragment is not None:
            pulumi.set(__self__, "destination_fragment", destination_fragment)
        if destination_path is not None:
            pulumi.set(__self__, "destination_path", destination_path)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if redirect_protocol is not None:
            pulumi.set(__self__, "redirect_protocol", redirect_protocol)

    @property
    @pulumi.getter(name="destinationHostname")
    def destination_hostname(self) -> str:
        """
        The host name you want the request to be redirected to. The value must be a string between `0` and `2048` characters in length, leave blank to preserve the incoming host.
        """
        return pulumi.get(self, "destination_hostname")

    @property
    @pulumi.getter(name="redirectType")
    def redirect_type(self) -> str:
        """
        The response type to return to the requestor. Possible values include `Moved`, `Found` , `TemporaryRedirect` or `PermanentRedirect`.
        """
        return pulumi.get(self, "redirect_type")

    @property
    @pulumi.getter(name="destinationFragment")
    def destination_fragment(self) -> Optional[str]:
        """
        The fragment to use in the redirect. The value must be a string between `0` and `1024` characters in length, leave blank to preserve the incoming fragment. Defaults to an empty string.
        """
        return pulumi.get(self, "destination_fragment")

    @property
    @pulumi.getter(name="destinationPath")
    def destination_path(self) -> Optional[str]:
        """
        The path to use in the redirect. The value must be a string and include the leading `/`, leave blank to preserve the incoming path. Defaults to an empty string.
        """
        return pulumi.get(self, "destination_path")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[str]:
        """
        The query string used in the redirect URL. The value must be in the &lt;key>=&lt;value> or &lt;key>={`action_server_variable`} format and must not include the leading `?`, leave blank to preserve the incoming query string. Maximum allowed length for this field is `2048` characters. Defaults to an empty string.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="redirectProtocol")
    def redirect_protocol(self) -> Optional[str]:
        """
        The protocol the request will be redirected as. Possible values include `MatchRequest`, `Http` or `Https`. Defaults to `MatchRequest`.
        """
        return pulumi.get(self, "redirect_protocol")


@pulumi.output_type
class FrontdoorRuleActionsUrlRewriteAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourcePattern":
            suggest = "source_pattern"
        elif key == "preserveUnmatchedPath":
            suggest = "preserve_unmatched_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorRuleActionsUrlRewriteAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorRuleActionsUrlRewriteAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorRuleActionsUrlRewriteAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: str,
                 source_pattern: str,
                 preserve_unmatched_path: Optional[bool] = None):
        """
        :param str destination: The destination path to use in the rewrite. The destination path overwrites the source pattern.
        :param str source_pattern: The source pattern in the URL path to replace. This uses prefix-based matching. For example, to match all URL paths use a forward slash `"/"` as the source pattern value.
        :param bool preserve_unmatched_path: Append the remaining path after the source pattern to the new destination path? Possible values `true` or `false`. Defaults to `false`.
        """
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "source_pattern", source_pattern)
        if preserve_unmatched_path is not None:
            pulumi.set(__self__, "preserve_unmatched_path", preserve_unmatched_path)

    @property
    @pulumi.getter
    def destination(self) -> str:
        """
        The destination path to use in the rewrite. The destination path overwrites the source pattern.
        """
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter(name="sourcePattern")
    def source_pattern(self) -> str:
        """
        The source pattern in the URL path to replace. This uses prefix-based matching. For example, to match all URL paths use a forward slash `"/"` as the source pattern value.
        """
        return pulumi.get(self, "source_pattern")

    @property
    @pulumi.getter(name="preserveUnmatchedPath")
    def preserve_unmatched_path(self) -> Optional[bool]:
        """
        Append the remaining path after the source pattern to the new destination path? Possible values `true` or `false`. Defaults to `false`.
        """
        return pulumi.get(self, "preserve_unmatched_path")


@pulumi.output_type
class FrontdoorRuleConditions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientPortConditions":
            suggest = "client_port_conditions"
        elif key == "cookiesConditions":
            suggest = "cookies_conditions"
        elif key == "hostNameConditions":
            suggest = "host_name_conditions"
        elif key == "httpVersionConditions":
            suggest = "http_version_conditions"
        elif key == "isDeviceConditions":
            suggest = "is_device_conditions"
        elif key == "postArgsConditions":
            suggest = "post_args_conditions"
        elif key == "queryStringConditions":
            suggest = "query_string_conditions"
        elif key == "remoteAddressConditions":
            suggest = "remote_address_conditions"
        elif key == "requestBodyConditions":
            suggest = "request_body_conditions"
        elif key == "requestHeaderConditions":
            suggest = "request_header_conditions"
        elif key == "requestMethodConditions":
            suggest = "request_method_conditions"
        elif key == "requestSchemeConditions":
            suggest = "request_scheme_conditions"
        elif key == "requestUriConditions":
            suggest = "request_uri_conditions"
        elif key == "serverPortConditions":
            suggest = "server_port_conditions"
        elif key == "socketAddressConditions":
            suggest = "socket_address_conditions"
        elif key == "sslProtocolConditions":
            suggest = "ssl_protocol_conditions"
        elif key == "urlFileExtensionConditions":
            suggest = "url_file_extension_conditions"
        elif key == "urlFilenameConditions":
            suggest = "url_filename_conditions"
        elif key == "urlPathConditions":
            suggest = "url_path_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorRuleConditions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorRuleConditions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorRuleConditions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_port_conditions: Optional[Sequence['outputs.FrontdoorRuleConditionsClientPortCondition']] = None,
                 cookies_conditions: Optional[Sequence['outputs.FrontdoorRuleConditionsCookiesCondition']] = None,
                 host_name_conditions: Optional[Sequence['outputs.FrontdoorRuleConditionsHostNameCondition']] = None,
                 http_version_conditions: Optional[Sequence['outputs.FrontdoorRuleConditionsHttpVersionCondition']] = None,
                 is_device_conditions: Optional[Sequence['outputs.FrontdoorRuleConditionsIsDeviceCondition']] = None,
                 post_args_conditions: Optional[Sequence['outputs.FrontdoorRuleConditionsPostArgsCondition']] = None,
                 query_string_conditions: Optional[Sequence['outputs.FrontdoorRuleConditionsQueryStringCondition']] = None,
                 remote_address_conditions: Optional[Sequence['outputs.FrontdoorRuleConditionsRemoteAddressCondition']] = None,
                 request_body_conditions: Optional[Sequence['outputs.FrontdoorRuleConditionsRequestBodyCondition']] = None,
                 request_header_conditions: Optional[Sequence['outputs.FrontdoorRuleConditionsRequestHeaderCondition']] = None,
                 request_method_conditions: Optional[Sequence['outputs.FrontdoorRuleConditionsRequestMethodCondition']] = None,
                 request_scheme_conditions: Optional[Sequence['outputs.FrontdoorRuleConditionsRequestSchemeCondition']] = None,
                 request_uri_conditions: Optional[Sequence['outputs.FrontdoorRuleConditionsRequestUriCondition']] = None,
                 server_port_conditions: Optional[Sequence['outputs.FrontdoorRuleConditionsServerPortCondition']] = None,
                 socket_address_conditions: Optional[Sequence['outputs.FrontdoorRuleConditionsSocketAddressCondition']] = None,
                 ssl_protocol_conditions: Optional[Sequence['outputs.FrontdoorRuleConditionsSslProtocolCondition']] = None,
                 url_file_extension_conditions: Optional[Sequence['outputs.FrontdoorRuleConditionsUrlFileExtensionCondition']] = None,
                 url_filename_conditions: Optional[Sequence['outputs.FrontdoorRuleConditionsUrlFilenameCondition']] = None,
                 url_path_conditions: Optional[Sequence['outputs.FrontdoorRuleConditionsUrlPathCondition']] = None):
        """
        :param Sequence['FrontdoorRuleConditionsClientPortConditionArgs'] client_port_conditions: A `client_port_condition` block as defined below.
        :param Sequence['FrontdoorRuleConditionsCookiesConditionArgs'] cookies_conditions: A `cookies_condition` block as defined below.
        :param Sequence['FrontdoorRuleConditionsHostNameConditionArgs'] host_name_conditions: A `host_name_condition` block as defined below.
        :param Sequence['FrontdoorRuleConditionsHttpVersionConditionArgs'] http_version_conditions: A `http_version_condition` block as defined below.
        :param Sequence['FrontdoorRuleConditionsIsDeviceConditionArgs'] is_device_conditions: A `is_device_condition` block as defined below.
        :param Sequence['FrontdoorRuleConditionsPostArgsConditionArgs'] post_args_conditions: A `post_args_condition` block as defined below.
        :param Sequence['FrontdoorRuleConditionsQueryStringConditionArgs'] query_string_conditions: A `query_string_condition` block as defined below.
        :param Sequence['FrontdoorRuleConditionsRemoteAddressConditionArgs'] remote_address_conditions: A `remote_address_condition` block as defined below.
        :param Sequence['FrontdoorRuleConditionsRequestBodyConditionArgs'] request_body_conditions: A `request_body_condition` block as defined below.
        :param Sequence['FrontdoorRuleConditionsRequestHeaderConditionArgs'] request_header_conditions: A `request_header_condition` block as defined below.
        :param Sequence['FrontdoorRuleConditionsRequestMethodConditionArgs'] request_method_conditions: A `request_method_condition` block as defined below.
        :param Sequence['FrontdoorRuleConditionsRequestSchemeConditionArgs'] request_scheme_conditions: A `request_scheme_condition` block as defined below.
        :param Sequence['FrontdoorRuleConditionsRequestUriConditionArgs'] request_uri_conditions: A `request_uri_condition` block as defined below.
        :param Sequence['FrontdoorRuleConditionsServerPortConditionArgs'] server_port_conditions: A `server_port_condition` block as defined below.
        :param Sequence['FrontdoorRuleConditionsSocketAddressConditionArgs'] socket_address_conditions: A `socket_address_condition` block as defined below.
        :param Sequence['FrontdoorRuleConditionsSslProtocolConditionArgs'] ssl_protocol_conditions: A `ssl_protocol_condition` block as defined below.
        :param Sequence['FrontdoorRuleConditionsUrlFileExtensionConditionArgs'] url_file_extension_conditions: A `url_file_extension_condition` block as defined below.
        :param Sequence['FrontdoorRuleConditionsUrlFilenameConditionArgs'] url_filename_conditions: A `url_filename_condition` block as defined below.
        :param Sequence['FrontdoorRuleConditionsUrlPathConditionArgs'] url_path_conditions: A `url_path_condition` block as defined below.
        """
        if client_port_conditions is not None:
            pulumi.set(__self__, "client_port_conditions", client_port_conditions)
        if cookies_conditions is not None:
            pulumi.set(__self__, "cookies_conditions", cookies_conditions)
        if host_name_conditions is not None:
            pulumi.set(__self__, "host_name_conditions", host_name_conditions)
        if http_version_conditions is not None:
            pulumi.set(__self__, "http_version_conditions", http_version_conditions)
        if is_device_conditions is not None:
            pulumi.set(__self__, "is_device_conditions", is_device_conditions)
        if post_args_conditions is not None:
            pulumi.set(__self__, "post_args_conditions", post_args_conditions)
        if query_string_conditions is not None:
            pulumi.set(__self__, "query_string_conditions", query_string_conditions)
        if remote_address_conditions is not None:
            pulumi.set(__self__, "remote_address_conditions", remote_address_conditions)
        if request_body_conditions is not None:
            pulumi.set(__self__, "request_body_conditions", request_body_conditions)
        if request_header_conditions is not None:
            pulumi.set(__self__, "request_header_conditions", request_header_conditions)
        if request_method_conditions is not None:
            pulumi.set(__self__, "request_method_conditions", request_method_conditions)
        if request_scheme_conditions is not None:
            pulumi.set(__self__, "request_scheme_conditions", request_scheme_conditions)
        if request_uri_conditions is not None:
            pulumi.set(__self__, "request_uri_conditions", request_uri_conditions)
        if server_port_conditions is not None:
            pulumi.set(__self__, "server_port_conditions", server_port_conditions)
        if socket_address_conditions is not None:
            pulumi.set(__self__, "socket_address_conditions", socket_address_conditions)
        if ssl_protocol_conditions is not None:
            pulumi.set(__self__, "ssl_protocol_conditions", ssl_protocol_conditions)
        if url_file_extension_conditions is not None:
            pulumi.set(__self__, "url_file_extension_conditions", url_file_extension_conditions)
        if url_filename_conditions is not None:
            pulumi.set(__self__, "url_filename_conditions", url_filename_conditions)
        if url_path_conditions is not None:
            pulumi.set(__self__, "url_path_conditions", url_path_conditions)

    @property
    @pulumi.getter(name="clientPortConditions")
    def client_port_conditions(self) -> Optional[Sequence['outputs.FrontdoorRuleConditionsClientPortCondition']]:
        """
        A `client_port_condition` block as defined below.
        """
        return pulumi.get(self, "client_port_conditions")

    @property
    @pulumi.getter(name="cookiesConditions")
    def cookies_conditions(self) -> Optional[Sequence['outputs.FrontdoorRuleConditionsCookiesCondition']]:
        """
        A `cookies_condition` block as defined below.
        """
        return pulumi.get(self, "cookies_conditions")

    @property
    @pulumi.getter(name="hostNameConditions")
    def host_name_conditions(self) -> Optional[Sequence['outputs.FrontdoorRuleConditionsHostNameCondition']]:
        """
        A `host_name_condition` block as defined below.
        """
        return pulumi.get(self, "host_name_conditions")

    @property
    @pulumi.getter(name="httpVersionConditions")
    def http_version_conditions(self) -> Optional[Sequence['outputs.FrontdoorRuleConditionsHttpVersionCondition']]:
        """
        A `http_version_condition` block as defined below.
        """
        return pulumi.get(self, "http_version_conditions")

    @property
    @pulumi.getter(name="isDeviceConditions")
    def is_device_conditions(self) -> Optional[Sequence['outputs.FrontdoorRuleConditionsIsDeviceCondition']]:
        """
        A `is_device_condition` block as defined below.
        """
        return pulumi.get(self, "is_device_conditions")

    @property
    @pulumi.getter(name="postArgsConditions")
    def post_args_conditions(self) -> Optional[Sequence['outputs.FrontdoorRuleConditionsPostArgsCondition']]:
        """
        A `post_args_condition` block as defined below.
        """
        return pulumi.get(self, "post_args_conditions")

    @property
    @pulumi.getter(name="queryStringConditions")
    def query_string_conditions(self) -> Optional[Sequence['outputs.FrontdoorRuleConditionsQueryStringCondition']]:
        """
        A `query_string_condition` block as defined below.
        """
        return pulumi.get(self, "query_string_conditions")

    @property
    @pulumi.getter(name="remoteAddressConditions")
    def remote_address_conditions(self) -> Optional[Sequence['outputs.FrontdoorRuleConditionsRemoteAddressCondition']]:
        """
        A `remote_address_condition` block as defined below.
        """
        return pulumi.get(self, "remote_address_conditions")

    @property
    @pulumi.getter(name="requestBodyConditions")
    def request_body_conditions(self) -> Optional[Sequence['outputs.FrontdoorRuleConditionsRequestBodyCondition']]:
        """
        A `request_body_condition` block as defined below.
        """
        return pulumi.get(self, "request_body_conditions")

    @property
    @pulumi.getter(name="requestHeaderConditions")
    def request_header_conditions(self) -> Optional[Sequence['outputs.FrontdoorRuleConditionsRequestHeaderCondition']]:
        """
        A `request_header_condition` block as defined below.
        """
        return pulumi.get(self, "request_header_conditions")

    @property
    @pulumi.getter(name="requestMethodConditions")
    def request_method_conditions(self) -> Optional[Sequence['outputs.FrontdoorRuleConditionsRequestMethodCondition']]:
        """
        A `request_method_condition` block as defined below.
        """
        return pulumi.get(self, "request_method_conditions")

    @property
    @pulumi.getter(name="requestSchemeConditions")
    def request_scheme_conditions(self) -> Optional[Sequence['outputs.FrontdoorRuleConditionsRequestSchemeCondition']]:
        """
        A `request_scheme_condition` block as defined below.
        """
        return pulumi.get(self, "request_scheme_conditions")

    @property
    @pulumi.getter(name="requestUriConditions")
    def request_uri_conditions(self) -> Optional[Sequence['outputs.FrontdoorRuleConditionsRequestUriCondition']]:
        """
        A `request_uri_condition` block as defined below.
        """
        return pulumi.get(self, "request_uri_conditions")

    @property
    @pulumi.getter(name="serverPortConditions")
    def server_port_conditions(self) -> Optional[Sequence['outputs.FrontdoorRuleConditionsServerPortCondition']]:
        """
        A `server_port_condition` block as defined below.
        """
        return pulumi.get(self, "server_port_conditions")

    @property
    @pulumi.getter(name="socketAddressConditions")
    def socket_address_conditions(self) -> Optional[Sequence['outputs.FrontdoorRuleConditionsSocketAddressCondition']]:
        """
        A `socket_address_condition` block as defined below.
        """
        return pulumi.get(self, "socket_address_conditions")

    @property
    @pulumi.getter(name="sslProtocolConditions")
    def ssl_protocol_conditions(self) -> Optional[Sequence['outputs.FrontdoorRuleConditionsSslProtocolCondition']]:
        """
        A `ssl_protocol_condition` block as defined below.
        """
        return pulumi.get(self, "ssl_protocol_conditions")

    @property
    @pulumi.getter(name="urlFileExtensionConditions")
    def url_file_extension_conditions(self) -> Optional[Sequence['outputs.FrontdoorRuleConditionsUrlFileExtensionCondition']]:
        """
        A `url_file_extension_condition` block as defined below.
        """
        return pulumi.get(self, "url_file_extension_conditions")

    @property
    @pulumi.getter(name="urlFilenameConditions")
    def url_filename_conditions(self) -> Optional[Sequence['outputs.FrontdoorRuleConditionsUrlFilenameCondition']]:
        """
        A `url_filename_condition` block as defined below.
        """
        return pulumi.get(self, "url_filename_conditions")

    @property
    @pulumi.getter(name="urlPathConditions")
    def url_path_conditions(self) -> Optional[Sequence['outputs.FrontdoorRuleConditionsUrlPathCondition']]:
        """
        A `url_path_condition` block as defined below.
        """
        return pulumi.get(self, "url_path_conditions")


@pulumi.output_type
class FrontdoorRuleConditionsClientPortCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorRuleConditionsClientPortCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorRuleConditionsClientPortCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorRuleConditionsClientPortCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None):
        """
        :param str operator: A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        :param Sequence[str] match_values: One or more integer values(e.g. "1") representing the value of the client port to match. If multiple values are specified, they're evaluated using `OR` logic.
        :param bool negate_condition: If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        pulumi.set(__self__, "operator", operator)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        One or more integer values(e.g. "1") representing the value of the client port to match. If multiple values are specified, they're evaluated using `OR` logic.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "negate_condition")


@pulumi.output_type
class FrontdoorRuleConditionsCookiesCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cookieName":
            suggest = "cookie_name"
        elif key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorRuleConditionsCookiesCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorRuleConditionsCookiesCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorRuleConditionsCookiesCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cookie_name: str,
                 operator: str,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        :param str cookie_name: A string value representing the name of the cookie.
        :param str operator: A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        :param Sequence[str] match_values: One or more string or integer values(e.g. "1") representing the value of the request header to match. If multiple values are specified, they're evaluated using `OR` logic.
        :param bool negate_condition: If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        :param Sequence[str] transforms: A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Defaults to `Lowercase`. Details can be found in the `Condition Transform List` below.
        """
        pulumi.set(__self__, "cookie_name", cookie_name)
        pulumi.set(__self__, "operator", operator)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter(name="cookieName")
    def cookie_name(self) -> str:
        """
        A string value representing the name of the cookie.
        """
        return pulumi.get(self, "cookie_name")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        One or more string or integer values(e.g. "1") representing the value of the request header to match. If multiple values are specified, they're evaluated using `OR` logic.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Defaults to `Lowercase`. Details can be found in the `Condition Transform List` below.
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class FrontdoorRuleConditionsHostNameCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorRuleConditionsHostNameCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorRuleConditionsHostNameCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorRuleConditionsHostNameCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        :param str operator: A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        :param Sequence[str] match_values: A list of one or more string values representing the value of the request hostname to match. If multiple values are specified, they're evaluated using `OR` logic.
        :param bool negate_condition: If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        :param Sequence[str] transforms: A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Defaults to `Lowercase`. Details can be found in the `Condition Transform List` below.
        """
        pulumi.set(__self__, "operator", operator)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        A list of one or more string values representing the value of the request hostname to match. If multiple values are specified, they're evaluated using `OR` logic.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Defaults to `Lowercase`. Details can be found in the `Condition Transform List` below.
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class FrontdoorRuleConditionsHttpVersionCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorRuleConditionsHttpVersionCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorRuleConditionsHttpVersionCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorRuleConditionsHttpVersionCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_values: Sequence[str],
                 negate_condition: Optional[bool] = None,
                 operator: Optional[str] = None):
        """
        :param Sequence[str] match_values: What HTTP version should this condition match? Possible values `2.0`, `1.1`, `1.0` or `0.9`.
        :param bool negate_condition: If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        :param str operator: Possible value `Equal`. Defaults to `Equal`.
        """
        pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Sequence[str]:
        """
        What HTTP version should this condition match? Possible values `2.0`, `1.1`, `1.0` or `0.9`.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Possible value `Equal`. Defaults to `Equal`.
        """
        return pulumi.get(self, "operator")


@pulumi.output_type
class FrontdoorRuleConditionsIsDeviceCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorRuleConditionsIsDeviceCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorRuleConditionsIsDeviceCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorRuleConditionsIsDeviceCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_values: Optional[str] = None,
                 negate_condition: Optional[bool] = None,
                 operator: Optional[str] = None):
        """
        :param str match_values: Which device should this rule match on? Possible values `Mobile` or `Desktop`. Defaults to `Mobile`.
        :param bool negate_condition: If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        :param str operator: Possible value `Equal`. Defaults to `Equal`.
        """
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[str]:
        """
        Which device should this rule match on? Possible values `Mobile` or `Desktop`. Defaults to `Mobile`.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Possible value `Equal`. Defaults to `Equal`.
        """
        return pulumi.get(self, "operator")


@pulumi.output_type
class FrontdoorRuleConditionsPostArgsCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "postArgsName":
            suggest = "post_args_name"
        elif key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorRuleConditionsPostArgsCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorRuleConditionsPostArgsCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorRuleConditionsPostArgsCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 post_args_name: str,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        :param str operator: A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        :param str post_args_name: A string value representing the name of the `POST` argument.
        :param Sequence[str] match_values: One or more string or integer values(e.g. "1") representing the value of the `POST` argument to match. If multiple values are specified, they're evaluated using `OR` logic.
        :param bool negate_condition: If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        :param Sequence[str] transforms: A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Defaults to `Lowercase`. Details can be found in the `Condition Transform List` below.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "post_args_name", post_args_name)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="postArgsName")
    def post_args_name(self) -> str:
        """
        A string value representing the name of the `POST` argument.
        """
        return pulumi.get(self, "post_args_name")

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        One or more string or integer values(e.g. "1") representing the value of the `POST` argument to match. If multiple values are specified, they're evaluated using `OR` logic.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Defaults to `Lowercase`. Details can be found in the `Condition Transform List` below.
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class FrontdoorRuleConditionsQueryStringCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorRuleConditionsQueryStringCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorRuleConditionsQueryStringCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorRuleConditionsQueryStringCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        :param str operator: A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        :param Sequence[str] match_values: One or more string or integer values(e.g. "1") representing the value of the query string to match. If multiple values are specified, they're evaluated using `OR` logic.
        :param bool negate_condition: If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        :param Sequence[str] transforms: A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Defaults to `Lowercase`. Details can be found in the `Condition Transform List` below.
        """
        pulumi.set(__self__, "operator", operator)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        One or more string or integer values(e.g. "1") representing the value of the query string to match. If multiple values are specified, they're evaluated using `OR` logic.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Defaults to `Lowercase`. Details can be found in the `Condition Transform List` below.
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class FrontdoorRuleConditionsRemoteAddressCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorRuleConditionsRemoteAddressCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorRuleConditionsRemoteAddressCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorRuleConditionsRemoteAddressCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None,
                 operator: Optional[str] = None):
        """
        :param Sequence[str] match_values: For the IP Match or IP Not Match operators: specify one or more IP address ranges. If multiple IP address ranges are specified, they're evaluated using `OR` logic. For the Geo Match or Geo Not Match operators: specify one or more locations using their country code.
        :param bool negate_condition: If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        :param str operator: The type of the remote address to match. Possible values include `Any`, `GeoMatch` or `IPMatch`. Use the `negate_condition` to specify Not `GeoMatch` or Not `IPMatch`.
        """
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        For the IP Match or IP Not Match operators: specify one or more IP address ranges. If multiple IP address ranges are specified, they're evaluated using `OR` logic. For the Geo Match or Geo Not Match operators: specify one or more locations using their country code.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        The type of the remote address to match. Possible values include `Any`, `GeoMatch` or `IPMatch`. Use the `negate_condition` to specify Not `GeoMatch` or Not `IPMatch`.
        """
        return pulumi.get(self, "operator")


@pulumi.output_type
class FrontdoorRuleConditionsRequestBodyCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorRuleConditionsRequestBodyCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorRuleConditionsRequestBodyCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorRuleConditionsRequestBodyCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_values: Sequence[str],
                 operator: str,
                 negate_condition: Optional[bool] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] match_values: A list of one or more string or integer values(e.g. "1") representing the value of the request body text to match. If multiple values are specified, they're evaluated using `OR` logic.
        :param str operator: A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        :param bool negate_condition: If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        :param Sequence[str] transforms: A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Defaults to `Lowercase`. Details can be found in the `Condition Transform List` below.
        """
        pulumi.set(__self__, "match_values", match_values)
        pulumi.set(__self__, "operator", operator)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Sequence[str]:
        """
        A list of one or more string or integer values(e.g. "1") representing the value of the request body text to match. If multiple values are specified, they're evaluated using `OR` logic.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Defaults to `Lowercase`. Details can be found in the `Condition Transform List` below.
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class FrontdoorRuleConditionsRequestHeaderCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerName":
            suggest = "header_name"
        elif key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorRuleConditionsRequestHeaderCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorRuleConditionsRequestHeaderCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorRuleConditionsRequestHeaderCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_name: str,
                 operator: str,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        :param str header_name: A string value representing the name of the `POST` argument.
        :param str operator: A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        :param Sequence[str] match_values: One or more string or integer values(e.g. "1") representing the value of the request header to match. If multiple values are specified, they're evaluated using `OR` logic.
        :param bool negate_condition: If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        :param Sequence[str] transforms: A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Defaults to `Lowercase`. Details can be found in the `Condition Transform List` below.
        """
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "operator", operator)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        A string value representing the name of the `POST` argument.
        """
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        One or more string or integer values(e.g. "1") representing the value of the request header to match. If multiple values are specified, they're evaluated using `OR` logic.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Defaults to `Lowercase`. Details can be found in the `Condition Transform List` below.
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class FrontdoorRuleConditionsRequestMethodCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorRuleConditionsRequestMethodCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorRuleConditionsRequestMethodCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorRuleConditionsRequestMethodCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_values: Sequence[str],
                 negate_condition: Optional[bool] = None,
                 operator: Optional[str] = None):
        """
        :param Sequence[str] match_values: A list of one or more HTTP methods. Possible values include `GET`, `POST`, `PUT`, `DELETE`, `HEAD`, `OPTIONS` or `TRACE`. If multiple values are specified, they're evaluated using `OR` logic.
        :param bool negate_condition: If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        :param str operator: Possible value `Equal`. Defaults to `Equal`.
        """
        pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Sequence[str]:
        """
        A list of one or more HTTP methods. Possible values include `GET`, `POST`, `PUT`, `DELETE`, `HEAD`, `OPTIONS` or `TRACE`. If multiple values are specified, they're evaluated using `OR` logic.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Possible value `Equal`. Defaults to `Equal`.
        """
        return pulumi.get(self, "operator")


@pulumi.output_type
class FrontdoorRuleConditionsRequestSchemeCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorRuleConditionsRequestSchemeCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorRuleConditionsRequestSchemeCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorRuleConditionsRequestSchemeCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_values: Optional[str] = None,
                 negate_condition: Optional[bool] = None,
                 operator: Optional[str] = None):
        """
        :param str match_values: The requests protocol to match. Possible values include `HTTP` or `HTTPS`. Defaults to `HTTP`.
        :param bool negate_condition: If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        :param str operator: Possible value `Equal`. Defaults to `Equal`.
        """
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[str]:
        """
        The requests protocol to match. Possible values include `HTTP` or `HTTPS`. Defaults to `HTTP`.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Possible value `Equal`. Defaults to `Equal`.
        """
        return pulumi.get(self, "operator")


@pulumi.output_type
class FrontdoorRuleConditionsRequestUriCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorRuleConditionsRequestUriCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorRuleConditionsRequestUriCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorRuleConditionsRequestUriCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        :param str operator: A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        :param Sequence[str] match_values: One or more string or integer values(e.g. "1") representing the value of the request URL to match. If multiple values are specified, they're evaluated using `OR` logic.
        :param bool negate_condition: If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        :param Sequence[str] transforms: A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Defaults to `Lowercase`. Details can be found in the `Condition Transform List` below.
        """
        pulumi.set(__self__, "operator", operator)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        One or more string or integer values(e.g. "1") representing the value of the request URL to match. If multiple values are specified, they're evaluated using `OR` logic.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Defaults to `Lowercase`. Details can be found in the `Condition Transform List` below.
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class FrontdoorRuleConditionsServerPortCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorRuleConditionsServerPortCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorRuleConditionsServerPortCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorRuleConditionsServerPortCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_values: Sequence[str],
                 operator: str,
                 negate_condition: Optional[bool] = None):
        """
        :param Sequence[str] match_values: A list of one or more integer values(e.g. "1") representing the value of the client port to match. Possible values include `80` or `443`. If multiple values are specified, they're evaluated using `OR` logic.
        :param str operator: A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        :param bool negate_condition: If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        pulumi.set(__self__, "match_values", match_values)
        pulumi.set(__self__, "operator", operator)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Sequence[str]:
        """
        A list of one or more integer values(e.g. "1") representing the value of the client port to match. Possible values include `80` or `443`. If multiple values are specified, they're evaluated using `OR` logic.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "negate_condition")


@pulumi.output_type
class FrontdoorRuleConditionsSocketAddressCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorRuleConditionsSocketAddressCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorRuleConditionsSocketAddressCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorRuleConditionsSocketAddressCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None,
                 operator: Optional[str] = None):
        """
        :param Sequence[str] match_values: Specify one or more IP address ranges. If multiple IP address ranges are specified, they're evaluated using `OR` logic.
        :param bool negate_condition: If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        :param str operator: The type of match. The Possible values are `IpMatch` or `Any`. Defaults to `IpMatch`.
        """
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        Specify one or more IP address ranges. If multiple IP address ranges are specified, they're evaluated using `OR` logic.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        The type of match. The Possible values are `IpMatch` or `Any`. Defaults to `IpMatch`.
        """
        return pulumi.get(self, "operator")


@pulumi.output_type
class FrontdoorRuleConditionsSslProtocolCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorRuleConditionsSslProtocolCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorRuleConditionsSslProtocolCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorRuleConditionsSslProtocolCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_values: Sequence[str],
                 negate_condition: Optional[bool] = None,
                 operator: Optional[str] = None):
        """
        :param Sequence[str] match_values: A list of one or more HTTP methods. Possible values include `TLSv1.0`, `TLSv1.1` or `TLS1.2`. If multiple values are specified, they're evaluated using `OR` logic.
        :param bool negate_condition: If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        :param str operator: Possible value `Equal`. Defaults to `Equal`.
        """
        pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Sequence[str]:
        """
        A list of one or more HTTP methods. Possible values include `TLSv1.0`, `TLSv1.1` or `TLS1.2`. If multiple values are specified, they're evaluated using `OR` logic.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Possible value `Equal`. Defaults to `Equal`.
        """
        return pulumi.get(self, "operator")


@pulumi.output_type
class FrontdoorRuleConditionsUrlFileExtensionCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorRuleConditionsUrlFileExtensionCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorRuleConditionsUrlFileExtensionCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorRuleConditionsUrlFileExtensionCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_values: Sequence[str],
                 operator: str,
                 negate_condition: Optional[bool] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] match_values: A list of one or more string or integer values(e.g. "1") representing the value of the request file extension to match. If multiple values are specified, they're evaluated using `OR` logic.
        :param str operator: A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        :param bool negate_condition: If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        :param Sequence[str] transforms: A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Defaults to `Lowercase`. Details can be found in the `Condition Transform List` below.
        """
        pulumi.set(__self__, "match_values", match_values)
        pulumi.set(__self__, "operator", operator)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Sequence[str]:
        """
        A list of one or more string or integer values(e.g. "1") representing the value of the request file extension to match. If multiple values are specified, they're evaluated using `OR` logic.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Defaults to `Lowercase`. Details can be found in the `Condition Transform List` below.
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class FrontdoorRuleConditionsUrlFilenameCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorRuleConditionsUrlFilenameCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorRuleConditionsUrlFilenameCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorRuleConditionsUrlFilenameCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_values: Sequence[str],
                 operator: str,
                 negate_condition: Optional[bool] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] match_values: A list of one or more string or integer values(e.g. "1") representing the value of the request file name to match. If multiple values are specified, they're evaluated using `OR` logic.
        :param str operator: A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        :param bool negate_condition: If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        :param Sequence[str] transforms: A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Defaults to `Lowercase`. Details can be found in the `Condition Transform List` below.
        """
        pulumi.set(__self__, "match_values", match_values)
        pulumi.set(__self__, "operator", operator)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Sequence[str]:
        """
        A list of one or more string or integer values(e.g. "1") representing the value of the request file name to match. If multiple values are specified, they're evaluated using `OR` logic.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Defaults to `Lowercase`. Details can be found in the `Condition Transform List` below.
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class FrontdoorRuleConditionsUrlPathCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorRuleConditionsUrlPathCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorRuleConditionsUrlPathCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorRuleConditionsUrlPathCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        :param str operator: A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        :param Sequence[str] match_values: One or more string or integer values(e.g. "1") representing the value of the request path to match. Don't include the leading slash (`/`). If multiple values are specified, they're evaluated using `OR` logic.
        :param bool negate_condition: If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        :param Sequence[str] transforms: A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Defaults to `Lowercase`. Details can be found in the `Condition Transform List` below.
        """
        pulumi.set(__self__, "operator", operator)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        One or more string or integer values(e.g. "1") representing the value of the request path to match. Don't include the leading slash (`/`). If multiple values are specified, they're evaluated using `OR` logic.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Defaults to `Lowercase`. Details can be found in the `Condition Transform List` below.
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class FrontdoorSecretSecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customerCertificates":
            suggest = "customer_certificates"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorSecretSecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorSecretSecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorSecretSecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 customer_certificates: Sequence['outputs.FrontdoorSecretSecretCustomerCertificate']):
        """
        :param Sequence['FrontdoorSecretSecretCustomerCertificateArgs'] customer_certificates: A `customer_certificate` block as defined below. Changing this forces a new Front Door Secret to be created.
        """
        pulumi.set(__self__, "customer_certificates", customer_certificates)

    @property
    @pulumi.getter(name="customerCertificates")
    def customer_certificates(self) -> Sequence['outputs.FrontdoorSecretSecretCustomerCertificate']:
        """
        A `customer_certificate` block as defined below. Changing this forces a new Front Door Secret to be created.
        """
        return pulumi.get(self, "customer_certificates")


@pulumi.output_type
class FrontdoorSecretSecretCustomerCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVaultCertificateId":
            suggest = "key_vault_certificate_id"
        elif key == "subjectAlternativeNames":
            suggest = "subject_alternative_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorSecretSecretCustomerCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorSecretSecretCustomerCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorSecretSecretCustomerCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_vault_certificate_id: str,
                 subject_alternative_names: Optional[Sequence[str]] = None):
        """
        :param str key_vault_certificate_id: The ID of the Key Vault certificate resource to use. Changing this forces a new Front Door Secret to be created.
        :param Sequence[str] subject_alternative_names: One or more `subject alternative names` contained within the key vault certificate.
        """
        pulumi.set(__self__, "key_vault_certificate_id", key_vault_certificate_id)
        if subject_alternative_names is not None:
            pulumi.set(__self__, "subject_alternative_names", subject_alternative_names)

    @property
    @pulumi.getter(name="keyVaultCertificateId")
    def key_vault_certificate_id(self) -> str:
        """
        The ID of the Key Vault certificate resource to use. Changing this forces a new Front Door Secret to be created.
        """
        return pulumi.get(self, "key_vault_certificate_id")

    @property
    @pulumi.getter(name="subjectAlternativeNames")
    def subject_alternative_names(self) -> Optional[Sequence[str]]:
        """
        One or more `subject alternative names` contained within the key vault certificate.
        """
        return pulumi.get(self, "subject_alternative_names")


@pulumi.output_type
class FrontdoorSecurityPolicySecurityPolicies(dict):
    def __init__(__self__, *,
                 firewall: 'outputs.FrontdoorSecurityPolicySecurityPoliciesFirewall'):
        """
        :param 'FrontdoorSecurityPolicySecurityPoliciesFirewallArgs' firewall: An `firewall` block as defined below. Changing this forces a new Front Door Security Policy to be created.
        """
        pulumi.set(__self__, "firewall", firewall)

    @property
    @pulumi.getter
    def firewall(self) -> 'outputs.FrontdoorSecurityPolicySecurityPoliciesFirewall':
        """
        An `firewall` block as defined below. Changing this forces a new Front Door Security Policy to be created.
        """
        return pulumi.get(self, "firewall")


@pulumi.output_type
class FrontdoorSecurityPolicySecurityPoliciesFirewall(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cdnFrontdoorFirewallPolicyId":
            suggest = "cdn_frontdoor_firewall_policy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorSecurityPolicySecurityPoliciesFirewall. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorSecurityPolicySecurityPoliciesFirewall.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorSecurityPolicySecurityPoliciesFirewall.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 association: 'outputs.FrontdoorSecurityPolicySecurityPoliciesFirewallAssociation',
                 cdn_frontdoor_firewall_policy_id: str):
        """
        :param 'FrontdoorSecurityPolicySecurityPoliciesFirewallAssociationArgs' association: An `association` block as defined below. Changing this forces a new Front Door Security Policy to be created.
        :param str cdn_frontdoor_firewall_policy_id: The Resource Id of the Front Door Firewall Policy that should be linked to this Front Door Security Policy. Changing this forces a new Front Door Security Policy to be created.
        """
        pulumi.set(__self__, "association", association)
        pulumi.set(__self__, "cdn_frontdoor_firewall_policy_id", cdn_frontdoor_firewall_policy_id)

    @property
    @pulumi.getter
    def association(self) -> 'outputs.FrontdoorSecurityPolicySecurityPoliciesFirewallAssociation':
        """
        An `association` block as defined below. Changing this forces a new Front Door Security Policy to be created.
        """
        return pulumi.get(self, "association")

    @property
    @pulumi.getter(name="cdnFrontdoorFirewallPolicyId")
    def cdn_frontdoor_firewall_policy_id(self) -> str:
        """
        The Resource Id of the Front Door Firewall Policy that should be linked to this Front Door Security Policy. Changing this forces a new Front Door Security Policy to be created.
        """
        return pulumi.get(self, "cdn_frontdoor_firewall_policy_id")


@pulumi.output_type
class FrontdoorSecurityPolicySecurityPoliciesFirewallAssociation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "patternsToMatch":
            suggest = "patterns_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorSecurityPolicySecurityPoliciesFirewallAssociation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorSecurityPolicySecurityPoliciesFirewallAssociation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorSecurityPolicySecurityPoliciesFirewallAssociation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domains: Sequence['outputs.FrontdoorSecurityPolicySecurityPoliciesFirewallAssociationDomain'],
                 patterns_to_match: str):
        """
        :param Sequence['FrontdoorSecurityPolicySecurityPoliciesFirewallAssociationDomainArgs'] domains: One or more `domain` blocks as defined below. Changing this forces a new Front Door Security Policy to be created.
        :param str patterns_to_match: The list of paths to match for this firewall policy. Possible value includes `/*`. Changing this forces a new Front Door Security Policy to be created.
        """
        pulumi.set(__self__, "domains", domains)
        pulumi.set(__self__, "patterns_to_match", patterns_to_match)

    @property
    @pulumi.getter
    def domains(self) -> Sequence['outputs.FrontdoorSecurityPolicySecurityPoliciesFirewallAssociationDomain']:
        """
        One or more `domain` blocks as defined below. Changing this forces a new Front Door Security Policy to be created.
        """
        return pulumi.get(self, "domains")

    @property
    @pulumi.getter(name="patternsToMatch")
    def patterns_to_match(self) -> str:
        """
        The list of paths to match for this firewall policy. Possible value includes `/*`. Changing this forces a new Front Door Security Policy to be created.
        """
        return pulumi.get(self, "patterns_to_match")


@pulumi.output_type
class FrontdoorSecurityPolicySecurityPoliciesFirewallAssociationDomain(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cdnFrontdoorDomainId":
            suggest = "cdn_frontdoor_domain_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorSecurityPolicySecurityPoliciesFirewallAssociationDomain. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorSecurityPolicySecurityPoliciesFirewallAssociationDomain.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorSecurityPolicySecurityPoliciesFirewallAssociationDomain.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cdn_frontdoor_domain_id: str,
                 active: Optional[bool] = None):
        """
        :param str cdn_frontdoor_domain_id: The Resource Id of the **Front Door Custom Domain** or **Front Door Endpoint** that should be bound to this Front Door Security Policy. Changing this forces a new Front Door Security Policy to be created.
        :param bool active: Is the Front Door Custom Domain/Endpoint activated?
        """
        pulumi.set(__self__, "cdn_frontdoor_domain_id", cdn_frontdoor_domain_id)
        if active is not None:
            pulumi.set(__self__, "active", active)

    @property
    @pulumi.getter(name="cdnFrontdoorDomainId")
    def cdn_frontdoor_domain_id(self) -> str:
        """
        The Resource Id of the **Front Door Custom Domain** or **Front Door Endpoint** that should be bound to this Front Door Security Policy. Changing this forces a new Front Door Security Policy to be created.
        """
        return pulumi.get(self, "cdn_frontdoor_domain_id")

    @property
    @pulumi.getter
    def active(self) -> Optional[bool]:
        """
        Is the Front Door Custom Domain/Endpoint activated?
        """
        return pulumi.get(self, "active")


@pulumi.output_type
class GetFrontdoorOriginGroupHealthProbeResult(dict):
    def __init__(__self__, *,
                 interval_in_seconds: int,
                 path: str,
                 protocol: str,
                 request_type: str):
        """
        :param int interval_in_seconds: Specifies the number of seconds between health probes.
        :param str path: Specifies the path relative to the origin that is used to determine the health of the origin.
        :param str protocol: Specifies the protocol to use for health probe.
        :param str request_type: Specifies the type of health probe request that is made.
        """
        pulumi.set(__self__, "interval_in_seconds", interval_in_seconds)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "request_type", request_type)

    @property
    @pulumi.getter(name="intervalInSeconds")
    def interval_in_seconds(self) -> int:
        """
        Specifies the number of seconds between health probes.
        """
        return pulumi.get(self, "interval_in_seconds")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        Specifies the path relative to the origin that is used to determine the health of the origin.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Specifies the protocol to use for health probe.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="requestType")
    def request_type(self) -> str:
        """
        Specifies the type of health probe request that is made.
        """
        return pulumi.get(self, "request_type")


@pulumi.output_type
class GetFrontdoorOriginGroupLoadBalancingResult(dict):
    def __init__(__self__, *,
                 additional_latency_in_milliseconds: int,
                 sample_size: int,
                 successful_samples_required: int):
        """
        :param int additional_latency_in_milliseconds: Specifies the additional latency in milliseconds for probes to fall into the lowest latency bucket.
        :param int sample_size: Specifies the number of samples to consider for load balancing decisions.
        :param int successful_samples_required: Specifies the number of samples within the sample period that must succeed.
        """
        pulumi.set(__self__, "additional_latency_in_milliseconds", additional_latency_in_milliseconds)
        pulumi.set(__self__, "sample_size", sample_size)
        pulumi.set(__self__, "successful_samples_required", successful_samples_required)

    @property
    @pulumi.getter(name="additionalLatencyInMilliseconds")
    def additional_latency_in_milliseconds(self) -> int:
        """
        Specifies the additional latency in milliseconds for probes to fall into the lowest latency bucket.
        """
        return pulumi.get(self, "additional_latency_in_milliseconds")

    @property
    @pulumi.getter(name="sampleSize")
    def sample_size(self) -> int:
        """
        Specifies the number of samples to consider for load balancing decisions.
        """
        return pulumi.get(self, "sample_size")

    @property
    @pulumi.getter(name="successfulSamplesRequired")
    def successful_samples_required(self) -> int:
        """
        Specifies the number of samples within the sample period that must succeed.
        """
        return pulumi.get(self, "successful_samples_required")


@pulumi.output_type
class GetFrontdoorSecretSecretResult(dict):
    def __init__(__self__, *,
                 customer_certificates: Sequence['outputs.GetFrontdoorSecretSecretCustomerCertificateResult']):
        """
        :param Sequence['GetFrontdoorSecretSecretCustomerCertificateArgs'] customer_certificates: A `customer_certificate` block as defined below.
        """
        pulumi.set(__self__, "customer_certificates", customer_certificates)

    @property
    @pulumi.getter(name="customerCertificates")
    def customer_certificates(self) -> Sequence['outputs.GetFrontdoorSecretSecretCustomerCertificateResult']:
        """
        A `customer_certificate` block as defined below.
        """
        return pulumi.get(self, "customer_certificates")


@pulumi.output_type
class GetFrontdoorSecretSecretCustomerCertificateResult(dict):
    def __init__(__self__, *,
                 key_vault_certificate_id: str,
                 subject_alternative_names: Sequence[str]):
        """
        :param str key_vault_certificate_id: The key vault certificate ID.
        :param Sequence[str] subject_alternative_names: One or more `subject alternative names` contained within the key vault certificate.
        """
        pulumi.set(__self__, "key_vault_certificate_id", key_vault_certificate_id)
        pulumi.set(__self__, "subject_alternative_names", subject_alternative_names)

    @property
    @pulumi.getter(name="keyVaultCertificateId")
    def key_vault_certificate_id(self) -> str:
        """
        The key vault certificate ID.
        """
        return pulumi.get(self, "key_vault_certificate_id")

    @property
    @pulumi.getter(name="subjectAlternativeNames")
    def subject_alternative_names(self) -> Sequence[str]:
        """
        One or more `subject alternative names` contained within the key vault certificate.
        """
        return pulumi.get(self, "subject_alternative_names")


