# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'EndpointCustomDomainCdnManagedHttpsArgs',
    'EndpointCustomDomainCdnManagedHttpsArgsDict',
    'EndpointCustomDomainUserManagedHttpsArgs',
    'EndpointCustomDomainUserManagedHttpsArgsDict',
    'EndpointDeliveryRuleArgs',
    'EndpointDeliveryRuleArgsDict',
    'EndpointDeliveryRuleCacheExpirationActionArgs',
    'EndpointDeliveryRuleCacheExpirationActionArgsDict',
    'EndpointDeliveryRuleCacheKeyQueryStringActionArgs',
    'EndpointDeliveryRuleCacheKeyQueryStringActionArgsDict',
    'EndpointDeliveryRuleCookiesConditionArgs',
    'EndpointDeliveryRuleCookiesConditionArgsDict',
    'EndpointDeliveryRuleDeviceConditionArgs',
    'EndpointDeliveryRuleDeviceConditionArgsDict',
    'EndpointDeliveryRuleHttpVersionConditionArgs',
    'EndpointDeliveryRuleHttpVersionConditionArgsDict',
    'EndpointDeliveryRuleModifyRequestHeaderActionArgs',
    'EndpointDeliveryRuleModifyRequestHeaderActionArgsDict',
    'EndpointDeliveryRuleModifyResponseHeaderActionArgs',
    'EndpointDeliveryRuleModifyResponseHeaderActionArgsDict',
    'EndpointDeliveryRulePostArgConditionArgs',
    'EndpointDeliveryRulePostArgConditionArgsDict',
    'EndpointDeliveryRuleQueryStringConditionArgs',
    'EndpointDeliveryRuleQueryStringConditionArgsDict',
    'EndpointDeliveryRuleRemoteAddressConditionArgs',
    'EndpointDeliveryRuleRemoteAddressConditionArgsDict',
    'EndpointDeliveryRuleRequestBodyConditionArgs',
    'EndpointDeliveryRuleRequestBodyConditionArgsDict',
    'EndpointDeliveryRuleRequestHeaderConditionArgs',
    'EndpointDeliveryRuleRequestHeaderConditionArgsDict',
    'EndpointDeliveryRuleRequestMethodConditionArgs',
    'EndpointDeliveryRuleRequestMethodConditionArgsDict',
    'EndpointDeliveryRuleRequestSchemeConditionArgs',
    'EndpointDeliveryRuleRequestSchemeConditionArgsDict',
    'EndpointDeliveryRuleRequestUriConditionArgs',
    'EndpointDeliveryRuleRequestUriConditionArgsDict',
    'EndpointDeliveryRuleUrlFileExtensionConditionArgs',
    'EndpointDeliveryRuleUrlFileExtensionConditionArgsDict',
    'EndpointDeliveryRuleUrlFileNameConditionArgs',
    'EndpointDeliveryRuleUrlFileNameConditionArgsDict',
    'EndpointDeliveryRuleUrlPathConditionArgs',
    'EndpointDeliveryRuleUrlPathConditionArgsDict',
    'EndpointDeliveryRuleUrlRedirectActionArgs',
    'EndpointDeliveryRuleUrlRedirectActionArgsDict',
    'EndpointDeliveryRuleUrlRewriteActionArgs',
    'EndpointDeliveryRuleUrlRewriteActionArgsDict',
    'EndpointGeoFilterArgs',
    'EndpointGeoFilterArgsDict',
    'EndpointGlobalDeliveryRuleArgs',
    'EndpointGlobalDeliveryRuleArgsDict',
    'EndpointGlobalDeliveryRuleCacheExpirationActionArgs',
    'EndpointGlobalDeliveryRuleCacheExpirationActionArgsDict',
    'EndpointGlobalDeliveryRuleCacheKeyQueryStringActionArgs',
    'EndpointGlobalDeliveryRuleCacheKeyQueryStringActionArgsDict',
    'EndpointGlobalDeliveryRuleModifyRequestHeaderActionArgs',
    'EndpointGlobalDeliveryRuleModifyRequestHeaderActionArgsDict',
    'EndpointGlobalDeliveryRuleModifyResponseHeaderActionArgs',
    'EndpointGlobalDeliveryRuleModifyResponseHeaderActionArgsDict',
    'EndpointGlobalDeliveryRuleUrlRedirectActionArgs',
    'EndpointGlobalDeliveryRuleUrlRedirectActionArgsDict',
    'EndpointGlobalDeliveryRuleUrlRewriteActionArgs',
    'EndpointGlobalDeliveryRuleUrlRewriteActionArgsDict',
    'EndpointOriginArgs',
    'EndpointOriginArgsDict',
    'FrontdoorCustomDomainTlsArgs',
    'FrontdoorCustomDomainTlsArgsDict',
    'FrontdoorFirewallPolicyCustomRuleArgs',
    'FrontdoorFirewallPolicyCustomRuleArgsDict',
    'FrontdoorFirewallPolicyCustomRuleMatchConditionArgs',
    'FrontdoorFirewallPolicyCustomRuleMatchConditionArgsDict',
    'FrontdoorFirewallPolicyManagedRuleArgs',
    'FrontdoorFirewallPolicyManagedRuleArgsDict',
    'FrontdoorFirewallPolicyManagedRuleExclusionArgs',
    'FrontdoorFirewallPolicyManagedRuleExclusionArgsDict',
    'FrontdoorFirewallPolicyManagedRuleOverrideArgs',
    'FrontdoorFirewallPolicyManagedRuleOverrideArgsDict',
    'FrontdoorFirewallPolicyManagedRuleOverrideExclusionArgs',
    'FrontdoorFirewallPolicyManagedRuleOverrideExclusionArgsDict',
    'FrontdoorFirewallPolicyManagedRuleOverrideRuleArgs',
    'FrontdoorFirewallPolicyManagedRuleOverrideRuleArgsDict',
    'FrontdoorFirewallPolicyManagedRuleOverrideRuleExclusionArgs',
    'FrontdoorFirewallPolicyManagedRuleOverrideRuleExclusionArgsDict',
    'FrontdoorOriginGroupHealthProbeArgs',
    'FrontdoorOriginGroupHealthProbeArgsDict',
    'FrontdoorOriginGroupLoadBalancingArgs',
    'FrontdoorOriginGroupLoadBalancingArgsDict',
    'FrontdoorOriginPrivateLinkArgs',
    'FrontdoorOriginPrivateLinkArgsDict',
    'FrontdoorProfileIdentityArgs',
    'FrontdoorProfileIdentityArgsDict',
    'FrontdoorRouteCacheArgs',
    'FrontdoorRouteCacheArgsDict',
    'FrontdoorRuleActionsArgs',
    'FrontdoorRuleActionsArgsDict',
    'FrontdoorRuleActionsRequestHeaderActionArgs',
    'FrontdoorRuleActionsRequestHeaderActionArgsDict',
    'FrontdoorRuleActionsResponseHeaderActionArgs',
    'FrontdoorRuleActionsResponseHeaderActionArgsDict',
    'FrontdoorRuleActionsRouteConfigurationOverrideActionArgs',
    'FrontdoorRuleActionsRouteConfigurationOverrideActionArgsDict',
    'FrontdoorRuleActionsUrlRedirectActionArgs',
    'FrontdoorRuleActionsUrlRedirectActionArgsDict',
    'FrontdoorRuleActionsUrlRewriteActionArgs',
    'FrontdoorRuleActionsUrlRewriteActionArgsDict',
    'FrontdoorRuleConditionsArgs',
    'FrontdoorRuleConditionsArgsDict',
    'FrontdoorRuleConditionsClientPortConditionArgs',
    'FrontdoorRuleConditionsClientPortConditionArgsDict',
    'FrontdoorRuleConditionsCookiesConditionArgs',
    'FrontdoorRuleConditionsCookiesConditionArgsDict',
    'FrontdoorRuleConditionsHostNameConditionArgs',
    'FrontdoorRuleConditionsHostNameConditionArgsDict',
    'FrontdoorRuleConditionsHttpVersionConditionArgs',
    'FrontdoorRuleConditionsHttpVersionConditionArgsDict',
    'FrontdoorRuleConditionsIsDeviceConditionArgs',
    'FrontdoorRuleConditionsIsDeviceConditionArgsDict',
    'FrontdoorRuleConditionsPostArgsConditionArgs',
    'FrontdoorRuleConditionsPostArgsConditionArgsDict',
    'FrontdoorRuleConditionsQueryStringConditionArgs',
    'FrontdoorRuleConditionsQueryStringConditionArgsDict',
    'FrontdoorRuleConditionsRemoteAddressConditionArgs',
    'FrontdoorRuleConditionsRemoteAddressConditionArgsDict',
    'FrontdoorRuleConditionsRequestBodyConditionArgs',
    'FrontdoorRuleConditionsRequestBodyConditionArgsDict',
    'FrontdoorRuleConditionsRequestHeaderConditionArgs',
    'FrontdoorRuleConditionsRequestHeaderConditionArgsDict',
    'FrontdoorRuleConditionsRequestMethodConditionArgs',
    'FrontdoorRuleConditionsRequestMethodConditionArgsDict',
    'FrontdoorRuleConditionsRequestSchemeConditionArgs',
    'FrontdoorRuleConditionsRequestSchemeConditionArgsDict',
    'FrontdoorRuleConditionsRequestUriConditionArgs',
    'FrontdoorRuleConditionsRequestUriConditionArgsDict',
    'FrontdoorRuleConditionsServerPortConditionArgs',
    'FrontdoorRuleConditionsServerPortConditionArgsDict',
    'FrontdoorRuleConditionsSocketAddressConditionArgs',
    'FrontdoorRuleConditionsSocketAddressConditionArgsDict',
    'FrontdoorRuleConditionsSslProtocolConditionArgs',
    'FrontdoorRuleConditionsSslProtocolConditionArgsDict',
    'FrontdoorRuleConditionsUrlFileExtensionConditionArgs',
    'FrontdoorRuleConditionsUrlFileExtensionConditionArgsDict',
    'FrontdoorRuleConditionsUrlFilenameConditionArgs',
    'FrontdoorRuleConditionsUrlFilenameConditionArgsDict',
    'FrontdoorRuleConditionsUrlPathConditionArgs',
    'FrontdoorRuleConditionsUrlPathConditionArgsDict',
    'FrontdoorSecretSecretArgs',
    'FrontdoorSecretSecretArgsDict',
    'FrontdoorSecretSecretCustomerCertificateArgs',
    'FrontdoorSecretSecretCustomerCertificateArgsDict',
    'FrontdoorSecurityPolicySecurityPoliciesArgs',
    'FrontdoorSecurityPolicySecurityPoliciesArgsDict',
    'FrontdoorSecurityPolicySecurityPoliciesFirewallArgs',
    'FrontdoorSecurityPolicySecurityPoliciesFirewallArgsDict',
    'FrontdoorSecurityPolicySecurityPoliciesFirewallAssociationArgs',
    'FrontdoorSecurityPolicySecurityPoliciesFirewallAssociationArgsDict',
    'FrontdoorSecurityPolicySecurityPoliciesFirewallAssociationDomainArgs',
    'FrontdoorSecurityPolicySecurityPoliciesFirewallAssociationDomainArgsDict',
    'GetFrontdoorProfileIdentityArgs',
    'GetFrontdoorProfileIdentityArgsDict',
]

MYPY = False

if not MYPY:
    class EndpointCustomDomainCdnManagedHttpsArgsDict(TypedDict):
        certificate_type: pulumi.Input[str]
        """
        The type of HTTPS certificate. Possible values are `Shared` and `Dedicated`.
        """
        protocol_type: pulumi.Input[str]
        """
        The type of protocol. Possible values are `ServerNameIndication` and `IPBased`.
        """
        tls_version: NotRequired[pulumi.Input[str]]
        """
        The minimum TLS protocol version that is used for HTTPS. Possible values are `TLS10` (representing TLS 1.0/1.1), `TLS12` (representing TLS 1.2) and `None` (representing no minimums). Defaults to `TLS12`.

        > **Note** Azure Services will require TLS 1.2+ by August 2025, please see this [announcement](https://azure.microsoft.com/en-us/updates/v2/update-retirement-tls1-0-tls1-1-versions-azure-services/) for more.
        """
elif False:
    EndpointCustomDomainCdnManagedHttpsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EndpointCustomDomainCdnManagedHttpsArgs:
    def __init__(__self__, *,
                 certificate_type: pulumi.Input[str],
                 protocol_type: pulumi.Input[str],
                 tls_version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] certificate_type: The type of HTTPS certificate. Possible values are `Shared` and `Dedicated`.
        :param pulumi.Input[str] protocol_type: The type of protocol. Possible values are `ServerNameIndication` and `IPBased`.
        :param pulumi.Input[str] tls_version: The minimum TLS protocol version that is used for HTTPS. Possible values are `TLS10` (representing TLS 1.0/1.1), `TLS12` (representing TLS 1.2) and `None` (representing no minimums). Defaults to `TLS12`.
               
               > **Note** Azure Services will require TLS 1.2+ by August 2025, please see this [announcement](https://azure.microsoft.com/en-us/updates/v2/update-retirement-tls1-0-tls1-1-versions-azure-services/) for more.
        """
        pulumi.set(__self__, "certificate_type", certificate_type)
        pulumi.set(__self__, "protocol_type", protocol_type)
        if tls_version is not None:
            pulumi.set(__self__, "tls_version", tls_version)

    @property
    @pulumi.getter(name="certificateType")
    def certificate_type(self) -> pulumi.Input[str]:
        """
        The type of HTTPS certificate. Possible values are `Shared` and `Dedicated`.
        """
        return pulumi.get(self, "certificate_type")

    @certificate_type.setter
    def certificate_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate_type", value)

    @property
    @pulumi.getter(name="protocolType")
    def protocol_type(self) -> pulumi.Input[str]:
        """
        The type of protocol. Possible values are `ServerNameIndication` and `IPBased`.
        """
        return pulumi.get(self, "protocol_type")

    @protocol_type.setter
    def protocol_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol_type", value)

    @property
    @pulumi.getter(name="tlsVersion")
    def tls_version(self) -> Optional[pulumi.Input[str]]:
        """
        The minimum TLS protocol version that is used for HTTPS. Possible values are `TLS10` (representing TLS 1.0/1.1), `TLS12` (representing TLS 1.2) and `None` (representing no minimums). Defaults to `TLS12`.

        > **Note** Azure Services will require TLS 1.2+ by August 2025, please see this [announcement](https://azure.microsoft.com/en-us/updates/v2/update-retirement-tls1-0-tls1-1-versions-azure-services/) for more.
        """
        return pulumi.get(self, "tls_version")

    @tls_version.setter
    def tls_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tls_version", value)


if not MYPY:
    class EndpointCustomDomainUserManagedHttpsArgsDict(TypedDict):
        key_vault_secret_id: pulumi.Input[str]
        """
        The ID of the Key Vault Secret that contains the HTTPS certificate.
        """
        tls_version: NotRequired[pulumi.Input[str]]
        """
        The minimum TLS protocol version that is used for HTTPS. Possible values are `TLS10` (representing TLS 1.0/1.1), `TLS12` (representing TLS 1.2) and `None` (representing no minimums). Defaults to `TLS12`.

        > **Note** Azure Services will require TLS 1.2+ by August 2025, please see this [announcement](https://azure.microsoft.com/en-us/updates/v2/update-retirement-tls1-0-tls1-1-versions-azure-services/) for more.
        """
elif False:
    EndpointCustomDomainUserManagedHttpsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EndpointCustomDomainUserManagedHttpsArgs:
    def __init__(__self__, *,
                 key_vault_secret_id: pulumi.Input[str],
                 tls_version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key_vault_secret_id: The ID of the Key Vault Secret that contains the HTTPS certificate.
        :param pulumi.Input[str] tls_version: The minimum TLS protocol version that is used for HTTPS. Possible values are `TLS10` (representing TLS 1.0/1.1), `TLS12` (representing TLS 1.2) and `None` (representing no minimums). Defaults to `TLS12`.
               
               > **Note** Azure Services will require TLS 1.2+ by August 2025, please see this [announcement](https://azure.microsoft.com/en-us/updates/v2/update-retirement-tls1-0-tls1-1-versions-azure-services/) for more.
        """
        pulumi.set(__self__, "key_vault_secret_id", key_vault_secret_id)
        if tls_version is not None:
            pulumi.set(__self__, "tls_version", tls_version)

    @property
    @pulumi.getter(name="keyVaultSecretId")
    def key_vault_secret_id(self) -> pulumi.Input[str]:
        """
        The ID of the Key Vault Secret that contains the HTTPS certificate.
        """
        return pulumi.get(self, "key_vault_secret_id")

    @key_vault_secret_id.setter
    def key_vault_secret_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_vault_secret_id", value)

    @property
    @pulumi.getter(name="tlsVersion")
    def tls_version(self) -> Optional[pulumi.Input[str]]:
        """
        The minimum TLS protocol version that is used for HTTPS. Possible values are `TLS10` (representing TLS 1.0/1.1), `TLS12` (representing TLS 1.2) and `None` (representing no minimums). Defaults to `TLS12`.

        > **Note** Azure Services will require TLS 1.2+ by August 2025, please see this [announcement](https://azure.microsoft.com/en-us/updates/v2/update-retirement-tls1-0-tls1-1-versions-azure-services/) for more.
        """
        return pulumi.get(self, "tls_version")

    @tls_version.setter
    def tls_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tls_version", value)


if not MYPY:
    class EndpointDeliveryRuleArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The Name which should be used for this Delivery Rule.
        """
        order: pulumi.Input[int]
        """
        The order used for this rule. The order values should be sequential and begin at `1`.
        """
        cache_expiration_action: NotRequired[pulumi.Input['EndpointDeliveryRuleCacheExpirationActionArgsDict']]
        """
        A `cache_expiration_action` block as defined above.
        """
        cache_key_query_string_action: NotRequired[pulumi.Input['EndpointDeliveryRuleCacheKeyQueryStringActionArgsDict']]
        """
        A `cache_key_query_string_action` block as defined above.
        """
        cookies_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleCookiesConditionArgsDict']]]]
        """
        A `cookies_condition` block as defined above.
        """
        device_condition: NotRequired[pulumi.Input['EndpointDeliveryRuleDeviceConditionArgsDict']]
        """
        A `device_condition` block as defined below.
        """
        http_version_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleHttpVersionConditionArgsDict']]]]
        """
        A `http_version_condition` block as defined below.
        """
        modify_request_header_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleModifyRequestHeaderActionArgsDict']]]]
        """
        A `modify_request_header_action` block as defined below.
        """
        modify_response_header_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleModifyResponseHeaderActionArgsDict']]]]
        """
        A `modify_response_header_action` block as defined below.
        """
        post_arg_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRulePostArgConditionArgsDict']]]]
        """
        A `post_arg_condition` block as defined below.
        """
        query_string_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleQueryStringConditionArgsDict']]]]
        """
        A `query_string_condition` block as defined below.
        """
        remote_address_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleRemoteAddressConditionArgsDict']]]]
        """
        A `remote_address_condition` block as defined below.
        """
        request_body_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleRequestBodyConditionArgsDict']]]]
        """
        A `request_body_condition` block as defined below.
        """
        request_header_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleRequestHeaderConditionArgsDict']]]]
        """
        A `request_header_condition` block as defined below.
        """
        request_method_condition: NotRequired[pulumi.Input['EndpointDeliveryRuleRequestMethodConditionArgsDict']]
        """
        A `request_method_condition` block as defined below.
        """
        request_scheme_condition: NotRequired[pulumi.Input['EndpointDeliveryRuleRequestSchemeConditionArgsDict']]
        """
        A `request_scheme_condition` block as defined below.
        """
        request_uri_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleRequestUriConditionArgsDict']]]]
        """
        A `request_uri_condition` block as defined below.
        """
        url_file_extension_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleUrlFileExtensionConditionArgsDict']]]]
        """
        A `url_file_extension_condition` block as defined below.
        """
        url_file_name_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleUrlFileNameConditionArgsDict']]]]
        """
        A `url_file_name_condition` block as defined below.
        """
        url_path_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleUrlPathConditionArgsDict']]]]
        """
        A `url_path_condition` block as defined below.
        """
        url_redirect_action: NotRequired[pulumi.Input['EndpointDeliveryRuleUrlRedirectActionArgsDict']]
        """
        A `url_redirect_action` block as defined below.
        """
        url_rewrite_action: NotRequired[pulumi.Input['EndpointDeliveryRuleUrlRewriteActionArgsDict']]
        """
        A `url_rewrite_action` block as defined below.
        """
elif False:
    EndpointDeliveryRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EndpointDeliveryRuleArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 order: pulumi.Input[int],
                 cache_expiration_action: Optional[pulumi.Input['EndpointDeliveryRuleCacheExpirationActionArgs']] = None,
                 cache_key_query_string_action: Optional[pulumi.Input['EndpointDeliveryRuleCacheKeyQueryStringActionArgs']] = None,
                 cookies_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleCookiesConditionArgs']]]] = None,
                 device_condition: Optional[pulumi.Input['EndpointDeliveryRuleDeviceConditionArgs']] = None,
                 http_version_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleHttpVersionConditionArgs']]]] = None,
                 modify_request_header_actions: Optional[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleModifyRequestHeaderActionArgs']]]] = None,
                 modify_response_header_actions: Optional[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleModifyResponseHeaderActionArgs']]]] = None,
                 post_arg_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRulePostArgConditionArgs']]]] = None,
                 query_string_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleQueryStringConditionArgs']]]] = None,
                 remote_address_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleRemoteAddressConditionArgs']]]] = None,
                 request_body_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleRequestBodyConditionArgs']]]] = None,
                 request_header_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleRequestHeaderConditionArgs']]]] = None,
                 request_method_condition: Optional[pulumi.Input['EndpointDeliveryRuleRequestMethodConditionArgs']] = None,
                 request_scheme_condition: Optional[pulumi.Input['EndpointDeliveryRuleRequestSchemeConditionArgs']] = None,
                 request_uri_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleRequestUriConditionArgs']]]] = None,
                 url_file_extension_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleUrlFileExtensionConditionArgs']]]] = None,
                 url_file_name_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleUrlFileNameConditionArgs']]]] = None,
                 url_path_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleUrlPathConditionArgs']]]] = None,
                 url_redirect_action: Optional[pulumi.Input['EndpointDeliveryRuleUrlRedirectActionArgs']] = None,
                 url_rewrite_action: Optional[pulumi.Input['EndpointDeliveryRuleUrlRewriteActionArgs']] = None):
        """
        :param pulumi.Input[str] name: The Name which should be used for this Delivery Rule.
        :param pulumi.Input[int] order: The order used for this rule. The order values should be sequential and begin at `1`.
        :param pulumi.Input['EndpointDeliveryRuleCacheExpirationActionArgs'] cache_expiration_action: A `cache_expiration_action` block as defined above.
        :param pulumi.Input['EndpointDeliveryRuleCacheKeyQueryStringActionArgs'] cache_key_query_string_action: A `cache_key_query_string_action` block as defined above.
        :param pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleCookiesConditionArgs']]] cookies_conditions: A `cookies_condition` block as defined above.
        :param pulumi.Input['EndpointDeliveryRuleDeviceConditionArgs'] device_condition: A `device_condition` block as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleHttpVersionConditionArgs']]] http_version_conditions: A `http_version_condition` block as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleModifyRequestHeaderActionArgs']]] modify_request_header_actions: A `modify_request_header_action` block as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleModifyResponseHeaderActionArgs']]] modify_response_header_actions: A `modify_response_header_action` block as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRulePostArgConditionArgs']]] post_arg_conditions: A `post_arg_condition` block as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleQueryStringConditionArgs']]] query_string_conditions: A `query_string_condition` block as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleRemoteAddressConditionArgs']]] remote_address_conditions: A `remote_address_condition` block as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleRequestBodyConditionArgs']]] request_body_conditions: A `request_body_condition` block as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleRequestHeaderConditionArgs']]] request_header_conditions: A `request_header_condition` block as defined below.
        :param pulumi.Input['EndpointDeliveryRuleRequestMethodConditionArgs'] request_method_condition: A `request_method_condition` block as defined below.
        :param pulumi.Input['EndpointDeliveryRuleRequestSchemeConditionArgs'] request_scheme_condition: A `request_scheme_condition` block as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleRequestUriConditionArgs']]] request_uri_conditions: A `request_uri_condition` block as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleUrlFileExtensionConditionArgs']]] url_file_extension_conditions: A `url_file_extension_condition` block as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleUrlFileNameConditionArgs']]] url_file_name_conditions: A `url_file_name_condition` block as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleUrlPathConditionArgs']]] url_path_conditions: A `url_path_condition` block as defined below.
        :param pulumi.Input['EndpointDeliveryRuleUrlRedirectActionArgs'] url_redirect_action: A `url_redirect_action` block as defined below.
        :param pulumi.Input['EndpointDeliveryRuleUrlRewriteActionArgs'] url_rewrite_action: A `url_rewrite_action` block as defined below.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "order", order)
        if cache_expiration_action is not None:
            pulumi.set(__self__, "cache_expiration_action", cache_expiration_action)
        if cache_key_query_string_action is not None:
            pulumi.set(__self__, "cache_key_query_string_action", cache_key_query_string_action)
        if cookies_conditions is not None:
            pulumi.set(__self__, "cookies_conditions", cookies_conditions)
        if device_condition is not None:
            pulumi.set(__self__, "device_condition", device_condition)
        if http_version_conditions is not None:
            pulumi.set(__self__, "http_version_conditions", http_version_conditions)
        if modify_request_header_actions is not None:
            pulumi.set(__self__, "modify_request_header_actions", modify_request_header_actions)
        if modify_response_header_actions is not None:
            pulumi.set(__self__, "modify_response_header_actions", modify_response_header_actions)
        if post_arg_conditions is not None:
            pulumi.set(__self__, "post_arg_conditions", post_arg_conditions)
        if query_string_conditions is not None:
            pulumi.set(__self__, "query_string_conditions", query_string_conditions)
        if remote_address_conditions is not None:
            pulumi.set(__self__, "remote_address_conditions", remote_address_conditions)
        if request_body_conditions is not None:
            pulumi.set(__self__, "request_body_conditions", request_body_conditions)
        if request_header_conditions is not None:
            pulumi.set(__self__, "request_header_conditions", request_header_conditions)
        if request_method_condition is not None:
            pulumi.set(__self__, "request_method_condition", request_method_condition)
        if request_scheme_condition is not None:
            pulumi.set(__self__, "request_scheme_condition", request_scheme_condition)
        if request_uri_conditions is not None:
            pulumi.set(__self__, "request_uri_conditions", request_uri_conditions)
        if url_file_extension_conditions is not None:
            pulumi.set(__self__, "url_file_extension_conditions", url_file_extension_conditions)
        if url_file_name_conditions is not None:
            pulumi.set(__self__, "url_file_name_conditions", url_file_name_conditions)
        if url_path_conditions is not None:
            pulumi.set(__self__, "url_path_conditions", url_path_conditions)
        if url_redirect_action is not None:
            pulumi.set(__self__, "url_redirect_action", url_redirect_action)
        if url_rewrite_action is not None:
            pulumi.set(__self__, "url_rewrite_action", url_rewrite_action)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The Name which should be used for this Delivery Rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[int]:
        """
        The order used for this rule. The order values should be sequential and begin at `1`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[int]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter(name="cacheExpirationAction")
    def cache_expiration_action(self) -> Optional[pulumi.Input['EndpointDeliveryRuleCacheExpirationActionArgs']]:
        """
        A `cache_expiration_action` block as defined above.
        """
        return pulumi.get(self, "cache_expiration_action")

    @cache_expiration_action.setter
    def cache_expiration_action(self, value: Optional[pulumi.Input['EndpointDeliveryRuleCacheExpirationActionArgs']]):
        pulumi.set(self, "cache_expiration_action", value)

    @property
    @pulumi.getter(name="cacheKeyQueryStringAction")
    def cache_key_query_string_action(self) -> Optional[pulumi.Input['EndpointDeliveryRuleCacheKeyQueryStringActionArgs']]:
        """
        A `cache_key_query_string_action` block as defined above.
        """
        return pulumi.get(self, "cache_key_query_string_action")

    @cache_key_query_string_action.setter
    def cache_key_query_string_action(self, value: Optional[pulumi.Input['EndpointDeliveryRuleCacheKeyQueryStringActionArgs']]):
        pulumi.set(self, "cache_key_query_string_action", value)

    @property
    @pulumi.getter(name="cookiesConditions")
    def cookies_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleCookiesConditionArgs']]]]:
        """
        A `cookies_condition` block as defined above.
        """
        return pulumi.get(self, "cookies_conditions")

    @cookies_conditions.setter
    def cookies_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleCookiesConditionArgs']]]]):
        pulumi.set(self, "cookies_conditions", value)

    @property
    @pulumi.getter(name="deviceCondition")
    def device_condition(self) -> Optional[pulumi.Input['EndpointDeliveryRuleDeviceConditionArgs']]:
        """
        A `device_condition` block as defined below.
        """
        return pulumi.get(self, "device_condition")

    @device_condition.setter
    def device_condition(self, value: Optional[pulumi.Input['EndpointDeliveryRuleDeviceConditionArgs']]):
        pulumi.set(self, "device_condition", value)

    @property
    @pulumi.getter(name="httpVersionConditions")
    def http_version_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleHttpVersionConditionArgs']]]]:
        """
        A `http_version_condition` block as defined below.
        """
        return pulumi.get(self, "http_version_conditions")

    @http_version_conditions.setter
    def http_version_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleHttpVersionConditionArgs']]]]):
        pulumi.set(self, "http_version_conditions", value)

    @property
    @pulumi.getter(name="modifyRequestHeaderActions")
    def modify_request_header_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleModifyRequestHeaderActionArgs']]]]:
        """
        A `modify_request_header_action` block as defined below.
        """
        return pulumi.get(self, "modify_request_header_actions")

    @modify_request_header_actions.setter
    def modify_request_header_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleModifyRequestHeaderActionArgs']]]]):
        pulumi.set(self, "modify_request_header_actions", value)

    @property
    @pulumi.getter(name="modifyResponseHeaderActions")
    def modify_response_header_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleModifyResponseHeaderActionArgs']]]]:
        """
        A `modify_response_header_action` block as defined below.
        """
        return pulumi.get(self, "modify_response_header_actions")

    @modify_response_header_actions.setter
    def modify_response_header_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleModifyResponseHeaderActionArgs']]]]):
        pulumi.set(self, "modify_response_header_actions", value)

    @property
    @pulumi.getter(name="postArgConditions")
    def post_arg_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRulePostArgConditionArgs']]]]:
        """
        A `post_arg_condition` block as defined below.
        """
        return pulumi.get(self, "post_arg_conditions")

    @post_arg_conditions.setter
    def post_arg_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRulePostArgConditionArgs']]]]):
        pulumi.set(self, "post_arg_conditions", value)

    @property
    @pulumi.getter(name="queryStringConditions")
    def query_string_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleQueryStringConditionArgs']]]]:
        """
        A `query_string_condition` block as defined below.
        """
        return pulumi.get(self, "query_string_conditions")

    @query_string_conditions.setter
    def query_string_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleQueryStringConditionArgs']]]]):
        pulumi.set(self, "query_string_conditions", value)

    @property
    @pulumi.getter(name="remoteAddressConditions")
    def remote_address_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleRemoteAddressConditionArgs']]]]:
        """
        A `remote_address_condition` block as defined below.
        """
        return pulumi.get(self, "remote_address_conditions")

    @remote_address_conditions.setter
    def remote_address_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleRemoteAddressConditionArgs']]]]):
        pulumi.set(self, "remote_address_conditions", value)

    @property
    @pulumi.getter(name="requestBodyConditions")
    def request_body_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleRequestBodyConditionArgs']]]]:
        """
        A `request_body_condition` block as defined below.
        """
        return pulumi.get(self, "request_body_conditions")

    @request_body_conditions.setter
    def request_body_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleRequestBodyConditionArgs']]]]):
        pulumi.set(self, "request_body_conditions", value)

    @property
    @pulumi.getter(name="requestHeaderConditions")
    def request_header_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleRequestHeaderConditionArgs']]]]:
        """
        A `request_header_condition` block as defined below.
        """
        return pulumi.get(self, "request_header_conditions")

    @request_header_conditions.setter
    def request_header_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleRequestHeaderConditionArgs']]]]):
        pulumi.set(self, "request_header_conditions", value)

    @property
    @pulumi.getter(name="requestMethodCondition")
    def request_method_condition(self) -> Optional[pulumi.Input['EndpointDeliveryRuleRequestMethodConditionArgs']]:
        """
        A `request_method_condition` block as defined below.
        """
        return pulumi.get(self, "request_method_condition")

    @request_method_condition.setter
    def request_method_condition(self, value: Optional[pulumi.Input['EndpointDeliveryRuleRequestMethodConditionArgs']]):
        pulumi.set(self, "request_method_condition", value)

    @property
    @pulumi.getter(name="requestSchemeCondition")
    def request_scheme_condition(self) -> Optional[pulumi.Input['EndpointDeliveryRuleRequestSchemeConditionArgs']]:
        """
        A `request_scheme_condition` block as defined below.
        """
        return pulumi.get(self, "request_scheme_condition")

    @request_scheme_condition.setter
    def request_scheme_condition(self, value: Optional[pulumi.Input['EndpointDeliveryRuleRequestSchemeConditionArgs']]):
        pulumi.set(self, "request_scheme_condition", value)

    @property
    @pulumi.getter(name="requestUriConditions")
    def request_uri_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleRequestUriConditionArgs']]]]:
        """
        A `request_uri_condition` block as defined below.
        """
        return pulumi.get(self, "request_uri_conditions")

    @request_uri_conditions.setter
    def request_uri_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleRequestUriConditionArgs']]]]):
        pulumi.set(self, "request_uri_conditions", value)

    @property
    @pulumi.getter(name="urlFileExtensionConditions")
    def url_file_extension_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleUrlFileExtensionConditionArgs']]]]:
        """
        A `url_file_extension_condition` block as defined below.
        """
        return pulumi.get(self, "url_file_extension_conditions")

    @url_file_extension_conditions.setter
    def url_file_extension_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleUrlFileExtensionConditionArgs']]]]):
        pulumi.set(self, "url_file_extension_conditions", value)

    @property
    @pulumi.getter(name="urlFileNameConditions")
    def url_file_name_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleUrlFileNameConditionArgs']]]]:
        """
        A `url_file_name_condition` block as defined below.
        """
        return pulumi.get(self, "url_file_name_conditions")

    @url_file_name_conditions.setter
    def url_file_name_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleUrlFileNameConditionArgs']]]]):
        pulumi.set(self, "url_file_name_conditions", value)

    @property
    @pulumi.getter(name="urlPathConditions")
    def url_path_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleUrlPathConditionArgs']]]]:
        """
        A `url_path_condition` block as defined below.
        """
        return pulumi.get(self, "url_path_conditions")

    @url_path_conditions.setter
    def url_path_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EndpointDeliveryRuleUrlPathConditionArgs']]]]):
        pulumi.set(self, "url_path_conditions", value)

    @property
    @pulumi.getter(name="urlRedirectAction")
    def url_redirect_action(self) -> Optional[pulumi.Input['EndpointDeliveryRuleUrlRedirectActionArgs']]:
        """
        A `url_redirect_action` block as defined below.
        """
        return pulumi.get(self, "url_redirect_action")

    @url_redirect_action.setter
    def url_redirect_action(self, value: Optional[pulumi.Input['EndpointDeliveryRuleUrlRedirectActionArgs']]):
        pulumi.set(self, "url_redirect_action", value)

    @property
    @pulumi.getter(name="urlRewriteAction")
    def url_rewrite_action(self) -> Optional[pulumi.Input['EndpointDeliveryRuleUrlRewriteActionArgs']]:
        """
        A `url_rewrite_action` block as defined below.
        """
        return pulumi.get(self, "url_rewrite_action")

    @url_rewrite_action.setter
    def url_rewrite_action(self, value: Optional[pulumi.Input['EndpointDeliveryRuleUrlRewriteActionArgs']]):
        pulumi.set(self, "url_rewrite_action", value)


if not MYPY:
    class EndpointDeliveryRuleCacheExpirationActionArgsDict(TypedDict):
        behavior: pulumi.Input[str]
        """
        The behavior of the cache. Valid values are `BypassCache`, `Override` and `SetIfMissing`.
        """
        duration: NotRequired[pulumi.Input[str]]
        """
        Duration of the cache. Only allowed when `behavior` is set to `Override` or `SetIfMissing`. Format: `[d.]hh:mm:ss`
        """
elif False:
    EndpointDeliveryRuleCacheExpirationActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EndpointDeliveryRuleCacheExpirationActionArgs:
    def __init__(__self__, *,
                 behavior: pulumi.Input[str],
                 duration: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] behavior: The behavior of the cache. Valid values are `BypassCache`, `Override` and `SetIfMissing`.
        :param pulumi.Input[str] duration: Duration of the cache. Only allowed when `behavior` is set to `Override` or `SetIfMissing`. Format: `[d.]hh:mm:ss`
        """
        pulumi.set(__self__, "behavior", behavior)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)

    @property
    @pulumi.getter
    def behavior(self) -> pulumi.Input[str]:
        """
        The behavior of the cache. Valid values are `BypassCache`, `Override` and `SetIfMissing`.
        """
        return pulumi.get(self, "behavior")

    @behavior.setter
    def behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "behavior", value)

    @property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[str]]:
        """
        Duration of the cache. Only allowed when `behavior` is set to `Override` or `SetIfMissing`. Format: `[d.]hh:mm:ss`
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "duration", value)


if not MYPY:
    class EndpointDeliveryRuleCacheKeyQueryStringActionArgsDict(TypedDict):
        behavior: pulumi.Input[str]
        """
        The behavior of the cache key for query strings. Valid values are `Exclude`, `ExcludeAll`, `Include` and `IncludeAll`.
        """
        parameters: NotRequired[pulumi.Input[str]]
        """
        Comma separated list of parameter values.
        """
elif False:
    EndpointDeliveryRuleCacheKeyQueryStringActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EndpointDeliveryRuleCacheKeyQueryStringActionArgs:
    def __init__(__self__, *,
                 behavior: pulumi.Input[str],
                 parameters: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] behavior: The behavior of the cache key for query strings. Valid values are `Exclude`, `ExcludeAll`, `Include` and `IncludeAll`.
        :param pulumi.Input[str] parameters: Comma separated list of parameter values.
        """
        pulumi.set(__self__, "behavior", behavior)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def behavior(self) -> pulumi.Input[str]:
        """
        The behavior of the cache key for query strings. Valid values are `Exclude`, `ExcludeAll`, `Include` and `IncludeAll`.
        """
        return pulumi.get(self, "behavior")

    @behavior.setter
    def behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "behavior", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[str]]:
        """
        Comma separated list of parameter values.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class EndpointDeliveryRuleCookiesConditionArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        """
        selector: pulumi.Input[str]
        """
        Name of the cookie.
        """
        match_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of values for the cookie. This is required if `operator` is not `Any`.
        """
        negate_condition: NotRequired[pulumi.Input[bool]]
        """
        Defaults to `false`.
        """
        transforms: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
elif False:
    EndpointDeliveryRuleCookiesConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EndpointDeliveryRuleCookiesConditionArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 selector: pulumi.Input[str],
                 match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 transforms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] operator: Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        :param pulumi.Input[str] selector: Name of the cookie.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: List of values for the cookie. This is required if `operator` is not `Any`.
        :param pulumi.Input[bool] negate_condition: Defaults to `false`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] transforms: A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "selector", selector)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def selector(self) -> pulumi.Input[str]:
        """
        Name of the cookie.
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: pulumi.Input[str]):
        pulumi.set(self, "selector", value)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of values for the cookie. This is required if `operator` is not `Any`.
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def transforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        return pulumi.get(self, "transforms")

    @transforms.setter
    def transforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "transforms", value)


if not MYPY:
    class EndpointDeliveryRuleDeviceConditionArgsDict(TypedDict):
        match_values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Valid values are `Desktop` and `Mobile`.
        """
        negate_condition: NotRequired[pulumi.Input[bool]]
        """
        Defaults to `false`.
        """
        operator: NotRequired[pulumi.Input[str]]
        """
        Valid values are `Equal`. Defaults to `Equal`.
        """
elif False:
    EndpointDeliveryRuleDeviceConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EndpointDeliveryRuleDeviceConditionArgs:
    def __init__(__self__, *,
                 match_values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 operator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: Valid values are `Desktop` and `Mobile`.
        :param pulumi.Input[bool] negate_condition: Defaults to `false`.
        :param pulumi.Input[str] operator: Valid values are `Equal`. Defaults to `Equal`.
        """
        pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Valid values are `Desktop` and `Mobile`.
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        Valid values are `Equal`. Defaults to `Equal`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)


if not MYPY:
    class EndpointDeliveryRuleHttpVersionConditionArgsDict(TypedDict):
        match_values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Valid values are `0.9`, `1.0`, `1.1` and `2.0`.
        """
        negate_condition: NotRequired[pulumi.Input[bool]]
        """
        Defaults to `false`.
        """
        operator: NotRequired[pulumi.Input[str]]
        """
        Valid values are `Equal`. Defaults to `Equal`.
        """
elif False:
    EndpointDeliveryRuleHttpVersionConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EndpointDeliveryRuleHttpVersionConditionArgs:
    def __init__(__self__, *,
                 match_values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 operator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: Valid values are `0.9`, `1.0`, `1.1` and `2.0`.
        :param pulumi.Input[bool] negate_condition: Defaults to `false`.
        :param pulumi.Input[str] operator: Valid values are `Equal`. Defaults to `Equal`.
        """
        pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Valid values are `0.9`, `1.0`, `1.1` and `2.0`.
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        Valid values are `Equal`. Defaults to `Equal`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)


if not MYPY:
    class EndpointDeliveryRuleModifyRequestHeaderActionArgsDict(TypedDict):
        action: pulumi.Input[str]
        """
        Action to be executed on a header value. Valid values are `Append`, `Delete` and `Overwrite`.
        """
        name: pulumi.Input[str]
        """
        The header name.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        The value of the header. Only needed when `action` is set to `Append` or `overwrite`.
        """
elif False:
    EndpointDeliveryRuleModifyRequestHeaderActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EndpointDeliveryRuleModifyRequestHeaderActionArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 name: pulumi.Input[str],
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: Action to be executed on a header value. Valid values are `Append`, `Delete` and `Overwrite`.
        :param pulumi.Input[str] name: The header name.
        :param pulumi.Input[str] value: The value of the header. Only needed when `action` is set to `Append` or `overwrite`.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        Action to be executed on a header value. Valid values are `Append`, `Delete` and `Overwrite`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The header name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value of the header. Only needed when `action` is set to `Append` or `overwrite`.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EndpointDeliveryRuleModifyResponseHeaderActionArgsDict(TypedDict):
        action: pulumi.Input[str]
        """
        Action to be executed on a header value. Valid values are `Append`, `Delete` and `Overwrite`.
        """
        name: pulumi.Input[str]
        """
        The header name.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        The value of the header. Only needed when `action` is set to `Append` or `overwrite`.
        """
elif False:
    EndpointDeliveryRuleModifyResponseHeaderActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EndpointDeliveryRuleModifyResponseHeaderActionArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 name: pulumi.Input[str],
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: Action to be executed on a header value. Valid values are `Append`, `Delete` and `Overwrite`.
        :param pulumi.Input[str] name: The header name.
        :param pulumi.Input[str] value: The value of the header. Only needed when `action` is set to `Append` or `overwrite`.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        Action to be executed on a header value. Valid values are `Append`, `Delete` and `Overwrite`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The header name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value of the header. Only needed when `action` is set to `Append` or `overwrite`.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EndpointDeliveryRulePostArgConditionArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        """
        selector: pulumi.Input[str]
        """
        Name of the post arg.
        """
        match_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of string values. This is required if `operator` is not `Any`.
        """
        negate_condition: NotRequired[pulumi.Input[bool]]
        """
        Defaults to `false`.
        """
        transforms: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
elif False:
    EndpointDeliveryRulePostArgConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EndpointDeliveryRulePostArgConditionArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 selector: pulumi.Input[str],
                 match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 transforms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] operator: Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        :param pulumi.Input[str] selector: Name of the post arg.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: List of string values. This is required if `operator` is not `Any`.
        :param pulumi.Input[bool] negate_condition: Defaults to `false`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] transforms: A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "selector", selector)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def selector(self) -> pulumi.Input[str]:
        """
        Name of the post arg.
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: pulumi.Input[str]):
        pulumi.set(self, "selector", value)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of string values. This is required if `operator` is not `Any`.
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def transforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        return pulumi.get(self, "transforms")

    @transforms.setter
    def transforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "transforms", value)


if not MYPY:
    class EndpointDeliveryRuleQueryStringConditionArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        """
        match_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of string values. This is required if `operator` is not `Any`.
        """
        negate_condition: NotRequired[pulumi.Input[bool]]
        """
        Defaults to `false`.
        """
        transforms: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
elif False:
    EndpointDeliveryRuleQueryStringConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EndpointDeliveryRuleQueryStringConditionArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 transforms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] operator: Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: List of string values. This is required if `operator` is not `Any`.
        :param pulumi.Input[bool] negate_condition: Defaults to `false`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] transforms: A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        pulumi.set(__self__, "operator", operator)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of string values. This is required if `operator` is not `Any`.
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def transforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        return pulumi.get(self, "transforms")

    @transforms.setter
    def transforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "transforms", value)


if not MYPY:
    class EndpointDeliveryRuleRemoteAddressConditionArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        Valid values are `Any`, `GeoMatch` and `IPMatch`.
        """
        match_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of string values. For `GeoMatch` `operator` this should be a list of country codes (e.g. `US` or `DE`). List of IP address if `operator` equals to `IPMatch`. This is required if `operator` is not `Any`.
        """
        negate_condition: NotRequired[pulumi.Input[bool]]
        """
        Defaults to `false`.
        """
elif False:
    EndpointDeliveryRuleRemoteAddressConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EndpointDeliveryRuleRemoteAddressConditionArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 negate_condition: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] operator: Valid values are `Any`, `GeoMatch` and `IPMatch`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: List of string values. For `GeoMatch` `operator` this should be a list of country codes (e.g. `US` or `DE`). List of IP address if `operator` equals to `IPMatch`. This is required if `operator` is not `Any`.
        :param pulumi.Input[bool] negate_condition: Defaults to `false`.
        """
        pulumi.set(__self__, "operator", operator)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        Valid values are `Any`, `GeoMatch` and `IPMatch`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of string values. For `GeoMatch` `operator` this should be a list of country codes (e.g. `US` or `DE`). List of IP address if `operator` equals to `IPMatch`. This is required if `operator` is not `Any`.
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)


if not MYPY:
    class EndpointDeliveryRuleRequestBodyConditionArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        """
        match_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of string values. This is required if `operator` is not `Any`.
        """
        negate_condition: NotRequired[pulumi.Input[bool]]
        """
        Defaults to `false`.
        """
        transforms: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
elif False:
    EndpointDeliveryRuleRequestBodyConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EndpointDeliveryRuleRequestBodyConditionArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 transforms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] operator: Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: List of string values. This is required if `operator` is not `Any`.
        :param pulumi.Input[bool] negate_condition: Defaults to `false`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] transforms: A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        pulumi.set(__self__, "operator", operator)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of string values. This is required if `operator` is not `Any`.
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def transforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        return pulumi.get(self, "transforms")

    @transforms.setter
    def transforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "transforms", value)


if not MYPY:
    class EndpointDeliveryRuleRequestHeaderConditionArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        """
        selector: pulumi.Input[str]
        """
        Header name.
        """
        match_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of header values. This is required if `operator` is not `Any`.
        """
        negate_condition: NotRequired[pulumi.Input[bool]]
        """
        Defaults to `false`.
        """
        transforms: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
elif False:
    EndpointDeliveryRuleRequestHeaderConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EndpointDeliveryRuleRequestHeaderConditionArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 selector: pulumi.Input[str],
                 match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 transforms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] operator: Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        :param pulumi.Input[str] selector: Header name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: List of header values. This is required if `operator` is not `Any`.
        :param pulumi.Input[bool] negate_condition: Defaults to `false`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] transforms: A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "selector", selector)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def selector(self) -> pulumi.Input[str]:
        """
        Header name.
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: pulumi.Input[str]):
        pulumi.set(self, "selector", value)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of header values. This is required if `operator` is not `Any`.
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def transforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        return pulumi.get(self, "transforms")

    @transforms.setter
    def transforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "transforms", value)


if not MYPY:
    class EndpointDeliveryRuleRequestMethodConditionArgsDict(TypedDict):
        match_values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Valid values are `DELETE`, `GET`, `HEAD`, `OPTIONS`, `POST` and `PUT`.
        """
        negate_condition: NotRequired[pulumi.Input[bool]]
        """
        Defaults to `false`.
        """
        operator: NotRequired[pulumi.Input[str]]
        """
        Valid values are `Equal`. Defaults to `Equal`.
        """
elif False:
    EndpointDeliveryRuleRequestMethodConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EndpointDeliveryRuleRequestMethodConditionArgs:
    def __init__(__self__, *,
                 match_values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 operator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: Valid values are `DELETE`, `GET`, `HEAD`, `OPTIONS`, `POST` and `PUT`.
        :param pulumi.Input[bool] negate_condition: Defaults to `false`.
        :param pulumi.Input[str] operator: Valid values are `Equal`. Defaults to `Equal`.
        """
        pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Valid values are `DELETE`, `GET`, `HEAD`, `OPTIONS`, `POST` and `PUT`.
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        Valid values are `Equal`. Defaults to `Equal`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)


if not MYPY:
    class EndpointDeliveryRuleRequestSchemeConditionArgsDict(TypedDict):
        match_values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Valid values are `HTTP` and `HTTPS`.
        """
        negate_condition: NotRequired[pulumi.Input[bool]]
        """
        Defaults to `false`.
        """
        operator: NotRequired[pulumi.Input[str]]
        """
        Valid values are `Equal`. Defaults to `Equal`.
        """
elif False:
    EndpointDeliveryRuleRequestSchemeConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EndpointDeliveryRuleRequestSchemeConditionArgs:
    def __init__(__self__, *,
                 match_values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 operator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: Valid values are `HTTP` and `HTTPS`.
        :param pulumi.Input[bool] negate_condition: Defaults to `false`.
        :param pulumi.Input[str] operator: Valid values are `Equal`. Defaults to `Equal`.
        """
        pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Valid values are `HTTP` and `HTTPS`.
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        Valid values are `Equal`. Defaults to `Equal`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)


if not MYPY:
    class EndpointDeliveryRuleRequestUriConditionArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        """
        match_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of string values. This is required if `operator` is not `Any`.
        """
        negate_condition: NotRequired[pulumi.Input[bool]]
        """
        Defaults to `false`.
        """
        transforms: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
elif False:
    EndpointDeliveryRuleRequestUriConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EndpointDeliveryRuleRequestUriConditionArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 transforms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] operator: Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: List of string values. This is required if `operator` is not `Any`.
        :param pulumi.Input[bool] negate_condition: Defaults to `false`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] transforms: A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        pulumi.set(__self__, "operator", operator)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of string values. This is required if `operator` is not `Any`.
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def transforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        return pulumi.get(self, "transforms")

    @transforms.setter
    def transforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "transforms", value)


if not MYPY:
    class EndpointDeliveryRuleUrlFileExtensionConditionArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        """
        match_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of string values. This is required if `operator` is not `Any`.
        """
        negate_condition: NotRequired[pulumi.Input[bool]]
        """
        Defaults to `false`.
        """
        transforms: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
elif False:
    EndpointDeliveryRuleUrlFileExtensionConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EndpointDeliveryRuleUrlFileExtensionConditionArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 transforms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] operator: Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: List of string values. This is required if `operator` is not `Any`.
        :param pulumi.Input[bool] negate_condition: Defaults to `false`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] transforms: A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        pulumi.set(__self__, "operator", operator)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of string values. This is required if `operator` is not `Any`.
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def transforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        return pulumi.get(self, "transforms")

    @transforms.setter
    def transforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "transforms", value)


if not MYPY:
    class EndpointDeliveryRuleUrlFileNameConditionArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        """
        match_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of string values. This is required if `operator` is not `Any`.
        """
        negate_condition: NotRequired[pulumi.Input[bool]]
        """
        Defaults to `false`.
        """
        transforms: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
elif False:
    EndpointDeliveryRuleUrlFileNameConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EndpointDeliveryRuleUrlFileNameConditionArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 transforms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] operator: Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: List of string values. This is required if `operator` is not `Any`.
        :param pulumi.Input[bool] negate_condition: Defaults to `false`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] transforms: A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        pulumi.set(__self__, "operator", operator)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of string values. This is required if `operator` is not `Any`.
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def transforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        return pulumi.get(self, "transforms")

    @transforms.setter
    def transforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "transforms", value)


if not MYPY:
    class EndpointDeliveryRuleUrlPathConditionArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan`, `LessThanOrEqual`, `RegEx` and `Wildcard`.
        """
        match_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of string values. This is required if `operator` is not `Any`.
        """
        negate_condition: NotRequired[pulumi.Input[bool]]
        """
        Defaults to `false`.
        """
        transforms: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
elif False:
    EndpointDeliveryRuleUrlPathConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EndpointDeliveryRuleUrlPathConditionArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 transforms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] operator: Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan`, `LessThanOrEqual`, `RegEx` and `Wildcard`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: List of string values. This is required if `operator` is not `Any`.
        :param pulumi.Input[bool] negate_condition: Defaults to `false`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] transforms: A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        pulumi.set(__self__, "operator", operator)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan`, `LessThanOrEqual`, `RegEx` and `Wildcard`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of string values. This is required if `operator` is not `Any`.
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def transforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of transforms. Valid values are `Lowercase` and `Uppercase`.
        """
        return pulumi.get(self, "transforms")

    @transforms.setter
    def transforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "transforms", value)


if not MYPY:
    class EndpointDeliveryRuleUrlRedirectActionArgsDict(TypedDict):
        redirect_type: pulumi.Input[str]
        """
        Type of the redirect. Valid values are `Found`, `Moved`, `PermanentRedirect` and `TemporaryRedirect`.
        """
        fragment: NotRequired[pulumi.Input[str]]
        """
        Specifies the fragment part of the URL. This value must not start with a `#`.
        """
        hostname: NotRequired[pulumi.Input[str]]
        """
        Specifies the hostname part of the URL.
        """
        path: NotRequired[pulumi.Input[str]]
        """
        Specifies the path part of the URL. This value must begin with a `/`.
        """
        protocol: NotRequired[pulumi.Input[str]]
        """
        Specifies the protocol part of the URL. Valid values are `MatchRequest`, `Http` and `Https`. Defaults to `MatchRequest`.
        """
        query_string: NotRequired[pulumi.Input[str]]
        """
        Specifies the query string part of the URL. This value must not start with a `?` or `&` and must be in `<key>=<value>` format separated by `&`.
        """
elif False:
    EndpointDeliveryRuleUrlRedirectActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EndpointDeliveryRuleUrlRedirectActionArgs:
    def __init__(__self__, *,
                 redirect_type: pulumi.Input[str],
                 fragment: Optional[pulumi.Input[str]] = None,
                 hostname: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 query_string: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] redirect_type: Type of the redirect. Valid values are `Found`, `Moved`, `PermanentRedirect` and `TemporaryRedirect`.
        :param pulumi.Input[str] fragment: Specifies the fragment part of the URL. This value must not start with a `#`.
        :param pulumi.Input[str] hostname: Specifies the hostname part of the URL.
        :param pulumi.Input[str] path: Specifies the path part of the URL. This value must begin with a `/`.
        :param pulumi.Input[str] protocol: Specifies the protocol part of the URL. Valid values are `MatchRequest`, `Http` and `Https`. Defaults to `MatchRequest`.
        :param pulumi.Input[str] query_string: Specifies the query string part of the URL. This value must not start with a `?` or `&` and must be in `<key>=<value>` format separated by `&`.
        """
        pulumi.set(__self__, "redirect_type", redirect_type)
        if fragment is not None:
            pulumi.set(__self__, "fragment", fragment)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)

    @property
    @pulumi.getter(name="redirectType")
    def redirect_type(self) -> pulumi.Input[str]:
        """
        Type of the redirect. Valid values are `Found`, `Moved`, `PermanentRedirect` and `TemporaryRedirect`.
        """
        return pulumi.get(self, "redirect_type")

    @redirect_type.setter
    def redirect_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "redirect_type", value)

    @property
    @pulumi.getter
    def fragment(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the fragment part of the URL. This value must not start with a `#`.
        """
        return pulumi.get(self, "fragment")

    @fragment.setter
    def fragment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fragment", value)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the hostname part of the URL.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the path part of the URL. This value must begin with a `/`.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the protocol part of the URL. Valid values are `MatchRequest`, `Http` and `Https`. Defaults to `MatchRequest`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the query string part of the URL. This value must not start with a `?` or `&` and must be in `<key>=<value>` format separated by `&`.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query_string", value)


if not MYPY:
    class EndpointDeliveryRuleUrlRewriteActionArgsDict(TypedDict):
        destination: pulumi.Input[str]
        """
        This value must start with a `/` and can't be longer than 260 characters.
        """
        source_pattern: pulumi.Input[str]
        """
        This value must start with a `/` and can't be longer than 260 characters.
        """
        preserve_unmatched_path: NotRequired[pulumi.Input[bool]]
        """
        Whether preserve an unmatched path. Defaults to `true`.
        """
elif False:
    EndpointDeliveryRuleUrlRewriteActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EndpointDeliveryRuleUrlRewriteActionArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str],
                 source_pattern: pulumi.Input[str],
                 preserve_unmatched_path: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] destination: This value must start with a `/` and can't be longer than 260 characters.
        :param pulumi.Input[str] source_pattern: This value must start with a `/` and can't be longer than 260 characters.
        :param pulumi.Input[bool] preserve_unmatched_path: Whether preserve an unmatched path. Defaults to `true`.
        """
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "source_pattern", source_pattern)
        if preserve_unmatched_path is not None:
            pulumi.set(__self__, "preserve_unmatched_path", preserve_unmatched_path)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        """
        This value must start with a `/` and can't be longer than 260 characters.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="sourcePattern")
    def source_pattern(self) -> pulumi.Input[str]:
        """
        This value must start with a `/` and can't be longer than 260 characters.
        """
        return pulumi.get(self, "source_pattern")

    @source_pattern.setter
    def source_pattern(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_pattern", value)

    @property
    @pulumi.getter(name="preserveUnmatchedPath")
    def preserve_unmatched_path(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether preserve an unmatched path. Defaults to `true`.
        """
        return pulumi.get(self, "preserve_unmatched_path")

    @preserve_unmatched_path.setter
    def preserve_unmatched_path(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preserve_unmatched_path", value)


if not MYPY:
    class EndpointGeoFilterArgsDict(TypedDict):
        action: pulumi.Input[str]
        """
        The Action of the Geo Filter. Possible values include `Allow` and `Block`.
        """
        country_codes: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A List of two letter country codes (e.g. `US`, `GB`) to be associated with this Geo Filter.
        """
        relative_path: pulumi.Input[str]
        """
        The relative path applicable to geo filter.
        """
elif False:
    EndpointGeoFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EndpointGeoFilterArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 country_codes: pulumi.Input[Sequence[pulumi.Input[str]]],
                 relative_path: pulumi.Input[str]):
        """
        :param pulumi.Input[str] action: The Action of the Geo Filter. Possible values include `Allow` and `Block`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] country_codes: A List of two letter country codes (e.g. `US`, `GB`) to be associated with this Geo Filter.
        :param pulumi.Input[str] relative_path: The relative path applicable to geo filter.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "country_codes", country_codes)
        pulumi.set(__self__, "relative_path", relative_path)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        The Action of the Geo Filter. Possible values include `Allow` and `Block`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="countryCodes")
    def country_codes(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A List of two letter country codes (e.g. `US`, `GB`) to be associated with this Geo Filter.
        """
        return pulumi.get(self, "country_codes")

    @country_codes.setter
    def country_codes(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "country_codes", value)

    @property
    @pulumi.getter(name="relativePath")
    def relative_path(self) -> pulumi.Input[str]:
        """
        The relative path applicable to geo filter.
        """
        return pulumi.get(self, "relative_path")

    @relative_path.setter
    def relative_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "relative_path", value)


if not MYPY:
    class EndpointGlobalDeliveryRuleArgsDict(TypedDict):
        cache_expiration_action: NotRequired[pulumi.Input['EndpointGlobalDeliveryRuleCacheExpirationActionArgsDict']]
        """
        A `cache_expiration_action` block as defined above.
        """
        cache_key_query_string_action: NotRequired[pulumi.Input['EndpointGlobalDeliveryRuleCacheKeyQueryStringActionArgsDict']]
        """
        A `cache_key_query_string_action` block as defined above.
        """
        modify_request_header_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['EndpointGlobalDeliveryRuleModifyRequestHeaderActionArgsDict']]]]
        """
        A `modify_request_header_action` block as defined below.
        """
        modify_response_header_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['EndpointGlobalDeliveryRuleModifyResponseHeaderActionArgsDict']]]]
        """
        A `modify_response_header_action` block as defined below.
        """
        url_redirect_action: NotRequired[pulumi.Input['EndpointGlobalDeliveryRuleUrlRedirectActionArgsDict']]
        """
        A `url_redirect_action` block as defined below.
        """
        url_rewrite_action: NotRequired[pulumi.Input['EndpointGlobalDeliveryRuleUrlRewriteActionArgsDict']]
        """
        A `url_rewrite_action` block as defined below.
        """
elif False:
    EndpointGlobalDeliveryRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EndpointGlobalDeliveryRuleArgs:
    def __init__(__self__, *,
                 cache_expiration_action: Optional[pulumi.Input['EndpointGlobalDeliveryRuleCacheExpirationActionArgs']] = None,
                 cache_key_query_string_action: Optional[pulumi.Input['EndpointGlobalDeliveryRuleCacheKeyQueryStringActionArgs']] = None,
                 modify_request_header_actions: Optional[pulumi.Input[Sequence[pulumi.Input['EndpointGlobalDeliveryRuleModifyRequestHeaderActionArgs']]]] = None,
                 modify_response_header_actions: Optional[pulumi.Input[Sequence[pulumi.Input['EndpointGlobalDeliveryRuleModifyResponseHeaderActionArgs']]]] = None,
                 url_redirect_action: Optional[pulumi.Input['EndpointGlobalDeliveryRuleUrlRedirectActionArgs']] = None,
                 url_rewrite_action: Optional[pulumi.Input['EndpointGlobalDeliveryRuleUrlRewriteActionArgs']] = None):
        """
        :param pulumi.Input['EndpointGlobalDeliveryRuleCacheExpirationActionArgs'] cache_expiration_action: A `cache_expiration_action` block as defined above.
        :param pulumi.Input['EndpointGlobalDeliveryRuleCacheKeyQueryStringActionArgs'] cache_key_query_string_action: A `cache_key_query_string_action` block as defined above.
        :param pulumi.Input[Sequence[pulumi.Input['EndpointGlobalDeliveryRuleModifyRequestHeaderActionArgs']]] modify_request_header_actions: A `modify_request_header_action` block as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['EndpointGlobalDeliveryRuleModifyResponseHeaderActionArgs']]] modify_response_header_actions: A `modify_response_header_action` block as defined below.
        :param pulumi.Input['EndpointGlobalDeliveryRuleUrlRedirectActionArgs'] url_redirect_action: A `url_redirect_action` block as defined below.
        :param pulumi.Input['EndpointGlobalDeliveryRuleUrlRewriteActionArgs'] url_rewrite_action: A `url_rewrite_action` block as defined below.
        """
        if cache_expiration_action is not None:
            pulumi.set(__self__, "cache_expiration_action", cache_expiration_action)
        if cache_key_query_string_action is not None:
            pulumi.set(__self__, "cache_key_query_string_action", cache_key_query_string_action)
        if modify_request_header_actions is not None:
            pulumi.set(__self__, "modify_request_header_actions", modify_request_header_actions)
        if modify_response_header_actions is not None:
            pulumi.set(__self__, "modify_response_header_actions", modify_response_header_actions)
        if url_redirect_action is not None:
            pulumi.set(__self__, "url_redirect_action", url_redirect_action)
        if url_rewrite_action is not None:
            pulumi.set(__self__, "url_rewrite_action", url_rewrite_action)

    @property
    @pulumi.getter(name="cacheExpirationAction")
    def cache_expiration_action(self) -> Optional[pulumi.Input['EndpointGlobalDeliveryRuleCacheExpirationActionArgs']]:
        """
        A `cache_expiration_action` block as defined above.
        """
        return pulumi.get(self, "cache_expiration_action")

    @cache_expiration_action.setter
    def cache_expiration_action(self, value: Optional[pulumi.Input['EndpointGlobalDeliveryRuleCacheExpirationActionArgs']]):
        pulumi.set(self, "cache_expiration_action", value)

    @property
    @pulumi.getter(name="cacheKeyQueryStringAction")
    def cache_key_query_string_action(self) -> Optional[pulumi.Input['EndpointGlobalDeliveryRuleCacheKeyQueryStringActionArgs']]:
        """
        A `cache_key_query_string_action` block as defined above.
        """
        return pulumi.get(self, "cache_key_query_string_action")

    @cache_key_query_string_action.setter
    def cache_key_query_string_action(self, value: Optional[pulumi.Input['EndpointGlobalDeliveryRuleCacheKeyQueryStringActionArgs']]):
        pulumi.set(self, "cache_key_query_string_action", value)

    @property
    @pulumi.getter(name="modifyRequestHeaderActions")
    def modify_request_header_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EndpointGlobalDeliveryRuleModifyRequestHeaderActionArgs']]]]:
        """
        A `modify_request_header_action` block as defined below.
        """
        return pulumi.get(self, "modify_request_header_actions")

    @modify_request_header_actions.setter
    def modify_request_header_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EndpointGlobalDeliveryRuleModifyRequestHeaderActionArgs']]]]):
        pulumi.set(self, "modify_request_header_actions", value)

    @property
    @pulumi.getter(name="modifyResponseHeaderActions")
    def modify_response_header_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EndpointGlobalDeliveryRuleModifyResponseHeaderActionArgs']]]]:
        """
        A `modify_response_header_action` block as defined below.
        """
        return pulumi.get(self, "modify_response_header_actions")

    @modify_response_header_actions.setter
    def modify_response_header_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EndpointGlobalDeliveryRuleModifyResponseHeaderActionArgs']]]]):
        pulumi.set(self, "modify_response_header_actions", value)

    @property
    @pulumi.getter(name="urlRedirectAction")
    def url_redirect_action(self) -> Optional[pulumi.Input['EndpointGlobalDeliveryRuleUrlRedirectActionArgs']]:
        """
        A `url_redirect_action` block as defined below.
        """
        return pulumi.get(self, "url_redirect_action")

    @url_redirect_action.setter
    def url_redirect_action(self, value: Optional[pulumi.Input['EndpointGlobalDeliveryRuleUrlRedirectActionArgs']]):
        pulumi.set(self, "url_redirect_action", value)

    @property
    @pulumi.getter(name="urlRewriteAction")
    def url_rewrite_action(self) -> Optional[pulumi.Input['EndpointGlobalDeliveryRuleUrlRewriteActionArgs']]:
        """
        A `url_rewrite_action` block as defined below.
        """
        return pulumi.get(self, "url_rewrite_action")

    @url_rewrite_action.setter
    def url_rewrite_action(self, value: Optional[pulumi.Input['EndpointGlobalDeliveryRuleUrlRewriteActionArgs']]):
        pulumi.set(self, "url_rewrite_action", value)


if not MYPY:
    class EndpointGlobalDeliveryRuleCacheExpirationActionArgsDict(TypedDict):
        behavior: pulumi.Input[str]
        """
        The behavior of the cache. Valid values are `BypassCache`, `Override` and `SetIfMissing`.
        """
        duration: NotRequired[pulumi.Input[str]]
        """
        Duration of the cache. Only allowed when `behavior` is set to `Override` or `SetIfMissing`. Format: `[d.]hh:mm:ss`
        """
elif False:
    EndpointGlobalDeliveryRuleCacheExpirationActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EndpointGlobalDeliveryRuleCacheExpirationActionArgs:
    def __init__(__self__, *,
                 behavior: pulumi.Input[str],
                 duration: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] behavior: The behavior of the cache. Valid values are `BypassCache`, `Override` and `SetIfMissing`.
        :param pulumi.Input[str] duration: Duration of the cache. Only allowed when `behavior` is set to `Override` or `SetIfMissing`. Format: `[d.]hh:mm:ss`
        """
        pulumi.set(__self__, "behavior", behavior)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)

    @property
    @pulumi.getter
    def behavior(self) -> pulumi.Input[str]:
        """
        The behavior of the cache. Valid values are `BypassCache`, `Override` and `SetIfMissing`.
        """
        return pulumi.get(self, "behavior")

    @behavior.setter
    def behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "behavior", value)

    @property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[str]]:
        """
        Duration of the cache. Only allowed when `behavior` is set to `Override` or `SetIfMissing`. Format: `[d.]hh:mm:ss`
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "duration", value)


if not MYPY:
    class EndpointGlobalDeliveryRuleCacheKeyQueryStringActionArgsDict(TypedDict):
        behavior: pulumi.Input[str]
        """
        The behavior of the cache key for query strings. Valid values are `Exclude`, `ExcludeAll`, `Include` and `IncludeAll`.
        """
        parameters: NotRequired[pulumi.Input[str]]
        """
        Comma separated list of parameter values.
        """
elif False:
    EndpointGlobalDeliveryRuleCacheKeyQueryStringActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EndpointGlobalDeliveryRuleCacheKeyQueryStringActionArgs:
    def __init__(__self__, *,
                 behavior: pulumi.Input[str],
                 parameters: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] behavior: The behavior of the cache key for query strings. Valid values are `Exclude`, `ExcludeAll`, `Include` and `IncludeAll`.
        :param pulumi.Input[str] parameters: Comma separated list of parameter values.
        """
        pulumi.set(__self__, "behavior", behavior)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def behavior(self) -> pulumi.Input[str]:
        """
        The behavior of the cache key for query strings. Valid values are `Exclude`, `ExcludeAll`, `Include` and `IncludeAll`.
        """
        return pulumi.get(self, "behavior")

    @behavior.setter
    def behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "behavior", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[str]]:
        """
        Comma separated list of parameter values.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class EndpointGlobalDeliveryRuleModifyRequestHeaderActionArgsDict(TypedDict):
        action: pulumi.Input[str]
        """
        Action to be executed on a header value. Valid values are `Append`, `Delete` and `Overwrite`.
        """
        name: pulumi.Input[str]
        """
        The header name.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        The value of the header. Only needed when `action` is set to `Append` or `overwrite`.
        """
elif False:
    EndpointGlobalDeliveryRuleModifyRequestHeaderActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EndpointGlobalDeliveryRuleModifyRequestHeaderActionArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 name: pulumi.Input[str],
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: Action to be executed on a header value. Valid values are `Append`, `Delete` and `Overwrite`.
        :param pulumi.Input[str] name: The header name.
        :param pulumi.Input[str] value: The value of the header. Only needed when `action` is set to `Append` or `overwrite`.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        Action to be executed on a header value. Valid values are `Append`, `Delete` and `Overwrite`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The header name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value of the header. Only needed when `action` is set to `Append` or `overwrite`.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EndpointGlobalDeliveryRuleModifyResponseHeaderActionArgsDict(TypedDict):
        action: pulumi.Input[str]
        """
        Action to be executed on a header value. Valid values are `Append`, `Delete` and `Overwrite`.
        """
        name: pulumi.Input[str]
        """
        The header name.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        The value of the header. Only needed when `action` is set to `Append` or `overwrite`.
        """
elif False:
    EndpointGlobalDeliveryRuleModifyResponseHeaderActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EndpointGlobalDeliveryRuleModifyResponseHeaderActionArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 name: pulumi.Input[str],
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: Action to be executed on a header value. Valid values are `Append`, `Delete` and `Overwrite`.
        :param pulumi.Input[str] name: The header name.
        :param pulumi.Input[str] value: The value of the header. Only needed when `action` is set to `Append` or `overwrite`.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        Action to be executed on a header value. Valid values are `Append`, `Delete` and `Overwrite`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The header name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value of the header. Only needed when `action` is set to `Append` or `overwrite`.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EndpointGlobalDeliveryRuleUrlRedirectActionArgsDict(TypedDict):
        redirect_type: pulumi.Input[str]
        """
        Type of the redirect. Valid values are `Found`, `Moved`, `PermanentRedirect` and `TemporaryRedirect`.
        """
        fragment: NotRequired[pulumi.Input[str]]
        """
        Specifies the fragment part of the URL. This value must not start with a `#`.
        """
        hostname: NotRequired[pulumi.Input[str]]
        """
        Specifies the hostname part of the URL.
        """
        path: NotRequired[pulumi.Input[str]]
        """
        Specifies the path part of the URL. This value must begin with a `/`.
        """
        protocol: NotRequired[pulumi.Input[str]]
        """
        Specifies the protocol part of the URL. Valid values are `MatchRequest`, `Http` and `Https`. Defaults to `MatchRequest`.
        """
        query_string: NotRequired[pulumi.Input[str]]
        """
        Specifies the query string part of the URL. This value must not start with a `?` or `&` and must be in `<key>=<value>` format separated by `&`.
        """
elif False:
    EndpointGlobalDeliveryRuleUrlRedirectActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EndpointGlobalDeliveryRuleUrlRedirectActionArgs:
    def __init__(__self__, *,
                 redirect_type: pulumi.Input[str],
                 fragment: Optional[pulumi.Input[str]] = None,
                 hostname: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 query_string: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] redirect_type: Type of the redirect. Valid values are `Found`, `Moved`, `PermanentRedirect` and `TemporaryRedirect`.
        :param pulumi.Input[str] fragment: Specifies the fragment part of the URL. This value must not start with a `#`.
        :param pulumi.Input[str] hostname: Specifies the hostname part of the URL.
        :param pulumi.Input[str] path: Specifies the path part of the URL. This value must begin with a `/`.
        :param pulumi.Input[str] protocol: Specifies the protocol part of the URL. Valid values are `MatchRequest`, `Http` and `Https`. Defaults to `MatchRequest`.
        :param pulumi.Input[str] query_string: Specifies the query string part of the URL. This value must not start with a `?` or `&` and must be in `<key>=<value>` format separated by `&`.
        """
        pulumi.set(__self__, "redirect_type", redirect_type)
        if fragment is not None:
            pulumi.set(__self__, "fragment", fragment)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)

    @property
    @pulumi.getter(name="redirectType")
    def redirect_type(self) -> pulumi.Input[str]:
        """
        Type of the redirect. Valid values are `Found`, `Moved`, `PermanentRedirect` and `TemporaryRedirect`.
        """
        return pulumi.get(self, "redirect_type")

    @redirect_type.setter
    def redirect_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "redirect_type", value)

    @property
    @pulumi.getter
    def fragment(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the fragment part of the URL. This value must not start with a `#`.
        """
        return pulumi.get(self, "fragment")

    @fragment.setter
    def fragment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fragment", value)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the hostname part of the URL.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the path part of the URL. This value must begin with a `/`.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the protocol part of the URL. Valid values are `MatchRequest`, `Http` and `Https`. Defaults to `MatchRequest`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the query string part of the URL. This value must not start with a `?` or `&` and must be in `<key>=<value>` format separated by `&`.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query_string", value)


if not MYPY:
    class EndpointGlobalDeliveryRuleUrlRewriteActionArgsDict(TypedDict):
        destination: pulumi.Input[str]
        """
        This value must start with a `/` and can't be longer than 260 characters.
        """
        source_pattern: pulumi.Input[str]
        """
        This value must start with a `/` and can't be longer than 260 characters.
        """
        preserve_unmatched_path: NotRequired[pulumi.Input[bool]]
        """
        Whether preserve an unmatched path. Defaults to `true`.
        """
elif False:
    EndpointGlobalDeliveryRuleUrlRewriteActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EndpointGlobalDeliveryRuleUrlRewriteActionArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str],
                 source_pattern: pulumi.Input[str],
                 preserve_unmatched_path: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] destination: This value must start with a `/` and can't be longer than 260 characters.
        :param pulumi.Input[str] source_pattern: This value must start with a `/` and can't be longer than 260 characters.
        :param pulumi.Input[bool] preserve_unmatched_path: Whether preserve an unmatched path. Defaults to `true`.
        """
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "source_pattern", source_pattern)
        if preserve_unmatched_path is not None:
            pulumi.set(__self__, "preserve_unmatched_path", preserve_unmatched_path)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        """
        This value must start with a `/` and can't be longer than 260 characters.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="sourcePattern")
    def source_pattern(self) -> pulumi.Input[str]:
        """
        This value must start with a `/` and can't be longer than 260 characters.
        """
        return pulumi.get(self, "source_pattern")

    @source_pattern.setter
    def source_pattern(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_pattern", value)

    @property
    @pulumi.getter(name="preserveUnmatchedPath")
    def preserve_unmatched_path(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether preserve an unmatched path. Defaults to `true`.
        """
        return pulumi.get(self, "preserve_unmatched_path")

    @preserve_unmatched_path.setter
    def preserve_unmatched_path(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preserve_unmatched_path", value)


if not MYPY:
    class EndpointOriginArgsDict(TypedDict):
        host_name: pulumi.Input[str]
        """
        A string that determines the hostname/IP address of the origin server. This string can be a domain name, Storage Account endpoint, Web App endpoint, IPv4 address or IPv6 address. Changing this forces a new resource to be created.
        """
        name: pulumi.Input[str]
        """
        The name of the origin. This is an arbitrary value. However, this value needs to be unique under the endpoint. Changing this forces a new resource to be created.
        """
        http_port: NotRequired[pulumi.Input[int]]
        """
        The HTTP port of the origin. Defaults to `80`. Changing this forces a new resource to be created.
        """
        https_port: NotRequired[pulumi.Input[int]]
        """
        The HTTPS port of the origin. Defaults to `443`. Changing this forces a new resource to be created.
        """
elif False:
    EndpointOriginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EndpointOriginArgs:
    def __init__(__self__, *,
                 host_name: pulumi.Input[str],
                 name: pulumi.Input[str],
                 http_port: Optional[pulumi.Input[int]] = None,
                 https_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] host_name: A string that determines the hostname/IP address of the origin server. This string can be a domain name, Storage Account endpoint, Web App endpoint, IPv4 address or IPv6 address. Changing this forces a new resource to be created.
        :param pulumi.Input[str] name: The name of the origin. This is an arbitrary value. However, this value needs to be unique under the endpoint. Changing this forces a new resource to be created.
        :param pulumi.Input[int] http_port: The HTTP port of the origin. Defaults to `80`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] https_port: The HTTPS port of the origin. Defaults to `443`. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "host_name", host_name)
        pulumi.set(__self__, "name", name)
        if http_port is not None:
            pulumi.set(__self__, "http_port", http_port)
        if https_port is not None:
            pulumi.set(__self__, "https_port", https_port)

    @property
    @pulumi.getter(name="hostName")
    def host_name(self) -> pulumi.Input[str]:
        """
        A string that determines the hostname/IP address of the origin server. This string can be a domain name, Storage Account endpoint, Web App endpoint, IPv4 address or IPv6 address. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "host_name")

    @host_name.setter
    def host_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "host_name", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the origin. This is an arbitrary value. However, this value needs to be unique under the endpoint. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> Optional[pulumi.Input[int]]:
        """
        The HTTP port of the origin. Defaults to `80`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "http_port")

    @http_port.setter
    def http_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "http_port", value)

    @property
    @pulumi.getter(name="httpsPort")
    def https_port(self) -> Optional[pulumi.Input[int]]:
        """
        The HTTPS port of the origin. Defaults to `443`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "https_port")

    @https_port.setter
    def https_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "https_port", value)


if not MYPY:
    class FrontdoorCustomDomainTlsArgsDict(TypedDict):
        cdn_frontdoor_secret_id: NotRequired[pulumi.Input[str]]
        """
        Resource ID of the Front Door Secret.
        """
        certificate_type: NotRequired[pulumi.Input[str]]
        """
        Defines the source of the SSL certificate. Possible values include `CustomerCertificate` and `ManagedCertificate`. Defaults to `ManagedCertificate`.

        ->**Note:** It may take up to 15 minutes for the Front Door Service to validate the state and Domain ownership of the Custom Domain.
        """
        minimum_tls_version: NotRequired[pulumi.Input[str]]
        """
        TLS protocol version that will be used for Https. Possible values are `TLS12`. Defaults to `TLS12`.

        > **Note:** On March 1, 2025, support for Transport Layer Security (TLS) 1.0 and 1.1 will be retired for Azure Front Door, all connections to Azure Front Door must employ `TLS 1.2` or later, please see the product [announcement](https://azure.microsoft.com/en-us/updates/v2/update-retirement-tls1-0-tls1-1-versions-azure-services/) for more details.
        """
elif False:
    FrontdoorCustomDomainTlsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontdoorCustomDomainTlsArgs:
    def __init__(__self__, *,
                 cdn_frontdoor_secret_id: Optional[pulumi.Input[str]] = None,
                 certificate_type: Optional[pulumi.Input[str]] = None,
                 minimum_tls_version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cdn_frontdoor_secret_id: Resource ID of the Front Door Secret.
        :param pulumi.Input[str] certificate_type: Defines the source of the SSL certificate. Possible values include `CustomerCertificate` and `ManagedCertificate`. Defaults to `ManagedCertificate`.
               
               ->**Note:** It may take up to 15 minutes for the Front Door Service to validate the state and Domain ownership of the Custom Domain.
        :param pulumi.Input[str] minimum_tls_version: TLS protocol version that will be used for Https. Possible values are `TLS12`. Defaults to `TLS12`.
               
               > **Note:** On March 1, 2025, support for Transport Layer Security (TLS) 1.0 and 1.1 will be retired for Azure Front Door, all connections to Azure Front Door must employ `TLS 1.2` or later, please see the product [announcement](https://azure.microsoft.com/en-us/updates/v2/update-retirement-tls1-0-tls1-1-versions-azure-services/) for more details.
        """
        if cdn_frontdoor_secret_id is not None:
            pulumi.set(__self__, "cdn_frontdoor_secret_id", cdn_frontdoor_secret_id)
        if certificate_type is not None:
            pulumi.set(__self__, "certificate_type", certificate_type)
        if minimum_tls_version is not None:
            warnings.warn("""As of March 1, 2025, support for 'TLS10' will be retired from Azure Front Door, therefore the 'TLS10' property value will be removed in v5.0 of the provider.""", DeprecationWarning)
            pulumi.log.warn("""minimum_tls_version is deprecated: As of March 1, 2025, support for 'TLS10' will be retired from Azure Front Door, therefore the 'TLS10' property value will be removed in v5.0 of the provider.""")
        if minimum_tls_version is not None:
            pulumi.set(__self__, "minimum_tls_version", minimum_tls_version)

    @property
    @pulumi.getter(name="cdnFrontdoorSecretId")
    def cdn_frontdoor_secret_id(self) -> Optional[pulumi.Input[str]]:
        """
        Resource ID of the Front Door Secret.
        """
        return pulumi.get(self, "cdn_frontdoor_secret_id")

    @cdn_frontdoor_secret_id.setter
    def cdn_frontdoor_secret_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cdn_frontdoor_secret_id", value)

    @property
    @pulumi.getter(name="certificateType")
    def certificate_type(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the source of the SSL certificate. Possible values include `CustomerCertificate` and `ManagedCertificate`. Defaults to `ManagedCertificate`.

        ->**Note:** It may take up to 15 minutes for the Front Door Service to validate the state and Domain ownership of the Custom Domain.
        """
        return pulumi.get(self, "certificate_type")

    @certificate_type.setter
    def certificate_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_type", value)

    @property
    @pulumi.getter(name="minimumTlsVersion")
    @_utilities.deprecated("""As of March 1, 2025, support for 'TLS10' will be retired from Azure Front Door, therefore the 'TLS10' property value will be removed in v5.0 of the provider.""")
    def minimum_tls_version(self) -> Optional[pulumi.Input[str]]:
        """
        TLS protocol version that will be used for Https. Possible values are `TLS12`. Defaults to `TLS12`.

        > **Note:** On March 1, 2025, support for Transport Layer Security (TLS) 1.0 and 1.1 will be retired for Azure Front Door, all connections to Azure Front Door must employ `TLS 1.2` or later, please see the product [announcement](https://azure.microsoft.com/en-us/updates/v2/update-retirement-tls1-0-tls1-1-versions-azure-services/) for more details.
        """
        return pulumi.get(self, "minimum_tls_version")

    @minimum_tls_version.setter
    def minimum_tls_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "minimum_tls_version", value)


if not MYPY:
    class FrontdoorFirewallPolicyCustomRuleArgsDict(TypedDict):
        action: pulumi.Input[str]
        """
        The action to perform when the rule is matched. Possible values are `Allow`, `Block`, `Log`, `Redirect`, or `JSChallenge`.

        !> **Note:** Setting the `action` field to `JSChallenge` is currently in **PREVIEW**. Please see the [Supplemental Terms of Use for Microsoft Azure Previews](https://azure.microsoft.com/support/legal/preview-supplemental-terms/) for legal terms that apply to Azure features that are in beta, preview, or otherwise not yet released into general availability.
        """
        name: pulumi.Input[str]
        """
        Gets name of the resource that is unique within a policy. This name can be used to access the resource.
        """
        type: pulumi.Input[str]
        """
        The type of rule. Possible values are `MatchRule` or `RateLimitRule`.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Is the rule is enabled or disabled? Defaults to `true`.
        """
        match_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['FrontdoorFirewallPolicyCustomRuleMatchConditionArgsDict']]]]
        """
        One or more `match_condition` block defined below. Can support up to `10` `match_condition` blocks.
        """
        priority: NotRequired[pulumi.Input[int]]
        """
        The priority of the rule. Rules with a lower value will be evaluated before rules with a higher value. Defaults to `1`.
        """
        rate_limit_duration_in_minutes: NotRequired[pulumi.Input[int]]
        """
        The rate limit duration in minutes. Defaults to `1`.
        """
        rate_limit_threshold: NotRequired[pulumi.Input[int]]
        """
        The rate limit threshold. Defaults to `10`.
        """
elif False:
    FrontdoorFirewallPolicyCustomRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontdoorFirewallPolicyCustomRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 enabled: Optional[pulumi.Input[bool]] = None,
                 match_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorFirewallPolicyCustomRuleMatchConditionArgs']]]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 rate_limit_duration_in_minutes: Optional[pulumi.Input[int]] = None,
                 rate_limit_threshold: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] action: The action to perform when the rule is matched. Possible values are `Allow`, `Block`, `Log`, `Redirect`, or `JSChallenge`.
               
               !> **Note:** Setting the `action` field to `JSChallenge` is currently in **PREVIEW**. Please see the [Supplemental Terms of Use for Microsoft Azure Previews](https://azure.microsoft.com/support/legal/preview-supplemental-terms/) for legal terms that apply to Azure features that are in beta, preview, or otherwise not yet released into general availability.
        :param pulumi.Input[str] name: Gets name of the resource that is unique within a policy. This name can be used to access the resource.
        :param pulumi.Input[str] type: The type of rule. Possible values are `MatchRule` or `RateLimitRule`.
        :param pulumi.Input[bool] enabled: Is the rule is enabled or disabled? Defaults to `true`.
        :param pulumi.Input[Sequence[pulumi.Input['FrontdoorFirewallPolicyCustomRuleMatchConditionArgs']]] match_conditions: One or more `match_condition` block defined below. Can support up to `10` `match_condition` blocks.
        :param pulumi.Input[int] priority: The priority of the rule. Rules with a lower value will be evaluated before rules with a higher value. Defaults to `1`.
        :param pulumi.Input[int] rate_limit_duration_in_minutes: The rate limit duration in minutes. Defaults to `1`.
        :param pulumi.Input[int] rate_limit_threshold: The rate limit threshold. Defaults to `10`.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if match_conditions is not None:
            pulumi.set(__self__, "match_conditions", match_conditions)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if rate_limit_duration_in_minutes is not None:
            pulumi.set(__self__, "rate_limit_duration_in_minutes", rate_limit_duration_in_minutes)
        if rate_limit_threshold is not None:
            pulumi.set(__self__, "rate_limit_threshold", rate_limit_threshold)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        The action to perform when the rule is matched. Possible values are `Allow`, `Block`, `Log`, `Redirect`, or `JSChallenge`.

        !> **Note:** Setting the `action` field to `JSChallenge` is currently in **PREVIEW**. Please see the [Supplemental Terms of Use for Microsoft Azure Previews](https://azure.microsoft.com/support/legal/preview-supplemental-terms/) for legal terms that apply to Azure features that are in beta, preview, or otherwise not yet released into general availability.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Gets name of the resource that is unique within a policy. This name can be used to access the resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of rule. Possible values are `MatchRule` or `RateLimitRule`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is the rule is enabled or disabled? Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="matchConditions")
    def match_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorFirewallPolicyCustomRuleMatchConditionArgs']]]]:
        """
        One or more `match_condition` block defined below. Can support up to `10` `match_condition` blocks.
        """
        return pulumi.get(self, "match_conditions")

    @match_conditions.setter
    def match_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorFirewallPolicyCustomRuleMatchConditionArgs']]]]):
        pulumi.set(self, "match_conditions", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        The priority of the rule. Rules with a lower value will be evaluated before rules with a higher value. Defaults to `1`.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="rateLimitDurationInMinutes")
    def rate_limit_duration_in_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        The rate limit duration in minutes. Defaults to `1`.
        """
        return pulumi.get(self, "rate_limit_duration_in_minutes")

    @rate_limit_duration_in_minutes.setter
    def rate_limit_duration_in_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "rate_limit_duration_in_minutes", value)

    @property
    @pulumi.getter(name="rateLimitThreshold")
    def rate_limit_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        The rate limit threshold. Defaults to `10`.
        """
        return pulumi.get(self, "rate_limit_threshold")

    @rate_limit_threshold.setter
    def rate_limit_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "rate_limit_threshold", value)


if not MYPY:
    class FrontdoorFirewallPolicyCustomRuleMatchConditionArgsDict(TypedDict):
        match_values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Up to `600` possible values to match. Limit is in total across all `match_condition` blocks and `match_values` arguments. String value itself can be up to `256` characters in length.
        """
        match_variable: pulumi.Input[str]
        """
        The request variable to compare with. Possible values are `Cookies`, `PostArgs`, `QueryString`, `RemoteAddr`, `RequestBody`, `RequestHeader`, `RequestMethod`, `RequestUri`, or `SocketAddr`.
        """
        operator: pulumi.Input[str]
        """
        Comparison type to use for matching with the variable value. Possible values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GeoMatch`, `GreaterThan`, `GreaterThanOrEqual`, `IPMatch`, `LessThan`, `LessThanOrEqual`, or `RegEx`.
        """
        negation_condition: NotRequired[pulumi.Input[bool]]
        """
        Should the result of the condition be negated.
        """
        selector: NotRequired[pulumi.Input[str]]
        """
        Match against a specific key if the `match_variable` is `QueryString`, `PostArgs`, `RequestHeader`, or `Cookies`.
        """
        transforms: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Up to `5` transforms to apply. Possible values are `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `URLDecode`, or `URLEncode`.
        """
elif False:
    FrontdoorFirewallPolicyCustomRuleMatchConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontdoorFirewallPolicyCustomRuleMatchConditionArgs:
    def __init__(__self__, *,
                 match_values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 match_variable: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 negation_condition: Optional[pulumi.Input[bool]] = None,
                 selector: Optional[pulumi.Input[str]] = None,
                 transforms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: Up to `600` possible values to match. Limit is in total across all `match_condition` blocks and `match_values` arguments. String value itself can be up to `256` characters in length.
        :param pulumi.Input[str] match_variable: The request variable to compare with. Possible values are `Cookies`, `PostArgs`, `QueryString`, `RemoteAddr`, `RequestBody`, `RequestHeader`, `RequestMethod`, `RequestUri`, or `SocketAddr`.
        :param pulumi.Input[str] operator: Comparison type to use for matching with the variable value. Possible values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GeoMatch`, `GreaterThan`, `GreaterThanOrEqual`, `IPMatch`, `LessThan`, `LessThanOrEqual`, or `RegEx`.
        :param pulumi.Input[bool] negation_condition: Should the result of the condition be negated.
        :param pulumi.Input[str] selector: Match against a specific key if the `match_variable` is `QueryString`, `PostArgs`, `RequestHeader`, or `Cookies`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] transforms: Up to `5` transforms to apply. Possible values are `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `URLDecode`, or `URLEncode`.
        """
        pulumi.set(__self__, "match_values", match_values)
        pulumi.set(__self__, "match_variable", match_variable)
        pulumi.set(__self__, "operator", operator)
        if negation_condition is not None:
            pulumi.set(__self__, "negation_condition", negation_condition)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Up to `600` possible values to match. Limit is in total across all `match_condition` blocks and `match_values` arguments. String value itself can be up to `256` characters in length.
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="matchVariable")
    def match_variable(self) -> pulumi.Input[str]:
        """
        The request variable to compare with. Possible values are `Cookies`, `PostArgs`, `QueryString`, `RemoteAddr`, `RequestBody`, `RequestHeader`, `RequestMethod`, `RequestUri`, or `SocketAddr`.
        """
        return pulumi.get(self, "match_variable")

    @match_variable.setter
    def match_variable(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_variable", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        Comparison type to use for matching with the variable value. Possible values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GeoMatch`, `GreaterThan`, `GreaterThanOrEqual`, `IPMatch`, `LessThan`, `LessThanOrEqual`, or `RegEx`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="negationCondition")
    def negation_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the result of the condition be negated.
        """
        return pulumi.get(self, "negation_condition")

    @negation_condition.setter
    def negation_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negation_condition", value)

    @property
    @pulumi.getter
    def selector(self) -> Optional[pulumi.Input[str]]:
        """
        Match against a specific key if the `match_variable` is `QueryString`, `PostArgs`, `RequestHeader`, or `Cookies`.
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "selector", value)

    @property
    @pulumi.getter
    def transforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Up to `5` transforms to apply. Possible values are `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `URLDecode`, or `URLEncode`.
        """
        return pulumi.get(self, "transforms")

    @transforms.setter
    def transforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "transforms", value)


if not MYPY:
    class FrontdoorFirewallPolicyManagedRuleArgsDict(TypedDict):
        action: pulumi.Input[str]
        """
        The action to perform for all default rule set rules when the managed rule is matched or when the anomaly score is 5 or greater depending on which version of the default rule set you are using. Possible values include `Allow`, `Log`, `Block`, or `Redirect`.
        """
        type: pulumi.Input[str]
        """
        The name of the managed rule to use with this resource. Possible values include `DefaultRuleSet`, `Microsoft_DefaultRuleSet`, `BotProtection`, or `Microsoft_BotManagerRuleSet`.
        """
        version: pulumi.Input[str]
        """
        The version of the managed rule to use with this resource. Possible values depends on which default rule set type you are using, for the `DefaultRuleSet` type the possible values include `1.0` or `preview-0.1`. For `Microsoft_DefaultRuleSet` the possible values include `1.1`, `2.0`, or `2.1`. For `BotProtection` the value must be `preview-0.1` and for `Microsoft_BotManagerRuleSet` the possible values include `1.0` and `1.1`.
        """
        exclusions: NotRequired[pulumi.Input[Sequence[pulumi.Input['FrontdoorFirewallPolicyManagedRuleExclusionArgsDict']]]]
        """
        One or more `exclusion` blocks as defined below.
        """
        overrides: NotRequired[pulumi.Input[Sequence[pulumi.Input['FrontdoorFirewallPolicyManagedRuleOverrideArgsDict']]]]
        """
        One or more `override` blocks as defined below.
        """
elif False:
    FrontdoorFirewallPolicyManagedRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontdoorFirewallPolicyManagedRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 type: pulumi.Input[str],
                 version: pulumi.Input[str],
                 exclusions: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorFirewallPolicyManagedRuleExclusionArgs']]]] = None,
                 overrides: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorFirewallPolicyManagedRuleOverrideArgs']]]] = None):
        """
        :param pulumi.Input[str] action: The action to perform for all default rule set rules when the managed rule is matched or when the anomaly score is 5 or greater depending on which version of the default rule set you are using. Possible values include `Allow`, `Log`, `Block`, or `Redirect`.
        :param pulumi.Input[str] type: The name of the managed rule to use with this resource. Possible values include `DefaultRuleSet`, `Microsoft_DefaultRuleSet`, `BotProtection`, or `Microsoft_BotManagerRuleSet`.
        :param pulumi.Input[str] version: The version of the managed rule to use with this resource. Possible values depends on which default rule set type you are using, for the `DefaultRuleSet` type the possible values include `1.0` or `preview-0.1`. For `Microsoft_DefaultRuleSet` the possible values include `1.1`, `2.0`, or `2.1`. For `BotProtection` the value must be `preview-0.1` and for `Microsoft_BotManagerRuleSet` the possible values include `1.0` and `1.1`.
        :param pulumi.Input[Sequence[pulumi.Input['FrontdoorFirewallPolicyManagedRuleExclusionArgs']]] exclusions: One or more `exclusion` blocks as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['FrontdoorFirewallPolicyManagedRuleOverrideArgs']]] overrides: One or more `override` blocks as defined below.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "version", version)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        The action to perform for all default rule set rules when the managed rule is matched or when the anomaly score is 5 or greater depending on which version of the default rule set you are using. Possible values include `Allow`, `Log`, `Block`, or `Redirect`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The name of the managed rule to use with this resource. Possible values include `DefaultRuleSet`, `Microsoft_DefaultRuleSet`, `BotProtection`, or `Microsoft_BotManagerRuleSet`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[str]:
        """
        The version of the managed rule to use with this resource. Possible values depends on which default rule set type you are using, for the `DefaultRuleSet` type the possible values include `1.0` or `preview-0.1`. For `Microsoft_DefaultRuleSet` the possible values include `1.1`, `2.0`, or `2.1`. For `BotProtection` the value must be `preview-0.1` and for `Microsoft_BotManagerRuleSet` the possible values include `1.0` and `1.1`.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[str]):
        pulumi.set(self, "version", value)

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorFirewallPolicyManagedRuleExclusionArgs']]]]:
        """
        One or more `exclusion` blocks as defined below.
        """
        return pulumi.get(self, "exclusions")

    @exclusions.setter
    def exclusions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorFirewallPolicyManagedRuleExclusionArgs']]]]):
        pulumi.set(self, "exclusions", value)

    @property
    @pulumi.getter
    def overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorFirewallPolicyManagedRuleOverrideArgs']]]]:
        """
        One or more `override` blocks as defined below.
        """
        return pulumi.get(self, "overrides")

    @overrides.setter
    def overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorFirewallPolicyManagedRuleOverrideArgs']]]]):
        pulumi.set(self, "overrides", value)


if not MYPY:
    class FrontdoorFirewallPolicyManagedRuleExclusionArgsDict(TypedDict):
        match_variable: pulumi.Input[str]
        """
        The variable type to be excluded. Possible values are `QueryStringArgNames`, `RequestBodyPostArgNames`, `RequestCookieNames`, `RequestHeaderNames`, `RequestBodyJsonArgNames`

        > **Note:** `RequestBodyJsonArgNames` is only available on Default Rule Set (DRS) 2.0 or later
        """
        operator: pulumi.Input[str]
        """
        Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to. Possible values are: `Equals`, `Contains`, `StartsWith`, `EndsWith`, or `EqualsAny`.
        """
        selector: pulumi.Input[str]
        """
        Selector for the value in the `match_variable` attribute this exclusion applies to.

        > **Note:** `selector` must be set to `*` if `operator` is set to `EqualsAny`.
        """
elif False:
    FrontdoorFirewallPolicyManagedRuleExclusionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontdoorFirewallPolicyManagedRuleExclusionArgs:
    def __init__(__self__, *,
                 match_variable: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 selector: pulumi.Input[str]):
        """
        :param pulumi.Input[str] match_variable: The variable type to be excluded. Possible values are `QueryStringArgNames`, `RequestBodyPostArgNames`, `RequestCookieNames`, `RequestHeaderNames`, `RequestBodyJsonArgNames`
               
               > **Note:** `RequestBodyJsonArgNames` is only available on Default Rule Set (DRS) 2.0 or later
        :param pulumi.Input[str] operator: Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to. Possible values are: `Equals`, `Contains`, `StartsWith`, `EndsWith`, or `EqualsAny`.
        :param pulumi.Input[str] selector: Selector for the value in the `match_variable` attribute this exclusion applies to.
               
               > **Note:** `selector` must be set to `*` if `operator` is set to `EqualsAny`.
        """
        pulumi.set(__self__, "match_variable", match_variable)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "selector", selector)

    @property
    @pulumi.getter(name="matchVariable")
    def match_variable(self) -> pulumi.Input[str]:
        """
        The variable type to be excluded. Possible values are `QueryStringArgNames`, `RequestBodyPostArgNames`, `RequestCookieNames`, `RequestHeaderNames`, `RequestBodyJsonArgNames`

        > **Note:** `RequestBodyJsonArgNames` is only available on Default Rule Set (DRS) 2.0 or later
        """
        return pulumi.get(self, "match_variable")

    @match_variable.setter
    def match_variable(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_variable", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to. Possible values are: `Equals`, `Contains`, `StartsWith`, `EndsWith`, or `EqualsAny`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def selector(self) -> pulumi.Input[str]:
        """
        Selector for the value in the `match_variable` attribute this exclusion applies to.

        > **Note:** `selector` must be set to `*` if `operator` is set to `EqualsAny`.
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: pulumi.Input[str]):
        pulumi.set(self, "selector", value)


if not MYPY:
    class FrontdoorFirewallPolicyManagedRuleOverrideArgsDict(TypedDict):
        rule_group_name: pulumi.Input[str]
        """
        The managed rule group to override.
        """
        exclusions: NotRequired[pulumi.Input[Sequence[pulumi.Input['FrontdoorFirewallPolicyManagedRuleOverrideExclusionArgsDict']]]]
        """
        One or more `exclusion` blocks as defined below.
        """
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['FrontdoorFirewallPolicyManagedRuleOverrideRuleArgsDict']]]]
        """
        One or more `rule` blocks as defined below. If none are specified, all of the rules in the group will be disabled.
        """
elif False:
    FrontdoorFirewallPolicyManagedRuleOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontdoorFirewallPolicyManagedRuleOverrideArgs:
    def __init__(__self__, *,
                 rule_group_name: pulumi.Input[str],
                 exclusions: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorFirewallPolicyManagedRuleOverrideExclusionArgs']]]] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorFirewallPolicyManagedRuleOverrideRuleArgs']]]] = None):
        """
        :param pulumi.Input[str] rule_group_name: The managed rule group to override.
        :param pulumi.Input[Sequence[pulumi.Input['FrontdoorFirewallPolicyManagedRuleOverrideExclusionArgs']]] exclusions: One or more `exclusion` blocks as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['FrontdoorFirewallPolicyManagedRuleOverrideRuleArgs']]] rules: One or more `rule` blocks as defined below. If none are specified, all of the rules in the group will be disabled.
        """
        pulumi.set(__self__, "rule_group_name", rule_group_name)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter(name="ruleGroupName")
    def rule_group_name(self) -> pulumi.Input[str]:
        """
        The managed rule group to override.
        """
        return pulumi.get(self, "rule_group_name")

    @rule_group_name.setter
    def rule_group_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "rule_group_name", value)

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorFirewallPolicyManagedRuleOverrideExclusionArgs']]]]:
        """
        One or more `exclusion` blocks as defined below.
        """
        return pulumi.get(self, "exclusions")

    @exclusions.setter
    def exclusions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorFirewallPolicyManagedRuleOverrideExclusionArgs']]]]):
        pulumi.set(self, "exclusions", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorFirewallPolicyManagedRuleOverrideRuleArgs']]]]:
        """
        One or more `rule` blocks as defined below. If none are specified, all of the rules in the group will be disabled.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorFirewallPolicyManagedRuleOverrideRuleArgs']]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class FrontdoorFirewallPolicyManagedRuleOverrideExclusionArgsDict(TypedDict):
        match_variable: pulumi.Input[str]
        """
        The variable type to be excluded. Possible values are `QueryStringArgNames`, `RequestBodyPostArgNames`, `RequestCookieNames`, `RequestHeaderNames`, `RequestBodyJsonArgNames`

        > **Note:** `RequestBodyJsonArgNames` is only available on Default Rule Set (DRS) 2.0 or later
        """
        operator: pulumi.Input[str]
        """
        Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to. Possible values are: `Equals`, `Contains`, `StartsWith`, `EndsWith`, or `EqualsAny`.
        """
        selector: pulumi.Input[str]
        """
        Selector for the value in the `match_variable` attribute this exclusion applies to.

        > **Note:** `selector` must be set to `*` if `operator` is set to `EqualsAny`.
        """
elif False:
    FrontdoorFirewallPolicyManagedRuleOverrideExclusionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontdoorFirewallPolicyManagedRuleOverrideExclusionArgs:
    def __init__(__self__, *,
                 match_variable: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 selector: pulumi.Input[str]):
        """
        :param pulumi.Input[str] match_variable: The variable type to be excluded. Possible values are `QueryStringArgNames`, `RequestBodyPostArgNames`, `RequestCookieNames`, `RequestHeaderNames`, `RequestBodyJsonArgNames`
               
               > **Note:** `RequestBodyJsonArgNames` is only available on Default Rule Set (DRS) 2.0 or later
        :param pulumi.Input[str] operator: Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to. Possible values are: `Equals`, `Contains`, `StartsWith`, `EndsWith`, or `EqualsAny`.
        :param pulumi.Input[str] selector: Selector for the value in the `match_variable` attribute this exclusion applies to.
               
               > **Note:** `selector` must be set to `*` if `operator` is set to `EqualsAny`.
        """
        pulumi.set(__self__, "match_variable", match_variable)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "selector", selector)

    @property
    @pulumi.getter(name="matchVariable")
    def match_variable(self) -> pulumi.Input[str]:
        """
        The variable type to be excluded. Possible values are `QueryStringArgNames`, `RequestBodyPostArgNames`, `RequestCookieNames`, `RequestHeaderNames`, `RequestBodyJsonArgNames`

        > **Note:** `RequestBodyJsonArgNames` is only available on Default Rule Set (DRS) 2.0 or later
        """
        return pulumi.get(self, "match_variable")

    @match_variable.setter
    def match_variable(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_variable", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to. Possible values are: `Equals`, `Contains`, `StartsWith`, `EndsWith`, or `EqualsAny`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def selector(self) -> pulumi.Input[str]:
        """
        Selector for the value in the `match_variable` attribute this exclusion applies to.

        > **Note:** `selector` must be set to `*` if `operator` is set to `EqualsAny`.
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: pulumi.Input[str]):
        pulumi.set(self, "selector", value)


if not MYPY:
    class FrontdoorFirewallPolicyManagedRuleOverrideRuleArgsDict(TypedDict):
        action: pulumi.Input[str]
        """
        The action to be applied when the managed rule matches or when the anomaly score is 5 or greater. Possible values for `DefaultRuleSet 1.1` and below are `Allow`, `Log`, `Block`, or `Redirect`. Possible values for `DefaultRuleSet 2.0` and above are `Log` or `AnomalyScoring`. Possible values for `Microsoft_BotManagerRuleSet` are `Allow`, `Log`, `Block`, `Redirect`, or `JSChallenge`.

        > **Note:** Please see the `DefaultRuleSet` [product documentation](https://learn.microsoft.com/azure/web-application-firewall/afds/waf-front-door-drs?tabs=drs20#anomaly-scoring-mode) or the `Microsoft_BotManagerRuleSet` [product documentation](https://learn.microsoft.com/azure/web-application-firewall/afds/afds-overview) for more information.

        !> **Note:** Setting the `action` field to `JSChallenge` is currently in **PREVIEW**. Please see the [Supplemental Terms of Use for Microsoft Azure Previews](https://azure.microsoft.com/support/legal/preview-supplemental-terms/) for legal terms that apply to Azure features that are in beta, preview, or otherwise not yet released into general availability.
        """
        rule_id: pulumi.Input[str]
        """
        Identifier for the managed rule.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Is the managed rule override enabled or disabled. Defaults to `false`
        """
        exclusions: NotRequired[pulumi.Input[Sequence[pulumi.Input['FrontdoorFirewallPolicyManagedRuleOverrideRuleExclusionArgsDict']]]]
        """
        One or more `exclusion` blocks as defined below.
        """
elif False:
    FrontdoorFirewallPolicyManagedRuleOverrideRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontdoorFirewallPolicyManagedRuleOverrideRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 rule_id: pulumi.Input[str],
                 enabled: Optional[pulumi.Input[bool]] = None,
                 exclusions: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorFirewallPolicyManagedRuleOverrideRuleExclusionArgs']]]] = None):
        """
        :param pulumi.Input[str] action: The action to be applied when the managed rule matches or when the anomaly score is 5 or greater. Possible values for `DefaultRuleSet 1.1` and below are `Allow`, `Log`, `Block`, or `Redirect`. Possible values for `DefaultRuleSet 2.0` and above are `Log` or `AnomalyScoring`. Possible values for `Microsoft_BotManagerRuleSet` are `Allow`, `Log`, `Block`, `Redirect`, or `JSChallenge`.
               
               > **Note:** Please see the `DefaultRuleSet` [product documentation](https://learn.microsoft.com/azure/web-application-firewall/afds/waf-front-door-drs?tabs=drs20#anomaly-scoring-mode) or the `Microsoft_BotManagerRuleSet` [product documentation](https://learn.microsoft.com/azure/web-application-firewall/afds/afds-overview) for more information.
               
               !> **Note:** Setting the `action` field to `JSChallenge` is currently in **PREVIEW**. Please see the [Supplemental Terms of Use for Microsoft Azure Previews](https://azure.microsoft.com/support/legal/preview-supplemental-terms/) for legal terms that apply to Azure features that are in beta, preview, or otherwise not yet released into general availability.
        :param pulumi.Input[str] rule_id: Identifier for the managed rule.
        :param pulumi.Input[bool] enabled: Is the managed rule override enabled or disabled. Defaults to `false`
        :param pulumi.Input[Sequence[pulumi.Input['FrontdoorFirewallPolicyManagedRuleOverrideRuleExclusionArgs']]] exclusions: One or more `exclusion` blocks as defined below.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "rule_id", rule_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        The action to be applied when the managed rule matches or when the anomaly score is 5 or greater. Possible values for `DefaultRuleSet 1.1` and below are `Allow`, `Log`, `Block`, or `Redirect`. Possible values for `DefaultRuleSet 2.0` and above are `Log` or `AnomalyScoring`. Possible values for `Microsoft_BotManagerRuleSet` are `Allow`, `Log`, `Block`, `Redirect`, or `JSChallenge`.

        > **Note:** Please see the `DefaultRuleSet` [product documentation](https://learn.microsoft.com/azure/web-application-firewall/afds/waf-front-door-drs?tabs=drs20#anomaly-scoring-mode) or the `Microsoft_BotManagerRuleSet` [product documentation](https://learn.microsoft.com/azure/web-application-firewall/afds/afds-overview) for more information.

        !> **Note:** Setting the `action` field to `JSChallenge` is currently in **PREVIEW**. Please see the [Supplemental Terms of Use for Microsoft Azure Previews](https://azure.microsoft.com/support/legal/preview-supplemental-terms/) for legal terms that apply to Azure features that are in beta, preview, or otherwise not yet released into general availability.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> pulumi.Input[str]:
        """
        Identifier for the managed rule.
        """
        return pulumi.get(self, "rule_id")

    @rule_id.setter
    def rule_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "rule_id", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is the managed rule override enabled or disabled. Defaults to `false`
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorFirewallPolicyManagedRuleOverrideRuleExclusionArgs']]]]:
        """
        One or more `exclusion` blocks as defined below.
        """
        return pulumi.get(self, "exclusions")

    @exclusions.setter
    def exclusions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorFirewallPolicyManagedRuleOverrideRuleExclusionArgs']]]]):
        pulumi.set(self, "exclusions", value)


if not MYPY:
    class FrontdoorFirewallPolicyManagedRuleOverrideRuleExclusionArgsDict(TypedDict):
        match_variable: pulumi.Input[str]
        """
        The variable type to be excluded. Possible values are `QueryStringArgNames`, `RequestBodyPostArgNames`, `RequestCookieNames`, `RequestHeaderNames`, `RequestBodyJsonArgNames`

        > **Note:** `RequestBodyJsonArgNames` is only available on Default Rule Set (DRS) 2.0 or later
        """
        operator: pulumi.Input[str]
        """
        Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to. Possible values are: `Equals`, `Contains`, `StartsWith`, `EndsWith`, or `EqualsAny`.
        """
        selector: pulumi.Input[str]
        """
        Selector for the value in the `match_variable` attribute this exclusion applies to.

        > **Note:** `selector` must be set to `*` if `operator` is set to `EqualsAny`.
        """
elif False:
    FrontdoorFirewallPolicyManagedRuleOverrideRuleExclusionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontdoorFirewallPolicyManagedRuleOverrideRuleExclusionArgs:
    def __init__(__self__, *,
                 match_variable: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 selector: pulumi.Input[str]):
        """
        :param pulumi.Input[str] match_variable: The variable type to be excluded. Possible values are `QueryStringArgNames`, `RequestBodyPostArgNames`, `RequestCookieNames`, `RequestHeaderNames`, `RequestBodyJsonArgNames`
               
               > **Note:** `RequestBodyJsonArgNames` is only available on Default Rule Set (DRS) 2.0 or later
        :param pulumi.Input[str] operator: Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to. Possible values are: `Equals`, `Contains`, `StartsWith`, `EndsWith`, or `EqualsAny`.
        :param pulumi.Input[str] selector: Selector for the value in the `match_variable` attribute this exclusion applies to.
               
               > **Note:** `selector` must be set to `*` if `operator` is set to `EqualsAny`.
        """
        pulumi.set(__self__, "match_variable", match_variable)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "selector", selector)

    @property
    @pulumi.getter(name="matchVariable")
    def match_variable(self) -> pulumi.Input[str]:
        """
        The variable type to be excluded. Possible values are `QueryStringArgNames`, `RequestBodyPostArgNames`, `RequestCookieNames`, `RequestHeaderNames`, `RequestBodyJsonArgNames`

        > **Note:** `RequestBodyJsonArgNames` is only available on Default Rule Set (DRS) 2.0 or later
        """
        return pulumi.get(self, "match_variable")

    @match_variable.setter
    def match_variable(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_variable", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to. Possible values are: `Equals`, `Contains`, `StartsWith`, `EndsWith`, or `EqualsAny`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def selector(self) -> pulumi.Input[str]:
        """
        Selector for the value in the `match_variable` attribute this exclusion applies to.

        > **Note:** `selector` must be set to `*` if `operator` is set to `EqualsAny`.
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: pulumi.Input[str]):
        pulumi.set(self, "selector", value)


if not MYPY:
    class FrontdoorOriginGroupHealthProbeArgsDict(TypedDict):
        interval_in_seconds: pulumi.Input[int]
        """
        Specifies the number of seconds between health probes. Possible values are between `1` and `255` seconds (inclusive).
        """
        protocol: pulumi.Input[str]
        """
        Specifies the protocol to use for health probe. Possible values are `Http` and `Https`.
        """
        path: NotRequired[pulumi.Input[str]]
        """
        Specifies the path relative to the origin that is used to determine the health of the origin. Defaults to `/`.

        > **NOTE:** Health probes can only be disabled if there is a single enabled origin in a single enabled origin group. For more information about the `health_probe` settings please see the [product documentation](https://docs.microsoft.com/azure/frontdoor/health-probes).
        """
        request_type: NotRequired[pulumi.Input[str]]
        """
        Specifies the type of health probe request that is made. Possible values are `GET` and `HEAD`. Defaults to `HEAD`.
        """
elif False:
    FrontdoorOriginGroupHealthProbeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontdoorOriginGroupHealthProbeArgs:
    def __init__(__self__, *,
                 interval_in_seconds: pulumi.Input[int],
                 protocol: pulumi.Input[str],
                 path: Optional[pulumi.Input[str]] = None,
                 request_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] interval_in_seconds: Specifies the number of seconds between health probes. Possible values are between `1` and `255` seconds (inclusive).
        :param pulumi.Input[str] protocol: Specifies the protocol to use for health probe. Possible values are `Http` and `Https`.
        :param pulumi.Input[str] path: Specifies the path relative to the origin that is used to determine the health of the origin. Defaults to `/`.
               
               > **NOTE:** Health probes can only be disabled if there is a single enabled origin in a single enabled origin group. For more information about the `health_probe` settings please see the [product documentation](https://docs.microsoft.com/azure/frontdoor/health-probes).
        :param pulumi.Input[str] request_type: Specifies the type of health probe request that is made. Possible values are `GET` and `HEAD`. Defaults to `HEAD`.
        """
        pulumi.set(__self__, "interval_in_seconds", interval_in_seconds)
        pulumi.set(__self__, "protocol", protocol)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if request_type is not None:
            pulumi.set(__self__, "request_type", request_type)

    @property
    @pulumi.getter(name="intervalInSeconds")
    def interval_in_seconds(self) -> pulumi.Input[int]:
        """
        Specifies the number of seconds between health probes. Possible values are between `1` and `255` seconds (inclusive).
        """
        return pulumi.get(self, "interval_in_seconds")

    @interval_in_seconds.setter
    def interval_in_seconds(self, value: pulumi.Input[int]):
        pulumi.set(self, "interval_in_seconds", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        Specifies the protocol to use for health probe. Possible values are `Http` and `Https`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the path relative to the origin that is used to determine the health of the origin. Defaults to `/`.

        > **NOTE:** Health probes can only be disabled if there is a single enabled origin in a single enabled origin group. For more information about the `health_probe` settings please see the [product documentation](https://docs.microsoft.com/azure/frontdoor/health-probes).
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="requestType")
    def request_type(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the type of health probe request that is made. Possible values are `GET` and `HEAD`. Defaults to `HEAD`.
        """
        return pulumi.get(self, "request_type")

    @request_type.setter
    def request_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "request_type", value)


if not MYPY:
    class FrontdoorOriginGroupLoadBalancingArgsDict(TypedDict):
        additional_latency_in_milliseconds: NotRequired[pulumi.Input[int]]
        """
        Specifies the additional latency in milliseconds for probes to fall into the lowest latency bucket. Possible values are between `0` and `1000` milliseconds (inclusive). Defaults to `50`.
        """
        sample_size: NotRequired[pulumi.Input[int]]
        """
        Specifies the number of samples to consider for load balancing decisions. Possible values are between `0` and `255` (inclusive). Defaults to `4`.
        """
        successful_samples_required: NotRequired[pulumi.Input[int]]
        """
        Specifies the number of samples within the sample period that must succeed. Possible values are between `0` and `255` (inclusive). Defaults to `3`.
        """
elif False:
    FrontdoorOriginGroupLoadBalancingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontdoorOriginGroupLoadBalancingArgs:
    def __init__(__self__, *,
                 additional_latency_in_milliseconds: Optional[pulumi.Input[int]] = None,
                 sample_size: Optional[pulumi.Input[int]] = None,
                 successful_samples_required: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] additional_latency_in_milliseconds: Specifies the additional latency in milliseconds for probes to fall into the lowest latency bucket. Possible values are between `0` and `1000` milliseconds (inclusive). Defaults to `50`.
        :param pulumi.Input[int] sample_size: Specifies the number of samples to consider for load balancing decisions. Possible values are between `0` and `255` (inclusive). Defaults to `4`.
        :param pulumi.Input[int] successful_samples_required: Specifies the number of samples within the sample period that must succeed. Possible values are between `0` and `255` (inclusive). Defaults to `3`.
        """
        if additional_latency_in_milliseconds is not None:
            pulumi.set(__self__, "additional_latency_in_milliseconds", additional_latency_in_milliseconds)
        if sample_size is not None:
            pulumi.set(__self__, "sample_size", sample_size)
        if successful_samples_required is not None:
            pulumi.set(__self__, "successful_samples_required", successful_samples_required)

    @property
    @pulumi.getter(name="additionalLatencyInMilliseconds")
    def additional_latency_in_milliseconds(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the additional latency in milliseconds for probes to fall into the lowest latency bucket. Possible values are between `0` and `1000` milliseconds (inclusive). Defaults to `50`.
        """
        return pulumi.get(self, "additional_latency_in_milliseconds")

    @additional_latency_in_milliseconds.setter
    def additional_latency_in_milliseconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "additional_latency_in_milliseconds", value)

    @property
    @pulumi.getter(name="sampleSize")
    def sample_size(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the number of samples to consider for load balancing decisions. Possible values are between `0` and `255` (inclusive). Defaults to `4`.
        """
        return pulumi.get(self, "sample_size")

    @sample_size.setter
    def sample_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "sample_size", value)

    @property
    @pulumi.getter(name="successfulSamplesRequired")
    def successful_samples_required(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the number of samples within the sample period that must succeed. Possible values are between `0` and `255` (inclusive). Defaults to `3`.
        """
        return pulumi.get(self, "successful_samples_required")

    @successful_samples_required.setter
    def successful_samples_required(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "successful_samples_required", value)


if not MYPY:
    class FrontdoorOriginPrivateLinkArgsDict(TypedDict):
        location: pulumi.Input[str]
        """
        Specifies the location where the Private Link resource should exist. Changing this forces a new resource to be created.
        """
        private_link_target_id: pulumi.Input[str]
        """
        The ID of the Azure Resource to connect to via the Private Link.

        > **Note:** the `private_link_target_id` property must specify the Resource ID of the Private Link Service when using Load Balancer as an Origin.
        """
        request_message: NotRequired[pulumi.Input[str]]
        """
        Specifies the request message that will be submitted to the `private_link_target_id` when requesting the private link endpoint connection. Values must be between `1` and `140` characters in length. Defaults to `Access request for CDN FrontDoor Private Link Origin`.
        """
        target_type: NotRequired[pulumi.Input[str]]
        """
        Specifies the type of target for this Private Link Endpoint. Possible values are `blob`, `blob_secondary`, `web` and `sites`.

        > **NOTE:** `target_type` cannot be specified when using a Load Balancer as an Origin.
        """
elif False:
    FrontdoorOriginPrivateLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontdoorOriginPrivateLinkArgs:
    def __init__(__self__, *,
                 location: pulumi.Input[str],
                 private_link_target_id: pulumi.Input[str],
                 request_message: Optional[pulumi.Input[str]] = None,
                 target_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] location: Specifies the location where the Private Link resource should exist. Changing this forces a new resource to be created.
        :param pulumi.Input[str] private_link_target_id: The ID of the Azure Resource to connect to via the Private Link.
               
               > **Note:** the `private_link_target_id` property must specify the Resource ID of the Private Link Service when using Load Balancer as an Origin.
        :param pulumi.Input[str] request_message: Specifies the request message that will be submitted to the `private_link_target_id` when requesting the private link endpoint connection. Values must be between `1` and `140` characters in length. Defaults to `Access request for CDN FrontDoor Private Link Origin`.
        :param pulumi.Input[str] target_type: Specifies the type of target for this Private Link Endpoint. Possible values are `blob`, `blob_secondary`, `web` and `sites`.
               
               > **NOTE:** `target_type` cannot be specified when using a Load Balancer as an Origin.
        """
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "private_link_target_id", private_link_target_id)
        if request_message is not None:
            pulumi.set(__self__, "request_message", request_message)
        if target_type is not None:
            pulumi.set(__self__, "target_type", target_type)

    @property
    @pulumi.getter
    def location(self) -> pulumi.Input[str]:
        """
        Specifies the location where the Private Link resource should exist. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: pulumi.Input[str]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter(name="privateLinkTargetId")
    def private_link_target_id(self) -> pulumi.Input[str]:
        """
        The ID of the Azure Resource to connect to via the Private Link.

        > **Note:** the `private_link_target_id` property must specify the Resource ID of the Private Link Service when using Load Balancer as an Origin.
        """
        return pulumi.get(self, "private_link_target_id")

    @private_link_target_id.setter
    def private_link_target_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "private_link_target_id", value)

    @property
    @pulumi.getter(name="requestMessage")
    def request_message(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the request message that will be submitted to the `private_link_target_id` when requesting the private link endpoint connection. Values must be between `1` and `140` characters in length. Defaults to `Access request for CDN FrontDoor Private Link Origin`.
        """
        return pulumi.get(self, "request_message")

    @request_message.setter
    def request_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "request_message", value)

    @property
    @pulumi.getter(name="targetType")
    def target_type(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the type of target for this Private Link Endpoint. Possible values are `blob`, `blob_secondary`, `web` and `sites`.

        > **NOTE:** `target_type` cannot be specified when using a Load Balancer as an Origin.
        """
        return pulumi.get(self, "target_type")

    @target_type.setter
    def target_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_type", value)


if not MYPY:
    class FrontdoorProfileIdentityArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        The type of managed identity to assign. Possible values are `SystemAssigned`, `UserAssigned` or `SystemAssigned, UserAssigned`.
        """
        identity_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of one or more Resource IDs for User Assigned Managed identities to assign. Required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        """
        principal_id: NotRequired[pulumi.Input[str]]
        tenant_id: NotRequired[pulumi.Input[str]]
elif False:
    FrontdoorProfileIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontdoorProfileIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 identity_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 principal_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The type of managed identity to assign. Possible values are `SystemAssigned`, `UserAssigned` or `SystemAssigned, UserAssigned`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] identity_ids: A list of one or more Resource IDs for User Assigned Managed identities to assign. Required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of managed identity to assign. Possible values are `SystemAssigned`, `UserAssigned` or `SystemAssigned, UserAssigned`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of one or more Resource IDs for User Assigned Managed identities to assign. Required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @identity_ids.setter
    def identity_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "identity_ids", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class FrontdoorRouteCacheArgsDict(TypedDict):
        compression_enabled: NotRequired[pulumi.Input[bool]]
        """
        Is content compression enabled? Possible values are `true` or `false`. Defaults to `false`.

        > **NOTE:** Content won't be compressed when the requested content is smaller than `1 KB` or larger than `8 MB`(inclusive).
        """
        content_types_to_compresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of one or more `Content types` (formerly known as `MIME types`) to compress. Possible values include `application/eot`, `application/font`, `application/font-sfnt`, `application/javascript`, `application/json`, `application/opentype`, `application/otf`, `application/pkcs7-mime`, `application/truetype`, `application/ttf`, `application/vnd.ms-fontobject`, `application/xhtml+xml`, `application/xml`, `application/xml+rss`, `application/x-font-opentype`, `application/x-font-truetype`, `application/x-font-ttf`, `application/x-httpd-cgi`, `application/x-mpegurl`, `application/x-opentype`, `application/x-otf`, `application/x-perl`, `application/x-ttf`, `application/x-javascript`, `font/eot`, `font/ttf`, `font/otf`, `font/opentype`, `image/svg+xml`, `text/css`, `text/csv`, `text/html`, `text/javascript`, `text/js`, `text/plain`, `text/richtext`, `text/tab-separated-values`, `text/xml`, `text/x-script`, `text/x-component` or `text/x-java-source`.
        """
        query_string_caching_behavior: NotRequired[pulumi.Input[str]]
        """
        Defines how the Front Door Route will cache requests that include query strings. Possible values include `IgnoreQueryString`, `IgnoreSpecifiedQueryStrings`, `IncludeSpecifiedQueryStrings` or `UseQueryString`. Defaults to `IgnoreQueryString`.

        > **NOTE:** The value of the `query_string_caching_behavior` determines if the `query_strings` field will be used as an include list or an ignore list.
        """
        query_strings: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Query strings to include or ignore.
        """
elif False:
    FrontdoorRouteCacheArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontdoorRouteCacheArgs:
    def __init__(__self__, *,
                 compression_enabled: Optional[pulumi.Input[bool]] = None,
                 content_types_to_compresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 query_string_caching_behavior: Optional[pulumi.Input[str]] = None,
                 query_strings: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] compression_enabled: Is content compression enabled? Possible values are `true` or `false`. Defaults to `false`.
               
               > **NOTE:** Content won't be compressed when the requested content is smaller than `1 KB` or larger than `8 MB`(inclusive).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] content_types_to_compresses: A list of one or more `Content types` (formerly known as `MIME types`) to compress. Possible values include `application/eot`, `application/font`, `application/font-sfnt`, `application/javascript`, `application/json`, `application/opentype`, `application/otf`, `application/pkcs7-mime`, `application/truetype`, `application/ttf`, `application/vnd.ms-fontobject`, `application/xhtml+xml`, `application/xml`, `application/xml+rss`, `application/x-font-opentype`, `application/x-font-truetype`, `application/x-font-ttf`, `application/x-httpd-cgi`, `application/x-mpegurl`, `application/x-opentype`, `application/x-otf`, `application/x-perl`, `application/x-ttf`, `application/x-javascript`, `font/eot`, `font/ttf`, `font/otf`, `font/opentype`, `image/svg+xml`, `text/css`, `text/csv`, `text/html`, `text/javascript`, `text/js`, `text/plain`, `text/richtext`, `text/tab-separated-values`, `text/xml`, `text/x-script`, `text/x-component` or `text/x-java-source`.
        :param pulumi.Input[str] query_string_caching_behavior: Defines how the Front Door Route will cache requests that include query strings. Possible values include `IgnoreQueryString`, `IgnoreSpecifiedQueryStrings`, `IncludeSpecifiedQueryStrings` or `UseQueryString`. Defaults to `IgnoreQueryString`.
               
               > **NOTE:** The value of the `query_string_caching_behavior` determines if the `query_strings` field will be used as an include list or an ignore list.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] query_strings: Query strings to include or ignore.
        """
        if compression_enabled is not None:
            pulumi.set(__self__, "compression_enabled", compression_enabled)
        if content_types_to_compresses is not None:
            pulumi.set(__self__, "content_types_to_compresses", content_types_to_compresses)
        if query_string_caching_behavior is not None:
            pulumi.set(__self__, "query_string_caching_behavior", query_string_caching_behavior)
        if query_strings is not None:
            pulumi.set(__self__, "query_strings", query_strings)

    @property
    @pulumi.getter(name="compressionEnabled")
    def compression_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is content compression enabled? Possible values are `true` or `false`. Defaults to `false`.

        > **NOTE:** Content won't be compressed when the requested content is smaller than `1 KB` or larger than `8 MB`(inclusive).
        """
        return pulumi.get(self, "compression_enabled")

    @compression_enabled.setter
    def compression_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "compression_enabled", value)

    @property
    @pulumi.getter(name="contentTypesToCompresses")
    def content_types_to_compresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of one or more `Content types` (formerly known as `MIME types`) to compress. Possible values include `application/eot`, `application/font`, `application/font-sfnt`, `application/javascript`, `application/json`, `application/opentype`, `application/otf`, `application/pkcs7-mime`, `application/truetype`, `application/ttf`, `application/vnd.ms-fontobject`, `application/xhtml+xml`, `application/xml`, `application/xml+rss`, `application/x-font-opentype`, `application/x-font-truetype`, `application/x-font-ttf`, `application/x-httpd-cgi`, `application/x-mpegurl`, `application/x-opentype`, `application/x-otf`, `application/x-perl`, `application/x-ttf`, `application/x-javascript`, `font/eot`, `font/ttf`, `font/otf`, `font/opentype`, `image/svg+xml`, `text/css`, `text/csv`, `text/html`, `text/javascript`, `text/js`, `text/plain`, `text/richtext`, `text/tab-separated-values`, `text/xml`, `text/x-script`, `text/x-component` or `text/x-java-source`.
        """
        return pulumi.get(self, "content_types_to_compresses")

    @content_types_to_compresses.setter
    def content_types_to_compresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "content_types_to_compresses", value)

    @property
    @pulumi.getter(name="queryStringCachingBehavior")
    def query_string_caching_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        Defines how the Front Door Route will cache requests that include query strings. Possible values include `IgnoreQueryString`, `IgnoreSpecifiedQueryStrings`, `IncludeSpecifiedQueryStrings` or `UseQueryString`. Defaults to `IgnoreQueryString`.

        > **NOTE:** The value of the `query_string_caching_behavior` determines if the `query_strings` field will be used as an include list or an ignore list.
        """
        return pulumi.get(self, "query_string_caching_behavior")

    @query_string_caching_behavior.setter
    def query_string_caching_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query_string_caching_behavior", value)

    @property
    @pulumi.getter(name="queryStrings")
    def query_strings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Query strings to include or ignore.
        """
        return pulumi.get(self, "query_strings")

    @query_strings.setter
    def query_strings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "query_strings", value)


if not MYPY:
    class FrontdoorRuleActionsArgsDict(TypedDict):
        request_header_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleActionsRequestHeaderActionArgsDict']]]]
        """
        A `request_header_action` block as defined below.
        """
        response_header_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleActionsResponseHeaderActionArgsDict']]]]
        """
        A `response_header_action` block as defined below.
        """
        route_configuration_override_action: NotRequired[pulumi.Input['FrontdoorRuleActionsRouteConfigurationOverrideActionArgsDict']]
        """
        A `route_configuration_override_action` block as defined below.
        """
        url_redirect_action: NotRequired[pulumi.Input['FrontdoorRuleActionsUrlRedirectActionArgsDict']]
        """
        A `url_redirect_action` block as defined below. You may **not** have a `url_redirect_action` **and** a `url_rewrite_action` defined in the same `actions` block.
        """
        url_rewrite_action: NotRequired[pulumi.Input['FrontdoorRuleActionsUrlRewriteActionArgsDict']]
        """
        A `url_rewrite_action` block as defined below. You may **not** have a `url_rewrite_action` **and** a `url_redirect_action` defined in the same `actions` block.
        """
elif False:
    FrontdoorRuleActionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontdoorRuleActionsArgs:
    def __init__(__self__, *,
                 request_header_actions: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleActionsRequestHeaderActionArgs']]]] = None,
                 response_header_actions: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleActionsResponseHeaderActionArgs']]]] = None,
                 route_configuration_override_action: Optional[pulumi.Input['FrontdoorRuleActionsRouteConfigurationOverrideActionArgs']] = None,
                 url_redirect_action: Optional[pulumi.Input['FrontdoorRuleActionsUrlRedirectActionArgs']] = None,
                 url_rewrite_action: Optional[pulumi.Input['FrontdoorRuleActionsUrlRewriteActionArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleActionsRequestHeaderActionArgs']]] request_header_actions: A `request_header_action` block as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleActionsResponseHeaderActionArgs']]] response_header_actions: A `response_header_action` block as defined below.
        :param pulumi.Input['FrontdoorRuleActionsRouteConfigurationOverrideActionArgs'] route_configuration_override_action: A `route_configuration_override_action` block as defined below.
        :param pulumi.Input['FrontdoorRuleActionsUrlRedirectActionArgs'] url_redirect_action: A `url_redirect_action` block as defined below. You may **not** have a `url_redirect_action` **and** a `url_rewrite_action` defined in the same `actions` block.
        :param pulumi.Input['FrontdoorRuleActionsUrlRewriteActionArgs'] url_rewrite_action: A `url_rewrite_action` block as defined below. You may **not** have a `url_rewrite_action` **and** a `url_redirect_action` defined in the same `actions` block.
        """
        if request_header_actions is not None:
            pulumi.set(__self__, "request_header_actions", request_header_actions)
        if response_header_actions is not None:
            pulumi.set(__self__, "response_header_actions", response_header_actions)
        if route_configuration_override_action is not None:
            pulumi.set(__self__, "route_configuration_override_action", route_configuration_override_action)
        if url_redirect_action is not None:
            pulumi.set(__self__, "url_redirect_action", url_redirect_action)
        if url_rewrite_action is not None:
            pulumi.set(__self__, "url_rewrite_action", url_rewrite_action)

    @property
    @pulumi.getter(name="requestHeaderActions")
    def request_header_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleActionsRequestHeaderActionArgs']]]]:
        """
        A `request_header_action` block as defined below.
        """
        return pulumi.get(self, "request_header_actions")

    @request_header_actions.setter
    def request_header_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleActionsRequestHeaderActionArgs']]]]):
        pulumi.set(self, "request_header_actions", value)

    @property
    @pulumi.getter(name="responseHeaderActions")
    def response_header_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleActionsResponseHeaderActionArgs']]]]:
        """
        A `response_header_action` block as defined below.
        """
        return pulumi.get(self, "response_header_actions")

    @response_header_actions.setter
    def response_header_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleActionsResponseHeaderActionArgs']]]]):
        pulumi.set(self, "response_header_actions", value)

    @property
    @pulumi.getter(name="routeConfigurationOverrideAction")
    def route_configuration_override_action(self) -> Optional[pulumi.Input['FrontdoorRuleActionsRouteConfigurationOverrideActionArgs']]:
        """
        A `route_configuration_override_action` block as defined below.
        """
        return pulumi.get(self, "route_configuration_override_action")

    @route_configuration_override_action.setter
    def route_configuration_override_action(self, value: Optional[pulumi.Input['FrontdoorRuleActionsRouteConfigurationOverrideActionArgs']]):
        pulumi.set(self, "route_configuration_override_action", value)

    @property
    @pulumi.getter(name="urlRedirectAction")
    def url_redirect_action(self) -> Optional[pulumi.Input['FrontdoorRuleActionsUrlRedirectActionArgs']]:
        """
        A `url_redirect_action` block as defined below. You may **not** have a `url_redirect_action` **and** a `url_rewrite_action` defined in the same `actions` block.
        """
        return pulumi.get(self, "url_redirect_action")

    @url_redirect_action.setter
    def url_redirect_action(self, value: Optional[pulumi.Input['FrontdoorRuleActionsUrlRedirectActionArgs']]):
        pulumi.set(self, "url_redirect_action", value)

    @property
    @pulumi.getter(name="urlRewriteAction")
    def url_rewrite_action(self) -> Optional[pulumi.Input['FrontdoorRuleActionsUrlRewriteActionArgs']]:
        """
        A `url_rewrite_action` block as defined below. You may **not** have a `url_rewrite_action` **and** a `url_redirect_action` defined in the same `actions` block.
        """
        return pulumi.get(self, "url_rewrite_action")

    @url_rewrite_action.setter
    def url_rewrite_action(self, value: Optional[pulumi.Input['FrontdoorRuleActionsUrlRewriteActionArgs']]):
        pulumi.set(self, "url_rewrite_action", value)


if not MYPY:
    class FrontdoorRuleActionsRequestHeaderActionArgsDict(TypedDict):
        header_action: pulumi.Input[str]
        """
        The action to be taken on the specified `header_name`. Possible values include `Append`, `Overwrite` or `Delete`.

        > **NOTE:** `Append` causes the specified header to be added to the request with the specified value. If the header is already present, the value is appended to the existing header value using string concatenation. No delimiters are added. `Overwrite` causes specified header to be added to the request with the specified value. If the header is already present, the specified value overwrites the existing value. `Delete` causes the header to be deleted from the request.
        """
        header_name: pulumi.Input[str]
        """
        The name of the header to modify.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        The value to append or overwrite.

        ->**NOTE:** `value` is required if the `header_action` is set to `Append` or `Overwrite`.
        """
elif False:
    FrontdoorRuleActionsRequestHeaderActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontdoorRuleActionsRequestHeaderActionArgs:
    def __init__(__self__, *,
                 header_action: pulumi.Input[str],
                 header_name: pulumi.Input[str],
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] header_action: The action to be taken on the specified `header_name`. Possible values include `Append`, `Overwrite` or `Delete`.
               
               > **NOTE:** `Append` causes the specified header to be added to the request with the specified value. If the header is already present, the value is appended to the existing header value using string concatenation. No delimiters are added. `Overwrite` causes specified header to be added to the request with the specified value. If the header is already present, the specified value overwrites the existing value. `Delete` causes the header to be deleted from the request.
        :param pulumi.Input[str] header_name: The name of the header to modify.
        :param pulumi.Input[str] value: The value to append or overwrite.
               
               ->**NOTE:** `value` is required if the `header_action` is set to `Append` or `Overwrite`.
        """
        pulumi.set(__self__, "header_action", header_action)
        pulumi.set(__self__, "header_name", header_name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="headerAction")
    def header_action(self) -> pulumi.Input[str]:
        """
        The action to be taken on the specified `header_name`. Possible values include `Append`, `Overwrite` or `Delete`.

        > **NOTE:** `Append` causes the specified header to be added to the request with the specified value. If the header is already present, the value is appended to the existing header value using string concatenation. No delimiters are added. `Overwrite` causes specified header to be added to the request with the specified value. If the header is already present, the specified value overwrites the existing value. `Delete` causes the header to be deleted from the request.
        """
        return pulumi.get(self, "header_action")

    @header_action.setter
    def header_action(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_action", value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[str]:
        """
        The name of the header to modify.
        """
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value to append or overwrite.

        ->**NOTE:** `value` is required if the `header_action` is set to `Append` or `Overwrite`.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FrontdoorRuleActionsResponseHeaderActionArgsDict(TypedDict):
        header_action: pulumi.Input[str]
        """
        The action to be taken on the specified `header_name`. Possible values include `Append`, `Overwrite` or `Delete`.

        > **NOTE:** `Append` causes the specified header to be added to the request with the specified value. If the header is already present, the value is appended to the existing header value using string concatenation. No delimiters are added. `Overwrite` causes specified header to be added to the request with the specified value. If the header is already present, the specified value overwrites the existing value. `Delete` causes the header to be deleted from the request.
        """
        header_name: pulumi.Input[str]
        """
        The name of the header to modify.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        The value to append or overwrite.

        ->**NOTE:** `value` is required if the `header_action` is set to `Append` or `Overwrite`.
        """
elif False:
    FrontdoorRuleActionsResponseHeaderActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontdoorRuleActionsResponseHeaderActionArgs:
    def __init__(__self__, *,
                 header_action: pulumi.Input[str],
                 header_name: pulumi.Input[str],
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] header_action: The action to be taken on the specified `header_name`. Possible values include `Append`, `Overwrite` or `Delete`.
               
               > **NOTE:** `Append` causes the specified header to be added to the request with the specified value. If the header is already present, the value is appended to the existing header value using string concatenation. No delimiters are added. `Overwrite` causes specified header to be added to the request with the specified value. If the header is already present, the specified value overwrites the existing value. `Delete` causes the header to be deleted from the request.
        :param pulumi.Input[str] header_name: The name of the header to modify.
        :param pulumi.Input[str] value: The value to append or overwrite.
               
               ->**NOTE:** `value` is required if the `header_action` is set to `Append` or `Overwrite`.
        """
        pulumi.set(__self__, "header_action", header_action)
        pulumi.set(__self__, "header_name", header_name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="headerAction")
    def header_action(self) -> pulumi.Input[str]:
        """
        The action to be taken on the specified `header_name`. Possible values include `Append`, `Overwrite` or `Delete`.

        > **NOTE:** `Append` causes the specified header to be added to the request with the specified value. If the header is already present, the value is appended to the existing header value using string concatenation. No delimiters are added. `Overwrite` causes specified header to be added to the request with the specified value. If the header is already present, the specified value overwrites the existing value. `Delete` causes the header to be deleted from the request.
        """
        return pulumi.get(self, "header_action")

    @header_action.setter
    def header_action(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_action", value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[str]:
        """
        The name of the header to modify.
        """
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value to append or overwrite.

        ->**NOTE:** `value` is required if the `header_action` is set to `Append` or `Overwrite`.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FrontdoorRuleActionsRouteConfigurationOverrideActionArgsDict(TypedDict):
        cache_behavior: NotRequired[pulumi.Input[str]]
        """
        `HonorOrigin` the Front Door will always honor origin response header directive. If the origin directive is missing, Front Door will cache contents anywhere from `1` to `3` days. `OverrideAlways` the TTL value returned from your Front Door Origin is overwritten with the value specified in the action. This behavior will only be applied if the response is cacheable. `OverrideIfOriginMissing` if no TTL value gets returned from your Front Door Origin, the rule sets the TTL to the value specified in the action. This behavior will only be applied if the response is cacheable. `Disabled` the Front Door will not cache the response contents, irrespective of Front Door Origin response directives. Possible values include `HonorOrigin`, `OverrideAlways`, `OverrideIfOriginMissing` or `Disabled`.
        """
        cache_duration: NotRequired[pulumi.Input[str]]
        """
        When Cache behavior is set to `Override` or `SetIfMissing`, this field specifies the cache duration to use. The maximum duration is 366 days specified in the `d.HH:MM:SS` format(e.g. `365.23:59:59`). If the desired maximum cache duration is less than 1 day then the maximum cache duration should be specified in the `HH:MM:SS` format(e.g. `23:59:59`).
        """
        cdn_frontdoor_origin_group_id: NotRequired[pulumi.Input[str]]
        """
        The Front Door Origin Group resource ID that the request should be routed to. This overrides the configuration specified in the Front Door Endpoint route.
        """
        compression_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should the Front Door dynamically compress the content? Possible values include `true` or `false`.

        ->**NOTE:** Content won't be compressed on AzureFrontDoor when requested content is smaller than `1 byte` or larger than `1 MB`.
        """
        forwarding_protocol: NotRequired[pulumi.Input[str]]
        """
        The forwarding protocol the request will be redirected as. This overrides the configuration specified in the route to be associated with. Possible values include `MatchRequest`, `HttpOnly` or `HttpsOnly`.

        ->**NOTE:** If the `cdn_frontdoor_origin_group_id` is not defined you cannot set the `forwarding_protocol`.
        """
        query_string_caching_behavior: NotRequired[pulumi.Input[str]]
        """
        `IncludeSpecifiedQueryStrings` query strings specified in the `query_string_parameters` field get included when the cache key gets generated. `UseQueryString` cache every unique URL, each unique URL will have its own cache key. `IgnoreSpecifiedQueryStrings` query strings specified in the `query_string_parameters` field get excluded when the cache key gets generated. `IgnoreQueryString` query strings aren't considered when the cache key gets generated. Possible values include `IgnoreQueryString`, `UseQueryString`, `IgnoreSpecifiedQueryStrings` or `IncludeSpecifiedQueryStrings`.
        """
        query_string_parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of query string parameter names.

        ->**NOTE:** `query_string_parameters` is a required field when the `query_string_caching_behavior` is set to `IncludeSpecifiedQueryStrings` or `IgnoreSpecifiedQueryStrings`.
        """
elif False:
    FrontdoorRuleActionsRouteConfigurationOverrideActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontdoorRuleActionsRouteConfigurationOverrideActionArgs:
    def __init__(__self__, *,
                 cache_behavior: Optional[pulumi.Input[str]] = None,
                 cache_duration: Optional[pulumi.Input[str]] = None,
                 cdn_frontdoor_origin_group_id: Optional[pulumi.Input[str]] = None,
                 compression_enabled: Optional[pulumi.Input[bool]] = None,
                 forwarding_protocol: Optional[pulumi.Input[str]] = None,
                 query_string_caching_behavior: Optional[pulumi.Input[str]] = None,
                 query_string_parameters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] cache_behavior: `HonorOrigin` the Front Door will always honor origin response header directive. If the origin directive is missing, Front Door will cache contents anywhere from `1` to `3` days. `OverrideAlways` the TTL value returned from your Front Door Origin is overwritten with the value specified in the action. This behavior will only be applied if the response is cacheable. `OverrideIfOriginMissing` if no TTL value gets returned from your Front Door Origin, the rule sets the TTL to the value specified in the action. This behavior will only be applied if the response is cacheable. `Disabled` the Front Door will not cache the response contents, irrespective of Front Door Origin response directives. Possible values include `HonorOrigin`, `OverrideAlways`, `OverrideIfOriginMissing` or `Disabled`.
        :param pulumi.Input[str] cache_duration: When Cache behavior is set to `Override` or `SetIfMissing`, this field specifies the cache duration to use. The maximum duration is 366 days specified in the `d.HH:MM:SS` format(e.g. `365.23:59:59`). If the desired maximum cache duration is less than 1 day then the maximum cache duration should be specified in the `HH:MM:SS` format(e.g. `23:59:59`).
        :param pulumi.Input[str] cdn_frontdoor_origin_group_id: The Front Door Origin Group resource ID that the request should be routed to. This overrides the configuration specified in the Front Door Endpoint route.
        :param pulumi.Input[bool] compression_enabled: Should the Front Door dynamically compress the content? Possible values include `true` or `false`.
               
               ->**NOTE:** Content won't be compressed on AzureFrontDoor when requested content is smaller than `1 byte` or larger than `1 MB`.
        :param pulumi.Input[str] forwarding_protocol: The forwarding protocol the request will be redirected as. This overrides the configuration specified in the route to be associated with. Possible values include `MatchRequest`, `HttpOnly` or `HttpsOnly`.
               
               ->**NOTE:** If the `cdn_frontdoor_origin_group_id` is not defined you cannot set the `forwarding_protocol`.
        :param pulumi.Input[str] query_string_caching_behavior: `IncludeSpecifiedQueryStrings` query strings specified in the `query_string_parameters` field get included when the cache key gets generated. `UseQueryString` cache every unique URL, each unique URL will have its own cache key. `IgnoreSpecifiedQueryStrings` query strings specified in the `query_string_parameters` field get excluded when the cache key gets generated. `IgnoreQueryString` query strings aren't considered when the cache key gets generated. Possible values include `IgnoreQueryString`, `UseQueryString`, `IgnoreSpecifiedQueryStrings` or `IncludeSpecifiedQueryStrings`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] query_string_parameters: A list of query string parameter names.
               
               ->**NOTE:** `query_string_parameters` is a required field when the `query_string_caching_behavior` is set to `IncludeSpecifiedQueryStrings` or `IgnoreSpecifiedQueryStrings`.
        """
        if cache_behavior is not None:
            pulumi.set(__self__, "cache_behavior", cache_behavior)
        if cache_duration is not None:
            pulumi.set(__self__, "cache_duration", cache_duration)
        if cdn_frontdoor_origin_group_id is not None:
            pulumi.set(__self__, "cdn_frontdoor_origin_group_id", cdn_frontdoor_origin_group_id)
        if compression_enabled is not None:
            pulumi.set(__self__, "compression_enabled", compression_enabled)
        if forwarding_protocol is not None:
            pulumi.set(__self__, "forwarding_protocol", forwarding_protocol)
        if query_string_caching_behavior is not None:
            pulumi.set(__self__, "query_string_caching_behavior", query_string_caching_behavior)
        if query_string_parameters is not None:
            pulumi.set(__self__, "query_string_parameters", query_string_parameters)

    @property
    @pulumi.getter(name="cacheBehavior")
    def cache_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        `HonorOrigin` the Front Door will always honor origin response header directive. If the origin directive is missing, Front Door will cache contents anywhere from `1` to `3` days. `OverrideAlways` the TTL value returned from your Front Door Origin is overwritten with the value specified in the action. This behavior will only be applied if the response is cacheable. `OverrideIfOriginMissing` if no TTL value gets returned from your Front Door Origin, the rule sets the TTL to the value specified in the action. This behavior will only be applied if the response is cacheable. `Disabled` the Front Door will not cache the response contents, irrespective of Front Door Origin response directives. Possible values include `HonorOrigin`, `OverrideAlways`, `OverrideIfOriginMissing` or `Disabled`.
        """
        return pulumi.get(self, "cache_behavior")

    @cache_behavior.setter
    def cache_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cache_behavior", value)

    @property
    @pulumi.getter(name="cacheDuration")
    def cache_duration(self) -> Optional[pulumi.Input[str]]:
        """
        When Cache behavior is set to `Override` or `SetIfMissing`, this field specifies the cache duration to use. The maximum duration is 366 days specified in the `d.HH:MM:SS` format(e.g. `365.23:59:59`). If the desired maximum cache duration is less than 1 day then the maximum cache duration should be specified in the `HH:MM:SS` format(e.g. `23:59:59`).
        """
        return pulumi.get(self, "cache_duration")

    @cache_duration.setter
    def cache_duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cache_duration", value)

    @property
    @pulumi.getter(name="cdnFrontdoorOriginGroupId")
    def cdn_frontdoor_origin_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Front Door Origin Group resource ID that the request should be routed to. This overrides the configuration specified in the Front Door Endpoint route.
        """
        return pulumi.get(self, "cdn_frontdoor_origin_group_id")

    @cdn_frontdoor_origin_group_id.setter
    def cdn_frontdoor_origin_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cdn_frontdoor_origin_group_id", value)

    @property
    @pulumi.getter(name="compressionEnabled")
    def compression_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Front Door dynamically compress the content? Possible values include `true` or `false`.

        ->**NOTE:** Content won't be compressed on AzureFrontDoor when requested content is smaller than `1 byte` or larger than `1 MB`.
        """
        return pulumi.get(self, "compression_enabled")

    @compression_enabled.setter
    def compression_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "compression_enabled", value)

    @property
    @pulumi.getter(name="forwardingProtocol")
    def forwarding_protocol(self) -> Optional[pulumi.Input[str]]:
        """
        The forwarding protocol the request will be redirected as. This overrides the configuration specified in the route to be associated with. Possible values include `MatchRequest`, `HttpOnly` or `HttpsOnly`.

        ->**NOTE:** If the `cdn_frontdoor_origin_group_id` is not defined you cannot set the `forwarding_protocol`.
        """
        return pulumi.get(self, "forwarding_protocol")

    @forwarding_protocol.setter
    def forwarding_protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "forwarding_protocol", value)

    @property
    @pulumi.getter(name="queryStringCachingBehavior")
    def query_string_caching_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        `IncludeSpecifiedQueryStrings` query strings specified in the `query_string_parameters` field get included when the cache key gets generated. `UseQueryString` cache every unique URL, each unique URL will have its own cache key. `IgnoreSpecifiedQueryStrings` query strings specified in the `query_string_parameters` field get excluded when the cache key gets generated. `IgnoreQueryString` query strings aren't considered when the cache key gets generated. Possible values include `IgnoreQueryString`, `UseQueryString`, `IgnoreSpecifiedQueryStrings` or `IncludeSpecifiedQueryStrings`.
        """
        return pulumi.get(self, "query_string_caching_behavior")

    @query_string_caching_behavior.setter
    def query_string_caching_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query_string_caching_behavior", value)

    @property
    @pulumi.getter(name="queryStringParameters")
    def query_string_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of query string parameter names.

        ->**NOTE:** `query_string_parameters` is a required field when the `query_string_caching_behavior` is set to `IncludeSpecifiedQueryStrings` or `IgnoreSpecifiedQueryStrings`.
        """
        return pulumi.get(self, "query_string_parameters")

    @query_string_parameters.setter
    def query_string_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "query_string_parameters", value)


if not MYPY:
    class FrontdoorRuleActionsUrlRedirectActionArgsDict(TypedDict):
        destination_hostname: pulumi.Input[str]
        """
        The host name you want the request to be redirected to. The value must be a string between `0` and `2048` characters in length, leave blank to preserve the incoming host.
        """
        redirect_type: pulumi.Input[str]
        """
        The response type to return to the requestor. Possible values include `Moved`, `Found` , `TemporaryRedirect` or `PermanentRedirect`.
        """
        destination_fragment: NotRequired[pulumi.Input[str]]
        """
        The fragment to use in the redirect. The value must be a string between `0` and `1024` characters in length, leave blank to preserve the incoming fragment. Defaults to `""`.
        """
        destination_path: NotRequired[pulumi.Input[str]]
        """
        The path to use in the redirect. The value must be a string and include the leading `/`, leave blank to preserve the incoming path. Defaults to `""`.
        """
        query_string: NotRequired[pulumi.Input[str]]
        """
        The query string used in the redirect URL. The value must be in the &lt;key>=&lt;value> or &lt;key>={`action_server_variable`} format and must not include the leading `?`, leave blank to preserve the incoming query string. Maximum allowed length for this field is `2048` characters. Defaults to `""`.
        """
        redirect_protocol: NotRequired[pulumi.Input[str]]
        """
        The protocol the request will be redirected as. Possible values include `MatchRequest`, `Http` or `Https`. Defaults to `MatchRequest`.
        """
elif False:
    FrontdoorRuleActionsUrlRedirectActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontdoorRuleActionsUrlRedirectActionArgs:
    def __init__(__self__, *,
                 destination_hostname: pulumi.Input[str],
                 redirect_type: pulumi.Input[str],
                 destination_fragment: Optional[pulumi.Input[str]] = None,
                 destination_path: Optional[pulumi.Input[str]] = None,
                 query_string: Optional[pulumi.Input[str]] = None,
                 redirect_protocol: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] destination_hostname: The host name you want the request to be redirected to. The value must be a string between `0` and `2048` characters in length, leave blank to preserve the incoming host.
        :param pulumi.Input[str] redirect_type: The response type to return to the requestor. Possible values include `Moved`, `Found` , `TemporaryRedirect` or `PermanentRedirect`.
        :param pulumi.Input[str] destination_fragment: The fragment to use in the redirect. The value must be a string between `0` and `1024` characters in length, leave blank to preserve the incoming fragment. Defaults to `""`.
        :param pulumi.Input[str] destination_path: The path to use in the redirect. The value must be a string and include the leading `/`, leave blank to preserve the incoming path. Defaults to `""`.
        :param pulumi.Input[str] query_string: The query string used in the redirect URL. The value must be in the &lt;key>=&lt;value> or &lt;key>={`action_server_variable`} format and must not include the leading `?`, leave blank to preserve the incoming query string. Maximum allowed length for this field is `2048` characters. Defaults to `""`.
        :param pulumi.Input[str] redirect_protocol: The protocol the request will be redirected as. Possible values include `MatchRequest`, `Http` or `Https`. Defaults to `MatchRequest`.
        """
        pulumi.set(__self__, "destination_hostname", destination_hostname)
        pulumi.set(__self__, "redirect_type", redirect_type)
        if destination_fragment is not None:
            pulumi.set(__self__, "destination_fragment", destination_fragment)
        if destination_path is not None:
            pulumi.set(__self__, "destination_path", destination_path)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if redirect_protocol is not None:
            pulumi.set(__self__, "redirect_protocol", redirect_protocol)

    @property
    @pulumi.getter(name="destinationHostname")
    def destination_hostname(self) -> pulumi.Input[str]:
        """
        The host name you want the request to be redirected to. The value must be a string between `0` and `2048` characters in length, leave blank to preserve the incoming host.
        """
        return pulumi.get(self, "destination_hostname")

    @destination_hostname.setter
    def destination_hostname(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination_hostname", value)

    @property
    @pulumi.getter(name="redirectType")
    def redirect_type(self) -> pulumi.Input[str]:
        """
        The response type to return to the requestor. Possible values include `Moved`, `Found` , `TemporaryRedirect` or `PermanentRedirect`.
        """
        return pulumi.get(self, "redirect_type")

    @redirect_type.setter
    def redirect_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "redirect_type", value)

    @property
    @pulumi.getter(name="destinationFragment")
    def destination_fragment(self) -> Optional[pulumi.Input[str]]:
        """
        The fragment to use in the redirect. The value must be a string between `0` and `1024` characters in length, leave blank to preserve the incoming fragment. Defaults to `""`.
        """
        return pulumi.get(self, "destination_fragment")

    @destination_fragment.setter
    def destination_fragment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_fragment", value)

    @property
    @pulumi.getter(name="destinationPath")
    def destination_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to use in the redirect. The value must be a string and include the leading `/`, leave blank to preserve the incoming path. Defaults to `""`.
        """
        return pulumi.get(self, "destination_path")

    @destination_path.setter
    def destination_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_path", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input[str]]:
        """
        The query string used in the redirect URL. The value must be in the &lt;key>=&lt;value> or &lt;key>={`action_server_variable`} format and must not include the leading `?`, leave blank to preserve the incoming query string. Maximum allowed length for this field is `2048` characters. Defaults to `""`.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="redirectProtocol")
    def redirect_protocol(self) -> Optional[pulumi.Input[str]]:
        """
        The protocol the request will be redirected as. Possible values include `MatchRequest`, `Http` or `Https`. Defaults to `MatchRequest`.
        """
        return pulumi.get(self, "redirect_protocol")

    @redirect_protocol.setter
    def redirect_protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "redirect_protocol", value)


if not MYPY:
    class FrontdoorRuleActionsUrlRewriteActionArgsDict(TypedDict):
        destination: pulumi.Input[str]
        """
        The destination path to use in the rewrite. The destination path overwrites the source pattern.
        """
        source_pattern: pulumi.Input[str]
        """
        The source pattern in the URL path to replace. This uses prefix-based matching. For example, to match all URL paths use a forward slash `"/"` as the source pattern value.
        """
        preserve_unmatched_path: NotRequired[pulumi.Input[bool]]
        """
        Append the remaining path after the source pattern to the new destination path? Possible values `true` or `false`. Defaults to `false`.
        """
elif False:
    FrontdoorRuleActionsUrlRewriteActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontdoorRuleActionsUrlRewriteActionArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str],
                 source_pattern: pulumi.Input[str],
                 preserve_unmatched_path: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] destination: The destination path to use in the rewrite. The destination path overwrites the source pattern.
        :param pulumi.Input[str] source_pattern: The source pattern in the URL path to replace. This uses prefix-based matching. For example, to match all URL paths use a forward slash `"/"` as the source pattern value.
        :param pulumi.Input[bool] preserve_unmatched_path: Append the remaining path after the source pattern to the new destination path? Possible values `true` or `false`. Defaults to `false`.
        """
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "source_pattern", source_pattern)
        if preserve_unmatched_path is not None:
            pulumi.set(__self__, "preserve_unmatched_path", preserve_unmatched_path)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        """
        The destination path to use in the rewrite. The destination path overwrites the source pattern.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="sourcePattern")
    def source_pattern(self) -> pulumi.Input[str]:
        """
        The source pattern in the URL path to replace. This uses prefix-based matching. For example, to match all URL paths use a forward slash `"/"` as the source pattern value.
        """
        return pulumi.get(self, "source_pattern")

    @source_pattern.setter
    def source_pattern(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_pattern", value)

    @property
    @pulumi.getter(name="preserveUnmatchedPath")
    def preserve_unmatched_path(self) -> Optional[pulumi.Input[bool]]:
        """
        Append the remaining path after the source pattern to the new destination path? Possible values `true` or `false`. Defaults to `false`.
        """
        return pulumi.get(self, "preserve_unmatched_path")

    @preserve_unmatched_path.setter
    def preserve_unmatched_path(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preserve_unmatched_path", value)


if not MYPY:
    class FrontdoorRuleConditionsArgsDict(TypedDict):
        client_port_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsClientPortConditionArgsDict']]]]
        """
        A `client_port_condition` block as defined below.
        """
        cookies_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsCookiesConditionArgsDict']]]]
        """
        A `cookies_condition` block as defined below.
        """
        host_name_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsHostNameConditionArgsDict']]]]
        """
        A `host_name_condition` block as defined below.
        """
        http_version_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsHttpVersionConditionArgsDict']]]]
        """
        A `http_version_condition` block as defined below.
        """
        is_device_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsIsDeviceConditionArgsDict']]]]
        """
        A `is_device_condition` block as defined below.
        """
        post_args_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsPostArgsConditionArgsDict']]]]
        """
        A `post_args_condition` block as defined below.
        """
        query_string_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsQueryStringConditionArgsDict']]]]
        """
        A `query_string_condition` block as defined below.
        """
        remote_address_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsRemoteAddressConditionArgsDict']]]]
        """
        A `remote_address_condition` block as defined below.
        """
        request_body_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsRequestBodyConditionArgsDict']]]]
        """
        A `request_body_condition` block as defined below.
        """
        request_header_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsRequestHeaderConditionArgsDict']]]]
        """
        A `request_header_condition` block as defined below.
        """
        request_method_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsRequestMethodConditionArgsDict']]]]
        """
        A `request_method_condition` block as defined below.
        """
        request_scheme_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsRequestSchemeConditionArgsDict']]]]
        """
        A `request_scheme_condition` block as defined below.
        """
        request_uri_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsRequestUriConditionArgsDict']]]]
        """
        A `request_uri_condition` block as defined below.
        """
        server_port_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsServerPortConditionArgsDict']]]]
        """
        A `server_port_condition` block as defined below.
        """
        socket_address_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsSocketAddressConditionArgsDict']]]]
        """
        A `socket_address_condition` block as defined below.
        """
        ssl_protocol_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsSslProtocolConditionArgsDict']]]]
        """
        A `ssl_protocol_condition` block as defined below.
        """
        url_file_extension_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsUrlFileExtensionConditionArgsDict']]]]
        """
        A `url_file_extension_condition` block as defined below.
        """
        url_filename_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsUrlFilenameConditionArgsDict']]]]
        """
        A `url_filename_condition` block as defined below.
        """
        url_path_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsUrlPathConditionArgsDict']]]]
        """
        A `url_path_condition` block as defined below.
        """
elif False:
    FrontdoorRuleConditionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontdoorRuleConditionsArgs:
    def __init__(__self__, *,
                 client_port_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsClientPortConditionArgs']]]] = None,
                 cookies_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsCookiesConditionArgs']]]] = None,
                 host_name_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsHostNameConditionArgs']]]] = None,
                 http_version_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsHttpVersionConditionArgs']]]] = None,
                 is_device_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsIsDeviceConditionArgs']]]] = None,
                 post_args_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsPostArgsConditionArgs']]]] = None,
                 query_string_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsQueryStringConditionArgs']]]] = None,
                 remote_address_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsRemoteAddressConditionArgs']]]] = None,
                 request_body_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsRequestBodyConditionArgs']]]] = None,
                 request_header_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsRequestHeaderConditionArgs']]]] = None,
                 request_method_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsRequestMethodConditionArgs']]]] = None,
                 request_scheme_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsRequestSchemeConditionArgs']]]] = None,
                 request_uri_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsRequestUriConditionArgs']]]] = None,
                 server_port_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsServerPortConditionArgs']]]] = None,
                 socket_address_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsSocketAddressConditionArgs']]]] = None,
                 ssl_protocol_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsSslProtocolConditionArgs']]]] = None,
                 url_file_extension_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsUrlFileExtensionConditionArgs']]]] = None,
                 url_filename_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsUrlFilenameConditionArgs']]]] = None,
                 url_path_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsUrlPathConditionArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsClientPortConditionArgs']]] client_port_conditions: A `client_port_condition` block as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsCookiesConditionArgs']]] cookies_conditions: A `cookies_condition` block as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsHostNameConditionArgs']]] host_name_conditions: A `host_name_condition` block as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsHttpVersionConditionArgs']]] http_version_conditions: A `http_version_condition` block as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsIsDeviceConditionArgs']]] is_device_conditions: A `is_device_condition` block as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsPostArgsConditionArgs']]] post_args_conditions: A `post_args_condition` block as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsQueryStringConditionArgs']]] query_string_conditions: A `query_string_condition` block as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsRemoteAddressConditionArgs']]] remote_address_conditions: A `remote_address_condition` block as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsRequestBodyConditionArgs']]] request_body_conditions: A `request_body_condition` block as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsRequestHeaderConditionArgs']]] request_header_conditions: A `request_header_condition` block as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsRequestMethodConditionArgs']]] request_method_conditions: A `request_method_condition` block as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsRequestSchemeConditionArgs']]] request_scheme_conditions: A `request_scheme_condition` block as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsRequestUriConditionArgs']]] request_uri_conditions: A `request_uri_condition` block as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsServerPortConditionArgs']]] server_port_conditions: A `server_port_condition` block as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsSocketAddressConditionArgs']]] socket_address_conditions: A `socket_address_condition` block as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsSslProtocolConditionArgs']]] ssl_protocol_conditions: A `ssl_protocol_condition` block as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsUrlFileExtensionConditionArgs']]] url_file_extension_conditions: A `url_file_extension_condition` block as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsUrlFilenameConditionArgs']]] url_filename_conditions: A `url_filename_condition` block as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsUrlPathConditionArgs']]] url_path_conditions: A `url_path_condition` block as defined below.
        """
        if client_port_conditions is not None:
            pulumi.set(__self__, "client_port_conditions", client_port_conditions)
        if cookies_conditions is not None:
            pulumi.set(__self__, "cookies_conditions", cookies_conditions)
        if host_name_conditions is not None:
            pulumi.set(__self__, "host_name_conditions", host_name_conditions)
        if http_version_conditions is not None:
            pulumi.set(__self__, "http_version_conditions", http_version_conditions)
        if is_device_conditions is not None:
            pulumi.set(__self__, "is_device_conditions", is_device_conditions)
        if post_args_conditions is not None:
            pulumi.set(__self__, "post_args_conditions", post_args_conditions)
        if query_string_conditions is not None:
            pulumi.set(__self__, "query_string_conditions", query_string_conditions)
        if remote_address_conditions is not None:
            pulumi.set(__self__, "remote_address_conditions", remote_address_conditions)
        if request_body_conditions is not None:
            pulumi.set(__self__, "request_body_conditions", request_body_conditions)
        if request_header_conditions is not None:
            pulumi.set(__self__, "request_header_conditions", request_header_conditions)
        if request_method_conditions is not None:
            pulumi.set(__self__, "request_method_conditions", request_method_conditions)
        if request_scheme_conditions is not None:
            pulumi.set(__self__, "request_scheme_conditions", request_scheme_conditions)
        if request_uri_conditions is not None:
            pulumi.set(__self__, "request_uri_conditions", request_uri_conditions)
        if server_port_conditions is not None:
            pulumi.set(__self__, "server_port_conditions", server_port_conditions)
        if socket_address_conditions is not None:
            pulumi.set(__self__, "socket_address_conditions", socket_address_conditions)
        if ssl_protocol_conditions is not None:
            pulumi.set(__self__, "ssl_protocol_conditions", ssl_protocol_conditions)
        if url_file_extension_conditions is not None:
            pulumi.set(__self__, "url_file_extension_conditions", url_file_extension_conditions)
        if url_filename_conditions is not None:
            pulumi.set(__self__, "url_filename_conditions", url_filename_conditions)
        if url_path_conditions is not None:
            pulumi.set(__self__, "url_path_conditions", url_path_conditions)

    @property
    @pulumi.getter(name="clientPortConditions")
    def client_port_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsClientPortConditionArgs']]]]:
        """
        A `client_port_condition` block as defined below.
        """
        return pulumi.get(self, "client_port_conditions")

    @client_port_conditions.setter
    def client_port_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsClientPortConditionArgs']]]]):
        pulumi.set(self, "client_port_conditions", value)

    @property
    @pulumi.getter(name="cookiesConditions")
    def cookies_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsCookiesConditionArgs']]]]:
        """
        A `cookies_condition` block as defined below.
        """
        return pulumi.get(self, "cookies_conditions")

    @cookies_conditions.setter
    def cookies_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsCookiesConditionArgs']]]]):
        pulumi.set(self, "cookies_conditions", value)

    @property
    @pulumi.getter(name="hostNameConditions")
    def host_name_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsHostNameConditionArgs']]]]:
        """
        A `host_name_condition` block as defined below.
        """
        return pulumi.get(self, "host_name_conditions")

    @host_name_conditions.setter
    def host_name_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsHostNameConditionArgs']]]]):
        pulumi.set(self, "host_name_conditions", value)

    @property
    @pulumi.getter(name="httpVersionConditions")
    def http_version_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsHttpVersionConditionArgs']]]]:
        """
        A `http_version_condition` block as defined below.
        """
        return pulumi.get(self, "http_version_conditions")

    @http_version_conditions.setter
    def http_version_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsHttpVersionConditionArgs']]]]):
        pulumi.set(self, "http_version_conditions", value)

    @property
    @pulumi.getter(name="isDeviceConditions")
    def is_device_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsIsDeviceConditionArgs']]]]:
        """
        A `is_device_condition` block as defined below.
        """
        return pulumi.get(self, "is_device_conditions")

    @is_device_conditions.setter
    def is_device_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsIsDeviceConditionArgs']]]]):
        pulumi.set(self, "is_device_conditions", value)

    @property
    @pulumi.getter(name="postArgsConditions")
    def post_args_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsPostArgsConditionArgs']]]]:
        """
        A `post_args_condition` block as defined below.
        """
        return pulumi.get(self, "post_args_conditions")

    @post_args_conditions.setter
    def post_args_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsPostArgsConditionArgs']]]]):
        pulumi.set(self, "post_args_conditions", value)

    @property
    @pulumi.getter(name="queryStringConditions")
    def query_string_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsQueryStringConditionArgs']]]]:
        """
        A `query_string_condition` block as defined below.
        """
        return pulumi.get(self, "query_string_conditions")

    @query_string_conditions.setter
    def query_string_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsQueryStringConditionArgs']]]]):
        pulumi.set(self, "query_string_conditions", value)

    @property
    @pulumi.getter(name="remoteAddressConditions")
    def remote_address_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsRemoteAddressConditionArgs']]]]:
        """
        A `remote_address_condition` block as defined below.
        """
        return pulumi.get(self, "remote_address_conditions")

    @remote_address_conditions.setter
    def remote_address_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsRemoteAddressConditionArgs']]]]):
        pulumi.set(self, "remote_address_conditions", value)

    @property
    @pulumi.getter(name="requestBodyConditions")
    def request_body_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsRequestBodyConditionArgs']]]]:
        """
        A `request_body_condition` block as defined below.
        """
        return pulumi.get(self, "request_body_conditions")

    @request_body_conditions.setter
    def request_body_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsRequestBodyConditionArgs']]]]):
        pulumi.set(self, "request_body_conditions", value)

    @property
    @pulumi.getter(name="requestHeaderConditions")
    def request_header_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsRequestHeaderConditionArgs']]]]:
        """
        A `request_header_condition` block as defined below.
        """
        return pulumi.get(self, "request_header_conditions")

    @request_header_conditions.setter
    def request_header_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsRequestHeaderConditionArgs']]]]):
        pulumi.set(self, "request_header_conditions", value)

    @property
    @pulumi.getter(name="requestMethodConditions")
    def request_method_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsRequestMethodConditionArgs']]]]:
        """
        A `request_method_condition` block as defined below.
        """
        return pulumi.get(self, "request_method_conditions")

    @request_method_conditions.setter
    def request_method_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsRequestMethodConditionArgs']]]]):
        pulumi.set(self, "request_method_conditions", value)

    @property
    @pulumi.getter(name="requestSchemeConditions")
    def request_scheme_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsRequestSchemeConditionArgs']]]]:
        """
        A `request_scheme_condition` block as defined below.
        """
        return pulumi.get(self, "request_scheme_conditions")

    @request_scheme_conditions.setter
    def request_scheme_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsRequestSchemeConditionArgs']]]]):
        pulumi.set(self, "request_scheme_conditions", value)

    @property
    @pulumi.getter(name="requestUriConditions")
    def request_uri_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsRequestUriConditionArgs']]]]:
        """
        A `request_uri_condition` block as defined below.
        """
        return pulumi.get(self, "request_uri_conditions")

    @request_uri_conditions.setter
    def request_uri_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsRequestUriConditionArgs']]]]):
        pulumi.set(self, "request_uri_conditions", value)

    @property
    @pulumi.getter(name="serverPortConditions")
    def server_port_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsServerPortConditionArgs']]]]:
        """
        A `server_port_condition` block as defined below.
        """
        return pulumi.get(self, "server_port_conditions")

    @server_port_conditions.setter
    def server_port_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsServerPortConditionArgs']]]]):
        pulumi.set(self, "server_port_conditions", value)

    @property
    @pulumi.getter(name="socketAddressConditions")
    def socket_address_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsSocketAddressConditionArgs']]]]:
        """
        A `socket_address_condition` block as defined below.
        """
        return pulumi.get(self, "socket_address_conditions")

    @socket_address_conditions.setter
    def socket_address_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsSocketAddressConditionArgs']]]]):
        pulumi.set(self, "socket_address_conditions", value)

    @property
    @pulumi.getter(name="sslProtocolConditions")
    def ssl_protocol_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsSslProtocolConditionArgs']]]]:
        """
        A `ssl_protocol_condition` block as defined below.
        """
        return pulumi.get(self, "ssl_protocol_conditions")

    @ssl_protocol_conditions.setter
    def ssl_protocol_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsSslProtocolConditionArgs']]]]):
        pulumi.set(self, "ssl_protocol_conditions", value)

    @property
    @pulumi.getter(name="urlFileExtensionConditions")
    def url_file_extension_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsUrlFileExtensionConditionArgs']]]]:
        """
        A `url_file_extension_condition` block as defined below.
        """
        return pulumi.get(self, "url_file_extension_conditions")

    @url_file_extension_conditions.setter
    def url_file_extension_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsUrlFileExtensionConditionArgs']]]]):
        pulumi.set(self, "url_file_extension_conditions", value)

    @property
    @pulumi.getter(name="urlFilenameConditions")
    def url_filename_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsUrlFilenameConditionArgs']]]]:
        """
        A `url_filename_condition` block as defined below.
        """
        return pulumi.get(self, "url_filename_conditions")

    @url_filename_conditions.setter
    def url_filename_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsUrlFilenameConditionArgs']]]]):
        pulumi.set(self, "url_filename_conditions", value)

    @property
    @pulumi.getter(name="urlPathConditions")
    def url_path_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsUrlPathConditionArgs']]]]:
        """
        A `url_path_condition` block as defined below.
        """
        return pulumi.get(self, "url_path_conditions")

    @url_path_conditions.setter
    def url_path_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FrontdoorRuleConditionsUrlPathConditionArgs']]]]):
        pulumi.set(self, "url_path_conditions", value)


if not MYPY:
    class FrontdoorRuleConditionsClientPortConditionArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        """
        match_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        One or more integer values(e.g. "1") representing the value of the client port to match. If multiple values are specified, they're evaluated using `OR` logic.
        """
        negate_condition: NotRequired[pulumi.Input[bool]]
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
elif False:
    FrontdoorRuleConditionsClientPortConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontdoorRuleConditionsClientPortConditionArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 negate_condition: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] operator: A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: One or more integer values(e.g. "1") representing the value of the client port to match. If multiple values are specified, they're evaluated using `OR` logic.
        :param pulumi.Input[bool] negate_condition: If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        pulumi.set(__self__, "operator", operator)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        One or more integer values(e.g. "1") representing the value of the client port to match. If multiple values are specified, they're evaluated using `OR` logic.
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)


if not MYPY:
    class FrontdoorRuleConditionsCookiesConditionArgsDict(TypedDict):
        cookie_name: pulumi.Input[str]
        """
        A string value representing the name of the cookie.
        """
        operator: pulumi.Input[str]
        """
        A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        """
        match_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        One or more string or integer values(e.g. "1") representing the value of the request header to match. If multiple values are specified, they're evaluated using `OR` logic.
        """
        negate_condition: NotRequired[pulumi.Input[bool]]
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        transforms: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Details can be found in the `Condition Transform List` below.
        """
elif False:
    FrontdoorRuleConditionsCookiesConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontdoorRuleConditionsCookiesConditionArgs:
    def __init__(__self__, *,
                 cookie_name: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 transforms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] cookie_name: A string value representing the name of the cookie.
        :param pulumi.Input[str] operator: A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: One or more string or integer values(e.g. "1") representing the value of the request header to match. If multiple values are specified, they're evaluated using `OR` logic.
        :param pulumi.Input[bool] negate_condition: If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] transforms: A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Details can be found in the `Condition Transform List` below.
        """
        pulumi.set(__self__, "cookie_name", cookie_name)
        pulumi.set(__self__, "operator", operator)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter(name="cookieName")
    def cookie_name(self) -> pulumi.Input[str]:
        """
        A string value representing the name of the cookie.
        """
        return pulumi.get(self, "cookie_name")

    @cookie_name.setter
    def cookie_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "cookie_name", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        One or more string or integer values(e.g. "1") representing the value of the request header to match. If multiple values are specified, they're evaluated using `OR` logic.
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def transforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Details can be found in the `Condition Transform List` below.
        """
        return pulumi.get(self, "transforms")

    @transforms.setter
    def transforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "transforms", value)


if not MYPY:
    class FrontdoorRuleConditionsHostNameConditionArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        """
        match_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of one or more string values representing the value of the request hostname to match. If multiple values are specified, they're evaluated using `OR` logic.
        """
        negate_condition: NotRequired[pulumi.Input[bool]]
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        transforms: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Details can be found in the `Condition Transform List` below.
        """
elif False:
    FrontdoorRuleConditionsHostNameConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontdoorRuleConditionsHostNameConditionArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 transforms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] operator: A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: A list of one or more string values representing the value of the request hostname to match. If multiple values are specified, they're evaluated using `OR` logic.
        :param pulumi.Input[bool] negate_condition: If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] transforms: A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Details can be found in the `Condition Transform List` below.
        """
        pulumi.set(__self__, "operator", operator)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of one or more string values representing the value of the request hostname to match. If multiple values are specified, they're evaluated using `OR` logic.
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def transforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Details can be found in the `Condition Transform List` below.
        """
        return pulumi.get(self, "transforms")

    @transforms.setter
    def transforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "transforms", value)


if not MYPY:
    class FrontdoorRuleConditionsHttpVersionConditionArgsDict(TypedDict):
        match_values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        What HTTP version should this condition match? Possible values `2.0`, `1.1`, `1.0` or `0.9`.
        """
        negate_condition: NotRequired[pulumi.Input[bool]]
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        operator: NotRequired[pulumi.Input[str]]
        """
        Possible value `Equal`. Defaults to `Equal`.
        """
elif False:
    FrontdoorRuleConditionsHttpVersionConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontdoorRuleConditionsHttpVersionConditionArgs:
    def __init__(__self__, *,
                 match_values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 operator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: What HTTP version should this condition match? Possible values `2.0`, `1.1`, `1.0` or `0.9`.
        :param pulumi.Input[bool] negate_condition: If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        :param pulumi.Input[str] operator: Possible value `Equal`. Defaults to `Equal`.
        """
        pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        What HTTP version should this condition match? Possible values `2.0`, `1.1`, `1.0` or `0.9`.
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        Possible value `Equal`. Defaults to `Equal`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)


if not MYPY:
    class FrontdoorRuleConditionsIsDeviceConditionArgsDict(TypedDict):
        match_values: NotRequired[pulumi.Input[str]]
        """
        Which device should this rule match on? Possible values `Mobile` or `Desktop`.
        """
        negate_condition: NotRequired[pulumi.Input[bool]]
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        operator: NotRequired[pulumi.Input[str]]
        """
        Possible value `Equal`. Defaults to `Equal`.
        """
elif False:
    FrontdoorRuleConditionsIsDeviceConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontdoorRuleConditionsIsDeviceConditionArgs:
    def __init__(__self__, *,
                 match_values: Optional[pulumi.Input[str]] = None,
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 operator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] match_values: Which device should this rule match on? Possible values `Mobile` or `Desktop`.
        :param pulumi.Input[bool] negate_condition: If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        :param pulumi.Input[str] operator: Possible value `Equal`. Defaults to `Equal`.
        """
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[pulumi.Input[str]]:
        """
        Which device should this rule match on? Possible values `Mobile` or `Desktop`.
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        Possible value `Equal`. Defaults to `Equal`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)


if not MYPY:
    class FrontdoorRuleConditionsPostArgsConditionArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        """
        post_args_name: pulumi.Input[str]
        """
        A string value representing the name of the `POST` argument.
        """
        match_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        One or more string or integer values(e.g. "1") representing the value of the `POST` argument to match. If multiple values are specified, they're evaluated using `OR` logic.
        """
        negate_condition: NotRequired[pulumi.Input[bool]]
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        transforms: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Details can be found in the `Condition Transform List` below.
        """
elif False:
    FrontdoorRuleConditionsPostArgsConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontdoorRuleConditionsPostArgsConditionArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 post_args_name: pulumi.Input[str],
                 match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 transforms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] operator: A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        :param pulumi.Input[str] post_args_name: A string value representing the name of the `POST` argument.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: One or more string or integer values(e.g. "1") representing the value of the `POST` argument to match. If multiple values are specified, they're evaluated using `OR` logic.
        :param pulumi.Input[bool] negate_condition: If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] transforms: A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Details can be found in the `Condition Transform List` below.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "post_args_name", post_args_name)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="postArgsName")
    def post_args_name(self) -> pulumi.Input[str]:
        """
        A string value representing the name of the `POST` argument.
        """
        return pulumi.get(self, "post_args_name")

    @post_args_name.setter
    def post_args_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "post_args_name", value)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        One or more string or integer values(e.g. "1") representing the value of the `POST` argument to match. If multiple values are specified, they're evaluated using `OR` logic.
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def transforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Details can be found in the `Condition Transform List` below.
        """
        return pulumi.get(self, "transforms")

    @transforms.setter
    def transforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "transforms", value)


if not MYPY:
    class FrontdoorRuleConditionsQueryStringConditionArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        """
        match_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        One or more string or integer values(e.g. "1") representing the value of the query string to match. If multiple values are specified, they're evaluated using `OR` logic.
        """
        negate_condition: NotRequired[pulumi.Input[bool]]
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        transforms: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Details can be found in the `Condition Transform List` below.
        """
elif False:
    FrontdoorRuleConditionsQueryStringConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontdoorRuleConditionsQueryStringConditionArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 transforms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] operator: A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: One or more string or integer values(e.g. "1") representing the value of the query string to match. If multiple values are specified, they're evaluated using `OR` logic.
        :param pulumi.Input[bool] negate_condition: If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] transforms: A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Details can be found in the `Condition Transform List` below.
        """
        pulumi.set(__self__, "operator", operator)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        One or more string or integer values(e.g. "1") representing the value of the query string to match. If multiple values are specified, they're evaluated using `OR` logic.
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def transforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Details can be found in the `Condition Transform List` below.
        """
        return pulumi.get(self, "transforms")

    @transforms.setter
    def transforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "transforms", value)


if not MYPY:
    class FrontdoorRuleConditionsRemoteAddressConditionArgsDict(TypedDict):
        match_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        For the IP Match or IP Not Match operators: specify one or more IP address ranges. If multiple IP address ranges are specified, they're evaluated using `OR` logic. For the Geo Match or Geo Not Match operators: specify one or more locations using their country code.

        ->**NOTE:** See the `Specifying IP Address Ranges` section below on how to correctly define the `match_values` field.
        """
        negate_condition: NotRequired[pulumi.Input[bool]]
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        operator: NotRequired[pulumi.Input[str]]
        """
        The type of the remote address to match. Possible values include `Any`, `GeoMatch` or `IPMatch`. Use the `negate_condition` to specify Not `GeoMatch` or Not `IPMatch`. Defaults to `IPMatch`.
        """
elif False:
    FrontdoorRuleConditionsRemoteAddressConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontdoorRuleConditionsRemoteAddressConditionArgs:
    def __init__(__self__, *,
                 match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 operator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: For the IP Match or IP Not Match operators: specify one or more IP address ranges. If multiple IP address ranges are specified, they're evaluated using `OR` logic. For the Geo Match or Geo Not Match operators: specify one or more locations using their country code.
               
               ->**NOTE:** See the `Specifying IP Address Ranges` section below on how to correctly define the `match_values` field.
        :param pulumi.Input[bool] negate_condition: If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        :param pulumi.Input[str] operator: The type of the remote address to match. Possible values include `Any`, `GeoMatch` or `IPMatch`. Use the `negate_condition` to specify Not `GeoMatch` or Not `IPMatch`. Defaults to `IPMatch`.
        """
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        For the IP Match or IP Not Match operators: specify one or more IP address ranges. If multiple IP address ranges are specified, they're evaluated using `OR` logic. For the Geo Match or Geo Not Match operators: specify one or more locations using their country code.

        ->**NOTE:** See the `Specifying IP Address Ranges` section below on how to correctly define the `match_values` field.
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        The type of the remote address to match. Possible values include `Any`, `GeoMatch` or `IPMatch`. Use the `negate_condition` to specify Not `GeoMatch` or Not `IPMatch`. Defaults to `IPMatch`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)


if not MYPY:
    class FrontdoorRuleConditionsRequestBodyConditionArgsDict(TypedDict):
        match_values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list of one or more string or integer values(e.g. "1") representing the value of the request body text to match. If multiple values are specified, they're evaluated using `OR` logic.
        """
        operator: pulumi.Input[str]
        """
        A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        """
        negate_condition: NotRequired[pulumi.Input[bool]]
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        transforms: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Details can be found in the `Condition Transform List` below.
        """
elif False:
    FrontdoorRuleConditionsRequestBodyConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontdoorRuleConditionsRequestBodyConditionArgs:
    def __init__(__self__, *,
                 match_values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 operator: pulumi.Input[str],
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 transforms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: A list of one or more string or integer values(e.g. "1") representing the value of the request body text to match. If multiple values are specified, they're evaluated using `OR` logic.
        :param pulumi.Input[str] operator: A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        :param pulumi.Input[bool] negate_condition: If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] transforms: A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Details can be found in the `Condition Transform List` below.
        """
        pulumi.set(__self__, "match_values", match_values)
        pulumi.set(__self__, "operator", operator)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of one or more string or integer values(e.g. "1") representing the value of the request body text to match. If multiple values are specified, they're evaluated using `OR` logic.
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def transforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Details can be found in the `Condition Transform List` below.
        """
        return pulumi.get(self, "transforms")

    @transforms.setter
    def transforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "transforms", value)


if not MYPY:
    class FrontdoorRuleConditionsRequestHeaderConditionArgsDict(TypedDict):
        header_name: pulumi.Input[str]
        """
        A string value representing the name of the `POST` argument.
        """
        operator: pulumi.Input[str]
        """
        A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        """
        match_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        One or more string or integer values(e.g. "1") representing the value of the request header to match. If multiple values are specified, they're evaluated using `OR` logic.
        """
        negate_condition: NotRequired[pulumi.Input[bool]]
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        transforms: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Details can be found in the `Condition Transform List` below.
        """
elif False:
    FrontdoorRuleConditionsRequestHeaderConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontdoorRuleConditionsRequestHeaderConditionArgs:
    def __init__(__self__, *,
                 header_name: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 transforms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] header_name: A string value representing the name of the `POST` argument.
        :param pulumi.Input[str] operator: A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: One or more string or integer values(e.g. "1") representing the value of the request header to match. If multiple values are specified, they're evaluated using `OR` logic.
        :param pulumi.Input[bool] negate_condition: If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] transforms: A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Details can be found in the `Condition Transform List` below.
        """
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "operator", operator)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[str]:
        """
        A string value representing the name of the `POST` argument.
        """
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_name", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        One or more string or integer values(e.g. "1") representing the value of the request header to match. If multiple values are specified, they're evaluated using `OR` logic.
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def transforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Details can be found in the `Condition Transform List` below.
        """
        return pulumi.get(self, "transforms")

    @transforms.setter
    def transforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "transforms", value)


if not MYPY:
    class FrontdoorRuleConditionsRequestMethodConditionArgsDict(TypedDict):
        match_values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list of one or more HTTP methods. Possible values include `GET`, `POST`, `PUT`, `DELETE`, `HEAD`, `OPTIONS` or `TRACE`. If multiple values are specified, they're evaluated using `OR` logic.
        """
        negate_condition: NotRequired[pulumi.Input[bool]]
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        operator: NotRequired[pulumi.Input[str]]
        """
        Possible value `Equal`. Defaults to `Equal`.
        """
elif False:
    FrontdoorRuleConditionsRequestMethodConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontdoorRuleConditionsRequestMethodConditionArgs:
    def __init__(__self__, *,
                 match_values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 operator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: A list of one or more HTTP methods. Possible values include `GET`, `POST`, `PUT`, `DELETE`, `HEAD`, `OPTIONS` or `TRACE`. If multiple values are specified, they're evaluated using `OR` logic.
        :param pulumi.Input[bool] negate_condition: If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        :param pulumi.Input[str] operator: Possible value `Equal`. Defaults to `Equal`.
        """
        pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of one or more HTTP methods. Possible values include `GET`, `POST`, `PUT`, `DELETE`, `HEAD`, `OPTIONS` or `TRACE`. If multiple values are specified, they're evaluated using `OR` logic.
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        Possible value `Equal`. Defaults to `Equal`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)


if not MYPY:
    class FrontdoorRuleConditionsRequestSchemeConditionArgsDict(TypedDict):
        match_values: NotRequired[pulumi.Input[str]]
        """
        The requests protocol to match. Possible values include `HTTP` or `HTTPS`.
        """
        negate_condition: NotRequired[pulumi.Input[bool]]
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        operator: NotRequired[pulumi.Input[str]]
        """
        Possible value `Equal`. Defaults to `Equal`.
        """
elif False:
    FrontdoorRuleConditionsRequestSchemeConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontdoorRuleConditionsRequestSchemeConditionArgs:
    def __init__(__self__, *,
                 match_values: Optional[pulumi.Input[str]] = None,
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 operator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] match_values: The requests protocol to match. Possible values include `HTTP` or `HTTPS`.
        :param pulumi.Input[bool] negate_condition: If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        :param pulumi.Input[str] operator: Possible value `Equal`. Defaults to `Equal`.
        """
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[pulumi.Input[str]]:
        """
        The requests protocol to match. Possible values include `HTTP` or `HTTPS`.
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        Possible value `Equal`. Defaults to `Equal`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)


if not MYPY:
    class FrontdoorRuleConditionsRequestUriConditionArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        """
        match_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        One or more string or integer values(e.g. "1") representing the value of the request URL to match. If multiple values are specified, they're evaluated using `OR` logic.
        """
        negate_condition: NotRequired[pulumi.Input[bool]]
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        transforms: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Details can be found in the `Condition Transform List` below.
        """
elif False:
    FrontdoorRuleConditionsRequestUriConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontdoorRuleConditionsRequestUriConditionArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 transforms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] operator: A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: One or more string or integer values(e.g. "1") representing the value of the request URL to match. If multiple values are specified, they're evaluated using `OR` logic.
        :param pulumi.Input[bool] negate_condition: If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] transforms: A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Details can be found in the `Condition Transform List` below.
        """
        pulumi.set(__self__, "operator", operator)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        One or more string or integer values(e.g. "1") representing the value of the request URL to match. If multiple values are specified, they're evaluated using `OR` logic.
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def transforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Details can be found in the `Condition Transform List` below.
        """
        return pulumi.get(self, "transforms")

    @transforms.setter
    def transforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "transforms", value)


if not MYPY:
    class FrontdoorRuleConditionsServerPortConditionArgsDict(TypedDict):
        match_values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list of one or more integer values(e.g. "1") representing the value of the client port to match. Possible values include `80` or `443`. If multiple values are specified, they're evaluated using `OR` logic.
        """
        operator: pulumi.Input[str]
        """
        A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        """
        negate_condition: NotRequired[pulumi.Input[bool]]
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
elif False:
    FrontdoorRuleConditionsServerPortConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontdoorRuleConditionsServerPortConditionArgs:
    def __init__(__self__, *,
                 match_values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 operator: pulumi.Input[str],
                 negate_condition: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: A list of one or more integer values(e.g. "1") representing the value of the client port to match. Possible values include `80` or `443`. If multiple values are specified, they're evaluated using `OR` logic.
        :param pulumi.Input[str] operator: A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        :param pulumi.Input[bool] negate_condition: If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        pulumi.set(__self__, "match_values", match_values)
        pulumi.set(__self__, "operator", operator)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of one or more integer values(e.g. "1") representing the value of the client port to match. Possible values include `80` or `443`. If multiple values are specified, they're evaluated using `OR` logic.
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)


if not MYPY:
    class FrontdoorRuleConditionsSocketAddressConditionArgsDict(TypedDict):
        match_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify one or more IP address ranges. If multiple IP address ranges are specified, they're evaluated using `OR` logic.

        ->**NOTE:** See the `Specifying IP Address Ranges` section below on how to correctly define the `match_values` field.
        """
        negate_condition: NotRequired[pulumi.Input[bool]]
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        operator: NotRequired[pulumi.Input[str]]
        """
        The type of match. The Possible values are `IpMatch` or `Any`. Defaults to `IPMatch`.

        ->**NOTE:** If the value of the `operator` field is set to `IpMatch` then the `match_values` field is also required.
        """
elif False:
    FrontdoorRuleConditionsSocketAddressConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontdoorRuleConditionsSocketAddressConditionArgs:
    def __init__(__self__, *,
                 match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 operator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: Specify one or more IP address ranges. If multiple IP address ranges are specified, they're evaluated using `OR` logic.
               
               ->**NOTE:** See the `Specifying IP Address Ranges` section below on how to correctly define the `match_values` field.
        :param pulumi.Input[bool] negate_condition: If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        :param pulumi.Input[str] operator: The type of match. The Possible values are `IpMatch` or `Any`. Defaults to `IPMatch`.
               
               ->**NOTE:** If the value of the `operator` field is set to `IpMatch` then the `match_values` field is also required.
        """
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify one or more IP address ranges. If multiple IP address ranges are specified, they're evaluated using `OR` logic.

        ->**NOTE:** See the `Specifying IP Address Ranges` section below on how to correctly define the `match_values` field.
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        The type of match. The Possible values are `IpMatch` or `Any`. Defaults to `IPMatch`.

        ->**NOTE:** If the value of the `operator` field is set to `IpMatch` then the `match_values` field is also required.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)


if not MYPY:
    class FrontdoorRuleConditionsSslProtocolConditionArgsDict(TypedDict):
        match_values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list of one or more HTTP methods. Possible values are `TLSv1`, `TLSv1.1` and `TLSv1.2` logic.
        """
        negate_condition: NotRequired[pulumi.Input[bool]]
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        operator: NotRequired[pulumi.Input[str]]
        """
        Possible value `Equal`. Defaults to `Equal`.
        """
elif False:
    FrontdoorRuleConditionsSslProtocolConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontdoorRuleConditionsSslProtocolConditionArgs:
    def __init__(__self__, *,
                 match_values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 operator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: A list of one or more HTTP methods. Possible values are `TLSv1`, `TLSv1.1` and `TLSv1.2` logic.
        :param pulumi.Input[bool] negate_condition: If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        :param pulumi.Input[str] operator: Possible value `Equal`. Defaults to `Equal`.
        """
        pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of one or more HTTP methods. Possible values are `TLSv1`, `TLSv1.1` and `TLSv1.2` logic.
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        Possible value `Equal`. Defaults to `Equal`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)


if not MYPY:
    class FrontdoorRuleConditionsUrlFileExtensionConditionArgsDict(TypedDict):
        match_values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list of one or more string or integer values(e.g. "1") representing the value of the request file extension to match. If multiple values are specified, they're evaluated using `OR` logic.
        """
        operator: pulumi.Input[str]
        """
        A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        """
        negate_condition: NotRequired[pulumi.Input[bool]]
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        transforms: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Details can be found in the `Condition Transform List` below.
        """
elif False:
    FrontdoorRuleConditionsUrlFileExtensionConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontdoorRuleConditionsUrlFileExtensionConditionArgs:
    def __init__(__self__, *,
                 match_values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 operator: pulumi.Input[str],
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 transforms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: A list of one or more string or integer values(e.g. "1") representing the value of the request file extension to match. If multiple values are specified, they're evaluated using `OR` logic.
        :param pulumi.Input[str] operator: A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        :param pulumi.Input[bool] negate_condition: If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] transforms: A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Details can be found in the `Condition Transform List` below.
        """
        pulumi.set(__self__, "match_values", match_values)
        pulumi.set(__self__, "operator", operator)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of one or more string or integer values(e.g. "1") representing the value of the request file extension to match. If multiple values are specified, they're evaluated using `OR` logic.
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def transforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Details can be found in the `Condition Transform List` below.
        """
        return pulumi.get(self, "transforms")

    @transforms.setter
    def transforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "transforms", value)


if not MYPY:
    class FrontdoorRuleConditionsUrlFilenameConditionArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        """
        match_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of one or more string or integer values(e.g. "1") representing the value of the request file name to match. If multiple values are specified, they're evaluated using `OR` logic.

        > **NOTE:** The `match_values` field is only optional if the `operator` is set to `Any`.
        """
        negate_condition: NotRequired[pulumi.Input[bool]]
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        transforms: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Details can be found in the `Condition Transform List` below.
        """
elif False:
    FrontdoorRuleConditionsUrlFilenameConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontdoorRuleConditionsUrlFilenameConditionArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 transforms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] operator: A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: A list of one or more string or integer values(e.g. "1") representing the value of the request file name to match. If multiple values are specified, they're evaluated using `OR` logic.
               
               > **NOTE:** The `match_values` field is only optional if the `operator` is set to `Any`.
        :param pulumi.Input[bool] negate_condition: If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] transforms: A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Details can be found in the `Condition Transform List` below.
        """
        pulumi.set(__self__, "operator", operator)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of one or more string or integer values(e.g. "1") representing the value of the request file name to match. If multiple values are specified, they're evaluated using `OR` logic.

        > **NOTE:** The `match_values` field is only optional if the `operator` is set to `Any`.
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def transforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Details can be found in the `Condition Transform List` below.
        """
        return pulumi.get(self, "transforms")

    @transforms.setter
    def transforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "transforms", value)


if not MYPY:
    class FrontdoorRuleConditionsUrlPathConditionArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        """
        match_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        One or more string or integer values(e.g. "1") representing the value of the request path to match. Don't include the leading slash (`/`). If multiple values are specified, they're evaluated using `OR` logic.
        """
        negate_condition: NotRequired[pulumi.Input[bool]]
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        transforms: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Details can be found in the `Condition Transform List` below.
        """
elif False:
    FrontdoorRuleConditionsUrlPathConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontdoorRuleConditionsUrlPathConditionArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 transforms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] operator: A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: One or more string or integer values(e.g. "1") representing the value of the request path to match. Don't include the leading slash (`/`). If multiple values are specified, they're evaluated using `OR` logic.
        :param pulumi.Input[bool] negate_condition: If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] transforms: A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Details can be found in the `Condition Transform List` below.
        """
        pulumi.set(__self__, "operator", operator)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        One or more string or integer values(e.g. "1") representing the value of the request path to match. Don't include the leading slash (`/`). If multiple values are specified, they're evaluated using `OR` logic.
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def transforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Details can be found in the `Condition Transform List` below.
        """
        return pulumi.get(self, "transforms")

    @transforms.setter
    def transforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "transforms", value)


if not MYPY:
    class FrontdoorSecretSecretArgsDict(TypedDict):
        customer_certificates: pulumi.Input[Sequence[pulumi.Input['FrontdoorSecretSecretCustomerCertificateArgsDict']]]
        """
        A `customer_certificate` block as defined below. Changing this forces a new Front Door Secret to be created.
        """
elif False:
    FrontdoorSecretSecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontdoorSecretSecretArgs:
    def __init__(__self__, *,
                 customer_certificates: pulumi.Input[Sequence[pulumi.Input['FrontdoorSecretSecretCustomerCertificateArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FrontdoorSecretSecretCustomerCertificateArgs']]] customer_certificates: A `customer_certificate` block as defined below. Changing this forces a new Front Door Secret to be created.
        """
        pulumi.set(__self__, "customer_certificates", customer_certificates)

    @property
    @pulumi.getter(name="customerCertificates")
    def customer_certificates(self) -> pulumi.Input[Sequence[pulumi.Input['FrontdoorSecretSecretCustomerCertificateArgs']]]:
        """
        A `customer_certificate` block as defined below. Changing this forces a new Front Door Secret to be created.
        """
        return pulumi.get(self, "customer_certificates")

    @customer_certificates.setter
    def customer_certificates(self, value: pulumi.Input[Sequence[pulumi.Input['FrontdoorSecretSecretCustomerCertificateArgs']]]):
        pulumi.set(self, "customer_certificates", value)


if not MYPY:
    class FrontdoorSecretSecretCustomerCertificateArgsDict(TypedDict):
        key_vault_certificate_id: pulumi.Input[str]
        """
        The ID of the Key Vault certificate resource to use. Changing this forces a new Front Door Secret to be created.

        ->**NOTE:** If you would like to use the **latest version** of the Key Vault Certificate use the Key Vault Certificates `versionless_id` attribute as the `key_vault_certificate_id` fields value(e.g. `key_vault_certificate_id = azurerm_key_vault_certificate.example.versionless_id`).
        """
        subject_alternative_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        One or more `subject alternative names` contained within the key vault certificate.
        """
elif False:
    FrontdoorSecretSecretCustomerCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontdoorSecretSecretCustomerCertificateArgs:
    def __init__(__self__, *,
                 key_vault_certificate_id: pulumi.Input[str],
                 subject_alternative_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key_vault_certificate_id: The ID of the Key Vault certificate resource to use. Changing this forces a new Front Door Secret to be created.
               
               ->**NOTE:** If you would like to use the **latest version** of the Key Vault Certificate use the Key Vault Certificates `versionless_id` attribute as the `key_vault_certificate_id` fields value(e.g. `key_vault_certificate_id = azurerm_key_vault_certificate.example.versionless_id`).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subject_alternative_names: One or more `subject alternative names` contained within the key vault certificate.
        """
        pulumi.set(__self__, "key_vault_certificate_id", key_vault_certificate_id)
        if subject_alternative_names is not None:
            pulumi.set(__self__, "subject_alternative_names", subject_alternative_names)

    @property
    @pulumi.getter(name="keyVaultCertificateId")
    def key_vault_certificate_id(self) -> pulumi.Input[str]:
        """
        The ID of the Key Vault certificate resource to use. Changing this forces a new Front Door Secret to be created.

        ->**NOTE:** If you would like to use the **latest version** of the Key Vault Certificate use the Key Vault Certificates `versionless_id` attribute as the `key_vault_certificate_id` fields value(e.g. `key_vault_certificate_id = azurerm_key_vault_certificate.example.versionless_id`).
        """
        return pulumi.get(self, "key_vault_certificate_id")

    @key_vault_certificate_id.setter
    def key_vault_certificate_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_vault_certificate_id", value)

    @property
    @pulumi.getter(name="subjectAlternativeNames")
    def subject_alternative_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        One or more `subject alternative names` contained within the key vault certificate.
        """
        return pulumi.get(self, "subject_alternative_names")

    @subject_alternative_names.setter
    def subject_alternative_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "subject_alternative_names", value)


if not MYPY:
    class FrontdoorSecurityPolicySecurityPoliciesArgsDict(TypedDict):
        firewall: pulumi.Input['FrontdoorSecurityPolicySecurityPoliciesFirewallArgsDict']
        """
        An `firewall` block as defined below. Changing this forces a new Front Door Security Policy to be created.
        """
elif False:
    FrontdoorSecurityPolicySecurityPoliciesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontdoorSecurityPolicySecurityPoliciesArgs:
    def __init__(__self__, *,
                 firewall: pulumi.Input['FrontdoorSecurityPolicySecurityPoliciesFirewallArgs']):
        """
        :param pulumi.Input['FrontdoorSecurityPolicySecurityPoliciesFirewallArgs'] firewall: An `firewall` block as defined below. Changing this forces a new Front Door Security Policy to be created.
        """
        pulumi.set(__self__, "firewall", firewall)

    @property
    @pulumi.getter
    def firewall(self) -> pulumi.Input['FrontdoorSecurityPolicySecurityPoliciesFirewallArgs']:
        """
        An `firewall` block as defined below. Changing this forces a new Front Door Security Policy to be created.
        """
        return pulumi.get(self, "firewall")

    @firewall.setter
    def firewall(self, value: pulumi.Input['FrontdoorSecurityPolicySecurityPoliciesFirewallArgs']):
        pulumi.set(self, "firewall", value)


if not MYPY:
    class FrontdoorSecurityPolicySecurityPoliciesFirewallArgsDict(TypedDict):
        association: pulumi.Input['FrontdoorSecurityPolicySecurityPoliciesFirewallAssociationArgsDict']
        """
        An `association` block as defined below. Changing this forces a new Front Door Security Policy to be created.
        """
        cdn_frontdoor_firewall_policy_id: pulumi.Input[str]
        """
        The Resource Id of the Front Door Firewall Policy that should be linked to this Front Door Security Policy. Changing this forces a new Front Door Security Policy to be created.
        """
elif False:
    FrontdoorSecurityPolicySecurityPoliciesFirewallArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontdoorSecurityPolicySecurityPoliciesFirewallArgs:
    def __init__(__self__, *,
                 association: pulumi.Input['FrontdoorSecurityPolicySecurityPoliciesFirewallAssociationArgs'],
                 cdn_frontdoor_firewall_policy_id: pulumi.Input[str]):
        """
        :param pulumi.Input['FrontdoorSecurityPolicySecurityPoliciesFirewallAssociationArgs'] association: An `association` block as defined below. Changing this forces a new Front Door Security Policy to be created.
        :param pulumi.Input[str] cdn_frontdoor_firewall_policy_id: The Resource Id of the Front Door Firewall Policy that should be linked to this Front Door Security Policy. Changing this forces a new Front Door Security Policy to be created.
        """
        pulumi.set(__self__, "association", association)
        pulumi.set(__self__, "cdn_frontdoor_firewall_policy_id", cdn_frontdoor_firewall_policy_id)

    @property
    @pulumi.getter
    def association(self) -> pulumi.Input['FrontdoorSecurityPolicySecurityPoliciesFirewallAssociationArgs']:
        """
        An `association` block as defined below. Changing this forces a new Front Door Security Policy to be created.
        """
        return pulumi.get(self, "association")

    @association.setter
    def association(self, value: pulumi.Input['FrontdoorSecurityPolicySecurityPoliciesFirewallAssociationArgs']):
        pulumi.set(self, "association", value)

    @property
    @pulumi.getter(name="cdnFrontdoorFirewallPolicyId")
    def cdn_frontdoor_firewall_policy_id(self) -> pulumi.Input[str]:
        """
        The Resource Id of the Front Door Firewall Policy that should be linked to this Front Door Security Policy. Changing this forces a new Front Door Security Policy to be created.
        """
        return pulumi.get(self, "cdn_frontdoor_firewall_policy_id")

    @cdn_frontdoor_firewall_policy_id.setter
    def cdn_frontdoor_firewall_policy_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "cdn_frontdoor_firewall_policy_id", value)


if not MYPY:
    class FrontdoorSecurityPolicySecurityPoliciesFirewallAssociationArgsDict(TypedDict):
        domains: pulumi.Input[Sequence[pulumi.Input['FrontdoorSecurityPolicySecurityPoliciesFirewallAssociationDomainArgsDict']]]
        """
        One or more `domain` blocks as defined below. Changing this forces a new Front Door Security Policy to be created.
        """
        patterns_to_match: pulumi.Input[str]
        """
        The list of paths to match for this firewall policy. Possible value includes `/*`. Changing this forces a new Front Door Security Policy to be created.
        """
elif False:
    FrontdoorSecurityPolicySecurityPoliciesFirewallAssociationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontdoorSecurityPolicySecurityPoliciesFirewallAssociationArgs:
    def __init__(__self__, *,
                 domains: pulumi.Input[Sequence[pulumi.Input['FrontdoorSecurityPolicySecurityPoliciesFirewallAssociationDomainArgs']]],
                 patterns_to_match: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FrontdoorSecurityPolicySecurityPoliciesFirewallAssociationDomainArgs']]] domains: One or more `domain` blocks as defined below. Changing this forces a new Front Door Security Policy to be created.
        :param pulumi.Input[str] patterns_to_match: The list of paths to match for this firewall policy. Possible value includes `/*`. Changing this forces a new Front Door Security Policy to be created.
        """
        pulumi.set(__self__, "domains", domains)
        pulumi.set(__self__, "patterns_to_match", patterns_to_match)

    @property
    @pulumi.getter
    def domains(self) -> pulumi.Input[Sequence[pulumi.Input['FrontdoorSecurityPolicySecurityPoliciesFirewallAssociationDomainArgs']]]:
        """
        One or more `domain` blocks as defined below. Changing this forces a new Front Door Security Policy to be created.
        """
        return pulumi.get(self, "domains")

    @domains.setter
    def domains(self, value: pulumi.Input[Sequence[pulumi.Input['FrontdoorSecurityPolicySecurityPoliciesFirewallAssociationDomainArgs']]]):
        pulumi.set(self, "domains", value)

    @property
    @pulumi.getter(name="patternsToMatch")
    def patterns_to_match(self) -> pulumi.Input[str]:
        """
        The list of paths to match for this firewall policy. Possible value includes `/*`. Changing this forces a new Front Door Security Policy to be created.
        """
        return pulumi.get(self, "patterns_to_match")

    @patterns_to_match.setter
    def patterns_to_match(self, value: pulumi.Input[str]):
        pulumi.set(self, "patterns_to_match", value)


if not MYPY:
    class FrontdoorSecurityPolicySecurityPoliciesFirewallAssociationDomainArgsDict(TypedDict):
        cdn_frontdoor_domain_id: pulumi.Input[str]
        """
        The Resource Id of the **Front Door Custom Domain** or **Front Door Endpoint** that should be bound to this Front Door Security Policy. Changing this forces a new Front Door Security Policy to be created.
        """
        active: NotRequired[pulumi.Input[bool]]
        """
        Is the Front Door Custom Domain/Endpoint activated?
        """
elif False:
    FrontdoorSecurityPolicySecurityPoliciesFirewallAssociationDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontdoorSecurityPolicySecurityPoliciesFirewallAssociationDomainArgs:
    def __init__(__self__, *,
                 cdn_frontdoor_domain_id: pulumi.Input[str],
                 active: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] cdn_frontdoor_domain_id: The Resource Id of the **Front Door Custom Domain** or **Front Door Endpoint** that should be bound to this Front Door Security Policy. Changing this forces a new Front Door Security Policy to be created.
        :param pulumi.Input[bool] active: Is the Front Door Custom Domain/Endpoint activated?
        """
        pulumi.set(__self__, "cdn_frontdoor_domain_id", cdn_frontdoor_domain_id)
        if active is not None:
            pulumi.set(__self__, "active", active)

    @property
    @pulumi.getter(name="cdnFrontdoorDomainId")
    def cdn_frontdoor_domain_id(self) -> pulumi.Input[str]:
        """
        The Resource Id of the **Front Door Custom Domain** or **Front Door Endpoint** that should be bound to this Front Door Security Policy. Changing this forces a new Front Door Security Policy to be created.
        """
        return pulumi.get(self, "cdn_frontdoor_domain_id")

    @cdn_frontdoor_domain_id.setter
    def cdn_frontdoor_domain_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "cdn_frontdoor_domain_id", value)

    @property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[bool]]:
        """
        Is the Front Door Custom Domain/Endpoint activated?
        """
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "active", value)


if not MYPY:
    class GetFrontdoorProfileIdentityArgsDict(TypedDict):
        principal_id: str
        tenant_id: str
        type: str
        """
        The type of Managed Service Identity that is configured on this Front Door Profile.
        """
        identity_ids: NotRequired[Sequence[str]]
        """
        The list of User Assigned Managed Identity IDs assigned to this Front Door Profile.
        """
elif False:
    GetFrontdoorProfileIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFrontdoorProfileIdentityArgs:
    def __init__(__self__, *,
                 principal_id: str,
                 tenant_id: str,
                 type: str,
                 identity_ids: Optional[Sequence[str]] = None):
        """
        :param str type: The type of Managed Service Identity that is configured on this Front Door Profile.
        :param Sequence[str] identity_ids: The list of User Assigned Managed Identity IDs assigned to this Front Door Profile.
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: str):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: str):
        pulumi.set(self, "tenant_id", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of Managed Service Identity that is configured on this Front Door Profile.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: str):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[str]]:
        """
        The list of User Assigned Managed Identity IDs assigned to this Front Door Profile.
        """
        return pulumi.get(self, "identity_ids")

    @identity_ids.setter
    def identity_ids(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "identity_ids", value)


