# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'DomainIdentityArgs',
    'DomainInboundIpRuleArgs',
    'DomainInputMappingDefaultValuesArgs',
    'DomainInputMappingFieldsArgs',
    'EventGridTopicIdentityArgs',
    'EventGridTopicInboundIpRuleArgs',
    'EventGridTopicInputMappingDefaultValuesArgs',
    'EventGridTopicInputMappingFieldsArgs',
    'EventHubCaptureDescriptionArgs',
    'EventHubCaptureDescriptionDestinationArgs',
    'EventHubNamespaceIdentityArgs',
    'EventHubNamespaceNetworkRulesetsArgs',
    'EventHubNamespaceNetworkRulesetsIpRuleArgs',
    'EventHubNamespaceNetworkRulesetsVirtualNetworkRuleArgs',
    'EventSubscriptionAdvancedFilterArgs',
    'EventSubscriptionAdvancedFilterBoolEqualArgs',
    'EventSubscriptionAdvancedFilterIsNotNullArgs',
    'EventSubscriptionAdvancedFilterIsNullOrUndefinedArgs',
    'EventSubscriptionAdvancedFilterNumberGreaterThanArgs',
    'EventSubscriptionAdvancedFilterNumberGreaterThanOrEqualArgs',
    'EventSubscriptionAdvancedFilterNumberInArgs',
    'EventSubscriptionAdvancedFilterNumberInRangeArgs',
    'EventSubscriptionAdvancedFilterNumberLessThanArgs',
    'EventSubscriptionAdvancedFilterNumberLessThanOrEqualArgs',
    'EventSubscriptionAdvancedFilterNumberNotInArgs',
    'EventSubscriptionAdvancedFilterNumberNotInRangeArgs',
    'EventSubscriptionAdvancedFilterStringBeginsWithArgs',
    'EventSubscriptionAdvancedFilterStringContainArgs',
    'EventSubscriptionAdvancedFilterStringEndsWithArgs',
    'EventSubscriptionAdvancedFilterStringInArgs',
    'EventSubscriptionAdvancedFilterStringNotBeginsWithArgs',
    'EventSubscriptionAdvancedFilterStringNotContainArgs',
    'EventSubscriptionAdvancedFilterStringNotEndsWithArgs',
    'EventSubscriptionAdvancedFilterStringNotInArgs',
    'EventSubscriptionAzureFunctionEndpointArgs',
    'EventSubscriptionDeadLetterIdentityArgs',
    'EventSubscriptionDeliveryIdentityArgs',
    'EventSubscriptionDeliveryPropertyArgs',
    'EventSubscriptionRetryPolicyArgs',
    'EventSubscriptionStorageBlobDeadLetterDestinationArgs',
    'EventSubscriptionStorageQueueEndpointArgs',
    'EventSubscriptionSubjectFilterArgs',
    'EventSubscriptionWebhookEndpointArgs',
    'NamespaceCustomerManagedKeyArgs',
    'NamespaceIdentityArgs',
    'NamespaceNetworkRuleSetArgs',
    'NamespaceNetworkRuleSetNetworkRuleArgs',
    'SubscriptionClientScopedSubscriptionArgs',
    'SubscriptionRuleCorrelationFilterArgs',
]

@pulumi.input_type
class DomainIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 identity_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 principal_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Specifies the type of Managed Service Identity that should be configured on this Event Grid Domain. Possible values are `SystemAssigned`, `UserAssigned`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] identity_ids: Specifies a list of User Assigned Managed Identity IDs to be assigned to this Event Grid Domain.
               
               > **NOTE:** This is required when `type` is set to `UserAssigned`
               
               > **NOTE:** When `type` is set to `SystemAssigned`, The assigned `principal_id` and `tenant_id` can be retrieved after the Event Grid Domain has been created. More details are available below.
        :param pulumi.Input[str] principal_id: The Principal ID associated with this Managed Service Identity.
        :param pulumi.Input[str] tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies the type of Managed Service Identity that should be configured on this Event Grid Domain. Possible values are `SystemAssigned`, `UserAssigned`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of User Assigned Managed Identity IDs to be assigned to this Event Grid Domain.

        > **NOTE:** This is required when `type` is set to `UserAssigned`

        > **NOTE:** When `type` is set to `SystemAssigned`, The assigned `principal_id` and `tenant_id` can be retrieved after the Event Grid Domain has been created. More details are available below.
        """
        return pulumi.get(self, "identity_ids")

    @identity_ids.setter
    def identity_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "identity_ids", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


@pulumi.input_type
class DomainInboundIpRuleArgs:
    def __init__(__self__, *,
                 ip_mask: pulumi.Input[str],
                 action: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ip_mask: The IP mask (CIDR) to match on.
        :param pulumi.Input[str] action: The action to take when the rule is matched. Possible values are `Allow`. Defaults to `Allow`.
        """
        pulumi.set(__self__, "ip_mask", ip_mask)
        if action is not None:
            pulumi.set(__self__, "action", action)

    @property
    @pulumi.getter(name="ipMask")
    def ip_mask(self) -> pulumi.Input[str]:
        """
        The IP mask (CIDR) to match on.
        """
        return pulumi.get(self, "ip_mask")

    @ip_mask.setter
    def ip_mask(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip_mask", value)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        The action to take when the rule is matched. Possible values are `Allow`. Defaults to `Allow`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)


@pulumi.input_type
class DomainInputMappingDefaultValuesArgs:
    def __init__(__self__, *,
                 data_version: Optional[pulumi.Input[str]] = None,
                 event_type: Optional[pulumi.Input[str]] = None,
                 subject: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_version: Specifies the default data version of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        :param pulumi.Input[str] event_type: Specifies the default event type of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        :param pulumi.Input[str] subject: Specifies the default subject of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        if data_version is not None:
            pulumi.set(__self__, "data_version", data_version)
        if event_type is not None:
            pulumi.set(__self__, "event_type", event_type)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)

    @property
    @pulumi.getter(name="dataVersion")
    def data_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the default data version of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "data_version")

    @data_version.setter
    def data_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_version", value)

    @property
    @pulumi.getter(name="eventType")
    def event_type(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the default event type of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "event_type")

    @event_type.setter
    def event_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_type", value)

    @property
    @pulumi.getter
    def subject(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the default subject of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject", value)


@pulumi.input_type
class DomainInputMappingFieldsArgs:
    def __init__(__self__, *,
                 data_version: Optional[pulumi.Input[str]] = None,
                 event_time: Optional[pulumi.Input[str]] = None,
                 event_type: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 subject: Optional[pulumi.Input[str]] = None,
                 topic: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_version: Specifies the data version of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        :param pulumi.Input[str] event_time: Specifies the event time of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        :param pulumi.Input[str] event_type: Specifies the event type of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        :param pulumi.Input[str] id: Specifies the id of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        :param pulumi.Input[str] subject: Specifies the subject of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        :param pulumi.Input[str] topic: Specifies the topic of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        if data_version is not None:
            pulumi.set(__self__, "data_version", data_version)
        if event_time is not None:
            pulumi.set(__self__, "event_time", event_time)
        if event_type is not None:
            pulumi.set(__self__, "event_type", event_type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)
        if topic is not None:
            pulumi.set(__self__, "topic", topic)

    @property
    @pulumi.getter(name="dataVersion")
    def data_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the data version of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "data_version")

    @data_version.setter
    def data_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_version", value)

    @property
    @pulumi.getter(name="eventTime")
    def event_time(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the event time of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "event_time")

    @event_time.setter
    def event_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_time", value)

    @property
    @pulumi.getter(name="eventType")
    def event_type(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the event type of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "event_type")

    @event_type.setter
    def event_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the id of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def subject(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the subject of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject", value)

    @property
    @pulumi.getter
    def topic(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the topic of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topic", value)


@pulumi.input_type
class EventGridTopicIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 identity_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 principal_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Specifies the type of Managed Service Identity that should be configured on this Event Grid Topic. Possible values are `SystemAssigned`, `UserAssigned`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] identity_ids: Specifies a list of User Assigned Managed Identity IDs to be assigned to this Event Grid Topic.
               
               > **NOTE:** This is required when `type` is set to `UserAssigned`
               
               > **NOTE:** When `type` is set to `SystemAssigned`, The assigned `principal_id` and `tenant_id` can be retrieved after the Event Grid Topic has been created. More details are available below.
        :param pulumi.Input[str] principal_id: The Principal ID associated with this Managed Service Identity.
        :param pulumi.Input[str] tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies the type of Managed Service Identity that should be configured on this Event Grid Topic. Possible values are `SystemAssigned`, `UserAssigned`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of User Assigned Managed Identity IDs to be assigned to this Event Grid Topic.

        > **NOTE:** This is required when `type` is set to `UserAssigned`

        > **NOTE:** When `type` is set to `SystemAssigned`, The assigned `principal_id` and `tenant_id` can be retrieved after the Event Grid Topic has been created. More details are available below.
        """
        return pulumi.get(self, "identity_ids")

    @identity_ids.setter
    def identity_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "identity_ids", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


@pulumi.input_type
class EventGridTopicInboundIpRuleArgs:
    def __init__(__self__, *,
                 ip_mask: pulumi.Input[str],
                 action: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ip_mask: The IP mask (CIDR) to match on.
        :param pulumi.Input[str] action: The action to take when the rule is matched. Possible values are `Allow`. Defaults to `Allow`.
        """
        pulumi.set(__self__, "ip_mask", ip_mask)
        if action is not None:
            pulumi.set(__self__, "action", action)

    @property
    @pulumi.getter(name="ipMask")
    def ip_mask(self) -> pulumi.Input[str]:
        """
        The IP mask (CIDR) to match on.
        """
        return pulumi.get(self, "ip_mask")

    @ip_mask.setter
    def ip_mask(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip_mask", value)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        The action to take when the rule is matched. Possible values are `Allow`. Defaults to `Allow`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)


@pulumi.input_type
class EventGridTopicInputMappingDefaultValuesArgs:
    def __init__(__self__, *,
                 data_version: Optional[pulumi.Input[str]] = None,
                 event_type: Optional[pulumi.Input[str]] = None,
                 subject: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_version: Specifies the default data version of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        :param pulumi.Input[str] event_type: Specifies the default event type of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        :param pulumi.Input[str] subject: Specifies the default subject of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        if data_version is not None:
            pulumi.set(__self__, "data_version", data_version)
        if event_type is not None:
            pulumi.set(__self__, "event_type", event_type)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)

    @property
    @pulumi.getter(name="dataVersion")
    def data_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the default data version of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "data_version")

    @data_version.setter
    def data_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_version", value)

    @property
    @pulumi.getter(name="eventType")
    def event_type(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the default event type of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "event_type")

    @event_type.setter
    def event_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_type", value)

    @property
    @pulumi.getter
    def subject(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the default subject of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject", value)


@pulumi.input_type
class EventGridTopicInputMappingFieldsArgs:
    def __init__(__self__, *,
                 data_version: Optional[pulumi.Input[str]] = None,
                 event_time: Optional[pulumi.Input[str]] = None,
                 event_type: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 subject: Optional[pulumi.Input[str]] = None,
                 topic: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_version: Specifies the data version of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        :param pulumi.Input[str] event_time: Specifies the event time of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        :param pulumi.Input[str] event_type: Specifies the event type of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        :param pulumi.Input[str] id: Specifies the id of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        :param pulumi.Input[str] subject: Specifies the subject of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        :param pulumi.Input[str] topic: Specifies the topic of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        if data_version is not None:
            pulumi.set(__self__, "data_version", data_version)
        if event_time is not None:
            pulumi.set(__self__, "event_time", event_time)
        if event_type is not None:
            pulumi.set(__self__, "event_type", event_type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)
        if topic is not None:
            pulumi.set(__self__, "topic", topic)

    @property
    @pulumi.getter(name="dataVersion")
    def data_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the data version of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "data_version")

    @data_version.setter
    def data_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_version", value)

    @property
    @pulumi.getter(name="eventTime")
    def event_time(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the event time of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "event_time")

    @event_time.setter
    def event_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_time", value)

    @property
    @pulumi.getter(name="eventType")
    def event_type(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the event type of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "event_type")

    @event_type.setter
    def event_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the id of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def subject(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the subject of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject", value)

    @property
    @pulumi.getter
    def topic(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the topic of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topic", value)


@pulumi.input_type
class EventHubCaptureDescriptionArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input['EventHubCaptureDescriptionDestinationArgs'],
                 enabled: pulumi.Input[bool],
                 encoding: pulumi.Input[str],
                 interval_in_seconds: Optional[pulumi.Input[int]] = None,
                 size_limit_in_bytes: Optional[pulumi.Input[int]] = None,
                 skip_empty_archives: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input['EventHubCaptureDescriptionDestinationArgs'] destination: A `destination` block as defined below.
        :param pulumi.Input[bool] enabled: Specifies if the Capture Description is Enabled.
        :param pulumi.Input[str] encoding: Specifies the Encoding used for the Capture Description. Possible values are `Avro` and `AvroDeflate`.
        :param pulumi.Input[int] interval_in_seconds: Specifies the time interval in seconds at which the capture will happen. Values can be between `60` and `900` seconds. Defaults to `300` seconds.
        :param pulumi.Input[int] size_limit_in_bytes: Specifies the amount of data built up in your EventHub before a Capture Operation occurs. Value should be between `10485760` and `524288000` bytes. Defaults to `314572800` bytes.
        :param pulumi.Input[bool] skip_empty_archives: Specifies if empty files should not be emitted if no events occur during the Capture time window. Defaults to `false`.
        """
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "encoding", encoding)
        if interval_in_seconds is not None:
            pulumi.set(__self__, "interval_in_seconds", interval_in_seconds)
        if size_limit_in_bytes is not None:
            pulumi.set(__self__, "size_limit_in_bytes", size_limit_in_bytes)
        if skip_empty_archives is not None:
            pulumi.set(__self__, "skip_empty_archives", skip_empty_archives)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input['EventHubCaptureDescriptionDestinationArgs']:
        """
        A `destination` block as defined below.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input['EventHubCaptureDescriptionDestinationArgs']):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Specifies if the Capture Description is Enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def encoding(self) -> pulumi.Input[str]:
        """
        Specifies the Encoding used for the Capture Description. Possible values are `Avro` and `AvroDeflate`.
        """
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: pulumi.Input[str]):
        pulumi.set(self, "encoding", value)

    @property
    @pulumi.getter(name="intervalInSeconds")
    def interval_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the time interval in seconds at which the capture will happen. Values can be between `60` and `900` seconds. Defaults to `300` seconds.
        """
        return pulumi.get(self, "interval_in_seconds")

    @interval_in_seconds.setter
    def interval_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval_in_seconds", value)

    @property
    @pulumi.getter(name="sizeLimitInBytes")
    def size_limit_in_bytes(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the amount of data built up in your EventHub before a Capture Operation occurs. Value should be between `10485760` and `524288000` bytes. Defaults to `314572800` bytes.
        """
        return pulumi.get(self, "size_limit_in_bytes")

    @size_limit_in_bytes.setter
    def size_limit_in_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "size_limit_in_bytes", value)

    @property
    @pulumi.getter(name="skipEmptyArchives")
    def skip_empty_archives(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies if empty files should not be emitted if no events occur during the Capture time window. Defaults to `false`.
        """
        return pulumi.get(self, "skip_empty_archives")

    @skip_empty_archives.setter
    def skip_empty_archives(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "skip_empty_archives", value)


@pulumi.input_type
class EventHubCaptureDescriptionDestinationArgs:
    def __init__(__self__, *,
                 archive_name_format: pulumi.Input[str],
                 blob_container_name: pulumi.Input[str],
                 name: pulumi.Input[str],
                 storage_account_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] archive_name_format: The Blob naming convention for archiving. e.g. `{Namespace}/{EventHub}/{PartitionId}/{Year}/{Month}/{Day}/{Hour}/{Minute}/{Second}`. Here all the parameters (Namespace,EventHub .. etc) are mandatory irrespective of order
        :param pulumi.Input[str] blob_container_name: The name of the Container within the Blob Storage Account where messages should be archived.
        :param pulumi.Input[str] name: The Name of the Destination where the capture should take place. At this time the only supported value is `EventHubArchive.AzureBlockBlob`.
               
               > At this time it's only possible to Capture EventHub messages to Blob Storage. There's [a Feature Request for the Azure SDK to add support for Capturing messages to Azure Data Lake here](https://github.com/Azure/azure-rest-api-specs/issues/2255).
        :param pulumi.Input[str] storage_account_id: The ID of the Blob Storage Account where messages should be archived.
        """
        pulumi.set(__self__, "archive_name_format", archive_name_format)
        pulumi.set(__self__, "blob_container_name", blob_container_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "storage_account_id", storage_account_id)

    @property
    @pulumi.getter(name="archiveNameFormat")
    def archive_name_format(self) -> pulumi.Input[str]:
        """
        The Blob naming convention for archiving. e.g. `{Namespace}/{EventHub}/{PartitionId}/{Year}/{Month}/{Day}/{Hour}/{Minute}/{Second}`. Here all the parameters (Namespace,EventHub .. etc) are mandatory irrespective of order
        """
        return pulumi.get(self, "archive_name_format")

    @archive_name_format.setter
    def archive_name_format(self, value: pulumi.Input[str]):
        pulumi.set(self, "archive_name_format", value)

    @property
    @pulumi.getter(name="blobContainerName")
    def blob_container_name(self) -> pulumi.Input[str]:
        """
        The name of the Container within the Blob Storage Account where messages should be archived.
        """
        return pulumi.get(self, "blob_container_name")

    @blob_container_name.setter
    def blob_container_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "blob_container_name", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The Name of the Destination where the capture should take place. At this time the only supported value is `EventHubArchive.AzureBlockBlob`.

        > At this time it's only possible to Capture EventHub messages to Blob Storage. There's [a Feature Request for the Azure SDK to add support for Capturing messages to Azure Data Lake here](https://github.com/Azure/azure-rest-api-specs/issues/2255).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="storageAccountId")
    def storage_account_id(self) -> pulumi.Input[str]:
        """
        The ID of the Blob Storage Account where messages should be archived.
        """
        return pulumi.get(self, "storage_account_id")

    @storage_account_id.setter
    def storage_account_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_account_id", value)


@pulumi.input_type
class EventHubNamespaceIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 identity_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 principal_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Specifies the type of Managed Service Identity that should be configured on this Event Hub Namespace. Possible values are `SystemAssigned` or `UserAssigned`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] identity_ids: Specifies a list of User Assigned Managed Identity IDs to be assigned to this EventHub namespace.
               
               > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
               
               > **Note:** Due to the limitation of the current Azure API, once an EventHub Namespace has been assigned an identity, it cannot be removed.
        :param pulumi.Input[str] principal_id: The Principal ID associated with this Managed Service Identity.
        :param pulumi.Input[str] tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies the type of Managed Service Identity that should be configured on this Event Hub Namespace. Possible values are `SystemAssigned` or `UserAssigned`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of User Assigned Managed Identity IDs to be assigned to this EventHub namespace.

        > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.

        > **Note:** Due to the limitation of the current Azure API, once an EventHub Namespace has been assigned an identity, it cannot be removed.
        """
        return pulumi.get(self, "identity_ids")

    @identity_ids.setter
    def identity_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "identity_ids", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


@pulumi.input_type
class EventHubNamespaceNetworkRulesetsArgs:
    def __init__(__self__, *,
                 default_action: pulumi.Input[str],
                 ip_rules: Optional[pulumi.Input[Sequence[pulumi.Input['EventHubNamespaceNetworkRulesetsIpRuleArgs']]]] = None,
                 public_network_access_enabled: Optional[pulumi.Input[bool]] = None,
                 trusted_service_access_enabled: Optional[pulumi.Input[bool]] = None,
                 virtual_network_rules: Optional[pulumi.Input[Sequence[pulumi.Input['EventHubNamespaceNetworkRulesetsVirtualNetworkRuleArgs']]]] = None):
        """
        :param pulumi.Input[str] default_action: The default action to take when a rule is not matched. Possible values are `Allow` and `Deny`.
        :param pulumi.Input[Sequence[pulumi.Input['EventHubNamespaceNetworkRulesetsIpRuleArgs']]] ip_rules: One or more `ip_rule` blocks as defined below.
        :param pulumi.Input[bool] public_network_access_enabled: Is public network access enabled for the EventHub Namespace? Defaults to `true`.
               
               > **Note:** The public network access setting at the network rule sets level should be the same as it's at the namespace level.
        :param pulumi.Input[bool] trusted_service_access_enabled: Whether Trusted Microsoft Services are allowed to bypass firewall.
        :param pulumi.Input[Sequence[pulumi.Input['EventHubNamespaceNetworkRulesetsVirtualNetworkRuleArgs']]] virtual_network_rules: One or more `virtual_network_rule` blocks as defined below.
        """
        pulumi.set(__self__, "default_action", default_action)
        if ip_rules is not None:
            pulumi.set(__self__, "ip_rules", ip_rules)
        if public_network_access_enabled is not None:
            pulumi.set(__self__, "public_network_access_enabled", public_network_access_enabled)
        if trusted_service_access_enabled is not None:
            pulumi.set(__self__, "trusted_service_access_enabled", trusted_service_access_enabled)
        if virtual_network_rules is not None:
            pulumi.set(__self__, "virtual_network_rules", virtual_network_rules)

    @property
    @pulumi.getter(name="defaultAction")
    def default_action(self) -> pulumi.Input[str]:
        """
        The default action to take when a rule is not matched. Possible values are `Allow` and `Deny`.
        """
        return pulumi.get(self, "default_action")

    @default_action.setter
    def default_action(self, value: pulumi.Input[str]):
        pulumi.set(self, "default_action", value)

    @property
    @pulumi.getter(name="ipRules")
    def ip_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventHubNamespaceNetworkRulesetsIpRuleArgs']]]]:
        """
        One or more `ip_rule` blocks as defined below.
        """
        return pulumi.get(self, "ip_rules")

    @ip_rules.setter
    def ip_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventHubNamespaceNetworkRulesetsIpRuleArgs']]]]):
        pulumi.set(self, "ip_rules", value)

    @property
    @pulumi.getter(name="publicNetworkAccessEnabled")
    def public_network_access_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is public network access enabled for the EventHub Namespace? Defaults to `true`.

        > **Note:** The public network access setting at the network rule sets level should be the same as it's at the namespace level.
        """
        return pulumi.get(self, "public_network_access_enabled")

    @public_network_access_enabled.setter
    def public_network_access_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "public_network_access_enabled", value)

    @property
    @pulumi.getter(name="trustedServiceAccessEnabled")
    def trusted_service_access_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether Trusted Microsoft Services are allowed to bypass firewall.
        """
        return pulumi.get(self, "trusted_service_access_enabled")

    @trusted_service_access_enabled.setter
    def trusted_service_access_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "trusted_service_access_enabled", value)

    @property
    @pulumi.getter(name="virtualNetworkRules")
    def virtual_network_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventHubNamespaceNetworkRulesetsVirtualNetworkRuleArgs']]]]:
        """
        One or more `virtual_network_rule` blocks as defined below.
        """
        return pulumi.get(self, "virtual_network_rules")

    @virtual_network_rules.setter
    def virtual_network_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventHubNamespaceNetworkRulesetsVirtualNetworkRuleArgs']]]]):
        pulumi.set(self, "virtual_network_rules", value)


@pulumi.input_type
class EventHubNamespaceNetworkRulesetsIpRuleArgs:
    def __init__(__self__, *,
                 ip_mask: pulumi.Input[str],
                 action: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ip_mask: The IP mask to match on.
        :param pulumi.Input[str] action: The action to take when the rule is matched. Possible values are `Allow`. Defaults to `Allow`.
        """
        pulumi.set(__self__, "ip_mask", ip_mask)
        if action is not None:
            pulumi.set(__self__, "action", action)

    @property
    @pulumi.getter(name="ipMask")
    def ip_mask(self) -> pulumi.Input[str]:
        """
        The IP mask to match on.
        """
        return pulumi.get(self, "ip_mask")

    @ip_mask.setter
    def ip_mask(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip_mask", value)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        The action to take when the rule is matched. Possible values are `Allow`. Defaults to `Allow`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)


@pulumi.input_type
class EventHubNamespaceNetworkRulesetsVirtualNetworkRuleArgs:
    def __init__(__self__, *,
                 subnet_id: pulumi.Input[str],
                 ignore_missing_virtual_network_service_endpoint: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] subnet_id: The id of the subnet to match on.
        :param pulumi.Input[bool] ignore_missing_virtual_network_service_endpoint: Are missing virtual network service endpoints ignored?
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        if ignore_missing_virtual_network_service_endpoint is not None:
            pulumi.set(__self__, "ignore_missing_virtual_network_service_endpoint", ignore_missing_virtual_network_service_endpoint)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        The id of the subnet to match on.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="ignoreMissingVirtualNetworkServiceEndpoint")
    def ignore_missing_virtual_network_service_endpoint(self) -> Optional[pulumi.Input[bool]]:
        """
        Are missing virtual network service endpoints ignored?
        """
        return pulumi.get(self, "ignore_missing_virtual_network_service_endpoint")

    @ignore_missing_virtual_network_service_endpoint.setter
    def ignore_missing_virtual_network_service_endpoint(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_missing_virtual_network_service_endpoint", value)


@pulumi.input_type
class EventSubscriptionAdvancedFilterArgs:
    def __init__(__self__, *,
                 bool_equals: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterBoolEqualArgs']]]] = None,
                 is_not_nulls: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterIsNotNullArgs']]]] = None,
                 is_null_or_undefineds: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterIsNullOrUndefinedArgs']]]] = None,
                 number_greater_than_or_equals: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberGreaterThanOrEqualArgs']]]] = None,
                 number_greater_thans: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberGreaterThanArgs']]]] = None,
                 number_in_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberInRangeArgs']]]] = None,
                 number_ins: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberInArgs']]]] = None,
                 number_less_than_or_equals: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberLessThanOrEqualArgs']]]] = None,
                 number_less_thans: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberLessThanArgs']]]] = None,
                 number_not_in_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberNotInRangeArgs']]]] = None,
                 number_not_ins: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberNotInArgs']]]] = None,
                 string_begins_withs: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringBeginsWithArgs']]]] = None,
                 string_contains: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringContainArgs']]]] = None,
                 string_ends_withs: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringEndsWithArgs']]]] = None,
                 string_ins: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringInArgs']]]] = None,
                 string_not_begins_withs: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringNotBeginsWithArgs']]]] = None,
                 string_not_contains: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringNotContainArgs']]]] = None,
                 string_not_ends_withs: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringNotEndsWithArgs']]]] = None,
                 string_not_ins: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringNotInArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterBoolEqualArgs']]] bool_equals: Compares a value of an event using a single boolean value.
        :param pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterIsNotNullArgs']]] is_not_nulls: Evaluates if a value of an event isn't NULL or undefined.
        :param pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterIsNullOrUndefinedArgs']]] is_null_or_undefineds: Evaluates if a value of an event is NULL or undefined.
               
               Each nested block consists of a key and a value(s) element.
        :param pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberGreaterThanOrEqualArgs']]] number_greater_than_or_equals: Compares a value of an event using a single floating point number.
        :param pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberGreaterThanArgs']]] number_greater_thans: Compares a value of an event using a single floating point number.
        :param pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberInRangeArgs']]] number_in_ranges: Compares a value of an event using multiple floating point number ranges.
        :param pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberInArgs']]] number_ins: Compares a value of an event using multiple floating point numbers.
        :param pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberLessThanOrEqualArgs']]] number_less_than_or_equals: Compares a value of an event using a single floating point number.
        :param pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberLessThanArgs']]] number_less_thans: Compares a value of an event using a single floating point number.
        :param pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberNotInRangeArgs']]] number_not_in_ranges: Compares a value of an event using multiple floating point number ranges.
        :param pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberNotInArgs']]] number_not_ins: Compares a value of an event using multiple floating point numbers.
        :param pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringBeginsWithArgs']]] string_begins_withs: Compares a value of an event using multiple string values.
        :param pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringContainArgs']]] string_contains: Compares a value of an event using multiple string values.
        :param pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringEndsWithArgs']]] string_ends_withs: Compares a value of an event using multiple string values.
        :param pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringInArgs']]] string_ins: Compares a value of an event using multiple string values.
        :param pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringNotBeginsWithArgs']]] string_not_begins_withs: Compares a value of an event using multiple string values.
        :param pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringNotContainArgs']]] string_not_contains: Compares a value of an event using multiple string values.
        :param pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringNotEndsWithArgs']]] string_not_ends_withs: Compares a value of an event using multiple string values.
        :param pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringNotInArgs']]] string_not_ins: Compares a value of an event using multiple string values.
        """
        if bool_equals is not None:
            pulumi.set(__self__, "bool_equals", bool_equals)
        if is_not_nulls is not None:
            pulumi.set(__self__, "is_not_nulls", is_not_nulls)
        if is_null_or_undefineds is not None:
            pulumi.set(__self__, "is_null_or_undefineds", is_null_or_undefineds)
        if number_greater_than_or_equals is not None:
            pulumi.set(__self__, "number_greater_than_or_equals", number_greater_than_or_equals)
        if number_greater_thans is not None:
            pulumi.set(__self__, "number_greater_thans", number_greater_thans)
        if number_in_ranges is not None:
            pulumi.set(__self__, "number_in_ranges", number_in_ranges)
        if number_ins is not None:
            pulumi.set(__self__, "number_ins", number_ins)
        if number_less_than_or_equals is not None:
            pulumi.set(__self__, "number_less_than_or_equals", number_less_than_or_equals)
        if number_less_thans is not None:
            pulumi.set(__self__, "number_less_thans", number_less_thans)
        if number_not_in_ranges is not None:
            pulumi.set(__self__, "number_not_in_ranges", number_not_in_ranges)
        if number_not_ins is not None:
            pulumi.set(__self__, "number_not_ins", number_not_ins)
        if string_begins_withs is not None:
            pulumi.set(__self__, "string_begins_withs", string_begins_withs)
        if string_contains is not None:
            pulumi.set(__self__, "string_contains", string_contains)
        if string_ends_withs is not None:
            pulumi.set(__self__, "string_ends_withs", string_ends_withs)
        if string_ins is not None:
            pulumi.set(__self__, "string_ins", string_ins)
        if string_not_begins_withs is not None:
            pulumi.set(__self__, "string_not_begins_withs", string_not_begins_withs)
        if string_not_contains is not None:
            pulumi.set(__self__, "string_not_contains", string_not_contains)
        if string_not_ends_withs is not None:
            pulumi.set(__self__, "string_not_ends_withs", string_not_ends_withs)
        if string_not_ins is not None:
            pulumi.set(__self__, "string_not_ins", string_not_ins)

    @property
    @pulumi.getter(name="boolEquals")
    def bool_equals(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterBoolEqualArgs']]]]:
        """
        Compares a value of an event using a single boolean value.
        """
        return pulumi.get(self, "bool_equals")

    @bool_equals.setter
    def bool_equals(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterBoolEqualArgs']]]]):
        pulumi.set(self, "bool_equals", value)

    @property
    @pulumi.getter(name="isNotNulls")
    def is_not_nulls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterIsNotNullArgs']]]]:
        """
        Evaluates if a value of an event isn't NULL or undefined.
        """
        return pulumi.get(self, "is_not_nulls")

    @is_not_nulls.setter
    def is_not_nulls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterIsNotNullArgs']]]]):
        pulumi.set(self, "is_not_nulls", value)

    @property
    @pulumi.getter(name="isNullOrUndefineds")
    def is_null_or_undefineds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterIsNullOrUndefinedArgs']]]]:
        """
        Evaluates if a value of an event is NULL or undefined.

        Each nested block consists of a key and a value(s) element.
        """
        return pulumi.get(self, "is_null_or_undefineds")

    @is_null_or_undefineds.setter
    def is_null_or_undefineds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterIsNullOrUndefinedArgs']]]]):
        pulumi.set(self, "is_null_or_undefineds", value)

    @property
    @pulumi.getter(name="numberGreaterThanOrEquals")
    def number_greater_than_or_equals(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberGreaterThanOrEqualArgs']]]]:
        """
        Compares a value of an event using a single floating point number.
        """
        return pulumi.get(self, "number_greater_than_or_equals")

    @number_greater_than_or_equals.setter
    def number_greater_than_or_equals(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberGreaterThanOrEqualArgs']]]]):
        pulumi.set(self, "number_greater_than_or_equals", value)

    @property
    @pulumi.getter(name="numberGreaterThans")
    def number_greater_thans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberGreaterThanArgs']]]]:
        """
        Compares a value of an event using a single floating point number.
        """
        return pulumi.get(self, "number_greater_thans")

    @number_greater_thans.setter
    def number_greater_thans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberGreaterThanArgs']]]]):
        pulumi.set(self, "number_greater_thans", value)

    @property
    @pulumi.getter(name="numberInRanges")
    def number_in_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberInRangeArgs']]]]:
        """
        Compares a value of an event using multiple floating point number ranges.
        """
        return pulumi.get(self, "number_in_ranges")

    @number_in_ranges.setter
    def number_in_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberInRangeArgs']]]]):
        pulumi.set(self, "number_in_ranges", value)

    @property
    @pulumi.getter(name="numberIns")
    def number_ins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberInArgs']]]]:
        """
        Compares a value of an event using multiple floating point numbers.
        """
        return pulumi.get(self, "number_ins")

    @number_ins.setter
    def number_ins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberInArgs']]]]):
        pulumi.set(self, "number_ins", value)

    @property
    @pulumi.getter(name="numberLessThanOrEquals")
    def number_less_than_or_equals(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberLessThanOrEqualArgs']]]]:
        """
        Compares a value of an event using a single floating point number.
        """
        return pulumi.get(self, "number_less_than_or_equals")

    @number_less_than_or_equals.setter
    def number_less_than_or_equals(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberLessThanOrEqualArgs']]]]):
        pulumi.set(self, "number_less_than_or_equals", value)

    @property
    @pulumi.getter(name="numberLessThans")
    def number_less_thans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberLessThanArgs']]]]:
        """
        Compares a value of an event using a single floating point number.
        """
        return pulumi.get(self, "number_less_thans")

    @number_less_thans.setter
    def number_less_thans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberLessThanArgs']]]]):
        pulumi.set(self, "number_less_thans", value)

    @property
    @pulumi.getter(name="numberNotInRanges")
    def number_not_in_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberNotInRangeArgs']]]]:
        """
        Compares a value of an event using multiple floating point number ranges.
        """
        return pulumi.get(self, "number_not_in_ranges")

    @number_not_in_ranges.setter
    def number_not_in_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberNotInRangeArgs']]]]):
        pulumi.set(self, "number_not_in_ranges", value)

    @property
    @pulumi.getter(name="numberNotIns")
    def number_not_ins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberNotInArgs']]]]:
        """
        Compares a value of an event using multiple floating point numbers.
        """
        return pulumi.get(self, "number_not_ins")

    @number_not_ins.setter
    def number_not_ins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberNotInArgs']]]]):
        pulumi.set(self, "number_not_ins", value)

    @property
    @pulumi.getter(name="stringBeginsWiths")
    def string_begins_withs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringBeginsWithArgs']]]]:
        """
        Compares a value of an event using multiple string values.
        """
        return pulumi.get(self, "string_begins_withs")

    @string_begins_withs.setter
    def string_begins_withs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringBeginsWithArgs']]]]):
        pulumi.set(self, "string_begins_withs", value)

    @property
    @pulumi.getter(name="stringContains")
    def string_contains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringContainArgs']]]]:
        """
        Compares a value of an event using multiple string values.
        """
        return pulumi.get(self, "string_contains")

    @string_contains.setter
    def string_contains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringContainArgs']]]]):
        pulumi.set(self, "string_contains", value)

    @property
    @pulumi.getter(name="stringEndsWiths")
    def string_ends_withs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringEndsWithArgs']]]]:
        """
        Compares a value of an event using multiple string values.
        """
        return pulumi.get(self, "string_ends_withs")

    @string_ends_withs.setter
    def string_ends_withs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringEndsWithArgs']]]]):
        pulumi.set(self, "string_ends_withs", value)

    @property
    @pulumi.getter(name="stringIns")
    def string_ins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringInArgs']]]]:
        """
        Compares a value of an event using multiple string values.
        """
        return pulumi.get(self, "string_ins")

    @string_ins.setter
    def string_ins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringInArgs']]]]):
        pulumi.set(self, "string_ins", value)

    @property
    @pulumi.getter(name="stringNotBeginsWiths")
    def string_not_begins_withs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringNotBeginsWithArgs']]]]:
        """
        Compares a value of an event using multiple string values.
        """
        return pulumi.get(self, "string_not_begins_withs")

    @string_not_begins_withs.setter
    def string_not_begins_withs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringNotBeginsWithArgs']]]]):
        pulumi.set(self, "string_not_begins_withs", value)

    @property
    @pulumi.getter(name="stringNotContains")
    def string_not_contains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringNotContainArgs']]]]:
        """
        Compares a value of an event using multiple string values.
        """
        return pulumi.get(self, "string_not_contains")

    @string_not_contains.setter
    def string_not_contains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringNotContainArgs']]]]):
        pulumi.set(self, "string_not_contains", value)

    @property
    @pulumi.getter(name="stringNotEndsWiths")
    def string_not_ends_withs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringNotEndsWithArgs']]]]:
        """
        Compares a value of an event using multiple string values.
        """
        return pulumi.get(self, "string_not_ends_withs")

    @string_not_ends_withs.setter
    def string_not_ends_withs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringNotEndsWithArgs']]]]):
        pulumi.set(self, "string_not_ends_withs", value)

    @property
    @pulumi.getter(name="stringNotIns")
    def string_not_ins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringNotInArgs']]]]:
        """
        Compares a value of an event using multiple string values.
        """
        return pulumi.get(self, "string_not_ins")

    @string_not_ins.setter
    def string_not_ins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringNotInArgs']]]]):
        pulumi.set(self, "string_not_ins", value)


@pulumi.input_type
class EventSubscriptionAdvancedFilterBoolEqualArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[bool]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[bool]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class EventSubscriptionAdvancedFilterIsNotNullArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str]):
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)


@pulumi.input_type
class EventSubscriptionAdvancedFilterIsNullOrUndefinedArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str]):
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)


@pulumi.input_type
class EventSubscriptionAdvancedFilterNumberGreaterThanArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[float]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class EventSubscriptionAdvancedFilterNumberGreaterThanOrEqualArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[float]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class EventSubscriptionAdvancedFilterNumberInArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[float]]]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[float]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[float]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class EventSubscriptionAdvancedFilterNumberInRangeArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[float]]]]]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[float]]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[float]]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class EventSubscriptionAdvancedFilterNumberLessThanArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[float]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class EventSubscriptionAdvancedFilterNumberLessThanOrEqualArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[float]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class EventSubscriptionAdvancedFilterNumberNotInArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[float]]]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[float]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[float]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class EventSubscriptionAdvancedFilterNumberNotInRangeArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[float]]]]]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[float]]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[float]]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class EventSubscriptionAdvancedFilterStringBeginsWithArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class EventSubscriptionAdvancedFilterStringContainArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class EventSubscriptionAdvancedFilterStringEndsWithArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class EventSubscriptionAdvancedFilterStringInArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class EventSubscriptionAdvancedFilterStringNotBeginsWithArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class EventSubscriptionAdvancedFilterStringNotContainArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class EventSubscriptionAdvancedFilterStringNotEndsWithArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class EventSubscriptionAdvancedFilterStringNotInArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class EventSubscriptionAzureFunctionEndpointArgs:
    def __init__(__self__, *,
                 function_id: pulumi.Input[str],
                 max_events_per_batch: Optional[pulumi.Input[int]] = None,
                 preferred_batch_size_in_kilobytes: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] function_id: Specifies the ID of the Function where the Event Subscription will receive events. This must be the functions ID in format {function_app.id}/functions/{name}.
        :param pulumi.Input[int] max_events_per_batch: Maximum number of events per batch.
        :param pulumi.Input[int] preferred_batch_size_in_kilobytes: Preferred batch size in Kilobytes.
        """
        pulumi.set(__self__, "function_id", function_id)
        if max_events_per_batch is not None:
            pulumi.set(__self__, "max_events_per_batch", max_events_per_batch)
        if preferred_batch_size_in_kilobytes is not None:
            pulumi.set(__self__, "preferred_batch_size_in_kilobytes", preferred_batch_size_in_kilobytes)

    @property
    @pulumi.getter(name="functionId")
    def function_id(self) -> pulumi.Input[str]:
        """
        Specifies the ID of the Function where the Event Subscription will receive events. This must be the functions ID in format {function_app.id}/functions/{name}.
        """
        return pulumi.get(self, "function_id")

    @function_id.setter
    def function_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "function_id", value)

    @property
    @pulumi.getter(name="maxEventsPerBatch")
    def max_events_per_batch(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of events per batch.
        """
        return pulumi.get(self, "max_events_per_batch")

    @max_events_per_batch.setter
    def max_events_per_batch(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_events_per_batch", value)

    @property
    @pulumi.getter(name="preferredBatchSizeInKilobytes")
    def preferred_batch_size_in_kilobytes(self) -> Optional[pulumi.Input[int]]:
        """
        Preferred batch size in Kilobytes.
        """
        return pulumi.get(self, "preferred_batch_size_in_kilobytes")

    @preferred_batch_size_in_kilobytes.setter
    def preferred_batch_size_in_kilobytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "preferred_batch_size_in_kilobytes", value)


@pulumi.input_type
class EventSubscriptionDeadLetterIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 user_assigned_identity: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Specifies the type of Managed Service Identity that is used for dead lettering. Allowed value is `SystemAssigned`, `UserAssigned`.
        :param pulumi.Input[str] user_assigned_identity: The user identity associated with the resource.
        """
        pulumi.set(__self__, "type", type)
        if user_assigned_identity is not None:
            pulumi.set(__self__, "user_assigned_identity", user_assigned_identity)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies the type of Managed Service Identity that is used for dead lettering. Allowed value is `SystemAssigned`, `UserAssigned`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignedIdentity")
    def user_assigned_identity(self) -> Optional[pulumi.Input[str]]:
        """
        The user identity associated with the resource.
        """
        return pulumi.get(self, "user_assigned_identity")

    @user_assigned_identity.setter
    def user_assigned_identity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_assigned_identity", value)


@pulumi.input_type
class EventSubscriptionDeliveryIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 user_assigned_identity: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Specifies the type of Managed Service Identity that is used for event delivery. Allowed value is `SystemAssigned`, `UserAssigned`.
        :param pulumi.Input[str] user_assigned_identity: The user identity associated with the resource.
        """
        pulumi.set(__self__, "type", type)
        if user_assigned_identity is not None:
            pulumi.set(__self__, "user_assigned_identity", user_assigned_identity)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies the type of Managed Service Identity that is used for event delivery. Allowed value is `SystemAssigned`, `UserAssigned`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignedIdentity")
    def user_assigned_identity(self) -> Optional[pulumi.Input[str]]:
        """
        The user identity associated with the resource.
        """
        return pulumi.get(self, "user_assigned_identity")

    @user_assigned_identity.setter
    def user_assigned_identity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_assigned_identity", value)


@pulumi.input_type
class EventSubscriptionDeliveryPropertyArgs:
    def __init__(__self__, *,
                 header_name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 secret: Optional[pulumi.Input[bool]] = None,
                 source_field: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] header_name: The name of the header to send on to the destination
        :param pulumi.Input[str] type: Either `Static` or `Dynamic`
        :param pulumi.Input[bool] secret: True if the `value` is a secret and should be protected, otherwise false. If True, then this value won't be returned from Azure API calls
        :param pulumi.Input[str] source_field: If the `type` is `Dynamic`, then provide the payload field to be used as the value. Valid source fields differ by subscription type.
        :param pulumi.Input[str] value: If the `type` is `Static`, then provide the value to use
        """
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "type", type)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if source_field is not None:
            pulumi.set(__self__, "source_field", source_field)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[str]:
        """
        The name of the header to send on to the destination
        """
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Either `Static` or `Dynamic`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[bool]]:
        """
        True if the `value` is a secret and should be protected, otherwise false. If True, then this value won't be returned from Azure API calls
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="sourceField")
    def source_field(self) -> Optional[pulumi.Input[str]]:
        """
        If the `type` is `Dynamic`, then provide the payload field to be used as the value. Valid source fields differ by subscription type.
        """
        return pulumi.get(self, "source_field")

    @source_field.setter
    def source_field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_field", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        If the `type` is `Static`, then provide the value to use
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class EventSubscriptionRetryPolicyArgs:
    def __init__(__self__, *,
                 event_time_to_live: pulumi.Input[int],
                 max_delivery_attempts: pulumi.Input[int]):
        """
        :param pulumi.Input[int] event_time_to_live: Specifies the time to live (in minutes) for events. Supported range is `1` to `1440`. See [official documentation](https://docs.microsoft.com/azure/event-grid/manage-event-delivery#set-retry-policy) for more details.
        :param pulumi.Input[int] max_delivery_attempts: Specifies the maximum number of delivery retry attempts for events.
        """
        pulumi.set(__self__, "event_time_to_live", event_time_to_live)
        pulumi.set(__self__, "max_delivery_attempts", max_delivery_attempts)

    @property
    @pulumi.getter(name="eventTimeToLive")
    def event_time_to_live(self) -> pulumi.Input[int]:
        """
        Specifies the time to live (in minutes) for events. Supported range is `1` to `1440`. See [official documentation](https://docs.microsoft.com/azure/event-grid/manage-event-delivery#set-retry-policy) for more details.
        """
        return pulumi.get(self, "event_time_to_live")

    @event_time_to_live.setter
    def event_time_to_live(self, value: pulumi.Input[int]):
        pulumi.set(self, "event_time_to_live", value)

    @property
    @pulumi.getter(name="maxDeliveryAttempts")
    def max_delivery_attempts(self) -> pulumi.Input[int]:
        """
        Specifies the maximum number of delivery retry attempts for events.
        """
        return pulumi.get(self, "max_delivery_attempts")

    @max_delivery_attempts.setter
    def max_delivery_attempts(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_delivery_attempts", value)


@pulumi.input_type
class EventSubscriptionStorageBlobDeadLetterDestinationArgs:
    def __init__(__self__, *,
                 storage_account_id: pulumi.Input[str],
                 storage_blob_container_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] storage_account_id: Specifies the id of the storage account id where the storage blob is located.
        :param pulumi.Input[str] storage_blob_container_name: Specifies the name of the Storage blob container that is the destination of the deadletter events.
        """
        pulumi.set(__self__, "storage_account_id", storage_account_id)
        pulumi.set(__self__, "storage_blob_container_name", storage_blob_container_name)

    @property
    @pulumi.getter(name="storageAccountId")
    def storage_account_id(self) -> pulumi.Input[str]:
        """
        Specifies the id of the storage account id where the storage blob is located.
        """
        return pulumi.get(self, "storage_account_id")

    @storage_account_id.setter
    def storage_account_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_account_id", value)

    @property
    @pulumi.getter(name="storageBlobContainerName")
    def storage_blob_container_name(self) -> pulumi.Input[str]:
        """
        Specifies the name of the Storage blob container that is the destination of the deadletter events.
        """
        return pulumi.get(self, "storage_blob_container_name")

    @storage_blob_container_name.setter
    def storage_blob_container_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_blob_container_name", value)


@pulumi.input_type
class EventSubscriptionStorageQueueEndpointArgs:
    def __init__(__self__, *,
                 queue_name: pulumi.Input[str],
                 storage_account_id: pulumi.Input[str],
                 queue_message_time_to_live_in_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] queue_name: Specifies the name of the storage queue where the Event Subscription will receive events.
        :param pulumi.Input[str] storage_account_id: Specifies the id of the storage account id where the storage queue is located.
        :param pulumi.Input[int] queue_message_time_to_live_in_seconds: Storage queue message time to live in seconds.
        """
        pulumi.set(__self__, "queue_name", queue_name)
        pulumi.set(__self__, "storage_account_id", storage_account_id)
        if queue_message_time_to_live_in_seconds is not None:
            pulumi.set(__self__, "queue_message_time_to_live_in_seconds", queue_message_time_to_live_in_seconds)

    @property
    @pulumi.getter(name="queueName")
    def queue_name(self) -> pulumi.Input[str]:
        """
        Specifies the name of the storage queue where the Event Subscription will receive events.
        """
        return pulumi.get(self, "queue_name")

    @queue_name.setter
    def queue_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "queue_name", value)

    @property
    @pulumi.getter(name="storageAccountId")
    def storage_account_id(self) -> pulumi.Input[str]:
        """
        Specifies the id of the storage account id where the storage queue is located.
        """
        return pulumi.get(self, "storage_account_id")

    @storage_account_id.setter
    def storage_account_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_account_id", value)

    @property
    @pulumi.getter(name="queueMessageTimeToLiveInSeconds")
    def queue_message_time_to_live_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Storage queue message time to live in seconds.
        """
        return pulumi.get(self, "queue_message_time_to_live_in_seconds")

    @queue_message_time_to_live_in_seconds.setter
    def queue_message_time_to_live_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "queue_message_time_to_live_in_seconds", value)


@pulumi.input_type
class EventSubscriptionSubjectFilterArgs:
    def __init__(__self__, *,
                 case_sensitive: Optional[pulumi.Input[bool]] = None,
                 subject_begins_with: Optional[pulumi.Input[str]] = None,
                 subject_ends_with: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] case_sensitive: Specifies if `subject_begins_with` and `subject_ends_with` case sensitive. This value
        :param pulumi.Input[str] subject_begins_with: A string to filter events for an event subscription based on a resource path prefix.
        :param pulumi.Input[str] subject_ends_with: A string to filter events for an event subscription based on a resource path suffix.
        """
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if subject_begins_with is not None:
            pulumi.set(__self__, "subject_begins_with", subject_begins_with)
        if subject_ends_with is not None:
            pulumi.set(__self__, "subject_ends_with", subject_ends_with)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies if `subject_begins_with` and `subject_ends_with` case sensitive. This value
        """
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "case_sensitive", value)

    @property
    @pulumi.getter(name="subjectBeginsWith")
    def subject_begins_with(self) -> Optional[pulumi.Input[str]]:
        """
        A string to filter events for an event subscription based on a resource path prefix.
        """
        return pulumi.get(self, "subject_begins_with")

    @subject_begins_with.setter
    def subject_begins_with(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject_begins_with", value)

    @property
    @pulumi.getter(name="subjectEndsWith")
    def subject_ends_with(self) -> Optional[pulumi.Input[str]]:
        """
        A string to filter events for an event subscription based on a resource path suffix.
        """
        return pulumi.get(self, "subject_ends_with")

    @subject_ends_with.setter
    def subject_ends_with(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject_ends_with", value)


@pulumi.input_type
class EventSubscriptionWebhookEndpointArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 active_directory_app_id_or_uri: Optional[pulumi.Input[str]] = None,
                 active_directory_tenant_id: Optional[pulumi.Input[str]] = None,
                 base_url: Optional[pulumi.Input[str]] = None,
                 max_events_per_batch: Optional[pulumi.Input[int]] = None,
                 preferred_batch_size_in_kilobytes: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] url: Specifies the url of the webhook where the Event Subscription will receive events.
        :param pulumi.Input[str] active_directory_app_id_or_uri: The Azure Active Directory Application ID or URI to get the access token that will be included as the bearer token in delivery requests.
        :param pulumi.Input[str] active_directory_tenant_id: The Azure Active Directory Tenant ID to get the access token that will be included as the bearer token in delivery requests.
        :param pulumi.Input[str] base_url: The base url of the webhook where the Event Subscription will receive events.
        :param pulumi.Input[int] max_events_per_batch: Maximum number of events per batch.
        :param pulumi.Input[int] preferred_batch_size_in_kilobytes: Preferred batch size in Kilobytes.
        """
        pulumi.set(__self__, "url", url)
        if active_directory_app_id_or_uri is not None:
            pulumi.set(__self__, "active_directory_app_id_or_uri", active_directory_app_id_or_uri)
        if active_directory_tenant_id is not None:
            pulumi.set(__self__, "active_directory_tenant_id", active_directory_tenant_id)
        if base_url is not None:
            pulumi.set(__self__, "base_url", base_url)
        if max_events_per_batch is not None:
            pulumi.set(__self__, "max_events_per_batch", max_events_per_batch)
        if preferred_batch_size_in_kilobytes is not None:
            pulumi.set(__self__, "preferred_batch_size_in_kilobytes", preferred_batch_size_in_kilobytes)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Specifies the url of the webhook where the Event Subscription will receive events.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="activeDirectoryAppIdOrUri")
    def active_directory_app_id_or_uri(self) -> Optional[pulumi.Input[str]]:
        """
        The Azure Active Directory Application ID or URI to get the access token that will be included as the bearer token in delivery requests.
        """
        return pulumi.get(self, "active_directory_app_id_or_uri")

    @active_directory_app_id_or_uri.setter
    def active_directory_app_id_or_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "active_directory_app_id_or_uri", value)

    @property
    @pulumi.getter(name="activeDirectoryTenantId")
    def active_directory_tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Azure Active Directory Tenant ID to get the access token that will be included as the bearer token in delivery requests.
        """
        return pulumi.get(self, "active_directory_tenant_id")

    @active_directory_tenant_id.setter
    def active_directory_tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "active_directory_tenant_id", value)

    @property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> Optional[pulumi.Input[str]]:
        """
        The base url of the webhook where the Event Subscription will receive events.
        """
        return pulumi.get(self, "base_url")

    @base_url.setter
    def base_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "base_url", value)

    @property
    @pulumi.getter(name="maxEventsPerBatch")
    def max_events_per_batch(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of events per batch.
        """
        return pulumi.get(self, "max_events_per_batch")

    @max_events_per_batch.setter
    def max_events_per_batch(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_events_per_batch", value)

    @property
    @pulumi.getter(name="preferredBatchSizeInKilobytes")
    def preferred_batch_size_in_kilobytes(self) -> Optional[pulumi.Input[int]]:
        """
        Preferred batch size in Kilobytes.
        """
        return pulumi.get(self, "preferred_batch_size_in_kilobytes")

    @preferred_batch_size_in_kilobytes.setter
    def preferred_batch_size_in_kilobytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "preferred_batch_size_in_kilobytes", value)


@pulumi.input_type
class NamespaceCustomerManagedKeyArgs:
    def __init__(__self__, *,
                 identity_id: pulumi.Input[str],
                 key_vault_key_id: pulumi.Input[str],
                 infrastructure_encryption_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] identity_id: The ID of the User Assigned Identity that has access to the key.
        :param pulumi.Input[str] key_vault_key_id: The ID of the Key Vault Key which should be used to Encrypt the data in this ServiceBus Namespace.
        :param pulumi.Input[bool] infrastructure_encryption_enabled: Used to specify whether enable Infrastructure Encryption (Double Encryption). Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "identity_id", identity_id)
        pulumi.set(__self__, "key_vault_key_id", key_vault_key_id)
        if infrastructure_encryption_enabled is not None:
            pulumi.set(__self__, "infrastructure_encryption_enabled", infrastructure_encryption_enabled)

    @property
    @pulumi.getter(name="identityId")
    def identity_id(self) -> pulumi.Input[str]:
        """
        The ID of the User Assigned Identity that has access to the key.
        """
        return pulumi.get(self, "identity_id")

    @identity_id.setter
    def identity_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_id", value)

    @property
    @pulumi.getter(name="keyVaultKeyId")
    def key_vault_key_id(self) -> pulumi.Input[str]:
        """
        The ID of the Key Vault Key which should be used to Encrypt the data in this ServiceBus Namespace.
        """
        return pulumi.get(self, "key_vault_key_id")

    @key_vault_key_id.setter
    def key_vault_key_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_vault_key_id", value)

    @property
    @pulumi.getter(name="infrastructureEncryptionEnabled")
    def infrastructure_encryption_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Used to specify whether enable Infrastructure Encryption (Double Encryption). Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "infrastructure_encryption_enabled")

    @infrastructure_encryption_enabled.setter
    def infrastructure_encryption_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "infrastructure_encryption_enabled", value)


@pulumi.input_type
class NamespaceIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 identity_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 principal_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Specifies the type of Managed Service Identity that should be configured on this ServiceBus Namespace. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] identity_ids: Specifies a list of User Assigned Managed Identity IDs to be assigned to this ServiceBus namespace.
               
               > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        :param pulumi.Input[str] principal_id: The Principal ID for the Service Principal associated with the Managed Service Identity of this ServiceBus Namespace.
        :param pulumi.Input[str] tenant_id: The Tenant ID for the Service Principal associated with the Managed Service Identity of this ServiceBus Namespace.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies the type of Managed Service Identity that should be configured on this ServiceBus Namespace. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of User Assigned Managed Identity IDs to be assigned to this ServiceBus namespace.

        > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @identity_ids.setter
    def identity_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "identity_ids", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Principal ID for the Service Principal associated with the Managed Service Identity of this ServiceBus Namespace.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Tenant ID for the Service Principal associated with the Managed Service Identity of this ServiceBus Namespace.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


@pulumi.input_type
class NamespaceNetworkRuleSetArgs:
    def __init__(__self__, *,
                 default_action: Optional[pulumi.Input[str]] = None,
                 ip_rules: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 network_rules: Optional[pulumi.Input[Sequence[pulumi.Input['NamespaceNetworkRuleSetNetworkRuleArgs']]]] = None,
                 public_network_access_enabled: Optional[pulumi.Input[bool]] = None,
                 trusted_services_allowed: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] default_action: Specifies the default action for the Network Rule Set. Possible values are `Allow` and `Deny`. Defaults to `Allow`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_rules: One or more IP Addresses, or CIDR Blocks which should be able to access the ServiceBus Namespace.
        :param pulumi.Input[Sequence[pulumi.Input['NamespaceNetworkRuleSetNetworkRuleArgs']]] network_rules: One or more `network_rules` blocks as defined below.
        :param pulumi.Input[bool] public_network_access_enabled: Whether to allow traffic over public network. Possible values are `true` and `false`. Defaults to `true`.
        :param pulumi.Input[bool] trusted_services_allowed: Are Azure Services that are known and trusted for this resource type are allowed to bypass firewall configuration? See [Trusted Microsoft Services](https://github.com/MicrosoftDocs/azure-docs/blob/master/articles/service-bus-messaging/includes/service-bus-trusted-services.md)
        """
        if default_action is not None:
            pulumi.set(__self__, "default_action", default_action)
        if ip_rules is not None:
            pulumi.set(__self__, "ip_rules", ip_rules)
        if network_rules is not None:
            pulumi.set(__self__, "network_rules", network_rules)
        if public_network_access_enabled is not None:
            pulumi.set(__self__, "public_network_access_enabled", public_network_access_enabled)
        if trusted_services_allowed is not None:
            pulumi.set(__self__, "trusted_services_allowed", trusted_services_allowed)

    @property
    @pulumi.getter(name="defaultAction")
    def default_action(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the default action for the Network Rule Set. Possible values are `Allow` and `Deny`. Defaults to `Allow`.
        """
        return pulumi.get(self, "default_action")

    @default_action.setter
    def default_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_action", value)

    @property
    @pulumi.getter(name="ipRules")
    def ip_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        One or more IP Addresses, or CIDR Blocks which should be able to access the ServiceBus Namespace.
        """
        return pulumi.get(self, "ip_rules")

    @ip_rules.setter
    def ip_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_rules", value)

    @property
    @pulumi.getter(name="networkRules")
    def network_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NamespaceNetworkRuleSetNetworkRuleArgs']]]]:
        """
        One or more `network_rules` blocks as defined below.
        """
        return pulumi.get(self, "network_rules")

    @network_rules.setter
    def network_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NamespaceNetworkRuleSetNetworkRuleArgs']]]]):
        pulumi.set(self, "network_rules", value)

    @property
    @pulumi.getter(name="publicNetworkAccessEnabled")
    def public_network_access_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to allow traffic over public network. Possible values are `true` and `false`. Defaults to `true`.
        """
        return pulumi.get(self, "public_network_access_enabled")

    @public_network_access_enabled.setter
    def public_network_access_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "public_network_access_enabled", value)

    @property
    @pulumi.getter(name="trustedServicesAllowed")
    def trusted_services_allowed(self) -> Optional[pulumi.Input[bool]]:
        """
        Are Azure Services that are known and trusted for this resource type are allowed to bypass firewall configuration? See [Trusted Microsoft Services](https://github.com/MicrosoftDocs/azure-docs/blob/master/articles/service-bus-messaging/includes/service-bus-trusted-services.md)
        """
        return pulumi.get(self, "trusted_services_allowed")

    @trusted_services_allowed.setter
    def trusted_services_allowed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "trusted_services_allowed", value)


@pulumi.input_type
class NamespaceNetworkRuleSetNetworkRuleArgs:
    def __init__(__self__, *,
                 subnet_id: pulumi.Input[str],
                 ignore_missing_vnet_service_endpoint: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] subnet_id: The Subnet ID which should be able to access this ServiceBus Namespace.
        :param pulumi.Input[bool] ignore_missing_vnet_service_endpoint: Should the ServiceBus Namespace Network Rule Set ignore missing Virtual Network Service Endpoint option in the Subnet? Defaults to `false`.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        if ignore_missing_vnet_service_endpoint is not None:
            pulumi.set(__self__, "ignore_missing_vnet_service_endpoint", ignore_missing_vnet_service_endpoint)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        The Subnet ID which should be able to access this ServiceBus Namespace.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="ignoreMissingVnetServiceEndpoint")
    def ignore_missing_vnet_service_endpoint(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the ServiceBus Namespace Network Rule Set ignore missing Virtual Network Service Endpoint option in the Subnet? Defaults to `false`.
        """
        return pulumi.get(self, "ignore_missing_vnet_service_endpoint")

    @ignore_missing_vnet_service_endpoint.setter
    def ignore_missing_vnet_service_endpoint(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_missing_vnet_service_endpoint", value)


@pulumi.input_type
class SubscriptionClientScopedSubscriptionArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[str]] = None,
                 is_client_scoped_subscription_durable: Optional[pulumi.Input[bool]] = None,
                 is_client_scoped_subscription_shareable: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] client_id: Specifies the Client ID of the application that created the client-scoped subscription. Changing this forces a new resource to be created.
               
               > **NOTE:** Client ID can be null or empty, but it must match the client ID set on the JMS client application. From the Azure Service Bus perspective, a null client ID and an empty client id have the same behavior. If the client ID is set to null or empty, it is only accessible to client applications whose client ID is also set to null or empty.
        :param pulumi.Input[bool] is_client_scoped_subscription_durable: Whether the client scoped subscription is durable. This property can only be controlled from the application side.
        :param pulumi.Input[bool] is_client_scoped_subscription_shareable: Whether the client scoped subscription is shareable. Defaults to `true` Changing this forces a new resource to be created.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if is_client_scoped_subscription_durable is not None:
            pulumi.set(__self__, "is_client_scoped_subscription_durable", is_client_scoped_subscription_durable)
        if is_client_scoped_subscription_shareable is not None:
            pulumi.set(__self__, "is_client_scoped_subscription_shareable", is_client_scoped_subscription_shareable)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the Client ID of the application that created the client-scoped subscription. Changing this forces a new resource to be created.

        > **NOTE:** Client ID can be null or empty, but it must match the client ID set on the JMS client application. From the Azure Service Bus perspective, a null client ID and an empty client id have the same behavior. If the client ID is set to null or empty, it is only accessible to client applications whose client ID is also set to null or empty.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="isClientScopedSubscriptionDurable")
    def is_client_scoped_subscription_durable(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the client scoped subscription is durable. This property can only be controlled from the application side.
        """
        return pulumi.get(self, "is_client_scoped_subscription_durable")

    @is_client_scoped_subscription_durable.setter
    def is_client_scoped_subscription_durable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_client_scoped_subscription_durable", value)

    @property
    @pulumi.getter(name="isClientScopedSubscriptionShareable")
    def is_client_scoped_subscription_shareable(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the client scoped subscription is shareable. Defaults to `true` Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "is_client_scoped_subscription_shareable")

    @is_client_scoped_subscription_shareable.setter
    def is_client_scoped_subscription_shareable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_client_scoped_subscription_shareable", value)


@pulumi.input_type
class SubscriptionRuleCorrelationFilterArgs:
    def __init__(__self__, *,
                 content_type: Optional[pulumi.Input[str]] = None,
                 correlation_id: Optional[pulumi.Input[str]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 message_id: Optional[pulumi.Input[str]] = None,
                 properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 reply_to: Optional[pulumi.Input[str]] = None,
                 reply_to_session_id: Optional[pulumi.Input[str]] = None,
                 session_id: Optional[pulumi.Input[str]] = None,
                 to: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] content_type: Content type of the message.
        :param pulumi.Input[str] correlation_id: Identifier of the correlation.
        :param pulumi.Input[str] label: Application specific label.
        :param pulumi.Input[str] message_id: Identifier of the message.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] properties: A list of user defined properties to be included in the filter. Specified as a map of name/value pairs.
               
               > **NOTE:** When creating a subscription rule of type `CorrelationFilter` at least one property must be set in the `correlation_filter` block.
        :param pulumi.Input[str] reply_to: Address of the queue to reply to.
        :param pulumi.Input[str] reply_to_session_id: Session identifier to reply to.
        :param pulumi.Input[str] session_id: Session identifier.
        :param pulumi.Input[str] to: Address to send to.
        """
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if correlation_id is not None:
            pulumi.set(__self__, "correlation_id", correlation_id)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if message_id is not None:
            pulumi.set(__self__, "message_id", message_id)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if reply_to is not None:
            pulumi.set(__self__, "reply_to", reply_to)
        if reply_to_session_id is not None:
            pulumi.set(__self__, "reply_to_session_id", reply_to_session_id)
        if session_id is not None:
            pulumi.set(__self__, "session_id", session_id)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[str]]:
        """
        Content type of the message.
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_type", value)

    @property
    @pulumi.getter(name="correlationId")
    def correlation_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of the correlation.
        """
        return pulumi.get(self, "correlation_id")

    @correlation_id.setter
    def correlation_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "correlation_id", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        Application specific label.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter(name="messageId")
    def message_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of the message.
        """
        return pulumi.get(self, "message_id")

    @message_id.setter
    def message_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message_id", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A list of user defined properties to be included in the filter. Specified as a map of name/value pairs.

        > **NOTE:** When creating a subscription rule of type `CorrelationFilter` at least one property must be set in the `correlation_filter` block.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter(name="replyTo")
    def reply_to(self) -> Optional[pulumi.Input[str]]:
        """
        Address of the queue to reply to.
        """
        return pulumi.get(self, "reply_to")

    @reply_to.setter
    def reply_to(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reply_to", value)

    @property
    @pulumi.getter(name="replyToSessionId")
    def reply_to_session_id(self) -> Optional[pulumi.Input[str]]:
        """
        Session identifier to reply to.
        """
        return pulumi.get(self, "reply_to_session_id")

    @reply_to_session_id.setter
    def reply_to_session_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reply_to_session_id", value)

    @property
    @pulumi.getter(name="sessionId")
    def session_id(self) -> Optional[pulumi.Input[str]]:
        """
        Session identifier.
        """
        return pulumi.get(self, "session_id")

    @session_id.setter
    def session_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "session_id", value)

    @property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input[str]]:
        """
        Address to send to.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "to", value)


