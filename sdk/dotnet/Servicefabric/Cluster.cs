// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Azure.ServiceFabric
{
    /// <summary>
    /// Manages a Service Fabric Cluster.
    /// 
    /// &gt; This content is derived from https://github.com/terraform-providers/terraform-provider-azurerm/blob/master/website/docs/r/service_fabric_cluster.html.markdown.
    /// </summary>
    public partial class Cluster : Pulumi.CustomResource
    {
        /// <summary>
        /// A List of one or more features which should be enabled, such as `DnsService`.
        /// </summary>
        [Output("addOnFeatures")]
        public Output<ImmutableArray<string>> AddOnFeatures { get; private set; } = null!;

        /// <summary>
        /// An `azure_active_directory` block as defined below.
        /// </summary>
        [Output("azureActiveDirectory")]
        public Output<Outputs.ClusterAzureActiveDirectory?> AzureActiveDirectory { get; private set; } = null!;

        /// <summary>
        /// A `certificate` block as defined below. Conflicts with `certificate_common_names`.
        /// </summary>
        [Output("certificate")]
        public Output<Outputs.ClusterCertificate?> Certificate { get; private set; } = null!;

        /// <summary>
        /// A `certificate_common_names` block as defined below. Conflicts with `certificate`.
        /// </summary>
        [Output("certificateCommonNames")]
        public Output<Outputs.ClusterCertificateCommonNames?> CertificateCommonNames { get; private set; } = null!;

        /// <summary>
        /// A `client_certificate_common_name` block as defined below. 
        /// </summary>
        [Output("clientCertificateCommonNames")]
        public Output<ImmutableArray<Outputs.ClusterClientCertificateCommonNames>> ClientCertificateCommonNames { get; private set; } = null!;

        /// <summary>
        /// One or two `client_certificate_thumbprint` blocks as defined below. 
        /// </summary>
        [Output("clientCertificateThumbprints")]
        public Output<ImmutableArray<Outputs.ClusterClientCertificateThumbprints>> ClientCertificateThumbprints { get; private set; } = null!;

        /// <summary>
        /// Required if Upgrade Mode set to `Manual`, Specifies the Version of the Cluster Code of the cluster.
        /// </summary>
        [Output("clusterCodeVersion")]
        public Output<string> ClusterCodeVersion { get; private set; } = null!;

        /// <summary>
        /// The Cluster Endpoint for this Service Fabric Cluster.
        /// </summary>
        [Output("clusterEndpoint")]
        public Output<string> ClusterEndpoint { get; private set; } = null!;

        /// <summary>
        /// A `diagnostics_config` block as defined below. Changing this forces a new resource to be created.
        /// </summary>
        [Output("diagnosticsConfig")]
        public Output<Outputs.ClusterDiagnosticsConfig?> DiagnosticsConfig { get; private set; } = null!;

        /// <summary>
        /// One or more `fabric_settings` blocks as defined below.
        /// </summary>
        [Output("fabricSettings")]
        public Output<ImmutableArray<Outputs.ClusterFabricSettings>> FabricSettings { get; private set; } = null!;

        /// <summary>
        /// Specifies the Azure Region where the Service Fabric Cluster should exist. Changing this forces a new resource to be created.
        /// </summary>
        [Output("location")]
        public Output<string> Location { get; private set; } = null!;

        /// <summary>
        /// Specifies the Management Endpoint of the cluster such as `http://example.com`. Changing this forces a new resource to be created.
        /// </summary>
        [Output("managementEndpoint")]
        public Output<string> ManagementEndpoint { get; private set; } = null!;

        /// <summary>
        /// The name of the Service Fabric Cluster. Changing this forces a new resource to be created.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// One or more `node_type` blocks as defined below.
        /// </summary>
        [Output("nodeTypes")]
        public Output<ImmutableArray<Outputs.ClusterNodeTypes>> NodeTypes { get; private set; } = null!;

        /// <summary>
        /// Specifies the Reliability Level of the Cluster. Possible values include `None`, `Bronze`, `Silver`, `Gold` and `Platinum`.
        /// </summary>
        [Output("reliabilityLevel")]
        public Output<string> ReliabilityLevel { get; private set; } = null!;

        /// <summary>
        /// The name of the Resource Group in which the Service Fabric Cluster exists. Changing this forces a new resource to be created.
        /// </summary>
        [Output("resourceGroupName")]
        public Output<string> ResourceGroupName { get; private set; } = null!;

        /// <summary>
        /// A `reverse_proxy_certificate` block as defined below.
        /// </summary>
        [Output("reverseProxyCertificate")]
        public Output<Outputs.ClusterReverseProxyCertificate?> ReverseProxyCertificate { get; private set; } = null!;

        /// <summary>
        /// A mapping of tags to assign to the resource.
        /// </summary>
        [Output("tags")]
        public Output<ImmutableDictionary<string, string>?> Tags { get; private set; } = null!;

        /// <summary>
        /// Specifies the Upgrade Mode of the cluster. Possible values are `Automatic` or `Manual`.
        /// </summary>
        [Output("upgradeMode")]
        public Output<string> UpgradeMode { get; private set; } = null!;

        /// <summary>
        /// Specifies the Image expected for the Service Fabric Cluster, such as `Windows`. Changing this forces a new resource to be created.
        /// </summary>
        [Output("vmImage")]
        public Output<string> VmImage { get; private set; } = null!;


        /// <summary>
        /// Create a Cluster resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public Cluster(string name, ClusterArgs args, CustomResourceOptions? options = null)
            : base("azure:servicefabric/cluster:Cluster", name, args ?? ResourceArgs.Empty, MakeResourceOptions(options, ""))
        {
        }

        private Cluster(string name, Input<string> id, ClusterState? state = null, CustomResourceOptions? options = null)
            : base("azure:servicefabric/cluster:Cluster", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing Cluster resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static Cluster Get(string name, Input<string> id, ClusterState? state = null, CustomResourceOptions? options = null)
        {
            return new Cluster(name, id, state, options);
        }
    }

    public sealed class ClusterArgs : Pulumi.ResourceArgs
    {
        [Input("addOnFeatures")]
        private InputList<string>? _addOnFeatures;

        /// <summary>
        /// A List of one or more features which should be enabled, such as `DnsService`.
        /// </summary>
        public InputList<string> AddOnFeatures
        {
            get => _addOnFeatures ?? (_addOnFeatures = new InputList<string>());
            set => _addOnFeatures = value;
        }

        /// <summary>
        /// An `azure_active_directory` block as defined below.
        /// </summary>
        [Input("azureActiveDirectory")]
        public Input<Inputs.ClusterAzureActiveDirectoryArgs>? AzureActiveDirectory { get; set; }

        /// <summary>
        /// A `certificate` block as defined below. Conflicts with `certificate_common_names`.
        /// </summary>
        [Input("certificate")]
        public Input<Inputs.ClusterCertificateArgs>? Certificate { get; set; }

        /// <summary>
        /// A `certificate_common_names` block as defined below. Conflicts with `certificate`.
        /// </summary>
        [Input("certificateCommonNames")]
        public Input<Inputs.ClusterCertificateCommonNamesArgs>? CertificateCommonNames { get; set; }

        [Input("clientCertificateCommonNames")]
        private InputList<Inputs.ClusterClientCertificateCommonNamesArgs>? _clientCertificateCommonNames;

        /// <summary>
        /// A `client_certificate_common_name` block as defined below. 
        /// </summary>
        public InputList<Inputs.ClusterClientCertificateCommonNamesArgs> ClientCertificateCommonNames
        {
            get => _clientCertificateCommonNames ?? (_clientCertificateCommonNames = new InputList<Inputs.ClusterClientCertificateCommonNamesArgs>());
            set => _clientCertificateCommonNames = value;
        }

        [Input("clientCertificateThumbprints")]
        private InputList<Inputs.ClusterClientCertificateThumbprintsArgs>? _clientCertificateThumbprints;

        /// <summary>
        /// One or two `client_certificate_thumbprint` blocks as defined below. 
        /// </summary>
        public InputList<Inputs.ClusterClientCertificateThumbprintsArgs> ClientCertificateThumbprints
        {
            get => _clientCertificateThumbprints ?? (_clientCertificateThumbprints = new InputList<Inputs.ClusterClientCertificateThumbprintsArgs>());
            set => _clientCertificateThumbprints = value;
        }

        /// <summary>
        /// Required if Upgrade Mode set to `Manual`, Specifies the Version of the Cluster Code of the cluster.
        /// </summary>
        [Input("clusterCodeVersion")]
        public Input<string>? ClusterCodeVersion { get; set; }

        /// <summary>
        /// A `diagnostics_config` block as defined below. Changing this forces a new resource to be created.
        /// </summary>
        [Input("diagnosticsConfig")]
        public Input<Inputs.ClusterDiagnosticsConfigArgs>? DiagnosticsConfig { get; set; }

        [Input("fabricSettings")]
        private InputList<Inputs.ClusterFabricSettingsArgs>? _fabricSettings;

        /// <summary>
        /// One or more `fabric_settings` blocks as defined below.
        /// </summary>
        public InputList<Inputs.ClusterFabricSettingsArgs> FabricSettings
        {
            get => _fabricSettings ?? (_fabricSettings = new InputList<Inputs.ClusterFabricSettingsArgs>());
            set => _fabricSettings = value;
        }

        /// <summary>
        /// Specifies the Azure Region where the Service Fabric Cluster should exist. Changing this forces a new resource to be created.
        /// </summary>
        [Input("location")]
        public Input<string>? Location { get; set; }

        /// <summary>
        /// Specifies the Management Endpoint of the cluster such as `http://example.com`. Changing this forces a new resource to be created.
        /// </summary>
        [Input("managementEndpoint", required: true)]
        public Input<string> ManagementEndpoint { get; set; } = null!;

        /// <summary>
        /// The name of the Service Fabric Cluster. Changing this forces a new resource to be created.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("nodeTypes", required: true)]
        private InputList<Inputs.ClusterNodeTypesArgs>? _nodeTypes;

        /// <summary>
        /// One or more `node_type` blocks as defined below.
        /// </summary>
        public InputList<Inputs.ClusterNodeTypesArgs> NodeTypes
        {
            get => _nodeTypes ?? (_nodeTypes = new InputList<Inputs.ClusterNodeTypesArgs>());
            set => _nodeTypes = value;
        }

        /// <summary>
        /// Specifies the Reliability Level of the Cluster. Possible values include `None`, `Bronze`, `Silver`, `Gold` and `Platinum`.
        /// </summary>
        [Input("reliabilityLevel", required: true)]
        public Input<string> ReliabilityLevel { get; set; } = null!;

        /// <summary>
        /// The name of the Resource Group in which the Service Fabric Cluster exists. Changing this forces a new resource to be created.
        /// </summary>
        [Input("resourceGroupName", required: true)]
        public Input<string> ResourceGroupName { get; set; } = null!;

        /// <summary>
        /// A `reverse_proxy_certificate` block as defined below.
        /// </summary>
        [Input("reverseProxyCertificate")]
        public Input<Inputs.ClusterReverseProxyCertificateArgs>? ReverseProxyCertificate { get; set; }

        [Input("tags")]
        private InputMap<string>? _tags;

        /// <summary>
        /// A mapping of tags to assign to the resource.
        /// </summary>
        public InputMap<string> Tags
        {
            get => _tags ?? (_tags = new InputMap<string>());
            set => _tags = value;
        }

        /// <summary>
        /// Specifies the Upgrade Mode of the cluster. Possible values are `Automatic` or `Manual`.
        /// </summary>
        [Input("upgradeMode", required: true)]
        public Input<string> UpgradeMode { get; set; } = null!;

        /// <summary>
        /// Specifies the Image expected for the Service Fabric Cluster, such as `Windows`. Changing this forces a new resource to be created.
        /// </summary>
        [Input("vmImage", required: true)]
        public Input<string> VmImage { get; set; } = null!;

        public ClusterArgs()
        {
        }
    }

    public sealed class ClusterState : Pulumi.ResourceArgs
    {
        [Input("addOnFeatures")]
        private InputList<string>? _addOnFeatures;

        /// <summary>
        /// A List of one or more features which should be enabled, such as `DnsService`.
        /// </summary>
        public InputList<string> AddOnFeatures
        {
            get => _addOnFeatures ?? (_addOnFeatures = new InputList<string>());
            set => _addOnFeatures = value;
        }

        /// <summary>
        /// An `azure_active_directory` block as defined below.
        /// </summary>
        [Input("azureActiveDirectory")]
        public Input<Inputs.ClusterAzureActiveDirectoryGetArgs>? AzureActiveDirectory { get; set; }

        /// <summary>
        /// A `certificate` block as defined below. Conflicts with `certificate_common_names`.
        /// </summary>
        [Input("certificate")]
        public Input<Inputs.ClusterCertificateGetArgs>? Certificate { get; set; }

        /// <summary>
        /// A `certificate_common_names` block as defined below. Conflicts with `certificate`.
        /// </summary>
        [Input("certificateCommonNames")]
        public Input<Inputs.ClusterCertificateCommonNamesGetArgs>? CertificateCommonNames { get; set; }

        [Input("clientCertificateCommonNames")]
        private InputList<Inputs.ClusterClientCertificateCommonNamesGetArgs>? _clientCertificateCommonNames;

        /// <summary>
        /// A `client_certificate_common_name` block as defined below. 
        /// </summary>
        public InputList<Inputs.ClusterClientCertificateCommonNamesGetArgs> ClientCertificateCommonNames
        {
            get => _clientCertificateCommonNames ?? (_clientCertificateCommonNames = new InputList<Inputs.ClusterClientCertificateCommonNamesGetArgs>());
            set => _clientCertificateCommonNames = value;
        }

        [Input("clientCertificateThumbprints")]
        private InputList<Inputs.ClusterClientCertificateThumbprintsGetArgs>? _clientCertificateThumbprints;

        /// <summary>
        /// One or two `client_certificate_thumbprint` blocks as defined below. 
        /// </summary>
        public InputList<Inputs.ClusterClientCertificateThumbprintsGetArgs> ClientCertificateThumbprints
        {
            get => _clientCertificateThumbprints ?? (_clientCertificateThumbprints = new InputList<Inputs.ClusterClientCertificateThumbprintsGetArgs>());
            set => _clientCertificateThumbprints = value;
        }

        /// <summary>
        /// Required if Upgrade Mode set to `Manual`, Specifies the Version of the Cluster Code of the cluster.
        /// </summary>
        [Input("clusterCodeVersion")]
        public Input<string>? ClusterCodeVersion { get; set; }

        /// <summary>
        /// The Cluster Endpoint for this Service Fabric Cluster.
        /// </summary>
        [Input("clusterEndpoint")]
        public Input<string>? ClusterEndpoint { get; set; }

        /// <summary>
        /// A `diagnostics_config` block as defined below. Changing this forces a new resource to be created.
        /// </summary>
        [Input("diagnosticsConfig")]
        public Input<Inputs.ClusterDiagnosticsConfigGetArgs>? DiagnosticsConfig { get; set; }

        [Input("fabricSettings")]
        private InputList<Inputs.ClusterFabricSettingsGetArgs>? _fabricSettings;

        /// <summary>
        /// One or more `fabric_settings` blocks as defined below.
        /// </summary>
        public InputList<Inputs.ClusterFabricSettingsGetArgs> FabricSettings
        {
            get => _fabricSettings ?? (_fabricSettings = new InputList<Inputs.ClusterFabricSettingsGetArgs>());
            set => _fabricSettings = value;
        }

        /// <summary>
        /// Specifies the Azure Region where the Service Fabric Cluster should exist. Changing this forces a new resource to be created.
        /// </summary>
        [Input("location")]
        public Input<string>? Location { get; set; }

        /// <summary>
        /// Specifies the Management Endpoint of the cluster such as `http://example.com`. Changing this forces a new resource to be created.
        /// </summary>
        [Input("managementEndpoint")]
        public Input<string>? ManagementEndpoint { get; set; }

        /// <summary>
        /// The name of the Service Fabric Cluster. Changing this forces a new resource to be created.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("nodeTypes")]
        private InputList<Inputs.ClusterNodeTypesGetArgs>? _nodeTypes;

        /// <summary>
        /// One or more `node_type` blocks as defined below.
        /// </summary>
        public InputList<Inputs.ClusterNodeTypesGetArgs> NodeTypes
        {
            get => _nodeTypes ?? (_nodeTypes = new InputList<Inputs.ClusterNodeTypesGetArgs>());
            set => _nodeTypes = value;
        }

        /// <summary>
        /// Specifies the Reliability Level of the Cluster. Possible values include `None`, `Bronze`, `Silver`, `Gold` and `Platinum`.
        /// </summary>
        [Input("reliabilityLevel")]
        public Input<string>? ReliabilityLevel { get; set; }

        /// <summary>
        /// The name of the Resource Group in which the Service Fabric Cluster exists. Changing this forces a new resource to be created.
        /// </summary>
        [Input("resourceGroupName")]
        public Input<string>? ResourceGroupName { get; set; }

        /// <summary>
        /// A `reverse_proxy_certificate` block as defined below.
        /// </summary>
        [Input("reverseProxyCertificate")]
        public Input<Inputs.ClusterReverseProxyCertificateGetArgs>? ReverseProxyCertificate { get; set; }

        [Input("tags")]
        private InputMap<string>? _tags;

        /// <summary>
        /// A mapping of tags to assign to the resource.
        /// </summary>
        public InputMap<string> Tags
        {
            get => _tags ?? (_tags = new InputMap<string>());
            set => _tags = value;
        }

        /// <summary>
        /// Specifies the Upgrade Mode of the cluster. Possible values are `Automatic` or `Manual`.
        /// </summary>
        [Input("upgradeMode")]
        public Input<string>? UpgradeMode { get; set; }

        /// <summary>
        /// Specifies the Image expected for the Service Fabric Cluster, such as `Windows`. Changing this forces a new resource to be created.
        /// </summary>
        [Input("vmImage")]
        public Input<string>? VmImage { get; set; }

        public ClusterState()
        {
        }
    }

    namespace Inputs
    {

    public sealed class ClusterAzureActiveDirectoryArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The Azure Active Directory Client ID which should be used for the Client Application.
        /// </summary>
        [Input("clientApplicationId", required: true)]
        public Input<string> ClientApplicationId { get; set; } = null!;

        /// <summary>
        /// The Azure Active Directory Cluster Application ID.
        /// </summary>
        [Input("clusterApplicationId", required: true)]
        public Input<string> ClusterApplicationId { get; set; } = null!;

        /// <summary>
        /// The Azure Active Directory Tenant ID.
        /// </summary>
        [Input("tenantId", required: true)]
        public Input<string> TenantId { get; set; } = null!;

        public ClusterAzureActiveDirectoryArgs()
        {
        }
    }

    public sealed class ClusterAzureActiveDirectoryGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The Azure Active Directory Client ID which should be used for the Client Application.
        /// </summary>
        [Input("clientApplicationId", required: true)]
        public Input<string> ClientApplicationId { get; set; } = null!;

        /// <summary>
        /// The Azure Active Directory Cluster Application ID.
        /// </summary>
        [Input("clusterApplicationId", required: true)]
        public Input<string> ClusterApplicationId { get; set; } = null!;

        /// <summary>
        /// The Azure Active Directory Tenant ID.
        /// </summary>
        [Input("tenantId", required: true)]
        public Input<string> TenantId { get; set; } = null!;

        public ClusterAzureActiveDirectoryGetArgs()
        {
        }
    }

    public sealed class ClusterCertificateArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The Thumbprint of the Certificate.
        /// </summary>
        [Input("thumbprint", required: true)]
        public Input<string> Thumbprint { get; set; } = null!;

        /// <summary>
        /// The Secondary Thumbprint of the Certificate.
        /// </summary>
        [Input("thumbprintSecondary")]
        public Input<string>? ThumbprintSecondary { get; set; }

        /// <summary>
        /// The X509 Store where the Certificate Exists, such as `My`.
        /// </summary>
        [Input("x509StoreName", required: true)]
        public Input<string> X509StoreName { get; set; } = null!;

        public ClusterCertificateArgs()
        {
        }
    }

    public sealed class ClusterCertificateCommonNamesArgs : Pulumi.ResourceArgs
    {
        [Input("commonNames", required: true)]
        private InputList<ClusterCertificateCommonNamesCommonNamesArgs>? _commonNames;

        /// <summary>
        /// A `common_names` block as defined below.
        /// </summary>
        public InputList<ClusterCertificateCommonNamesCommonNamesArgs> CommonNames
        {
            get => _commonNames ?? (_commonNames = new InputList<ClusterCertificateCommonNamesCommonNamesArgs>());
            set => _commonNames = value;
        }

        /// <summary>
        /// The X509 Store where the Certificate Exists, such as `My`.
        /// </summary>
        [Input("x509StoreName", required: true)]
        public Input<string> X509StoreName { get; set; } = null!;

        public ClusterCertificateCommonNamesArgs()
        {
        }
    }

    public sealed class ClusterCertificateCommonNamesCommonNamesArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The common or subject name of the certificate.
        /// </summary>
        [Input("certificateCommonName", required: true)]
        public Input<string> CertificateCommonName { get; set; } = null!;

        /// <summary>
        /// The Issuer Thumbprint of the Certificate.
        /// </summary>
        [Input("certificateIssuerThumbprint")]
        public Input<string>? CertificateIssuerThumbprint { get; set; }

        public ClusterCertificateCommonNamesCommonNamesArgs()
        {
        }
    }

    public sealed class ClusterCertificateCommonNamesCommonNamesGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The common or subject name of the certificate.
        /// </summary>
        [Input("certificateCommonName", required: true)]
        public Input<string> CertificateCommonName { get; set; } = null!;

        /// <summary>
        /// The Issuer Thumbprint of the Certificate.
        /// </summary>
        [Input("certificateIssuerThumbprint")]
        public Input<string>? CertificateIssuerThumbprint { get; set; }

        public ClusterCertificateCommonNamesCommonNamesGetArgs()
        {
        }
    }

    public sealed class ClusterCertificateCommonNamesGetArgs : Pulumi.ResourceArgs
    {
        [Input("commonNames", required: true)]
        private InputList<ClusterCertificateCommonNamesCommonNamesGetArgs>? _commonNames;

        /// <summary>
        /// A `common_names` block as defined below.
        /// </summary>
        public InputList<ClusterCertificateCommonNamesCommonNamesGetArgs> CommonNames
        {
            get => _commonNames ?? (_commonNames = new InputList<ClusterCertificateCommonNamesCommonNamesGetArgs>());
            set => _commonNames = value;
        }

        /// <summary>
        /// The X509 Store where the Certificate Exists, such as `My`.
        /// </summary>
        [Input("x509StoreName", required: true)]
        public Input<string> X509StoreName { get; set; } = null!;

        public ClusterCertificateCommonNamesGetArgs()
        {
        }
    }

    public sealed class ClusterCertificateGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The Thumbprint of the Certificate.
        /// </summary>
        [Input("thumbprint", required: true)]
        public Input<string> Thumbprint { get; set; } = null!;

        /// <summary>
        /// The Secondary Thumbprint of the Certificate.
        /// </summary>
        [Input("thumbprintSecondary")]
        public Input<string>? ThumbprintSecondary { get; set; }

        /// <summary>
        /// The X509 Store where the Certificate Exists, such as `My`.
        /// </summary>
        [Input("x509StoreName", required: true)]
        public Input<string> X509StoreName { get; set; } = null!;

        public ClusterCertificateGetArgs()
        {
        }
    }

    public sealed class ClusterClientCertificateCommonNamesArgs : Pulumi.ResourceArgs
    {
        [Input("commonName", required: true)]
        public Input<string> CommonName { get; set; } = null!;

        /// <summary>
        /// Does the Client Certificate have Admin Access to the cluster? Non-admin clients can only perform read only operations on the cluster.
        /// </summary>
        [Input("isAdmin", required: true)]
        public Input<bool> IsAdmin { get; set; } = null!;

        [Input("issuerThumbprint")]
        public Input<string>? IssuerThumbprint { get; set; }

        public ClusterClientCertificateCommonNamesArgs()
        {
        }
    }

    public sealed class ClusterClientCertificateCommonNamesGetArgs : Pulumi.ResourceArgs
    {
        [Input("commonName", required: true)]
        public Input<string> CommonName { get; set; } = null!;

        /// <summary>
        /// Does the Client Certificate have Admin Access to the cluster? Non-admin clients can only perform read only operations on the cluster.
        /// </summary>
        [Input("isAdmin", required: true)]
        public Input<bool> IsAdmin { get; set; } = null!;

        [Input("issuerThumbprint")]
        public Input<string>? IssuerThumbprint { get; set; }

        public ClusterClientCertificateCommonNamesGetArgs()
        {
        }
    }

    public sealed class ClusterClientCertificateThumbprintsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Does the Client Certificate have Admin Access to the cluster? Non-admin clients can only perform read only operations on the cluster.
        /// </summary>
        [Input("isAdmin", required: true)]
        public Input<bool> IsAdmin { get; set; } = null!;

        /// <summary>
        /// The Thumbprint associated with the Client Certificate.
        /// </summary>
        [Input("thumbprint", required: true)]
        public Input<string> Thumbprint { get; set; } = null!;

        public ClusterClientCertificateThumbprintsArgs()
        {
        }
    }

    public sealed class ClusterClientCertificateThumbprintsGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Does the Client Certificate have Admin Access to the cluster? Non-admin clients can only perform read only operations on the cluster.
        /// </summary>
        [Input("isAdmin", required: true)]
        public Input<bool> IsAdmin { get; set; } = null!;

        /// <summary>
        /// The Thumbprint associated with the Client Certificate.
        /// </summary>
        [Input("thumbprint", required: true)]
        public Input<string> Thumbprint { get; set; } = null!;

        public ClusterClientCertificateThumbprintsGetArgs()
        {
        }
    }

    public sealed class ClusterDiagnosticsConfigArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The Blob Endpoint of the Storage Account.
        /// </summary>
        [Input("blobEndpoint", required: true)]
        public Input<string> BlobEndpoint { get; set; } = null!;

        /// <summary>
        /// The protected diagnostics storage key name, such as `StorageAccountKey1`.
        /// </summary>
        [Input("protectedAccountKeyName", required: true)]
        public Input<string> ProtectedAccountKeyName { get; set; } = null!;

        /// <summary>
        /// The Queue Endpoint of the Storage Account.
        /// </summary>
        [Input("queueEndpoint", required: true)]
        public Input<string> QueueEndpoint { get; set; } = null!;

        /// <summary>
        /// The name of the Storage Account where the Diagnostics should be sent to.
        /// </summary>
        [Input("storageAccountName", required: true)]
        public Input<string> StorageAccountName { get; set; } = null!;

        /// <summary>
        /// The Table Endpoint of the Storage Account.
        /// </summary>
        [Input("tableEndpoint", required: true)]
        public Input<string> TableEndpoint { get; set; } = null!;

        public ClusterDiagnosticsConfigArgs()
        {
        }
    }

    public sealed class ClusterDiagnosticsConfigGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The Blob Endpoint of the Storage Account.
        /// </summary>
        [Input("blobEndpoint", required: true)]
        public Input<string> BlobEndpoint { get; set; } = null!;

        /// <summary>
        /// The protected diagnostics storage key name, such as `StorageAccountKey1`.
        /// </summary>
        [Input("protectedAccountKeyName", required: true)]
        public Input<string> ProtectedAccountKeyName { get; set; } = null!;

        /// <summary>
        /// The Queue Endpoint of the Storage Account.
        /// </summary>
        [Input("queueEndpoint", required: true)]
        public Input<string> QueueEndpoint { get; set; } = null!;

        /// <summary>
        /// The name of the Storage Account where the Diagnostics should be sent to.
        /// </summary>
        [Input("storageAccountName", required: true)]
        public Input<string> StorageAccountName { get; set; } = null!;

        /// <summary>
        /// The Table Endpoint of the Storage Account.
        /// </summary>
        [Input("tableEndpoint", required: true)]
        public Input<string> TableEndpoint { get; set; } = null!;

        public ClusterDiagnosticsConfigGetArgs()
        {
        }
    }

    public sealed class ClusterFabricSettingsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The name of the Fabric Setting, such as `Security` or `Federation`.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        [Input("parameters")]
        private InputMap<string>? _parameters;

        /// <summary>
        /// A map containing settings for the specified Fabric Setting.
        /// </summary>
        public InputMap<string> Parameters
        {
            get => _parameters ?? (_parameters = new InputMap<string>());
            set => _parameters = value;
        }

        public ClusterFabricSettingsArgs()
        {
        }
    }

    public sealed class ClusterFabricSettingsGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The name of the Fabric Setting, such as `Security` or `Federation`.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        [Input("parameters")]
        private InputMap<string>? _parameters;

        /// <summary>
        /// A map containing settings for the specified Fabric Setting.
        /// </summary>
        public InputMap<string> Parameters
        {
            get => _parameters ?? (_parameters = new InputMap<string>());
            set => _parameters = value;
        }

        public ClusterFabricSettingsGetArgs()
        {
        }
    }

    public sealed class ClusterNodeTypesApplicationPortsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The end of the Application Port Range on this Node Type.
        /// </summary>
        [Input("endPort", required: true)]
        public Input<int> EndPort { get; set; } = null!;

        /// <summary>
        /// The start of the Application Port Range on this Node Type.
        /// </summary>
        [Input("startPort", required: true)]
        public Input<int> StartPort { get; set; } = null!;

        public ClusterNodeTypesApplicationPortsArgs()
        {
        }
    }

    public sealed class ClusterNodeTypesApplicationPortsGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The end of the Application Port Range on this Node Type.
        /// </summary>
        [Input("endPort", required: true)]
        public Input<int> EndPort { get; set; } = null!;

        /// <summary>
        /// The start of the Application Port Range on this Node Type.
        /// </summary>
        [Input("startPort", required: true)]
        public Input<int> StartPort { get; set; } = null!;

        public ClusterNodeTypesApplicationPortsGetArgs()
        {
        }
    }

    public sealed class ClusterNodeTypesArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// A `application_ports` block as defined below.
        /// </summary>
        [Input("applicationPorts")]
        public Input<ClusterNodeTypesApplicationPortsArgs>? ApplicationPorts { get; set; }

        [Input("capacities")]
        private InputMap<string>? _capacities;

        /// <summary>
        /// The capacity tags applied to the nodes in the node type, the cluster resource manager uses these tags to understand how much resource a node has.
        /// </summary>
        public InputMap<string> Capacities
        {
            get => _capacities ?? (_capacities = new InputMap<string>());
            set => _capacities = value;
        }

        /// <summary>
        /// The Port used for the Client Endpoint for this Node Type. Changing this forces a new resource to be created.
        /// </summary>
        [Input("clientEndpointPort", required: true)]
        public Input<int> ClientEndpointPort { get; set; } = null!;

        /// <summary>
        /// The Durability Level for this Node Type. Possible values include `Bronze`, `Gold` and `Silver`. Defaults to `Bronze`. Changing this forces a new resource to be created.
        /// </summary>
        [Input("durabilityLevel")]
        public Input<string>? DurabilityLevel { get; set; }

        /// <summary>
        /// A `ephemeral_ports` block as defined below.
        /// </summary>
        [Input("ephemeralPorts")]
        public Input<ClusterNodeTypesEphemeralPortsArgs>? EphemeralPorts { get; set; }

        /// <summary>
        /// The Port used for the HTTP Endpoint for this Node Type. Changing this forces a new resource to be created.
        /// </summary>
        [Input("httpEndpointPort", required: true)]
        public Input<int> HttpEndpointPort { get; set; } = null!;

        /// <summary>
        /// The number of nodes for this Node Type.
        /// </summary>
        [Input("instanceCount", required: true)]
        public Input<int> InstanceCount { get; set; } = null!;

        /// <summary>
        /// Is this the Primary Node Type? Changing this forces a new resource to be created.
        /// </summary>
        [Input("isPrimary", required: true)]
        public Input<bool> IsPrimary { get; set; } = null!;

        /// <summary>
        /// The name of the Node Type. Changing this forces a new resource to be created.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        [Input("placementProperties")]
        private InputMap<string>? _placementProperties;

        /// <summary>
        /// The placement tags applied to nodes in the node type, which can be used to indicate where certain services (workload) should run.
        /// </summary>
        public InputMap<string> PlacementProperties
        {
            get => _placementProperties ?? (_placementProperties = new InputMap<string>());
            set => _placementProperties = value;
        }

        /// <summary>
        /// The Port used for the Reverse Proxy Endpoint  for this Node Type. Changing this will upgrade the cluster.
        /// </summary>
        [Input("reverseProxyEndpointPort")]
        public Input<int>? ReverseProxyEndpointPort { get; set; }

        public ClusterNodeTypesArgs()
        {
        }
    }

    public sealed class ClusterNodeTypesEphemeralPortsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The end of the Ephemeral Port Range on this Node Type.
        /// </summary>
        [Input("endPort", required: true)]
        public Input<int> EndPort { get; set; } = null!;

        /// <summary>
        /// The start of the Ephemeral Port Range on this Node Type.
        /// </summary>
        [Input("startPort", required: true)]
        public Input<int> StartPort { get; set; } = null!;

        public ClusterNodeTypesEphemeralPortsArgs()
        {
        }
    }

    public sealed class ClusterNodeTypesEphemeralPortsGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The end of the Ephemeral Port Range on this Node Type.
        /// </summary>
        [Input("endPort", required: true)]
        public Input<int> EndPort { get; set; } = null!;

        /// <summary>
        /// The start of the Ephemeral Port Range on this Node Type.
        /// </summary>
        [Input("startPort", required: true)]
        public Input<int> StartPort { get; set; } = null!;

        public ClusterNodeTypesEphemeralPortsGetArgs()
        {
        }
    }

    public sealed class ClusterNodeTypesGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// A `application_ports` block as defined below.
        /// </summary>
        [Input("applicationPorts")]
        public Input<ClusterNodeTypesApplicationPortsGetArgs>? ApplicationPorts { get; set; }

        [Input("capacities")]
        private InputMap<string>? _capacities;

        /// <summary>
        /// The capacity tags applied to the nodes in the node type, the cluster resource manager uses these tags to understand how much resource a node has.
        /// </summary>
        public InputMap<string> Capacities
        {
            get => _capacities ?? (_capacities = new InputMap<string>());
            set => _capacities = value;
        }

        /// <summary>
        /// The Port used for the Client Endpoint for this Node Type. Changing this forces a new resource to be created.
        /// </summary>
        [Input("clientEndpointPort", required: true)]
        public Input<int> ClientEndpointPort { get; set; } = null!;

        /// <summary>
        /// The Durability Level for this Node Type. Possible values include `Bronze`, `Gold` and `Silver`. Defaults to `Bronze`. Changing this forces a new resource to be created.
        /// </summary>
        [Input("durabilityLevel")]
        public Input<string>? DurabilityLevel { get; set; }

        /// <summary>
        /// A `ephemeral_ports` block as defined below.
        /// </summary>
        [Input("ephemeralPorts")]
        public Input<ClusterNodeTypesEphemeralPortsGetArgs>? EphemeralPorts { get; set; }

        /// <summary>
        /// The Port used for the HTTP Endpoint for this Node Type. Changing this forces a new resource to be created.
        /// </summary>
        [Input("httpEndpointPort", required: true)]
        public Input<int> HttpEndpointPort { get; set; } = null!;

        /// <summary>
        /// The number of nodes for this Node Type.
        /// </summary>
        [Input("instanceCount", required: true)]
        public Input<int> InstanceCount { get; set; } = null!;

        /// <summary>
        /// Is this the Primary Node Type? Changing this forces a new resource to be created.
        /// </summary>
        [Input("isPrimary", required: true)]
        public Input<bool> IsPrimary { get; set; } = null!;

        /// <summary>
        /// The name of the Node Type. Changing this forces a new resource to be created.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        [Input("placementProperties")]
        private InputMap<string>? _placementProperties;

        /// <summary>
        /// The placement tags applied to nodes in the node type, which can be used to indicate where certain services (workload) should run.
        /// </summary>
        public InputMap<string> PlacementProperties
        {
            get => _placementProperties ?? (_placementProperties = new InputMap<string>());
            set => _placementProperties = value;
        }

        /// <summary>
        /// The Port used for the Reverse Proxy Endpoint  for this Node Type. Changing this will upgrade the cluster.
        /// </summary>
        [Input("reverseProxyEndpointPort")]
        public Input<int>? ReverseProxyEndpointPort { get; set; }

        public ClusterNodeTypesGetArgs()
        {
        }
    }

    public sealed class ClusterReverseProxyCertificateArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The Thumbprint of the Certificate.
        /// </summary>
        [Input("thumbprint", required: true)]
        public Input<string> Thumbprint { get; set; } = null!;

        /// <summary>
        /// The Secondary Thumbprint of the Certificate.
        /// </summary>
        [Input("thumbprintSecondary")]
        public Input<string>? ThumbprintSecondary { get; set; }

        /// <summary>
        /// The X509 Store where the Certificate Exists, such as `My`.
        /// </summary>
        [Input("x509StoreName", required: true)]
        public Input<string> X509StoreName { get; set; } = null!;

        public ClusterReverseProxyCertificateArgs()
        {
        }
    }

    public sealed class ClusterReverseProxyCertificateGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The Thumbprint of the Certificate.
        /// </summary>
        [Input("thumbprint", required: true)]
        public Input<string> Thumbprint { get; set; } = null!;

        /// <summary>
        /// The Secondary Thumbprint of the Certificate.
        /// </summary>
        [Input("thumbprintSecondary")]
        public Input<string>? ThumbprintSecondary { get; set; }

        /// <summary>
        /// The X509 Store where the Certificate Exists, such as `My`.
        /// </summary>
        [Input("x509StoreName", required: true)]
        public Input<string> X509StoreName { get; set; } = null!;

        public ClusterReverseProxyCertificateGetArgs()
        {
        }
    }
    }

    namespace Outputs
    {

    [OutputType]
    public sealed class ClusterAzureActiveDirectory
    {
        /// <summary>
        /// The Azure Active Directory Client ID which should be used for the Client Application.
        /// </summary>
        public readonly string ClientApplicationId;
        /// <summary>
        /// The Azure Active Directory Cluster Application ID.
        /// </summary>
        public readonly string ClusterApplicationId;
        /// <summary>
        /// The Azure Active Directory Tenant ID.
        /// </summary>
        public readonly string TenantId;

        [OutputConstructor]
        private ClusterAzureActiveDirectory(
            string clientApplicationId,
            string clusterApplicationId,
            string tenantId)
        {
            ClientApplicationId = clientApplicationId;
            ClusterApplicationId = clusterApplicationId;
            TenantId = tenantId;
        }
    }

    [OutputType]
    public sealed class ClusterCertificate
    {
        /// <summary>
        /// The Thumbprint of the Certificate.
        /// </summary>
        public readonly string Thumbprint;
        /// <summary>
        /// The Secondary Thumbprint of the Certificate.
        /// </summary>
        public readonly string? ThumbprintSecondary;
        /// <summary>
        /// The X509 Store where the Certificate Exists, such as `My`.
        /// </summary>
        public readonly string X509StoreName;

        [OutputConstructor]
        private ClusterCertificate(
            string thumbprint,
            string? thumbprintSecondary,
            string x509StoreName)
        {
            Thumbprint = thumbprint;
            ThumbprintSecondary = thumbprintSecondary;
            X509StoreName = x509StoreName;
        }
    }

    [OutputType]
    public sealed class ClusterCertificateCommonNames
    {
        /// <summary>
        /// A `common_names` block as defined below.
        /// </summary>
        public readonly ImmutableArray<ClusterCertificateCommonNamesCommonNames> CommonNames;
        /// <summary>
        /// The X509 Store where the Certificate Exists, such as `My`.
        /// </summary>
        public readonly string X509StoreName;

        [OutputConstructor]
        private ClusterCertificateCommonNames(
            ImmutableArray<ClusterCertificateCommonNamesCommonNames> commonNames,
            string x509StoreName)
        {
            CommonNames = commonNames;
            X509StoreName = x509StoreName;
        }
    }

    [OutputType]
    public sealed class ClusterCertificateCommonNamesCommonNames
    {
        /// <summary>
        /// The common or subject name of the certificate.
        /// </summary>
        public readonly string CertificateCommonName;
        /// <summary>
        /// The Issuer Thumbprint of the Certificate.
        /// </summary>
        public readonly string? CertificateIssuerThumbprint;

        [OutputConstructor]
        private ClusterCertificateCommonNamesCommonNames(
            string certificateCommonName,
            string? certificateIssuerThumbprint)
        {
            CertificateCommonName = certificateCommonName;
            CertificateIssuerThumbprint = certificateIssuerThumbprint;
        }
    }

    [OutputType]
    public sealed class ClusterClientCertificateCommonNames
    {
        public readonly string CommonName;
        /// <summary>
        /// Does the Client Certificate have Admin Access to the cluster? Non-admin clients can only perform read only operations on the cluster.
        /// </summary>
        public readonly bool IsAdmin;
        public readonly string? IssuerThumbprint;

        [OutputConstructor]
        private ClusterClientCertificateCommonNames(
            string commonName,
            bool isAdmin,
            string? issuerThumbprint)
        {
            CommonName = commonName;
            IsAdmin = isAdmin;
            IssuerThumbprint = issuerThumbprint;
        }
    }

    [OutputType]
    public sealed class ClusterClientCertificateThumbprints
    {
        /// <summary>
        /// Does the Client Certificate have Admin Access to the cluster? Non-admin clients can only perform read only operations on the cluster.
        /// </summary>
        public readonly bool IsAdmin;
        /// <summary>
        /// The Thumbprint associated with the Client Certificate.
        /// </summary>
        public readonly string Thumbprint;

        [OutputConstructor]
        private ClusterClientCertificateThumbprints(
            bool isAdmin,
            string thumbprint)
        {
            IsAdmin = isAdmin;
            Thumbprint = thumbprint;
        }
    }

    [OutputType]
    public sealed class ClusterDiagnosticsConfig
    {
        /// <summary>
        /// The Blob Endpoint of the Storage Account.
        /// </summary>
        public readonly string BlobEndpoint;
        /// <summary>
        /// The protected diagnostics storage key name, such as `StorageAccountKey1`.
        /// </summary>
        public readonly string ProtectedAccountKeyName;
        /// <summary>
        /// The Queue Endpoint of the Storage Account.
        /// </summary>
        public readonly string QueueEndpoint;
        /// <summary>
        /// The name of the Storage Account where the Diagnostics should be sent to.
        /// </summary>
        public readonly string StorageAccountName;
        /// <summary>
        /// The Table Endpoint of the Storage Account.
        /// </summary>
        public readonly string TableEndpoint;

        [OutputConstructor]
        private ClusterDiagnosticsConfig(
            string blobEndpoint,
            string protectedAccountKeyName,
            string queueEndpoint,
            string storageAccountName,
            string tableEndpoint)
        {
            BlobEndpoint = blobEndpoint;
            ProtectedAccountKeyName = protectedAccountKeyName;
            QueueEndpoint = queueEndpoint;
            StorageAccountName = storageAccountName;
            TableEndpoint = tableEndpoint;
        }
    }

    [OutputType]
    public sealed class ClusterFabricSettings
    {
        /// <summary>
        /// The name of the Fabric Setting, such as `Security` or `Federation`.
        /// </summary>
        public readonly string Name;
        /// <summary>
        /// A map containing settings for the specified Fabric Setting.
        /// </summary>
        public readonly ImmutableDictionary<string, string>? Parameters;

        [OutputConstructor]
        private ClusterFabricSettings(
            string name,
            ImmutableDictionary<string, string>? parameters)
        {
            Name = name;
            Parameters = parameters;
        }
    }

    [OutputType]
    public sealed class ClusterNodeTypes
    {
        /// <summary>
        /// A `application_ports` block as defined below.
        /// </summary>
        public readonly ClusterNodeTypesApplicationPorts ApplicationPorts;
        /// <summary>
        /// The capacity tags applied to the nodes in the node type, the cluster resource manager uses these tags to understand how much resource a node has.
        /// </summary>
        public readonly ImmutableDictionary<string, string>? Capacities;
        /// <summary>
        /// The Port used for the Client Endpoint for this Node Type. Changing this forces a new resource to be created.
        /// </summary>
        public readonly int ClientEndpointPort;
        /// <summary>
        /// The Durability Level for this Node Type. Possible values include `Bronze`, `Gold` and `Silver`. Defaults to `Bronze`. Changing this forces a new resource to be created.
        /// </summary>
        public readonly string? DurabilityLevel;
        /// <summary>
        /// A `ephemeral_ports` block as defined below.
        /// </summary>
        public readonly ClusterNodeTypesEphemeralPorts EphemeralPorts;
        /// <summary>
        /// The Port used for the HTTP Endpoint for this Node Type. Changing this forces a new resource to be created.
        /// </summary>
        public readonly int HttpEndpointPort;
        /// <summary>
        /// The number of nodes for this Node Type.
        /// </summary>
        public readonly int InstanceCount;
        /// <summary>
        /// Is this the Primary Node Type? Changing this forces a new resource to be created.
        /// </summary>
        public readonly bool IsPrimary;
        /// <summary>
        /// The name of the Node Type. Changing this forces a new resource to be created.
        /// </summary>
        public readonly string Name;
        /// <summary>
        /// The placement tags applied to nodes in the node type, which can be used to indicate where certain services (workload) should run.
        /// </summary>
        public readonly ImmutableDictionary<string, string>? PlacementProperties;
        /// <summary>
        /// The Port used for the Reverse Proxy Endpoint  for this Node Type. Changing this will upgrade the cluster.
        /// </summary>
        public readonly int? ReverseProxyEndpointPort;

        [OutputConstructor]
        private ClusterNodeTypes(
            ClusterNodeTypesApplicationPorts applicationPorts,
            ImmutableDictionary<string, string>? capacities,
            int clientEndpointPort,
            string? durabilityLevel,
            ClusterNodeTypesEphemeralPorts ephemeralPorts,
            int httpEndpointPort,
            int instanceCount,
            bool isPrimary,
            string name,
            ImmutableDictionary<string, string>? placementProperties,
            int? reverseProxyEndpointPort)
        {
            ApplicationPorts = applicationPorts;
            Capacities = capacities;
            ClientEndpointPort = clientEndpointPort;
            DurabilityLevel = durabilityLevel;
            EphemeralPorts = ephemeralPorts;
            HttpEndpointPort = httpEndpointPort;
            InstanceCount = instanceCount;
            IsPrimary = isPrimary;
            Name = name;
            PlacementProperties = placementProperties;
            ReverseProxyEndpointPort = reverseProxyEndpointPort;
        }
    }

    [OutputType]
    public sealed class ClusterNodeTypesApplicationPorts
    {
        /// <summary>
        /// The end of the Application Port Range on this Node Type.
        /// </summary>
        public readonly int EndPort;
        /// <summary>
        /// The start of the Application Port Range on this Node Type.
        /// </summary>
        public readonly int StartPort;

        [OutputConstructor]
        private ClusterNodeTypesApplicationPorts(
            int endPort,
            int startPort)
        {
            EndPort = endPort;
            StartPort = startPort;
        }
    }

    [OutputType]
    public sealed class ClusterNodeTypesEphemeralPorts
    {
        /// <summary>
        /// The end of the Ephemeral Port Range on this Node Type.
        /// </summary>
        public readonly int EndPort;
        /// <summary>
        /// The start of the Ephemeral Port Range on this Node Type.
        /// </summary>
        public readonly int StartPort;

        [OutputConstructor]
        private ClusterNodeTypesEphemeralPorts(
            int endPort,
            int startPort)
        {
            EndPort = endPort;
            StartPort = startPort;
        }
    }

    [OutputType]
    public sealed class ClusterReverseProxyCertificate
    {
        /// <summary>
        /// The Thumbprint of the Certificate.
        /// </summary>
        public readonly string Thumbprint;
        /// <summary>
        /// The Secondary Thumbprint of the Certificate.
        /// </summary>
        public readonly string? ThumbprintSecondary;
        /// <summary>
        /// The X509 Store where the Certificate Exists, such as `My`.
        /// </summary>
        public readonly string X509StoreName;

        [OutputConstructor]
        private ClusterReverseProxyCertificate(
            string thumbprint,
            string? thumbprintSecondary,
            string x509StoreName)
        {
            Thumbprint = thumbprint;
            ThumbprintSecondary = thumbprintSecondary;
            X509StoreName = x509StoreName;
        }
    }
    }
}
