// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Azure.AppService.Inputs
{

    public sealed class LinuxFunctionAppSlotSiteConfigGetArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// If this Linux Web App is Always On enabled. Defaults to `false`.
        /// </summary>
        [Input("alwaysOn")]
        public Input<bool>? AlwaysOn { get; set; }

        /// <summary>
        /// The URL of the API definition that describes this Linux Function App.
        /// </summary>
        [Input("apiDefinitionUrl")]
        public Input<string>? ApiDefinitionUrl { get; set; }

        /// <summary>
        /// The ID of the API Management API for this Linux Function App.
        /// </summary>
        [Input("apiManagementApiId")]
        public Input<string>? ApiManagementApiId { get; set; }

        /// <summary>
        /// The program and any arguments used to launch this app via the command line. (Example `node myapp.js`).
        /// </summary>
        [Input("appCommandLine")]
        public Input<string>? AppCommandLine { get; set; }

        /// <summary>
        /// The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
        /// </summary>
        [Input("appScaleLimit")]
        public Input<int>? AppScaleLimit { get; set; }

        /// <summary>
        /// an `app_service_logs` block as detailed below.
        /// </summary>
        [Input("appServiceLogs")]
        public Input<Inputs.LinuxFunctionAppSlotSiteConfigAppServiceLogsGetArgs>? AppServiceLogs { get; set; }

        [Input("applicationInsightsConnectionString")]
        private Input<string>? _applicationInsightsConnectionString;

        /// <summary>
        /// The Connection String for linking the Linux Function App to Application Insights.
        /// </summary>
        public Input<string>? ApplicationInsightsConnectionString
        {
            get => _applicationInsightsConnectionString;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _applicationInsightsConnectionString = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        [Input("applicationInsightsKey")]
        private Input<string>? _applicationInsightsKey;

        /// <summary>
        /// The Instrumentation Key for connecting the Linux Function App to Application Insights.
        /// </summary>
        public Input<string>? ApplicationInsightsKey
        {
            get => _applicationInsightsKey;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _applicationInsightsKey = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        /// <summary>
        /// an `application_stack` block as detailed below.
        /// </summary>
        [Input("applicationStack")]
        public Input<Inputs.LinuxFunctionAppSlotSiteConfigApplicationStackGetArgs>? ApplicationStack { get; set; }

        /// <summary>
        /// The name of the slot to automatically swap with when this slot is successfully deployed.
        /// </summary>
        [Input("autoSwapSlotName")]
        public Input<string>? AutoSwapSlotName { get; set; }

        /// <summary>
        /// The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
        /// </summary>
        [Input("containerRegistryManagedIdentityClientId")]
        public Input<string>? ContainerRegistryManagedIdentityClientId { get; set; }

        /// <summary>
        /// Should connections for Azure Container Registry use Managed Identity.
        /// </summary>
        [Input("containerRegistryUseManagedIdentity")]
        public Input<bool>? ContainerRegistryUseManagedIdentity { get; set; }

        /// <summary>
        /// a `cors` block as detailed below.
        /// </summary>
        [Input("cors")]
        public Input<Inputs.LinuxFunctionAppSlotSiteConfigCorsGetArgs>? Cors { get; set; }

        [Input("defaultDocuments")]
        private InputList<string>? _defaultDocuments;

        /// <summary>
        /// Specifies a list of Default Documents for the Linux Web App.
        /// </summary>
        public InputList<string> DefaultDocuments
        {
            get => _defaultDocuments ?? (_defaultDocuments = new InputList<string>());
            set => _defaultDocuments = value;
        }

        /// <summary>
        /// Is detailed error logging enabled
        /// </summary>
        [Input("detailedErrorLoggingEnabled")]
        public Input<bool>? DetailedErrorLoggingEnabled { get; set; }

        /// <summary>
        /// The number of minimum instances for this Linux Function App. Only affects apps on Elastic Premium plans.
        /// </summary>
        [Input("elasticInstanceMinimum")]
        public Input<int>? ElasticInstanceMinimum { get; set; }

        /// <summary>
        /// State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`. Defaults to `Disabled`.
        /// </summary>
        [Input("ftpsState")]
        public Input<string>? FtpsState { get; set; }

        /// <summary>
        /// The amount of time in minutes that a node is unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Defaults to `0`. Only valid in conjunction with `health_check_path`.
        /// </summary>
        [Input("healthCheckEvictionTimeInMin")]
        public Input<int>? HealthCheckEvictionTimeInMin { get; set; }

        /// <summary>
        /// The path to be checked for this function app health.
        /// </summary>
        [Input("healthCheckPath")]
        public Input<string>? HealthCheckPath { get; set; }

        /// <summary>
        /// Specifies if the HTTP2 protocol should be enabled. Defaults to `false`.
        /// </summary>
        [Input("http2Enabled")]
        public Input<bool>? Http2Enabled { get; set; }

        /// <summary>
        /// The Default action for traffic that does not match any `ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        /// </summary>
        [Input("ipRestrictionDefaultAction")]
        public Input<string>? IpRestrictionDefaultAction { get; set; }

        [Input("ipRestrictions")]
        private InputList<Inputs.LinuxFunctionAppSlotSiteConfigIpRestrictionGetArgs>? _ipRestrictions;

        /// <summary>
        /// an `ip_restriction` block as detailed below.
        /// </summary>
        public InputList<Inputs.LinuxFunctionAppSlotSiteConfigIpRestrictionGetArgs> IpRestrictions
        {
            get => _ipRestrictions ?? (_ipRestrictions = new InputList<Inputs.LinuxFunctionAppSlotSiteConfigIpRestrictionGetArgs>());
            set => _ipRestrictions = value;
        }

        /// <summary>
        /// The Linux FX Version
        /// </summary>
        [Input("linuxFxVersion")]
        public Input<string>? LinuxFxVersion { get; set; }

        /// <summary>
        /// The Site load balancing mode. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        /// </summary>
        [Input("loadBalancingMode")]
        public Input<string>? LoadBalancingMode { get; set; }

        /// <summary>
        /// The Managed Pipeline mode. Possible values include: `Integrated`, `Classic`. Defaults to `Integrated`.
        /// </summary>
        [Input("managedPipelineMode")]
        public Input<string>? ManagedPipelineMode { get; set; }

        /// <summary>
        /// The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, `1.2` and `1.3`. Defaults to `1.2`.
        /// </summary>
        [Input("minimumTlsVersion")]
        public Input<string>? MinimumTlsVersion { get; set; }

        /// <summary>
        /// The number of pre-warmed instances for this function app. Only affects apps on an Elastic Premium plan.
        /// </summary>
        [Input("preWarmedInstanceCount")]
        public Input<int>? PreWarmedInstanceCount { get; set; }

        /// <summary>
        /// Should Remote Debugging be enabled. Defaults to `false`.
        /// </summary>
        [Input("remoteDebuggingEnabled")]
        public Input<bool>? RemoteDebuggingEnabled { get; set; }

        /// <summary>
        /// The Remote Debugging Version. Currently only `VS2022` is supported.
        /// </summary>
        [Input("remoteDebuggingVersion")]
        public Input<string>? RemoteDebuggingVersion { get; set; }

        /// <summary>
        /// Should Functions Runtime Scale Monitoring be enabled.
        /// 
        /// &gt; **Note:** Functions runtime scale monitoring can only be enabled for Elastic Premium Function Apps or Workflow Standard Logic Apps and requires a minimum prewarmed instance count of 1.
        /// </summary>
        [Input("runtimeScaleMonitoringEnabled")]
        public Input<bool>? RuntimeScaleMonitoringEnabled { get; set; }

        /// <summary>
        /// The Default action for traffic that does not match any `scm_ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        /// </summary>
        [Input("scmIpRestrictionDefaultAction")]
        public Input<string>? ScmIpRestrictionDefaultAction { get; set; }

        [Input("scmIpRestrictions")]
        private InputList<Inputs.LinuxFunctionAppSlotSiteConfigScmIpRestrictionGetArgs>? _scmIpRestrictions;

        /// <summary>
        /// a `scm_ip_restriction` block as detailed below.
        /// </summary>
        public InputList<Inputs.LinuxFunctionAppSlotSiteConfigScmIpRestrictionGetArgs> ScmIpRestrictions
        {
            get => _scmIpRestrictions ?? (_scmIpRestrictions = new InputList<Inputs.LinuxFunctionAppSlotSiteConfigScmIpRestrictionGetArgs>());
            set => _scmIpRestrictions = value;
        }

        /// <summary>
        /// Configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, `1.2` and `1.3`. Defaults to `1.2`.
        /// </summary>
        [Input("scmMinimumTlsVersion")]
        public Input<string>? ScmMinimumTlsVersion { get; set; }

        /// <summary>
        /// The SCM Type in use by the Linux Function App.
        /// </summary>
        [Input("scmType")]
        public Input<string>? ScmType { get; set; }

        /// <summary>
        /// Should the Linux Function App `ip_restriction` configuration be used for the SCM also.
        /// </summary>
        [Input("scmUseMainIpRestriction")]
        public Input<bool>? ScmUseMainIpRestriction { get; set; }

        /// <summary>
        /// Should the Linux Web App use a 32-bit worker.
        /// </summary>
        [Input("use32BitWorker")]
        public Input<bool>? Use32BitWorker { get; set; }

        /// <summary>
        /// Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        /// </summary>
        [Input("vnetRouteAllEnabled")]
        public Input<bool>? VnetRouteAllEnabled { get; set; }

        /// <summary>
        /// Should Web Sockets be enabled. Defaults to `false`.
        /// </summary>
        [Input("websocketsEnabled")]
        public Input<bool>? WebsocketsEnabled { get; set; }

        /// <summary>
        /// The number of Workers for this Linux Function App.
        /// </summary>
        [Input("workerCount")]
        public Input<int>? WorkerCount { get; set; }

        public LinuxFunctionAppSlotSiteConfigGetArgs()
        {
        }
        public static new LinuxFunctionAppSlotSiteConfigGetArgs Empty => new LinuxFunctionAppSlotSiteConfigGetArgs();
    }
}
