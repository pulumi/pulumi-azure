// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Azure.AppService.Inputs
{

    public sealed class LinuxWebAppAuthSettingsV2LoginArgs : global::Pulumi.ResourceArgs
    {
        [Input("allowedExternalRedirectUrls")]
        private InputList<string>? _allowedExternalRedirectUrls;

        /// <summary>
        /// External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends.
        /// 
        /// &gt; **Note:** URLs within the current domain are always implicitly allowed.
        /// </summary>
        public InputList<string> AllowedExternalRedirectUrls
        {
            get => _allowedExternalRedirectUrls ?? (_allowedExternalRedirectUrls = new InputList<string>());
            set => _allowedExternalRedirectUrls = value;
        }

        /// <summary>
        /// The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
        /// </summary>
        [Input("cookieExpirationConvention")]
        public Input<string>? CookieExpirationConvention { get; set; }

        /// <summary>
        /// The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
        /// </summary>
        [Input("cookieExpirationTime")]
        public Input<string>? CookieExpirationTime { get; set; }

        /// <summary>
        /// The endpoint to which logout requests should be made.
        /// </summary>
        [Input("logoutEndpoint")]
        public Input<string>? LogoutEndpoint { get; set; }

        /// <summary>
        /// The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
        /// </summary>
        [Input("nonceExpirationTime")]
        public Input<string>? NonceExpirationTime { get; set; }

        /// <summary>
        /// Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
        /// </summary>
        [Input("preserveUrlFragmentsForLogins")]
        public Input<bool>? PreserveUrlFragmentsForLogins { get; set; }

        /// <summary>
        /// The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        /// </summary>
        [Input("tokenRefreshExtensionTime")]
        public Input<double>? TokenRefreshExtensionTime { get; set; }

        /// <summary>
        /// Should the Token Store configuration Enabled. Defaults to `false`
        /// </summary>
        [Input("tokenStoreEnabled")]
        public Input<bool>? TokenStoreEnabled { get; set; }

        /// <summary>
        /// The directory path in the App Filesystem in which the tokens will be stored.
        /// </summary>
        [Input("tokenStorePath")]
        public Input<string>? TokenStorePath { get; set; }

        /// <summary>
        /// The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        /// </summary>
        [Input("tokenStoreSasSettingName")]
        public Input<string>? TokenStoreSasSettingName { get; set; }

        /// <summary>
        /// Should the nonce be validated while completing the login flow. Defaults to `true`.
        /// </summary>
        [Input("validateNonce")]
        public Input<bool>? ValidateNonce { get; set; }

        public LinuxWebAppAuthSettingsV2LoginArgs()
        {
        }
        public static new LinuxWebAppAuthSettingsV2LoginArgs Empty => new LinuxWebAppAuthSettingsV2LoginArgs();
    }
}
