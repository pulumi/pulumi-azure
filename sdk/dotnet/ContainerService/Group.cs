// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Azure.ContainerService
{
    /// <summary>
    /// Manages as an Azure Container Group instance.
    /// 
    /// ## Example Usage
    /// 
    /// This example provisions a Basic Container.
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Azure = Pulumi.Azure;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var example = new Azure.Core.ResourceGroup("example", new()
    ///     {
    ///         Name = "example-resources",
    ///         Location = "West Europe",
    ///     });
    /// 
    ///     var exampleGroup = new Azure.ContainerService.Group("example", new()
    ///     {
    ///         Name = "example-continst",
    ///         Location = example.Location,
    ///         ResourceGroupName = example.Name,
    ///         IpAddressType = "Public",
    ///         DnsNameLabel = "aci-label",
    ///         OsType = "Linux",
    ///         Containers = new[]
    ///         {
    ///             new Azure.ContainerService.Inputs.GroupContainerArgs
    ///             {
    ///                 Name = "hello-world",
    ///                 Image = "mcr.microsoft.com/azuredocs/aci-helloworld:latest",
    ///                 Cpu = 0.5,
    ///                 Memory = 1.5,
    ///                 Ports = new[]
    ///                 {
    ///                     new Azure.ContainerService.Inputs.GroupContainerPortArgs
    ///                     {
    ///                         Port = 443,
    ///                         Protocol = "TCP",
    ///                     },
    ///                 },
    ///             },
    ///             new Azure.ContainerService.Inputs.GroupContainerArgs
    ///             {
    ///                 Name = "sidecar",
    ///                 Image = "mcr.microsoft.com/azuredocs/aci-tutorial-sidecar",
    ///                 Cpu = 0.5,
    ///                 Memory = 1.5,
    ///             },
    ///         },
    ///         Tags = 
    ///         {
    ///             { "environment", "testing" },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## API Providers
    /// 
    /// &lt;!-- This section is generated, changes will be overwritten --&gt;
    /// This resource uses the following Azure API Providers:
    /// 
    /// * `Microsoft.ContainerInstance`: 2023-05-01
    /// 
    /// ## Import
    /// 
    /// Container Group's can be imported using the `resource id`, e.g.
    /// 
    /// ```sh
    /// $ pulumi import azure:containerservice/group:Group containerGroup1 /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/mygroup1/providers/Microsoft.ContainerInstance/containerGroups/myContainerGroup1
    /// ```
    /// </summary>
    [AzureResourceType("azure:containerservice/group:Group")]
    public partial class Group : global::Pulumi.CustomResource
    {
        /// <summary>
        /// The definition of a container that is part of the group as documented in the `container` block below. Changing this forces a new resource to be created.
        /// </summary>
        [Output("containers")]
        public Output<ImmutableArray<Outputs.GroupContainer>> Containers { get; private set; } = null!;

        /// <summary>
        /// A `diagnostics` block as documented below. Changing this forces a new resource to be created.
        /// </summary>
        [Output("diagnostics")]
        public Output<Outputs.GroupDiagnostics?> Diagnostics { get; private set; } = null!;

        /// <summary>
        /// A `dns_config` block as documented below. Changing this forces a new resource to be created.
        /// </summary>
        [Output("dnsConfig")]
        public Output<Outputs.GroupDnsConfig?> DnsConfig { get; private set; } = null!;

        /// <summary>
        /// The DNS label/name for the container group's IP. Changing this forces a new resource to be created.
        /// 
        /// &gt; **Note:** DNS label/name is not supported when deploying to virtual networks.
        /// </summary>
        [Output("dnsNameLabel")]
        public Output<string?> DnsNameLabel { get; private set; } = null!;

        /// <summary>
        /// The value representing the security enum. `Noreuse`, `ResourceGroupReuse`, `SubscriptionReuse`, `TenantReuse` or `Unsecure`. Defaults to `Unsecure`. Changing this forces a new resource to be created.
        /// </summary>
        [Output("dnsNameLabelReusePolicy")]
        public Output<string?> DnsNameLabelReusePolicy { get; private set; } = null!;

        /// <summary>
        /// Zero or more `exposed_port` blocks as defined below. Changing this forces a new resource to be created.
        /// 
        /// &gt; **Note:** The `exposed_port` can only contain ports that are also exposed on one or more containers in the group.
        /// </summary>
        [Output("exposedPorts")]
        public Output<ImmutableArray<Outputs.GroupExposedPort>> ExposedPorts { get; private set; } = null!;

        /// <summary>
        /// The FQDN of the container group derived from `dns_name_label`.
        /// </summary>
        [Output("fqdn")]
        public Output<string> Fqdn { get; private set; } = null!;

        /// <summary>
        /// An `identity` block as defined below.
        /// </summary>
        [Output("identity")]
        public Output<Outputs.GroupIdentity?> Identity { get; private set; } = null!;

        /// <summary>
        /// An `image_registry_credential` block as documented below. Changing this forces a new resource to be created.
        /// </summary>
        [Output("imageRegistryCredentials")]
        public Output<ImmutableArray<Outputs.GroupImageRegistryCredential>> ImageRegistryCredentials { get; private set; } = null!;

        /// <summary>
        /// The definition of an init container that is part of the group as documented in the `init_container` block below. Changing this forces a new resource to be created.
        /// </summary>
        [Output("initContainers")]
        public Output<ImmutableArray<Outputs.GroupInitContainer>> InitContainers { get; private set; } = null!;

        /// <summary>
        /// The IP address allocated to the container group.
        /// </summary>
        [Output("ipAddress")]
        public Output<string> IpAddress { get; private set; } = null!;

        /// <summary>
        /// Specifies the IP address type of the container. `Public`, `Private` or `None`. Changing this forces a new resource to be created. If set to `Private`, `subnet_ids` also needs to be set. Defaults to `Public`.
        /// 
        /// &gt; **Note:** `dns_name_label` and `os_type` set to `windows` are not compatible with `Private` `ip_address_type`
        /// </summary>
        [Output("ipAddressType")]
        public Output<string?> IpAddressType { get; private set; } = null!;

        /// <summary>
        /// The Key Vault key URI for CMK encryption. Changing this forces a new resource to be created.
        /// </summary>
        [Output("keyVaultKeyId")]
        public Output<string?> KeyVaultKeyId { get; private set; } = null!;

        /// <summary>
        /// The user assigned identity that has access to the Key Vault Key. If not specified, the RP principal named "Azure Container Instance Service" will be used instead. Make sure the identity has the proper `key_permissions` set, at least with `Get`, `UnwrapKey`, `WrapKey` and `GetRotationPolicy`.
        /// </summary>
        [Output("keyVaultUserAssignedIdentityId")]
        public Output<string?> KeyVaultUserAssignedIdentityId { get; private set; } = null!;

        /// <summary>
        /// Specifies the supported Azure location where the resource exists. Changing this forces a new resource to be created.
        /// </summary>
        [Output("location")]
        public Output<string> Location { get; private set; } = null!;

        /// <summary>
        /// Specifies the name of the Container Group. Changing this forces a new resource to be created.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        [Output("networkProfileId")]
        public Output<string> NetworkProfileId { get; private set; } = null!;

        /// <summary>
        /// The OS for the container group. Allowed values are `Linux` and `Windows`. Changing this forces a new resource to be created.
        /// 
        /// &gt; **Note:** if `os_type` is set to `Windows` currently only a single `container` block is supported. Windows containers are not supported in virtual networks.
        /// </summary>
        [Output("osType")]
        public Output<string> OsType { get; private set; } = null!;

        /// <summary>
        /// The priority of the Container Group. Possible values are `Regular` and `Spot`. Changing this forces a new resource to be created.
        /// 
        /// &gt; **Note:** When `priority` is set to `Spot`, the `ip_address_type` has to be `None`.
        /// </summary>
        [Output("priority")]
        public Output<string?> Priority { get; private set; } = null!;

        /// <summary>
        /// The name of the resource group in which to create the Container Group. Changing this forces a new resource to be created.
        /// </summary>
        [Output("resourceGroupName")]
        public Output<string> ResourceGroupName { get; private set; } = null!;

        /// <summary>
        /// Restart policy for the container group. Allowed values are `Always`, `Never`, `OnFailure`. Defaults to `Always`. Changing this forces a new resource to be created.
        /// </summary>
        [Output("restartPolicy")]
        public Output<string?> RestartPolicy { get; private set; } = null!;

        /// <summary>
        /// Specifies the sku of the Container Group. Possible values are `Confidential`, `Dedicated` and `Standard`. Defaults to `Standard`. Changing this forces a new resource to be created.
        /// </summary>
        [Output("sku")]
        public Output<string?> Sku { get; private set; } = null!;

        /// <summary>
        /// The subnet resource IDs for a container group. Changing this forces a new resource to be created.
        /// </summary>
        [Output("subnetIds")]
        public Output<string?> SubnetIds { get; private set; } = null!;

        /// <summary>
        /// A mapping of tags to assign to the resource.
        /// </summary>
        [Output("tags")]
        public Output<ImmutableDictionary<string, string>?> Tags { get; private set; } = null!;

        /// <summary>
        /// A list of Availability Zones in which this Container Group is located. Changing this forces a new resource to be created.
        /// </summary>
        [Output("zones")]
        public Output<ImmutableArray<string>> Zones { get; private set; } = null!;


        /// <summary>
        /// Create a Group resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public Group(string name, GroupArgs args, CustomResourceOptions? options = null)
            : base("azure:containerservice/group:Group", name, args ?? new GroupArgs(), MakeResourceOptions(options, ""))
        {
        }

        private Group(string name, Input<string> id, GroupState? state = null, CustomResourceOptions? options = null)
            : base("azure:containerservice/group:Group", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing Group resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static Group Get(string name, Input<string> id, GroupState? state = null, CustomResourceOptions? options = null)
        {
            return new Group(name, id, state, options);
        }
    }

    public sealed class GroupArgs : global::Pulumi.ResourceArgs
    {
        [Input("containers", required: true)]
        private InputList<Inputs.GroupContainerArgs>? _containers;

        /// <summary>
        /// The definition of a container that is part of the group as documented in the `container` block below. Changing this forces a new resource to be created.
        /// </summary>
        public InputList<Inputs.GroupContainerArgs> Containers
        {
            get => _containers ?? (_containers = new InputList<Inputs.GroupContainerArgs>());
            set => _containers = value;
        }

        /// <summary>
        /// A `diagnostics` block as documented below. Changing this forces a new resource to be created.
        /// </summary>
        [Input("diagnostics")]
        public Input<Inputs.GroupDiagnosticsArgs>? Diagnostics { get; set; }

        /// <summary>
        /// A `dns_config` block as documented below. Changing this forces a new resource to be created.
        /// </summary>
        [Input("dnsConfig")]
        public Input<Inputs.GroupDnsConfigArgs>? DnsConfig { get; set; }

        /// <summary>
        /// The DNS label/name for the container group's IP. Changing this forces a new resource to be created.
        /// 
        /// &gt; **Note:** DNS label/name is not supported when deploying to virtual networks.
        /// </summary>
        [Input("dnsNameLabel")]
        public Input<string>? DnsNameLabel { get; set; }

        /// <summary>
        /// The value representing the security enum. `Noreuse`, `ResourceGroupReuse`, `SubscriptionReuse`, `TenantReuse` or `Unsecure`. Defaults to `Unsecure`. Changing this forces a new resource to be created.
        /// </summary>
        [Input("dnsNameLabelReusePolicy")]
        public Input<string>? DnsNameLabelReusePolicy { get; set; }

        [Input("exposedPorts")]
        private InputList<Inputs.GroupExposedPortArgs>? _exposedPorts;

        /// <summary>
        /// Zero or more `exposed_port` blocks as defined below. Changing this forces a new resource to be created.
        /// 
        /// &gt; **Note:** The `exposed_port` can only contain ports that are also exposed on one or more containers in the group.
        /// </summary>
        public InputList<Inputs.GroupExposedPortArgs> ExposedPorts
        {
            get => _exposedPorts ?? (_exposedPorts = new InputList<Inputs.GroupExposedPortArgs>());
            set => _exposedPorts = value;
        }

        /// <summary>
        /// An `identity` block as defined below.
        /// </summary>
        [Input("identity")]
        public Input<Inputs.GroupIdentityArgs>? Identity { get; set; }

        [Input("imageRegistryCredentials")]
        private InputList<Inputs.GroupImageRegistryCredentialArgs>? _imageRegistryCredentials;

        /// <summary>
        /// An `image_registry_credential` block as documented below. Changing this forces a new resource to be created.
        /// </summary>
        public InputList<Inputs.GroupImageRegistryCredentialArgs> ImageRegistryCredentials
        {
            get => _imageRegistryCredentials ?? (_imageRegistryCredentials = new InputList<Inputs.GroupImageRegistryCredentialArgs>());
            set => _imageRegistryCredentials = value;
        }

        [Input("initContainers")]
        private InputList<Inputs.GroupInitContainerArgs>? _initContainers;

        /// <summary>
        /// The definition of an init container that is part of the group as documented in the `init_container` block below. Changing this forces a new resource to be created.
        /// </summary>
        public InputList<Inputs.GroupInitContainerArgs> InitContainers
        {
            get => _initContainers ?? (_initContainers = new InputList<Inputs.GroupInitContainerArgs>());
            set => _initContainers = value;
        }

        /// <summary>
        /// Specifies the IP address type of the container. `Public`, `Private` or `None`. Changing this forces a new resource to be created. If set to `Private`, `subnet_ids` also needs to be set. Defaults to `Public`.
        /// 
        /// &gt; **Note:** `dns_name_label` and `os_type` set to `windows` are not compatible with `Private` `ip_address_type`
        /// </summary>
        [Input("ipAddressType")]
        public Input<string>? IpAddressType { get; set; }

        /// <summary>
        /// The Key Vault key URI for CMK encryption. Changing this forces a new resource to be created.
        /// </summary>
        [Input("keyVaultKeyId")]
        public Input<string>? KeyVaultKeyId { get; set; }

        /// <summary>
        /// The user assigned identity that has access to the Key Vault Key. If not specified, the RP principal named "Azure Container Instance Service" will be used instead. Make sure the identity has the proper `key_permissions` set, at least with `Get`, `UnwrapKey`, `WrapKey` and `GetRotationPolicy`.
        /// </summary>
        [Input("keyVaultUserAssignedIdentityId")]
        public Input<string>? KeyVaultUserAssignedIdentityId { get; set; }

        /// <summary>
        /// Specifies the supported Azure location where the resource exists. Changing this forces a new resource to be created.
        /// </summary>
        [Input("location")]
        public Input<string>? Location { get; set; }

        /// <summary>
        /// Specifies the name of the Container Group. Changing this forces a new resource to be created.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("networkProfileId")]
        public Input<string>? NetworkProfileId { get; set; }

        /// <summary>
        /// The OS for the container group. Allowed values are `Linux` and `Windows`. Changing this forces a new resource to be created.
        /// 
        /// &gt; **Note:** if `os_type` is set to `Windows` currently only a single `container` block is supported. Windows containers are not supported in virtual networks.
        /// </summary>
        [Input("osType", required: true)]
        public Input<string> OsType { get; set; } = null!;

        /// <summary>
        /// The priority of the Container Group. Possible values are `Regular` and `Spot`. Changing this forces a new resource to be created.
        /// 
        /// &gt; **Note:** When `priority` is set to `Spot`, the `ip_address_type` has to be `None`.
        /// </summary>
        [Input("priority")]
        public Input<string>? Priority { get; set; }

        /// <summary>
        /// The name of the resource group in which to create the Container Group. Changing this forces a new resource to be created.
        /// </summary>
        [Input("resourceGroupName", required: true)]
        public Input<string> ResourceGroupName { get; set; } = null!;

        /// <summary>
        /// Restart policy for the container group. Allowed values are `Always`, `Never`, `OnFailure`. Defaults to `Always`. Changing this forces a new resource to be created.
        /// </summary>
        [Input("restartPolicy")]
        public Input<string>? RestartPolicy { get; set; }

        /// <summary>
        /// Specifies the sku of the Container Group. Possible values are `Confidential`, `Dedicated` and `Standard`. Defaults to `Standard`. Changing this forces a new resource to be created.
        /// </summary>
        [Input("sku")]
        public Input<string>? Sku { get; set; }

        /// <summary>
        /// The subnet resource IDs for a container group. Changing this forces a new resource to be created.
        /// </summary>
        [Input("subnetIds")]
        public Input<string>? SubnetIds { get; set; }

        [Input("tags")]
        private InputMap<string>? _tags;

        /// <summary>
        /// A mapping of tags to assign to the resource.
        /// </summary>
        public InputMap<string> Tags
        {
            get => _tags ?? (_tags = new InputMap<string>());
            set => _tags = value;
        }

        [Input("zones")]
        private InputList<string>? _zones;

        /// <summary>
        /// A list of Availability Zones in which this Container Group is located. Changing this forces a new resource to be created.
        /// </summary>
        public InputList<string> Zones
        {
            get => _zones ?? (_zones = new InputList<string>());
            set => _zones = value;
        }

        public GroupArgs()
        {
        }
        public static new GroupArgs Empty => new GroupArgs();
    }

    public sealed class GroupState : global::Pulumi.ResourceArgs
    {
        [Input("containers")]
        private InputList<Inputs.GroupContainerGetArgs>? _containers;

        /// <summary>
        /// The definition of a container that is part of the group as documented in the `container` block below. Changing this forces a new resource to be created.
        /// </summary>
        public InputList<Inputs.GroupContainerGetArgs> Containers
        {
            get => _containers ?? (_containers = new InputList<Inputs.GroupContainerGetArgs>());
            set => _containers = value;
        }

        /// <summary>
        /// A `diagnostics` block as documented below. Changing this forces a new resource to be created.
        /// </summary>
        [Input("diagnostics")]
        public Input<Inputs.GroupDiagnosticsGetArgs>? Diagnostics { get; set; }

        /// <summary>
        /// A `dns_config` block as documented below. Changing this forces a new resource to be created.
        /// </summary>
        [Input("dnsConfig")]
        public Input<Inputs.GroupDnsConfigGetArgs>? DnsConfig { get; set; }

        /// <summary>
        /// The DNS label/name for the container group's IP. Changing this forces a new resource to be created.
        /// 
        /// &gt; **Note:** DNS label/name is not supported when deploying to virtual networks.
        /// </summary>
        [Input("dnsNameLabel")]
        public Input<string>? DnsNameLabel { get; set; }

        /// <summary>
        /// The value representing the security enum. `Noreuse`, `ResourceGroupReuse`, `SubscriptionReuse`, `TenantReuse` or `Unsecure`. Defaults to `Unsecure`. Changing this forces a new resource to be created.
        /// </summary>
        [Input("dnsNameLabelReusePolicy")]
        public Input<string>? DnsNameLabelReusePolicy { get; set; }

        [Input("exposedPorts")]
        private InputList<Inputs.GroupExposedPortGetArgs>? _exposedPorts;

        /// <summary>
        /// Zero or more `exposed_port` blocks as defined below. Changing this forces a new resource to be created.
        /// 
        /// &gt; **Note:** The `exposed_port` can only contain ports that are also exposed on one or more containers in the group.
        /// </summary>
        public InputList<Inputs.GroupExposedPortGetArgs> ExposedPorts
        {
            get => _exposedPorts ?? (_exposedPorts = new InputList<Inputs.GroupExposedPortGetArgs>());
            set => _exposedPorts = value;
        }

        /// <summary>
        /// The FQDN of the container group derived from `dns_name_label`.
        /// </summary>
        [Input("fqdn")]
        public Input<string>? Fqdn { get; set; }

        /// <summary>
        /// An `identity` block as defined below.
        /// </summary>
        [Input("identity")]
        public Input<Inputs.GroupIdentityGetArgs>? Identity { get; set; }

        [Input("imageRegistryCredentials")]
        private InputList<Inputs.GroupImageRegistryCredentialGetArgs>? _imageRegistryCredentials;

        /// <summary>
        /// An `image_registry_credential` block as documented below. Changing this forces a new resource to be created.
        /// </summary>
        public InputList<Inputs.GroupImageRegistryCredentialGetArgs> ImageRegistryCredentials
        {
            get => _imageRegistryCredentials ?? (_imageRegistryCredentials = new InputList<Inputs.GroupImageRegistryCredentialGetArgs>());
            set => _imageRegistryCredentials = value;
        }

        [Input("initContainers")]
        private InputList<Inputs.GroupInitContainerGetArgs>? _initContainers;

        /// <summary>
        /// The definition of an init container that is part of the group as documented in the `init_container` block below. Changing this forces a new resource to be created.
        /// </summary>
        public InputList<Inputs.GroupInitContainerGetArgs> InitContainers
        {
            get => _initContainers ?? (_initContainers = new InputList<Inputs.GroupInitContainerGetArgs>());
            set => _initContainers = value;
        }

        /// <summary>
        /// The IP address allocated to the container group.
        /// </summary>
        [Input("ipAddress")]
        public Input<string>? IpAddress { get; set; }

        /// <summary>
        /// Specifies the IP address type of the container. `Public`, `Private` or `None`. Changing this forces a new resource to be created. If set to `Private`, `subnet_ids` also needs to be set. Defaults to `Public`.
        /// 
        /// &gt; **Note:** `dns_name_label` and `os_type` set to `windows` are not compatible with `Private` `ip_address_type`
        /// </summary>
        [Input("ipAddressType")]
        public Input<string>? IpAddressType { get; set; }

        /// <summary>
        /// The Key Vault key URI for CMK encryption. Changing this forces a new resource to be created.
        /// </summary>
        [Input("keyVaultKeyId")]
        public Input<string>? KeyVaultKeyId { get; set; }

        /// <summary>
        /// The user assigned identity that has access to the Key Vault Key. If not specified, the RP principal named "Azure Container Instance Service" will be used instead. Make sure the identity has the proper `key_permissions` set, at least with `Get`, `UnwrapKey`, `WrapKey` and `GetRotationPolicy`.
        /// </summary>
        [Input("keyVaultUserAssignedIdentityId")]
        public Input<string>? KeyVaultUserAssignedIdentityId { get; set; }

        /// <summary>
        /// Specifies the supported Azure location where the resource exists. Changing this forces a new resource to be created.
        /// </summary>
        [Input("location")]
        public Input<string>? Location { get; set; }

        /// <summary>
        /// Specifies the name of the Container Group. Changing this forces a new resource to be created.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("networkProfileId")]
        public Input<string>? NetworkProfileId { get; set; }

        /// <summary>
        /// The OS for the container group. Allowed values are `Linux` and `Windows`. Changing this forces a new resource to be created.
        /// 
        /// &gt; **Note:** if `os_type` is set to `Windows` currently only a single `container` block is supported. Windows containers are not supported in virtual networks.
        /// </summary>
        [Input("osType")]
        public Input<string>? OsType { get; set; }

        /// <summary>
        /// The priority of the Container Group. Possible values are `Regular` and `Spot`. Changing this forces a new resource to be created.
        /// 
        /// &gt; **Note:** When `priority` is set to `Spot`, the `ip_address_type` has to be `None`.
        /// </summary>
        [Input("priority")]
        public Input<string>? Priority { get; set; }

        /// <summary>
        /// The name of the resource group in which to create the Container Group. Changing this forces a new resource to be created.
        /// </summary>
        [Input("resourceGroupName")]
        public Input<string>? ResourceGroupName { get; set; }

        /// <summary>
        /// Restart policy for the container group. Allowed values are `Always`, `Never`, `OnFailure`. Defaults to `Always`. Changing this forces a new resource to be created.
        /// </summary>
        [Input("restartPolicy")]
        public Input<string>? RestartPolicy { get; set; }

        /// <summary>
        /// Specifies the sku of the Container Group. Possible values are `Confidential`, `Dedicated` and `Standard`. Defaults to `Standard`. Changing this forces a new resource to be created.
        /// </summary>
        [Input("sku")]
        public Input<string>? Sku { get; set; }

        /// <summary>
        /// The subnet resource IDs for a container group. Changing this forces a new resource to be created.
        /// </summary>
        [Input("subnetIds")]
        public Input<string>? SubnetIds { get; set; }

        [Input("tags")]
        private InputMap<string>? _tags;

        /// <summary>
        /// A mapping of tags to assign to the resource.
        /// </summary>
        public InputMap<string> Tags
        {
            get => _tags ?? (_tags = new InputMap<string>());
            set => _tags = value;
        }

        [Input("zones")]
        private InputList<string>? _zones;

        /// <summary>
        /// A list of Availability Zones in which this Container Group is located. Changing this forces a new resource to be created.
        /// </summary>
        public InputList<string> Zones
        {
            get => _zones ?? (_zones = new InputList<string>());
            set => _zones = value;
        }

        public GroupState()
        {
        }
        public static new GroupState Empty => new GroupState();
    }
}
