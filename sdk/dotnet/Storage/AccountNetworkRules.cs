// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Azure.Storage
{
    /// <summary>
    /// Manages network rules inside of a Azure Storage Account.
    /// 
    /// &gt; **NOTE:** Network Rules can be defined either directly on the `azure.storage.Account` resource, or using the `azure.storage.AccountNetworkRules` resource - but the two cannot be used together. Spurious changes will occur if both are used against the same Storage Account.
    /// 
    /// &gt; **NOTE:** Only one `azure.storage.AccountNetworkRules` can be tied to an `azure.storage.Account`. Spurious changes will occur if more than `azure.storage.AccountNetworkRules` is tied to the same `azure.storage.Account`.
    /// 
    /// &gt; **NOTE:** Deleting this resource updates the storage account back to the default values it had when the storage account was created.
    /// 
    /// ## Example Usage
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Azure = Pulumi.Azure;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var exampleResourceGroup = new Azure.Core.ResourceGroup("exampleResourceGroup", new()
    ///     {
    ///         Location = "West Europe",
    ///     });
    /// 
    ///     var exampleVirtualNetwork = new Azure.Network.VirtualNetwork("exampleVirtualNetwork", new()
    ///     {
    ///         AddressSpaces = new[]
    ///         {
    ///             "10.0.0.0/16",
    ///         },
    ///         Location = exampleResourceGroup.Location,
    ///         ResourceGroupName = exampleResourceGroup.Name,
    ///     });
    /// 
    ///     var exampleSubnet = new Azure.Network.Subnet("exampleSubnet", new()
    ///     {
    ///         ResourceGroupName = exampleResourceGroup.Name,
    ///         VirtualNetworkName = exampleVirtualNetwork.Name,
    ///         AddressPrefixes = new[]
    ///         {
    ///             "10.0.2.0/24",
    ///         },
    ///         ServiceEndpoints = new[]
    ///         {
    ///             "Microsoft.Storage",
    ///         },
    ///     });
    /// 
    ///     var exampleAccount = new Azure.Storage.Account("exampleAccount", new()
    ///     {
    ///         ResourceGroupName = exampleResourceGroup.Name,
    ///         Location = exampleResourceGroup.Location,
    ///         AccountTier = "Standard",
    ///         AccountReplicationType = "GRS",
    ///         Tags = 
    ///         {
    ///             { "environment", "staging" },
    ///         },
    ///     });
    /// 
    ///     var exampleAccountNetworkRules = new Azure.Storage.AccountNetworkRules("exampleAccountNetworkRules", new()
    ///     {
    ///         StorageAccountId = exampleAccount.Id,
    ///         DefaultAction = "Allow",
    ///         IpRules = new[]
    ///         {
    ///             "127.0.0.1",
    ///         },
    ///         VirtualNetworkSubnetIds = new[]
    ///         {
    ///             exampleSubnet.Id,
    ///         },
    ///         Bypasses = new[]
    ///         {
    ///             "Metrics",
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## Import
    /// 
    /// Storage Account Network Rules can be imported using the `resource id`, e.g.
    /// 
    /// ```sh
    ///  $ pulumi import azure:storage/accountNetworkRules:AccountNetworkRules storageAcc1 /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/myresourcegroup/providers/Microsoft.Storage/storageAccounts/myaccount
    /// ```
    /// </summary>
    [AzureResourceType("azure:storage/accountNetworkRules:AccountNetworkRules")]
    public partial class AccountNetworkRules : global::Pulumi.CustomResource
    {
        /// <summary>
        /// Specifies whether traffic is bypassed for Logging/Metrics/AzureServices. Valid options are any combination of `Logging`, `Metrics`, `AzureServices`, or `None`.
        /// 
        /// &gt; **NOTE** User has to explicitly set `bypass` to empty slice (`[]`) to remove it.
        /// </summary>
        [Output("bypasses")]
        public Output<ImmutableArray<string>> Bypasses { get; private set; } = null!;

        /// <summary>
        /// Specifies the default action of allow or deny when no other rules match. Valid options are `Deny` or `Allow`.
        /// </summary>
        [Output("defaultAction")]
        public Output<string> DefaultAction { get; private set; } = null!;

        /// <summary>
        /// List of public IP or IP ranges in CIDR Format. Only IPv4 addresses are allowed. Private IP address ranges (as defined in [RFC 1918](https://tools.ietf.org/html/rfc1918#section-3)) are not allowed.
        /// 
        /// &gt; **NOTE** Small address ranges using "/31" or "/32" prefix sizes are not supported. These ranges should be configured using individual IP address rules without prefix specified.
        /// 
        /// &gt; **NOTE** IP network rules have no effect on requests originating from the same Azure region as the storage account. Use Virtual network rules to allow same-region requests. Services deployed in the same region as the storage account use private Azure IP addresses for communication. Thus, you cannot restrict access to specific Azure services based on their public outbound IP address range.
        /// 
        /// &gt; **NOTE** User has to explicitly set `ip_rules` to empty slice (`[]`) to remove it.
        /// </summary>
        [Output("ipRules")]
        public Output<ImmutableArray<string>> IpRules { get; private set; } = null!;

        /// <summary>
        /// One or more `private_link_access` block as defined below.
        /// </summary>
        [Output("privateLinkAccessRules")]
        public Output<ImmutableArray<Outputs.AccountNetworkRulesPrivateLinkAccessRule>> PrivateLinkAccessRules { get; private set; } = null!;

        /// <summary>
        /// Specifies the ID of the storage account. Changing this forces a new resource to be created.
        /// </summary>
        [Output("storageAccountId")]
        public Output<string> StorageAccountId { get; private set; } = null!;

        /// <summary>
        /// A list of virtual network subnet ids to secure the storage account.
        /// 
        /// &gt; **NOTE** User has to explicitly set `virtual_network_subnet_ids` to empty slice (`[]`) to remove it.
        /// </summary>
        [Output("virtualNetworkSubnetIds")]
        public Output<ImmutableArray<string>> VirtualNetworkSubnetIds { get; private set; } = null!;


        /// <summary>
        /// Create a AccountNetworkRules resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public AccountNetworkRules(string name, AccountNetworkRulesArgs args, CustomResourceOptions? options = null)
            : base("azure:storage/accountNetworkRules:AccountNetworkRules", name, args ?? new AccountNetworkRulesArgs(), MakeResourceOptions(options, ""))
        {
        }

        private AccountNetworkRules(string name, Input<string> id, AccountNetworkRulesState? state = null, CustomResourceOptions? options = null)
            : base("azure:storage/accountNetworkRules:AccountNetworkRules", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing AccountNetworkRules resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static AccountNetworkRules Get(string name, Input<string> id, AccountNetworkRulesState? state = null, CustomResourceOptions? options = null)
        {
            return new AccountNetworkRules(name, id, state, options);
        }
    }

    public sealed class AccountNetworkRulesArgs : global::Pulumi.ResourceArgs
    {
        [Input("bypasses")]
        private InputList<string>? _bypasses;

        /// <summary>
        /// Specifies whether traffic is bypassed for Logging/Metrics/AzureServices. Valid options are any combination of `Logging`, `Metrics`, `AzureServices`, or `None`.
        /// 
        /// &gt; **NOTE** User has to explicitly set `bypass` to empty slice (`[]`) to remove it.
        /// </summary>
        public InputList<string> Bypasses
        {
            get => _bypasses ?? (_bypasses = new InputList<string>());
            set => _bypasses = value;
        }

        /// <summary>
        /// Specifies the default action of allow or deny when no other rules match. Valid options are `Deny` or `Allow`.
        /// </summary>
        [Input("defaultAction", required: true)]
        public Input<string> DefaultAction { get; set; } = null!;

        [Input("ipRules")]
        private InputList<string>? _ipRules;

        /// <summary>
        /// List of public IP or IP ranges in CIDR Format. Only IPv4 addresses are allowed. Private IP address ranges (as defined in [RFC 1918](https://tools.ietf.org/html/rfc1918#section-3)) are not allowed.
        /// 
        /// &gt; **NOTE** Small address ranges using "/31" or "/32" prefix sizes are not supported. These ranges should be configured using individual IP address rules without prefix specified.
        /// 
        /// &gt; **NOTE** IP network rules have no effect on requests originating from the same Azure region as the storage account. Use Virtual network rules to allow same-region requests. Services deployed in the same region as the storage account use private Azure IP addresses for communication. Thus, you cannot restrict access to specific Azure services based on their public outbound IP address range.
        /// 
        /// &gt; **NOTE** User has to explicitly set `ip_rules` to empty slice (`[]`) to remove it.
        /// </summary>
        public InputList<string> IpRules
        {
            get => _ipRules ?? (_ipRules = new InputList<string>());
            set => _ipRules = value;
        }

        [Input("privateLinkAccessRules")]
        private InputList<Inputs.AccountNetworkRulesPrivateLinkAccessRuleArgs>? _privateLinkAccessRules;

        /// <summary>
        /// One or more `private_link_access` block as defined below.
        /// </summary>
        public InputList<Inputs.AccountNetworkRulesPrivateLinkAccessRuleArgs> PrivateLinkAccessRules
        {
            get => _privateLinkAccessRules ?? (_privateLinkAccessRules = new InputList<Inputs.AccountNetworkRulesPrivateLinkAccessRuleArgs>());
            set => _privateLinkAccessRules = value;
        }

        /// <summary>
        /// Specifies the ID of the storage account. Changing this forces a new resource to be created.
        /// </summary>
        [Input("storageAccountId", required: true)]
        public Input<string> StorageAccountId { get; set; } = null!;

        [Input("virtualNetworkSubnetIds")]
        private InputList<string>? _virtualNetworkSubnetIds;

        /// <summary>
        /// A list of virtual network subnet ids to secure the storage account.
        /// 
        /// &gt; **NOTE** User has to explicitly set `virtual_network_subnet_ids` to empty slice (`[]`) to remove it.
        /// </summary>
        public InputList<string> VirtualNetworkSubnetIds
        {
            get => _virtualNetworkSubnetIds ?? (_virtualNetworkSubnetIds = new InputList<string>());
            set => _virtualNetworkSubnetIds = value;
        }

        public AccountNetworkRulesArgs()
        {
        }
        public static new AccountNetworkRulesArgs Empty => new AccountNetworkRulesArgs();
    }

    public sealed class AccountNetworkRulesState : global::Pulumi.ResourceArgs
    {
        [Input("bypasses")]
        private InputList<string>? _bypasses;

        /// <summary>
        /// Specifies whether traffic is bypassed for Logging/Metrics/AzureServices. Valid options are any combination of `Logging`, `Metrics`, `AzureServices`, or `None`.
        /// 
        /// &gt; **NOTE** User has to explicitly set `bypass` to empty slice (`[]`) to remove it.
        /// </summary>
        public InputList<string> Bypasses
        {
            get => _bypasses ?? (_bypasses = new InputList<string>());
            set => _bypasses = value;
        }

        /// <summary>
        /// Specifies the default action of allow or deny when no other rules match. Valid options are `Deny` or `Allow`.
        /// </summary>
        [Input("defaultAction")]
        public Input<string>? DefaultAction { get; set; }

        [Input("ipRules")]
        private InputList<string>? _ipRules;

        /// <summary>
        /// List of public IP or IP ranges in CIDR Format. Only IPv4 addresses are allowed. Private IP address ranges (as defined in [RFC 1918](https://tools.ietf.org/html/rfc1918#section-3)) are not allowed.
        /// 
        /// &gt; **NOTE** Small address ranges using "/31" or "/32" prefix sizes are not supported. These ranges should be configured using individual IP address rules without prefix specified.
        /// 
        /// &gt; **NOTE** IP network rules have no effect on requests originating from the same Azure region as the storage account. Use Virtual network rules to allow same-region requests. Services deployed in the same region as the storage account use private Azure IP addresses for communication. Thus, you cannot restrict access to specific Azure services based on their public outbound IP address range.
        /// 
        /// &gt; **NOTE** User has to explicitly set `ip_rules` to empty slice (`[]`) to remove it.
        /// </summary>
        public InputList<string> IpRules
        {
            get => _ipRules ?? (_ipRules = new InputList<string>());
            set => _ipRules = value;
        }

        [Input("privateLinkAccessRules")]
        private InputList<Inputs.AccountNetworkRulesPrivateLinkAccessRuleGetArgs>? _privateLinkAccessRules;

        /// <summary>
        /// One or more `private_link_access` block as defined below.
        /// </summary>
        public InputList<Inputs.AccountNetworkRulesPrivateLinkAccessRuleGetArgs> PrivateLinkAccessRules
        {
            get => _privateLinkAccessRules ?? (_privateLinkAccessRules = new InputList<Inputs.AccountNetworkRulesPrivateLinkAccessRuleGetArgs>());
            set => _privateLinkAccessRules = value;
        }

        /// <summary>
        /// Specifies the ID of the storage account. Changing this forces a new resource to be created.
        /// </summary>
        [Input("storageAccountId")]
        public Input<string>? StorageAccountId { get; set; }

        [Input("virtualNetworkSubnetIds")]
        private InputList<string>? _virtualNetworkSubnetIds;

        /// <summary>
        /// A list of virtual network subnet ids to secure the storage account.
        /// 
        /// &gt; **NOTE** User has to explicitly set `virtual_network_subnet_ids` to empty slice (`[]`) to remove it.
        /// </summary>
        public InputList<string> VirtualNetworkSubnetIds
        {
            get => _virtualNetworkSubnetIds ?? (_virtualNetworkSubnetIds = new InputList<string>());
            set => _virtualNetworkSubnetIds = value;
        }

        public AccountNetworkRulesState()
        {
        }
        public static new AccountNetworkRulesState Empty => new AccountNetworkRulesState();
    }
}
