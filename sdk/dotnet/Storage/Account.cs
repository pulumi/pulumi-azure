// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Azure.Storage
{
    /// <summary>
    /// Manages an Azure Storage Account.
    /// 
    /// ## Example Usage
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Azure = Pulumi.Azure;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var example = new Azure.Core.ResourceGroup("example", new()
    ///     {
    ///         Name = "example-resources",
    ///         Location = "West Europe",
    ///     });
    /// 
    ///     var exampleAccount = new Azure.Storage.Account("example", new()
    ///     {
    ///         Name = "storageaccountname",
    ///         ResourceGroupName = example.Name,
    ///         Location = example.Location,
    ///         AccountTier = "Standard",
    ///         AccountReplicationType = "GRS",
    ///         Tags = 
    ///         {
    ///             { "environment", "staging" },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ### With Network Rules
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Azure = Pulumi.Azure;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var example = new Azure.Core.ResourceGroup("example", new()
    ///     {
    ///         Name = "example-resources",
    ///         Location = "West Europe",
    ///     });
    /// 
    ///     var exampleVirtualNetwork = new Azure.Network.VirtualNetwork("example", new()
    ///     {
    ///         Name = "virtnetname",
    ///         AddressSpaces = new[]
    ///         {
    ///             "10.0.0.0/16",
    ///         },
    ///         Location = example.Location,
    ///         ResourceGroupName = example.Name,
    ///     });
    /// 
    ///     var exampleSubnet = new Azure.Network.Subnet("example", new()
    ///     {
    ///         Name = "subnetname",
    ///         ResourceGroupName = example.Name,
    ///         VirtualNetworkName = exampleVirtualNetwork.Name,
    ///         AddressPrefixes = new[]
    ///         {
    ///             "10.0.2.0/24",
    ///         },
    ///         ServiceEndpoints = new[]
    ///         {
    ///             "Microsoft.Sql",
    ///             "Microsoft.Storage",
    ///         },
    ///     });
    /// 
    ///     var exampleAccount = new Azure.Storage.Account("example", new()
    ///     {
    ///         Name = "storageaccountname",
    ///         ResourceGroupName = example.Name,
    ///         Location = example.Location,
    ///         AccountTier = "Standard",
    ///         AccountReplicationType = "LRS",
    ///         NetworkRules = new Azure.Storage.Inputs.AccountNetworkRulesArgs
    ///         {
    ///             DefaultAction = "Deny",
    ///             IpRules = new[]
    ///             {
    ///                 "100.0.0.1",
    ///             },
    ///             VirtualNetworkSubnetIds = new[]
    ///             {
    ///                 exampleSubnet.Id,
    ///             },
    ///         },
    ///         Tags = 
    ///         {
    ///             { "environment", "staging" },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## API Providers
    /// 
    /// &lt;!-- This section is generated, changes will be overwritten --&gt;
    /// This resource uses the following Azure API Providers:
    /// 
    /// * `Microsoft.Storage` - 2023-05-01
    /// 
    /// ## Import
    /// 
    /// Storage Accounts can be imported using the `resource id`, e.g.
    /// 
    /// ```sh
    /// $ pulumi import azure:storage/account:Account storageAcc1 /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/myresourcegroup/providers/Microsoft.Storage/storageAccounts/myaccount
    /// ```
    /// </summary>
    [AzureResourceType("azure:storage/account:Account")]
    public partial class Account : global::Pulumi.CustomResource
    {
        /// <summary>
        /// Defines the access tier for `BlobStorage`, `FileStorage` and `StorageV2` accounts. Valid options are `Hot`, `Cool`, `Cold` and `Premium`. Defaults to `Hot`.
        /// </summary>
        [Output("accessTier")]
        public Output<string> AccessTier { get; private set; } = null!;

        /// <summary>
        /// Defines the Kind of account. Valid options are `BlobStorage`, `BlockBlobStorage`, `FileStorage`, `Storage` and `StorageV2`. Defaults to `StorageV2`.
        /// 
        /// &gt; **Note:** Changing the `AccountKind` value from `Storage` to `StorageV2` will not trigger a force new on the storage account, it will only upgrade the existing storage account from `Storage` to `StorageV2` keeping the existing storage account in place.
        /// </summary>
        [Output("accountKind")]
        public Output<string?> AccountKind { get; private set; } = null!;

        /// <summary>
        /// Defines the type of replication to use for this storage account. Valid options are `LRS`, `GRS`, `RAGRS`, `ZRS`, `GZRS` and `RAGZRS`. Changing this forces a new resource to be created when types `LRS`, `GRS` and `RAGRS` are changed to `ZRS`, `GZRS` or `RAGZRS` and vice versa.
        /// </summary>
        [Output("accountReplicationType")]
        public Output<string> AccountReplicationType { get; private set; } = null!;

        /// <summary>
        /// Defines the Tier to use for this storage account. Valid options are `Standard` and `Premium`. For `BlockBlobStorage` and `FileStorage` accounts only `Premium` is valid. Changing this forces a new resource to be created.
        /// 
        /// &gt; **Note:** Blobs with a tier of `Premium` are of account kind `StorageV2`.
        /// </summary>
        [Output("accountTier")]
        public Output<string> AccountTier { get; private set; } = null!;

        /// <summary>
        /// Allow or disallow nested items within this Account to opt into being public. Defaults to `True`.
        /// 
        /// &gt; **Note:** At this time `AllowNestedItemsToBePublic` is only supported in the Public Cloud, China Cloud, and US Government Cloud.
        /// </summary>
        [Output("allowNestedItemsToBePublic")]
        public Output<bool?> AllowNestedItemsToBePublic { get; private set; } = null!;

        /// <summary>
        /// Restrict copy to and from Storage Accounts within an AAD tenant or with Private Links to the same VNet. Possible values are `AAD` and `PrivateLink`.
        /// </summary>
        [Output("allowedCopyScope")]
        public Output<string?> AllowedCopyScope { get; private set; } = null!;

        /// <summary>
        /// A `AzureFilesAuthentication` block as defined below.
        /// </summary>
        [Output("azureFilesAuthentication")]
        public Output<Outputs.AccountAzureFilesAuthentication?> AzureFilesAuthentication { get; private set; } = null!;

        /// <summary>
        /// A `BlobProperties` block as defined below.
        /// </summary>
        [Output("blobProperties")]
        public Output<Outputs.AccountBlobProperties> BlobProperties { get; private set; } = null!;

        /// <summary>
        /// Should cross Tenant replication be enabled? Defaults to `False`.
        /// </summary>
        [Output("crossTenantReplicationEnabled")]
        public Output<bool?> CrossTenantReplicationEnabled { get; private set; } = null!;

        /// <summary>
        /// A `CustomDomain` block as documented below.
        /// </summary>
        [Output("customDomain")]
        public Output<Outputs.AccountCustomDomain?> CustomDomain { get; private set; } = null!;

        /// <summary>
        /// A `CustomerManagedKey` block as documented below.
        /// 
        /// &gt; **Note:** It's possible to define a Customer Managed Key both within either the `CustomerManagedKey` block or by using the `azure.storage.CustomerManagedKey` resource. However, it's not possible to use both methods to manage a Customer Managed Key for a Storage Account, since these will conflict. When using the `azure.storage.CustomerManagedKey` resource, you will need to use `IgnoreChanges` on the `CustomerManagedKey` block.
        /// </summary>
        [Output("customerManagedKey")]
        public Output<Outputs.AccountCustomerManagedKey?> CustomerManagedKey { get; private set; } = null!;

        /// <summary>
        /// Default to Azure Active Directory authorization in the Azure portal when accessing the Storage Account. The default value is `False`
        /// </summary>
        [Output("defaultToOauthAuthentication")]
        public Output<bool?> DefaultToOauthAuthentication { get; private set; } = null!;

        /// <summary>
        /// Specifies which DNS endpoint type to use. Possible values are `Standard` and `AzureDnsZone`. Defaults to `Standard`. Changing this forces a new resource to be created.
        /// 
        /// &gt; **Note:** Azure DNS zone support requires `PartitionedDns` feature to be enabled. To enable this feature for your subscription, use the following command: `az feature register --namespace "Microsoft.Storage" --name "PartitionedDns"`.
        /// </summary>
        [Output("dnsEndpointType")]
        public Output<string?> DnsEndpointType { get; private set; } = null!;

        /// <summary>
        /// Specifies the Edge Zone within the Azure Region where this Storage Account should exist. Changing this forces a new Storage Account to be created.
        /// </summary>
        [Output("edgeZone")]
        public Output<string?> EdgeZone { get; private set; } = null!;

        /// <summary>
        /// Boolean flag which forces HTTPS if enabled, see [here](https://docs.microsoft.com/azure/storage/storage-require-secure-transfer/) for more information. Defaults to `True`.
        /// </summary>
        [Output("httpsTrafficOnlyEnabled")]
        public Output<bool?> HttpsTrafficOnlyEnabled { get; private set; } = null!;

        /// <summary>
        /// An `Identity` block as defined below.
        /// </summary>
        [Output("identity")]
        public Output<Outputs.AccountIdentity?> Identity { get; private set; } = null!;

        /// <summary>
        /// An `ImmutabilityPolicy` block as defined below. Changing this forces a new resource to be created.
        /// </summary>
        [Output("immutabilityPolicy")]
        public Output<Outputs.AccountImmutabilityPolicy?> ImmutabilityPolicy { get; private set; } = null!;

        /// <summary>
        /// Is infrastructure encryption enabled? Changing this forces a new resource to be created. Defaults to `False`.
        /// 
        /// &gt; **Note:** This can only be `True` when `AccountKind` is `StorageV2` or when `AccountTier` is `Premium` *and* `AccountKind` is one of `BlockBlobStorage` or `FileStorage`.
        /// </summary>
        [Output("infrastructureEncryptionEnabled")]
        public Output<bool?> InfrastructureEncryptionEnabled { get; private set; } = null!;

        /// <summary>
        /// Is Hierarchical Namespace enabled? This can be used with Azure Data Lake Storage Gen 2 ([see here for more information](https://docs.microsoft.com/azure/storage/blobs/data-lake-storage-quickstart-create-account/)). Changing this forces a new resource to be created.
        /// 
        /// &gt; **Note:** This can only be `True` when `AccountTier` is `Standard` or when `AccountTier` is `Premium` *and* `AccountKind` is `BlockBlobStorage`
        /// </summary>
        [Output("isHnsEnabled")]
        public Output<bool?> IsHnsEnabled { get; private set; } = null!;

        /// <summary>
        /// Are Large File Shares Enabled? Defaults to `False`.
        /// 
        /// &gt; **Note:** Large File Shares are enabled by default when using an `AccountKind` of `FileStorage`.
        /// </summary>
        [Output("largeFileShareEnabled")]
        public Output<bool> LargeFileShareEnabled { get; private set; } = null!;

        /// <summary>
        /// Is Local User Enabled? Defaults to `True`.
        /// </summary>
        [Output("localUserEnabled")]
        public Output<bool?> LocalUserEnabled { get; private set; } = null!;

        /// <summary>
        /// Specifies the supported Azure location where the resource exists. Changing this forces a new resource to be created.
        /// </summary>
        [Output("location")]
        public Output<string> Location { get; private set; } = null!;

        /// <summary>
        /// The minimum supported TLS version for the storage account. Possible values are `TLS1_0`, `TLS1_1`, `TLS1_2` and `TLS1_3`. Defaults to `TLS1_2` for new storage accounts.
        /// 
        /// &gt; **Note:** Azure Services will require TLS 1.2+ by August 2025, please see this [announcement](https://azure.microsoft.com/en-us/updates/v2/update-retirement-tls1-0-tls1-1-versions-azure-services/) for more.
        /// 
        /// &gt; **Note:** At this time `MinTlsVersion` is only supported in the Public Cloud, China Cloud, and US Government Cloud.
        /// </summary>
        [Output("minTlsVersion")]
        public Output<string?> MinTlsVersion { get; private set; } = null!;

        /// <summary>
        /// Specifies the name of the storage account. Only lowercase Alphanumeric characters allowed. Changing this forces a new resource to be created. This must be unique across the entire Azure service, not just within the resource group.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// A `NetworkRules` block as documented below.
        /// </summary>
        [Output("networkRules")]
        public Output<Outputs.AccountNetworkRules> NetworkRules { get; private set; } = null!;

        /// <summary>
        /// Is NFSv3 protocol enabled? Changing this forces a new resource to be created. Defaults to `False`.
        /// 
        /// &gt; **Note:** This can only be `True` when `AccountTier` is `Standard` and `AccountKind` is `StorageV2`, or `AccountTier` is `Premium` and `AccountKind` is `BlockBlobStorage`. Additionally, the `IsHnsEnabled` is `True` and `AccountReplicationType` must be `LRS` or `RAGRS`.
        /// </summary>
        [Output("nfsv3Enabled")]
        public Output<bool?> Nfsv3Enabled { get; private set; } = null!;

        /// <summary>
        /// The primary access key for the storage account.
        /// </summary>
        [Output("primaryAccessKey")]
        public Output<string> PrimaryAccessKey { get; private set; } = null!;

        /// <summary>
        /// The connection string associated with the primary blob location.
        /// </summary>
        [Output("primaryBlobConnectionString")]
        public Output<string> PrimaryBlobConnectionString { get; private set; } = null!;

        /// <summary>
        /// The endpoint URL for blob storage in the primary location.
        /// </summary>
        [Output("primaryBlobEndpoint")]
        public Output<string> PrimaryBlobEndpoint { get; private set; } = null!;

        /// <summary>
        /// The hostname with port if applicable for blob storage in the primary location.
        /// </summary>
        [Output("primaryBlobHost")]
        public Output<string> PrimaryBlobHost { get; private set; } = null!;

        /// <summary>
        /// The internet routing endpoint URL for blob storage in the primary location.
        /// </summary>
        [Output("primaryBlobInternetEndpoint")]
        public Output<string> PrimaryBlobInternetEndpoint { get; private set; } = null!;

        /// <summary>
        /// The internet routing hostname with port if applicable for blob storage in the primary location.
        /// </summary>
        [Output("primaryBlobInternetHost")]
        public Output<string> PrimaryBlobInternetHost { get; private set; } = null!;

        /// <summary>
        /// The microsoft routing endpoint URL for blob storage in the primary location.
        /// </summary>
        [Output("primaryBlobMicrosoftEndpoint")]
        public Output<string> PrimaryBlobMicrosoftEndpoint { get; private set; } = null!;

        /// <summary>
        /// The microsoft routing hostname with port if applicable for blob storage in the primary location.
        /// </summary>
        [Output("primaryBlobMicrosoftHost")]
        public Output<string> PrimaryBlobMicrosoftHost { get; private set; } = null!;

        /// <summary>
        /// The connection string associated with the primary location.
        /// </summary>
        [Output("primaryConnectionString")]
        public Output<string> PrimaryConnectionString { get; private set; } = null!;

        /// <summary>
        /// The endpoint URL for DFS storage in the primary location.
        /// </summary>
        [Output("primaryDfsEndpoint")]
        public Output<string> PrimaryDfsEndpoint { get; private set; } = null!;

        /// <summary>
        /// The hostname with port if applicable for DFS storage in the primary location.
        /// </summary>
        [Output("primaryDfsHost")]
        public Output<string> PrimaryDfsHost { get; private set; } = null!;

        /// <summary>
        /// The internet routing endpoint URL for DFS storage in the primary location.
        /// </summary>
        [Output("primaryDfsInternetEndpoint")]
        public Output<string> PrimaryDfsInternetEndpoint { get; private set; } = null!;

        /// <summary>
        /// The internet routing hostname with port if applicable for DFS storage in the primary location.
        /// </summary>
        [Output("primaryDfsInternetHost")]
        public Output<string> PrimaryDfsInternetHost { get; private set; } = null!;

        /// <summary>
        /// The microsoft routing endpoint URL for DFS storage in the primary location.
        /// </summary>
        [Output("primaryDfsMicrosoftEndpoint")]
        public Output<string> PrimaryDfsMicrosoftEndpoint { get; private set; } = null!;

        /// <summary>
        /// The microsoft routing hostname with port if applicable for DFS storage in the primary location.
        /// </summary>
        [Output("primaryDfsMicrosoftHost")]
        public Output<string> PrimaryDfsMicrosoftHost { get; private set; } = null!;

        /// <summary>
        /// The endpoint URL for file storage in the primary location.
        /// </summary>
        [Output("primaryFileEndpoint")]
        public Output<string> PrimaryFileEndpoint { get; private set; } = null!;

        /// <summary>
        /// The hostname with port if applicable for file storage in the primary location.
        /// </summary>
        [Output("primaryFileHost")]
        public Output<string> PrimaryFileHost { get; private set; } = null!;

        /// <summary>
        /// The internet routing endpoint URL for file storage in the primary location.
        /// </summary>
        [Output("primaryFileInternetEndpoint")]
        public Output<string> PrimaryFileInternetEndpoint { get; private set; } = null!;

        /// <summary>
        /// The internet routing hostname with port if applicable for file storage in the primary location.
        /// </summary>
        [Output("primaryFileInternetHost")]
        public Output<string> PrimaryFileInternetHost { get; private set; } = null!;

        /// <summary>
        /// The microsoft routing endpoint URL for file storage in the primary location.
        /// </summary>
        [Output("primaryFileMicrosoftEndpoint")]
        public Output<string> PrimaryFileMicrosoftEndpoint { get; private set; } = null!;

        /// <summary>
        /// The microsoft routing hostname with port if applicable for file storage in the primary location.
        /// </summary>
        [Output("primaryFileMicrosoftHost")]
        public Output<string> PrimaryFileMicrosoftHost { get; private set; } = null!;

        /// <summary>
        /// The primary location of the storage account.
        /// </summary>
        [Output("primaryLocation")]
        public Output<string> PrimaryLocation { get; private set; } = null!;

        /// <summary>
        /// The endpoint URL for queue storage in the primary location.
        /// </summary>
        [Output("primaryQueueEndpoint")]
        public Output<string> PrimaryQueueEndpoint { get; private set; } = null!;

        /// <summary>
        /// The hostname with port if applicable for queue storage in the primary location.
        /// </summary>
        [Output("primaryQueueHost")]
        public Output<string> PrimaryQueueHost { get; private set; } = null!;

        /// <summary>
        /// The microsoft routing endpoint URL for queue storage in the primary location.
        /// </summary>
        [Output("primaryQueueMicrosoftEndpoint")]
        public Output<string> PrimaryQueueMicrosoftEndpoint { get; private set; } = null!;

        /// <summary>
        /// The microsoft routing hostname with port if applicable for queue storage in the primary location.
        /// </summary>
        [Output("primaryQueueMicrosoftHost")]
        public Output<string> PrimaryQueueMicrosoftHost { get; private set; } = null!;

        /// <summary>
        /// The endpoint URL for table storage in the primary location.
        /// </summary>
        [Output("primaryTableEndpoint")]
        public Output<string> PrimaryTableEndpoint { get; private set; } = null!;

        /// <summary>
        /// The hostname with port if applicable for table storage in the primary location.
        /// </summary>
        [Output("primaryTableHost")]
        public Output<string> PrimaryTableHost { get; private set; } = null!;

        /// <summary>
        /// The microsoft routing endpoint URL for table storage in the primary location.
        /// </summary>
        [Output("primaryTableMicrosoftEndpoint")]
        public Output<string> PrimaryTableMicrosoftEndpoint { get; private set; } = null!;

        /// <summary>
        /// The microsoft routing hostname with port if applicable for table storage in the primary location.
        /// </summary>
        [Output("primaryTableMicrosoftHost")]
        public Output<string> PrimaryTableMicrosoftHost { get; private set; } = null!;

        /// <summary>
        /// The endpoint URL for web storage in the primary location.
        /// </summary>
        [Output("primaryWebEndpoint")]
        public Output<string> PrimaryWebEndpoint { get; private set; } = null!;

        /// <summary>
        /// The hostname with port if applicable for web storage in the primary location.
        /// </summary>
        [Output("primaryWebHost")]
        public Output<string> PrimaryWebHost { get; private set; } = null!;

        /// <summary>
        /// The internet routing endpoint URL for web storage in the primary location.
        /// </summary>
        [Output("primaryWebInternetEndpoint")]
        public Output<string> PrimaryWebInternetEndpoint { get; private set; } = null!;

        /// <summary>
        /// The internet routing hostname with port if applicable for web storage in the primary location.
        /// </summary>
        [Output("primaryWebInternetHost")]
        public Output<string> PrimaryWebInternetHost { get; private set; } = null!;

        /// <summary>
        /// The microsoft routing endpoint URL for web storage in the primary location.
        /// </summary>
        [Output("primaryWebMicrosoftEndpoint")]
        public Output<string> PrimaryWebMicrosoftEndpoint { get; private set; } = null!;

        /// <summary>
        /// The microsoft routing hostname with port if applicable for web storage in the primary location.
        /// </summary>
        [Output("primaryWebMicrosoftHost")]
        public Output<string> PrimaryWebMicrosoftHost { get; private set; } = null!;

        /// <summary>
        /// Specifies the version of the **provisioned** billing model (e.g. when `AccountKind = "FileStorage"` for Storage File). Possible value is `V2`. Changing this forces a new resource to be created.
        /// </summary>
        [Output("provisionedBillingModelVersion")]
        public Output<string?> ProvisionedBillingModelVersion { get; private set; } = null!;

        /// <summary>
        /// Whether the public network access is enabled? Defaults to `True`.
        /// </summary>
        [Output("publicNetworkAccessEnabled")]
        public Output<bool?> PublicNetworkAccessEnabled { get; private set; } = null!;

        /// <summary>
        /// The encryption type of the queue service. Possible values are `Service` and `Account`. Changing this forces a new resource to be created. Default value is `Service`.
        /// </summary>
        [Output("queueEncryptionKeyType")]
        public Output<string?> QueueEncryptionKeyType { get; private set; } = null!;

        /// <summary>
        /// A `QueueProperties` block as defined below.
        /// 
        /// &gt; **Note:** `QueueProperties` can only be configured when `AccountTier` is set to `Standard` and `AccountKind` is set to either `Storage` or `StorageV2`.
        /// </summary>
        [Output("queueProperties")]
        public Output<Outputs.AccountQueueProperties> QueueProperties { get; private set; } = null!;

        /// <summary>
        /// The name of the resource group in which to create the storage account. Changing this forces a new resource to be created.
        /// </summary>
        [Output("resourceGroupName")]
        public Output<string> ResourceGroupName { get; private set; } = null!;

        /// <summary>
        /// A `Routing` block as defined below.
        /// </summary>
        [Output("routing")]
        public Output<Outputs.AccountRouting> Routing { get; private set; } = null!;

        /// <summary>
        /// A `SasPolicy` block as defined below.
        /// </summary>
        [Output("sasPolicy")]
        public Output<Outputs.AccountSasPolicy?> SasPolicy { get; private set; } = null!;

        /// <summary>
        /// The secondary access key for the storage account.
        /// </summary>
        [Output("secondaryAccessKey")]
        public Output<string> SecondaryAccessKey { get; private set; } = null!;

        /// <summary>
        /// The connection string associated with the secondary blob location.
        /// </summary>
        [Output("secondaryBlobConnectionString")]
        public Output<string> SecondaryBlobConnectionString { get; private set; } = null!;

        /// <summary>
        /// The endpoint URL for blob storage in the secondary location.
        /// </summary>
        [Output("secondaryBlobEndpoint")]
        public Output<string> SecondaryBlobEndpoint { get; private set; } = null!;

        /// <summary>
        /// The hostname with port if applicable for blob storage in the secondary location.
        /// </summary>
        [Output("secondaryBlobHost")]
        public Output<string> SecondaryBlobHost { get; private set; } = null!;

        /// <summary>
        /// The internet routing endpoint URL for blob storage in the secondary location.
        /// </summary>
        [Output("secondaryBlobInternetEndpoint")]
        public Output<string> SecondaryBlobInternetEndpoint { get; private set; } = null!;

        /// <summary>
        /// The internet routing hostname with port if applicable for blob storage in the secondary location.
        /// </summary>
        [Output("secondaryBlobInternetHost")]
        public Output<string> SecondaryBlobInternetHost { get; private set; } = null!;

        /// <summary>
        /// The microsoft routing endpoint URL for blob storage in the secondary location.
        /// </summary>
        [Output("secondaryBlobMicrosoftEndpoint")]
        public Output<string> SecondaryBlobMicrosoftEndpoint { get; private set; } = null!;

        /// <summary>
        /// The microsoft routing hostname with port if applicable for blob storage in the secondary location.
        /// </summary>
        [Output("secondaryBlobMicrosoftHost")]
        public Output<string> SecondaryBlobMicrosoftHost { get; private set; } = null!;

        /// <summary>
        /// The connection string associated with the secondary location.
        /// </summary>
        [Output("secondaryConnectionString")]
        public Output<string> SecondaryConnectionString { get; private set; } = null!;

        /// <summary>
        /// The endpoint URL for DFS storage in the secondary location.
        /// </summary>
        [Output("secondaryDfsEndpoint")]
        public Output<string> SecondaryDfsEndpoint { get; private set; } = null!;

        /// <summary>
        /// The hostname with port if applicable for DFS storage in the secondary location.
        /// </summary>
        [Output("secondaryDfsHost")]
        public Output<string> SecondaryDfsHost { get; private set; } = null!;

        /// <summary>
        /// The internet routing endpoint URL for DFS storage in the secondary location.
        /// </summary>
        [Output("secondaryDfsInternetEndpoint")]
        public Output<string> SecondaryDfsInternetEndpoint { get; private set; } = null!;

        /// <summary>
        /// The internet routing hostname with port if applicable for DFS storage in the secondary location.
        /// </summary>
        [Output("secondaryDfsInternetHost")]
        public Output<string> SecondaryDfsInternetHost { get; private set; } = null!;

        /// <summary>
        /// The microsoft routing endpoint URL for DFS storage in the secondary location.
        /// </summary>
        [Output("secondaryDfsMicrosoftEndpoint")]
        public Output<string> SecondaryDfsMicrosoftEndpoint { get; private set; } = null!;

        /// <summary>
        /// The microsoft routing hostname with port if applicable for DFS storage in the secondary location.
        /// </summary>
        [Output("secondaryDfsMicrosoftHost")]
        public Output<string> SecondaryDfsMicrosoftHost { get; private set; } = null!;

        /// <summary>
        /// The endpoint URL for file storage in the secondary location.
        /// </summary>
        [Output("secondaryFileEndpoint")]
        public Output<string> SecondaryFileEndpoint { get; private set; } = null!;

        /// <summary>
        /// The hostname with port if applicable for file storage in the secondary location.
        /// </summary>
        [Output("secondaryFileHost")]
        public Output<string> SecondaryFileHost { get; private set; } = null!;

        /// <summary>
        /// The internet routing endpoint URL for file storage in the secondary location.
        /// </summary>
        [Output("secondaryFileInternetEndpoint")]
        public Output<string> SecondaryFileInternetEndpoint { get; private set; } = null!;

        /// <summary>
        /// The internet routing hostname with port if applicable for file storage in the secondary location.
        /// </summary>
        [Output("secondaryFileInternetHost")]
        public Output<string> SecondaryFileInternetHost { get; private set; } = null!;

        /// <summary>
        /// The microsoft routing endpoint URL for file storage in the secondary location.
        /// </summary>
        [Output("secondaryFileMicrosoftEndpoint")]
        public Output<string> SecondaryFileMicrosoftEndpoint { get; private set; } = null!;

        /// <summary>
        /// The microsoft routing hostname with port if applicable for file storage in the secondary location.
        /// </summary>
        [Output("secondaryFileMicrosoftHost")]
        public Output<string> SecondaryFileMicrosoftHost { get; private set; } = null!;

        /// <summary>
        /// The secondary location of the storage account.
        /// </summary>
        [Output("secondaryLocation")]
        public Output<string> SecondaryLocation { get; private set; } = null!;

        /// <summary>
        /// The endpoint URL for queue storage in the secondary location.
        /// </summary>
        [Output("secondaryQueueEndpoint")]
        public Output<string> SecondaryQueueEndpoint { get; private set; } = null!;

        /// <summary>
        /// The hostname with port if applicable for queue storage in the secondary location.
        /// </summary>
        [Output("secondaryQueueHost")]
        public Output<string> SecondaryQueueHost { get; private set; } = null!;

        /// <summary>
        /// The microsoft routing endpoint URL for queue storage in the secondary location.
        /// </summary>
        [Output("secondaryQueueMicrosoftEndpoint")]
        public Output<string> SecondaryQueueMicrosoftEndpoint { get; private set; } = null!;

        /// <summary>
        /// The microsoft routing hostname with port if applicable for queue storage in the secondary location.
        /// </summary>
        [Output("secondaryQueueMicrosoftHost")]
        public Output<string> SecondaryQueueMicrosoftHost { get; private set; } = null!;

        /// <summary>
        /// The endpoint URL for table storage in the secondary location.
        /// </summary>
        [Output("secondaryTableEndpoint")]
        public Output<string> SecondaryTableEndpoint { get; private set; } = null!;

        /// <summary>
        /// The hostname with port if applicable for table storage in the secondary location.
        /// </summary>
        [Output("secondaryTableHost")]
        public Output<string> SecondaryTableHost { get; private set; } = null!;

        /// <summary>
        /// The microsoft routing endpoint URL for table storage in the secondary location.
        /// </summary>
        [Output("secondaryTableMicrosoftEndpoint")]
        public Output<string> SecondaryTableMicrosoftEndpoint { get; private set; } = null!;

        /// <summary>
        /// The microsoft routing hostname with port if applicable for table storage in the secondary location.
        /// </summary>
        [Output("secondaryTableMicrosoftHost")]
        public Output<string> SecondaryTableMicrosoftHost { get; private set; } = null!;

        /// <summary>
        /// The endpoint URL for web storage in the secondary location.
        /// </summary>
        [Output("secondaryWebEndpoint")]
        public Output<string> SecondaryWebEndpoint { get; private set; } = null!;

        /// <summary>
        /// The hostname with port if applicable for web storage in the secondary location.
        /// </summary>
        [Output("secondaryWebHost")]
        public Output<string> SecondaryWebHost { get; private set; } = null!;

        /// <summary>
        /// The internet routing endpoint URL for web storage in the secondary location.
        /// </summary>
        [Output("secondaryWebInternetEndpoint")]
        public Output<string> SecondaryWebInternetEndpoint { get; private set; } = null!;

        /// <summary>
        /// The internet routing hostname with port if applicable for web storage in the secondary location.
        /// </summary>
        [Output("secondaryWebInternetHost")]
        public Output<string> SecondaryWebInternetHost { get; private set; } = null!;

        /// <summary>
        /// The microsoft routing endpoint URL for web storage in the secondary location.
        /// </summary>
        [Output("secondaryWebMicrosoftEndpoint")]
        public Output<string> SecondaryWebMicrosoftEndpoint { get; private set; } = null!;

        /// <summary>
        /// The microsoft routing hostname with port if applicable for web storage in the secondary location.
        /// </summary>
        [Output("secondaryWebMicrosoftHost")]
        public Output<string> SecondaryWebMicrosoftHost { get; private set; } = null!;

        /// <summary>
        /// Boolean, enable SFTP for the storage account
        /// 
        /// &gt; **Note:** SFTP support requires `IsHnsEnabled` set to `True`. [More information on SFTP support can be found here](https://learn.microsoft.com/azure/storage/blobs/secure-file-transfer-protocol-support). Defaults to `False`
        /// </summary>
        [Output("sftpEnabled")]
        public Output<bool?> SftpEnabled { get; private set; } = null!;

        /// <summary>
        /// A `ShareProperties` block as defined below.
        /// 
        /// &gt; **Note:** `ShareProperties` can only be configured when either `AccountTier` is `Standard` and `AccountKind` is either `Storage` or `StorageV2` - or when `AccountTier` is `Premium` and `AccountKind` is `FileStorage`.
        /// </summary>
        [Output("shareProperties")]
        public Output<Outputs.AccountShareProperties> ShareProperties { get; private set; } = null!;

        /// <summary>
        /// Indicates whether the storage account permits requests to be authorized with the account access key via Shared Key. If false, then all requests, including shared access signatures, must be authorized with Azure Active Directory (Azure AD). Defaults to `True`.
        /// 
        /// &gt; **Note:** Terraform uses Shared Key Authorisation to provision Storage Containers, Blobs and other items - when Shared Key Access is disabled, you will need to enable the `StorageUseAzuread` flag in the Provider block to use Azure AD for authentication, however not all Azure Storage services support Active Directory authentication.
        /// </summary>
        [Output("sharedAccessKeyEnabled")]
        public Output<bool?> SharedAccessKeyEnabled { get; private set; } = null!;

        /// <summary>
        /// A `StaticWebsite` block as defined below.
        /// 
        /// &gt; **Note:** `StaticWebsite` can only be set when the `AccountKind` is set to `StorageV2` or `BlockBlobStorage`.
        /// 
        /// &gt; **Note:** If `StaticWebsite` is specified, the service will automatically create a `azure.storage.Container` named `$web`.
        /// </summary>
        [Output("staticWebsite")]
        public Output<Outputs.AccountStaticWebsite> StaticWebsite { get; private set; } = null!;

        /// <summary>
        /// The encryption type of the table service. Possible values are `Service` and `Account`. Changing this forces a new resource to be created. Default value is `Service`.
        /// 
        /// &gt; **Note:** `QueueEncryptionKeyType` and `TableEncryptionKeyType` cannot be set to `Account` when `AccountKind` is set `Storage`
        /// </summary>
        [Output("tableEncryptionKeyType")]
        public Output<string?> TableEncryptionKeyType { get; private set; } = null!;

        /// <summary>
        /// A mapping of tags to assign to the resource.
        /// </summary>
        [Output("tags")]
        public Output<ImmutableDictionary<string, string>?> Tags { get; private set; } = null!;


        /// <summary>
        /// Create a Account resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public Account(string name, AccountArgs args, CustomResourceOptions? options = null)
            : base("azure:storage/account:Account", name, args ?? new AccountArgs(), MakeResourceOptions(options, ""))
        {
        }

        private Account(string name, Input<string> id, AccountState? state = null, CustomResourceOptions? options = null)
            : base("azure:storage/account:Account", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                AdditionalSecretOutputs =
                {
                    "primaryAccessKey",
                    "primaryBlobConnectionString",
                    "primaryConnectionString",
                    "secondaryAccessKey",
                    "secondaryBlobConnectionString",
                    "secondaryConnectionString",
                },
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing Account resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static Account Get(string name, Input<string> id, AccountState? state = null, CustomResourceOptions? options = null)
        {
            return new Account(name, id, state, options);
        }
    }

    public sealed class AccountArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Defines the access tier for `BlobStorage`, `FileStorage` and `StorageV2` accounts. Valid options are `Hot`, `Cool`, `Cold` and `Premium`. Defaults to `Hot`.
        /// </summary>
        [Input("accessTier")]
        public Input<string>? AccessTier { get; set; }

        /// <summary>
        /// Defines the Kind of account. Valid options are `BlobStorage`, `BlockBlobStorage`, `FileStorage`, `Storage` and `StorageV2`. Defaults to `StorageV2`.
        /// 
        /// &gt; **Note:** Changing the `AccountKind` value from `Storage` to `StorageV2` will not trigger a force new on the storage account, it will only upgrade the existing storage account from `Storage` to `StorageV2` keeping the existing storage account in place.
        /// </summary>
        [Input("accountKind")]
        public Input<string>? AccountKind { get; set; }

        /// <summary>
        /// Defines the type of replication to use for this storage account. Valid options are `LRS`, `GRS`, `RAGRS`, `ZRS`, `GZRS` and `RAGZRS`. Changing this forces a new resource to be created when types `LRS`, `GRS` and `RAGRS` are changed to `ZRS`, `GZRS` or `RAGZRS` and vice versa.
        /// </summary>
        [Input("accountReplicationType", required: true)]
        public Input<string> AccountReplicationType { get; set; } = null!;

        /// <summary>
        /// Defines the Tier to use for this storage account. Valid options are `Standard` and `Premium`. For `BlockBlobStorage` and `FileStorage` accounts only `Premium` is valid. Changing this forces a new resource to be created.
        /// 
        /// &gt; **Note:** Blobs with a tier of `Premium` are of account kind `StorageV2`.
        /// </summary>
        [Input("accountTier", required: true)]
        public Input<string> AccountTier { get; set; } = null!;

        /// <summary>
        /// Allow or disallow nested items within this Account to opt into being public. Defaults to `True`.
        /// 
        /// &gt; **Note:** At this time `AllowNestedItemsToBePublic` is only supported in the Public Cloud, China Cloud, and US Government Cloud.
        /// </summary>
        [Input("allowNestedItemsToBePublic")]
        public Input<bool>? AllowNestedItemsToBePublic { get; set; }

        /// <summary>
        /// Restrict copy to and from Storage Accounts within an AAD tenant or with Private Links to the same VNet. Possible values are `AAD` and `PrivateLink`.
        /// </summary>
        [Input("allowedCopyScope")]
        public Input<string>? AllowedCopyScope { get; set; }

        /// <summary>
        /// A `AzureFilesAuthentication` block as defined below.
        /// </summary>
        [Input("azureFilesAuthentication")]
        public Input<Inputs.AccountAzureFilesAuthenticationArgs>? AzureFilesAuthentication { get; set; }

        /// <summary>
        /// A `BlobProperties` block as defined below.
        /// </summary>
        [Input("blobProperties")]
        public Input<Inputs.AccountBlobPropertiesArgs>? BlobProperties { get; set; }

        /// <summary>
        /// Should cross Tenant replication be enabled? Defaults to `False`.
        /// </summary>
        [Input("crossTenantReplicationEnabled")]
        public Input<bool>? CrossTenantReplicationEnabled { get; set; }

        /// <summary>
        /// A `CustomDomain` block as documented below.
        /// </summary>
        [Input("customDomain")]
        public Input<Inputs.AccountCustomDomainArgs>? CustomDomain { get; set; }

        /// <summary>
        /// A `CustomerManagedKey` block as documented below.
        /// 
        /// &gt; **Note:** It's possible to define a Customer Managed Key both within either the `CustomerManagedKey` block or by using the `azure.storage.CustomerManagedKey` resource. However, it's not possible to use both methods to manage a Customer Managed Key for a Storage Account, since these will conflict. When using the `azure.storage.CustomerManagedKey` resource, you will need to use `IgnoreChanges` on the `CustomerManagedKey` block.
        /// </summary>
        [Input("customerManagedKey")]
        public Input<Inputs.AccountCustomerManagedKeyArgs>? CustomerManagedKey { get; set; }

        /// <summary>
        /// Default to Azure Active Directory authorization in the Azure portal when accessing the Storage Account. The default value is `False`
        /// </summary>
        [Input("defaultToOauthAuthentication")]
        public Input<bool>? DefaultToOauthAuthentication { get; set; }

        /// <summary>
        /// Specifies which DNS endpoint type to use. Possible values are `Standard` and `AzureDnsZone`. Defaults to `Standard`. Changing this forces a new resource to be created.
        /// 
        /// &gt; **Note:** Azure DNS zone support requires `PartitionedDns` feature to be enabled. To enable this feature for your subscription, use the following command: `az feature register --namespace "Microsoft.Storage" --name "PartitionedDns"`.
        /// </summary>
        [Input("dnsEndpointType")]
        public Input<string>? DnsEndpointType { get; set; }

        /// <summary>
        /// Specifies the Edge Zone within the Azure Region where this Storage Account should exist. Changing this forces a new Storage Account to be created.
        /// </summary>
        [Input("edgeZone")]
        public Input<string>? EdgeZone { get; set; }

        /// <summary>
        /// Boolean flag which forces HTTPS if enabled, see [here](https://docs.microsoft.com/azure/storage/storage-require-secure-transfer/) for more information. Defaults to `True`.
        /// </summary>
        [Input("httpsTrafficOnlyEnabled")]
        public Input<bool>? HttpsTrafficOnlyEnabled { get; set; }

        /// <summary>
        /// An `Identity` block as defined below.
        /// </summary>
        [Input("identity")]
        public Input<Inputs.AccountIdentityArgs>? Identity { get; set; }

        /// <summary>
        /// An `ImmutabilityPolicy` block as defined below. Changing this forces a new resource to be created.
        /// </summary>
        [Input("immutabilityPolicy")]
        public Input<Inputs.AccountImmutabilityPolicyArgs>? ImmutabilityPolicy { get; set; }

        /// <summary>
        /// Is infrastructure encryption enabled? Changing this forces a new resource to be created. Defaults to `False`.
        /// 
        /// &gt; **Note:** This can only be `True` when `AccountKind` is `StorageV2` or when `AccountTier` is `Premium` *and* `AccountKind` is one of `BlockBlobStorage` or `FileStorage`.
        /// </summary>
        [Input("infrastructureEncryptionEnabled")]
        public Input<bool>? InfrastructureEncryptionEnabled { get; set; }

        /// <summary>
        /// Is Hierarchical Namespace enabled? This can be used with Azure Data Lake Storage Gen 2 ([see here for more information](https://docs.microsoft.com/azure/storage/blobs/data-lake-storage-quickstart-create-account/)). Changing this forces a new resource to be created.
        /// 
        /// &gt; **Note:** This can only be `True` when `AccountTier` is `Standard` or when `AccountTier` is `Premium` *and* `AccountKind` is `BlockBlobStorage`
        /// </summary>
        [Input("isHnsEnabled")]
        public Input<bool>? IsHnsEnabled { get; set; }

        /// <summary>
        /// Are Large File Shares Enabled? Defaults to `False`.
        /// 
        /// &gt; **Note:** Large File Shares are enabled by default when using an `AccountKind` of `FileStorage`.
        /// </summary>
        [Input("largeFileShareEnabled")]
        public Input<bool>? LargeFileShareEnabled { get; set; }

        /// <summary>
        /// Is Local User Enabled? Defaults to `True`.
        /// </summary>
        [Input("localUserEnabled")]
        public Input<bool>? LocalUserEnabled { get; set; }

        /// <summary>
        /// Specifies the supported Azure location where the resource exists. Changing this forces a new resource to be created.
        /// </summary>
        [Input("location")]
        public Input<string>? Location { get; set; }

        /// <summary>
        /// The minimum supported TLS version for the storage account. Possible values are `TLS1_0`, `TLS1_1`, `TLS1_2` and `TLS1_3`. Defaults to `TLS1_2` for new storage accounts.
        /// 
        /// &gt; **Note:** Azure Services will require TLS 1.2+ by August 2025, please see this [announcement](https://azure.microsoft.com/en-us/updates/v2/update-retirement-tls1-0-tls1-1-versions-azure-services/) for more.
        /// 
        /// &gt; **Note:** At this time `MinTlsVersion` is only supported in the Public Cloud, China Cloud, and US Government Cloud.
        /// </summary>
        [Input("minTlsVersion")]
        public Input<string>? MinTlsVersion { get; set; }

        /// <summary>
        /// Specifies the name of the storage account. Only lowercase Alphanumeric characters allowed. Changing this forces a new resource to be created. This must be unique across the entire Azure service, not just within the resource group.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// A `NetworkRules` block as documented below.
        /// </summary>
        [Input("networkRules")]
        public Input<Inputs.AccountNetworkRulesArgs>? NetworkRules { get; set; }

        /// <summary>
        /// Is NFSv3 protocol enabled? Changing this forces a new resource to be created. Defaults to `False`.
        /// 
        /// &gt; **Note:** This can only be `True` when `AccountTier` is `Standard` and `AccountKind` is `StorageV2`, or `AccountTier` is `Premium` and `AccountKind` is `BlockBlobStorage`. Additionally, the `IsHnsEnabled` is `True` and `AccountReplicationType` must be `LRS` or `RAGRS`.
        /// </summary>
        [Input("nfsv3Enabled")]
        public Input<bool>? Nfsv3Enabled { get; set; }

        /// <summary>
        /// Specifies the version of the **provisioned** billing model (e.g. when `AccountKind = "FileStorage"` for Storage File). Possible value is `V2`. Changing this forces a new resource to be created.
        /// </summary>
        [Input("provisionedBillingModelVersion")]
        public Input<string>? ProvisionedBillingModelVersion { get; set; }

        /// <summary>
        /// Whether the public network access is enabled? Defaults to `True`.
        /// </summary>
        [Input("publicNetworkAccessEnabled")]
        public Input<bool>? PublicNetworkAccessEnabled { get; set; }

        /// <summary>
        /// The encryption type of the queue service. Possible values are `Service` and `Account`. Changing this forces a new resource to be created. Default value is `Service`.
        /// </summary>
        [Input("queueEncryptionKeyType")]
        public Input<string>? QueueEncryptionKeyType { get; set; }

        /// <summary>
        /// A `QueueProperties` block as defined below.
        /// 
        /// &gt; **Note:** `QueueProperties` can only be configured when `AccountTier` is set to `Standard` and `AccountKind` is set to either `Storage` or `StorageV2`.
        /// </summary>
        [Input("queueProperties")]
        public Input<Inputs.AccountQueuePropertiesArgs>? QueueProperties { get; set; }

        /// <summary>
        /// The name of the resource group in which to create the storage account. Changing this forces a new resource to be created.
        /// </summary>
        [Input("resourceGroupName", required: true)]
        public Input<string> ResourceGroupName { get; set; } = null!;

        /// <summary>
        /// A `Routing` block as defined below.
        /// </summary>
        [Input("routing")]
        public Input<Inputs.AccountRoutingArgs>? Routing { get; set; }

        /// <summary>
        /// A `SasPolicy` block as defined below.
        /// </summary>
        [Input("sasPolicy")]
        public Input<Inputs.AccountSasPolicyArgs>? SasPolicy { get; set; }

        /// <summary>
        /// Boolean, enable SFTP for the storage account
        /// 
        /// &gt; **Note:** SFTP support requires `IsHnsEnabled` set to `True`. [More information on SFTP support can be found here](https://learn.microsoft.com/azure/storage/blobs/secure-file-transfer-protocol-support). Defaults to `False`
        /// </summary>
        [Input("sftpEnabled")]
        public Input<bool>? SftpEnabled { get; set; }

        /// <summary>
        /// A `ShareProperties` block as defined below.
        /// 
        /// &gt; **Note:** `ShareProperties` can only be configured when either `AccountTier` is `Standard` and `AccountKind` is either `Storage` or `StorageV2` - or when `AccountTier` is `Premium` and `AccountKind` is `FileStorage`.
        /// </summary>
        [Input("shareProperties")]
        public Input<Inputs.AccountSharePropertiesArgs>? ShareProperties { get; set; }

        /// <summary>
        /// Indicates whether the storage account permits requests to be authorized with the account access key via Shared Key. If false, then all requests, including shared access signatures, must be authorized with Azure Active Directory (Azure AD). Defaults to `True`.
        /// 
        /// &gt; **Note:** Terraform uses Shared Key Authorisation to provision Storage Containers, Blobs and other items - when Shared Key Access is disabled, you will need to enable the `StorageUseAzuread` flag in the Provider block to use Azure AD for authentication, however not all Azure Storage services support Active Directory authentication.
        /// </summary>
        [Input("sharedAccessKeyEnabled")]
        public Input<bool>? SharedAccessKeyEnabled { get; set; }

        /// <summary>
        /// A `StaticWebsite` block as defined below.
        /// 
        /// &gt; **Note:** `StaticWebsite` can only be set when the `AccountKind` is set to `StorageV2` or `BlockBlobStorage`.
        /// 
        /// &gt; **Note:** If `StaticWebsite` is specified, the service will automatically create a `azure.storage.Container` named `$web`.
        /// </summary>
        [Input("staticWebsite")]
        public Input<Inputs.AccountStaticWebsiteArgs>? StaticWebsite { get; set; }

        /// <summary>
        /// The encryption type of the table service. Possible values are `Service` and `Account`. Changing this forces a new resource to be created. Default value is `Service`.
        /// 
        /// &gt; **Note:** `QueueEncryptionKeyType` and `TableEncryptionKeyType` cannot be set to `Account` when `AccountKind` is set `Storage`
        /// </summary>
        [Input("tableEncryptionKeyType")]
        public Input<string>? TableEncryptionKeyType { get; set; }

        [Input("tags")]
        private InputMap<string>? _tags;

        /// <summary>
        /// A mapping of tags to assign to the resource.
        /// </summary>
        public InputMap<string> Tags
        {
            get => _tags ?? (_tags = new InputMap<string>());
            set => _tags = value;
        }

        public AccountArgs()
        {
        }
        public static new AccountArgs Empty => new AccountArgs();
    }

    public sealed class AccountState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Defines the access tier for `BlobStorage`, `FileStorage` and `StorageV2` accounts. Valid options are `Hot`, `Cool`, `Cold` and `Premium`. Defaults to `Hot`.
        /// </summary>
        [Input("accessTier")]
        public Input<string>? AccessTier { get; set; }

        /// <summary>
        /// Defines the Kind of account. Valid options are `BlobStorage`, `BlockBlobStorage`, `FileStorage`, `Storage` and `StorageV2`. Defaults to `StorageV2`.
        /// 
        /// &gt; **Note:** Changing the `AccountKind` value from `Storage` to `StorageV2` will not trigger a force new on the storage account, it will only upgrade the existing storage account from `Storage` to `StorageV2` keeping the existing storage account in place.
        /// </summary>
        [Input("accountKind")]
        public Input<string>? AccountKind { get; set; }

        /// <summary>
        /// Defines the type of replication to use for this storage account. Valid options are `LRS`, `GRS`, `RAGRS`, `ZRS`, `GZRS` and `RAGZRS`. Changing this forces a new resource to be created when types `LRS`, `GRS` and `RAGRS` are changed to `ZRS`, `GZRS` or `RAGZRS` and vice versa.
        /// </summary>
        [Input("accountReplicationType")]
        public Input<string>? AccountReplicationType { get; set; }

        /// <summary>
        /// Defines the Tier to use for this storage account. Valid options are `Standard` and `Premium`. For `BlockBlobStorage` and `FileStorage` accounts only `Premium` is valid. Changing this forces a new resource to be created.
        /// 
        /// &gt; **Note:** Blobs with a tier of `Premium` are of account kind `StorageV2`.
        /// </summary>
        [Input("accountTier")]
        public Input<string>? AccountTier { get; set; }

        /// <summary>
        /// Allow or disallow nested items within this Account to opt into being public. Defaults to `True`.
        /// 
        /// &gt; **Note:** At this time `AllowNestedItemsToBePublic` is only supported in the Public Cloud, China Cloud, and US Government Cloud.
        /// </summary>
        [Input("allowNestedItemsToBePublic")]
        public Input<bool>? AllowNestedItemsToBePublic { get; set; }

        /// <summary>
        /// Restrict copy to and from Storage Accounts within an AAD tenant or with Private Links to the same VNet. Possible values are `AAD` and `PrivateLink`.
        /// </summary>
        [Input("allowedCopyScope")]
        public Input<string>? AllowedCopyScope { get; set; }

        /// <summary>
        /// A `AzureFilesAuthentication` block as defined below.
        /// </summary>
        [Input("azureFilesAuthentication")]
        public Input<Inputs.AccountAzureFilesAuthenticationGetArgs>? AzureFilesAuthentication { get; set; }

        /// <summary>
        /// A `BlobProperties` block as defined below.
        /// </summary>
        [Input("blobProperties")]
        public Input<Inputs.AccountBlobPropertiesGetArgs>? BlobProperties { get; set; }

        /// <summary>
        /// Should cross Tenant replication be enabled? Defaults to `False`.
        /// </summary>
        [Input("crossTenantReplicationEnabled")]
        public Input<bool>? CrossTenantReplicationEnabled { get; set; }

        /// <summary>
        /// A `CustomDomain` block as documented below.
        /// </summary>
        [Input("customDomain")]
        public Input<Inputs.AccountCustomDomainGetArgs>? CustomDomain { get; set; }

        /// <summary>
        /// A `CustomerManagedKey` block as documented below.
        /// 
        /// &gt; **Note:** It's possible to define a Customer Managed Key both within either the `CustomerManagedKey` block or by using the `azure.storage.CustomerManagedKey` resource. However, it's not possible to use both methods to manage a Customer Managed Key for a Storage Account, since these will conflict. When using the `azure.storage.CustomerManagedKey` resource, you will need to use `IgnoreChanges` on the `CustomerManagedKey` block.
        /// </summary>
        [Input("customerManagedKey")]
        public Input<Inputs.AccountCustomerManagedKeyGetArgs>? CustomerManagedKey { get; set; }

        /// <summary>
        /// Default to Azure Active Directory authorization in the Azure portal when accessing the Storage Account. The default value is `False`
        /// </summary>
        [Input("defaultToOauthAuthentication")]
        public Input<bool>? DefaultToOauthAuthentication { get; set; }

        /// <summary>
        /// Specifies which DNS endpoint type to use. Possible values are `Standard` and `AzureDnsZone`. Defaults to `Standard`. Changing this forces a new resource to be created.
        /// 
        /// &gt; **Note:** Azure DNS zone support requires `PartitionedDns` feature to be enabled. To enable this feature for your subscription, use the following command: `az feature register --namespace "Microsoft.Storage" --name "PartitionedDns"`.
        /// </summary>
        [Input("dnsEndpointType")]
        public Input<string>? DnsEndpointType { get; set; }

        /// <summary>
        /// Specifies the Edge Zone within the Azure Region where this Storage Account should exist. Changing this forces a new Storage Account to be created.
        /// </summary>
        [Input("edgeZone")]
        public Input<string>? EdgeZone { get; set; }

        /// <summary>
        /// Boolean flag which forces HTTPS if enabled, see [here](https://docs.microsoft.com/azure/storage/storage-require-secure-transfer/) for more information. Defaults to `True`.
        /// </summary>
        [Input("httpsTrafficOnlyEnabled")]
        public Input<bool>? HttpsTrafficOnlyEnabled { get; set; }

        /// <summary>
        /// An `Identity` block as defined below.
        /// </summary>
        [Input("identity")]
        public Input<Inputs.AccountIdentityGetArgs>? Identity { get; set; }

        /// <summary>
        /// An `ImmutabilityPolicy` block as defined below. Changing this forces a new resource to be created.
        /// </summary>
        [Input("immutabilityPolicy")]
        public Input<Inputs.AccountImmutabilityPolicyGetArgs>? ImmutabilityPolicy { get; set; }

        /// <summary>
        /// Is infrastructure encryption enabled? Changing this forces a new resource to be created. Defaults to `False`.
        /// 
        /// &gt; **Note:** This can only be `True` when `AccountKind` is `StorageV2` or when `AccountTier` is `Premium` *and* `AccountKind` is one of `BlockBlobStorage` or `FileStorage`.
        /// </summary>
        [Input("infrastructureEncryptionEnabled")]
        public Input<bool>? InfrastructureEncryptionEnabled { get; set; }

        /// <summary>
        /// Is Hierarchical Namespace enabled? This can be used with Azure Data Lake Storage Gen 2 ([see here for more information](https://docs.microsoft.com/azure/storage/blobs/data-lake-storage-quickstart-create-account/)). Changing this forces a new resource to be created.
        /// 
        /// &gt; **Note:** This can only be `True` when `AccountTier` is `Standard` or when `AccountTier` is `Premium` *and* `AccountKind` is `BlockBlobStorage`
        /// </summary>
        [Input("isHnsEnabled")]
        public Input<bool>? IsHnsEnabled { get; set; }

        /// <summary>
        /// Are Large File Shares Enabled? Defaults to `False`.
        /// 
        /// &gt; **Note:** Large File Shares are enabled by default when using an `AccountKind` of `FileStorage`.
        /// </summary>
        [Input("largeFileShareEnabled")]
        public Input<bool>? LargeFileShareEnabled { get; set; }

        /// <summary>
        /// Is Local User Enabled? Defaults to `True`.
        /// </summary>
        [Input("localUserEnabled")]
        public Input<bool>? LocalUserEnabled { get; set; }

        /// <summary>
        /// Specifies the supported Azure location where the resource exists. Changing this forces a new resource to be created.
        /// </summary>
        [Input("location")]
        public Input<string>? Location { get; set; }

        /// <summary>
        /// The minimum supported TLS version for the storage account. Possible values are `TLS1_0`, `TLS1_1`, `TLS1_2` and `TLS1_3`. Defaults to `TLS1_2` for new storage accounts.
        /// 
        /// &gt; **Note:** Azure Services will require TLS 1.2+ by August 2025, please see this [announcement](https://azure.microsoft.com/en-us/updates/v2/update-retirement-tls1-0-tls1-1-versions-azure-services/) for more.
        /// 
        /// &gt; **Note:** At this time `MinTlsVersion` is only supported in the Public Cloud, China Cloud, and US Government Cloud.
        /// </summary>
        [Input("minTlsVersion")]
        public Input<string>? MinTlsVersion { get; set; }

        /// <summary>
        /// Specifies the name of the storage account. Only lowercase Alphanumeric characters allowed. Changing this forces a new resource to be created. This must be unique across the entire Azure service, not just within the resource group.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// A `NetworkRules` block as documented below.
        /// </summary>
        [Input("networkRules")]
        public Input<Inputs.AccountNetworkRulesGetArgs>? NetworkRules { get; set; }

        /// <summary>
        /// Is NFSv3 protocol enabled? Changing this forces a new resource to be created. Defaults to `False`.
        /// 
        /// &gt; **Note:** This can only be `True` when `AccountTier` is `Standard` and `AccountKind` is `StorageV2`, or `AccountTier` is `Premium` and `AccountKind` is `BlockBlobStorage`. Additionally, the `IsHnsEnabled` is `True` and `AccountReplicationType` must be `LRS` or `RAGRS`.
        /// </summary>
        [Input("nfsv3Enabled")]
        public Input<bool>? Nfsv3Enabled { get; set; }

        [Input("primaryAccessKey")]
        private Input<string>? _primaryAccessKey;

        /// <summary>
        /// The primary access key for the storage account.
        /// </summary>
        public Input<string>? PrimaryAccessKey
        {
            get => _primaryAccessKey;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _primaryAccessKey = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        [Input("primaryBlobConnectionString")]
        private Input<string>? _primaryBlobConnectionString;

        /// <summary>
        /// The connection string associated with the primary blob location.
        /// </summary>
        public Input<string>? PrimaryBlobConnectionString
        {
            get => _primaryBlobConnectionString;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _primaryBlobConnectionString = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        /// <summary>
        /// The endpoint URL for blob storage in the primary location.
        /// </summary>
        [Input("primaryBlobEndpoint")]
        public Input<string>? PrimaryBlobEndpoint { get; set; }

        /// <summary>
        /// The hostname with port if applicable for blob storage in the primary location.
        /// </summary>
        [Input("primaryBlobHost")]
        public Input<string>? PrimaryBlobHost { get; set; }

        /// <summary>
        /// The internet routing endpoint URL for blob storage in the primary location.
        /// </summary>
        [Input("primaryBlobInternetEndpoint")]
        public Input<string>? PrimaryBlobInternetEndpoint { get; set; }

        /// <summary>
        /// The internet routing hostname with port if applicable for blob storage in the primary location.
        /// </summary>
        [Input("primaryBlobInternetHost")]
        public Input<string>? PrimaryBlobInternetHost { get; set; }

        /// <summary>
        /// The microsoft routing endpoint URL for blob storage in the primary location.
        /// </summary>
        [Input("primaryBlobMicrosoftEndpoint")]
        public Input<string>? PrimaryBlobMicrosoftEndpoint { get; set; }

        /// <summary>
        /// The microsoft routing hostname with port if applicable for blob storage in the primary location.
        /// </summary>
        [Input("primaryBlobMicrosoftHost")]
        public Input<string>? PrimaryBlobMicrosoftHost { get; set; }

        [Input("primaryConnectionString")]
        private Input<string>? _primaryConnectionString;

        /// <summary>
        /// The connection string associated with the primary location.
        /// </summary>
        public Input<string>? PrimaryConnectionString
        {
            get => _primaryConnectionString;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _primaryConnectionString = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        /// <summary>
        /// The endpoint URL for DFS storage in the primary location.
        /// </summary>
        [Input("primaryDfsEndpoint")]
        public Input<string>? PrimaryDfsEndpoint { get; set; }

        /// <summary>
        /// The hostname with port if applicable for DFS storage in the primary location.
        /// </summary>
        [Input("primaryDfsHost")]
        public Input<string>? PrimaryDfsHost { get; set; }

        /// <summary>
        /// The internet routing endpoint URL for DFS storage in the primary location.
        /// </summary>
        [Input("primaryDfsInternetEndpoint")]
        public Input<string>? PrimaryDfsInternetEndpoint { get; set; }

        /// <summary>
        /// The internet routing hostname with port if applicable for DFS storage in the primary location.
        /// </summary>
        [Input("primaryDfsInternetHost")]
        public Input<string>? PrimaryDfsInternetHost { get; set; }

        /// <summary>
        /// The microsoft routing endpoint URL for DFS storage in the primary location.
        /// </summary>
        [Input("primaryDfsMicrosoftEndpoint")]
        public Input<string>? PrimaryDfsMicrosoftEndpoint { get; set; }

        /// <summary>
        /// The microsoft routing hostname with port if applicable for DFS storage in the primary location.
        /// </summary>
        [Input("primaryDfsMicrosoftHost")]
        public Input<string>? PrimaryDfsMicrosoftHost { get; set; }

        /// <summary>
        /// The endpoint URL for file storage in the primary location.
        /// </summary>
        [Input("primaryFileEndpoint")]
        public Input<string>? PrimaryFileEndpoint { get; set; }

        /// <summary>
        /// The hostname with port if applicable for file storage in the primary location.
        /// </summary>
        [Input("primaryFileHost")]
        public Input<string>? PrimaryFileHost { get; set; }

        /// <summary>
        /// The internet routing endpoint URL for file storage in the primary location.
        /// </summary>
        [Input("primaryFileInternetEndpoint")]
        public Input<string>? PrimaryFileInternetEndpoint { get; set; }

        /// <summary>
        /// The internet routing hostname with port if applicable for file storage in the primary location.
        /// </summary>
        [Input("primaryFileInternetHost")]
        public Input<string>? PrimaryFileInternetHost { get; set; }

        /// <summary>
        /// The microsoft routing endpoint URL for file storage in the primary location.
        /// </summary>
        [Input("primaryFileMicrosoftEndpoint")]
        public Input<string>? PrimaryFileMicrosoftEndpoint { get; set; }

        /// <summary>
        /// The microsoft routing hostname with port if applicable for file storage in the primary location.
        /// </summary>
        [Input("primaryFileMicrosoftHost")]
        public Input<string>? PrimaryFileMicrosoftHost { get; set; }

        /// <summary>
        /// The primary location of the storage account.
        /// </summary>
        [Input("primaryLocation")]
        public Input<string>? PrimaryLocation { get; set; }

        /// <summary>
        /// The endpoint URL for queue storage in the primary location.
        /// </summary>
        [Input("primaryQueueEndpoint")]
        public Input<string>? PrimaryQueueEndpoint { get; set; }

        /// <summary>
        /// The hostname with port if applicable for queue storage in the primary location.
        /// </summary>
        [Input("primaryQueueHost")]
        public Input<string>? PrimaryQueueHost { get; set; }

        /// <summary>
        /// The microsoft routing endpoint URL for queue storage in the primary location.
        /// </summary>
        [Input("primaryQueueMicrosoftEndpoint")]
        public Input<string>? PrimaryQueueMicrosoftEndpoint { get; set; }

        /// <summary>
        /// The microsoft routing hostname with port if applicable for queue storage in the primary location.
        /// </summary>
        [Input("primaryQueueMicrosoftHost")]
        public Input<string>? PrimaryQueueMicrosoftHost { get; set; }

        /// <summary>
        /// The endpoint URL for table storage in the primary location.
        /// </summary>
        [Input("primaryTableEndpoint")]
        public Input<string>? PrimaryTableEndpoint { get; set; }

        /// <summary>
        /// The hostname with port if applicable for table storage in the primary location.
        /// </summary>
        [Input("primaryTableHost")]
        public Input<string>? PrimaryTableHost { get; set; }

        /// <summary>
        /// The microsoft routing endpoint URL for table storage in the primary location.
        /// </summary>
        [Input("primaryTableMicrosoftEndpoint")]
        public Input<string>? PrimaryTableMicrosoftEndpoint { get; set; }

        /// <summary>
        /// The microsoft routing hostname with port if applicable for table storage in the primary location.
        /// </summary>
        [Input("primaryTableMicrosoftHost")]
        public Input<string>? PrimaryTableMicrosoftHost { get; set; }

        /// <summary>
        /// The endpoint URL for web storage in the primary location.
        /// </summary>
        [Input("primaryWebEndpoint")]
        public Input<string>? PrimaryWebEndpoint { get; set; }

        /// <summary>
        /// The hostname with port if applicable for web storage in the primary location.
        /// </summary>
        [Input("primaryWebHost")]
        public Input<string>? PrimaryWebHost { get; set; }

        /// <summary>
        /// The internet routing endpoint URL for web storage in the primary location.
        /// </summary>
        [Input("primaryWebInternetEndpoint")]
        public Input<string>? PrimaryWebInternetEndpoint { get; set; }

        /// <summary>
        /// The internet routing hostname with port if applicable for web storage in the primary location.
        /// </summary>
        [Input("primaryWebInternetHost")]
        public Input<string>? PrimaryWebInternetHost { get; set; }

        /// <summary>
        /// The microsoft routing endpoint URL for web storage in the primary location.
        /// </summary>
        [Input("primaryWebMicrosoftEndpoint")]
        public Input<string>? PrimaryWebMicrosoftEndpoint { get; set; }

        /// <summary>
        /// The microsoft routing hostname with port if applicable for web storage in the primary location.
        /// </summary>
        [Input("primaryWebMicrosoftHost")]
        public Input<string>? PrimaryWebMicrosoftHost { get; set; }

        /// <summary>
        /// Specifies the version of the **provisioned** billing model (e.g. when `AccountKind = "FileStorage"` for Storage File). Possible value is `V2`. Changing this forces a new resource to be created.
        /// </summary>
        [Input("provisionedBillingModelVersion")]
        public Input<string>? ProvisionedBillingModelVersion { get; set; }

        /// <summary>
        /// Whether the public network access is enabled? Defaults to `True`.
        /// </summary>
        [Input("publicNetworkAccessEnabled")]
        public Input<bool>? PublicNetworkAccessEnabled { get; set; }

        /// <summary>
        /// The encryption type of the queue service. Possible values are `Service` and `Account`. Changing this forces a new resource to be created. Default value is `Service`.
        /// </summary>
        [Input("queueEncryptionKeyType")]
        public Input<string>? QueueEncryptionKeyType { get; set; }

        /// <summary>
        /// A `QueueProperties` block as defined below.
        /// 
        /// &gt; **Note:** `QueueProperties` can only be configured when `AccountTier` is set to `Standard` and `AccountKind` is set to either `Storage` or `StorageV2`.
        /// </summary>
        [Input("queueProperties")]
        public Input<Inputs.AccountQueuePropertiesGetArgs>? QueueProperties { get; set; }

        /// <summary>
        /// The name of the resource group in which to create the storage account. Changing this forces a new resource to be created.
        /// </summary>
        [Input("resourceGroupName")]
        public Input<string>? ResourceGroupName { get; set; }

        /// <summary>
        /// A `Routing` block as defined below.
        /// </summary>
        [Input("routing")]
        public Input<Inputs.AccountRoutingGetArgs>? Routing { get; set; }

        /// <summary>
        /// A `SasPolicy` block as defined below.
        /// </summary>
        [Input("sasPolicy")]
        public Input<Inputs.AccountSasPolicyGetArgs>? SasPolicy { get; set; }

        [Input("secondaryAccessKey")]
        private Input<string>? _secondaryAccessKey;

        /// <summary>
        /// The secondary access key for the storage account.
        /// </summary>
        public Input<string>? SecondaryAccessKey
        {
            get => _secondaryAccessKey;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _secondaryAccessKey = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        [Input("secondaryBlobConnectionString")]
        private Input<string>? _secondaryBlobConnectionString;

        /// <summary>
        /// The connection string associated with the secondary blob location.
        /// </summary>
        public Input<string>? SecondaryBlobConnectionString
        {
            get => _secondaryBlobConnectionString;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _secondaryBlobConnectionString = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        /// <summary>
        /// The endpoint URL for blob storage in the secondary location.
        /// </summary>
        [Input("secondaryBlobEndpoint")]
        public Input<string>? SecondaryBlobEndpoint { get; set; }

        /// <summary>
        /// The hostname with port if applicable for blob storage in the secondary location.
        /// </summary>
        [Input("secondaryBlobHost")]
        public Input<string>? SecondaryBlobHost { get; set; }

        /// <summary>
        /// The internet routing endpoint URL for blob storage in the secondary location.
        /// </summary>
        [Input("secondaryBlobInternetEndpoint")]
        public Input<string>? SecondaryBlobInternetEndpoint { get; set; }

        /// <summary>
        /// The internet routing hostname with port if applicable for blob storage in the secondary location.
        /// </summary>
        [Input("secondaryBlobInternetHost")]
        public Input<string>? SecondaryBlobInternetHost { get; set; }

        /// <summary>
        /// The microsoft routing endpoint URL for blob storage in the secondary location.
        /// </summary>
        [Input("secondaryBlobMicrosoftEndpoint")]
        public Input<string>? SecondaryBlobMicrosoftEndpoint { get; set; }

        /// <summary>
        /// The microsoft routing hostname with port if applicable for blob storage in the secondary location.
        /// </summary>
        [Input("secondaryBlobMicrosoftHost")]
        public Input<string>? SecondaryBlobMicrosoftHost { get; set; }

        [Input("secondaryConnectionString")]
        private Input<string>? _secondaryConnectionString;

        /// <summary>
        /// The connection string associated with the secondary location.
        /// </summary>
        public Input<string>? SecondaryConnectionString
        {
            get => _secondaryConnectionString;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _secondaryConnectionString = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        /// <summary>
        /// The endpoint URL for DFS storage in the secondary location.
        /// </summary>
        [Input("secondaryDfsEndpoint")]
        public Input<string>? SecondaryDfsEndpoint { get; set; }

        /// <summary>
        /// The hostname with port if applicable for DFS storage in the secondary location.
        /// </summary>
        [Input("secondaryDfsHost")]
        public Input<string>? SecondaryDfsHost { get; set; }

        /// <summary>
        /// The internet routing endpoint URL for DFS storage in the secondary location.
        /// </summary>
        [Input("secondaryDfsInternetEndpoint")]
        public Input<string>? SecondaryDfsInternetEndpoint { get; set; }

        /// <summary>
        /// The internet routing hostname with port if applicable for DFS storage in the secondary location.
        /// </summary>
        [Input("secondaryDfsInternetHost")]
        public Input<string>? SecondaryDfsInternetHost { get; set; }

        /// <summary>
        /// The microsoft routing endpoint URL for DFS storage in the secondary location.
        /// </summary>
        [Input("secondaryDfsMicrosoftEndpoint")]
        public Input<string>? SecondaryDfsMicrosoftEndpoint { get; set; }

        /// <summary>
        /// The microsoft routing hostname with port if applicable for DFS storage in the secondary location.
        /// </summary>
        [Input("secondaryDfsMicrosoftHost")]
        public Input<string>? SecondaryDfsMicrosoftHost { get; set; }

        /// <summary>
        /// The endpoint URL for file storage in the secondary location.
        /// </summary>
        [Input("secondaryFileEndpoint")]
        public Input<string>? SecondaryFileEndpoint { get; set; }

        /// <summary>
        /// The hostname with port if applicable for file storage in the secondary location.
        /// </summary>
        [Input("secondaryFileHost")]
        public Input<string>? SecondaryFileHost { get; set; }

        /// <summary>
        /// The internet routing endpoint URL for file storage in the secondary location.
        /// </summary>
        [Input("secondaryFileInternetEndpoint")]
        public Input<string>? SecondaryFileInternetEndpoint { get; set; }

        /// <summary>
        /// The internet routing hostname with port if applicable for file storage in the secondary location.
        /// </summary>
        [Input("secondaryFileInternetHost")]
        public Input<string>? SecondaryFileInternetHost { get; set; }

        /// <summary>
        /// The microsoft routing endpoint URL for file storage in the secondary location.
        /// </summary>
        [Input("secondaryFileMicrosoftEndpoint")]
        public Input<string>? SecondaryFileMicrosoftEndpoint { get; set; }

        /// <summary>
        /// The microsoft routing hostname with port if applicable for file storage in the secondary location.
        /// </summary>
        [Input("secondaryFileMicrosoftHost")]
        public Input<string>? SecondaryFileMicrosoftHost { get; set; }

        /// <summary>
        /// The secondary location of the storage account.
        /// </summary>
        [Input("secondaryLocation")]
        public Input<string>? SecondaryLocation { get; set; }

        /// <summary>
        /// The endpoint URL for queue storage in the secondary location.
        /// </summary>
        [Input("secondaryQueueEndpoint")]
        public Input<string>? SecondaryQueueEndpoint { get; set; }

        /// <summary>
        /// The hostname with port if applicable for queue storage in the secondary location.
        /// </summary>
        [Input("secondaryQueueHost")]
        public Input<string>? SecondaryQueueHost { get; set; }

        /// <summary>
        /// The microsoft routing endpoint URL for queue storage in the secondary location.
        /// </summary>
        [Input("secondaryQueueMicrosoftEndpoint")]
        public Input<string>? SecondaryQueueMicrosoftEndpoint { get; set; }

        /// <summary>
        /// The microsoft routing hostname with port if applicable for queue storage in the secondary location.
        /// </summary>
        [Input("secondaryQueueMicrosoftHost")]
        public Input<string>? SecondaryQueueMicrosoftHost { get; set; }

        /// <summary>
        /// The endpoint URL for table storage in the secondary location.
        /// </summary>
        [Input("secondaryTableEndpoint")]
        public Input<string>? SecondaryTableEndpoint { get; set; }

        /// <summary>
        /// The hostname with port if applicable for table storage in the secondary location.
        /// </summary>
        [Input("secondaryTableHost")]
        public Input<string>? SecondaryTableHost { get; set; }

        /// <summary>
        /// The microsoft routing endpoint URL for table storage in the secondary location.
        /// </summary>
        [Input("secondaryTableMicrosoftEndpoint")]
        public Input<string>? SecondaryTableMicrosoftEndpoint { get; set; }

        /// <summary>
        /// The microsoft routing hostname with port if applicable for table storage in the secondary location.
        /// </summary>
        [Input("secondaryTableMicrosoftHost")]
        public Input<string>? SecondaryTableMicrosoftHost { get; set; }

        /// <summary>
        /// The endpoint URL for web storage in the secondary location.
        /// </summary>
        [Input("secondaryWebEndpoint")]
        public Input<string>? SecondaryWebEndpoint { get; set; }

        /// <summary>
        /// The hostname with port if applicable for web storage in the secondary location.
        /// </summary>
        [Input("secondaryWebHost")]
        public Input<string>? SecondaryWebHost { get; set; }

        /// <summary>
        /// The internet routing endpoint URL for web storage in the secondary location.
        /// </summary>
        [Input("secondaryWebInternetEndpoint")]
        public Input<string>? SecondaryWebInternetEndpoint { get; set; }

        /// <summary>
        /// The internet routing hostname with port if applicable for web storage in the secondary location.
        /// </summary>
        [Input("secondaryWebInternetHost")]
        public Input<string>? SecondaryWebInternetHost { get; set; }

        /// <summary>
        /// The microsoft routing endpoint URL for web storage in the secondary location.
        /// </summary>
        [Input("secondaryWebMicrosoftEndpoint")]
        public Input<string>? SecondaryWebMicrosoftEndpoint { get; set; }

        /// <summary>
        /// The microsoft routing hostname with port if applicable for web storage in the secondary location.
        /// </summary>
        [Input("secondaryWebMicrosoftHost")]
        public Input<string>? SecondaryWebMicrosoftHost { get; set; }

        /// <summary>
        /// Boolean, enable SFTP for the storage account
        /// 
        /// &gt; **Note:** SFTP support requires `IsHnsEnabled` set to `True`. [More information on SFTP support can be found here](https://learn.microsoft.com/azure/storage/blobs/secure-file-transfer-protocol-support). Defaults to `False`
        /// </summary>
        [Input("sftpEnabled")]
        public Input<bool>? SftpEnabled { get; set; }

        /// <summary>
        /// A `ShareProperties` block as defined below.
        /// 
        /// &gt; **Note:** `ShareProperties` can only be configured when either `AccountTier` is `Standard` and `AccountKind` is either `Storage` or `StorageV2` - or when `AccountTier` is `Premium` and `AccountKind` is `FileStorage`.
        /// </summary>
        [Input("shareProperties")]
        public Input<Inputs.AccountSharePropertiesGetArgs>? ShareProperties { get; set; }

        /// <summary>
        /// Indicates whether the storage account permits requests to be authorized with the account access key via Shared Key. If false, then all requests, including shared access signatures, must be authorized with Azure Active Directory (Azure AD). Defaults to `True`.
        /// 
        /// &gt; **Note:** Terraform uses Shared Key Authorisation to provision Storage Containers, Blobs and other items - when Shared Key Access is disabled, you will need to enable the `StorageUseAzuread` flag in the Provider block to use Azure AD for authentication, however not all Azure Storage services support Active Directory authentication.
        /// </summary>
        [Input("sharedAccessKeyEnabled")]
        public Input<bool>? SharedAccessKeyEnabled { get; set; }

        /// <summary>
        /// A `StaticWebsite` block as defined below.
        /// 
        /// &gt; **Note:** `StaticWebsite` can only be set when the `AccountKind` is set to `StorageV2` or `BlockBlobStorage`.
        /// 
        /// &gt; **Note:** If `StaticWebsite` is specified, the service will automatically create a `azure.storage.Container` named `$web`.
        /// </summary>
        [Input("staticWebsite")]
        public Input<Inputs.AccountStaticWebsiteGetArgs>? StaticWebsite { get; set; }

        /// <summary>
        /// The encryption type of the table service. Possible values are `Service` and `Account`. Changing this forces a new resource to be created. Default value is `Service`.
        /// 
        /// &gt; **Note:** `QueueEncryptionKeyType` and `TableEncryptionKeyType` cannot be set to `Account` when `AccountKind` is set `Storage`
        /// </summary>
        [Input("tableEncryptionKeyType")]
        public Input<string>? TableEncryptionKeyType { get; set; }

        [Input("tags")]
        private InputMap<string>? _tags;

        /// <summary>
        /// A mapping of tags to assign to the resource.
        /// </summary>
        public InputMap<string> Tags
        {
            get => _tags ?? (_tags = new InputMap<string>());
            set => _tags = value;
        }

        public AccountState()
        {
        }
        public static new AccountState Empty => new AccountState();
    }
}
