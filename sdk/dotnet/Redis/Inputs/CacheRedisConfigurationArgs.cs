// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Azure.Redis.Inputs
{

    public sealed class CacheRedisConfigurationArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Enable Microsoft Entra (AAD) authentication. Defaults to `false`.
        /// </summary>
        [Input("activeDirectoryAuthenticationEnabled")]
        public Input<bool>? ActiveDirectoryAuthenticationEnabled { get; set; }

        /// <summary>
        /// Enable or disable AOF persistence for this Redis Cache. Defaults to `false`.
        /// 
        /// &gt; **Note:** `aof_backup_enabled` can only be set when SKU is `Premium`.
        /// </summary>
        [Input("aofBackupEnabled")]
        public Input<bool>? AofBackupEnabled { get; set; }

        [Input("aofStorageConnectionString0")]
        private Input<string>? _aofStorageConnectionString0;

        /// <summary>
        /// First Storage Account connection string for AOF persistence.
        /// </summary>
        public Input<string>? AofStorageConnectionString0
        {
            get => _aofStorageConnectionString0;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _aofStorageConnectionString0 = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        [Input("aofStorageConnectionString1")]
        private Input<string>? _aofStorageConnectionString1;

        /// <summary>
        /// Second Storage Account connection string for AOF persistence.
        /// 
        /// Example usage:
        /// </summary>
        public Input<string>? AofStorageConnectionString1
        {
            get => _aofStorageConnectionString1;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _aofStorageConnectionString1 = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        /// <summary>
        /// If set to `false`, the Redis instance will be accessible without authentication. Defaults to `true`.
        /// 
        /// &gt; **Note:** `authentication_enabled` can only be set to `false` if a `subnet_id` is specified; and only works if there aren't existing instances within the subnet with `authentication_enabled` set to `true`.
        /// </summary>
        [Input("authenticationEnabled")]
        public Input<bool>? AuthenticationEnabled { get; set; }

        /// <summary>
        /// Preferred auth method to communicate to storage account used for data persistence. Possible values are `SAS` and `ManagedIdentity`.
        /// </summary>
        [Input("dataPersistenceAuthenticationMethod")]
        public Input<string>? DataPersistenceAuthenticationMethod { get; set; }

        /// <summary>
        /// Returns the max number of connected clients at the same time.
        /// </summary>
        [Input("maxclients")]
        public Input<int>? Maxclients { get; set; }

        /// <summary>
        /// Value in megabytes reserved to accommodate for memory fragmentation. Defaults are shown below.
        /// </summary>
        [Input("maxfragmentationmemoryReserved")]
        public Input<int>? MaxfragmentationmemoryReserved { get; set; }

        /// <summary>
        /// The max-memory delta for this Redis instance. Defaults are shown below.
        /// </summary>
        [Input("maxmemoryDelta")]
        public Input<int>? MaxmemoryDelta { get; set; }

        /// <summary>
        /// How Redis will select what to remove when `maxmemory` is reached. Defaults to `volatile-lru`.
        /// </summary>
        [Input("maxmemoryPolicy")]
        public Input<string>? MaxmemoryPolicy { get; set; }

        /// <summary>
        /// Value in megabytes reserved for non-cache usage e.g. failover. Defaults are shown below.
        /// </summary>
        [Input("maxmemoryReserved")]
        public Input<int>? MaxmemoryReserved { get; set; }

        /// <summary>
        /// Keyspace notifications allows clients to subscribe to Pub/Sub channels in order to receive events affecting the Redis data set in some way. [Reference](https://redis.io/topics/notifications#configuration)
        /// </summary>
        [Input("notifyKeyspaceEvents")]
        public Input<string>? NotifyKeyspaceEvents { get; set; }

        /// <summary>
        /// Is Backup Enabled? Only supported on Premium SKUs. Defaults to `false`.
        /// 
        /// &gt; **Note:** If `rdb_backup_enabled` set to `true`, `rdb_storage_connection_string` must also be set.
        /// </summary>
        [Input("rdbBackupEnabled")]
        public Input<bool>? RdbBackupEnabled { get; set; }

        /// <summary>
        /// The Backup Frequency in Minutes. Only supported on Premium SKUs. Possible values are: `15`, `30`, `60`, `360`, `720` and `1440`.
        /// </summary>
        [Input("rdbBackupFrequency")]
        public Input<int>? RdbBackupFrequency { get; set; }

        /// <summary>
        /// The maximum number of snapshots to create as a backup. Only supported for Premium SKUs.
        /// </summary>
        [Input("rdbBackupMaxSnapshotCount")]
        public Input<int>? RdbBackupMaxSnapshotCount { get; set; }

        [Input("rdbStorageConnectionString")]
        private Input<string>? _rdbStorageConnectionString;

        /// <summary>
        /// The Connection String to the Storage Account. Only supported for Premium SKUs. In the format: `DefaultEndpointsProtocol=https;BlobEndpoint=${azurerm_storage_account.example.primary_blob_endpoint};AccountName=${azurerm_storage_account.example.name};AccountKey=${azurerm_storage_account.example.primary_access_key}`.
        /// 
        /// &gt; **Note:** There's a bug in the Redis API where the original storage connection string isn't being returned, which [is being tracked in this issue](https://github.com/Azure/azure-rest-api-specs/issues/3037). In the interim you can use the `ignore_changes` attribute to ignore changes to this field e.g.:
        /// </summary>
        public Input<string>? RdbStorageConnectionString
        {
            get => _rdbStorageConnectionString;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _rdbStorageConnectionString = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        /// <summary>
        /// The ID of the Subscription containing the Storage Account.
        /// </summary>
        [Input("storageAccountSubscriptionId")]
        public Input<string>? StorageAccountSubscriptionId { get; set; }

        public CacheRedisConfigurationArgs()
        {
        }
        public static new CacheRedisConfigurationArgs Empty => new CacheRedisConfigurationArgs();
    }
}
