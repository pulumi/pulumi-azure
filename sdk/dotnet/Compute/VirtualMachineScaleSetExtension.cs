// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Azure.Compute
{
    /// <summary>
    /// Manages an Extension for a Virtual Machine Scale Set.
    /// 
    /// &gt; **NOTE:** This resource is not intended to be used with the `azure.compute.ScaleSet` resource - instead it's intended for this to be used with the `azure.compute.LinuxVirtualMachineScaleSet` and `azure.compute.WindowsVirtualMachineScaleSet` resources.
    /// 
    /// ## Example Usage
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using System.Text.Json;
    /// using Pulumi;
    /// using Azure = Pulumi.Azure;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var exampleResourceGroup = new Azure.Core.ResourceGroup("exampleResourceGroup", new()
    ///     {
    ///         Location = "West Europe",
    ///     });
    /// 
    ///     var exampleLinuxVirtualMachineScaleSet = new Azure.Compute.LinuxVirtualMachineScaleSet("exampleLinuxVirtualMachineScaleSet", new()
    ///     {
    ///         ResourceGroupName = exampleResourceGroup.Name,
    ///         Location = exampleResourceGroup.Location,
    ///         Sku = "Standard_F2",
    ///         AdminUsername = "adminuser",
    ///         Instances = 1,
    ///         NetworkInterfaces = new[]
    ///         {
    ///             new Azure.Compute.Inputs.LinuxVirtualMachineScaleSetNetworkInterfaceArgs
    ///             {
    ///                 Name = "example",
    ///                 IpConfigurations = new[]
    ///                 {
    ///                     new Azure.Compute.Inputs.LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs
    ///                     {
    ///                         Name = "internal",
    ///                     },
    ///                 },
    ///             },
    ///         },
    ///         OsDisk = new Azure.Compute.Inputs.LinuxVirtualMachineScaleSetOsDiskArgs
    ///         {
    ///             StorageAccountType = "Standard_LRS",
    ///             Caching = "ReadWrite",
    ///         },
    ///     });
    /// 
    ///     var exampleVirtualMachineScaleSetExtension = new Azure.Compute.VirtualMachineScaleSetExtension("exampleVirtualMachineScaleSetExtension", new()
    ///     {
    ///         VirtualMachineScaleSetId = exampleLinuxVirtualMachineScaleSet.Id,
    ///         Publisher = "Microsoft.Azure.Extensions",
    ///         Type = "CustomScript",
    ///         TypeHandlerVersion = "2.0",
    ///         Settings = JsonSerializer.Serialize(new Dictionary&lt;string, object?&gt;
    ///         {
    ///             ["commandToExecute"] = "echo $HOSTNAME",
    ///         }),
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## Import
    /// 
    /// Virtual Machine Scale Set Extensions can be imported using the `resource id`, e.g.
    /// 
    /// ```sh
    ///  $ pulumi import azure:compute/virtualMachineScaleSetExtension:VirtualMachineScaleSetExtension test /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/group1/providers/Microsoft.Compute/virtualMachineScaleSets/scaleSet1/extensions/extension1
    /// ```
    /// </summary>
    [AzureResourceType("azure:compute/virtualMachineScaleSetExtension:VirtualMachineScaleSetExtension")]
    public partial class VirtualMachineScaleSetExtension : global::Pulumi.CustomResource
    {
        /// <summary>
        /// Should the latest version of the Extension be used at Deployment Time, if one is available? This won't auto-update the extension on existing installation. Defaults to `true`.
        /// </summary>
        [Output("autoUpgradeMinorVersion")]
        public Output<bool?> AutoUpgradeMinorVersion { get; private set; } = null!;

        /// <summary>
        /// Should the Extension be automatically updated whenever the Publisher releases a new version of this VM Extension?
        /// </summary>
        [Output("automaticUpgradeEnabled")]
        public Output<bool?> AutomaticUpgradeEnabled { get; private set; } = null!;

        /// <summary>
        /// Should failures from the extension be suppressed? Possible values are `true` or `false`. Defaults to `false`.
        /// 
        /// &gt; **NOTE:** Operational failures such as not connecting to the VM will not be suppressed regardless of the `failure_suppression_enabled` value.
        /// </summary>
        [Output("failureSuppressionEnabled")]
        public Output<bool?> FailureSuppressionEnabled { get; private set; } = null!;

        /// <summary>
        /// A value which, when different to the previous value can be used to force-run the Extension even if the Extension Configuration hasn't changed.
        /// </summary>
        [Output("forceUpdateTag")]
        public Output<string?> ForceUpdateTag { get; private set; } = null!;

        /// <summary>
        /// The name for the Virtual Machine Scale Set Extension. Changing this forces a new resource to be created.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// A JSON String which specifies Sensitive Settings (such as Passwords) for the Extension.
        /// 
        /// &gt; **NOTE:** Keys within the `protected_settings` block are notoriously case-sensitive, where the casing required (e.g. TitleCase vs snakeCase) depends on the Extension being used. Please refer to the documentation for the specific Virtual Machine Extension you're looking to use for more information.
        /// </summary>
        [Output("protectedSettings")]
        public Output<string?> ProtectedSettings { get; private set; } = null!;

        /// <summary>
        /// A `protected_settings_from_key_vault` block as defined below.
        /// 
        /// &gt; **Note:** `protected_settings_from_key_vault` cannot be used with `protected_settings`
        /// </summary>
        [Output("protectedSettingsFromKeyVault")]
        public Output<Outputs.VirtualMachineScaleSetExtensionProtectedSettingsFromKeyVault?> ProtectedSettingsFromKeyVault { get; private set; } = null!;

        /// <summary>
        /// An ordered list of Extension names which this should be provisioned after.
        /// </summary>
        [Output("provisionAfterExtensions")]
        public Output<ImmutableArray<string>> ProvisionAfterExtensions { get; private set; } = null!;

        /// <summary>
        /// Specifies the Publisher of the Extension. Changing this forces a new resource to be created.
        /// </summary>
        [Output("publisher")]
        public Output<string> Publisher { get; private set; } = null!;

        /// <summary>
        /// A JSON String which specifies Settings for the Extension.
        /// 
        /// &gt; **NOTE:** Keys within the `settings` block are notoriously case-sensitive, where the casing required (e.g. TitleCase vs snakeCase) depends on the Extension being used. Please refer to the documentation for the specific Virtual Machine Extension you're looking to use for more information.
        /// </summary>
        [Output("settings")]
        public Output<string?> Settings { get; private set; } = null!;

        /// <summary>
        /// Specifies the Type of the Extension. Changing this forces a new resource to be created.
        /// </summary>
        [Output("type")]
        public Output<string> Type { get; private set; } = null!;

        /// <summary>
        /// Specifies the version of the extension to use, available versions can be found using the Azure CLI.
        /// 
        /// &gt; **Note:** The `Publisher` and `Type` of Virtual Machine Scale Set Extensions can be found using the Azure CLI, via:
        /// 
        /// ```csharp
        /// using System.Collections.Generic;
        /// using System.Linq;
        /// using Pulumi;
        /// 
        /// return await Deployment.RunAsync(() =&gt; 
        /// {
        /// });
        /// ```
        /// </summary>
        [Output("typeHandlerVersion")]
        public Output<string> TypeHandlerVersion { get; private set; } = null!;

        /// <summary>
        /// The ID of the Virtual Machine Scale Set. Changing this forces a new resource to be created.
        /// 
        /// &gt; **NOTE:** This should be the ID from the `azure.compute.LinuxVirtualMachineScaleSet` or `azure.compute.WindowsVirtualMachineScaleSet` resource - when using the older `azure.compute.ScaleSet` resource extensions should instead be defined inline.
        /// </summary>
        [Output("virtualMachineScaleSetId")]
        public Output<string> VirtualMachineScaleSetId { get; private set; } = null!;


        /// <summary>
        /// Create a VirtualMachineScaleSetExtension resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public VirtualMachineScaleSetExtension(string name, VirtualMachineScaleSetExtensionArgs args, CustomResourceOptions? options = null)
            : base("azure:compute/virtualMachineScaleSetExtension:VirtualMachineScaleSetExtension", name, args ?? new VirtualMachineScaleSetExtensionArgs(), MakeResourceOptions(options, ""))
        {
        }

        private VirtualMachineScaleSetExtension(string name, Input<string> id, VirtualMachineScaleSetExtensionState? state = null, CustomResourceOptions? options = null)
            : base("azure:compute/virtualMachineScaleSetExtension:VirtualMachineScaleSetExtension", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                AdditionalSecretOutputs =
                {
                    "protectedSettings",
                },
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing VirtualMachineScaleSetExtension resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static VirtualMachineScaleSetExtension Get(string name, Input<string> id, VirtualMachineScaleSetExtensionState? state = null, CustomResourceOptions? options = null)
        {
            return new VirtualMachineScaleSetExtension(name, id, state, options);
        }
    }

    public sealed class VirtualMachineScaleSetExtensionArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Should the latest version of the Extension be used at Deployment Time, if one is available? This won't auto-update the extension on existing installation. Defaults to `true`.
        /// </summary>
        [Input("autoUpgradeMinorVersion")]
        public Input<bool>? AutoUpgradeMinorVersion { get; set; }

        /// <summary>
        /// Should the Extension be automatically updated whenever the Publisher releases a new version of this VM Extension?
        /// </summary>
        [Input("automaticUpgradeEnabled")]
        public Input<bool>? AutomaticUpgradeEnabled { get; set; }

        /// <summary>
        /// Should failures from the extension be suppressed? Possible values are `true` or `false`. Defaults to `false`.
        /// 
        /// &gt; **NOTE:** Operational failures such as not connecting to the VM will not be suppressed regardless of the `failure_suppression_enabled` value.
        /// </summary>
        [Input("failureSuppressionEnabled")]
        public Input<bool>? FailureSuppressionEnabled { get; set; }

        /// <summary>
        /// A value which, when different to the previous value can be used to force-run the Extension even if the Extension Configuration hasn't changed.
        /// </summary>
        [Input("forceUpdateTag")]
        public Input<string>? ForceUpdateTag { get; set; }

        /// <summary>
        /// The name for the Virtual Machine Scale Set Extension. Changing this forces a new resource to be created.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("protectedSettings")]
        private Input<string>? _protectedSettings;

        /// <summary>
        /// A JSON String which specifies Sensitive Settings (such as Passwords) for the Extension.
        /// 
        /// &gt; **NOTE:** Keys within the `protected_settings` block are notoriously case-sensitive, where the casing required (e.g. TitleCase vs snakeCase) depends on the Extension being used. Please refer to the documentation for the specific Virtual Machine Extension you're looking to use for more information.
        /// </summary>
        public Input<string>? ProtectedSettings
        {
            get => _protectedSettings;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _protectedSettings = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        /// <summary>
        /// A `protected_settings_from_key_vault` block as defined below.
        /// 
        /// &gt; **Note:** `protected_settings_from_key_vault` cannot be used with `protected_settings`
        /// </summary>
        [Input("protectedSettingsFromKeyVault")]
        public Input<Inputs.VirtualMachineScaleSetExtensionProtectedSettingsFromKeyVaultArgs>? ProtectedSettingsFromKeyVault { get; set; }

        [Input("provisionAfterExtensions")]
        private InputList<string>? _provisionAfterExtensions;

        /// <summary>
        /// An ordered list of Extension names which this should be provisioned after.
        /// </summary>
        public InputList<string> ProvisionAfterExtensions
        {
            get => _provisionAfterExtensions ?? (_provisionAfterExtensions = new InputList<string>());
            set => _provisionAfterExtensions = value;
        }

        /// <summary>
        /// Specifies the Publisher of the Extension. Changing this forces a new resource to be created.
        /// </summary>
        [Input("publisher", required: true)]
        public Input<string> Publisher { get; set; } = null!;

        /// <summary>
        /// A JSON String which specifies Settings for the Extension.
        /// 
        /// &gt; **NOTE:** Keys within the `settings` block are notoriously case-sensitive, where the casing required (e.g. TitleCase vs snakeCase) depends on the Extension being used. Please refer to the documentation for the specific Virtual Machine Extension you're looking to use for more information.
        /// </summary>
        [Input("settings")]
        public Input<string>? Settings { get; set; }

        /// <summary>
        /// Specifies the Type of the Extension. Changing this forces a new resource to be created.
        /// </summary>
        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// Specifies the version of the extension to use, available versions can be found using the Azure CLI.
        /// 
        /// &gt; **Note:** The `Publisher` and `Type` of Virtual Machine Scale Set Extensions can be found using the Azure CLI, via:
        /// 
        /// ```csharp
        /// using System.Collections.Generic;
        /// using System.Linq;
        /// using Pulumi;
        /// 
        /// return await Deployment.RunAsync(() =&gt; 
        /// {
        /// });
        /// ```
        /// </summary>
        [Input("typeHandlerVersion", required: true)]
        public Input<string> TypeHandlerVersion { get; set; } = null!;

        /// <summary>
        /// The ID of the Virtual Machine Scale Set. Changing this forces a new resource to be created.
        /// 
        /// &gt; **NOTE:** This should be the ID from the `azure.compute.LinuxVirtualMachineScaleSet` or `azure.compute.WindowsVirtualMachineScaleSet` resource - when using the older `azure.compute.ScaleSet` resource extensions should instead be defined inline.
        /// </summary>
        [Input("virtualMachineScaleSetId", required: true)]
        public Input<string> VirtualMachineScaleSetId { get; set; } = null!;

        public VirtualMachineScaleSetExtensionArgs()
        {
        }
        public static new VirtualMachineScaleSetExtensionArgs Empty => new VirtualMachineScaleSetExtensionArgs();
    }

    public sealed class VirtualMachineScaleSetExtensionState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Should the latest version of the Extension be used at Deployment Time, if one is available? This won't auto-update the extension on existing installation. Defaults to `true`.
        /// </summary>
        [Input("autoUpgradeMinorVersion")]
        public Input<bool>? AutoUpgradeMinorVersion { get; set; }

        /// <summary>
        /// Should the Extension be automatically updated whenever the Publisher releases a new version of this VM Extension?
        /// </summary>
        [Input("automaticUpgradeEnabled")]
        public Input<bool>? AutomaticUpgradeEnabled { get; set; }

        /// <summary>
        /// Should failures from the extension be suppressed? Possible values are `true` or `false`. Defaults to `false`.
        /// 
        /// &gt; **NOTE:** Operational failures such as not connecting to the VM will not be suppressed regardless of the `failure_suppression_enabled` value.
        /// </summary>
        [Input("failureSuppressionEnabled")]
        public Input<bool>? FailureSuppressionEnabled { get; set; }

        /// <summary>
        /// A value which, when different to the previous value can be used to force-run the Extension even if the Extension Configuration hasn't changed.
        /// </summary>
        [Input("forceUpdateTag")]
        public Input<string>? ForceUpdateTag { get; set; }

        /// <summary>
        /// The name for the Virtual Machine Scale Set Extension. Changing this forces a new resource to be created.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("protectedSettings")]
        private Input<string>? _protectedSettings;

        /// <summary>
        /// A JSON String which specifies Sensitive Settings (such as Passwords) for the Extension.
        /// 
        /// &gt; **NOTE:** Keys within the `protected_settings` block are notoriously case-sensitive, where the casing required (e.g. TitleCase vs snakeCase) depends on the Extension being used. Please refer to the documentation for the specific Virtual Machine Extension you're looking to use for more information.
        /// </summary>
        public Input<string>? ProtectedSettings
        {
            get => _protectedSettings;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _protectedSettings = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        /// <summary>
        /// A `protected_settings_from_key_vault` block as defined below.
        /// 
        /// &gt; **Note:** `protected_settings_from_key_vault` cannot be used with `protected_settings`
        /// </summary>
        [Input("protectedSettingsFromKeyVault")]
        public Input<Inputs.VirtualMachineScaleSetExtensionProtectedSettingsFromKeyVaultGetArgs>? ProtectedSettingsFromKeyVault { get; set; }

        [Input("provisionAfterExtensions")]
        private InputList<string>? _provisionAfterExtensions;

        /// <summary>
        /// An ordered list of Extension names which this should be provisioned after.
        /// </summary>
        public InputList<string> ProvisionAfterExtensions
        {
            get => _provisionAfterExtensions ?? (_provisionAfterExtensions = new InputList<string>());
            set => _provisionAfterExtensions = value;
        }

        /// <summary>
        /// Specifies the Publisher of the Extension. Changing this forces a new resource to be created.
        /// </summary>
        [Input("publisher")]
        public Input<string>? Publisher { get; set; }

        /// <summary>
        /// A JSON String which specifies Settings for the Extension.
        /// 
        /// &gt; **NOTE:** Keys within the `settings` block are notoriously case-sensitive, where the casing required (e.g. TitleCase vs snakeCase) depends on the Extension being used. Please refer to the documentation for the specific Virtual Machine Extension you're looking to use for more information.
        /// </summary>
        [Input("settings")]
        public Input<string>? Settings { get; set; }

        /// <summary>
        /// Specifies the Type of the Extension. Changing this forces a new resource to be created.
        /// </summary>
        [Input("type")]
        public Input<string>? Type { get; set; }

        /// <summary>
        /// Specifies the version of the extension to use, available versions can be found using the Azure CLI.
        /// 
        /// &gt; **Note:** The `Publisher` and `Type` of Virtual Machine Scale Set Extensions can be found using the Azure CLI, via:
        /// 
        /// ```csharp
        /// using System.Collections.Generic;
        /// using System.Linq;
        /// using Pulumi;
        /// 
        /// return await Deployment.RunAsync(() =&gt; 
        /// {
        /// });
        /// ```
        /// </summary>
        [Input("typeHandlerVersion")]
        public Input<string>? TypeHandlerVersion { get; set; }

        /// <summary>
        /// The ID of the Virtual Machine Scale Set. Changing this forces a new resource to be created.
        /// 
        /// &gt; **NOTE:** This should be the ID from the `azure.compute.LinuxVirtualMachineScaleSet` or `azure.compute.WindowsVirtualMachineScaleSet` resource - when using the older `azure.compute.ScaleSet` resource extensions should instead be defined inline.
        /// </summary>
        [Input("virtualMachineScaleSetId")]
        public Input<string>? VirtualMachineScaleSetId { get; set; }

        public VirtualMachineScaleSetExtensionState()
        {
        }
        public static new VirtualMachineScaleSetExtensionState Empty => new VirtualMachineScaleSetExtensionState();
    }
}
