// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Azure.Compute
{
    /// <summary>
    /// Manages an implicit Data Disk of a Virtual Machine.
    /// 
    /// &gt; **Note:** The Implicit Data Disk will be deleted instantly after this resource is destroyed. If you want to detach this disk only, you may set `DetachImplicitDataDiskOnDeletion` field to `True` within the `VirtualMachine` block in the provider `Features` block.
    /// 
    /// ## Example Usage
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Azure = Pulumi.Azure;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var config = new Config();
    ///     var prefix = config.Get("prefix") ?? "example";
    ///     var vmName = $"{prefix}-vm";
    /// 
    ///     var example = new Azure.Core.ResourceGroup("example", new()
    ///     {
    ///         Name = $"{prefix}-resources",
    ///         Location = "West Europe",
    ///     });
    /// 
    ///     var main = new Azure.Network.VirtualNetwork("main", new()
    ///     {
    ///         Name = $"{prefix}-network",
    ///         AddressSpaces = new[]
    ///         {
    ///             "10.0.0.0/16",
    ///         },
    ///         Location = example.Location,
    ///         ResourceGroupName = example.Name,
    ///     });
    /// 
    ///     var @internal = new Azure.Network.Subnet("internal", new()
    ///     {
    ///         Name = "internal",
    ///         ResourceGroupName = example.Name,
    ///         VirtualNetworkName = main.Name,
    ///         AddressPrefixes = new[]
    ///         {
    ///             "10.0.2.0/24",
    ///         },
    ///     });
    /// 
    ///     var mainNetworkInterface = new Azure.Network.NetworkInterface("main", new()
    ///     {
    ///         Name = $"{prefix}-nic",
    ///         Location = example.Location,
    ///         ResourceGroupName = example.Name,
    ///         IpConfigurations = new[]
    ///         {
    ///             new Azure.Network.Inputs.NetworkInterfaceIpConfigurationArgs
    ///             {
    ///                 Name = "internal",
    ///                 SubnetId = @internal.Id,
    ///                 PrivateIpAddressAllocation = "Dynamic",
    ///             },
    ///         },
    ///     });
    /// 
    ///     var exampleVirtualMachine = new Azure.Compute.VirtualMachine("example", new()
    ///     {
    ///         Name = vmName,
    ///         Location = example.Location,
    ///         ResourceGroupName = example.Name,
    ///         NetworkInterfaceIds = new[]
    ///         {
    ///             mainNetworkInterface.Id,
    ///         },
    ///         VmSize = "Standard_F2",
    ///         StorageImageReference = new Azure.Compute.Inputs.VirtualMachineStorageImageReferenceArgs
    ///         {
    ///             Publisher = "Canonical",
    ///             Offer = "0001-com-ubuntu-server-jammy",
    ///             Sku = "22_04-lts",
    ///             Version = "latest",
    ///         },
    ///         StorageOsDisk = new Azure.Compute.Inputs.VirtualMachineStorageOsDiskArgs
    ///         {
    ///             Name = "myosdisk1",
    ///             Caching = "ReadWrite",
    ///             CreateOption = "FromImage",
    ///             ManagedDiskType = "Standard_LRS",
    ///         },
    ///         OsProfile = new Azure.Compute.Inputs.VirtualMachineOsProfileArgs
    ///         {
    ///             ComputerName = vmName,
    ///             AdminUsername = "testadmin",
    ///             AdminPassword = "Password1234!",
    ///         },
    ///         OsProfileLinuxConfig = new Azure.Compute.Inputs.VirtualMachineOsProfileLinuxConfigArgs
    ///         {
    ///             DisablePasswordAuthentication = false,
    ///         },
    ///     });
    /// 
    ///     var exampleManagedDisk = new Azure.Compute.ManagedDisk("example", new()
    ///     {
    ///         Name = $"{vmName}-disk1",
    ///         Location = example.Location,
    ///         ResourceGroupName = example.Name,
    ///         StorageAccountType = "Standard_LRS",
    ///         CreateOption = "Empty",
    ///         DiskSizeGb = 10,
    ///     });
    /// 
    ///     var exampleSnapshot = new Azure.Compute.Snapshot("example", new()
    ///     {
    ///         Name = $"{vmName}-snapshot1",
    ///         Location = example.Location,
    ///         ResourceGroupName = example.Name,
    ///         CreateOption = "Copy",
    ///         SourceUri = exampleManagedDisk.Id,
    ///     });
    /// 
    ///     var exampleImplicitDataDiskFromSource = new Azure.Compute.ImplicitDataDiskFromSource("example", new()
    ///     {
    ///         Name = $"{vmName}-implicitdisk1",
    ///         VirtualMachineId = testAzurermVirtualMachine.Id,
    ///         Lun = 0,
    ///         Caching = "None",
    ///         CreateOption = "Copy",
    ///         DiskSizeGb = 20,
    ///         SourceResourceId = test.Id,
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## API Providers
    /// 
    /// &lt;!-- This section is generated, changes will be overwritten --&gt;
    /// This resource uses the following Azure API Providers:
    /// 
    /// * `Microsoft.Compute` - 2024-03-01, 2023-04-02
    /// 
    /// ## Import
    /// 
    /// The implicit Data Disk of the Virtual Machine can be imported using the `resource id`, e.g.
    /// 
    /// ```sh
    /// $ pulumi import azure:compute/implicitDataDiskFromSource:ImplicitDataDiskFromSource example /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/mygroup1/providers/Microsoft.Compute/virtualMachines/machine1/dataDisks/disk1
    /// ```
    /// 
    /// &gt; **Note:** This is a Terraform Unique ID matching the format: `{virtualMachineID}/dataDisks/{diskName}`
    /// </summary>
    [AzureResourceType("azure:compute/implicitDataDiskFromSource:ImplicitDataDiskFromSource")]
    public partial class ImplicitDataDiskFromSource : global::Pulumi.CustomResource
    {
        /// <summary>
        /// Specifies the caching requirements for this Data Disk. Possible values are `ReadOnly` and `ReadWrite`.
        /// </summary>
        [Output("caching")]
        public Output<string?> Caching { get; private set; } = null!;

        /// <summary>
        /// Specifies the Create Option of the Data Disk. The only possible value is `Copy`. Changing this forces a new resource to be created.
        /// </summary>
        [Output("createOption")]
        public Output<string> CreateOption { get; private set; } = null!;

        /// <summary>
        /// Specifies the size of the Data Disk in gigabytes.
        /// 
        /// &gt; **Note:** Updating `DiskSizeGb` to shrink the disk size is not supported on Azure and forces a new Data Disk to be created.
        /// 
        /// &gt; **Note:** In certain conditions the Data Disk size can be updated without shutting down the Virtual Machine, however only a subset of Virtual Machine SKUs/Disk combinations support this. More information can be found [for Linux Virtual Machines](https://learn.microsoft.com/en-us/azure/virtual-machines/linux/expand-disks?tabs=azure-cli%2Cubuntu#expand-without-downtime) and [Windows Virtual Machines](https://learn.microsoft.com/azure/virtual-machines/windows/expand-os-disk#expand-without-downtime) respectively.
        /// 
        /// &gt; **Note:** If the VM does not meet the requirements to expand the disk without downtime, changing this value is disruptive. The VM will be shut down and deallocated as required by Azure to action the change. Terraform will attempt to start the VM again after the update if it was in a `Running` state prior to the change.
        /// 
        /// &gt; **Note:** Expanding Ultra Disks and Premium SSD v2 disks without downtime has additional limitations. Allow up to 10 minutes for the correct size to be reflected, and a `Rescan` function may be required. For more details, refer to [Expand with Ultra Disks and Premium SSD v2](https://learn.microsoft.com/azure/virtual-machines/linux/expand-disks?tabs=ubuntu#expand-with-ultra-disks-and-premium-ssd-v2).
        /// </summary>
        [Output("diskSizeGb")]
        public Output<int> DiskSizeGb { get; private set; } = null!;

        /// <summary>
        /// The Logical Unit Number of the Data Disk, which needs to be unique within the Virtual Machine. Changing this forces a new resource to be created.
        /// </summary>
        [Output("lun")]
        public Output<int> Lun { get; private set; } = null!;

        /// <summary>
        /// Specifies the name of this Data Disk. Changing this forces a new resource to be created.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// The ID of the source resource which this Data Disk was created from. Changing this forces a new resource to be created.
        /// </summary>
        [Output("sourceResourceId")]
        public Output<string> SourceResourceId { get; private set; } = null!;

        /// <summary>
        /// The ID of the Virtual Machine to which the Data Disk should be attached. Changing this forces a new resource to be created.
        /// </summary>
        [Output("virtualMachineId")]
        public Output<string> VirtualMachineId { get; private set; } = null!;

        /// <summary>
        /// Specifies if Write Accelerator is enabled on the disk. This can only be enabled on `Premium_LRS` managed disks with no caching and [M-Series VMs](https://docs.microsoft.com/azure/virtual-machines/workloads/sap/how-to-enable-write-accelerator). Defaults to `False`.
        /// </summary>
        [Output("writeAcceleratorEnabled")]
        public Output<bool?> WriteAcceleratorEnabled { get; private set; } = null!;


        /// <summary>
        /// Create a ImplicitDataDiskFromSource resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public ImplicitDataDiskFromSource(string name, ImplicitDataDiskFromSourceArgs args, CustomResourceOptions? options = null)
            : base("azure:compute/implicitDataDiskFromSource:ImplicitDataDiskFromSource", name, args ?? new ImplicitDataDiskFromSourceArgs(), MakeResourceOptions(options, ""))
        {
        }

        private ImplicitDataDiskFromSource(string name, Input<string> id, ImplicitDataDiskFromSourceState? state = null, CustomResourceOptions? options = null)
            : base("azure:compute/implicitDataDiskFromSource:ImplicitDataDiskFromSource", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing ImplicitDataDiskFromSource resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static ImplicitDataDiskFromSource Get(string name, Input<string> id, ImplicitDataDiskFromSourceState? state = null, CustomResourceOptions? options = null)
        {
            return new ImplicitDataDiskFromSource(name, id, state, options);
        }
    }

    public sealed class ImplicitDataDiskFromSourceArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Specifies the caching requirements for this Data Disk. Possible values are `ReadOnly` and `ReadWrite`.
        /// </summary>
        [Input("caching")]
        public Input<string>? Caching { get; set; }

        /// <summary>
        /// Specifies the Create Option of the Data Disk. The only possible value is `Copy`. Changing this forces a new resource to be created.
        /// </summary>
        [Input("createOption", required: true)]
        public Input<string> CreateOption { get; set; } = null!;

        /// <summary>
        /// Specifies the size of the Data Disk in gigabytes.
        /// 
        /// &gt; **Note:** Updating `DiskSizeGb` to shrink the disk size is not supported on Azure and forces a new Data Disk to be created.
        /// 
        /// &gt; **Note:** In certain conditions the Data Disk size can be updated without shutting down the Virtual Machine, however only a subset of Virtual Machine SKUs/Disk combinations support this. More information can be found [for Linux Virtual Machines](https://learn.microsoft.com/en-us/azure/virtual-machines/linux/expand-disks?tabs=azure-cli%2Cubuntu#expand-without-downtime) and [Windows Virtual Machines](https://learn.microsoft.com/azure/virtual-machines/windows/expand-os-disk#expand-without-downtime) respectively.
        /// 
        /// &gt; **Note:** If the VM does not meet the requirements to expand the disk without downtime, changing this value is disruptive. The VM will be shut down and deallocated as required by Azure to action the change. Terraform will attempt to start the VM again after the update if it was in a `Running` state prior to the change.
        /// 
        /// &gt; **Note:** Expanding Ultra Disks and Premium SSD v2 disks without downtime has additional limitations. Allow up to 10 minutes for the correct size to be reflected, and a `Rescan` function may be required. For more details, refer to [Expand with Ultra Disks and Premium SSD v2](https://learn.microsoft.com/azure/virtual-machines/linux/expand-disks?tabs=ubuntu#expand-with-ultra-disks-and-premium-ssd-v2).
        /// </summary>
        [Input("diskSizeGb", required: true)]
        public Input<int> DiskSizeGb { get; set; } = null!;

        /// <summary>
        /// The Logical Unit Number of the Data Disk, which needs to be unique within the Virtual Machine. Changing this forces a new resource to be created.
        /// </summary>
        [Input("lun", required: true)]
        public Input<int> Lun { get; set; } = null!;

        /// <summary>
        /// Specifies the name of this Data Disk. Changing this forces a new resource to be created.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// The ID of the source resource which this Data Disk was created from. Changing this forces a new resource to be created.
        /// </summary>
        [Input("sourceResourceId", required: true)]
        public Input<string> SourceResourceId { get; set; } = null!;

        /// <summary>
        /// The ID of the Virtual Machine to which the Data Disk should be attached. Changing this forces a new resource to be created.
        /// </summary>
        [Input("virtualMachineId", required: true)]
        public Input<string> VirtualMachineId { get; set; } = null!;

        /// <summary>
        /// Specifies if Write Accelerator is enabled on the disk. This can only be enabled on `Premium_LRS` managed disks with no caching and [M-Series VMs](https://docs.microsoft.com/azure/virtual-machines/workloads/sap/how-to-enable-write-accelerator). Defaults to `False`.
        /// </summary>
        [Input("writeAcceleratorEnabled")]
        public Input<bool>? WriteAcceleratorEnabled { get; set; }

        public ImplicitDataDiskFromSourceArgs()
        {
        }
        public static new ImplicitDataDiskFromSourceArgs Empty => new ImplicitDataDiskFromSourceArgs();
    }

    public sealed class ImplicitDataDiskFromSourceState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Specifies the caching requirements for this Data Disk. Possible values are `ReadOnly` and `ReadWrite`.
        /// </summary>
        [Input("caching")]
        public Input<string>? Caching { get; set; }

        /// <summary>
        /// Specifies the Create Option of the Data Disk. The only possible value is `Copy`. Changing this forces a new resource to be created.
        /// </summary>
        [Input("createOption")]
        public Input<string>? CreateOption { get; set; }

        /// <summary>
        /// Specifies the size of the Data Disk in gigabytes.
        /// 
        /// &gt; **Note:** Updating `DiskSizeGb` to shrink the disk size is not supported on Azure and forces a new Data Disk to be created.
        /// 
        /// &gt; **Note:** In certain conditions the Data Disk size can be updated without shutting down the Virtual Machine, however only a subset of Virtual Machine SKUs/Disk combinations support this. More information can be found [for Linux Virtual Machines](https://learn.microsoft.com/en-us/azure/virtual-machines/linux/expand-disks?tabs=azure-cli%2Cubuntu#expand-without-downtime) and [Windows Virtual Machines](https://learn.microsoft.com/azure/virtual-machines/windows/expand-os-disk#expand-without-downtime) respectively.
        /// 
        /// &gt; **Note:** If the VM does not meet the requirements to expand the disk without downtime, changing this value is disruptive. The VM will be shut down and deallocated as required by Azure to action the change. Terraform will attempt to start the VM again after the update if it was in a `Running` state prior to the change.
        /// 
        /// &gt; **Note:** Expanding Ultra Disks and Premium SSD v2 disks without downtime has additional limitations. Allow up to 10 minutes for the correct size to be reflected, and a `Rescan` function may be required. For more details, refer to [Expand with Ultra Disks and Premium SSD v2](https://learn.microsoft.com/azure/virtual-machines/linux/expand-disks?tabs=ubuntu#expand-with-ultra-disks-and-premium-ssd-v2).
        /// </summary>
        [Input("diskSizeGb")]
        public Input<int>? DiskSizeGb { get; set; }

        /// <summary>
        /// The Logical Unit Number of the Data Disk, which needs to be unique within the Virtual Machine. Changing this forces a new resource to be created.
        /// </summary>
        [Input("lun")]
        public Input<int>? Lun { get; set; }

        /// <summary>
        /// Specifies the name of this Data Disk. Changing this forces a new resource to be created.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// The ID of the source resource which this Data Disk was created from. Changing this forces a new resource to be created.
        /// </summary>
        [Input("sourceResourceId")]
        public Input<string>? SourceResourceId { get; set; }

        /// <summary>
        /// The ID of the Virtual Machine to which the Data Disk should be attached. Changing this forces a new resource to be created.
        /// </summary>
        [Input("virtualMachineId")]
        public Input<string>? VirtualMachineId { get; set; }

        /// <summary>
        /// Specifies if Write Accelerator is enabled on the disk. This can only be enabled on `Premium_LRS` managed disks with no caching and [M-Series VMs](https://docs.microsoft.com/azure/virtual-machines/workloads/sap/how-to-enable-write-accelerator). Defaults to `False`.
        /// </summary>
        [Input("writeAcceleratorEnabled")]
        public Input<bool>? WriteAcceleratorEnabled { get; set; }

        public ImplicitDataDiskFromSourceState()
        {
        }
        public static new ImplicitDataDiskFromSourceState Empty => new ImplicitDataDiskFromSourceState();
    }
}
