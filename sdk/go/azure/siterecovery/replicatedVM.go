// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package siterecovery

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-azure/sdk/v5/go/azure/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages a VM replicated using Azure Site Recovery (Azure to Azure only). A replicated VM keeps a copiously updated image of the VM in another region in order to be able to start the VM in that region in case of a disaster.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-azure/sdk/v5/go/azure/compute"
//	"github.com/pulumi/pulumi-azure/sdk/v5/go/azure/core"
//	"github.com/pulumi/pulumi-azure/sdk/v5/go/azure/network"
//	"github.com/pulumi/pulumi-azure/sdk/v5/go/azure/recoveryservices"
//	"github.com/pulumi/pulumi-azure/sdk/v5/go/azure/siterecovery"
//	"github.com/pulumi/pulumi-azure/sdk/v5/go/azure/storage"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			primaryResourceGroup, err := core.NewResourceGroup(ctx, "primaryResourceGroup", &core.ResourceGroupArgs{
//				Location: pulumi.String("West US"),
//			})
//			if err != nil {
//				return err
//			}
//			secondaryResourceGroup, err := core.NewResourceGroup(ctx, "secondaryResourceGroup", &core.ResourceGroupArgs{
//				Location: pulumi.String("East US"),
//			})
//			if err != nil {
//				return err
//			}
//			primaryVirtualNetwork, err := network.NewVirtualNetwork(ctx, "primaryVirtualNetwork", &network.VirtualNetworkArgs{
//				ResourceGroupName: primaryResourceGroup.Name,
//				AddressSpaces: pulumi.StringArray{
//					pulumi.String("192.168.1.0/24"),
//				},
//				Location: primaryResourceGroup.Location,
//			})
//			if err != nil {
//				return err
//			}
//			primarySubnet, err := network.NewSubnet(ctx, "primarySubnet", &network.SubnetArgs{
//				ResourceGroupName:  primaryResourceGroup.Name,
//				VirtualNetworkName: primaryVirtualNetwork.Name,
//				AddressPrefixes: pulumi.StringArray{
//					pulumi.String("192.168.1.0/24"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			primaryPublicIp, err := network.NewPublicIp(ctx, "primaryPublicIp", &network.PublicIpArgs{
//				AllocationMethod:  pulumi.String("Static"),
//				Location:          primaryResourceGroup.Location,
//				ResourceGroupName: primaryResourceGroup.Name,
//				Sku:               pulumi.String("Basic"),
//			})
//			if err != nil {
//				return err
//			}
//			vmNetworkInterface, err := network.NewNetworkInterface(ctx, "vmNetworkInterface", &network.NetworkInterfaceArgs{
//				Location:          primaryResourceGroup.Location,
//				ResourceGroupName: primaryResourceGroup.Name,
//				IpConfigurations: network.NetworkInterfaceIpConfigurationArray{
//					&network.NetworkInterfaceIpConfigurationArgs{
//						Name:                       pulumi.String("vm"),
//						SubnetId:                   primarySubnet.ID(),
//						PrivateIpAddressAllocation: pulumi.String("Dynamic"),
//						PublicIpAddressId:          primaryPublicIp.ID(),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			vmVirtualMachine, err := compute.NewVirtualMachine(ctx, "vmVirtualMachine", &compute.VirtualMachineArgs{
//				Location:          primaryResourceGroup.Location,
//				ResourceGroupName: primaryResourceGroup.Name,
//				VmSize:            pulumi.String("Standard_B1s"),
//				NetworkInterfaceIds: pulumi.StringArray{
//					vmNetworkInterface.ID(),
//				},
//				StorageImageReference: &compute.VirtualMachineStorageImageReferenceArgs{
//					Publisher: pulumi.String("Canonical"),
//					Offer:     pulumi.String("0001-com-ubuntu-server-jammy"),
//					Sku:       pulumi.String("22_04-lts"),
//					Version:   pulumi.String("latest"),
//				},
//				StorageOsDisk: &compute.VirtualMachineStorageOsDiskArgs{
//					Name:            pulumi.String("vm-os-disk"),
//					OsType:          pulumi.String("Linux"),
//					Caching:         pulumi.String("ReadWrite"),
//					CreateOption:    pulumi.String("FromImage"),
//					ManagedDiskType: pulumi.String("Premium_LRS"),
//				},
//				OsProfile: &compute.VirtualMachineOsProfileArgs{
//					AdminUsername: pulumi.String("test-admin-123"),
//					AdminPassword: pulumi.String("test-pwd-123"),
//					ComputerName:  pulumi.String("vm"),
//				},
//				OsProfileLinuxConfig: &compute.VirtualMachineOsProfileLinuxConfigArgs{
//					DisablePasswordAuthentication: pulumi.Bool(false),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			vault, err := recoveryservices.NewVault(ctx, "vault", &recoveryservices.VaultArgs{
//				Location:          secondaryResourceGroup.Location,
//				ResourceGroupName: secondaryResourceGroup.Name,
//				Sku:               pulumi.String("Standard"),
//			})
//			if err != nil {
//				return err
//			}
//			primaryFabric, err := siterecovery.NewFabric(ctx, "primaryFabric", &siterecovery.FabricArgs{
//				ResourceGroupName: secondaryResourceGroup.Name,
//				RecoveryVaultName: vault.Name,
//				Location:          primaryResourceGroup.Location,
//			})
//			if err != nil {
//				return err
//			}
//			secondaryFabric, err := siterecovery.NewFabric(ctx, "secondaryFabric", &siterecovery.FabricArgs{
//				ResourceGroupName: secondaryResourceGroup.Name,
//				RecoveryVaultName: vault.Name,
//				Location:          secondaryResourceGroup.Location,
//			})
//			if err != nil {
//				return err
//			}
//			primaryProtectionContainer, err := siterecovery.NewProtectionContainer(ctx, "primaryProtectionContainer", &siterecovery.ProtectionContainerArgs{
//				ResourceGroupName:  secondaryResourceGroup.Name,
//				RecoveryVaultName:  vault.Name,
//				RecoveryFabricName: primaryFabric.Name,
//			})
//			if err != nil {
//				return err
//			}
//			secondaryProtectionContainer, err := siterecovery.NewProtectionContainer(ctx, "secondaryProtectionContainer", &siterecovery.ProtectionContainerArgs{
//				ResourceGroupName:  secondaryResourceGroup.Name,
//				RecoveryVaultName:  vault.Name,
//				RecoveryFabricName: secondaryFabric.Name,
//			})
//			if err != nil {
//				return err
//			}
//			policy, err := siterecovery.NewReplicationPolicy(ctx, "policy", &siterecovery.ReplicationPolicyArgs{
//				ResourceGroupName:                               secondaryResourceGroup.Name,
//				RecoveryVaultName:                               vault.Name,
//				RecoveryPointRetentionInMinutes:                 24 * 60,
//				ApplicationConsistentSnapshotFrequencyInMinutes: 4 * 60,
//			})
//			if err != nil {
//				return err
//			}
//			_, err = siterecovery.NewProtectionContainerMapping(ctx, "container-mapping", &siterecovery.ProtectionContainerMappingArgs{
//				ResourceGroupName:                     secondaryResourceGroup.Name,
//				RecoveryVaultName:                     vault.Name,
//				RecoveryFabricName:                    primaryFabric.Name,
//				RecoverySourceProtectionContainerName: primaryProtectionContainer.Name,
//				RecoveryTargetProtectionContainerId:   secondaryProtectionContainer.ID(),
//				RecoveryReplicationPolicyId:           policy.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			secondaryVirtualNetwork, err := network.NewVirtualNetwork(ctx, "secondaryVirtualNetwork", &network.VirtualNetworkArgs{
//				ResourceGroupName: secondaryResourceGroup.Name,
//				AddressSpaces: pulumi.StringArray{
//					pulumi.String("192.168.2.0/24"),
//				},
//				Location: secondaryResourceGroup.Location,
//			})
//			if err != nil {
//				return err
//			}
//			_, err = siterecovery.NewNetworkMapping(ctx, "network-mapping", &siterecovery.NetworkMappingArgs{
//				ResourceGroupName:        secondaryResourceGroup.Name,
//				RecoveryVaultName:        vault.Name,
//				SourceRecoveryFabricName: primaryFabric.Name,
//				TargetRecoveryFabricName: secondaryFabric.Name,
//				SourceNetworkId:          primaryVirtualNetwork.ID(),
//				TargetNetworkId:          secondaryVirtualNetwork.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			primaryAccount, err := storage.NewAccount(ctx, "primaryAccount", &storage.AccountArgs{
//				Location:               primaryResourceGroup.Location,
//				ResourceGroupName:      primaryResourceGroup.Name,
//				AccountTier:            pulumi.String("Standard"),
//				AccountReplicationType: pulumi.String("LRS"),
//			})
//			if err != nil {
//				return err
//			}
//			secondarySubnet, err := network.NewSubnet(ctx, "secondarySubnet", &network.SubnetArgs{
//				ResourceGroupName:  secondaryResourceGroup.Name,
//				VirtualNetworkName: secondaryVirtualNetwork.Name,
//				AddressPrefixes: pulumi.StringArray{
//					pulumi.String("192.168.2.0/24"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			secondaryPublicIp, err := network.NewPublicIp(ctx, "secondaryPublicIp", &network.PublicIpArgs{
//				AllocationMethod:  pulumi.String("Static"),
//				Location:          secondaryResourceGroup.Location,
//				ResourceGroupName: secondaryResourceGroup.Name,
//				Sku:               pulumi.String("Basic"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = siterecovery.NewReplicatedVM(ctx, "vm-replication", &siterecovery.ReplicatedVMArgs{
//				ResourceGroupName:                     secondaryResourceGroup.Name,
//				RecoveryVaultName:                     vault.Name,
//				SourceRecoveryFabricName:              primaryFabric.Name,
//				SourceVmId:                            vmVirtualMachine.ID(),
//				RecoveryReplicationPolicyId:           policy.ID(),
//				SourceRecoveryProtectionContainerName: primaryProtectionContainer.Name,
//				TargetResourceGroupId:                 secondaryResourceGroup.ID(),
//				TargetRecoveryFabricId:                secondaryFabric.ID(),
//				TargetRecoveryProtectionContainerId:   secondaryProtectionContainer.ID(),
//				ManagedDisks: siterecovery.ReplicatedVMManagedDiskArray{
//					&siterecovery.ReplicatedVMManagedDiskArgs{
//						DiskId: vmVirtualMachine.StorageOsDisk.ApplyT(func(storageOsDisk compute.VirtualMachineStorageOsDisk) (*string, error) {
//							return &storageOsDisk.ManagedDiskId, nil
//						}).(pulumi.StringPtrOutput),
//						StagingStorageAccountId: primaryAccount.ID(),
//						TargetResourceGroupId:   secondaryResourceGroup.ID(),
//						TargetDiskType:          pulumi.String("Premium_LRS"),
//						TargetReplicaDiskType:   pulumi.String("Premium_LRS"),
//					},
//				},
//				NetworkInterfaces: siterecovery.ReplicatedVMNetworkInterfaceArray{
//					&siterecovery.ReplicatedVMNetworkInterfaceArgs{
//						SourceNetworkInterfaceId:  vmNetworkInterface.ID(),
//						TargetSubnetName:          secondarySubnet.Name,
//						RecoveryPublicIpAddressId: secondaryPublicIp.ID(),
//					},
//				},
//			}, pulumi.DependsOn([]pulumi.Resource{
//				container_mapping,
//				network_mapping,
//			}))
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Site Recovery Replicated VM's can be imported using the `resource id`, e.g.
//
// ```sh
//
//	$ pulumi import azure:siterecovery/replicatedVM:ReplicatedVM vmreplication /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/resource-group-name/providers/Microsoft.RecoveryServices/vaults/recovery-vault-name/replicationFabrics/fabric-name/replicationProtectionContainers/protection-container-name/replicationProtectedItems/vm-replication-name
//
// ```
type ReplicatedVM struct {
	pulumi.CustomResourceState

	// One or more `managedDisk` block as defined below. Changing this forces a new resource to be created.
	ManagedDisks ReplicatedVMManagedDiskArrayOutput `pulumi:"managedDisks"`
	// Name of group in which all machines will replicate together and have shared crash consistent and app-consistent recovery points when failed over.
	MultiVmGroupName pulumi.StringPtrOutput `pulumi:"multiVmGroupName"`
	// The name of the replication for the replicated VM. Changing this forces a new resource to be created.
	Name pulumi.StringOutput `pulumi:"name"`
	// One or more `networkInterface` block as defined below.
	NetworkInterfaces ReplicatedVMNetworkInterfaceArrayOutput `pulumi:"networkInterfaces"`
	// Id of the policy to use for this replicated vm. Changing this forces a new resource to be created.
	RecoveryReplicationPolicyId pulumi.StringOutput `pulumi:"recoveryReplicationPolicyId"`
	// The name of the vault that should be updated. Changing this forces a new resource to be created.
	RecoveryVaultName pulumi.StringOutput `pulumi:"recoveryVaultName"`
	// Name of the resource group where the vault that should be updated is located. Changing this forces a new resource to be created.
	ResourceGroupName pulumi.StringOutput `pulumi:"resourceGroupName"`
	// Name of fabric that should contain this replication. Changing this forces a new resource to be created.
	SourceRecoveryFabricName pulumi.StringOutput `pulumi:"sourceRecoveryFabricName"`
	// Name of the protection container to use. Changing this forces a new resource to be created.
	SourceRecoveryProtectionContainerName pulumi.StringOutput `pulumi:"sourceRecoveryProtectionContainerName"`
	// Id of the VM to replicate Changing this forces a new resource to be created.
	SourceVmId pulumi.StringOutput `pulumi:"sourceVmId"`
	// Id of availability set that the new VM should belong to when a failover is done.
	TargetAvailabilitySetId pulumi.StringPtrOutput `pulumi:"targetAvailabilitySetId"`
	// Id of the storage account which the new VM should used for boot diagnostic when a failover is done.
	TargetBootDiagnosticStorageAccountId pulumi.StringPtrOutput `pulumi:"targetBootDiagnosticStorageAccountId"`
	// Id of the Capacity reservation group where the new VM should belong to when a failover is done.
	TargetCapacityReservationGroupId pulumi.StringPtrOutput `pulumi:"targetCapacityReservationGroupId"`
	// Specifies the Edge Zone within the Azure Region where this Managed Kubernetes Cluster should exist. Changing this forces a new resource to be created.
	TargetEdgeZone pulumi.StringPtrOutput `pulumi:"targetEdgeZone"`
	// Network to use when a failover is done (recommended to set if any networkInterface is configured for failover).
	TargetNetworkId pulumi.StringOutput `pulumi:"targetNetworkId"`
	// Id of Proximity Placement Group the new VM should belong to when a failover is done.
	TargetProximityPlacementGroupId pulumi.StringPtrOutput `pulumi:"targetProximityPlacementGroupId"`
	// Id of fabric where the VM replication should be handled when a failover is done. Changing this forces a new resource to be created.
	TargetRecoveryFabricId pulumi.StringOutput `pulumi:"targetRecoveryFabricId"`
	// Id of protection container where the VM replication should be created when a failover is done. Changing this forces a new resource to be created.
	TargetRecoveryProtectionContainerId pulumi.StringOutput `pulumi:"targetRecoveryProtectionContainerId"`
	// Id of resource group where the VM should be created when a failover is done. Changing this forces a new resource to be created.
	TargetResourceGroupId pulumi.StringOutput `pulumi:"targetResourceGroupId"`
	// Id of the Virtual Machine Scale Set which the new Vm should belong to when a failover is done.
	TargetVirtualMachineScaleSetId pulumi.StringPtrOutput `pulumi:"targetVirtualMachineScaleSetId"`
	// Specifies the Availability Zone where the Failover VM should exist. Changing this forces a new resource to be created.
	TargetZone pulumi.StringPtrOutput `pulumi:"targetZone"`
	// Network to use when a test failover is done.
	TestNetworkId pulumi.StringOutput `pulumi:"testNetworkId"`
	// One or more `unmanagedDisk` block as defined below. Changing this forces a new resource to be created.
	UnmanagedDisks ReplicatedVMUnmanagedDiskArrayOutput `pulumi:"unmanagedDisks"`
}

// NewReplicatedVM registers a new resource with the given unique name, arguments, and options.
func NewReplicatedVM(ctx *pulumi.Context,
	name string, args *ReplicatedVMArgs, opts ...pulumi.ResourceOption) (*ReplicatedVM, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.RecoveryReplicationPolicyId == nil {
		return nil, errors.New("invalid value for required argument 'RecoveryReplicationPolicyId'")
	}
	if args.RecoveryVaultName == nil {
		return nil, errors.New("invalid value for required argument 'RecoveryVaultName'")
	}
	if args.ResourceGroupName == nil {
		return nil, errors.New("invalid value for required argument 'ResourceGroupName'")
	}
	if args.SourceRecoveryFabricName == nil {
		return nil, errors.New("invalid value for required argument 'SourceRecoveryFabricName'")
	}
	if args.SourceRecoveryProtectionContainerName == nil {
		return nil, errors.New("invalid value for required argument 'SourceRecoveryProtectionContainerName'")
	}
	if args.SourceVmId == nil {
		return nil, errors.New("invalid value for required argument 'SourceVmId'")
	}
	if args.TargetRecoveryFabricId == nil {
		return nil, errors.New("invalid value for required argument 'TargetRecoveryFabricId'")
	}
	if args.TargetRecoveryProtectionContainerId == nil {
		return nil, errors.New("invalid value for required argument 'TargetRecoveryProtectionContainerId'")
	}
	if args.TargetResourceGroupId == nil {
		return nil, errors.New("invalid value for required argument 'TargetResourceGroupId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ReplicatedVM
	err := ctx.RegisterResource("azure:siterecovery/replicatedVM:ReplicatedVM", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetReplicatedVM gets an existing ReplicatedVM resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetReplicatedVM(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ReplicatedVMState, opts ...pulumi.ResourceOption) (*ReplicatedVM, error) {
	var resource ReplicatedVM
	err := ctx.ReadResource("azure:siterecovery/replicatedVM:ReplicatedVM", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ReplicatedVM resources.
type replicatedVMState struct {
	// One or more `managedDisk` block as defined below. Changing this forces a new resource to be created.
	ManagedDisks []ReplicatedVMManagedDisk `pulumi:"managedDisks"`
	// Name of group in which all machines will replicate together and have shared crash consistent and app-consistent recovery points when failed over.
	MultiVmGroupName *string `pulumi:"multiVmGroupName"`
	// The name of the replication for the replicated VM. Changing this forces a new resource to be created.
	Name *string `pulumi:"name"`
	// One or more `networkInterface` block as defined below.
	NetworkInterfaces []ReplicatedVMNetworkInterface `pulumi:"networkInterfaces"`
	// Id of the policy to use for this replicated vm. Changing this forces a new resource to be created.
	RecoveryReplicationPolicyId *string `pulumi:"recoveryReplicationPolicyId"`
	// The name of the vault that should be updated. Changing this forces a new resource to be created.
	RecoveryVaultName *string `pulumi:"recoveryVaultName"`
	// Name of the resource group where the vault that should be updated is located. Changing this forces a new resource to be created.
	ResourceGroupName *string `pulumi:"resourceGroupName"`
	// Name of fabric that should contain this replication. Changing this forces a new resource to be created.
	SourceRecoveryFabricName *string `pulumi:"sourceRecoveryFabricName"`
	// Name of the protection container to use. Changing this forces a new resource to be created.
	SourceRecoveryProtectionContainerName *string `pulumi:"sourceRecoveryProtectionContainerName"`
	// Id of the VM to replicate Changing this forces a new resource to be created.
	SourceVmId *string `pulumi:"sourceVmId"`
	// Id of availability set that the new VM should belong to when a failover is done.
	TargetAvailabilitySetId *string `pulumi:"targetAvailabilitySetId"`
	// Id of the storage account which the new VM should used for boot diagnostic when a failover is done.
	TargetBootDiagnosticStorageAccountId *string `pulumi:"targetBootDiagnosticStorageAccountId"`
	// Id of the Capacity reservation group where the new VM should belong to when a failover is done.
	TargetCapacityReservationGroupId *string `pulumi:"targetCapacityReservationGroupId"`
	// Specifies the Edge Zone within the Azure Region where this Managed Kubernetes Cluster should exist. Changing this forces a new resource to be created.
	TargetEdgeZone *string `pulumi:"targetEdgeZone"`
	// Network to use when a failover is done (recommended to set if any networkInterface is configured for failover).
	TargetNetworkId *string `pulumi:"targetNetworkId"`
	// Id of Proximity Placement Group the new VM should belong to when a failover is done.
	TargetProximityPlacementGroupId *string `pulumi:"targetProximityPlacementGroupId"`
	// Id of fabric where the VM replication should be handled when a failover is done. Changing this forces a new resource to be created.
	TargetRecoveryFabricId *string `pulumi:"targetRecoveryFabricId"`
	// Id of protection container where the VM replication should be created when a failover is done. Changing this forces a new resource to be created.
	TargetRecoveryProtectionContainerId *string `pulumi:"targetRecoveryProtectionContainerId"`
	// Id of resource group where the VM should be created when a failover is done. Changing this forces a new resource to be created.
	TargetResourceGroupId *string `pulumi:"targetResourceGroupId"`
	// Id of the Virtual Machine Scale Set which the new Vm should belong to when a failover is done.
	TargetVirtualMachineScaleSetId *string `pulumi:"targetVirtualMachineScaleSetId"`
	// Specifies the Availability Zone where the Failover VM should exist. Changing this forces a new resource to be created.
	TargetZone *string `pulumi:"targetZone"`
	// Network to use when a test failover is done.
	TestNetworkId *string `pulumi:"testNetworkId"`
	// One or more `unmanagedDisk` block as defined below. Changing this forces a new resource to be created.
	UnmanagedDisks []ReplicatedVMUnmanagedDisk `pulumi:"unmanagedDisks"`
}

type ReplicatedVMState struct {
	// One or more `managedDisk` block as defined below. Changing this forces a new resource to be created.
	ManagedDisks ReplicatedVMManagedDiskArrayInput
	// Name of group in which all machines will replicate together and have shared crash consistent and app-consistent recovery points when failed over.
	MultiVmGroupName pulumi.StringPtrInput
	// The name of the replication for the replicated VM. Changing this forces a new resource to be created.
	Name pulumi.StringPtrInput
	// One or more `networkInterface` block as defined below.
	NetworkInterfaces ReplicatedVMNetworkInterfaceArrayInput
	// Id of the policy to use for this replicated vm. Changing this forces a new resource to be created.
	RecoveryReplicationPolicyId pulumi.StringPtrInput
	// The name of the vault that should be updated. Changing this forces a new resource to be created.
	RecoveryVaultName pulumi.StringPtrInput
	// Name of the resource group where the vault that should be updated is located. Changing this forces a new resource to be created.
	ResourceGroupName pulumi.StringPtrInput
	// Name of fabric that should contain this replication. Changing this forces a new resource to be created.
	SourceRecoveryFabricName pulumi.StringPtrInput
	// Name of the protection container to use. Changing this forces a new resource to be created.
	SourceRecoveryProtectionContainerName pulumi.StringPtrInput
	// Id of the VM to replicate Changing this forces a new resource to be created.
	SourceVmId pulumi.StringPtrInput
	// Id of availability set that the new VM should belong to when a failover is done.
	TargetAvailabilitySetId pulumi.StringPtrInput
	// Id of the storage account which the new VM should used for boot diagnostic when a failover is done.
	TargetBootDiagnosticStorageAccountId pulumi.StringPtrInput
	// Id of the Capacity reservation group where the new VM should belong to when a failover is done.
	TargetCapacityReservationGroupId pulumi.StringPtrInput
	// Specifies the Edge Zone within the Azure Region where this Managed Kubernetes Cluster should exist. Changing this forces a new resource to be created.
	TargetEdgeZone pulumi.StringPtrInput
	// Network to use when a failover is done (recommended to set if any networkInterface is configured for failover).
	TargetNetworkId pulumi.StringPtrInput
	// Id of Proximity Placement Group the new VM should belong to when a failover is done.
	TargetProximityPlacementGroupId pulumi.StringPtrInput
	// Id of fabric where the VM replication should be handled when a failover is done. Changing this forces a new resource to be created.
	TargetRecoveryFabricId pulumi.StringPtrInput
	// Id of protection container where the VM replication should be created when a failover is done. Changing this forces a new resource to be created.
	TargetRecoveryProtectionContainerId pulumi.StringPtrInput
	// Id of resource group where the VM should be created when a failover is done. Changing this forces a new resource to be created.
	TargetResourceGroupId pulumi.StringPtrInput
	// Id of the Virtual Machine Scale Set which the new Vm should belong to when a failover is done.
	TargetVirtualMachineScaleSetId pulumi.StringPtrInput
	// Specifies the Availability Zone where the Failover VM should exist. Changing this forces a new resource to be created.
	TargetZone pulumi.StringPtrInput
	// Network to use when a test failover is done.
	TestNetworkId pulumi.StringPtrInput
	// One or more `unmanagedDisk` block as defined below. Changing this forces a new resource to be created.
	UnmanagedDisks ReplicatedVMUnmanagedDiskArrayInput
}

func (ReplicatedVMState) ElementType() reflect.Type {
	return reflect.TypeOf((*replicatedVMState)(nil)).Elem()
}

type replicatedVMArgs struct {
	// One or more `managedDisk` block as defined below. Changing this forces a new resource to be created.
	ManagedDisks []ReplicatedVMManagedDisk `pulumi:"managedDisks"`
	// Name of group in which all machines will replicate together and have shared crash consistent and app-consistent recovery points when failed over.
	MultiVmGroupName *string `pulumi:"multiVmGroupName"`
	// The name of the replication for the replicated VM. Changing this forces a new resource to be created.
	Name *string `pulumi:"name"`
	// One or more `networkInterface` block as defined below.
	NetworkInterfaces []ReplicatedVMNetworkInterface `pulumi:"networkInterfaces"`
	// Id of the policy to use for this replicated vm. Changing this forces a new resource to be created.
	RecoveryReplicationPolicyId string `pulumi:"recoveryReplicationPolicyId"`
	// The name of the vault that should be updated. Changing this forces a new resource to be created.
	RecoveryVaultName string `pulumi:"recoveryVaultName"`
	// Name of the resource group where the vault that should be updated is located. Changing this forces a new resource to be created.
	ResourceGroupName string `pulumi:"resourceGroupName"`
	// Name of fabric that should contain this replication. Changing this forces a new resource to be created.
	SourceRecoveryFabricName string `pulumi:"sourceRecoveryFabricName"`
	// Name of the protection container to use. Changing this forces a new resource to be created.
	SourceRecoveryProtectionContainerName string `pulumi:"sourceRecoveryProtectionContainerName"`
	// Id of the VM to replicate Changing this forces a new resource to be created.
	SourceVmId string `pulumi:"sourceVmId"`
	// Id of availability set that the new VM should belong to when a failover is done.
	TargetAvailabilitySetId *string `pulumi:"targetAvailabilitySetId"`
	// Id of the storage account which the new VM should used for boot diagnostic when a failover is done.
	TargetBootDiagnosticStorageAccountId *string `pulumi:"targetBootDiagnosticStorageAccountId"`
	// Id of the Capacity reservation group where the new VM should belong to when a failover is done.
	TargetCapacityReservationGroupId *string `pulumi:"targetCapacityReservationGroupId"`
	// Specifies the Edge Zone within the Azure Region where this Managed Kubernetes Cluster should exist. Changing this forces a new resource to be created.
	TargetEdgeZone *string `pulumi:"targetEdgeZone"`
	// Network to use when a failover is done (recommended to set if any networkInterface is configured for failover).
	TargetNetworkId *string `pulumi:"targetNetworkId"`
	// Id of Proximity Placement Group the new VM should belong to when a failover is done.
	TargetProximityPlacementGroupId *string `pulumi:"targetProximityPlacementGroupId"`
	// Id of fabric where the VM replication should be handled when a failover is done. Changing this forces a new resource to be created.
	TargetRecoveryFabricId string `pulumi:"targetRecoveryFabricId"`
	// Id of protection container where the VM replication should be created when a failover is done. Changing this forces a new resource to be created.
	TargetRecoveryProtectionContainerId string `pulumi:"targetRecoveryProtectionContainerId"`
	// Id of resource group where the VM should be created when a failover is done. Changing this forces a new resource to be created.
	TargetResourceGroupId string `pulumi:"targetResourceGroupId"`
	// Id of the Virtual Machine Scale Set which the new Vm should belong to when a failover is done.
	TargetVirtualMachineScaleSetId *string `pulumi:"targetVirtualMachineScaleSetId"`
	// Specifies the Availability Zone where the Failover VM should exist. Changing this forces a new resource to be created.
	TargetZone *string `pulumi:"targetZone"`
	// Network to use when a test failover is done.
	TestNetworkId *string `pulumi:"testNetworkId"`
	// One or more `unmanagedDisk` block as defined below. Changing this forces a new resource to be created.
	UnmanagedDisks []ReplicatedVMUnmanagedDisk `pulumi:"unmanagedDisks"`
}

// The set of arguments for constructing a ReplicatedVM resource.
type ReplicatedVMArgs struct {
	// One or more `managedDisk` block as defined below. Changing this forces a new resource to be created.
	ManagedDisks ReplicatedVMManagedDiskArrayInput
	// Name of group in which all machines will replicate together and have shared crash consistent and app-consistent recovery points when failed over.
	MultiVmGroupName pulumi.StringPtrInput
	// The name of the replication for the replicated VM. Changing this forces a new resource to be created.
	Name pulumi.StringPtrInput
	// One or more `networkInterface` block as defined below.
	NetworkInterfaces ReplicatedVMNetworkInterfaceArrayInput
	// Id of the policy to use for this replicated vm. Changing this forces a new resource to be created.
	RecoveryReplicationPolicyId pulumi.StringInput
	// The name of the vault that should be updated. Changing this forces a new resource to be created.
	RecoveryVaultName pulumi.StringInput
	// Name of the resource group where the vault that should be updated is located. Changing this forces a new resource to be created.
	ResourceGroupName pulumi.StringInput
	// Name of fabric that should contain this replication. Changing this forces a new resource to be created.
	SourceRecoveryFabricName pulumi.StringInput
	// Name of the protection container to use. Changing this forces a new resource to be created.
	SourceRecoveryProtectionContainerName pulumi.StringInput
	// Id of the VM to replicate Changing this forces a new resource to be created.
	SourceVmId pulumi.StringInput
	// Id of availability set that the new VM should belong to when a failover is done.
	TargetAvailabilitySetId pulumi.StringPtrInput
	// Id of the storage account which the new VM should used for boot diagnostic when a failover is done.
	TargetBootDiagnosticStorageAccountId pulumi.StringPtrInput
	// Id of the Capacity reservation group where the new VM should belong to when a failover is done.
	TargetCapacityReservationGroupId pulumi.StringPtrInput
	// Specifies the Edge Zone within the Azure Region where this Managed Kubernetes Cluster should exist. Changing this forces a new resource to be created.
	TargetEdgeZone pulumi.StringPtrInput
	// Network to use when a failover is done (recommended to set if any networkInterface is configured for failover).
	TargetNetworkId pulumi.StringPtrInput
	// Id of Proximity Placement Group the new VM should belong to when a failover is done.
	TargetProximityPlacementGroupId pulumi.StringPtrInput
	// Id of fabric where the VM replication should be handled when a failover is done. Changing this forces a new resource to be created.
	TargetRecoveryFabricId pulumi.StringInput
	// Id of protection container where the VM replication should be created when a failover is done. Changing this forces a new resource to be created.
	TargetRecoveryProtectionContainerId pulumi.StringInput
	// Id of resource group where the VM should be created when a failover is done. Changing this forces a new resource to be created.
	TargetResourceGroupId pulumi.StringInput
	// Id of the Virtual Machine Scale Set which the new Vm should belong to when a failover is done.
	TargetVirtualMachineScaleSetId pulumi.StringPtrInput
	// Specifies the Availability Zone where the Failover VM should exist. Changing this forces a new resource to be created.
	TargetZone pulumi.StringPtrInput
	// Network to use when a test failover is done.
	TestNetworkId pulumi.StringPtrInput
	// One or more `unmanagedDisk` block as defined below. Changing this forces a new resource to be created.
	UnmanagedDisks ReplicatedVMUnmanagedDiskArrayInput
}

func (ReplicatedVMArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*replicatedVMArgs)(nil)).Elem()
}

type ReplicatedVMInput interface {
	pulumi.Input

	ToReplicatedVMOutput() ReplicatedVMOutput
	ToReplicatedVMOutputWithContext(ctx context.Context) ReplicatedVMOutput
}

func (*ReplicatedVM) ElementType() reflect.Type {
	return reflect.TypeOf((**ReplicatedVM)(nil)).Elem()
}

func (i *ReplicatedVM) ToReplicatedVMOutput() ReplicatedVMOutput {
	return i.ToReplicatedVMOutputWithContext(context.Background())
}

func (i *ReplicatedVM) ToReplicatedVMOutputWithContext(ctx context.Context) ReplicatedVMOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReplicatedVMOutput)
}

// ReplicatedVMArrayInput is an input type that accepts ReplicatedVMArray and ReplicatedVMArrayOutput values.
// You can construct a concrete instance of `ReplicatedVMArrayInput` via:
//
//	ReplicatedVMArray{ ReplicatedVMArgs{...} }
type ReplicatedVMArrayInput interface {
	pulumi.Input

	ToReplicatedVMArrayOutput() ReplicatedVMArrayOutput
	ToReplicatedVMArrayOutputWithContext(context.Context) ReplicatedVMArrayOutput
}

type ReplicatedVMArray []ReplicatedVMInput

func (ReplicatedVMArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ReplicatedVM)(nil)).Elem()
}

func (i ReplicatedVMArray) ToReplicatedVMArrayOutput() ReplicatedVMArrayOutput {
	return i.ToReplicatedVMArrayOutputWithContext(context.Background())
}

func (i ReplicatedVMArray) ToReplicatedVMArrayOutputWithContext(ctx context.Context) ReplicatedVMArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReplicatedVMArrayOutput)
}

// ReplicatedVMMapInput is an input type that accepts ReplicatedVMMap and ReplicatedVMMapOutput values.
// You can construct a concrete instance of `ReplicatedVMMapInput` via:
//
//	ReplicatedVMMap{ "key": ReplicatedVMArgs{...} }
type ReplicatedVMMapInput interface {
	pulumi.Input

	ToReplicatedVMMapOutput() ReplicatedVMMapOutput
	ToReplicatedVMMapOutputWithContext(context.Context) ReplicatedVMMapOutput
}

type ReplicatedVMMap map[string]ReplicatedVMInput

func (ReplicatedVMMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ReplicatedVM)(nil)).Elem()
}

func (i ReplicatedVMMap) ToReplicatedVMMapOutput() ReplicatedVMMapOutput {
	return i.ToReplicatedVMMapOutputWithContext(context.Background())
}

func (i ReplicatedVMMap) ToReplicatedVMMapOutputWithContext(ctx context.Context) ReplicatedVMMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReplicatedVMMapOutput)
}

type ReplicatedVMOutput struct{ *pulumi.OutputState }

func (ReplicatedVMOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ReplicatedVM)(nil)).Elem()
}

func (o ReplicatedVMOutput) ToReplicatedVMOutput() ReplicatedVMOutput {
	return o
}

func (o ReplicatedVMOutput) ToReplicatedVMOutputWithContext(ctx context.Context) ReplicatedVMOutput {
	return o
}

// One or more `managedDisk` block as defined below. Changing this forces a new resource to be created.
func (o ReplicatedVMOutput) ManagedDisks() ReplicatedVMManagedDiskArrayOutput {
	return o.ApplyT(func(v *ReplicatedVM) ReplicatedVMManagedDiskArrayOutput { return v.ManagedDisks }).(ReplicatedVMManagedDiskArrayOutput)
}

// Name of group in which all machines will replicate together and have shared crash consistent and app-consistent recovery points when failed over.
func (o ReplicatedVMOutput) MultiVmGroupName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ReplicatedVM) pulumi.StringPtrOutput { return v.MultiVmGroupName }).(pulumi.StringPtrOutput)
}

// The name of the replication for the replicated VM. Changing this forces a new resource to be created.
func (o ReplicatedVMOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *ReplicatedVM) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// One or more `networkInterface` block as defined below.
func (o ReplicatedVMOutput) NetworkInterfaces() ReplicatedVMNetworkInterfaceArrayOutput {
	return o.ApplyT(func(v *ReplicatedVM) ReplicatedVMNetworkInterfaceArrayOutput { return v.NetworkInterfaces }).(ReplicatedVMNetworkInterfaceArrayOutput)
}

// Id of the policy to use for this replicated vm. Changing this forces a new resource to be created.
func (o ReplicatedVMOutput) RecoveryReplicationPolicyId() pulumi.StringOutput {
	return o.ApplyT(func(v *ReplicatedVM) pulumi.StringOutput { return v.RecoveryReplicationPolicyId }).(pulumi.StringOutput)
}

// The name of the vault that should be updated. Changing this forces a new resource to be created.
func (o ReplicatedVMOutput) RecoveryVaultName() pulumi.StringOutput {
	return o.ApplyT(func(v *ReplicatedVM) pulumi.StringOutput { return v.RecoveryVaultName }).(pulumi.StringOutput)
}

// Name of the resource group where the vault that should be updated is located. Changing this forces a new resource to be created.
func (o ReplicatedVMOutput) ResourceGroupName() pulumi.StringOutput {
	return o.ApplyT(func(v *ReplicatedVM) pulumi.StringOutput { return v.ResourceGroupName }).(pulumi.StringOutput)
}

// Name of fabric that should contain this replication. Changing this forces a new resource to be created.
func (o ReplicatedVMOutput) SourceRecoveryFabricName() pulumi.StringOutput {
	return o.ApplyT(func(v *ReplicatedVM) pulumi.StringOutput { return v.SourceRecoveryFabricName }).(pulumi.StringOutput)
}

// Name of the protection container to use. Changing this forces a new resource to be created.
func (o ReplicatedVMOutput) SourceRecoveryProtectionContainerName() pulumi.StringOutput {
	return o.ApplyT(func(v *ReplicatedVM) pulumi.StringOutput { return v.SourceRecoveryProtectionContainerName }).(pulumi.StringOutput)
}

// Id of the VM to replicate Changing this forces a new resource to be created.
func (o ReplicatedVMOutput) SourceVmId() pulumi.StringOutput {
	return o.ApplyT(func(v *ReplicatedVM) pulumi.StringOutput { return v.SourceVmId }).(pulumi.StringOutput)
}

// Id of availability set that the new VM should belong to when a failover is done.
func (o ReplicatedVMOutput) TargetAvailabilitySetId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ReplicatedVM) pulumi.StringPtrOutput { return v.TargetAvailabilitySetId }).(pulumi.StringPtrOutput)
}

// Id of the storage account which the new VM should used for boot diagnostic when a failover is done.
func (o ReplicatedVMOutput) TargetBootDiagnosticStorageAccountId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ReplicatedVM) pulumi.StringPtrOutput { return v.TargetBootDiagnosticStorageAccountId }).(pulumi.StringPtrOutput)
}

// Id of the Capacity reservation group where the new VM should belong to when a failover is done.
func (o ReplicatedVMOutput) TargetCapacityReservationGroupId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ReplicatedVM) pulumi.StringPtrOutput { return v.TargetCapacityReservationGroupId }).(pulumi.StringPtrOutput)
}

// Specifies the Edge Zone within the Azure Region where this Managed Kubernetes Cluster should exist. Changing this forces a new resource to be created.
func (o ReplicatedVMOutput) TargetEdgeZone() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ReplicatedVM) pulumi.StringPtrOutput { return v.TargetEdgeZone }).(pulumi.StringPtrOutput)
}

// Network to use when a failover is done (recommended to set if any networkInterface is configured for failover).
func (o ReplicatedVMOutput) TargetNetworkId() pulumi.StringOutput {
	return o.ApplyT(func(v *ReplicatedVM) pulumi.StringOutput { return v.TargetNetworkId }).(pulumi.StringOutput)
}

// Id of Proximity Placement Group the new VM should belong to when a failover is done.
func (o ReplicatedVMOutput) TargetProximityPlacementGroupId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ReplicatedVM) pulumi.StringPtrOutput { return v.TargetProximityPlacementGroupId }).(pulumi.StringPtrOutput)
}

// Id of fabric where the VM replication should be handled when a failover is done. Changing this forces a new resource to be created.
func (o ReplicatedVMOutput) TargetRecoveryFabricId() pulumi.StringOutput {
	return o.ApplyT(func(v *ReplicatedVM) pulumi.StringOutput { return v.TargetRecoveryFabricId }).(pulumi.StringOutput)
}

// Id of protection container where the VM replication should be created when a failover is done. Changing this forces a new resource to be created.
func (o ReplicatedVMOutput) TargetRecoveryProtectionContainerId() pulumi.StringOutput {
	return o.ApplyT(func(v *ReplicatedVM) pulumi.StringOutput { return v.TargetRecoveryProtectionContainerId }).(pulumi.StringOutput)
}

// Id of resource group where the VM should be created when a failover is done. Changing this forces a new resource to be created.
func (o ReplicatedVMOutput) TargetResourceGroupId() pulumi.StringOutput {
	return o.ApplyT(func(v *ReplicatedVM) pulumi.StringOutput { return v.TargetResourceGroupId }).(pulumi.StringOutput)
}

// Id of the Virtual Machine Scale Set which the new Vm should belong to when a failover is done.
func (o ReplicatedVMOutput) TargetVirtualMachineScaleSetId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ReplicatedVM) pulumi.StringPtrOutput { return v.TargetVirtualMachineScaleSetId }).(pulumi.StringPtrOutput)
}

// Specifies the Availability Zone where the Failover VM should exist. Changing this forces a new resource to be created.
func (o ReplicatedVMOutput) TargetZone() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ReplicatedVM) pulumi.StringPtrOutput { return v.TargetZone }).(pulumi.StringPtrOutput)
}

// Network to use when a test failover is done.
func (o ReplicatedVMOutput) TestNetworkId() pulumi.StringOutput {
	return o.ApplyT(func(v *ReplicatedVM) pulumi.StringOutput { return v.TestNetworkId }).(pulumi.StringOutput)
}

// One or more `unmanagedDisk` block as defined below. Changing this forces a new resource to be created.
func (o ReplicatedVMOutput) UnmanagedDisks() ReplicatedVMUnmanagedDiskArrayOutput {
	return o.ApplyT(func(v *ReplicatedVM) ReplicatedVMUnmanagedDiskArrayOutput { return v.UnmanagedDisks }).(ReplicatedVMUnmanagedDiskArrayOutput)
}

type ReplicatedVMArrayOutput struct{ *pulumi.OutputState }

func (ReplicatedVMArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ReplicatedVM)(nil)).Elem()
}

func (o ReplicatedVMArrayOutput) ToReplicatedVMArrayOutput() ReplicatedVMArrayOutput {
	return o
}

func (o ReplicatedVMArrayOutput) ToReplicatedVMArrayOutputWithContext(ctx context.Context) ReplicatedVMArrayOutput {
	return o
}

func (o ReplicatedVMArrayOutput) Index(i pulumi.IntInput) ReplicatedVMOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ReplicatedVM {
		return vs[0].([]*ReplicatedVM)[vs[1].(int)]
	}).(ReplicatedVMOutput)
}

type ReplicatedVMMapOutput struct{ *pulumi.OutputState }

func (ReplicatedVMMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ReplicatedVM)(nil)).Elem()
}

func (o ReplicatedVMMapOutput) ToReplicatedVMMapOutput() ReplicatedVMMapOutput {
	return o
}

func (o ReplicatedVMMapOutput) ToReplicatedVMMapOutputWithContext(ctx context.Context) ReplicatedVMMapOutput {
	return o
}

func (o ReplicatedVMMapOutput) MapIndex(k pulumi.StringInput) ReplicatedVMOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ReplicatedVM {
		return vs[0].(map[string]*ReplicatedVM)[vs[1].(string)]
	}).(ReplicatedVMOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ReplicatedVMInput)(nil)).Elem(), &ReplicatedVM{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReplicatedVMArrayInput)(nil)).Elem(), ReplicatedVMArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReplicatedVMMapInput)(nil)).Elem(), ReplicatedVMMap{})
	pulumi.RegisterOutputType(ReplicatedVMOutput{})
	pulumi.RegisterOutputType(ReplicatedVMArrayOutput{})
	pulumi.RegisterOutputType(ReplicatedVMMapOutput{})
}
