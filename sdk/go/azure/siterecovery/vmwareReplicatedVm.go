// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package siterecovery

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-azure/sdk/v6/go/azure/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages a VMWare replicated VM using Azure Site Recovery (VMWare to Azure only). A replicated VM keeps a copiously updated image of the VM in Azure in order to be able to start the VM in Azure in case of a disaster.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-azure/sdk/v6/go/azure/core"
//	"github.com/pulumi/pulumi-azure/sdk/v6/go/azure/network"
//	"github.com/pulumi/pulumi-azure/sdk/v6/go/azure/recoveryservices"
//	"github.com/pulumi/pulumi-azure/sdk/v6/go/azure/siterecovery"
//	"github.com/pulumi/pulumi-azure/sdk/v6/go/azure/storage"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			example, err := core.NewResourceGroup(ctx, "example", &core.ResourceGroupArgs{
//				Name:     pulumi.String("example-rg"),
//				Location: pulumi.String("West US"),
//			})
//			if err != nil {
//				return err
//			}
//			exampleVault, err := recoveryservices.NewVault(ctx, "example", &recoveryservices.VaultArgs{
//				Name:              pulumi.String("example-recovery-vault"),
//				Location:          example.Location,
//				ResourceGroupName: example.Name,
//				Sku:               pulumi.String("Standard"),
//			})
//			if err != nil {
//				return err
//			}
//			exampleVMWareReplicationPolicy, err := siterecovery.NewVMWareReplicationPolicy(ctx, "example", &siterecovery.VMWareReplicationPolicyArgs{
//				RecoveryVaultId:                 exampleVault.ID(),
//				Name:                            pulumi.String("example-policy"),
//				RecoveryPointRetentionInMinutes: pulumi.Int(1440),
//				ApplicationConsistentSnapshotFrequencyInMinutes: pulumi.Int(240),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = siterecovery.NewVmwareReplicationPolicyAssociation(ctx, "test", &siterecovery.VmwareReplicationPolicyAssociationArgs{
//				Name:            pulumi.String("example-association"),
//				RecoveryVaultId: exampleVault.ID(),
//				PolicyId:        exampleVMWareReplicationPolicy.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			exampleAccount, err := storage.NewAccount(ctx, "example", &storage.AccountArgs{
//				Name:                   pulumi.String("examplestorageacc"),
//				ResourceGroupName:      example.Name,
//				Location:               example.Location,
//				AccountTier:            pulumi.String("Standard"),
//				AccountKind:            pulumi.String("StorageV2"),
//				AccountReplicationType: pulumi.String("LRS"),
//			})
//			if err != nil {
//				return err
//			}
//			exampleVirtualNetwork, err := network.NewVirtualNetwork(ctx, "example", &network.VirtualNetworkArgs{
//				Name:              pulumi.String("example-net"),
//				ResourceGroupName: example.Name,
//				AddressSpaces: pulumi.StringArray{
//					pulumi.String("192.168.2.0/24"),
//				},
//				Location: example.Location,
//			})
//			if err != nil {
//				return err
//			}
//			exampleSubnet, err := network.NewSubnet(ctx, "example", &network.SubnetArgs{
//				Name:               pulumi.String("example-subnet"),
//				ResourceGroupName:  example.Name,
//				VirtualNetworkName: exampleVirtualNetwork.Name,
//				AddressPrefixes: pulumi.StringArray{
//					pulumi.String("192.168.2.0/24"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = siterecovery.NewVmwareReplicatedVm(ctx, "example", &siterecovery.VmwareReplicatedVmArgs{
//				Name:                                  pulumi.String("example-vmware-vm"),
//				RecoveryVaultId:                       exampleVault.ID(),
//				SourceVmName:                          pulumi.String("example-vm"),
//				ApplianceName:                         pulumi.String("example-appliance"),
//				RecoveryReplicationPolicyId:           pulumi.Any(exampleAzurermSiteRecoveryVmwareReplicationPolicyAssociation.PolicyId),
//				PhysicalServerCredentialName:          pulumi.String("example-creds"),
//				LicenseType:                           pulumi.String("NotSpecified"),
//				TargetBootDiagnosticsStorageAccountId: exampleAccount.ID(),
//				TargetVmName:                          pulumi.String("example_replicated_vm"),
//				TargetResourceGroupId:                 example.ID(),
//				DefaultLogStorageAccountId:            exampleAccount.ID(),
//				DefaultRecoveryDiskType:               pulumi.String("Standard_LRS"),
//				TargetNetworkId:                       exampleVirtualNetwork.ID(),
//				NetworkInterfaces: siterecovery.VmwareReplicatedVmNetworkInterfaceArray{
//					&siterecovery.VmwareReplicatedVmNetworkInterfaceArgs{
//						SourceMacAddress: pulumi.String("00:00:00:00:00:00"),
//						TargetSubnetName: exampleSubnet.Name,
//						IsPrimary:        pulumi.Bool(true),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## API Providers
//
// <!-- This section is generated, changes will be overwritten -->
// This resource uses the following Azure API Providers:
//
// * `Microsoft.OffAzure` - 2020-01-01
//
// * `Microsoft.RecoveryServices` - 2024-04-01
//
// ## Import
//
// Site Recovery VMWare Replicated VM's can be imported using the `resource id`, e.g.
//
// ```sh
// $ pulumi import azure:siterecovery/vmwareReplicatedVm:VmwareReplicatedVm vmreplication /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/resource-group-name/providers/Microsoft.RecoveryServices/vaults/recovery-vault-name/replicationFabrics/fabric-name/replicationProtectionContainers/protection-container-name/replicationProtectedItems/vm-replication-name
// ```
type VmwareReplicatedVm struct {
	pulumi.CustomResourceState

	// The name of VMWare appliance which handles the replication. Changing this forces a new resource to be created.
	ApplianceName pulumi.StringOutput `pulumi:"applianceName"`
	// The ID of the stroage account that should be used for logging during replication.
	//
	// > **Note:** Only standard types of storage accounts are allowed.
	//
	// > **Note:** Only one of `defaultLogStorageAccountId` or `managedDisk` must be specified.
	//
	// > **Note:** Changing `defaultLogStorageAccountId` forces a new resource to be created. But removing it does not.
	//
	// > **Note:** When `defaultLogStorageAccountId` co-exist with `managedDisk`, the value of `defaultLogStorageAccountId` must be as same as `logStorageAccountId` of every `managedDisk` or it forces a new resource to be created.
	DefaultLogStorageAccountId pulumi.StringPtrOutput `pulumi:"defaultLogStorageAccountId"`
	// The type of storage account that should be used for recovery disks when a failover is done. Possible values are `Premium_LRS`, `Standard_LRS` and `StandardSSD_LRS`.
	//
	// > **Note:** Only one of `defaultRecoveryDiskType` or `managedDisk` must be specified.
	//
	// > **Note:** Changing `defaultRecoveryDiskType` forces a new resource to be created. But removing it does not.
	//
	// > **Note:** When `defaultRecoveryDiskType` co-exist with `managedDisk`, the value of `defaultRecoveryDiskType` must be as same as `targetDiskType` of every `managedDisk` or it forces a new resource to be created.
	DefaultRecoveryDiskType pulumi.StringPtrOutput `pulumi:"defaultRecoveryDiskType"`
	// The ID of the default Disk Encryption Set that should be used for the disks when a failover is done.
	//
	// > **Note:** Changing `defaultTargetDiskEncryptionSetId` forces a new resource to be created. But removing it does not.
	//
	// > **Note:** When `defaultTargetDiskEncryptionSetId` co-exist with `managedDisk`, the value of `defaultTargetDiskEncryptionSetId` must be as same as `targetDiskEncryptionSetId` of every `managedDisk` or it forces a new resource to be created.
	DefaultTargetDiskEncryptionSetId pulumi.StringPtrOutput `pulumi:"defaultTargetDiskEncryptionSetId"`
	// The license type of the VM. Possible values are `NoLicenseType`, `NotSpecified` and `WindowsServer`. Defaults to `NotSpecified`.
	LicenseType pulumi.StringPtrOutput `pulumi:"licenseType"`
	// One or more `managedDisk` block as defined below. It's available only if mobility service is already installed on the source VM.
	//
	// > **Note:** A replicated VM could be created without `managedDisk` block, once the block has been specified, changing it expect removing it forces a new resource to be created.
	ManagedDisks VmwareReplicatedVmManagedDiskArrayOutput `pulumi:"managedDisks"`
	// Name of group in which all machines will replicate together and have shared crash consistent and app-consistent recovery points when failed over.
	MultiVmGroupName pulumi.StringPtrOutput `pulumi:"multiVmGroupName"`
	// The name of the replicated VM. Changing this forces a new resource to be created.
	Name pulumi.StringOutput `pulumi:"name"`
	// One or more `networkInterface` block as defined below.
	NetworkInterfaces VmwareReplicatedVmNetworkInterfaceArrayOutput `pulumi:"networkInterfaces"`
	// The name of the credential to access the source VM. Changing this forces a new resource to be created. More information about the credentials could be found [here](https://learn.microsoft.com/en-us/azure/site-recovery/deploy-vmware-azure-replication-appliance-modernized).
	PhysicalServerCredentialName pulumi.StringOutput `pulumi:"physicalServerCredentialName"`
	// The ID of the policy to use for this replicated VM.
	RecoveryReplicationPolicyId pulumi.StringOutput `pulumi:"recoveryReplicationPolicyId"`
	// The ID of the Recovery Services Vault where the replicated VM is created.
	RecoveryVaultId pulumi.StringOutput `pulumi:"recoveryVaultId"`
	// The name of the source VM in VMWare. Changing this forces a new resource to be created.
	SourceVmName pulumi.StringOutput `pulumi:"sourceVmName"`
	// The ID of availability set that the new VM should belong to when a failover is done.
	TargetAvailabilitySetId pulumi.StringPtrOutput `pulumi:"targetAvailabilitySetId"`
	// The ID of the storage account that should be used for boot diagnostics when a failover is done.
	TargetBootDiagnosticsStorageAccountId pulumi.StringPtrOutput `pulumi:"targetBootDiagnosticsStorageAccountId"`
	// The ID of network to use when a failover is done.
	//
	// > **Note:** `targetNetworkId` is required when `networkInterface` is specified.
	TargetNetworkId pulumi.StringPtrOutput `pulumi:"targetNetworkId"`
	// The ID of Proximity Placement Group the new VM should belong to when a failover is done.
	//
	// > **Note:** Only one of `targetAvailabilitySetId` or `targetZone` can be specified.
	TargetProximityPlacementGroupId pulumi.StringPtrOutput `pulumi:"targetProximityPlacementGroupId"`
	// The ID of resource group where the VM should be created when a failover is done.
	TargetResourceGroupId pulumi.StringOutput `pulumi:"targetResourceGroupId"`
	// Name of the VM that should be created when a failover is done. Changing this forces a new resource to be created.
	TargetVmName pulumi.StringOutput `pulumi:"targetVmName"`
	// Size of the VM that should be created when a failover is done, such as `Standard_F2`. If it's not specified, it will automatically be set by detecting the source VM size.
	TargetVmSize pulumi.StringPtrOutput `pulumi:"targetVmSize"`
	// Specifies the Availability Zone where the Failover VM should exist.
	TargetZone pulumi.StringPtrOutput `pulumi:"targetZone"`
	// The ID of network to use when a test failover is done.
	TestNetworkId pulumi.StringPtrOutput `pulumi:"testNetworkId"`
}

// NewVmwareReplicatedVm registers a new resource with the given unique name, arguments, and options.
func NewVmwareReplicatedVm(ctx *pulumi.Context,
	name string, args *VmwareReplicatedVmArgs, opts ...pulumi.ResourceOption) (*VmwareReplicatedVm, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ApplianceName == nil {
		return nil, errors.New("invalid value for required argument 'ApplianceName'")
	}
	if args.PhysicalServerCredentialName == nil {
		return nil, errors.New("invalid value for required argument 'PhysicalServerCredentialName'")
	}
	if args.RecoveryReplicationPolicyId == nil {
		return nil, errors.New("invalid value for required argument 'RecoveryReplicationPolicyId'")
	}
	if args.RecoveryVaultId == nil {
		return nil, errors.New("invalid value for required argument 'RecoveryVaultId'")
	}
	if args.SourceVmName == nil {
		return nil, errors.New("invalid value for required argument 'SourceVmName'")
	}
	if args.TargetResourceGroupId == nil {
		return nil, errors.New("invalid value for required argument 'TargetResourceGroupId'")
	}
	if args.TargetVmName == nil {
		return nil, errors.New("invalid value for required argument 'TargetVmName'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource VmwareReplicatedVm
	err := ctx.RegisterResource("azure:siterecovery/vmwareReplicatedVm:VmwareReplicatedVm", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetVmwareReplicatedVm gets an existing VmwareReplicatedVm resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetVmwareReplicatedVm(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *VmwareReplicatedVmState, opts ...pulumi.ResourceOption) (*VmwareReplicatedVm, error) {
	var resource VmwareReplicatedVm
	err := ctx.ReadResource("azure:siterecovery/vmwareReplicatedVm:VmwareReplicatedVm", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering VmwareReplicatedVm resources.
type vmwareReplicatedVmState struct {
	// The name of VMWare appliance which handles the replication. Changing this forces a new resource to be created.
	ApplianceName *string `pulumi:"applianceName"`
	// The ID of the stroage account that should be used for logging during replication.
	//
	// > **Note:** Only standard types of storage accounts are allowed.
	//
	// > **Note:** Only one of `defaultLogStorageAccountId` or `managedDisk` must be specified.
	//
	// > **Note:** Changing `defaultLogStorageAccountId` forces a new resource to be created. But removing it does not.
	//
	// > **Note:** When `defaultLogStorageAccountId` co-exist with `managedDisk`, the value of `defaultLogStorageAccountId` must be as same as `logStorageAccountId` of every `managedDisk` or it forces a new resource to be created.
	DefaultLogStorageAccountId *string `pulumi:"defaultLogStorageAccountId"`
	// The type of storage account that should be used for recovery disks when a failover is done. Possible values are `Premium_LRS`, `Standard_LRS` and `StandardSSD_LRS`.
	//
	// > **Note:** Only one of `defaultRecoveryDiskType` or `managedDisk` must be specified.
	//
	// > **Note:** Changing `defaultRecoveryDiskType` forces a new resource to be created. But removing it does not.
	//
	// > **Note:** When `defaultRecoveryDiskType` co-exist with `managedDisk`, the value of `defaultRecoveryDiskType` must be as same as `targetDiskType` of every `managedDisk` or it forces a new resource to be created.
	DefaultRecoveryDiskType *string `pulumi:"defaultRecoveryDiskType"`
	// The ID of the default Disk Encryption Set that should be used for the disks when a failover is done.
	//
	// > **Note:** Changing `defaultTargetDiskEncryptionSetId` forces a new resource to be created. But removing it does not.
	//
	// > **Note:** When `defaultTargetDiskEncryptionSetId` co-exist with `managedDisk`, the value of `defaultTargetDiskEncryptionSetId` must be as same as `targetDiskEncryptionSetId` of every `managedDisk` or it forces a new resource to be created.
	DefaultTargetDiskEncryptionSetId *string `pulumi:"defaultTargetDiskEncryptionSetId"`
	// The license type of the VM. Possible values are `NoLicenseType`, `NotSpecified` and `WindowsServer`. Defaults to `NotSpecified`.
	LicenseType *string `pulumi:"licenseType"`
	// One or more `managedDisk` block as defined below. It's available only if mobility service is already installed on the source VM.
	//
	// > **Note:** A replicated VM could be created without `managedDisk` block, once the block has been specified, changing it expect removing it forces a new resource to be created.
	ManagedDisks []VmwareReplicatedVmManagedDisk `pulumi:"managedDisks"`
	// Name of group in which all machines will replicate together and have shared crash consistent and app-consistent recovery points when failed over.
	MultiVmGroupName *string `pulumi:"multiVmGroupName"`
	// The name of the replicated VM. Changing this forces a new resource to be created.
	Name *string `pulumi:"name"`
	// One or more `networkInterface` block as defined below.
	NetworkInterfaces []VmwareReplicatedVmNetworkInterface `pulumi:"networkInterfaces"`
	// The name of the credential to access the source VM. Changing this forces a new resource to be created. More information about the credentials could be found [here](https://learn.microsoft.com/en-us/azure/site-recovery/deploy-vmware-azure-replication-appliance-modernized).
	PhysicalServerCredentialName *string `pulumi:"physicalServerCredentialName"`
	// The ID of the policy to use for this replicated VM.
	RecoveryReplicationPolicyId *string `pulumi:"recoveryReplicationPolicyId"`
	// The ID of the Recovery Services Vault where the replicated VM is created.
	RecoveryVaultId *string `pulumi:"recoveryVaultId"`
	// The name of the source VM in VMWare. Changing this forces a new resource to be created.
	SourceVmName *string `pulumi:"sourceVmName"`
	// The ID of availability set that the new VM should belong to when a failover is done.
	TargetAvailabilitySetId *string `pulumi:"targetAvailabilitySetId"`
	// The ID of the storage account that should be used for boot diagnostics when a failover is done.
	TargetBootDiagnosticsStorageAccountId *string `pulumi:"targetBootDiagnosticsStorageAccountId"`
	// The ID of network to use when a failover is done.
	//
	// > **Note:** `targetNetworkId` is required when `networkInterface` is specified.
	TargetNetworkId *string `pulumi:"targetNetworkId"`
	// The ID of Proximity Placement Group the new VM should belong to when a failover is done.
	//
	// > **Note:** Only one of `targetAvailabilitySetId` or `targetZone` can be specified.
	TargetProximityPlacementGroupId *string `pulumi:"targetProximityPlacementGroupId"`
	// The ID of resource group where the VM should be created when a failover is done.
	TargetResourceGroupId *string `pulumi:"targetResourceGroupId"`
	// Name of the VM that should be created when a failover is done. Changing this forces a new resource to be created.
	TargetVmName *string `pulumi:"targetVmName"`
	// Size of the VM that should be created when a failover is done, such as `Standard_F2`. If it's not specified, it will automatically be set by detecting the source VM size.
	TargetVmSize *string `pulumi:"targetVmSize"`
	// Specifies the Availability Zone where the Failover VM should exist.
	TargetZone *string `pulumi:"targetZone"`
	// The ID of network to use when a test failover is done.
	TestNetworkId *string `pulumi:"testNetworkId"`
}

type VmwareReplicatedVmState struct {
	// The name of VMWare appliance which handles the replication. Changing this forces a new resource to be created.
	ApplianceName pulumi.StringPtrInput
	// The ID of the stroage account that should be used for logging during replication.
	//
	// > **Note:** Only standard types of storage accounts are allowed.
	//
	// > **Note:** Only one of `defaultLogStorageAccountId` or `managedDisk` must be specified.
	//
	// > **Note:** Changing `defaultLogStorageAccountId` forces a new resource to be created. But removing it does not.
	//
	// > **Note:** When `defaultLogStorageAccountId` co-exist with `managedDisk`, the value of `defaultLogStorageAccountId` must be as same as `logStorageAccountId` of every `managedDisk` or it forces a new resource to be created.
	DefaultLogStorageAccountId pulumi.StringPtrInput
	// The type of storage account that should be used for recovery disks when a failover is done. Possible values are `Premium_LRS`, `Standard_LRS` and `StandardSSD_LRS`.
	//
	// > **Note:** Only one of `defaultRecoveryDiskType` or `managedDisk` must be specified.
	//
	// > **Note:** Changing `defaultRecoveryDiskType` forces a new resource to be created. But removing it does not.
	//
	// > **Note:** When `defaultRecoveryDiskType` co-exist with `managedDisk`, the value of `defaultRecoveryDiskType` must be as same as `targetDiskType` of every `managedDisk` or it forces a new resource to be created.
	DefaultRecoveryDiskType pulumi.StringPtrInput
	// The ID of the default Disk Encryption Set that should be used for the disks when a failover is done.
	//
	// > **Note:** Changing `defaultTargetDiskEncryptionSetId` forces a new resource to be created. But removing it does not.
	//
	// > **Note:** When `defaultTargetDiskEncryptionSetId` co-exist with `managedDisk`, the value of `defaultTargetDiskEncryptionSetId` must be as same as `targetDiskEncryptionSetId` of every `managedDisk` or it forces a new resource to be created.
	DefaultTargetDiskEncryptionSetId pulumi.StringPtrInput
	// The license type of the VM. Possible values are `NoLicenseType`, `NotSpecified` and `WindowsServer`. Defaults to `NotSpecified`.
	LicenseType pulumi.StringPtrInput
	// One or more `managedDisk` block as defined below. It's available only if mobility service is already installed on the source VM.
	//
	// > **Note:** A replicated VM could be created without `managedDisk` block, once the block has been specified, changing it expect removing it forces a new resource to be created.
	ManagedDisks VmwareReplicatedVmManagedDiskArrayInput
	// Name of group in which all machines will replicate together and have shared crash consistent and app-consistent recovery points when failed over.
	MultiVmGroupName pulumi.StringPtrInput
	// The name of the replicated VM. Changing this forces a new resource to be created.
	Name pulumi.StringPtrInput
	// One or more `networkInterface` block as defined below.
	NetworkInterfaces VmwareReplicatedVmNetworkInterfaceArrayInput
	// The name of the credential to access the source VM. Changing this forces a new resource to be created. More information about the credentials could be found [here](https://learn.microsoft.com/en-us/azure/site-recovery/deploy-vmware-azure-replication-appliance-modernized).
	PhysicalServerCredentialName pulumi.StringPtrInput
	// The ID of the policy to use for this replicated VM.
	RecoveryReplicationPolicyId pulumi.StringPtrInput
	// The ID of the Recovery Services Vault where the replicated VM is created.
	RecoveryVaultId pulumi.StringPtrInput
	// The name of the source VM in VMWare. Changing this forces a new resource to be created.
	SourceVmName pulumi.StringPtrInput
	// The ID of availability set that the new VM should belong to when a failover is done.
	TargetAvailabilitySetId pulumi.StringPtrInput
	// The ID of the storage account that should be used for boot diagnostics when a failover is done.
	TargetBootDiagnosticsStorageAccountId pulumi.StringPtrInput
	// The ID of network to use when a failover is done.
	//
	// > **Note:** `targetNetworkId` is required when `networkInterface` is specified.
	TargetNetworkId pulumi.StringPtrInput
	// The ID of Proximity Placement Group the new VM should belong to when a failover is done.
	//
	// > **Note:** Only one of `targetAvailabilitySetId` or `targetZone` can be specified.
	TargetProximityPlacementGroupId pulumi.StringPtrInput
	// The ID of resource group where the VM should be created when a failover is done.
	TargetResourceGroupId pulumi.StringPtrInput
	// Name of the VM that should be created when a failover is done. Changing this forces a new resource to be created.
	TargetVmName pulumi.StringPtrInput
	// Size of the VM that should be created when a failover is done, such as `Standard_F2`. If it's not specified, it will automatically be set by detecting the source VM size.
	TargetVmSize pulumi.StringPtrInput
	// Specifies the Availability Zone where the Failover VM should exist.
	TargetZone pulumi.StringPtrInput
	// The ID of network to use when a test failover is done.
	TestNetworkId pulumi.StringPtrInput
}

func (VmwareReplicatedVmState) ElementType() reflect.Type {
	return reflect.TypeOf((*vmwareReplicatedVmState)(nil)).Elem()
}

type vmwareReplicatedVmArgs struct {
	// The name of VMWare appliance which handles the replication. Changing this forces a new resource to be created.
	ApplianceName string `pulumi:"applianceName"`
	// The ID of the stroage account that should be used for logging during replication.
	//
	// > **Note:** Only standard types of storage accounts are allowed.
	//
	// > **Note:** Only one of `defaultLogStorageAccountId` or `managedDisk` must be specified.
	//
	// > **Note:** Changing `defaultLogStorageAccountId` forces a new resource to be created. But removing it does not.
	//
	// > **Note:** When `defaultLogStorageAccountId` co-exist with `managedDisk`, the value of `defaultLogStorageAccountId` must be as same as `logStorageAccountId` of every `managedDisk` or it forces a new resource to be created.
	DefaultLogStorageAccountId *string `pulumi:"defaultLogStorageAccountId"`
	// The type of storage account that should be used for recovery disks when a failover is done. Possible values are `Premium_LRS`, `Standard_LRS` and `StandardSSD_LRS`.
	//
	// > **Note:** Only one of `defaultRecoveryDiskType` or `managedDisk` must be specified.
	//
	// > **Note:** Changing `defaultRecoveryDiskType` forces a new resource to be created. But removing it does not.
	//
	// > **Note:** When `defaultRecoveryDiskType` co-exist with `managedDisk`, the value of `defaultRecoveryDiskType` must be as same as `targetDiskType` of every `managedDisk` or it forces a new resource to be created.
	DefaultRecoveryDiskType *string `pulumi:"defaultRecoveryDiskType"`
	// The ID of the default Disk Encryption Set that should be used for the disks when a failover is done.
	//
	// > **Note:** Changing `defaultTargetDiskEncryptionSetId` forces a new resource to be created. But removing it does not.
	//
	// > **Note:** When `defaultTargetDiskEncryptionSetId` co-exist with `managedDisk`, the value of `defaultTargetDiskEncryptionSetId` must be as same as `targetDiskEncryptionSetId` of every `managedDisk` or it forces a new resource to be created.
	DefaultTargetDiskEncryptionSetId *string `pulumi:"defaultTargetDiskEncryptionSetId"`
	// The license type of the VM. Possible values are `NoLicenseType`, `NotSpecified` and `WindowsServer`. Defaults to `NotSpecified`.
	LicenseType *string `pulumi:"licenseType"`
	// One or more `managedDisk` block as defined below. It's available only if mobility service is already installed on the source VM.
	//
	// > **Note:** A replicated VM could be created without `managedDisk` block, once the block has been specified, changing it expect removing it forces a new resource to be created.
	ManagedDisks []VmwareReplicatedVmManagedDisk `pulumi:"managedDisks"`
	// Name of group in which all machines will replicate together and have shared crash consistent and app-consistent recovery points when failed over.
	MultiVmGroupName *string `pulumi:"multiVmGroupName"`
	// The name of the replicated VM. Changing this forces a new resource to be created.
	Name *string `pulumi:"name"`
	// One or more `networkInterface` block as defined below.
	NetworkInterfaces []VmwareReplicatedVmNetworkInterface `pulumi:"networkInterfaces"`
	// The name of the credential to access the source VM. Changing this forces a new resource to be created. More information about the credentials could be found [here](https://learn.microsoft.com/en-us/azure/site-recovery/deploy-vmware-azure-replication-appliance-modernized).
	PhysicalServerCredentialName string `pulumi:"physicalServerCredentialName"`
	// The ID of the policy to use for this replicated VM.
	RecoveryReplicationPolicyId string `pulumi:"recoveryReplicationPolicyId"`
	// The ID of the Recovery Services Vault where the replicated VM is created.
	RecoveryVaultId string `pulumi:"recoveryVaultId"`
	// The name of the source VM in VMWare. Changing this forces a new resource to be created.
	SourceVmName string `pulumi:"sourceVmName"`
	// The ID of availability set that the new VM should belong to when a failover is done.
	TargetAvailabilitySetId *string `pulumi:"targetAvailabilitySetId"`
	// The ID of the storage account that should be used for boot diagnostics when a failover is done.
	TargetBootDiagnosticsStorageAccountId *string `pulumi:"targetBootDiagnosticsStorageAccountId"`
	// The ID of network to use when a failover is done.
	//
	// > **Note:** `targetNetworkId` is required when `networkInterface` is specified.
	TargetNetworkId *string `pulumi:"targetNetworkId"`
	// The ID of Proximity Placement Group the new VM should belong to when a failover is done.
	//
	// > **Note:** Only one of `targetAvailabilitySetId` or `targetZone` can be specified.
	TargetProximityPlacementGroupId *string `pulumi:"targetProximityPlacementGroupId"`
	// The ID of resource group where the VM should be created when a failover is done.
	TargetResourceGroupId string `pulumi:"targetResourceGroupId"`
	// Name of the VM that should be created when a failover is done. Changing this forces a new resource to be created.
	TargetVmName string `pulumi:"targetVmName"`
	// Size of the VM that should be created when a failover is done, such as `Standard_F2`. If it's not specified, it will automatically be set by detecting the source VM size.
	TargetVmSize *string `pulumi:"targetVmSize"`
	// Specifies the Availability Zone where the Failover VM should exist.
	TargetZone *string `pulumi:"targetZone"`
	// The ID of network to use when a test failover is done.
	TestNetworkId *string `pulumi:"testNetworkId"`
}

// The set of arguments for constructing a VmwareReplicatedVm resource.
type VmwareReplicatedVmArgs struct {
	// The name of VMWare appliance which handles the replication. Changing this forces a new resource to be created.
	ApplianceName pulumi.StringInput
	// The ID of the stroage account that should be used for logging during replication.
	//
	// > **Note:** Only standard types of storage accounts are allowed.
	//
	// > **Note:** Only one of `defaultLogStorageAccountId` or `managedDisk` must be specified.
	//
	// > **Note:** Changing `defaultLogStorageAccountId` forces a new resource to be created. But removing it does not.
	//
	// > **Note:** When `defaultLogStorageAccountId` co-exist with `managedDisk`, the value of `defaultLogStorageAccountId` must be as same as `logStorageAccountId` of every `managedDisk` or it forces a new resource to be created.
	DefaultLogStorageAccountId pulumi.StringPtrInput
	// The type of storage account that should be used for recovery disks when a failover is done. Possible values are `Premium_LRS`, `Standard_LRS` and `StandardSSD_LRS`.
	//
	// > **Note:** Only one of `defaultRecoveryDiskType` or `managedDisk` must be specified.
	//
	// > **Note:** Changing `defaultRecoveryDiskType` forces a new resource to be created. But removing it does not.
	//
	// > **Note:** When `defaultRecoveryDiskType` co-exist with `managedDisk`, the value of `defaultRecoveryDiskType` must be as same as `targetDiskType` of every `managedDisk` or it forces a new resource to be created.
	DefaultRecoveryDiskType pulumi.StringPtrInput
	// The ID of the default Disk Encryption Set that should be used for the disks when a failover is done.
	//
	// > **Note:** Changing `defaultTargetDiskEncryptionSetId` forces a new resource to be created. But removing it does not.
	//
	// > **Note:** When `defaultTargetDiskEncryptionSetId` co-exist with `managedDisk`, the value of `defaultTargetDiskEncryptionSetId` must be as same as `targetDiskEncryptionSetId` of every `managedDisk` or it forces a new resource to be created.
	DefaultTargetDiskEncryptionSetId pulumi.StringPtrInput
	// The license type of the VM. Possible values are `NoLicenseType`, `NotSpecified` and `WindowsServer`. Defaults to `NotSpecified`.
	LicenseType pulumi.StringPtrInput
	// One or more `managedDisk` block as defined below. It's available only if mobility service is already installed on the source VM.
	//
	// > **Note:** A replicated VM could be created without `managedDisk` block, once the block has been specified, changing it expect removing it forces a new resource to be created.
	ManagedDisks VmwareReplicatedVmManagedDiskArrayInput
	// Name of group in which all machines will replicate together and have shared crash consistent and app-consistent recovery points when failed over.
	MultiVmGroupName pulumi.StringPtrInput
	// The name of the replicated VM. Changing this forces a new resource to be created.
	Name pulumi.StringPtrInput
	// One or more `networkInterface` block as defined below.
	NetworkInterfaces VmwareReplicatedVmNetworkInterfaceArrayInput
	// The name of the credential to access the source VM. Changing this forces a new resource to be created. More information about the credentials could be found [here](https://learn.microsoft.com/en-us/azure/site-recovery/deploy-vmware-azure-replication-appliance-modernized).
	PhysicalServerCredentialName pulumi.StringInput
	// The ID of the policy to use for this replicated VM.
	RecoveryReplicationPolicyId pulumi.StringInput
	// The ID of the Recovery Services Vault where the replicated VM is created.
	RecoveryVaultId pulumi.StringInput
	// The name of the source VM in VMWare. Changing this forces a new resource to be created.
	SourceVmName pulumi.StringInput
	// The ID of availability set that the new VM should belong to when a failover is done.
	TargetAvailabilitySetId pulumi.StringPtrInput
	// The ID of the storage account that should be used for boot diagnostics when a failover is done.
	TargetBootDiagnosticsStorageAccountId pulumi.StringPtrInput
	// The ID of network to use when a failover is done.
	//
	// > **Note:** `targetNetworkId` is required when `networkInterface` is specified.
	TargetNetworkId pulumi.StringPtrInput
	// The ID of Proximity Placement Group the new VM should belong to when a failover is done.
	//
	// > **Note:** Only one of `targetAvailabilitySetId` or `targetZone` can be specified.
	TargetProximityPlacementGroupId pulumi.StringPtrInput
	// The ID of resource group where the VM should be created when a failover is done.
	TargetResourceGroupId pulumi.StringInput
	// Name of the VM that should be created when a failover is done. Changing this forces a new resource to be created.
	TargetVmName pulumi.StringInput
	// Size of the VM that should be created when a failover is done, such as `Standard_F2`. If it's not specified, it will automatically be set by detecting the source VM size.
	TargetVmSize pulumi.StringPtrInput
	// Specifies the Availability Zone where the Failover VM should exist.
	TargetZone pulumi.StringPtrInput
	// The ID of network to use when a test failover is done.
	TestNetworkId pulumi.StringPtrInput
}

func (VmwareReplicatedVmArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*vmwareReplicatedVmArgs)(nil)).Elem()
}

type VmwareReplicatedVmInput interface {
	pulumi.Input

	ToVmwareReplicatedVmOutput() VmwareReplicatedVmOutput
	ToVmwareReplicatedVmOutputWithContext(ctx context.Context) VmwareReplicatedVmOutput
}

func (*VmwareReplicatedVm) ElementType() reflect.Type {
	return reflect.TypeOf((**VmwareReplicatedVm)(nil)).Elem()
}

func (i *VmwareReplicatedVm) ToVmwareReplicatedVmOutput() VmwareReplicatedVmOutput {
	return i.ToVmwareReplicatedVmOutputWithContext(context.Background())
}

func (i *VmwareReplicatedVm) ToVmwareReplicatedVmOutputWithContext(ctx context.Context) VmwareReplicatedVmOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VmwareReplicatedVmOutput)
}

// VmwareReplicatedVmArrayInput is an input type that accepts VmwareReplicatedVmArray and VmwareReplicatedVmArrayOutput values.
// You can construct a concrete instance of `VmwareReplicatedVmArrayInput` via:
//
//	VmwareReplicatedVmArray{ VmwareReplicatedVmArgs{...} }
type VmwareReplicatedVmArrayInput interface {
	pulumi.Input

	ToVmwareReplicatedVmArrayOutput() VmwareReplicatedVmArrayOutput
	ToVmwareReplicatedVmArrayOutputWithContext(context.Context) VmwareReplicatedVmArrayOutput
}

type VmwareReplicatedVmArray []VmwareReplicatedVmInput

func (VmwareReplicatedVmArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*VmwareReplicatedVm)(nil)).Elem()
}

func (i VmwareReplicatedVmArray) ToVmwareReplicatedVmArrayOutput() VmwareReplicatedVmArrayOutput {
	return i.ToVmwareReplicatedVmArrayOutputWithContext(context.Background())
}

func (i VmwareReplicatedVmArray) ToVmwareReplicatedVmArrayOutputWithContext(ctx context.Context) VmwareReplicatedVmArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VmwareReplicatedVmArrayOutput)
}

// VmwareReplicatedVmMapInput is an input type that accepts VmwareReplicatedVmMap and VmwareReplicatedVmMapOutput values.
// You can construct a concrete instance of `VmwareReplicatedVmMapInput` via:
//
//	VmwareReplicatedVmMap{ "key": VmwareReplicatedVmArgs{...} }
type VmwareReplicatedVmMapInput interface {
	pulumi.Input

	ToVmwareReplicatedVmMapOutput() VmwareReplicatedVmMapOutput
	ToVmwareReplicatedVmMapOutputWithContext(context.Context) VmwareReplicatedVmMapOutput
}

type VmwareReplicatedVmMap map[string]VmwareReplicatedVmInput

func (VmwareReplicatedVmMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*VmwareReplicatedVm)(nil)).Elem()
}

func (i VmwareReplicatedVmMap) ToVmwareReplicatedVmMapOutput() VmwareReplicatedVmMapOutput {
	return i.ToVmwareReplicatedVmMapOutputWithContext(context.Background())
}

func (i VmwareReplicatedVmMap) ToVmwareReplicatedVmMapOutputWithContext(ctx context.Context) VmwareReplicatedVmMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VmwareReplicatedVmMapOutput)
}

type VmwareReplicatedVmOutput struct{ *pulumi.OutputState }

func (VmwareReplicatedVmOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VmwareReplicatedVm)(nil)).Elem()
}

func (o VmwareReplicatedVmOutput) ToVmwareReplicatedVmOutput() VmwareReplicatedVmOutput {
	return o
}

func (o VmwareReplicatedVmOutput) ToVmwareReplicatedVmOutputWithContext(ctx context.Context) VmwareReplicatedVmOutput {
	return o
}

// The name of VMWare appliance which handles the replication. Changing this forces a new resource to be created.
func (o VmwareReplicatedVmOutput) ApplianceName() pulumi.StringOutput {
	return o.ApplyT(func(v *VmwareReplicatedVm) pulumi.StringOutput { return v.ApplianceName }).(pulumi.StringOutput)
}

// The ID of the stroage account that should be used for logging during replication.
//
// > **Note:** Only standard types of storage accounts are allowed.
//
// > **Note:** Only one of `defaultLogStorageAccountId` or `managedDisk` must be specified.
//
// > **Note:** Changing `defaultLogStorageAccountId` forces a new resource to be created. But removing it does not.
//
// > **Note:** When `defaultLogStorageAccountId` co-exist with `managedDisk`, the value of `defaultLogStorageAccountId` must be as same as `logStorageAccountId` of every `managedDisk` or it forces a new resource to be created.
func (o VmwareReplicatedVmOutput) DefaultLogStorageAccountId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VmwareReplicatedVm) pulumi.StringPtrOutput { return v.DefaultLogStorageAccountId }).(pulumi.StringPtrOutput)
}

// The type of storage account that should be used for recovery disks when a failover is done. Possible values are `Premium_LRS`, `Standard_LRS` and `StandardSSD_LRS`.
//
// > **Note:** Only one of `defaultRecoveryDiskType` or `managedDisk` must be specified.
//
// > **Note:** Changing `defaultRecoveryDiskType` forces a new resource to be created. But removing it does not.
//
// > **Note:** When `defaultRecoveryDiskType` co-exist with `managedDisk`, the value of `defaultRecoveryDiskType` must be as same as `targetDiskType` of every `managedDisk` or it forces a new resource to be created.
func (o VmwareReplicatedVmOutput) DefaultRecoveryDiskType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VmwareReplicatedVm) pulumi.StringPtrOutput { return v.DefaultRecoveryDiskType }).(pulumi.StringPtrOutput)
}

// The ID of the default Disk Encryption Set that should be used for the disks when a failover is done.
//
// > **Note:** Changing `defaultTargetDiskEncryptionSetId` forces a new resource to be created. But removing it does not.
//
// > **Note:** When `defaultTargetDiskEncryptionSetId` co-exist with `managedDisk`, the value of `defaultTargetDiskEncryptionSetId` must be as same as `targetDiskEncryptionSetId` of every `managedDisk` or it forces a new resource to be created.
func (o VmwareReplicatedVmOutput) DefaultTargetDiskEncryptionSetId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VmwareReplicatedVm) pulumi.StringPtrOutput { return v.DefaultTargetDiskEncryptionSetId }).(pulumi.StringPtrOutput)
}

// The license type of the VM. Possible values are `NoLicenseType`, `NotSpecified` and `WindowsServer`. Defaults to `NotSpecified`.
func (o VmwareReplicatedVmOutput) LicenseType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VmwareReplicatedVm) pulumi.StringPtrOutput { return v.LicenseType }).(pulumi.StringPtrOutput)
}

// One or more `managedDisk` block as defined below. It's available only if mobility service is already installed on the source VM.
//
// > **Note:** A replicated VM could be created without `managedDisk` block, once the block has been specified, changing it expect removing it forces a new resource to be created.
func (o VmwareReplicatedVmOutput) ManagedDisks() VmwareReplicatedVmManagedDiskArrayOutput {
	return o.ApplyT(func(v *VmwareReplicatedVm) VmwareReplicatedVmManagedDiskArrayOutput { return v.ManagedDisks }).(VmwareReplicatedVmManagedDiskArrayOutput)
}

// Name of group in which all machines will replicate together and have shared crash consistent and app-consistent recovery points when failed over.
func (o VmwareReplicatedVmOutput) MultiVmGroupName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VmwareReplicatedVm) pulumi.StringPtrOutput { return v.MultiVmGroupName }).(pulumi.StringPtrOutput)
}

// The name of the replicated VM. Changing this forces a new resource to be created.
func (o VmwareReplicatedVmOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *VmwareReplicatedVm) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// One or more `networkInterface` block as defined below.
func (o VmwareReplicatedVmOutput) NetworkInterfaces() VmwareReplicatedVmNetworkInterfaceArrayOutput {
	return o.ApplyT(func(v *VmwareReplicatedVm) VmwareReplicatedVmNetworkInterfaceArrayOutput { return v.NetworkInterfaces }).(VmwareReplicatedVmNetworkInterfaceArrayOutput)
}

// The name of the credential to access the source VM. Changing this forces a new resource to be created. More information about the credentials could be found [here](https://learn.microsoft.com/en-us/azure/site-recovery/deploy-vmware-azure-replication-appliance-modernized).
func (o VmwareReplicatedVmOutput) PhysicalServerCredentialName() pulumi.StringOutput {
	return o.ApplyT(func(v *VmwareReplicatedVm) pulumi.StringOutput { return v.PhysicalServerCredentialName }).(pulumi.StringOutput)
}

// The ID of the policy to use for this replicated VM.
func (o VmwareReplicatedVmOutput) RecoveryReplicationPolicyId() pulumi.StringOutput {
	return o.ApplyT(func(v *VmwareReplicatedVm) pulumi.StringOutput { return v.RecoveryReplicationPolicyId }).(pulumi.StringOutput)
}

// The ID of the Recovery Services Vault where the replicated VM is created.
func (o VmwareReplicatedVmOutput) RecoveryVaultId() pulumi.StringOutput {
	return o.ApplyT(func(v *VmwareReplicatedVm) pulumi.StringOutput { return v.RecoveryVaultId }).(pulumi.StringOutput)
}

// The name of the source VM in VMWare. Changing this forces a new resource to be created.
func (o VmwareReplicatedVmOutput) SourceVmName() pulumi.StringOutput {
	return o.ApplyT(func(v *VmwareReplicatedVm) pulumi.StringOutput { return v.SourceVmName }).(pulumi.StringOutput)
}

// The ID of availability set that the new VM should belong to when a failover is done.
func (o VmwareReplicatedVmOutput) TargetAvailabilitySetId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VmwareReplicatedVm) pulumi.StringPtrOutput { return v.TargetAvailabilitySetId }).(pulumi.StringPtrOutput)
}

// The ID of the storage account that should be used for boot diagnostics when a failover is done.
func (o VmwareReplicatedVmOutput) TargetBootDiagnosticsStorageAccountId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VmwareReplicatedVm) pulumi.StringPtrOutput { return v.TargetBootDiagnosticsStorageAccountId }).(pulumi.StringPtrOutput)
}

// The ID of network to use when a failover is done.
//
// > **Note:** `targetNetworkId` is required when `networkInterface` is specified.
func (o VmwareReplicatedVmOutput) TargetNetworkId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VmwareReplicatedVm) pulumi.StringPtrOutput { return v.TargetNetworkId }).(pulumi.StringPtrOutput)
}

// The ID of Proximity Placement Group the new VM should belong to when a failover is done.
//
// > **Note:** Only one of `targetAvailabilitySetId` or `targetZone` can be specified.
func (o VmwareReplicatedVmOutput) TargetProximityPlacementGroupId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VmwareReplicatedVm) pulumi.StringPtrOutput { return v.TargetProximityPlacementGroupId }).(pulumi.StringPtrOutput)
}

// The ID of resource group where the VM should be created when a failover is done.
func (o VmwareReplicatedVmOutput) TargetResourceGroupId() pulumi.StringOutput {
	return o.ApplyT(func(v *VmwareReplicatedVm) pulumi.StringOutput { return v.TargetResourceGroupId }).(pulumi.StringOutput)
}

// Name of the VM that should be created when a failover is done. Changing this forces a new resource to be created.
func (o VmwareReplicatedVmOutput) TargetVmName() pulumi.StringOutput {
	return o.ApplyT(func(v *VmwareReplicatedVm) pulumi.StringOutput { return v.TargetVmName }).(pulumi.StringOutput)
}

// Size of the VM that should be created when a failover is done, such as `Standard_F2`. If it's not specified, it will automatically be set by detecting the source VM size.
func (o VmwareReplicatedVmOutput) TargetVmSize() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VmwareReplicatedVm) pulumi.StringPtrOutput { return v.TargetVmSize }).(pulumi.StringPtrOutput)
}

// Specifies the Availability Zone where the Failover VM should exist.
func (o VmwareReplicatedVmOutput) TargetZone() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VmwareReplicatedVm) pulumi.StringPtrOutput { return v.TargetZone }).(pulumi.StringPtrOutput)
}

// The ID of network to use when a test failover is done.
func (o VmwareReplicatedVmOutput) TestNetworkId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VmwareReplicatedVm) pulumi.StringPtrOutput { return v.TestNetworkId }).(pulumi.StringPtrOutput)
}

type VmwareReplicatedVmArrayOutput struct{ *pulumi.OutputState }

func (VmwareReplicatedVmArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*VmwareReplicatedVm)(nil)).Elem()
}

func (o VmwareReplicatedVmArrayOutput) ToVmwareReplicatedVmArrayOutput() VmwareReplicatedVmArrayOutput {
	return o
}

func (o VmwareReplicatedVmArrayOutput) ToVmwareReplicatedVmArrayOutputWithContext(ctx context.Context) VmwareReplicatedVmArrayOutput {
	return o
}

func (o VmwareReplicatedVmArrayOutput) Index(i pulumi.IntInput) VmwareReplicatedVmOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *VmwareReplicatedVm {
		return vs[0].([]*VmwareReplicatedVm)[vs[1].(int)]
	}).(VmwareReplicatedVmOutput)
}

type VmwareReplicatedVmMapOutput struct{ *pulumi.OutputState }

func (VmwareReplicatedVmMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*VmwareReplicatedVm)(nil)).Elem()
}

func (o VmwareReplicatedVmMapOutput) ToVmwareReplicatedVmMapOutput() VmwareReplicatedVmMapOutput {
	return o
}

func (o VmwareReplicatedVmMapOutput) ToVmwareReplicatedVmMapOutputWithContext(ctx context.Context) VmwareReplicatedVmMapOutput {
	return o
}

func (o VmwareReplicatedVmMapOutput) MapIndex(k pulumi.StringInput) VmwareReplicatedVmOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *VmwareReplicatedVm {
		return vs[0].(map[string]*VmwareReplicatedVm)[vs[1].(string)]
	}).(VmwareReplicatedVmOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*VmwareReplicatedVmInput)(nil)).Elem(), &VmwareReplicatedVm{})
	pulumi.RegisterInputType(reflect.TypeOf((*VmwareReplicatedVmArrayInput)(nil)).Elem(), VmwareReplicatedVmArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*VmwareReplicatedVmMapInput)(nil)).Elem(), VmwareReplicatedVmMap{})
	pulumi.RegisterOutputType(VmwareReplicatedVmOutput{})
	pulumi.RegisterOutputType(VmwareReplicatedVmArrayOutput{})
	pulumi.RegisterOutputType(VmwareReplicatedVmMapOutput{})
}
