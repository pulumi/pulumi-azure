// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package siterecovery

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-azure/sdk/v5/go/azure/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages a VMWare replicated VM using Azure Site Recovery (VMWare to Azure only). A replicated VM keeps a copiously updated image of the VM in Azure in order to be able to start the VM in Azure in case of a disaster.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	core/resourceGroup "github.com/pulumi/pulumi-azure/sdk/v1/go/azure/core/resourceGroup"
//	network/subnet "github.com/pulumi/pulumi-azure/sdk/v1/go/azure/network/subnet"
//	network/virtualNetwork "github.com/pulumi/pulumi-azure/sdk/v1/go/azure/network/virtualNetwork"
//	recoveryservices/vault "github.com/pulumi/pulumi-azure/sdk/v1/go/azure/recoveryservices/vault"
//	siterecovery/vMWareReplicationPolicy "github.com/pulumi/pulumi-azure/sdk/v1/go/azure/siterecovery/vMWareReplicationPolicy"
//	siterecovery/vmwareReplicatedVm "github.com/pulumi/pulumi-azure/sdk/v1/go/azure/siterecovery/vmwareReplicatedVm"
//	siterecovery/vmwareReplicationPolicyAssociation "github.com/pulumi/pulumi-azure/sdk/v1/go/azure/siterecovery/vmwareReplicationPolicyAssociation"
//	storage/account "github.com/pulumi/pulumi-azure/sdk/v1/go/azure/storage/account"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
// func main() {
// pulumi.Run(func(ctx *pulumi.Context) error {
// example, err := core/resourceGroup.NewResourceGroup(ctx, "example", &core/resourceGroup.ResourceGroupArgs{
// Name: "example-rg",
// Location: "West US",
// })
// if err != nil {
// return err
// }
// exampleVault, err := recoveryservices/vault.NewVault(ctx, "example", &recoveryservices/vault.VaultArgs{
// Name: "example-recovery-vault",
// Location: example.Location,
// ResourceGroupName: example.Name,
// Sku: "Standard",
// })
// if err != nil {
// return err
// }
// exampleVMWareReplicationPolicy, err := siterecovery/vMWareReplicationPolicy.NewVMWareReplicationPolicy(ctx, "example", &siterecovery/vMWareReplicationPolicy.VMWareReplicationPolicyArgs{
// RecoveryVaultId: exampleVault.Id,
// Name: "example-policy",
// RecoveryPointRetentionInMinutes: 1440,
// ApplicationConsistentSnapshotFrequencyInMinutes: 240,
// })
// if err != nil {
// return err
// }
// _, err = siterecovery/vmwareReplicationPolicyAssociation.NewVmwareReplicationPolicyAssociation(ctx, "test", &siterecovery/vmwareReplicationPolicyAssociation.VmwareReplicationPolicyAssociationArgs{
// Name: "example-association",
// RecoveryVaultId: exampleVault.Id,
// PolicyId: exampleVMWareReplicationPolicy.Id,
// })
// if err != nil {
// return err
// }
// exampleAccount, err := storage/account.NewAccount(ctx, "example", &storage/account.AccountArgs{
// Name: "examplestorageacc",
// ResourceGroupName: example.Name,
// Location: example.Location,
// AccountTier: "Standard",
// AccountKind: "StorageV2",
// AccountReplicationType: "LRS",
// })
// if err != nil {
// return err
// }
// exampleVirtualNetwork, err := network/virtualNetwork.NewVirtualNetwork(ctx, "example", &network/virtualNetwork.VirtualNetworkArgs{
// Name: "example-net",
// ResourceGroupName: example.Name,
// AddressSpaces: []string{
// "192.168.2.0/24",
// },
// Location: example.Location,
// })
// if err != nil {
// return err
// }
// exampleSubnet, err := network/subnet.NewSubnet(ctx, "example", &network/subnet.SubnetArgs{
// Name: "example-subnet",
// ResourceGroupName: example.Name,
// VirtualNetworkName: exampleVirtualNetwork.Name,
// AddressPrefixes: []string{
// "192.168.2.0/24",
// },
// })
// if err != nil {
// return err
// }
// _, err = siterecovery/vmwareReplicatedVm.NewVmwareReplicatedVm(ctx, "example", &siterecovery/vmwareReplicatedVm.VmwareReplicatedVmArgs{
// Name: "example-vmware-vm",
// RecoveryVaultId: exampleVault.Id,
// SourceVmName: "example-vm",
// ApplianceName: "example-appliance",
// RecoveryReplicationPolicyId: exampleAzurermSiteRecoveryVmwareReplicationPolicyAssociation.PolicyId,
// PhysicalServerCredentialName: "example-creds",
// LicenseType: "NotSpecified",
// TargetBootDiagnosticsStorageAccountId: exampleAccount.Id,
// TargetVmName: "example_replicated_vm",
// TargetResourceGroupId: example.Id,
// DefaultLogStorageAccountId: exampleAccount.Id,
// DefaultRecoveryDiskType: "Standard_LRS",
// TargetNetworkId: exampleVirtualNetwork.Id,
// NetworkInterfaces: []map[string]interface{}{
// map[string]interface{}{
// "sourceMacAddress": "00:00:00:00:00:00",
// "targetSubnetName": exampleSubnet.Name,
// "isPrimary": true,
// },
// },
// })
// if err != nil {
// return err
// }
// return nil
// })
// }
// ```
//
// ## Import
//
// Site Recovery VMWare Replicated VM's can be imported using the `resource id`, e.g.
//
// ```sh
// $ pulumi import azure:siterecovery/vmwareReplicatedVm:VmwareReplicatedVm vmreplication /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/resource-group-name/providers/Microsoft.RecoveryServices/vaults/recovery-vault-name/replicationFabrics/fabric-name/replicationProtectionContainers/protection-container-name/replicationProtectedItems/vm-replication-name
// ```
type VmwareReplicatedVm struct {
	pulumi.CustomResourceState

	// The name of VMWare appliance which handles the replication. Changing this forces a new resource to be created.
	ApplianceName pulumi.StringOutput `pulumi:"applianceName"`
	// The ID of the stroage account that should be used for logging during replication.
	//
	// **Note:** Only standard types of storage accounts are allowed.
	//
	// **Note:** Only one of `defaultLogStorageAccountId` or `managedDisk` must be specified.
	//
	// **Note:** Changing `defaultLogStorageAccountId` forces a new resource to be created. But removing it does not.
	//
	// **Note:** When `defaultLogStorageAccountId` co-exist with `managedDisk`, the value of `defaultLogStorageAccountId` must be as same as `logStorageAccountId` of every `managedDisk` or it forces a new resource to be created.
	DefaultLogStorageAccountId pulumi.StringPtrOutput `pulumi:"defaultLogStorageAccountId"`
	// The type of storage account that should be used for recovery disks when a failover is done. Possible values are `Standard_LRS`, `Standard_LRS` and `StandardSSD_LRS`.
	//
	// **Note:** Only one of `defaultRecoveryDiskType` or `managedDisk` must be specified.
	//
	// **Note:** Changing `defaultRecoveryDiskType` forces a new resource to be created. But removing it does not.
	//
	// **Note:** When `defaultRecoveryDiskType` co-exist with `managedDisk`, the value of `defaultRecoveryDiskType` must be as same as `targetDiskType` of every `managedDisk` or it forces a new resource to be created.
	DefaultRecoveryDiskType pulumi.StringPtrOutput `pulumi:"defaultRecoveryDiskType"`
	// The ID of the default Disk Encryption Set that should be used for the disks when a failover is done.
	//
	// **Note:** Changing `defaultTargetDiskEncryptionSetId` forces a new resource to be created. But removing it does not.
	//
	// **Note:** When `defaultTargetDiskEncryptionSetId` co-exist with `managedDisk`, the value of `defaultTargetDiskEncryptionSetId` must be as same as `targetDiskEncryptionSetId` of every `managedDisk` or it forces a new resource to be created.
	DefaultTargetDiskEncryptionSetId pulumi.StringPtrOutput `pulumi:"defaultTargetDiskEncryptionSetId"`
	// The license type of the VM. Possible values are `NoLicenseType`, `NotSpecified` and `WindowsServer`. Defaults to `NotSpecified`.
	LicenseType pulumi.StringPtrOutput `pulumi:"licenseType"`
	// One or more `managedDisk` block as defined below. It's available only if mobility service is already installed on the source VM.
	//
	// **Note:** A replicated VM could be created without `managedDisk` block, once the block has been specified, changing it expect removing it forces a new resource to be created.
	ManagedDisks VmwareReplicatedVmManagedDiskArrayOutput `pulumi:"managedDisks"`
	// Name of group in which all machines will replicate together and have shared crash consistent and app-consistent recovery points when failed over. Changing this forces a new resource to be created.
	MultiVmGroupName pulumi.StringPtrOutput `pulumi:"multiVmGroupName"`
	// The name of the replicated VM. Changing this forces a new resource to be created.
	Name pulumi.StringOutput `pulumi:"name"`
	// One or more `networkInterface` block as defined below.
	NetworkInterfaces VmwareReplicatedVmNetworkInterfaceArrayOutput `pulumi:"networkInterfaces"`
	// The name of the credential to access the source VM. Changing this forces a new resource to be created. More information about the credentials could be found [here](https://learn.microsoft.com/en-us/azure/site-recovery/deploy-vmware-azure-replication-appliance-modernized).
	PhysicalServerCredentialName pulumi.StringOutput `pulumi:"physicalServerCredentialName"`
	// The ID of the policy to use for this replicated VM. Changing this forces a new resource to be created.
	RecoveryReplicationPolicyId pulumi.StringOutput `pulumi:"recoveryReplicationPolicyId"`
	// The ID of the Recovery Services Vault where the replicated VM is created. Changing this forces a new resource to be created.
	RecoveryVaultId pulumi.StringOutput `pulumi:"recoveryVaultId"`
	// The name of the source VM in VMWare. Changing this forces a new resource to be created.
	SourceVmName pulumi.StringOutput `pulumi:"sourceVmName"`
	// The ID of availability set that the new VM should belong to when a failover is done. Changing this forces a new resource to be created.
	TargetAvailabilitySetId pulumi.StringPtrOutput `pulumi:"targetAvailabilitySetId"`
	// The ID of the storage account that should be used for boot diagnostics when a failover is done.
	TargetBootDiagnosticsStorageAccountId pulumi.StringPtrOutput `pulumi:"targetBootDiagnosticsStorageAccountId"`
	// The ID of network to use when a failover is done.
	//
	// **Note:** `targetNetworkId` is required when `networkInterface` is specified.
	TargetNetworkId pulumi.StringPtrOutput `pulumi:"targetNetworkId"`
	// The ID of Proximity Placement Group the new VM should belong to when a failover is done.
	//
	// **Note:** Only one of `targetAvailabilitySetId` or `targetZone` can be specified.
	TargetProximityPlacementGroupId pulumi.StringPtrOutput `pulumi:"targetProximityPlacementGroupId"`
	// The ID of resource group where the VM should be created when a failover is done. Changing this forces a new resource to be created.
	TargetResourceGroupId pulumi.StringOutput `pulumi:"targetResourceGroupId"`
	// Name of the VM that should be created when a failover is done. Changing this forces a new resource to be created.
	TargetVmName pulumi.StringOutput `pulumi:"targetVmName"`
	// Size of the VM that should be created when a failover is done, such as `Standard_F2`. If it's not specified, it will automatically be set by detecting the source VM size.
	TargetVmSize pulumi.StringPtrOutput `pulumi:"targetVmSize"`
	// Specifies the Availability Zone where the Failover VM should exist.
	TargetZone pulumi.StringPtrOutput `pulumi:"targetZone"`
	// The ID of network to use when a test failover is done.
	TestNetworkId pulumi.StringPtrOutput `pulumi:"testNetworkId"`
}

// NewVmwareReplicatedVm registers a new resource with the given unique name, arguments, and options.
func NewVmwareReplicatedVm(ctx *pulumi.Context,
	name string, args *VmwareReplicatedVmArgs, opts ...pulumi.ResourceOption) (*VmwareReplicatedVm, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ApplianceName == nil {
		return nil, errors.New("invalid value for required argument 'ApplianceName'")
	}
	if args.PhysicalServerCredentialName == nil {
		return nil, errors.New("invalid value for required argument 'PhysicalServerCredentialName'")
	}
	if args.RecoveryReplicationPolicyId == nil {
		return nil, errors.New("invalid value for required argument 'RecoveryReplicationPolicyId'")
	}
	if args.RecoveryVaultId == nil {
		return nil, errors.New("invalid value for required argument 'RecoveryVaultId'")
	}
	if args.SourceVmName == nil {
		return nil, errors.New("invalid value for required argument 'SourceVmName'")
	}
	if args.TargetResourceGroupId == nil {
		return nil, errors.New("invalid value for required argument 'TargetResourceGroupId'")
	}
	if args.TargetVmName == nil {
		return nil, errors.New("invalid value for required argument 'TargetVmName'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource VmwareReplicatedVm
	err := ctx.RegisterResource("azure:siterecovery/vmwareReplicatedVm:VmwareReplicatedVm", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetVmwareReplicatedVm gets an existing VmwareReplicatedVm resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetVmwareReplicatedVm(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *VmwareReplicatedVmState, opts ...pulumi.ResourceOption) (*VmwareReplicatedVm, error) {
	var resource VmwareReplicatedVm
	err := ctx.ReadResource("azure:siterecovery/vmwareReplicatedVm:VmwareReplicatedVm", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering VmwareReplicatedVm resources.
type vmwareReplicatedVmState struct {
	// The name of VMWare appliance which handles the replication. Changing this forces a new resource to be created.
	ApplianceName *string `pulumi:"applianceName"`
	// The ID of the stroage account that should be used for logging during replication.
	//
	// **Note:** Only standard types of storage accounts are allowed.
	//
	// **Note:** Only one of `defaultLogStorageAccountId` or `managedDisk` must be specified.
	//
	// **Note:** Changing `defaultLogStorageAccountId` forces a new resource to be created. But removing it does not.
	//
	// **Note:** When `defaultLogStorageAccountId` co-exist with `managedDisk`, the value of `defaultLogStorageAccountId` must be as same as `logStorageAccountId` of every `managedDisk` or it forces a new resource to be created.
	DefaultLogStorageAccountId *string `pulumi:"defaultLogStorageAccountId"`
	// The type of storage account that should be used for recovery disks when a failover is done. Possible values are `Standard_LRS`, `Standard_LRS` and `StandardSSD_LRS`.
	//
	// **Note:** Only one of `defaultRecoveryDiskType` or `managedDisk` must be specified.
	//
	// **Note:** Changing `defaultRecoveryDiskType` forces a new resource to be created. But removing it does not.
	//
	// **Note:** When `defaultRecoveryDiskType` co-exist with `managedDisk`, the value of `defaultRecoveryDiskType` must be as same as `targetDiskType` of every `managedDisk` or it forces a new resource to be created.
	DefaultRecoveryDiskType *string `pulumi:"defaultRecoveryDiskType"`
	// The ID of the default Disk Encryption Set that should be used for the disks when a failover is done.
	//
	// **Note:** Changing `defaultTargetDiskEncryptionSetId` forces a new resource to be created. But removing it does not.
	//
	// **Note:** When `defaultTargetDiskEncryptionSetId` co-exist with `managedDisk`, the value of `defaultTargetDiskEncryptionSetId` must be as same as `targetDiskEncryptionSetId` of every `managedDisk` or it forces a new resource to be created.
	DefaultTargetDiskEncryptionSetId *string `pulumi:"defaultTargetDiskEncryptionSetId"`
	// The license type of the VM. Possible values are `NoLicenseType`, `NotSpecified` and `WindowsServer`. Defaults to `NotSpecified`.
	LicenseType *string `pulumi:"licenseType"`
	// One or more `managedDisk` block as defined below. It's available only if mobility service is already installed on the source VM.
	//
	// **Note:** A replicated VM could be created without `managedDisk` block, once the block has been specified, changing it expect removing it forces a new resource to be created.
	ManagedDisks []VmwareReplicatedVmManagedDisk `pulumi:"managedDisks"`
	// Name of group in which all machines will replicate together and have shared crash consistent and app-consistent recovery points when failed over. Changing this forces a new resource to be created.
	MultiVmGroupName *string `pulumi:"multiVmGroupName"`
	// The name of the replicated VM. Changing this forces a new resource to be created.
	Name *string `pulumi:"name"`
	// One or more `networkInterface` block as defined below.
	NetworkInterfaces []VmwareReplicatedVmNetworkInterface `pulumi:"networkInterfaces"`
	// The name of the credential to access the source VM. Changing this forces a new resource to be created. More information about the credentials could be found [here](https://learn.microsoft.com/en-us/azure/site-recovery/deploy-vmware-azure-replication-appliance-modernized).
	PhysicalServerCredentialName *string `pulumi:"physicalServerCredentialName"`
	// The ID of the policy to use for this replicated VM. Changing this forces a new resource to be created.
	RecoveryReplicationPolicyId *string `pulumi:"recoveryReplicationPolicyId"`
	// The ID of the Recovery Services Vault where the replicated VM is created. Changing this forces a new resource to be created.
	RecoveryVaultId *string `pulumi:"recoveryVaultId"`
	// The name of the source VM in VMWare. Changing this forces a new resource to be created.
	SourceVmName *string `pulumi:"sourceVmName"`
	// The ID of availability set that the new VM should belong to when a failover is done. Changing this forces a new resource to be created.
	TargetAvailabilitySetId *string `pulumi:"targetAvailabilitySetId"`
	// The ID of the storage account that should be used for boot diagnostics when a failover is done.
	TargetBootDiagnosticsStorageAccountId *string `pulumi:"targetBootDiagnosticsStorageAccountId"`
	// The ID of network to use when a failover is done.
	//
	// **Note:** `targetNetworkId` is required when `networkInterface` is specified.
	TargetNetworkId *string `pulumi:"targetNetworkId"`
	// The ID of Proximity Placement Group the new VM should belong to when a failover is done.
	//
	// **Note:** Only one of `targetAvailabilitySetId` or `targetZone` can be specified.
	TargetProximityPlacementGroupId *string `pulumi:"targetProximityPlacementGroupId"`
	// The ID of resource group where the VM should be created when a failover is done. Changing this forces a new resource to be created.
	TargetResourceGroupId *string `pulumi:"targetResourceGroupId"`
	// Name of the VM that should be created when a failover is done. Changing this forces a new resource to be created.
	TargetVmName *string `pulumi:"targetVmName"`
	// Size of the VM that should be created when a failover is done, such as `Standard_F2`. If it's not specified, it will automatically be set by detecting the source VM size.
	TargetVmSize *string `pulumi:"targetVmSize"`
	// Specifies the Availability Zone where the Failover VM should exist.
	TargetZone *string `pulumi:"targetZone"`
	// The ID of network to use when a test failover is done.
	TestNetworkId *string `pulumi:"testNetworkId"`
}

type VmwareReplicatedVmState struct {
	// The name of VMWare appliance which handles the replication. Changing this forces a new resource to be created.
	ApplianceName pulumi.StringPtrInput
	// The ID of the stroage account that should be used for logging during replication.
	//
	// **Note:** Only standard types of storage accounts are allowed.
	//
	// **Note:** Only one of `defaultLogStorageAccountId` or `managedDisk` must be specified.
	//
	// **Note:** Changing `defaultLogStorageAccountId` forces a new resource to be created. But removing it does not.
	//
	// **Note:** When `defaultLogStorageAccountId` co-exist with `managedDisk`, the value of `defaultLogStorageAccountId` must be as same as `logStorageAccountId` of every `managedDisk` or it forces a new resource to be created.
	DefaultLogStorageAccountId pulumi.StringPtrInput
	// The type of storage account that should be used for recovery disks when a failover is done. Possible values are `Standard_LRS`, `Standard_LRS` and `StandardSSD_LRS`.
	//
	// **Note:** Only one of `defaultRecoveryDiskType` or `managedDisk` must be specified.
	//
	// **Note:** Changing `defaultRecoveryDiskType` forces a new resource to be created. But removing it does not.
	//
	// **Note:** When `defaultRecoveryDiskType` co-exist with `managedDisk`, the value of `defaultRecoveryDiskType` must be as same as `targetDiskType` of every `managedDisk` or it forces a new resource to be created.
	DefaultRecoveryDiskType pulumi.StringPtrInput
	// The ID of the default Disk Encryption Set that should be used for the disks when a failover is done.
	//
	// **Note:** Changing `defaultTargetDiskEncryptionSetId` forces a new resource to be created. But removing it does not.
	//
	// **Note:** When `defaultTargetDiskEncryptionSetId` co-exist with `managedDisk`, the value of `defaultTargetDiskEncryptionSetId` must be as same as `targetDiskEncryptionSetId` of every `managedDisk` or it forces a new resource to be created.
	DefaultTargetDiskEncryptionSetId pulumi.StringPtrInput
	// The license type of the VM. Possible values are `NoLicenseType`, `NotSpecified` and `WindowsServer`. Defaults to `NotSpecified`.
	LicenseType pulumi.StringPtrInput
	// One or more `managedDisk` block as defined below. It's available only if mobility service is already installed on the source VM.
	//
	// **Note:** A replicated VM could be created without `managedDisk` block, once the block has been specified, changing it expect removing it forces a new resource to be created.
	ManagedDisks VmwareReplicatedVmManagedDiskArrayInput
	// Name of group in which all machines will replicate together and have shared crash consistent and app-consistent recovery points when failed over. Changing this forces a new resource to be created.
	MultiVmGroupName pulumi.StringPtrInput
	// The name of the replicated VM. Changing this forces a new resource to be created.
	Name pulumi.StringPtrInput
	// One or more `networkInterface` block as defined below.
	NetworkInterfaces VmwareReplicatedVmNetworkInterfaceArrayInput
	// The name of the credential to access the source VM. Changing this forces a new resource to be created. More information about the credentials could be found [here](https://learn.microsoft.com/en-us/azure/site-recovery/deploy-vmware-azure-replication-appliance-modernized).
	PhysicalServerCredentialName pulumi.StringPtrInput
	// The ID of the policy to use for this replicated VM. Changing this forces a new resource to be created.
	RecoveryReplicationPolicyId pulumi.StringPtrInput
	// The ID of the Recovery Services Vault where the replicated VM is created. Changing this forces a new resource to be created.
	RecoveryVaultId pulumi.StringPtrInput
	// The name of the source VM in VMWare. Changing this forces a new resource to be created.
	SourceVmName pulumi.StringPtrInput
	// The ID of availability set that the new VM should belong to when a failover is done. Changing this forces a new resource to be created.
	TargetAvailabilitySetId pulumi.StringPtrInput
	// The ID of the storage account that should be used for boot diagnostics when a failover is done.
	TargetBootDiagnosticsStorageAccountId pulumi.StringPtrInput
	// The ID of network to use when a failover is done.
	//
	// **Note:** `targetNetworkId` is required when `networkInterface` is specified.
	TargetNetworkId pulumi.StringPtrInput
	// The ID of Proximity Placement Group the new VM should belong to when a failover is done.
	//
	// **Note:** Only one of `targetAvailabilitySetId` or `targetZone` can be specified.
	TargetProximityPlacementGroupId pulumi.StringPtrInput
	// The ID of resource group where the VM should be created when a failover is done. Changing this forces a new resource to be created.
	TargetResourceGroupId pulumi.StringPtrInput
	// Name of the VM that should be created when a failover is done. Changing this forces a new resource to be created.
	TargetVmName pulumi.StringPtrInput
	// Size of the VM that should be created when a failover is done, such as `Standard_F2`. If it's not specified, it will automatically be set by detecting the source VM size.
	TargetVmSize pulumi.StringPtrInput
	// Specifies the Availability Zone where the Failover VM should exist.
	TargetZone pulumi.StringPtrInput
	// The ID of network to use when a test failover is done.
	TestNetworkId pulumi.StringPtrInput
}

func (VmwareReplicatedVmState) ElementType() reflect.Type {
	return reflect.TypeOf((*vmwareReplicatedVmState)(nil)).Elem()
}

type vmwareReplicatedVmArgs struct {
	// The name of VMWare appliance which handles the replication. Changing this forces a new resource to be created.
	ApplianceName string `pulumi:"applianceName"`
	// The ID of the stroage account that should be used for logging during replication.
	//
	// **Note:** Only standard types of storage accounts are allowed.
	//
	// **Note:** Only one of `defaultLogStorageAccountId` or `managedDisk` must be specified.
	//
	// **Note:** Changing `defaultLogStorageAccountId` forces a new resource to be created. But removing it does not.
	//
	// **Note:** When `defaultLogStorageAccountId` co-exist with `managedDisk`, the value of `defaultLogStorageAccountId` must be as same as `logStorageAccountId` of every `managedDisk` or it forces a new resource to be created.
	DefaultLogStorageAccountId *string `pulumi:"defaultLogStorageAccountId"`
	// The type of storage account that should be used for recovery disks when a failover is done. Possible values are `Standard_LRS`, `Standard_LRS` and `StandardSSD_LRS`.
	//
	// **Note:** Only one of `defaultRecoveryDiskType` or `managedDisk` must be specified.
	//
	// **Note:** Changing `defaultRecoveryDiskType` forces a new resource to be created. But removing it does not.
	//
	// **Note:** When `defaultRecoveryDiskType` co-exist with `managedDisk`, the value of `defaultRecoveryDiskType` must be as same as `targetDiskType` of every `managedDisk` or it forces a new resource to be created.
	DefaultRecoveryDiskType *string `pulumi:"defaultRecoveryDiskType"`
	// The ID of the default Disk Encryption Set that should be used for the disks when a failover is done.
	//
	// **Note:** Changing `defaultTargetDiskEncryptionSetId` forces a new resource to be created. But removing it does not.
	//
	// **Note:** When `defaultTargetDiskEncryptionSetId` co-exist with `managedDisk`, the value of `defaultTargetDiskEncryptionSetId` must be as same as `targetDiskEncryptionSetId` of every `managedDisk` or it forces a new resource to be created.
	DefaultTargetDiskEncryptionSetId *string `pulumi:"defaultTargetDiskEncryptionSetId"`
	// The license type of the VM. Possible values are `NoLicenseType`, `NotSpecified` and `WindowsServer`. Defaults to `NotSpecified`.
	LicenseType *string `pulumi:"licenseType"`
	// One or more `managedDisk` block as defined below. It's available only if mobility service is already installed on the source VM.
	//
	// **Note:** A replicated VM could be created without `managedDisk` block, once the block has been specified, changing it expect removing it forces a new resource to be created.
	ManagedDisks []VmwareReplicatedVmManagedDisk `pulumi:"managedDisks"`
	// Name of group in which all machines will replicate together and have shared crash consistent and app-consistent recovery points when failed over. Changing this forces a new resource to be created.
	MultiVmGroupName *string `pulumi:"multiVmGroupName"`
	// The name of the replicated VM. Changing this forces a new resource to be created.
	Name *string `pulumi:"name"`
	// One or more `networkInterface` block as defined below.
	NetworkInterfaces []VmwareReplicatedVmNetworkInterface `pulumi:"networkInterfaces"`
	// The name of the credential to access the source VM. Changing this forces a new resource to be created. More information about the credentials could be found [here](https://learn.microsoft.com/en-us/azure/site-recovery/deploy-vmware-azure-replication-appliance-modernized).
	PhysicalServerCredentialName string `pulumi:"physicalServerCredentialName"`
	// The ID of the policy to use for this replicated VM. Changing this forces a new resource to be created.
	RecoveryReplicationPolicyId string `pulumi:"recoveryReplicationPolicyId"`
	// The ID of the Recovery Services Vault where the replicated VM is created. Changing this forces a new resource to be created.
	RecoveryVaultId string `pulumi:"recoveryVaultId"`
	// The name of the source VM in VMWare. Changing this forces a new resource to be created.
	SourceVmName string `pulumi:"sourceVmName"`
	// The ID of availability set that the new VM should belong to when a failover is done. Changing this forces a new resource to be created.
	TargetAvailabilitySetId *string `pulumi:"targetAvailabilitySetId"`
	// The ID of the storage account that should be used for boot diagnostics when a failover is done.
	TargetBootDiagnosticsStorageAccountId *string `pulumi:"targetBootDiagnosticsStorageAccountId"`
	// The ID of network to use when a failover is done.
	//
	// **Note:** `targetNetworkId` is required when `networkInterface` is specified.
	TargetNetworkId *string `pulumi:"targetNetworkId"`
	// The ID of Proximity Placement Group the new VM should belong to when a failover is done.
	//
	// **Note:** Only one of `targetAvailabilitySetId` or `targetZone` can be specified.
	TargetProximityPlacementGroupId *string `pulumi:"targetProximityPlacementGroupId"`
	// The ID of resource group where the VM should be created when a failover is done. Changing this forces a new resource to be created.
	TargetResourceGroupId string `pulumi:"targetResourceGroupId"`
	// Name of the VM that should be created when a failover is done. Changing this forces a new resource to be created.
	TargetVmName string `pulumi:"targetVmName"`
	// Size of the VM that should be created when a failover is done, such as `Standard_F2`. If it's not specified, it will automatically be set by detecting the source VM size.
	TargetVmSize *string `pulumi:"targetVmSize"`
	// Specifies the Availability Zone where the Failover VM should exist.
	TargetZone *string `pulumi:"targetZone"`
	// The ID of network to use when a test failover is done.
	TestNetworkId *string `pulumi:"testNetworkId"`
}

// The set of arguments for constructing a VmwareReplicatedVm resource.
type VmwareReplicatedVmArgs struct {
	// The name of VMWare appliance which handles the replication. Changing this forces a new resource to be created.
	ApplianceName pulumi.StringInput
	// The ID of the stroage account that should be used for logging during replication.
	//
	// **Note:** Only standard types of storage accounts are allowed.
	//
	// **Note:** Only one of `defaultLogStorageAccountId` or `managedDisk` must be specified.
	//
	// **Note:** Changing `defaultLogStorageAccountId` forces a new resource to be created. But removing it does not.
	//
	// **Note:** When `defaultLogStorageAccountId` co-exist with `managedDisk`, the value of `defaultLogStorageAccountId` must be as same as `logStorageAccountId` of every `managedDisk` or it forces a new resource to be created.
	DefaultLogStorageAccountId pulumi.StringPtrInput
	// The type of storage account that should be used for recovery disks when a failover is done. Possible values are `Standard_LRS`, `Standard_LRS` and `StandardSSD_LRS`.
	//
	// **Note:** Only one of `defaultRecoveryDiskType` or `managedDisk` must be specified.
	//
	// **Note:** Changing `defaultRecoveryDiskType` forces a new resource to be created. But removing it does not.
	//
	// **Note:** When `defaultRecoveryDiskType` co-exist with `managedDisk`, the value of `defaultRecoveryDiskType` must be as same as `targetDiskType` of every `managedDisk` or it forces a new resource to be created.
	DefaultRecoveryDiskType pulumi.StringPtrInput
	// The ID of the default Disk Encryption Set that should be used for the disks when a failover is done.
	//
	// **Note:** Changing `defaultTargetDiskEncryptionSetId` forces a new resource to be created. But removing it does not.
	//
	// **Note:** When `defaultTargetDiskEncryptionSetId` co-exist with `managedDisk`, the value of `defaultTargetDiskEncryptionSetId` must be as same as `targetDiskEncryptionSetId` of every `managedDisk` or it forces a new resource to be created.
	DefaultTargetDiskEncryptionSetId pulumi.StringPtrInput
	// The license type of the VM. Possible values are `NoLicenseType`, `NotSpecified` and `WindowsServer`. Defaults to `NotSpecified`.
	LicenseType pulumi.StringPtrInput
	// One or more `managedDisk` block as defined below. It's available only if mobility service is already installed on the source VM.
	//
	// **Note:** A replicated VM could be created without `managedDisk` block, once the block has been specified, changing it expect removing it forces a new resource to be created.
	ManagedDisks VmwareReplicatedVmManagedDiskArrayInput
	// Name of group in which all machines will replicate together and have shared crash consistent and app-consistent recovery points when failed over. Changing this forces a new resource to be created.
	MultiVmGroupName pulumi.StringPtrInput
	// The name of the replicated VM. Changing this forces a new resource to be created.
	Name pulumi.StringPtrInput
	// One or more `networkInterface` block as defined below.
	NetworkInterfaces VmwareReplicatedVmNetworkInterfaceArrayInput
	// The name of the credential to access the source VM. Changing this forces a new resource to be created. More information about the credentials could be found [here](https://learn.microsoft.com/en-us/azure/site-recovery/deploy-vmware-azure-replication-appliance-modernized).
	PhysicalServerCredentialName pulumi.StringInput
	// The ID of the policy to use for this replicated VM. Changing this forces a new resource to be created.
	RecoveryReplicationPolicyId pulumi.StringInput
	// The ID of the Recovery Services Vault where the replicated VM is created. Changing this forces a new resource to be created.
	RecoveryVaultId pulumi.StringInput
	// The name of the source VM in VMWare. Changing this forces a new resource to be created.
	SourceVmName pulumi.StringInput
	// The ID of availability set that the new VM should belong to when a failover is done. Changing this forces a new resource to be created.
	TargetAvailabilitySetId pulumi.StringPtrInput
	// The ID of the storage account that should be used for boot diagnostics when a failover is done.
	TargetBootDiagnosticsStorageAccountId pulumi.StringPtrInput
	// The ID of network to use when a failover is done.
	//
	// **Note:** `targetNetworkId` is required when `networkInterface` is specified.
	TargetNetworkId pulumi.StringPtrInput
	// The ID of Proximity Placement Group the new VM should belong to when a failover is done.
	//
	// **Note:** Only one of `targetAvailabilitySetId` or `targetZone` can be specified.
	TargetProximityPlacementGroupId pulumi.StringPtrInput
	// The ID of resource group where the VM should be created when a failover is done. Changing this forces a new resource to be created.
	TargetResourceGroupId pulumi.StringInput
	// Name of the VM that should be created when a failover is done. Changing this forces a new resource to be created.
	TargetVmName pulumi.StringInput
	// Size of the VM that should be created when a failover is done, such as `Standard_F2`. If it's not specified, it will automatically be set by detecting the source VM size.
	TargetVmSize pulumi.StringPtrInput
	// Specifies the Availability Zone where the Failover VM should exist.
	TargetZone pulumi.StringPtrInput
	// The ID of network to use when a test failover is done.
	TestNetworkId pulumi.StringPtrInput
}

func (VmwareReplicatedVmArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*vmwareReplicatedVmArgs)(nil)).Elem()
}

type VmwareReplicatedVmInput interface {
	pulumi.Input

	ToVmwareReplicatedVmOutput() VmwareReplicatedVmOutput
	ToVmwareReplicatedVmOutputWithContext(ctx context.Context) VmwareReplicatedVmOutput
}

func (*VmwareReplicatedVm) ElementType() reflect.Type {
	return reflect.TypeOf((**VmwareReplicatedVm)(nil)).Elem()
}

func (i *VmwareReplicatedVm) ToVmwareReplicatedVmOutput() VmwareReplicatedVmOutput {
	return i.ToVmwareReplicatedVmOutputWithContext(context.Background())
}

func (i *VmwareReplicatedVm) ToVmwareReplicatedVmOutputWithContext(ctx context.Context) VmwareReplicatedVmOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VmwareReplicatedVmOutput)
}

// VmwareReplicatedVmArrayInput is an input type that accepts VmwareReplicatedVmArray and VmwareReplicatedVmArrayOutput values.
// You can construct a concrete instance of `VmwareReplicatedVmArrayInput` via:
//
//	VmwareReplicatedVmArray{ VmwareReplicatedVmArgs{...} }
type VmwareReplicatedVmArrayInput interface {
	pulumi.Input

	ToVmwareReplicatedVmArrayOutput() VmwareReplicatedVmArrayOutput
	ToVmwareReplicatedVmArrayOutputWithContext(context.Context) VmwareReplicatedVmArrayOutput
}

type VmwareReplicatedVmArray []VmwareReplicatedVmInput

func (VmwareReplicatedVmArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*VmwareReplicatedVm)(nil)).Elem()
}

func (i VmwareReplicatedVmArray) ToVmwareReplicatedVmArrayOutput() VmwareReplicatedVmArrayOutput {
	return i.ToVmwareReplicatedVmArrayOutputWithContext(context.Background())
}

func (i VmwareReplicatedVmArray) ToVmwareReplicatedVmArrayOutputWithContext(ctx context.Context) VmwareReplicatedVmArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VmwareReplicatedVmArrayOutput)
}

// VmwareReplicatedVmMapInput is an input type that accepts VmwareReplicatedVmMap and VmwareReplicatedVmMapOutput values.
// You can construct a concrete instance of `VmwareReplicatedVmMapInput` via:
//
//	VmwareReplicatedVmMap{ "key": VmwareReplicatedVmArgs{...} }
type VmwareReplicatedVmMapInput interface {
	pulumi.Input

	ToVmwareReplicatedVmMapOutput() VmwareReplicatedVmMapOutput
	ToVmwareReplicatedVmMapOutputWithContext(context.Context) VmwareReplicatedVmMapOutput
}

type VmwareReplicatedVmMap map[string]VmwareReplicatedVmInput

func (VmwareReplicatedVmMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*VmwareReplicatedVm)(nil)).Elem()
}

func (i VmwareReplicatedVmMap) ToVmwareReplicatedVmMapOutput() VmwareReplicatedVmMapOutput {
	return i.ToVmwareReplicatedVmMapOutputWithContext(context.Background())
}

func (i VmwareReplicatedVmMap) ToVmwareReplicatedVmMapOutputWithContext(ctx context.Context) VmwareReplicatedVmMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VmwareReplicatedVmMapOutput)
}

type VmwareReplicatedVmOutput struct{ *pulumi.OutputState }

func (VmwareReplicatedVmOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VmwareReplicatedVm)(nil)).Elem()
}

func (o VmwareReplicatedVmOutput) ToVmwareReplicatedVmOutput() VmwareReplicatedVmOutput {
	return o
}

func (o VmwareReplicatedVmOutput) ToVmwareReplicatedVmOutputWithContext(ctx context.Context) VmwareReplicatedVmOutput {
	return o
}

// The name of VMWare appliance which handles the replication. Changing this forces a new resource to be created.
func (o VmwareReplicatedVmOutput) ApplianceName() pulumi.StringOutput {
	return o.ApplyT(func(v *VmwareReplicatedVm) pulumi.StringOutput { return v.ApplianceName }).(pulumi.StringOutput)
}

// The ID of the stroage account that should be used for logging during replication.
//
// **Note:** Only standard types of storage accounts are allowed.
//
// **Note:** Only one of `defaultLogStorageAccountId` or `managedDisk` must be specified.
//
// **Note:** Changing `defaultLogStorageAccountId` forces a new resource to be created. But removing it does not.
//
// **Note:** When `defaultLogStorageAccountId` co-exist with `managedDisk`, the value of `defaultLogStorageAccountId` must be as same as `logStorageAccountId` of every `managedDisk` or it forces a new resource to be created.
func (o VmwareReplicatedVmOutput) DefaultLogStorageAccountId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VmwareReplicatedVm) pulumi.StringPtrOutput { return v.DefaultLogStorageAccountId }).(pulumi.StringPtrOutput)
}

// The type of storage account that should be used for recovery disks when a failover is done. Possible values are `Standard_LRS`, `Standard_LRS` and `StandardSSD_LRS`.
//
// **Note:** Only one of `defaultRecoveryDiskType` or `managedDisk` must be specified.
//
// **Note:** Changing `defaultRecoveryDiskType` forces a new resource to be created. But removing it does not.
//
// **Note:** When `defaultRecoveryDiskType` co-exist with `managedDisk`, the value of `defaultRecoveryDiskType` must be as same as `targetDiskType` of every `managedDisk` or it forces a new resource to be created.
func (o VmwareReplicatedVmOutput) DefaultRecoveryDiskType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VmwareReplicatedVm) pulumi.StringPtrOutput { return v.DefaultRecoveryDiskType }).(pulumi.StringPtrOutput)
}

// The ID of the default Disk Encryption Set that should be used for the disks when a failover is done.
//
// **Note:** Changing `defaultTargetDiskEncryptionSetId` forces a new resource to be created. But removing it does not.
//
// **Note:** When `defaultTargetDiskEncryptionSetId` co-exist with `managedDisk`, the value of `defaultTargetDiskEncryptionSetId` must be as same as `targetDiskEncryptionSetId` of every `managedDisk` or it forces a new resource to be created.
func (o VmwareReplicatedVmOutput) DefaultTargetDiskEncryptionSetId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VmwareReplicatedVm) pulumi.StringPtrOutput { return v.DefaultTargetDiskEncryptionSetId }).(pulumi.StringPtrOutput)
}

// The license type of the VM. Possible values are `NoLicenseType`, `NotSpecified` and `WindowsServer`. Defaults to `NotSpecified`.
func (o VmwareReplicatedVmOutput) LicenseType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VmwareReplicatedVm) pulumi.StringPtrOutput { return v.LicenseType }).(pulumi.StringPtrOutput)
}

// One or more `managedDisk` block as defined below. It's available only if mobility service is already installed on the source VM.
//
// **Note:** A replicated VM could be created without `managedDisk` block, once the block has been specified, changing it expect removing it forces a new resource to be created.
func (o VmwareReplicatedVmOutput) ManagedDisks() VmwareReplicatedVmManagedDiskArrayOutput {
	return o.ApplyT(func(v *VmwareReplicatedVm) VmwareReplicatedVmManagedDiskArrayOutput { return v.ManagedDisks }).(VmwareReplicatedVmManagedDiskArrayOutput)
}

// Name of group in which all machines will replicate together and have shared crash consistent and app-consistent recovery points when failed over. Changing this forces a new resource to be created.
func (o VmwareReplicatedVmOutput) MultiVmGroupName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VmwareReplicatedVm) pulumi.StringPtrOutput { return v.MultiVmGroupName }).(pulumi.StringPtrOutput)
}

// The name of the replicated VM. Changing this forces a new resource to be created.
func (o VmwareReplicatedVmOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *VmwareReplicatedVm) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// One or more `networkInterface` block as defined below.
func (o VmwareReplicatedVmOutput) NetworkInterfaces() VmwareReplicatedVmNetworkInterfaceArrayOutput {
	return o.ApplyT(func(v *VmwareReplicatedVm) VmwareReplicatedVmNetworkInterfaceArrayOutput { return v.NetworkInterfaces }).(VmwareReplicatedVmNetworkInterfaceArrayOutput)
}

// The name of the credential to access the source VM. Changing this forces a new resource to be created. More information about the credentials could be found [here](https://learn.microsoft.com/en-us/azure/site-recovery/deploy-vmware-azure-replication-appliance-modernized).
func (o VmwareReplicatedVmOutput) PhysicalServerCredentialName() pulumi.StringOutput {
	return o.ApplyT(func(v *VmwareReplicatedVm) pulumi.StringOutput { return v.PhysicalServerCredentialName }).(pulumi.StringOutput)
}

// The ID of the policy to use for this replicated VM. Changing this forces a new resource to be created.
func (o VmwareReplicatedVmOutput) RecoveryReplicationPolicyId() pulumi.StringOutput {
	return o.ApplyT(func(v *VmwareReplicatedVm) pulumi.StringOutput { return v.RecoveryReplicationPolicyId }).(pulumi.StringOutput)
}

// The ID of the Recovery Services Vault where the replicated VM is created. Changing this forces a new resource to be created.
func (o VmwareReplicatedVmOutput) RecoveryVaultId() pulumi.StringOutput {
	return o.ApplyT(func(v *VmwareReplicatedVm) pulumi.StringOutput { return v.RecoveryVaultId }).(pulumi.StringOutput)
}

// The name of the source VM in VMWare. Changing this forces a new resource to be created.
func (o VmwareReplicatedVmOutput) SourceVmName() pulumi.StringOutput {
	return o.ApplyT(func(v *VmwareReplicatedVm) pulumi.StringOutput { return v.SourceVmName }).(pulumi.StringOutput)
}

// The ID of availability set that the new VM should belong to when a failover is done. Changing this forces a new resource to be created.
func (o VmwareReplicatedVmOutput) TargetAvailabilitySetId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VmwareReplicatedVm) pulumi.StringPtrOutput { return v.TargetAvailabilitySetId }).(pulumi.StringPtrOutput)
}

// The ID of the storage account that should be used for boot diagnostics when a failover is done.
func (o VmwareReplicatedVmOutput) TargetBootDiagnosticsStorageAccountId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VmwareReplicatedVm) pulumi.StringPtrOutput { return v.TargetBootDiagnosticsStorageAccountId }).(pulumi.StringPtrOutput)
}

// The ID of network to use when a failover is done.
//
// **Note:** `targetNetworkId` is required when `networkInterface` is specified.
func (o VmwareReplicatedVmOutput) TargetNetworkId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VmwareReplicatedVm) pulumi.StringPtrOutput { return v.TargetNetworkId }).(pulumi.StringPtrOutput)
}

// The ID of Proximity Placement Group the new VM should belong to when a failover is done.
//
// **Note:** Only one of `targetAvailabilitySetId` or `targetZone` can be specified.
func (o VmwareReplicatedVmOutput) TargetProximityPlacementGroupId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VmwareReplicatedVm) pulumi.StringPtrOutput { return v.TargetProximityPlacementGroupId }).(pulumi.StringPtrOutput)
}

// The ID of resource group where the VM should be created when a failover is done. Changing this forces a new resource to be created.
func (o VmwareReplicatedVmOutput) TargetResourceGroupId() pulumi.StringOutput {
	return o.ApplyT(func(v *VmwareReplicatedVm) pulumi.StringOutput { return v.TargetResourceGroupId }).(pulumi.StringOutput)
}

// Name of the VM that should be created when a failover is done. Changing this forces a new resource to be created.
func (o VmwareReplicatedVmOutput) TargetVmName() pulumi.StringOutput {
	return o.ApplyT(func(v *VmwareReplicatedVm) pulumi.StringOutput { return v.TargetVmName }).(pulumi.StringOutput)
}

// Size of the VM that should be created when a failover is done, such as `Standard_F2`. If it's not specified, it will automatically be set by detecting the source VM size.
func (o VmwareReplicatedVmOutput) TargetVmSize() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VmwareReplicatedVm) pulumi.StringPtrOutput { return v.TargetVmSize }).(pulumi.StringPtrOutput)
}

// Specifies the Availability Zone where the Failover VM should exist.
func (o VmwareReplicatedVmOutput) TargetZone() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VmwareReplicatedVm) pulumi.StringPtrOutput { return v.TargetZone }).(pulumi.StringPtrOutput)
}

// The ID of network to use when a test failover is done.
func (o VmwareReplicatedVmOutput) TestNetworkId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VmwareReplicatedVm) pulumi.StringPtrOutput { return v.TestNetworkId }).(pulumi.StringPtrOutput)
}

type VmwareReplicatedVmArrayOutput struct{ *pulumi.OutputState }

func (VmwareReplicatedVmArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*VmwareReplicatedVm)(nil)).Elem()
}

func (o VmwareReplicatedVmArrayOutput) ToVmwareReplicatedVmArrayOutput() VmwareReplicatedVmArrayOutput {
	return o
}

func (o VmwareReplicatedVmArrayOutput) ToVmwareReplicatedVmArrayOutputWithContext(ctx context.Context) VmwareReplicatedVmArrayOutput {
	return o
}

func (o VmwareReplicatedVmArrayOutput) Index(i pulumi.IntInput) VmwareReplicatedVmOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *VmwareReplicatedVm {
		return vs[0].([]*VmwareReplicatedVm)[vs[1].(int)]
	}).(VmwareReplicatedVmOutput)
}

type VmwareReplicatedVmMapOutput struct{ *pulumi.OutputState }

func (VmwareReplicatedVmMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*VmwareReplicatedVm)(nil)).Elem()
}

func (o VmwareReplicatedVmMapOutput) ToVmwareReplicatedVmMapOutput() VmwareReplicatedVmMapOutput {
	return o
}

func (o VmwareReplicatedVmMapOutput) ToVmwareReplicatedVmMapOutputWithContext(ctx context.Context) VmwareReplicatedVmMapOutput {
	return o
}

func (o VmwareReplicatedVmMapOutput) MapIndex(k pulumi.StringInput) VmwareReplicatedVmOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *VmwareReplicatedVm {
		return vs[0].(map[string]*VmwareReplicatedVm)[vs[1].(string)]
	}).(VmwareReplicatedVmOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*VmwareReplicatedVmInput)(nil)).Elem(), &VmwareReplicatedVm{})
	pulumi.RegisterInputType(reflect.TypeOf((*VmwareReplicatedVmArrayInput)(nil)).Elem(), VmwareReplicatedVmArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*VmwareReplicatedVmMapInput)(nil)).Elem(), VmwareReplicatedVmMap{})
	pulumi.RegisterOutputType(VmwareReplicatedVmOutput{})
	pulumi.RegisterOutputType(VmwareReplicatedVmArrayOutput{})
	pulumi.RegisterOutputType(VmwareReplicatedVmMapOutput{})
}
