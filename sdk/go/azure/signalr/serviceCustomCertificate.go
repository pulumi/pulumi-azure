// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package signalr

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-azure/sdk/v5/go/azure/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
)

// Manages an Azure SignalR Custom Certificate.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"encoding/base64"
//	"os"
//
//	"github.com/pulumi/pulumi-azure/sdk/v5/go/azure/core"
//	"github.com/pulumi/pulumi-azure/sdk/v5/go/azure/keyvault"
//	"github.com/pulumi/pulumi-azure/sdk/v5/go/azure/signalr"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func filebase64OrPanic(path string) pulumi.StringPtrInput {
//		if fileData, err := os.ReadFile(path); err == nil {
//			return pulumi.String(base64.StdEncoding.EncodeToString(fileData[:]))
//		} else {
//			panic(err.Error())
//		}
//	}
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			current, err := core.GetClientConfig(ctx, nil, nil)
//			if err != nil {
//				return err
//			}
//			exampleResourceGroup, err := core.NewResourceGroup(ctx, "exampleResourceGroup", &core.ResourceGroupArgs{
//				Location: pulumi.String("West Europe"),
//			})
//			if err != nil {
//				return err
//			}
//			exampleService, err := signalr.NewService(ctx, "exampleService", &signalr.ServiceArgs{
//				Location:          pulumi.Any(azurerm_resource_group.Test.Location),
//				ResourceGroupName: pulumi.Any(azurerm_resource_group.Test.Name),
//				Sku: &signalr.ServiceSkuArgs{
//					Name:     pulumi.String("Premium_P1"),
//					Capacity: pulumi.Int(1),
//				},
//				Identity: &signalr.ServiceIdentityArgs{
//					Type: pulumi.String("SystemAssigned"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			exampleKeyVault, err := keyvault.NewKeyVault(ctx, "exampleKeyVault", &keyvault.KeyVaultArgs{
//				Location:          exampleResourceGroup.Location,
//				ResourceGroupName: exampleResourceGroup.Name,
//				TenantId:          *pulumi.String(current.TenantId),
//				SkuName:           pulumi.String("premium"),
//				AccessPolicies: keyvault.KeyVaultAccessPolicyArray{
//					&keyvault.KeyVaultAccessPolicyArgs{
//						TenantId: *pulumi.String(current.TenantId),
//						ObjectId: *pulumi.String(current.ObjectId),
//						CertificatePermissions: pulumi.StringArray{
//							pulumi.String("Create"),
//							pulumi.String("Get"),
//							pulumi.String("List"),
//						},
//						SecretPermissions: pulumi.StringArray{
//							pulumi.String("Get"),
//							pulumi.String("List"),
//						},
//					},
//					&keyvault.KeyVaultAccessPolicyArgs{
//						TenantId: *pulumi.String(current.TenantId),
//						ObjectId: pulumi.Any(azurerm_signalr_service.Test.Identity[0].Principal_id),
//						CertificatePermissions: pulumi.StringArray{
//							pulumi.String("Create"),
//							pulumi.String("Get"),
//							pulumi.String("List"),
//						},
//						SecretPermissions: pulumi.StringArray{
//							pulumi.String("Get"),
//							pulumi.String("List"),
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			exampleCertificate, err := keyvault.NewCertificate(ctx, "exampleCertificate", &keyvault.CertificateArgs{
//				KeyVaultId: exampleKeyVault.ID(),
//				Certificate: &keyvault.CertificateCertificateArgs{
//					Contents: filebase64OrPanic("certificate-to-import.pfx"),
//					Password: pulumi.String(""),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = signalr.NewServiceCustomCertificate(ctx, "test", &signalr.ServiceCustomCertificateArgs{
//				SignalrServiceId:    exampleService.ID(),
//				CustomCertificateId: exampleCertificate.ID(),
//			}, pulumi.DependsOn([]pulumi.Resource{
//				azurerm_key_vault_access_policy.Example,
//			}))
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Custom Certificate for a SignalR service can be imported using the `resource id`, e.g.
//
// ```sh
//
//	$ pulumi import azure:signalr/serviceCustomCertificate:ServiceCustomCertificate example /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/group1/providers/Microsoft.SignalRService/signalR/signalr1/customCertificates/cert1
//
// ```
type ServiceCustomCertificate struct {
	pulumi.CustomResourceState

	// The certificate version of the SignalR Custom Certificate service.
	CertificateVersion pulumi.StringOutput `pulumi:"certificateVersion"`
	// The certificate id of the SignalR Custom Certificate service. Changing this forces a new resource to be created.
	//
	// > **Note:** Self assigned certificate is not supported and the provisioning status will fail.
	CustomCertificateId pulumi.StringOutput `pulumi:"customCertificateId"`
	// The name of the SignalR Custom Certificate. Changing this forces a new resource to be created.
	Name pulumi.StringOutput `pulumi:"name"`
	// The SignalR ID of the SignalR Custom Certificate. Changing this forces a new resource to be created.
	//
	// > **Note:** Custom Certificate is only available for SignalR Premium tier. Please enable managed identity in the corresponding SignalR Service and give the managed identity access to the key vault, the required permission is Get Certificate and Secret.
	SignalrServiceId pulumi.StringOutput `pulumi:"signalrServiceId"`
}

// NewServiceCustomCertificate registers a new resource with the given unique name, arguments, and options.
func NewServiceCustomCertificate(ctx *pulumi.Context,
	name string, args *ServiceCustomCertificateArgs, opts ...pulumi.ResourceOption) (*ServiceCustomCertificate, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.CustomCertificateId == nil {
		return nil, errors.New("invalid value for required argument 'CustomCertificateId'")
	}
	if args.SignalrServiceId == nil {
		return nil, errors.New("invalid value for required argument 'SignalrServiceId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ServiceCustomCertificate
	err := ctx.RegisterResource("azure:signalr/serviceCustomCertificate:ServiceCustomCertificate", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetServiceCustomCertificate gets an existing ServiceCustomCertificate resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetServiceCustomCertificate(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ServiceCustomCertificateState, opts ...pulumi.ResourceOption) (*ServiceCustomCertificate, error) {
	var resource ServiceCustomCertificate
	err := ctx.ReadResource("azure:signalr/serviceCustomCertificate:ServiceCustomCertificate", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ServiceCustomCertificate resources.
type serviceCustomCertificateState struct {
	// The certificate version of the SignalR Custom Certificate service.
	CertificateVersion *string `pulumi:"certificateVersion"`
	// The certificate id of the SignalR Custom Certificate service. Changing this forces a new resource to be created.
	//
	// > **Note:** Self assigned certificate is not supported and the provisioning status will fail.
	CustomCertificateId *string `pulumi:"customCertificateId"`
	// The name of the SignalR Custom Certificate. Changing this forces a new resource to be created.
	Name *string `pulumi:"name"`
	// The SignalR ID of the SignalR Custom Certificate. Changing this forces a new resource to be created.
	//
	// > **Note:** Custom Certificate is only available for SignalR Premium tier. Please enable managed identity in the corresponding SignalR Service and give the managed identity access to the key vault, the required permission is Get Certificate and Secret.
	SignalrServiceId *string `pulumi:"signalrServiceId"`
}

type ServiceCustomCertificateState struct {
	// The certificate version of the SignalR Custom Certificate service.
	CertificateVersion pulumi.StringPtrInput
	// The certificate id of the SignalR Custom Certificate service. Changing this forces a new resource to be created.
	//
	// > **Note:** Self assigned certificate is not supported and the provisioning status will fail.
	CustomCertificateId pulumi.StringPtrInput
	// The name of the SignalR Custom Certificate. Changing this forces a new resource to be created.
	Name pulumi.StringPtrInput
	// The SignalR ID of the SignalR Custom Certificate. Changing this forces a new resource to be created.
	//
	// > **Note:** Custom Certificate is only available for SignalR Premium tier. Please enable managed identity in the corresponding SignalR Service and give the managed identity access to the key vault, the required permission is Get Certificate and Secret.
	SignalrServiceId pulumi.StringPtrInput
}

func (ServiceCustomCertificateState) ElementType() reflect.Type {
	return reflect.TypeOf((*serviceCustomCertificateState)(nil)).Elem()
}

type serviceCustomCertificateArgs struct {
	// The certificate id of the SignalR Custom Certificate service. Changing this forces a new resource to be created.
	//
	// > **Note:** Self assigned certificate is not supported and the provisioning status will fail.
	CustomCertificateId string `pulumi:"customCertificateId"`
	// The name of the SignalR Custom Certificate. Changing this forces a new resource to be created.
	Name *string `pulumi:"name"`
	// The SignalR ID of the SignalR Custom Certificate. Changing this forces a new resource to be created.
	//
	// > **Note:** Custom Certificate is only available for SignalR Premium tier. Please enable managed identity in the corresponding SignalR Service and give the managed identity access to the key vault, the required permission is Get Certificate and Secret.
	SignalrServiceId string `pulumi:"signalrServiceId"`
}

// The set of arguments for constructing a ServiceCustomCertificate resource.
type ServiceCustomCertificateArgs struct {
	// The certificate id of the SignalR Custom Certificate service. Changing this forces a new resource to be created.
	//
	// > **Note:** Self assigned certificate is not supported and the provisioning status will fail.
	CustomCertificateId pulumi.StringInput
	// The name of the SignalR Custom Certificate. Changing this forces a new resource to be created.
	Name pulumi.StringPtrInput
	// The SignalR ID of the SignalR Custom Certificate. Changing this forces a new resource to be created.
	//
	// > **Note:** Custom Certificate is only available for SignalR Premium tier. Please enable managed identity in the corresponding SignalR Service and give the managed identity access to the key vault, the required permission is Get Certificate and Secret.
	SignalrServiceId pulumi.StringInput
}

func (ServiceCustomCertificateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*serviceCustomCertificateArgs)(nil)).Elem()
}

type ServiceCustomCertificateInput interface {
	pulumi.Input

	ToServiceCustomCertificateOutput() ServiceCustomCertificateOutput
	ToServiceCustomCertificateOutputWithContext(ctx context.Context) ServiceCustomCertificateOutput
}

func (*ServiceCustomCertificate) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceCustomCertificate)(nil)).Elem()
}

func (i *ServiceCustomCertificate) ToServiceCustomCertificateOutput() ServiceCustomCertificateOutput {
	return i.ToServiceCustomCertificateOutputWithContext(context.Background())
}

func (i *ServiceCustomCertificate) ToServiceCustomCertificateOutputWithContext(ctx context.Context) ServiceCustomCertificateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceCustomCertificateOutput)
}

func (i *ServiceCustomCertificate) ToOutput(ctx context.Context) pulumix.Output[*ServiceCustomCertificate] {
	return pulumix.Output[*ServiceCustomCertificate]{
		OutputState: i.ToServiceCustomCertificateOutputWithContext(ctx).OutputState,
	}
}

// ServiceCustomCertificateArrayInput is an input type that accepts ServiceCustomCertificateArray and ServiceCustomCertificateArrayOutput values.
// You can construct a concrete instance of `ServiceCustomCertificateArrayInput` via:
//
//	ServiceCustomCertificateArray{ ServiceCustomCertificateArgs{...} }
type ServiceCustomCertificateArrayInput interface {
	pulumi.Input

	ToServiceCustomCertificateArrayOutput() ServiceCustomCertificateArrayOutput
	ToServiceCustomCertificateArrayOutputWithContext(context.Context) ServiceCustomCertificateArrayOutput
}

type ServiceCustomCertificateArray []ServiceCustomCertificateInput

func (ServiceCustomCertificateArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ServiceCustomCertificate)(nil)).Elem()
}

func (i ServiceCustomCertificateArray) ToServiceCustomCertificateArrayOutput() ServiceCustomCertificateArrayOutput {
	return i.ToServiceCustomCertificateArrayOutputWithContext(context.Background())
}

func (i ServiceCustomCertificateArray) ToServiceCustomCertificateArrayOutputWithContext(ctx context.Context) ServiceCustomCertificateArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceCustomCertificateArrayOutput)
}

func (i ServiceCustomCertificateArray) ToOutput(ctx context.Context) pulumix.Output[[]*ServiceCustomCertificate] {
	return pulumix.Output[[]*ServiceCustomCertificate]{
		OutputState: i.ToServiceCustomCertificateArrayOutputWithContext(ctx).OutputState,
	}
}

// ServiceCustomCertificateMapInput is an input type that accepts ServiceCustomCertificateMap and ServiceCustomCertificateMapOutput values.
// You can construct a concrete instance of `ServiceCustomCertificateMapInput` via:
//
//	ServiceCustomCertificateMap{ "key": ServiceCustomCertificateArgs{...} }
type ServiceCustomCertificateMapInput interface {
	pulumi.Input

	ToServiceCustomCertificateMapOutput() ServiceCustomCertificateMapOutput
	ToServiceCustomCertificateMapOutputWithContext(context.Context) ServiceCustomCertificateMapOutput
}

type ServiceCustomCertificateMap map[string]ServiceCustomCertificateInput

func (ServiceCustomCertificateMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ServiceCustomCertificate)(nil)).Elem()
}

func (i ServiceCustomCertificateMap) ToServiceCustomCertificateMapOutput() ServiceCustomCertificateMapOutput {
	return i.ToServiceCustomCertificateMapOutputWithContext(context.Background())
}

func (i ServiceCustomCertificateMap) ToServiceCustomCertificateMapOutputWithContext(ctx context.Context) ServiceCustomCertificateMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceCustomCertificateMapOutput)
}

func (i ServiceCustomCertificateMap) ToOutput(ctx context.Context) pulumix.Output[map[string]*ServiceCustomCertificate] {
	return pulumix.Output[map[string]*ServiceCustomCertificate]{
		OutputState: i.ToServiceCustomCertificateMapOutputWithContext(ctx).OutputState,
	}
}

type ServiceCustomCertificateOutput struct{ *pulumi.OutputState }

func (ServiceCustomCertificateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceCustomCertificate)(nil)).Elem()
}

func (o ServiceCustomCertificateOutput) ToServiceCustomCertificateOutput() ServiceCustomCertificateOutput {
	return o
}

func (o ServiceCustomCertificateOutput) ToServiceCustomCertificateOutputWithContext(ctx context.Context) ServiceCustomCertificateOutput {
	return o
}

func (o ServiceCustomCertificateOutput) ToOutput(ctx context.Context) pulumix.Output[*ServiceCustomCertificate] {
	return pulumix.Output[*ServiceCustomCertificate]{
		OutputState: o.OutputState,
	}
}

// The certificate version of the SignalR Custom Certificate service.
func (o ServiceCustomCertificateOutput) CertificateVersion() pulumi.StringOutput {
	return o.ApplyT(func(v *ServiceCustomCertificate) pulumi.StringOutput { return v.CertificateVersion }).(pulumi.StringOutput)
}

// The certificate id of the SignalR Custom Certificate service. Changing this forces a new resource to be created.
//
// > **Note:** Self assigned certificate is not supported and the provisioning status will fail.
func (o ServiceCustomCertificateOutput) CustomCertificateId() pulumi.StringOutput {
	return o.ApplyT(func(v *ServiceCustomCertificate) pulumi.StringOutput { return v.CustomCertificateId }).(pulumi.StringOutput)
}

// The name of the SignalR Custom Certificate. Changing this forces a new resource to be created.
func (o ServiceCustomCertificateOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *ServiceCustomCertificate) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The SignalR ID of the SignalR Custom Certificate. Changing this forces a new resource to be created.
//
// > **Note:** Custom Certificate is only available for SignalR Premium tier. Please enable managed identity in the corresponding SignalR Service and give the managed identity access to the key vault, the required permission is Get Certificate and Secret.
func (o ServiceCustomCertificateOutput) SignalrServiceId() pulumi.StringOutput {
	return o.ApplyT(func(v *ServiceCustomCertificate) pulumi.StringOutput { return v.SignalrServiceId }).(pulumi.StringOutput)
}

type ServiceCustomCertificateArrayOutput struct{ *pulumi.OutputState }

func (ServiceCustomCertificateArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ServiceCustomCertificate)(nil)).Elem()
}

func (o ServiceCustomCertificateArrayOutput) ToServiceCustomCertificateArrayOutput() ServiceCustomCertificateArrayOutput {
	return o
}

func (o ServiceCustomCertificateArrayOutput) ToServiceCustomCertificateArrayOutputWithContext(ctx context.Context) ServiceCustomCertificateArrayOutput {
	return o
}

func (o ServiceCustomCertificateArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]*ServiceCustomCertificate] {
	return pulumix.Output[[]*ServiceCustomCertificate]{
		OutputState: o.OutputState,
	}
}

func (o ServiceCustomCertificateArrayOutput) Index(i pulumi.IntInput) ServiceCustomCertificateOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ServiceCustomCertificate {
		return vs[0].([]*ServiceCustomCertificate)[vs[1].(int)]
	}).(ServiceCustomCertificateOutput)
}

type ServiceCustomCertificateMapOutput struct{ *pulumi.OutputState }

func (ServiceCustomCertificateMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ServiceCustomCertificate)(nil)).Elem()
}

func (o ServiceCustomCertificateMapOutput) ToServiceCustomCertificateMapOutput() ServiceCustomCertificateMapOutput {
	return o
}

func (o ServiceCustomCertificateMapOutput) ToServiceCustomCertificateMapOutputWithContext(ctx context.Context) ServiceCustomCertificateMapOutput {
	return o
}

func (o ServiceCustomCertificateMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]*ServiceCustomCertificate] {
	return pulumix.Output[map[string]*ServiceCustomCertificate]{
		OutputState: o.OutputState,
	}
}

func (o ServiceCustomCertificateMapOutput) MapIndex(k pulumi.StringInput) ServiceCustomCertificateOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ServiceCustomCertificate {
		return vs[0].(map[string]*ServiceCustomCertificate)[vs[1].(string)]
	}).(ServiceCustomCertificateOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ServiceCustomCertificateInput)(nil)).Elem(), &ServiceCustomCertificate{})
	pulumi.RegisterInputType(reflect.TypeOf((*ServiceCustomCertificateArrayInput)(nil)).Elem(), ServiceCustomCertificateArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ServiceCustomCertificateMapInput)(nil)).Elem(), ServiceCustomCertificateMap{})
	pulumi.RegisterOutputType(ServiceCustomCertificateOutput{})
	pulumi.RegisterOutputType(ServiceCustomCertificateArrayOutput{})
	pulumi.RegisterOutputType(ServiceCustomCertificateMapOutput{})
}
