// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package compute

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-azure/sdk/v5/go/azure/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages a Disk SAS Token.
//
// Use this resource to obtain a Shared Access Signature (SAS Token) for an existing Managed Disk.
//
// Shared access signatures allow fine-grained, ephemeral access control to various aspects of Managed Disk similar to blob/storage account container.
//
// With the help of this resource, data from the disk can be copied from managed disk to a storage blob or to some other system without the need of azcopy.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-azure/sdk/v5/go/azure/compute"
//	"github.com/pulumi/pulumi-azure/sdk/v5/go/azure/core"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			testResourceGroup, err := core.NewResourceGroup(ctx, "testResourceGroup", &core.ResourceGroupArgs{
//				Location: pulumi.String("West Europe"),
//			})
//			if err != nil {
//				return err
//			}
//			testManagedDisk, err := compute.NewManagedDisk(ctx, "testManagedDisk", &compute.ManagedDiskArgs{
//				Location:           testResourceGroup.Location,
//				ResourceGroupName:  testResourceGroup.Name,
//				StorageAccountType: pulumi.String("Standard_LRS"),
//				CreateOption:       pulumi.String("Empty"),
//				DiskSizeGb:         pulumi.Int(1),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = compute.NewManagedDiskSasToken(ctx, "testManagedDiskSasToken", &compute.ManagedDiskSasTokenArgs{
//				ManagedDiskId:     testManagedDisk.ID(),
//				DurationInSeconds: pulumi.Int(300),
//				AccessLevel:       pulumi.String("Read"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Disk SAS Token can be imported using the `resource id`, e.g.
//
// ```sh
//
//	$ pulumi import azure:compute/managedDiskSasToken:ManagedDiskSasToken example /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/mygroup1/providers/Microsoft.Compute/disks/manageddisk1
//
// ```
type ManagedDiskSasToken struct {
	pulumi.CustomResourceState

	// The level of access required on the disk. Supported are Read, Write. Changing this forces a new resource to be created.
	//
	// Refer to the [SAS creation reference from Azure](https://docs.microsoft.com/rest/api/compute/disks/grant-access)
	// for additional details on the fields above.
	AccessLevel pulumi.StringOutput `pulumi:"accessLevel"`
	// The duration for which the export should be allowed. Should be between 30 & 4294967295 seconds. Changing this forces a new resource to be created.
	DurationInSeconds pulumi.IntOutput `pulumi:"durationInSeconds"`
	// The ID of an existing Managed Disk which should be exported. Changing this forces a new resource to be created.
	ManagedDiskId pulumi.StringOutput `pulumi:"managedDiskId"`
	// The computed Shared Access Signature (SAS) of the Managed Disk.
	SasUrl pulumi.StringOutput `pulumi:"sasUrl"`
}

// NewManagedDiskSasToken registers a new resource with the given unique name, arguments, and options.
func NewManagedDiskSasToken(ctx *pulumi.Context,
	name string, args *ManagedDiskSasTokenArgs, opts ...pulumi.ResourceOption) (*ManagedDiskSasToken, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.AccessLevel == nil {
		return nil, errors.New("invalid value for required argument 'AccessLevel'")
	}
	if args.DurationInSeconds == nil {
		return nil, errors.New("invalid value for required argument 'DurationInSeconds'")
	}
	if args.ManagedDiskId == nil {
		return nil, errors.New("invalid value for required argument 'ManagedDiskId'")
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"sasUrl",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ManagedDiskSasToken
	err := ctx.RegisterResource("azure:compute/managedDiskSasToken:ManagedDiskSasToken", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetManagedDiskSasToken gets an existing ManagedDiskSasToken resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetManagedDiskSasToken(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ManagedDiskSasTokenState, opts ...pulumi.ResourceOption) (*ManagedDiskSasToken, error) {
	var resource ManagedDiskSasToken
	err := ctx.ReadResource("azure:compute/managedDiskSasToken:ManagedDiskSasToken", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ManagedDiskSasToken resources.
type managedDiskSasTokenState struct {
	// The level of access required on the disk. Supported are Read, Write. Changing this forces a new resource to be created.
	//
	// Refer to the [SAS creation reference from Azure](https://docs.microsoft.com/rest/api/compute/disks/grant-access)
	// for additional details on the fields above.
	AccessLevel *string `pulumi:"accessLevel"`
	// The duration for which the export should be allowed. Should be between 30 & 4294967295 seconds. Changing this forces a new resource to be created.
	DurationInSeconds *int `pulumi:"durationInSeconds"`
	// The ID of an existing Managed Disk which should be exported. Changing this forces a new resource to be created.
	ManagedDiskId *string `pulumi:"managedDiskId"`
	// The computed Shared Access Signature (SAS) of the Managed Disk.
	SasUrl *string `pulumi:"sasUrl"`
}

type ManagedDiskSasTokenState struct {
	// The level of access required on the disk. Supported are Read, Write. Changing this forces a new resource to be created.
	//
	// Refer to the [SAS creation reference from Azure](https://docs.microsoft.com/rest/api/compute/disks/grant-access)
	// for additional details on the fields above.
	AccessLevel pulumi.StringPtrInput
	// The duration for which the export should be allowed. Should be between 30 & 4294967295 seconds. Changing this forces a new resource to be created.
	DurationInSeconds pulumi.IntPtrInput
	// The ID of an existing Managed Disk which should be exported. Changing this forces a new resource to be created.
	ManagedDiskId pulumi.StringPtrInput
	// The computed Shared Access Signature (SAS) of the Managed Disk.
	SasUrl pulumi.StringPtrInput
}

func (ManagedDiskSasTokenState) ElementType() reflect.Type {
	return reflect.TypeOf((*managedDiskSasTokenState)(nil)).Elem()
}

type managedDiskSasTokenArgs struct {
	// The level of access required on the disk. Supported are Read, Write. Changing this forces a new resource to be created.
	//
	// Refer to the [SAS creation reference from Azure](https://docs.microsoft.com/rest/api/compute/disks/grant-access)
	// for additional details on the fields above.
	AccessLevel string `pulumi:"accessLevel"`
	// The duration for which the export should be allowed. Should be between 30 & 4294967295 seconds. Changing this forces a new resource to be created.
	DurationInSeconds int `pulumi:"durationInSeconds"`
	// The ID of an existing Managed Disk which should be exported. Changing this forces a new resource to be created.
	ManagedDiskId string `pulumi:"managedDiskId"`
}

// The set of arguments for constructing a ManagedDiskSasToken resource.
type ManagedDiskSasTokenArgs struct {
	// The level of access required on the disk. Supported are Read, Write. Changing this forces a new resource to be created.
	//
	// Refer to the [SAS creation reference from Azure](https://docs.microsoft.com/rest/api/compute/disks/grant-access)
	// for additional details on the fields above.
	AccessLevel pulumi.StringInput
	// The duration for which the export should be allowed. Should be between 30 & 4294967295 seconds. Changing this forces a new resource to be created.
	DurationInSeconds pulumi.IntInput
	// The ID of an existing Managed Disk which should be exported. Changing this forces a new resource to be created.
	ManagedDiskId pulumi.StringInput
}

func (ManagedDiskSasTokenArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*managedDiskSasTokenArgs)(nil)).Elem()
}

type ManagedDiskSasTokenInput interface {
	pulumi.Input

	ToManagedDiskSasTokenOutput() ManagedDiskSasTokenOutput
	ToManagedDiskSasTokenOutputWithContext(ctx context.Context) ManagedDiskSasTokenOutput
}

func (*ManagedDiskSasToken) ElementType() reflect.Type {
	return reflect.TypeOf((**ManagedDiskSasToken)(nil)).Elem()
}

func (i *ManagedDiskSasToken) ToManagedDiskSasTokenOutput() ManagedDiskSasTokenOutput {
	return i.ToManagedDiskSasTokenOutputWithContext(context.Background())
}

func (i *ManagedDiskSasToken) ToManagedDiskSasTokenOutputWithContext(ctx context.Context) ManagedDiskSasTokenOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedDiskSasTokenOutput)
}

// ManagedDiskSasTokenArrayInput is an input type that accepts ManagedDiskSasTokenArray and ManagedDiskSasTokenArrayOutput values.
// You can construct a concrete instance of `ManagedDiskSasTokenArrayInput` via:
//
//	ManagedDiskSasTokenArray{ ManagedDiskSasTokenArgs{...} }
type ManagedDiskSasTokenArrayInput interface {
	pulumi.Input

	ToManagedDiskSasTokenArrayOutput() ManagedDiskSasTokenArrayOutput
	ToManagedDiskSasTokenArrayOutputWithContext(context.Context) ManagedDiskSasTokenArrayOutput
}

type ManagedDiskSasTokenArray []ManagedDiskSasTokenInput

func (ManagedDiskSasTokenArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ManagedDiskSasToken)(nil)).Elem()
}

func (i ManagedDiskSasTokenArray) ToManagedDiskSasTokenArrayOutput() ManagedDiskSasTokenArrayOutput {
	return i.ToManagedDiskSasTokenArrayOutputWithContext(context.Background())
}

func (i ManagedDiskSasTokenArray) ToManagedDiskSasTokenArrayOutputWithContext(ctx context.Context) ManagedDiskSasTokenArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedDiskSasTokenArrayOutput)
}

// ManagedDiskSasTokenMapInput is an input type that accepts ManagedDiskSasTokenMap and ManagedDiskSasTokenMapOutput values.
// You can construct a concrete instance of `ManagedDiskSasTokenMapInput` via:
//
//	ManagedDiskSasTokenMap{ "key": ManagedDiskSasTokenArgs{...} }
type ManagedDiskSasTokenMapInput interface {
	pulumi.Input

	ToManagedDiskSasTokenMapOutput() ManagedDiskSasTokenMapOutput
	ToManagedDiskSasTokenMapOutputWithContext(context.Context) ManagedDiskSasTokenMapOutput
}

type ManagedDiskSasTokenMap map[string]ManagedDiskSasTokenInput

func (ManagedDiskSasTokenMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ManagedDiskSasToken)(nil)).Elem()
}

func (i ManagedDiskSasTokenMap) ToManagedDiskSasTokenMapOutput() ManagedDiskSasTokenMapOutput {
	return i.ToManagedDiskSasTokenMapOutputWithContext(context.Background())
}

func (i ManagedDiskSasTokenMap) ToManagedDiskSasTokenMapOutputWithContext(ctx context.Context) ManagedDiskSasTokenMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedDiskSasTokenMapOutput)
}

type ManagedDiskSasTokenOutput struct{ *pulumi.OutputState }

func (ManagedDiskSasTokenOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ManagedDiskSasToken)(nil)).Elem()
}

func (o ManagedDiskSasTokenOutput) ToManagedDiskSasTokenOutput() ManagedDiskSasTokenOutput {
	return o
}

func (o ManagedDiskSasTokenOutput) ToManagedDiskSasTokenOutputWithContext(ctx context.Context) ManagedDiskSasTokenOutput {
	return o
}

// The level of access required on the disk. Supported are Read, Write. Changing this forces a new resource to be created.
//
// Refer to the [SAS creation reference from Azure](https://docs.microsoft.com/rest/api/compute/disks/grant-access)
// for additional details on the fields above.
func (o ManagedDiskSasTokenOutput) AccessLevel() pulumi.StringOutput {
	return o.ApplyT(func(v *ManagedDiskSasToken) pulumi.StringOutput { return v.AccessLevel }).(pulumi.StringOutput)
}

// The duration for which the export should be allowed. Should be between 30 & 4294967295 seconds. Changing this forces a new resource to be created.
func (o ManagedDiskSasTokenOutput) DurationInSeconds() pulumi.IntOutput {
	return o.ApplyT(func(v *ManagedDiskSasToken) pulumi.IntOutput { return v.DurationInSeconds }).(pulumi.IntOutput)
}

// The ID of an existing Managed Disk which should be exported. Changing this forces a new resource to be created.
func (o ManagedDiskSasTokenOutput) ManagedDiskId() pulumi.StringOutput {
	return o.ApplyT(func(v *ManagedDiskSasToken) pulumi.StringOutput { return v.ManagedDiskId }).(pulumi.StringOutput)
}

// The computed Shared Access Signature (SAS) of the Managed Disk.
func (o ManagedDiskSasTokenOutput) SasUrl() pulumi.StringOutput {
	return o.ApplyT(func(v *ManagedDiskSasToken) pulumi.StringOutput { return v.SasUrl }).(pulumi.StringOutput)
}

type ManagedDiskSasTokenArrayOutput struct{ *pulumi.OutputState }

func (ManagedDiskSasTokenArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ManagedDiskSasToken)(nil)).Elem()
}

func (o ManagedDiskSasTokenArrayOutput) ToManagedDiskSasTokenArrayOutput() ManagedDiskSasTokenArrayOutput {
	return o
}

func (o ManagedDiskSasTokenArrayOutput) ToManagedDiskSasTokenArrayOutputWithContext(ctx context.Context) ManagedDiskSasTokenArrayOutput {
	return o
}

func (o ManagedDiskSasTokenArrayOutput) Index(i pulumi.IntInput) ManagedDiskSasTokenOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ManagedDiskSasToken {
		return vs[0].([]*ManagedDiskSasToken)[vs[1].(int)]
	}).(ManagedDiskSasTokenOutput)
}

type ManagedDiskSasTokenMapOutput struct{ *pulumi.OutputState }

func (ManagedDiskSasTokenMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ManagedDiskSasToken)(nil)).Elem()
}

func (o ManagedDiskSasTokenMapOutput) ToManagedDiskSasTokenMapOutput() ManagedDiskSasTokenMapOutput {
	return o
}

func (o ManagedDiskSasTokenMapOutput) ToManagedDiskSasTokenMapOutputWithContext(ctx context.Context) ManagedDiskSasTokenMapOutput {
	return o
}

func (o ManagedDiskSasTokenMapOutput) MapIndex(k pulumi.StringInput) ManagedDiskSasTokenOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ManagedDiskSasToken {
		return vs[0].(map[string]*ManagedDiskSasToken)[vs[1].(string)]
	}).(ManagedDiskSasTokenOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ManagedDiskSasTokenInput)(nil)).Elem(), &ManagedDiskSasToken{})
	pulumi.RegisterInputType(reflect.TypeOf((*ManagedDiskSasTokenArrayInput)(nil)).Elem(), ManagedDiskSasTokenArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ManagedDiskSasTokenMapInput)(nil)).Elem(), ManagedDiskSasTokenMap{})
	pulumi.RegisterOutputType(ManagedDiskSasTokenOutput{})
	pulumi.RegisterOutputType(ManagedDiskSasTokenArrayOutput{})
	pulumi.RegisterOutputType(ManagedDiskSasTokenMapOutput{})
}
