// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package compute

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-azure/sdk/v6/go/azure/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages an implicit Data Disk of a Virtual Machine.
//
// > **Note:** The Implicit Data Disk will be deleted instantly after this resource is destroyed. If you want to detach this disk only, you may set `detachImplicitDataDiskOnDeletion` field to `true` within the `virtualMachine` block in the provider `features` block.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"fmt"
//
//	"github.com/pulumi/pulumi-azure/sdk/v6/go/azure/compute"
//	"github.com/pulumi/pulumi-azure/sdk/v6/go/azure/core"
//	"github.com/pulumi/pulumi-azure/sdk/v6/go/azure/network"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			cfg := config.New(ctx, "")
//			prefix := "example"
//			if param := cfg.Get("prefix"); param != "" {
//				prefix = param
//			}
//			vmName := fmt.Sprintf("%v-vm", prefix)
//			example, err := core.NewResourceGroup(ctx, "example", &core.ResourceGroupArgs{
//				Name:     pulumi.Sprintf("%v-resources", prefix),
//				Location: pulumi.String("West Europe"),
//			})
//			if err != nil {
//				return err
//			}
//			main, err := network.NewVirtualNetwork(ctx, "main", &network.VirtualNetworkArgs{
//				Name: pulumi.Sprintf("%v-network", prefix),
//				AddressSpaces: pulumi.StringArray{
//					pulumi.String("10.0.0.0/16"),
//				},
//				Location:          example.Location,
//				ResourceGroupName: example.Name,
//			})
//			if err != nil {
//				return err
//			}
//			internal, err := network.NewSubnet(ctx, "internal", &network.SubnetArgs{
//				Name:               pulumi.String("internal"),
//				ResourceGroupName:  example.Name,
//				VirtualNetworkName: main.Name,
//				AddressPrefixes: pulumi.StringArray{
//					pulumi.String("10.0.2.0/24"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			mainNetworkInterface, err := network.NewNetworkInterface(ctx, "main", &network.NetworkInterfaceArgs{
//				Name:              pulumi.Sprintf("%v-nic", prefix),
//				Location:          example.Location,
//				ResourceGroupName: example.Name,
//				IpConfigurations: network.NetworkInterfaceIpConfigurationArray{
//					&network.NetworkInterfaceIpConfigurationArgs{
//						Name:                       pulumi.String("internal"),
//						SubnetId:                   internal.ID(),
//						PrivateIpAddressAllocation: pulumi.String("Dynamic"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = compute.NewVirtualMachine(ctx, "example", &compute.VirtualMachineArgs{
//				Name:              pulumi.String(vmName),
//				Location:          example.Location,
//				ResourceGroupName: example.Name,
//				NetworkInterfaceIds: pulumi.StringArray{
//					mainNetworkInterface.ID(),
//				},
//				VmSize: pulumi.String("Standard_F2"),
//				StorageImageReference: &compute.VirtualMachineStorageImageReferenceArgs{
//					Publisher: pulumi.String("Canonical"),
//					Offer:     pulumi.String("0001-com-ubuntu-server-jammy"),
//					Sku:       pulumi.String("22_04-lts"),
//					Version:   pulumi.String("latest"),
//				},
//				StorageOsDisk: &compute.VirtualMachineStorageOsDiskArgs{
//					Name:            pulumi.String("myosdisk1"),
//					Caching:         pulumi.String("ReadWrite"),
//					CreateOption:    pulumi.String("FromImage"),
//					ManagedDiskType: pulumi.String("Standard_LRS"),
//				},
//				OsProfile: &compute.VirtualMachineOsProfileArgs{
//					ComputerName:  pulumi.String(vmName),
//					AdminUsername: pulumi.String("testadmin"),
//					AdminPassword: pulumi.String("Password1234!"),
//				},
//				OsProfileLinuxConfig: &compute.VirtualMachineOsProfileLinuxConfigArgs{
//					DisablePasswordAuthentication: pulumi.Bool(false),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			exampleManagedDisk, err := compute.NewManagedDisk(ctx, "example", &compute.ManagedDiskArgs{
//				Name:               pulumi.Sprintf("%v-disk1", vmName),
//				Location:           example.Location,
//				ResourceGroupName:  example.Name,
//				StorageAccountType: pulumi.String("Standard_LRS"),
//				CreateOption:       pulumi.String("Empty"),
//				DiskSizeGb:         pulumi.Int(10),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = compute.NewSnapshot(ctx, "example", &compute.SnapshotArgs{
//				Name:              pulumi.Sprintf("%v-snapshot1", vmName),
//				Location:          example.Location,
//				ResourceGroupName: example.Name,
//				CreateOption:      pulumi.String("Copy"),
//				SourceUri:         exampleManagedDisk.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = compute.NewImplicitDataDiskFromSource(ctx, "example", &compute.ImplicitDataDiskFromSourceArgs{
//				Name:             pulumi.Sprintf("%v-implicitdisk1", vmName),
//				VirtualMachineId: pulumi.Any(testAzurermVirtualMachine.Id),
//				Lun:              pulumi.Int(0),
//				Caching:          pulumi.String("None"),
//				CreateOption:     pulumi.String("Copy"),
//				DiskSizeGb:       pulumi.Int(20),
//				SourceResourceId: pulumi.Any(test.Id),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## API Providers
//
// <!-- This section is generated, changes will be overwritten -->
// This resource uses the following Azure API Providers:
//
// * `Microsoft.Compute`: 2024-03-01, 2023-04-02
//
// ## Import
//
// The implicit Data Disk of the Virtual Machine can be imported using the `resource id`, e.g.
//
// ```sh
// $ pulumi import azure:compute/implicitDataDiskFromSource:ImplicitDataDiskFromSource example /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/mygroup1/providers/Microsoft.Compute/virtualMachines/machine1/dataDisks/disk1
// ```
type ImplicitDataDiskFromSource struct {
	pulumi.CustomResourceState

	// Specifies the caching requirements for this Data Disk. Possible values are `ReadOnly` and `ReadWrite`.
	Caching pulumi.StringPtrOutput `pulumi:"caching"`
	// Specifies the Create Option of the Data Disk. The only possible value is `Copy`. Changing this forces a new resource to be created.
	CreateOption pulumi.StringOutput `pulumi:"createOption"`
	DiskSizeGb   pulumi.IntOutput    `pulumi:"diskSizeGb"`
	// The Logical Unit Number of the Data Disk, which needs to be unique within the Virtual Machine. Changing this forces a new resource to be created.
	Lun pulumi.IntOutput `pulumi:"lun"`
	// Specifies the name of this Data Disk. Changing this forces a new resource to be created.
	Name pulumi.StringOutput `pulumi:"name"`
	// The ID of the source resource which this Data Disk was created from. Changing this forces a new resource to be created.
	SourceResourceId pulumi.StringOutput `pulumi:"sourceResourceId"`
	// The ID of the Virtual Machine to which the Data Disk should be attached. Changing this forces a new resource to be created.
	VirtualMachineId pulumi.StringOutput `pulumi:"virtualMachineId"`
	// Specifies if Write Accelerator is enabled on the disk. This can only be enabled on `Premium_LRS` managed disks with no caching and [M-Series VMs](https://docs.microsoft.com/azure/virtual-machines/workloads/sap/how-to-enable-write-accelerator). Defaults to `false`.
	WriteAcceleratorEnabled pulumi.BoolPtrOutput `pulumi:"writeAcceleratorEnabled"`
}

// NewImplicitDataDiskFromSource registers a new resource with the given unique name, arguments, and options.
func NewImplicitDataDiskFromSource(ctx *pulumi.Context,
	name string, args *ImplicitDataDiskFromSourceArgs, opts ...pulumi.ResourceOption) (*ImplicitDataDiskFromSource, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.CreateOption == nil {
		return nil, errors.New("invalid value for required argument 'CreateOption'")
	}
	if args.DiskSizeGb == nil {
		return nil, errors.New("invalid value for required argument 'DiskSizeGb'")
	}
	if args.Lun == nil {
		return nil, errors.New("invalid value for required argument 'Lun'")
	}
	if args.SourceResourceId == nil {
		return nil, errors.New("invalid value for required argument 'SourceResourceId'")
	}
	if args.VirtualMachineId == nil {
		return nil, errors.New("invalid value for required argument 'VirtualMachineId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ImplicitDataDiskFromSource
	err := ctx.RegisterResource("azure:compute/implicitDataDiskFromSource:ImplicitDataDiskFromSource", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetImplicitDataDiskFromSource gets an existing ImplicitDataDiskFromSource resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetImplicitDataDiskFromSource(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ImplicitDataDiskFromSourceState, opts ...pulumi.ResourceOption) (*ImplicitDataDiskFromSource, error) {
	var resource ImplicitDataDiskFromSource
	err := ctx.ReadResource("azure:compute/implicitDataDiskFromSource:ImplicitDataDiskFromSource", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ImplicitDataDiskFromSource resources.
type implicitDataDiskFromSourceState struct {
	// Specifies the caching requirements for this Data Disk. Possible values are `ReadOnly` and `ReadWrite`.
	Caching *string `pulumi:"caching"`
	// Specifies the Create Option of the Data Disk. The only possible value is `Copy`. Changing this forces a new resource to be created.
	CreateOption *string `pulumi:"createOption"`
	DiskSizeGb   *int    `pulumi:"diskSizeGb"`
	// The Logical Unit Number of the Data Disk, which needs to be unique within the Virtual Machine. Changing this forces a new resource to be created.
	Lun *int `pulumi:"lun"`
	// Specifies the name of this Data Disk. Changing this forces a new resource to be created.
	Name *string `pulumi:"name"`
	// The ID of the source resource which this Data Disk was created from. Changing this forces a new resource to be created.
	SourceResourceId *string `pulumi:"sourceResourceId"`
	// The ID of the Virtual Machine to which the Data Disk should be attached. Changing this forces a new resource to be created.
	VirtualMachineId *string `pulumi:"virtualMachineId"`
	// Specifies if Write Accelerator is enabled on the disk. This can only be enabled on `Premium_LRS` managed disks with no caching and [M-Series VMs](https://docs.microsoft.com/azure/virtual-machines/workloads/sap/how-to-enable-write-accelerator). Defaults to `false`.
	WriteAcceleratorEnabled *bool `pulumi:"writeAcceleratorEnabled"`
}

type ImplicitDataDiskFromSourceState struct {
	// Specifies the caching requirements for this Data Disk. Possible values are `ReadOnly` and `ReadWrite`.
	Caching pulumi.StringPtrInput
	// Specifies the Create Option of the Data Disk. The only possible value is `Copy`. Changing this forces a new resource to be created.
	CreateOption pulumi.StringPtrInput
	DiskSizeGb   pulumi.IntPtrInput
	// The Logical Unit Number of the Data Disk, which needs to be unique within the Virtual Machine. Changing this forces a new resource to be created.
	Lun pulumi.IntPtrInput
	// Specifies the name of this Data Disk. Changing this forces a new resource to be created.
	Name pulumi.StringPtrInput
	// The ID of the source resource which this Data Disk was created from. Changing this forces a new resource to be created.
	SourceResourceId pulumi.StringPtrInput
	// The ID of the Virtual Machine to which the Data Disk should be attached. Changing this forces a new resource to be created.
	VirtualMachineId pulumi.StringPtrInput
	// Specifies if Write Accelerator is enabled on the disk. This can only be enabled on `Premium_LRS` managed disks with no caching and [M-Series VMs](https://docs.microsoft.com/azure/virtual-machines/workloads/sap/how-to-enable-write-accelerator). Defaults to `false`.
	WriteAcceleratorEnabled pulumi.BoolPtrInput
}

func (ImplicitDataDiskFromSourceState) ElementType() reflect.Type {
	return reflect.TypeOf((*implicitDataDiskFromSourceState)(nil)).Elem()
}

type implicitDataDiskFromSourceArgs struct {
	// Specifies the caching requirements for this Data Disk. Possible values are `ReadOnly` and `ReadWrite`.
	Caching *string `pulumi:"caching"`
	// Specifies the Create Option of the Data Disk. The only possible value is `Copy`. Changing this forces a new resource to be created.
	CreateOption string `pulumi:"createOption"`
	DiskSizeGb   int    `pulumi:"diskSizeGb"`
	// The Logical Unit Number of the Data Disk, which needs to be unique within the Virtual Machine. Changing this forces a new resource to be created.
	Lun int `pulumi:"lun"`
	// Specifies the name of this Data Disk. Changing this forces a new resource to be created.
	Name *string `pulumi:"name"`
	// The ID of the source resource which this Data Disk was created from. Changing this forces a new resource to be created.
	SourceResourceId string `pulumi:"sourceResourceId"`
	// The ID of the Virtual Machine to which the Data Disk should be attached. Changing this forces a new resource to be created.
	VirtualMachineId string `pulumi:"virtualMachineId"`
	// Specifies if Write Accelerator is enabled on the disk. This can only be enabled on `Premium_LRS` managed disks with no caching and [M-Series VMs](https://docs.microsoft.com/azure/virtual-machines/workloads/sap/how-to-enable-write-accelerator). Defaults to `false`.
	WriteAcceleratorEnabled *bool `pulumi:"writeAcceleratorEnabled"`
}

// The set of arguments for constructing a ImplicitDataDiskFromSource resource.
type ImplicitDataDiskFromSourceArgs struct {
	// Specifies the caching requirements for this Data Disk. Possible values are `ReadOnly` and `ReadWrite`.
	Caching pulumi.StringPtrInput
	// Specifies the Create Option of the Data Disk. The only possible value is `Copy`. Changing this forces a new resource to be created.
	CreateOption pulumi.StringInput
	DiskSizeGb   pulumi.IntInput
	// The Logical Unit Number of the Data Disk, which needs to be unique within the Virtual Machine. Changing this forces a new resource to be created.
	Lun pulumi.IntInput
	// Specifies the name of this Data Disk. Changing this forces a new resource to be created.
	Name pulumi.StringPtrInput
	// The ID of the source resource which this Data Disk was created from. Changing this forces a new resource to be created.
	SourceResourceId pulumi.StringInput
	// The ID of the Virtual Machine to which the Data Disk should be attached. Changing this forces a new resource to be created.
	VirtualMachineId pulumi.StringInput
	// Specifies if Write Accelerator is enabled on the disk. This can only be enabled on `Premium_LRS` managed disks with no caching and [M-Series VMs](https://docs.microsoft.com/azure/virtual-machines/workloads/sap/how-to-enable-write-accelerator). Defaults to `false`.
	WriteAcceleratorEnabled pulumi.BoolPtrInput
}

func (ImplicitDataDiskFromSourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*implicitDataDiskFromSourceArgs)(nil)).Elem()
}

type ImplicitDataDiskFromSourceInput interface {
	pulumi.Input

	ToImplicitDataDiskFromSourceOutput() ImplicitDataDiskFromSourceOutput
	ToImplicitDataDiskFromSourceOutputWithContext(ctx context.Context) ImplicitDataDiskFromSourceOutput
}

func (*ImplicitDataDiskFromSource) ElementType() reflect.Type {
	return reflect.TypeOf((**ImplicitDataDiskFromSource)(nil)).Elem()
}

func (i *ImplicitDataDiskFromSource) ToImplicitDataDiskFromSourceOutput() ImplicitDataDiskFromSourceOutput {
	return i.ToImplicitDataDiskFromSourceOutputWithContext(context.Background())
}

func (i *ImplicitDataDiskFromSource) ToImplicitDataDiskFromSourceOutputWithContext(ctx context.Context) ImplicitDataDiskFromSourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ImplicitDataDiskFromSourceOutput)
}

// ImplicitDataDiskFromSourceArrayInput is an input type that accepts ImplicitDataDiskFromSourceArray and ImplicitDataDiskFromSourceArrayOutput values.
// You can construct a concrete instance of `ImplicitDataDiskFromSourceArrayInput` via:
//
//	ImplicitDataDiskFromSourceArray{ ImplicitDataDiskFromSourceArgs{...} }
type ImplicitDataDiskFromSourceArrayInput interface {
	pulumi.Input

	ToImplicitDataDiskFromSourceArrayOutput() ImplicitDataDiskFromSourceArrayOutput
	ToImplicitDataDiskFromSourceArrayOutputWithContext(context.Context) ImplicitDataDiskFromSourceArrayOutput
}

type ImplicitDataDiskFromSourceArray []ImplicitDataDiskFromSourceInput

func (ImplicitDataDiskFromSourceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ImplicitDataDiskFromSource)(nil)).Elem()
}

func (i ImplicitDataDiskFromSourceArray) ToImplicitDataDiskFromSourceArrayOutput() ImplicitDataDiskFromSourceArrayOutput {
	return i.ToImplicitDataDiskFromSourceArrayOutputWithContext(context.Background())
}

func (i ImplicitDataDiskFromSourceArray) ToImplicitDataDiskFromSourceArrayOutputWithContext(ctx context.Context) ImplicitDataDiskFromSourceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ImplicitDataDiskFromSourceArrayOutput)
}

// ImplicitDataDiskFromSourceMapInput is an input type that accepts ImplicitDataDiskFromSourceMap and ImplicitDataDiskFromSourceMapOutput values.
// You can construct a concrete instance of `ImplicitDataDiskFromSourceMapInput` via:
//
//	ImplicitDataDiskFromSourceMap{ "key": ImplicitDataDiskFromSourceArgs{...} }
type ImplicitDataDiskFromSourceMapInput interface {
	pulumi.Input

	ToImplicitDataDiskFromSourceMapOutput() ImplicitDataDiskFromSourceMapOutput
	ToImplicitDataDiskFromSourceMapOutputWithContext(context.Context) ImplicitDataDiskFromSourceMapOutput
}

type ImplicitDataDiskFromSourceMap map[string]ImplicitDataDiskFromSourceInput

func (ImplicitDataDiskFromSourceMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ImplicitDataDiskFromSource)(nil)).Elem()
}

func (i ImplicitDataDiskFromSourceMap) ToImplicitDataDiskFromSourceMapOutput() ImplicitDataDiskFromSourceMapOutput {
	return i.ToImplicitDataDiskFromSourceMapOutputWithContext(context.Background())
}

func (i ImplicitDataDiskFromSourceMap) ToImplicitDataDiskFromSourceMapOutputWithContext(ctx context.Context) ImplicitDataDiskFromSourceMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ImplicitDataDiskFromSourceMapOutput)
}

type ImplicitDataDiskFromSourceOutput struct{ *pulumi.OutputState }

func (ImplicitDataDiskFromSourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ImplicitDataDiskFromSource)(nil)).Elem()
}

func (o ImplicitDataDiskFromSourceOutput) ToImplicitDataDiskFromSourceOutput() ImplicitDataDiskFromSourceOutput {
	return o
}

func (o ImplicitDataDiskFromSourceOutput) ToImplicitDataDiskFromSourceOutputWithContext(ctx context.Context) ImplicitDataDiskFromSourceOutput {
	return o
}

// Specifies the caching requirements for this Data Disk. Possible values are `ReadOnly` and `ReadWrite`.
func (o ImplicitDataDiskFromSourceOutput) Caching() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ImplicitDataDiskFromSource) pulumi.StringPtrOutput { return v.Caching }).(pulumi.StringPtrOutput)
}

// Specifies the Create Option of the Data Disk. The only possible value is `Copy`. Changing this forces a new resource to be created.
func (o ImplicitDataDiskFromSourceOutput) CreateOption() pulumi.StringOutput {
	return o.ApplyT(func(v *ImplicitDataDiskFromSource) pulumi.StringOutput { return v.CreateOption }).(pulumi.StringOutput)
}

func (o ImplicitDataDiskFromSourceOutput) DiskSizeGb() pulumi.IntOutput {
	return o.ApplyT(func(v *ImplicitDataDiskFromSource) pulumi.IntOutput { return v.DiskSizeGb }).(pulumi.IntOutput)
}

// The Logical Unit Number of the Data Disk, which needs to be unique within the Virtual Machine. Changing this forces a new resource to be created.
func (o ImplicitDataDiskFromSourceOutput) Lun() pulumi.IntOutput {
	return o.ApplyT(func(v *ImplicitDataDiskFromSource) pulumi.IntOutput { return v.Lun }).(pulumi.IntOutput)
}

// Specifies the name of this Data Disk. Changing this forces a new resource to be created.
func (o ImplicitDataDiskFromSourceOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *ImplicitDataDiskFromSource) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The ID of the source resource which this Data Disk was created from. Changing this forces a new resource to be created.
func (o ImplicitDataDiskFromSourceOutput) SourceResourceId() pulumi.StringOutput {
	return o.ApplyT(func(v *ImplicitDataDiskFromSource) pulumi.StringOutput { return v.SourceResourceId }).(pulumi.StringOutput)
}

// The ID of the Virtual Machine to which the Data Disk should be attached. Changing this forces a new resource to be created.
func (o ImplicitDataDiskFromSourceOutput) VirtualMachineId() pulumi.StringOutput {
	return o.ApplyT(func(v *ImplicitDataDiskFromSource) pulumi.StringOutput { return v.VirtualMachineId }).(pulumi.StringOutput)
}

// Specifies if Write Accelerator is enabled on the disk. This can only be enabled on `Premium_LRS` managed disks with no caching and [M-Series VMs](https://docs.microsoft.com/azure/virtual-machines/workloads/sap/how-to-enable-write-accelerator). Defaults to `false`.
func (o ImplicitDataDiskFromSourceOutput) WriteAcceleratorEnabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ImplicitDataDiskFromSource) pulumi.BoolPtrOutput { return v.WriteAcceleratorEnabled }).(pulumi.BoolPtrOutput)
}

type ImplicitDataDiskFromSourceArrayOutput struct{ *pulumi.OutputState }

func (ImplicitDataDiskFromSourceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ImplicitDataDiskFromSource)(nil)).Elem()
}

func (o ImplicitDataDiskFromSourceArrayOutput) ToImplicitDataDiskFromSourceArrayOutput() ImplicitDataDiskFromSourceArrayOutput {
	return o
}

func (o ImplicitDataDiskFromSourceArrayOutput) ToImplicitDataDiskFromSourceArrayOutputWithContext(ctx context.Context) ImplicitDataDiskFromSourceArrayOutput {
	return o
}

func (o ImplicitDataDiskFromSourceArrayOutput) Index(i pulumi.IntInput) ImplicitDataDiskFromSourceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ImplicitDataDiskFromSource {
		return vs[0].([]*ImplicitDataDiskFromSource)[vs[1].(int)]
	}).(ImplicitDataDiskFromSourceOutput)
}

type ImplicitDataDiskFromSourceMapOutput struct{ *pulumi.OutputState }

func (ImplicitDataDiskFromSourceMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ImplicitDataDiskFromSource)(nil)).Elem()
}

func (o ImplicitDataDiskFromSourceMapOutput) ToImplicitDataDiskFromSourceMapOutput() ImplicitDataDiskFromSourceMapOutput {
	return o
}

func (o ImplicitDataDiskFromSourceMapOutput) ToImplicitDataDiskFromSourceMapOutputWithContext(ctx context.Context) ImplicitDataDiskFromSourceMapOutput {
	return o
}

func (o ImplicitDataDiskFromSourceMapOutput) MapIndex(k pulumi.StringInput) ImplicitDataDiskFromSourceOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ImplicitDataDiskFromSource {
		return vs[0].(map[string]*ImplicitDataDiskFromSource)[vs[1].(string)]
	}).(ImplicitDataDiskFromSourceOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ImplicitDataDiskFromSourceInput)(nil)).Elem(), &ImplicitDataDiskFromSource{})
	pulumi.RegisterInputType(reflect.TypeOf((*ImplicitDataDiskFromSourceArrayInput)(nil)).Elem(), ImplicitDataDiskFromSourceArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ImplicitDataDiskFromSourceMapInput)(nil)).Elem(), ImplicitDataDiskFromSourceMap{})
	pulumi.RegisterOutputType(ImplicitDataDiskFromSourceOutput{})
	pulumi.RegisterOutputType(ImplicitDataDiskFromSourceArrayOutput{})
	pulumi.RegisterOutputType(ImplicitDataDiskFromSourceMapOutput{})
}
