// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package compute

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-azure/sdk/v6/go/azure/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages a Virtual Machine Extension to provide post deployment configuration
// and run automated tasks.
//
// > **Note:** Custom Script Extensions for Linux & Windows require that the `commandToExecute` returns a `0` exit code to be classified as successfully deployed. You can achieve this by appending `exit 0` to the end of your `commandToExecute`.
//
// > **Note:** Custom Script Extensions require that the Azure Virtual Machine Guest Agent is running on the Virtual Machine.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-azure/sdk/v6/go/azure/compute"
//	"github.com/pulumi/pulumi-azure/sdk/v6/go/azure/core"
//	"github.com/pulumi/pulumi-azure/sdk/v6/go/azure/network"
//	"github.com/pulumi/pulumi-std/sdk/go/std"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			example, err := core.NewResourceGroup(ctx, "example", &core.ResourceGroupArgs{
//				Name:     pulumi.String("example-resources"),
//				Location: pulumi.String("West Europe"),
//			})
//			if err != nil {
//				return err
//			}
//			exampleVirtualNetwork, err := network.NewVirtualNetwork(ctx, "example", &network.VirtualNetworkArgs{
//				Name: pulumi.String("acctvn"),
//				AddressSpaces: pulumi.StringArray{
//					pulumi.String("10.0.0.0/16"),
//				},
//				Location:          example.Location,
//				ResourceGroupName: example.Name,
//			})
//			if err != nil {
//				return err
//			}
//			exampleSubnet, err := network.NewSubnet(ctx, "example", &network.SubnetArgs{
//				Name:               pulumi.String("acctsub"),
//				ResourceGroupName:  example.Name,
//				VirtualNetworkName: exampleVirtualNetwork.Name,
//				AddressPrefixes: pulumi.StringArray{
//					pulumi.String("10.0.2.0/24"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			exampleNetworkInterface, err := network.NewNetworkInterface(ctx, "example", &network.NetworkInterfaceArgs{
//				Name:              pulumi.String("acctni"),
//				Location:          example.Location,
//				ResourceGroupName: example.Name,
//				IpConfigurations: network.NetworkInterfaceIpConfigurationArray{
//					&network.NetworkInterfaceIpConfigurationArgs{
//						Name:                       pulumi.String("testconfiguration1"),
//						SubnetId:                   exampleSubnet.ID(),
//						PrivateIpAddressAllocation: pulumi.String("Dynamic"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			invokeFile, err := std.File(ctx, &std.FileArgs{
//				Input: "~/.ssh/id_rsa.pub",
//			}, nil)
//			if err != nil {
//				return err
//			}
//			exampleLinuxVirtualMachine, err := compute.NewLinuxVirtualMachine(ctx, "example", &compute.LinuxVirtualMachineArgs{
//				Name:              pulumi.String("example-machine"),
//				ResourceGroupName: example.Name,
//				Location:          example.Location,
//				Size:              pulumi.String("Standard_F2"),
//				AdminUsername:     pulumi.String("adminuser"),
//				NetworkInterfaceIds: pulumi.StringArray{
//					exampleNetworkInterface.ID(),
//				},
//				AdminSshKeys: compute.LinuxVirtualMachineAdminSshKeyArray{
//					&compute.LinuxVirtualMachineAdminSshKeyArgs{
//						Username:  pulumi.String("adminuser"),
//						PublicKey: pulumi.String(invokeFile.Result),
//					},
//				},
//				OsDisk: &compute.LinuxVirtualMachineOsDiskArgs{
//					Caching:            pulumi.String("ReadWrite"),
//					StorageAccountType: pulumi.String("Standard_LRS"),
//				},
//				SourceImageReference: &compute.LinuxVirtualMachineSourceImageReferenceArgs{
//					Publisher: pulumi.String("Canonical"),
//					Offer:     pulumi.String("0001-com-ubuntu-server-jammy"),
//					Sku:       pulumi.String("22_04-lts"),
//					Version:   pulumi.String("latest"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = compute.NewExtension(ctx, "example", &compute.ExtensionArgs{
//				Name:               pulumi.String("hostname"),
//				VirtualMachineId:   exampleLinuxVirtualMachine.ID(),
//				Publisher:          pulumi.String("Microsoft.Azure.Extensions"),
//				Type:               pulumi.String("CustomScript"),
//				TypeHandlerVersion: pulumi.String("2.0"),
//				Settings:           pulumi.String(" {\n  \"commandToExecute\": \"hostname && uptime\"\n }\n"),
//				Tags: pulumi.StringMap{
//					"environment": pulumi.String("Production"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## API Providers
//
// <!-- This section is generated, changes will be overwritten -->
// This resource uses the following Azure API Providers:
//
// * `Microsoft.Compute`: 2024-03-01
//
// ## Import
//
// Virtual Machine Extensions can be imported using the `resource id`, e.g.
//
// ```sh
// $ pulumi import azure:compute/extension:Extension example /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/mygroup1/providers/Microsoft.Compute/virtualMachines/myVM/extensions/extensionName
// ```
type Extension struct {
	pulumi.CustomResourceState

	// Specifies if the platform deploys the latest minor version update to the `typeHandlerVersion` specified.
	AutoUpgradeMinorVersion pulumi.BoolPtrOutput `pulumi:"autoUpgradeMinorVersion"`
	// Should the Extension be automatically updated whenever the Publisher releases a new version of this VM Extension?
	AutomaticUpgradeEnabled pulumi.BoolPtrOutput `pulumi:"automaticUpgradeEnabled"`
	// Should failures from the extension be suppressed? Possible values are `true` or `false`. Defaults to `false`.
	//
	// > **Note:** Operational failures such as not connecting to the VM will not be suppressed regardless of the `failureSuppressionEnabled` value.
	FailureSuppressionEnabled pulumi.BoolPtrOutput `pulumi:"failureSuppressionEnabled"`
	// The name of the virtual machine extension peering. Changing this forces a new resource to be created.
	Name pulumi.StringOutput `pulumi:"name"`
	// The protectedSettings passed to the extension, like settings, these are specified as a JSON object in a string.
	//
	// > **Note:** Certain VM Extensions require that the keys in the `protectedSettings` block are case sensitive. If you're seeing unhelpful errors, please ensure the keys are consistent with how Azure is expecting them (for instance, for the `JsonADDomainExtension` extension, the keys are expected to be in `TitleCase`.)
	ProtectedSettings pulumi.StringPtrOutput `pulumi:"protectedSettings"`
	// A `protectedSettingsFromKeyVault` block as defined below.
	//
	// > **Note:** `protectedSettingsFromKeyVault` cannot be used with `protectedSettings`
	ProtectedSettingsFromKeyVault ExtensionProtectedSettingsFromKeyVaultPtrOutput `pulumi:"protectedSettingsFromKeyVault"`
	// Specifies the collection of extension names after which this extension needs to be provisioned.
	ProvisionAfterExtensions pulumi.StringArrayOutput `pulumi:"provisionAfterExtensions"`
	// The publisher of the extension, available publishers can be found by using the Azure CLI. Changing this forces a new resource to be created.
	Publisher pulumi.StringOutput `pulumi:"publisher"`
	// The settings passed to the extension, these are specified as a JSON object in a string.
	//
	// > **Note:** Certain VM Extensions require that the keys in the `settings` block are case sensitive. If you're seeing unhelpful errors, please ensure the keys are consistent with how Azure is expecting them (for instance, for the `JsonADDomainExtension` extension, the keys are expected to be in `TitleCase`.)
	Settings pulumi.StringPtrOutput `pulumi:"settings"`
	// A mapping of tags to assign to the resource.
	Tags pulumi.StringMapOutput `pulumi:"tags"`
	// The type of extension, available types for a publisher can be found using the Azure CLI.
	//
	// > **Note:** The `Publisher` and `Type` of Virtual Machine Extensions can be found using the Azure CLI, via:
	Type pulumi.StringOutput `pulumi:"type"`
	// Specifies the version of the extension to use, available versions can be found using the Azure CLI.
	TypeHandlerVersion pulumi.StringOutput `pulumi:"typeHandlerVersion"`
	// The ID of the Virtual Machine. Changing this forces a new resource to be created
	VirtualMachineId pulumi.StringOutput `pulumi:"virtualMachineId"`
}

// NewExtension registers a new resource with the given unique name, arguments, and options.
func NewExtension(ctx *pulumi.Context,
	name string, args *ExtensionArgs, opts ...pulumi.ResourceOption) (*Extension, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Publisher == nil {
		return nil, errors.New("invalid value for required argument 'Publisher'")
	}
	if args.Type == nil {
		return nil, errors.New("invalid value for required argument 'Type'")
	}
	if args.TypeHandlerVersion == nil {
		return nil, errors.New("invalid value for required argument 'TypeHandlerVersion'")
	}
	if args.VirtualMachineId == nil {
		return nil, errors.New("invalid value for required argument 'VirtualMachineId'")
	}
	if args.ProtectedSettings != nil {
		args.ProtectedSettings = pulumi.ToSecret(args.ProtectedSettings).(pulumi.StringPtrInput)
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"protectedSettings",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Extension
	err := ctx.RegisterResource("azure:compute/extension:Extension", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetExtension gets an existing Extension resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetExtension(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ExtensionState, opts ...pulumi.ResourceOption) (*Extension, error) {
	var resource Extension
	err := ctx.ReadResource("azure:compute/extension:Extension", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Extension resources.
type extensionState struct {
	// Specifies if the platform deploys the latest minor version update to the `typeHandlerVersion` specified.
	AutoUpgradeMinorVersion *bool `pulumi:"autoUpgradeMinorVersion"`
	// Should the Extension be automatically updated whenever the Publisher releases a new version of this VM Extension?
	AutomaticUpgradeEnabled *bool `pulumi:"automaticUpgradeEnabled"`
	// Should failures from the extension be suppressed? Possible values are `true` or `false`. Defaults to `false`.
	//
	// > **Note:** Operational failures such as not connecting to the VM will not be suppressed regardless of the `failureSuppressionEnabled` value.
	FailureSuppressionEnabled *bool `pulumi:"failureSuppressionEnabled"`
	// The name of the virtual machine extension peering. Changing this forces a new resource to be created.
	Name *string `pulumi:"name"`
	// The protectedSettings passed to the extension, like settings, these are specified as a JSON object in a string.
	//
	// > **Note:** Certain VM Extensions require that the keys in the `protectedSettings` block are case sensitive. If you're seeing unhelpful errors, please ensure the keys are consistent with how Azure is expecting them (for instance, for the `JsonADDomainExtension` extension, the keys are expected to be in `TitleCase`.)
	ProtectedSettings *string `pulumi:"protectedSettings"`
	// A `protectedSettingsFromKeyVault` block as defined below.
	//
	// > **Note:** `protectedSettingsFromKeyVault` cannot be used with `protectedSettings`
	ProtectedSettingsFromKeyVault *ExtensionProtectedSettingsFromKeyVault `pulumi:"protectedSettingsFromKeyVault"`
	// Specifies the collection of extension names after which this extension needs to be provisioned.
	ProvisionAfterExtensions []string `pulumi:"provisionAfterExtensions"`
	// The publisher of the extension, available publishers can be found by using the Azure CLI. Changing this forces a new resource to be created.
	Publisher *string `pulumi:"publisher"`
	// The settings passed to the extension, these are specified as a JSON object in a string.
	//
	// > **Note:** Certain VM Extensions require that the keys in the `settings` block are case sensitive. If you're seeing unhelpful errors, please ensure the keys are consistent with how Azure is expecting them (for instance, for the `JsonADDomainExtension` extension, the keys are expected to be in `TitleCase`.)
	Settings *string `pulumi:"settings"`
	// A mapping of tags to assign to the resource.
	Tags map[string]string `pulumi:"tags"`
	// The type of extension, available types for a publisher can be found using the Azure CLI.
	//
	// > **Note:** The `Publisher` and `Type` of Virtual Machine Extensions can be found using the Azure CLI, via:
	Type *string `pulumi:"type"`
	// Specifies the version of the extension to use, available versions can be found using the Azure CLI.
	TypeHandlerVersion *string `pulumi:"typeHandlerVersion"`
	// The ID of the Virtual Machine. Changing this forces a new resource to be created
	VirtualMachineId *string `pulumi:"virtualMachineId"`
}

type ExtensionState struct {
	// Specifies if the platform deploys the latest minor version update to the `typeHandlerVersion` specified.
	AutoUpgradeMinorVersion pulumi.BoolPtrInput
	// Should the Extension be automatically updated whenever the Publisher releases a new version of this VM Extension?
	AutomaticUpgradeEnabled pulumi.BoolPtrInput
	// Should failures from the extension be suppressed? Possible values are `true` or `false`. Defaults to `false`.
	//
	// > **Note:** Operational failures such as not connecting to the VM will not be suppressed regardless of the `failureSuppressionEnabled` value.
	FailureSuppressionEnabled pulumi.BoolPtrInput
	// The name of the virtual machine extension peering. Changing this forces a new resource to be created.
	Name pulumi.StringPtrInput
	// The protectedSettings passed to the extension, like settings, these are specified as a JSON object in a string.
	//
	// > **Note:** Certain VM Extensions require that the keys in the `protectedSettings` block are case sensitive. If you're seeing unhelpful errors, please ensure the keys are consistent with how Azure is expecting them (for instance, for the `JsonADDomainExtension` extension, the keys are expected to be in `TitleCase`.)
	ProtectedSettings pulumi.StringPtrInput
	// A `protectedSettingsFromKeyVault` block as defined below.
	//
	// > **Note:** `protectedSettingsFromKeyVault` cannot be used with `protectedSettings`
	ProtectedSettingsFromKeyVault ExtensionProtectedSettingsFromKeyVaultPtrInput
	// Specifies the collection of extension names after which this extension needs to be provisioned.
	ProvisionAfterExtensions pulumi.StringArrayInput
	// The publisher of the extension, available publishers can be found by using the Azure CLI. Changing this forces a new resource to be created.
	Publisher pulumi.StringPtrInput
	// The settings passed to the extension, these are specified as a JSON object in a string.
	//
	// > **Note:** Certain VM Extensions require that the keys in the `settings` block are case sensitive. If you're seeing unhelpful errors, please ensure the keys are consistent with how Azure is expecting them (for instance, for the `JsonADDomainExtension` extension, the keys are expected to be in `TitleCase`.)
	Settings pulumi.StringPtrInput
	// A mapping of tags to assign to the resource.
	Tags pulumi.StringMapInput
	// The type of extension, available types for a publisher can be found using the Azure CLI.
	//
	// > **Note:** The `Publisher` and `Type` of Virtual Machine Extensions can be found using the Azure CLI, via:
	Type pulumi.StringPtrInput
	// Specifies the version of the extension to use, available versions can be found using the Azure CLI.
	TypeHandlerVersion pulumi.StringPtrInput
	// The ID of the Virtual Machine. Changing this forces a new resource to be created
	VirtualMachineId pulumi.StringPtrInput
}

func (ExtensionState) ElementType() reflect.Type {
	return reflect.TypeOf((*extensionState)(nil)).Elem()
}

type extensionArgs struct {
	// Specifies if the platform deploys the latest minor version update to the `typeHandlerVersion` specified.
	AutoUpgradeMinorVersion *bool `pulumi:"autoUpgradeMinorVersion"`
	// Should the Extension be automatically updated whenever the Publisher releases a new version of this VM Extension?
	AutomaticUpgradeEnabled *bool `pulumi:"automaticUpgradeEnabled"`
	// Should failures from the extension be suppressed? Possible values are `true` or `false`. Defaults to `false`.
	//
	// > **Note:** Operational failures such as not connecting to the VM will not be suppressed regardless of the `failureSuppressionEnabled` value.
	FailureSuppressionEnabled *bool `pulumi:"failureSuppressionEnabled"`
	// The name of the virtual machine extension peering. Changing this forces a new resource to be created.
	Name *string `pulumi:"name"`
	// The protectedSettings passed to the extension, like settings, these are specified as a JSON object in a string.
	//
	// > **Note:** Certain VM Extensions require that the keys in the `protectedSettings` block are case sensitive. If you're seeing unhelpful errors, please ensure the keys are consistent with how Azure is expecting them (for instance, for the `JsonADDomainExtension` extension, the keys are expected to be in `TitleCase`.)
	ProtectedSettings *string `pulumi:"protectedSettings"`
	// A `protectedSettingsFromKeyVault` block as defined below.
	//
	// > **Note:** `protectedSettingsFromKeyVault` cannot be used with `protectedSettings`
	ProtectedSettingsFromKeyVault *ExtensionProtectedSettingsFromKeyVault `pulumi:"protectedSettingsFromKeyVault"`
	// Specifies the collection of extension names after which this extension needs to be provisioned.
	ProvisionAfterExtensions []string `pulumi:"provisionAfterExtensions"`
	// The publisher of the extension, available publishers can be found by using the Azure CLI. Changing this forces a new resource to be created.
	Publisher string `pulumi:"publisher"`
	// The settings passed to the extension, these are specified as a JSON object in a string.
	//
	// > **Note:** Certain VM Extensions require that the keys in the `settings` block are case sensitive. If you're seeing unhelpful errors, please ensure the keys are consistent with how Azure is expecting them (for instance, for the `JsonADDomainExtension` extension, the keys are expected to be in `TitleCase`.)
	Settings *string `pulumi:"settings"`
	// A mapping of tags to assign to the resource.
	Tags map[string]string `pulumi:"tags"`
	// The type of extension, available types for a publisher can be found using the Azure CLI.
	//
	// > **Note:** The `Publisher` and `Type` of Virtual Machine Extensions can be found using the Azure CLI, via:
	Type string `pulumi:"type"`
	// Specifies the version of the extension to use, available versions can be found using the Azure CLI.
	TypeHandlerVersion string `pulumi:"typeHandlerVersion"`
	// The ID of the Virtual Machine. Changing this forces a new resource to be created
	VirtualMachineId string `pulumi:"virtualMachineId"`
}

// The set of arguments for constructing a Extension resource.
type ExtensionArgs struct {
	// Specifies if the platform deploys the latest minor version update to the `typeHandlerVersion` specified.
	AutoUpgradeMinorVersion pulumi.BoolPtrInput
	// Should the Extension be automatically updated whenever the Publisher releases a new version of this VM Extension?
	AutomaticUpgradeEnabled pulumi.BoolPtrInput
	// Should failures from the extension be suppressed? Possible values are `true` or `false`. Defaults to `false`.
	//
	// > **Note:** Operational failures such as not connecting to the VM will not be suppressed regardless of the `failureSuppressionEnabled` value.
	FailureSuppressionEnabled pulumi.BoolPtrInput
	// The name of the virtual machine extension peering. Changing this forces a new resource to be created.
	Name pulumi.StringPtrInput
	// The protectedSettings passed to the extension, like settings, these are specified as a JSON object in a string.
	//
	// > **Note:** Certain VM Extensions require that the keys in the `protectedSettings` block are case sensitive. If you're seeing unhelpful errors, please ensure the keys are consistent with how Azure is expecting them (for instance, for the `JsonADDomainExtension` extension, the keys are expected to be in `TitleCase`.)
	ProtectedSettings pulumi.StringPtrInput
	// A `protectedSettingsFromKeyVault` block as defined below.
	//
	// > **Note:** `protectedSettingsFromKeyVault` cannot be used with `protectedSettings`
	ProtectedSettingsFromKeyVault ExtensionProtectedSettingsFromKeyVaultPtrInput
	// Specifies the collection of extension names after which this extension needs to be provisioned.
	ProvisionAfterExtensions pulumi.StringArrayInput
	// The publisher of the extension, available publishers can be found by using the Azure CLI. Changing this forces a new resource to be created.
	Publisher pulumi.StringInput
	// The settings passed to the extension, these are specified as a JSON object in a string.
	//
	// > **Note:** Certain VM Extensions require that the keys in the `settings` block are case sensitive. If you're seeing unhelpful errors, please ensure the keys are consistent with how Azure is expecting them (for instance, for the `JsonADDomainExtension` extension, the keys are expected to be in `TitleCase`.)
	Settings pulumi.StringPtrInput
	// A mapping of tags to assign to the resource.
	Tags pulumi.StringMapInput
	// The type of extension, available types for a publisher can be found using the Azure CLI.
	//
	// > **Note:** The `Publisher` and `Type` of Virtual Machine Extensions can be found using the Azure CLI, via:
	Type pulumi.StringInput
	// Specifies the version of the extension to use, available versions can be found using the Azure CLI.
	TypeHandlerVersion pulumi.StringInput
	// The ID of the Virtual Machine. Changing this forces a new resource to be created
	VirtualMachineId pulumi.StringInput
}

func (ExtensionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*extensionArgs)(nil)).Elem()
}

type ExtensionInput interface {
	pulumi.Input

	ToExtensionOutput() ExtensionOutput
	ToExtensionOutputWithContext(ctx context.Context) ExtensionOutput
}

func (*Extension) ElementType() reflect.Type {
	return reflect.TypeOf((**Extension)(nil)).Elem()
}

func (i *Extension) ToExtensionOutput() ExtensionOutput {
	return i.ToExtensionOutputWithContext(context.Background())
}

func (i *Extension) ToExtensionOutputWithContext(ctx context.Context) ExtensionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExtensionOutput)
}

// ExtensionArrayInput is an input type that accepts ExtensionArray and ExtensionArrayOutput values.
// You can construct a concrete instance of `ExtensionArrayInput` via:
//
//	ExtensionArray{ ExtensionArgs{...} }
type ExtensionArrayInput interface {
	pulumi.Input

	ToExtensionArrayOutput() ExtensionArrayOutput
	ToExtensionArrayOutputWithContext(context.Context) ExtensionArrayOutput
}

type ExtensionArray []ExtensionInput

func (ExtensionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Extension)(nil)).Elem()
}

func (i ExtensionArray) ToExtensionArrayOutput() ExtensionArrayOutput {
	return i.ToExtensionArrayOutputWithContext(context.Background())
}

func (i ExtensionArray) ToExtensionArrayOutputWithContext(ctx context.Context) ExtensionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExtensionArrayOutput)
}

// ExtensionMapInput is an input type that accepts ExtensionMap and ExtensionMapOutput values.
// You can construct a concrete instance of `ExtensionMapInput` via:
//
//	ExtensionMap{ "key": ExtensionArgs{...} }
type ExtensionMapInput interface {
	pulumi.Input

	ToExtensionMapOutput() ExtensionMapOutput
	ToExtensionMapOutputWithContext(context.Context) ExtensionMapOutput
}

type ExtensionMap map[string]ExtensionInput

func (ExtensionMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Extension)(nil)).Elem()
}

func (i ExtensionMap) ToExtensionMapOutput() ExtensionMapOutput {
	return i.ToExtensionMapOutputWithContext(context.Background())
}

func (i ExtensionMap) ToExtensionMapOutputWithContext(ctx context.Context) ExtensionMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExtensionMapOutput)
}

type ExtensionOutput struct{ *pulumi.OutputState }

func (ExtensionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Extension)(nil)).Elem()
}

func (o ExtensionOutput) ToExtensionOutput() ExtensionOutput {
	return o
}

func (o ExtensionOutput) ToExtensionOutputWithContext(ctx context.Context) ExtensionOutput {
	return o
}

// Specifies if the platform deploys the latest minor version update to the `typeHandlerVersion` specified.
func (o ExtensionOutput) AutoUpgradeMinorVersion() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Extension) pulumi.BoolPtrOutput { return v.AutoUpgradeMinorVersion }).(pulumi.BoolPtrOutput)
}

// Should the Extension be automatically updated whenever the Publisher releases a new version of this VM Extension?
func (o ExtensionOutput) AutomaticUpgradeEnabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Extension) pulumi.BoolPtrOutput { return v.AutomaticUpgradeEnabled }).(pulumi.BoolPtrOutput)
}

// Should failures from the extension be suppressed? Possible values are `true` or `false`. Defaults to `false`.
//
// > **Note:** Operational failures such as not connecting to the VM will not be suppressed regardless of the `failureSuppressionEnabled` value.
func (o ExtensionOutput) FailureSuppressionEnabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Extension) pulumi.BoolPtrOutput { return v.FailureSuppressionEnabled }).(pulumi.BoolPtrOutput)
}

// The name of the virtual machine extension peering. Changing this forces a new resource to be created.
func (o ExtensionOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Extension) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The protectedSettings passed to the extension, like settings, these are specified as a JSON object in a string.
//
// > **Note:** Certain VM Extensions require that the keys in the `protectedSettings` block are case sensitive. If you're seeing unhelpful errors, please ensure the keys are consistent with how Azure is expecting them (for instance, for the `JsonADDomainExtension` extension, the keys are expected to be in `TitleCase`.)
func (o ExtensionOutput) ProtectedSettings() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Extension) pulumi.StringPtrOutput { return v.ProtectedSettings }).(pulumi.StringPtrOutput)
}

// A `protectedSettingsFromKeyVault` block as defined below.
//
// > **Note:** `protectedSettingsFromKeyVault` cannot be used with `protectedSettings`
func (o ExtensionOutput) ProtectedSettingsFromKeyVault() ExtensionProtectedSettingsFromKeyVaultPtrOutput {
	return o.ApplyT(func(v *Extension) ExtensionProtectedSettingsFromKeyVaultPtrOutput {
		return v.ProtectedSettingsFromKeyVault
	}).(ExtensionProtectedSettingsFromKeyVaultPtrOutput)
}

// Specifies the collection of extension names after which this extension needs to be provisioned.
func (o ExtensionOutput) ProvisionAfterExtensions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Extension) pulumi.StringArrayOutput { return v.ProvisionAfterExtensions }).(pulumi.StringArrayOutput)
}

// The publisher of the extension, available publishers can be found by using the Azure CLI. Changing this forces a new resource to be created.
func (o ExtensionOutput) Publisher() pulumi.StringOutput {
	return o.ApplyT(func(v *Extension) pulumi.StringOutput { return v.Publisher }).(pulumi.StringOutput)
}

// The settings passed to the extension, these are specified as a JSON object in a string.
//
// > **Note:** Certain VM Extensions require that the keys in the `settings` block are case sensitive. If you're seeing unhelpful errors, please ensure the keys are consistent with how Azure is expecting them (for instance, for the `JsonADDomainExtension` extension, the keys are expected to be in `TitleCase`.)
func (o ExtensionOutput) Settings() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Extension) pulumi.StringPtrOutput { return v.Settings }).(pulumi.StringPtrOutput)
}

// A mapping of tags to assign to the resource.
func (o ExtensionOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Extension) pulumi.StringMapOutput { return v.Tags }).(pulumi.StringMapOutput)
}

// The type of extension, available types for a publisher can be found using the Azure CLI.
//
// > **Note:** The `Publisher` and `Type` of Virtual Machine Extensions can be found using the Azure CLI, via:
func (o ExtensionOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v *Extension) pulumi.StringOutput { return v.Type }).(pulumi.StringOutput)
}

// Specifies the version of the extension to use, available versions can be found using the Azure CLI.
func (o ExtensionOutput) TypeHandlerVersion() pulumi.StringOutput {
	return o.ApplyT(func(v *Extension) pulumi.StringOutput { return v.TypeHandlerVersion }).(pulumi.StringOutput)
}

// The ID of the Virtual Machine. Changing this forces a new resource to be created
func (o ExtensionOutput) VirtualMachineId() pulumi.StringOutput {
	return o.ApplyT(func(v *Extension) pulumi.StringOutput { return v.VirtualMachineId }).(pulumi.StringOutput)
}

type ExtensionArrayOutput struct{ *pulumi.OutputState }

func (ExtensionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Extension)(nil)).Elem()
}

func (o ExtensionArrayOutput) ToExtensionArrayOutput() ExtensionArrayOutput {
	return o
}

func (o ExtensionArrayOutput) ToExtensionArrayOutputWithContext(ctx context.Context) ExtensionArrayOutput {
	return o
}

func (o ExtensionArrayOutput) Index(i pulumi.IntInput) ExtensionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Extension {
		return vs[0].([]*Extension)[vs[1].(int)]
	}).(ExtensionOutput)
}

type ExtensionMapOutput struct{ *pulumi.OutputState }

func (ExtensionMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Extension)(nil)).Elem()
}

func (o ExtensionMapOutput) ToExtensionMapOutput() ExtensionMapOutput {
	return o
}

func (o ExtensionMapOutput) ToExtensionMapOutputWithContext(ctx context.Context) ExtensionMapOutput {
	return o
}

func (o ExtensionMapOutput) MapIndex(k pulumi.StringInput) ExtensionOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Extension {
		return vs[0].(map[string]*Extension)[vs[1].(string)]
	}).(ExtensionOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ExtensionInput)(nil)).Elem(), &Extension{})
	pulumi.RegisterInputType(reflect.TypeOf((*ExtensionArrayInput)(nil)).Elem(), ExtensionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ExtensionMapInput)(nil)).Elem(), ExtensionMap{})
	pulumi.RegisterOutputType(ExtensionOutput{})
	pulumi.RegisterOutputType(ExtensionArrayOutput{})
	pulumi.RegisterOutputType(ExtensionMapOutput{})
}
