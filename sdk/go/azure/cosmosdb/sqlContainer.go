// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package cosmosdb

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-azure/sdk/v6/go/azure/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages a SQL Container within a Cosmos DB Account.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-azure/sdk/v6/go/azure/cosmosdb"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			example, err := cosmosdb.LookupAccount(ctx, &cosmosdb.LookupAccountArgs{
//				Name:              "tfex-cosmosdb-account",
//				ResourceGroupName: "tfex-cosmosdb-account-rg",
//			}, nil)
//			if err != nil {
//				return err
//			}
//			exampleSqlDatabase, err := cosmosdb.NewSqlDatabase(ctx, "example", &cosmosdb.SqlDatabaseArgs{
//				Name:              pulumi.String("example-acsd"),
//				ResourceGroupName: pulumi.String(example.ResourceGroupName),
//				AccountName:       pulumi.String(example.Name),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = cosmosdb.NewSqlContainer(ctx, "example", &cosmosdb.SqlContainerArgs{
//				Name:              pulumi.String("example-container"),
//				ResourceGroupName: pulumi.String(example.ResourceGroupName),
//				AccountName:       pulumi.String(example.Name),
//				DatabaseName:      exampleSqlDatabase.Name,
//				PartitionKeyPaths: pulumi.StringArray{
//					pulumi.String("/definition/id"),
//				},
//				PartitionKeyVersion: pulumi.Int(1),
//				Throughput:          pulumi.Int(400),
//				IndexingPolicy: &cosmosdb.SqlContainerIndexingPolicyArgs{
//					IndexingMode: pulumi.String("consistent"),
//					IncludedPaths: cosmosdb.SqlContainerIndexingPolicyIncludedPathArray{
//						&cosmosdb.SqlContainerIndexingPolicyIncludedPathArgs{
//							Path: pulumi.String("/*"),
//						},
//						&cosmosdb.SqlContainerIndexingPolicyIncludedPathArgs{
//							Path: pulumi.String("/included/?"),
//						},
//					},
//					ExcludedPaths: cosmosdb.SqlContainerIndexingPolicyExcludedPathArray{
//						&cosmosdb.SqlContainerIndexingPolicyExcludedPathArgs{
//							Path: pulumi.String("/excluded/?"),
//						},
//					},
//				},
//				UniqueKeys: cosmosdb.SqlContainerUniqueKeyArray{
//					&cosmosdb.SqlContainerUniqueKeyArgs{
//						Paths: pulumi.StringArray{
//							pulumi.String("/definition/idlong"),
//							pulumi.String("/definition/idshort"),
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Cosmos SQL Containers can be imported using the `resource id`, e.g.
//
// ```sh
// $ pulumi import azure:cosmosdb/sqlContainer:SqlContainer example /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/group1/providers/Microsoft.DocumentDB/databaseAccounts/account1/sqlDatabases/database1/containers/container1
// ```
type SqlContainer struct {
	pulumi.CustomResourceState

	// The name of the Cosmos DB Account to create the container within. Changing this forces a new resource to be created.
	AccountName pulumi.StringOutput `pulumi:"accountName"`
	// The default time to live of Analytical Storage for this SQL container. If present and the value is set to `-1`, it is equal to infinity, and items don’t expire by default. If present and the value is set to some number `n` – items will expire `n` seconds after their last modified time.
	AnalyticalStorageTtl pulumi.IntPtrOutput `pulumi:"analyticalStorageTtl"`
	// An `autoscaleSettings` block as defined below. This must be set upon database creation otherwise it cannot be updated without a manual destroy-apply.
	//
	// > **Note:** Switching between autoscale and manual throughput is not supported via this provider and must be completed via the Azure Portal and refreshed.
	AutoscaleSettings SqlContainerAutoscaleSettingsPtrOutput `pulumi:"autoscaleSettings"`
	// A `conflictResolutionPolicy` blocks as defined below. Changing this forces a new resource to be created.
	ConflictResolutionPolicy SqlContainerConflictResolutionPolicyOutput `pulumi:"conflictResolutionPolicy"`
	// The name of the Cosmos DB SQL Database to create the container within. Changing this forces a new resource to be created.
	DatabaseName pulumi.StringOutput `pulumi:"databaseName"`
	// The default time to live of SQL container. If missing, items are not expired automatically. If present and the value is set to `-1`, it is equal to infinity, and items don’t expire by default. If present and the value is set to some number `n` – items will expire `n` seconds after their last modified time.
	DefaultTtl pulumi.IntPtrOutput `pulumi:"defaultTtl"`
	// An `indexingPolicy` block as defined below.
	IndexingPolicy SqlContainerIndexingPolicyOutput `pulumi:"indexingPolicy"`
	// Specifies the name of the Cosmos DB SQL Container. Changing this forces a new resource to be created.
	Name pulumi.StringOutput `pulumi:"name"`
	// Define a partition key kind. Possible values are `Hash` and `MultiHash`. Defaults to `Hash`. Changing this forces a new resource to be created.
	PartitionKeyKind pulumi.StringPtrOutput `pulumi:"partitionKeyKind"`
	// A list of partition key paths. Changing this forces a new resource to be created.
	PartitionKeyPaths pulumi.StringArrayOutput `pulumi:"partitionKeyPaths"`
	// Define a partition key version. Possible values are `1`and `2`. This should be set to `2` in order to use large partition keys.
	//
	// > **Note:** If `partitionKeyVersion` is not specified when creating a new resource, you can update `partitionKeyVersion` to `1`, updating to `2` forces a new resource to be created.
	PartitionKeyVersion pulumi.IntPtrOutput `pulumi:"partitionKeyVersion"`
	// The name of the resource group in which the Cosmos DB SQL Container is created. Changing this forces a new resource to be created.
	ResourceGroupName pulumi.StringOutput `pulumi:"resourceGroupName"`
	// The throughput of SQL container (RU/s). Must be set in increments of `100`. The minimum value is `400`. This must be set upon container creation otherwise it cannot be updated without a manual resource destroy-apply.
	Throughput pulumi.IntOutput `pulumi:"throughput"`
	// One or more `uniqueKey` blocks as defined below. Changing this forces a new resource to be created.
	UniqueKeys SqlContainerUniqueKeyArrayOutput `pulumi:"uniqueKeys"`
}

// NewSqlContainer registers a new resource with the given unique name, arguments, and options.
func NewSqlContainer(ctx *pulumi.Context,
	name string, args *SqlContainerArgs, opts ...pulumi.ResourceOption) (*SqlContainer, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.AccountName == nil {
		return nil, errors.New("invalid value for required argument 'AccountName'")
	}
	if args.DatabaseName == nil {
		return nil, errors.New("invalid value for required argument 'DatabaseName'")
	}
	if args.PartitionKeyPaths == nil {
		return nil, errors.New("invalid value for required argument 'PartitionKeyPaths'")
	}
	if args.ResourceGroupName == nil {
		return nil, errors.New("invalid value for required argument 'ResourceGroupName'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource SqlContainer
	err := ctx.RegisterResource("azure:cosmosdb/sqlContainer:SqlContainer", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSqlContainer gets an existing SqlContainer resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSqlContainer(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SqlContainerState, opts ...pulumi.ResourceOption) (*SqlContainer, error) {
	var resource SqlContainer
	err := ctx.ReadResource("azure:cosmosdb/sqlContainer:SqlContainer", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering SqlContainer resources.
type sqlContainerState struct {
	// The name of the Cosmos DB Account to create the container within. Changing this forces a new resource to be created.
	AccountName *string `pulumi:"accountName"`
	// The default time to live of Analytical Storage for this SQL container. If present and the value is set to `-1`, it is equal to infinity, and items don’t expire by default. If present and the value is set to some number `n` – items will expire `n` seconds after their last modified time.
	AnalyticalStorageTtl *int `pulumi:"analyticalStorageTtl"`
	// An `autoscaleSettings` block as defined below. This must be set upon database creation otherwise it cannot be updated without a manual destroy-apply.
	//
	// > **Note:** Switching between autoscale and manual throughput is not supported via this provider and must be completed via the Azure Portal and refreshed.
	AutoscaleSettings *SqlContainerAutoscaleSettings `pulumi:"autoscaleSettings"`
	// A `conflictResolutionPolicy` blocks as defined below. Changing this forces a new resource to be created.
	ConflictResolutionPolicy *SqlContainerConflictResolutionPolicy `pulumi:"conflictResolutionPolicy"`
	// The name of the Cosmos DB SQL Database to create the container within. Changing this forces a new resource to be created.
	DatabaseName *string `pulumi:"databaseName"`
	// The default time to live of SQL container. If missing, items are not expired automatically. If present and the value is set to `-1`, it is equal to infinity, and items don’t expire by default. If present and the value is set to some number `n` – items will expire `n` seconds after their last modified time.
	DefaultTtl *int `pulumi:"defaultTtl"`
	// An `indexingPolicy` block as defined below.
	IndexingPolicy *SqlContainerIndexingPolicy `pulumi:"indexingPolicy"`
	// Specifies the name of the Cosmos DB SQL Container. Changing this forces a new resource to be created.
	Name *string `pulumi:"name"`
	// Define a partition key kind. Possible values are `Hash` and `MultiHash`. Defaults to `Hash`. Changing this forces a new resource to be created.
	PartitionKeyKind *string `pulumi:"partitionKeyKind"`
	// A list of partition key paths. Changing this forces a new resource to be created.
	PartitionKeyPaths []string `pulumi:"partitionKeyPaths"`
	// Define a partition key version. Possible values are `1`and `2`. This should be set to `2` in order to use large partition keys.
	//
	// > **Note:** If `partitionKeyVersion` is not specified when creating a new resource, you can update `partitionKeyVersion` to `1`, updating to `2` forces a new resource to be created.
	PartitionKeyVersion *int `pulumi:"partitionKeyVersion"`
	// The name of the resource group in which the Cosmos DB SQL Container is created. Changing this forces a new resource to be created.
	ResourceGroupName *string `pulumi:"resourceGroupName"`
	// The throughput of SQL container (RU/s). Must be set in increments of `100`. The minimum value is `400`. This must be set upon container creation otherwise it cannot be updated without a manual resource destroy-apply.
	Throughput *int `pulumi:"throughput"`
	// One or more `uniqueKey` blocks as defined below. Changing this forces a new resource to be created.
	UniqueKeys []SqlContainerUniqueKey `pulumi:"uniqueKeys"`
}

type SqlContainerState struct {
	// The name of the Cosmos DB Account to create the container within. Changing this forces a new resource to be created.
	AccountName pulumi.StringPtrInput
	// The default time to live of Analytical Storage for this SQL container. If present and the value is set to `-1`, it is equal to infinity, and items don’t expire by default. If present and the value is set to some number `n` – items will expire `n` seconds after their last modified time.
	AnalyticalStorageTtl pulumi.IntPtrInput
	// An `autoscaleSettings` block as defined below. This must be set upon database creation otherwise it cannot be updated without a manual destroy-apply.
	//
	// > **Note:** Switching between autoscale and manual throughput is not supported via this provider and must be completed via the Azure Portal and refreshed.
	AutoscaleSettings SqlContainerAutoscaleSettingsPtrInput
	// A `conflictResolutionPolicy` blocks as defined below. Changing this forces a new resource to be created.
	ConflictResolutionPolicy SqlContainerConflictResolutionPolicyPtrInput
	// The name of the Cosmos DB SQL Database to create the container within. Changing this forces a new resource to be created.
	DatabaseName pulumi.StringPtrInput
	// The default time to live of SQL container. If missing, items are not expired automatically. If present and the value is set to `-1`, it is equal to infinity, and items don’t expire by default. If present and the value is set to some number `n` – items will expire `n` seconds after their last modified time.
	DefaultTtl pulumi.IntPtrInput
	// An `indexingPolicy` block as defined below.
	IndexingPolicy SqlContainerIndexingPolicyPtrInput
	// Specifies the name of the Cosmos DB SQL Container. Changing this forces a new resource to be created.
	Name pulumi.StringPtrInput
	// Define a partition key kind. Possible values are `Hash` and `MultiHash`. Defaults to `Hash`. Changing this forces a new resource to be created.
	PartitionKeyKind pulumi.StringPtrInput
	// A list of partition key paths. Changing this forces a new resource to be created.
	PartitionKeyPaths pulumi.StringArrayInput
	// Define a partition key version. Possible values are `1`and `2`. This should be set to `2` in order to use large partition keys.
	//
	// > **Note:** If `partitionKeyVersion` is not specified when creating a new resource, you can update `partitionKeyVersion` to `1`, updating to `2` forces a new resource to be created.
	PartitionKeyVersion pulumi.IntPtrInput
	// The name of the resource group in which the Cosmos DB SQL Container is created. Changing this forces a new resource to be created.
	ResourceGroupName pulumi.StringPtrInput
	// The throughput of SQL container (RU/s). Must be set in increments of `100`. The minimum value is `400`. This must be set upon container creation otherwise it cannot be updated without a manual resource destroy-apply.
	Throughput pulumi.IntPtrInput
	// One or more `uniqueKey` blocks as defined below. Changing this forces a new resource to be created.
	UniqueKeys SqlContainerUniqueKeyArrayInput
}

func (SqlContainerState) ElementType() reflect.Type {
	return reflect.TypeOf((*sqlContainerState)(nil)).Elem()
}

type sqlContainerArgs struct {
	// The name of the Cosmos DB Account to create the container within. Changing this forces a new resource to be created.
	AccountName string `pulumi:"accountName"`
	// The default time to live of Analytical Storage for this SQL container. If present and the value is set to `-1`, it is equal to infinity, and items don’t expire by default. If present and the value is set to some number `n` – items will expire `n` seconds after their last modified time.
	AnalyticalStorageTtl *int `pulumi:"analyticalStorageTtl"`
	// An `autoscaleSettings` block as defined below. This must be set upon database creation otherwise it cannot be updated without a manual destroy-apply.
	//
	// > **Note:** Switching between autoscale and manual throughput is not supported via this provider and must be completed via the Azure Portal and refreshed.
	AutoscaleSettings *SqlContainerAutoscaleSettings `pulumi:"autoscaleSettings"`
	// A `conflictResolutionPolicy` blocks as defined below. Changing this forces a new resource to be created.
	ConflictResolutionPolicy *SqlContainerConflictResolutionPolicy `pulumi:"conflictResolutionPolicy"`
	// The name of the Cosmos DB SQL Database to create the container within. Changing this forces a new resource to be created.
	DatabaseName string `pulumi:"databaseName"`
	// The default time to live of SQL container. If missing, items are not expired automatically. If present and the value is set to `-1`, it is equal to infinity, and items don’t expire by default. If present and the value is set to some number `n` – items will expire `n` seconds after their last modified time.
	DefaultTtl *int `pulumi:"defaultTtl"`
	// An `indexingPolicy` block as defined below.
	IndexingPolicy *SqlContainerIndexingPolicy `pulumi:"indexingPolicy"`
	// Specifies the name of the Cosmos DB SQL Container. Changing this forces a new resource to be created.
	Name *string `pulumi:"name"`
	// Define a partition key kind. Possible values are `Hash` and `MultiHash`. Defaults to `Hash`. Changing this forces a new resource to be created.
	PartitionKeyKind *string `pulumi:"partitionKeyKind"`
	// A list of partition key paths. Changing this forces a new resource to be created.
	PartitionKeyPaths []string `pulumi:"partitionKeyPaths"`
	// Define a partition key version. Possible values are `1`and `2`. This should be set to `2` in order to use large partition keys.
	//
	// > **Note:** If `partitionKeyVersion` is not specified when creating a new resource, you can update `partitionKeyVersion` to `1`, updating to `2` forces a new resource to be created.
	PartitionKeyVersion *int `pulumi:"partitionKeyVersion"`
	// The name of the resource group in which the Cosmos DB SQL Container is created. Changing this forces a new resource to be created.
	ResourceGroupName string `pulumi:"resourceGroupName"`
	// The throughput of SQL container (RU/s). Must be set in increments of `100`. The minimum value is `400`. This must be set upon container creation otherwise it cannot be updated without a manual resource destroy-apply.
	Throughput *int `pulumi:"throughput"`
	// One or more `uniqueKey` blocks as defined below. Changing this forces a new resource to be created.
	UniqueKeys []SqlContainerUniqueKey `pulumi:"uniqueKeys"`
}

// The set of arguments for constructing a SqlContainer resource.
type SqlContainerArgs struct {
	// The name of the Cosmos DB Account to create the container within. Changing this forces a new resource to be created.
	AccountName pulumi.StringInput
	// The default time to live of Analytical Storage for this SQL container. If present and the value is set to `-1`, it is equal to infinity, and items don’t expire by default. If present and the value is set to some number `n` – items will expire `n` seconds after their last modified time.
	AnalyticalStorageTtl pulumi.IntPtrInput
	// An `autoscaleSettings` block as defined below. This must be set upon database creation otherwise it cannot be updated without a manual destroy-apply.
	//
	// > **Note:** Switching between autoscale and manual throughput is not supported via this provider and must be completed via the Azure Portal and refreshed.
	AutoscaleSettings SqlContainerAutoscaleSettingsPtrInput
	// A `conflictResolutionPolicy` blocks as defined below. Changing this forces a new resource to be created.
	ConflictResolutionPolicy SqlContainerConflictResolutionPolicyPtrInput
	// The name of the Cosmos DB SQL Database to create the container within. Changing this forces a new resource to be created.
	DatabaseName pulumi.StringInput
	// The default time to live of SQL container. If missing, items are not expired automatically. If present and the value is set to `-1`, it is equal to infinity, and items don’t expire by default. If present and the value is set to some number `n` – items will expire `n` seconds after their last modified time.
	DefaultTtl pulumi.IntPtrInput
	// An `indexingPolicy` block as defined below.
	IndexingPolicy SqlContainerIndexingPolicyPtrInput
	// Specifies the name of the Cosmos DB SQL Container. Changing this forces a new resource to be created.
	Name pulumi.StringPtrInput
	// Define a partition key kind. Possible values are `Hash` and `MultiHash`. Defaults to `Hash`. Changing this forces a new resource to be created.
	PartitionKeyKind pulumi.StringPtrInput
	// A list of partition key paths. Changing this forces a new resource to be created.
	PartitionKeyPaths pulumi.StringArrayInput
	// Define a partition key version. Possible values are `1`and `2`. This should be set to `2` in order to use large partition keys.
	//
	// > **Note:** If `partitionKeyVersion` is not specified when creating a new resource, you can update `partitionKeyVersion` to `1`, updating to `2` forces a new resource to be created.
	PartitionKeyVersion pulumi.IntPtrInput
	// The name of the resource group in which the Cosmos DB SQL Container is created. Changing this forces a new resource to be created.
	ResourceGroupName pulumi.StringInput
	// The throughput of SQL container (RU/s). Must be set in increments of `100`. The minimum value is `400`. This must be set upon container creation otherwise it cannot be updated without a manual resource destroy-apply.
	Throughput pulumi.IntPtrInput
	// One or more `uniqueKey` blocks as defined below. Changing this forces a new resource to be created.
	UniqueKeys SqlContainerUniqueKeyArrayInput
}

func (SqlContainerArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*sqlContainerArgs)(nil)).Elem()
}

type SqlContainerInput interface {
	pulumi.Input

	ToSqlContainerOutput() SqlContainerOutput
	ToSqlContainerOutputWithContext(ctx context.Context) SqlContainerOutput
}

func (*SqlContainer) ElementType() reflect.Type {
	return reflect.TypeOf((**SqlContainer)(nil)).Elem()
}

func (i *SqlContainer) ToSqlContainerOutput() SqlContainerOutput {
	return i.ToSqlContainerOutputWithContext(context.Background())
}

func (i *SqlContainer) ToSqlContainerOutputWithContext(ctx context.Context) SqlContainerOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SqlContainerOutput)
}

// SqlContainerArrayInput is an input type that accepts SqlContainerArray and SqlContainerArrayOutput values.
// You can construct a concrete instance of `SqlContainerArrayInput` via:
//
//	SqlContainerArray{ SqlContainerArgs{...} }
type SqlContainerArrayInput interface {
	pulumi.Input

	ToSqlContainerArrayOutput() SqlContainerArrayOutput
	ToSqlContainerArrayOutputWithContext(context.Context) SqlContainerArrayOutput
}

type SqlContainerArray []SqlContainerInput

func (SqlContainerArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SqlContainer)(nil)).Elem()
}

func (i SqlContainerArray) ToSqlContainerArrayOutput() SqlContainerArrayOutput {
	return i.ToSqlContainerArrayOutputWithContext(context.Background())
}

func (i SqlContainerArray) ToSqlContainerArrayOutputWithContext(ctx context.Context) SqlContainerArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SqlContainerArrayOutput)
}

// SqlContainerMapInput is an input type that accepts SqlContainerMap and SqlContainerMapOutput values.
// You can construct a concrete instance of `SqlContainerMapInput` via:
//
//	SqlContainerMap{ "key": SqlContainerArgs{...} }
type SqlContainerMapInput interface {
	pulumi.Input

	ToSqlContainerMapOutput() SqlContainerMapOutput
	ToSqlContainerMapOutputWithContext(context.Context) SqlContainerMapOutput
}

type SqlContainerMap map[string]SqlContainerInput

func (SqlContainerMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SqlContainer)(nil)).Elem()
}

func (i SqlContainerMap) ToSqlContainerMapOutput() SqlContainerMapOutput {
	return i.ToSqlContainerMapOutputWithContext(context.Background())
}

func (i SqlContainerMap) ToSqlContainerMapOutputWithContext(ctx context.Context) SqlContainerMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SqlContainerMapOutput)
}

type SqlContainerOutput struct{ *pulumi.OutputState }

func (SqlContainerOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SqlContainer)(nil)).Elem()
}

func (o SqlContainerOutput) ToSqlContainerOutput() SqlContainerOutput {
	return o
}

func (o SqlContainerOutput) ToSqlContainerOutputWithContext(ctx context.Context) SqlContainerOutput {
	return o
}

// The name of the Cosmos DB Account to create the container within. Changing this forces a new resource to be created.
func (o SqlContainerOutput) AccountName() pulumi.StringOutput {
	return o.ApplyT(func(v *SqlContainer) pulumi.StringOutput { return v.AccountName }).(pulumi.StringOutput)
}

// The default time to live of Analytical Storage for this SQL container. If present and the value is set to `-1`, it is equal to infinity, and items don’t expire by default. If present and the value is set to some number `n` – items will expire `n` seconds after their last modified time.
func (o SqlContainerOutput) AnalyticalStorageTtl() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *SqlContainer) pulumi.IntPtrOutput { return v.AnalyticalStorageTtl }).(pulumi.IntPtrOutput)
}

// An `autoscaleSettings` block as defined below. This must be set upon database creation otherwise it cannot be updated without a manual destroy-apply.
//
// > **Note:** Switching between autoscale and manual throughput is not supported via this provider and must be completed via the Azure Portal and refreshed.
func (o SqlContainerOutput) AutoscaleSettings() SqlContainerAutoscaleSettingsPtrOutput {
	return o.ApplyT(func(v *SqlContainer) SqlContainerAutoscaleSettingsPtrOutput { return v.AutoscaleSettings }).(SqlContainerAutoscaleSettingsPtrOutput)
}

// A `conflictResolutionPolicy` blocks as defined below. Changing this forces a new resource to be created.
func (o SqlContainerOutput) ConflictResolutionPolicy() SqlContainerConflictResolutionPolicyOutput {
	return o.ApplyT(func(v *SqlContainer) SqlContainerConflictResolutionPolicyOutput { return v.ConflictResolutionPolicy }).(SqlContainerConflictResolutionPolicyOutput)
}

// The name of the Cosmos DB SQL Database to create the container within. Changing this forces a new resource to be created.
func (o SqlContainerOutput) DatabaseName() pulumi.StringOutput {
	return o.ApplyT(func(v *SqlContainer) pulumi.StringOutput { return v.DatabaseName }).(pulumi.StringOutput)
}

// The default time to live of SQL container. If missing, items are not expired automatically. If present and the value is set to `-1`, it is equal to infinity, and items don’t expire by default. If present and the value is set to some number `n` – items will expire `n` seconds after their last modified time.
func (o SqlContainerOutput) DefaultTtl() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *SqlContainer) pulumi.IntPtrOutput { return v.DefaultTtl }).(pulumi.IntPtrOutput)
}

// An `indexingPolicy` block as defined below.
func (o SqlContainerOutput) IndexingPolicy() SqlContainerIndexingPolicyOutput {
	return o.ApplyT(func(v *SqlContainer) SqlContainerIndexingPolicyOutput { return v.IndexingPolicy }).(SqlContainerIndexingPolicyOutput)
}

// Specifies the name of the Cosmos DB SQL Container. Changing this forces a new resource to be created.
func (o SqlContainerOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *SqlContainer) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Define a partition key kind. Possible values are `Hash` and `MultiHash`. Defaults to `Hash`. Changing this forces a new resource to be created.
func (o SqlContainerOutput) PartitionKeyKind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SqlContainer) pulumi.StringPtrOutput { return v.PartitionKeyKind }).(pulumi.StringPtrOutput)
}

// A list of partition key paths. Changing this forces a new resource to be created.
func (o SqlContainerOutput) PartitionKeyPaths() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *SqlContainer) pulumi.StringArrayOutput { return v.PartitionKeyPaths }).(pulumi.StringArrayOutput)
}

// Define a partition key version. Possible values are `1`and `2`. This should be set to `2` in order to use large partition keys.
//
// > **Note:** If `partitionKeyVersion` is not specified when creating a new resource, you can update `partitionKeyVersion` to `1`, updating to `2` forces a new resource to be created.
func (o SqlContainerOutput) PartitionKeyVersion() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *SqlContainer) pulumi.IntPtrOutput { return v.PartitionKeyVersion }).(pulumi.IntPtrOutput)
}

// The name of the resource group in which the Cosmos DB SQL Container is created. Changing this forces a new resource to be created.
func (o SqlContainerOutput) ResourceGroupName() pulumi.StringOutput {
	return o.ApplyT(func(v *SqlContainer) pulumi.StringOutput { return v.ResourceGroupName }).(pulumi.StringOutput)
}

// The throughput of SQL container (RU/s). Must be set in increments of `100`. The minimum value is `400`. This must be set upon container creation otherwise it cannot be updated without a manual resource destroy-apply.
func (o SqlContainerOutput) Throughput() pulumi.IntOutput {
	return o.ApplyT(func(v *SqlContainer) pulumi.IntOutput { return v.Throughput }).(pulumi.IntOutput)
}

// One or more `uniqueKey` blocks as defined below. Changing this forces a new resource to be created.
func (o SqlContainerOutput) UniqueKeys() SqlContainerUniqueKeyArrayOutput {
	return o.ApplyT(func(v *SqlContainer) SqlContainerUniqueKeyArrayOutput { return v.UniqueKeys }).(SqlContainerUniqueKeyArrayOutput)
}

type SqlContainerArrayOutput struct{ *pulumi.OutputState }

func (SqlContainerArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SqlContainer)(nil)).Elem()
}

func (o SqlContainerArrayOutput) ToSqlContainerArrayOutput() SqlContainerArrayOutput {
	return o
}

func (o SqlContainerArrayOutput) ToSqlContainerArrayOutputWithContext(ctx context.Context) SqlContainerArrayOutput {
	return o
}

func (o SqlContainerArrayOutput) Index(i pulumi.IntInput) SqlContainerOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *SqlContainer {
		return vs[0].([]*SqlContainer)[vs[1].(int)]
	}).(SqlContainerOutput)
}

type SqlContainerMapOutput struct{ *pulumi.OutputState }

func (SqlContainerMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SqlContainer)(nil)).Elem()
}

func (o SqlContainerMapOutput) ToSqlContainerMapOutput() SqlContainerMapOutput {
	return o
}

func (o SqlContainerMapOutput) ToSqlContainerMapOutputWithContext(ctx context.Context) SqlContainerMapOutput {
	return o
}

func (o SqlContainerMapOutput) MapIndex(k pulumi.StringInput) SqlContainerOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *SqlContainer {
		return vs[0].(map[string]*SqlContainer)[vs[1].(string)]
	}).(SqlContainerOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SqlContainerInput)(nil)).Elem(), &SqlContainer{})
	pulumi.RegisterInputType(reflect.TypeOf((*SqlContainerArrayInput)(nil)).Elem(), SqlContainerArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SqlContainerMapInput)(nil)).Elem(), SqlContainerMap{})
	pulumi.RegisterOutputType(SqlContainerOutput{})
	pulumi.RegisterOutputType(SqlContainerArrayOutput{})
	pulumi.RegisterOutputType(SqlContainerMapOutput{})
}
