// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package cosmosdb

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-azure/sdk/v5/go/azure/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages an SQL Trigger.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-azure/sdk/v5/go/azure/cosmosdb"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			exampleAccount, err := cosmosdb.LookupAccount(ctx, &cosmosdb.LookupAccountArgs{
//				Name:              "tfex-cosmosdb-account",
//				ResourceGroupName: "tfex-cosmosdb-account-rg",
//			}, nil)
//			if err != nil {
//				return err
//			}
//			exampleSqlDatabase, err := cosmosdb.NewSqlDatabase(ctx, "exampleSqlDatabase", &cosmosdb.SqlDatabaseArgs{
//				ResourceGroupName: *pulumi.String(exampleAccount.ResourceGroupName),
//				AccountName:       *pulumi.String(exampleAccount.Name),
//				Throughput:        pulumi.Int(400),
//			})
//			if err != nil {
//				return err
//			}
//			exampleSqlContainer, err := cosmosdb.NewSqlContainer(ctx, "exampleSqlContainer", &cosmosdb.SqlContainerArgs{
//				ResourceGroupName: *pulumi.String(exampleAccount.ResourceGroupName),
//				AccountName:       *pulumi.String(exampleAccount.Name),
//				DatabaseName:      exampleSqlDatabase.Name,
//				PartitionKeyPath:  pulumi.String("/id"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = cosmosdb.NewSqlTrigger(ctx, "exampleSqlTrigger", &cosmosdb.SqlTriggerArgs{
//				ContainerId: exampleSqlContainer.ID(),
//				Body:        pulumi.String("function trigger(){}"),
//				Operation:   pulumi.String("Delete"),
//				Type:        pulumi.String("Post"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// SQL Triggers can be imported using the `resource id`, e.g.
//
// ```sh
//
//	$ pulumi import azure:cosmosdb/sqlTrigger:SqlTrigger example /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/group1/providers/Microsoft.DocumentDB/databaseAccounts/account1/sqlDatabases/database1/containers/container1/triggers/trigger1
//
// ```
type SqlTrigger struct {
	pulumi.CustomResourceState

	// Body of the Trigger.
	Body pulumi.StringOutput `pulumi:"body"`
	// The id of the Cosmos DB SQL Container to create the SQL Trigger within. Changing this forces a new SQL Trigger to be created.
	ContainerId pulumi.StringOutput `pulumi:"containerId"`
	// The name which should be used for this SQL Trigger. Changing this forces a new SQL Trigger to be created.
	Name pulumi.StringOutput `pulumi:"name"`
	// The operation the trigger is associated with. Possible values are `All`, `Create`, `Update`, `Delete` and `Replace`.
	Operation pulumi.StringOutput `pulumi:"operation"`
	// Type of the Trigger. Possible values are `Pre` and `Post`.
	Type pulumi.StringOutput `pulumi:"type"`
}

// NewSqlTrigger registers a new resource with the given unique name, arguments, and options.
func NewSqlTrigger(ctx *pulumi.Context,
	name string, args *SqlTriggerArgs, opts ...pulumi.ResourceOption) (*SqlTrigger, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Body == nil {
		return nil, errors.New("invalid value for required argument 'Body'")
	}
	if args.ContainerId == nil {
		return nil, errors.New("invalid value for required argument 'ContainerId'")
	}
	if args.Operation == nil {
		return nil, errors.New("invalid value for required argument 'Operation'")
	}
	if args.Type == nil {
		return nil, errors.New("invalid value for required argument 'Type'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource SqlTrigger
	err := ctx.RegisterResource("azure:cosmosdb/sqlTrigger:SqlTrigger", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSqlTrigger gets an existing SqlTrigger resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSqlTrigger(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SqlTriggerState, opts ...pulumi.ResourceOption) (*SqlTrigger, error) {
	var resource SqlTrigger
	err := ctx.ReadResource("azure:cosmosdb/sqlTrigger:SqlTrigger", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering SqlTrigger resources.
type sqlTriggerState struct {
	// Body of the Trigger.
	Body *string `pulumi:"body"`
	// The id of the Cosmos DB SQL Container to create the SQL Trigger within. Changing this forces a new SQL Trigger to be created.
	ContainerId *string `pulumi:"containerId"`
	// The name which should be used for this SQL Trigger. Changing this forces a new SQL Trigger to be created.
	Name *string `pulumi:"name"`
	// The operation the trigger is associated with. Possible values are `All`, `Create`, `Update`, `Delete` and `Replace`.
	Operation *string `pulumi:"operation"`
	// Type of the Trigger. Possible values are `Pre` and `Post`.
	Type *string `pulumi:"type"`
}

type SqlTriggerState struct {
	// Body of the Trigger.
	Body pulumi.StringPtrInput
	// The id of the Cosmos DB SQL Container to create the SQL Trigger within. Changing this forces a new SQL Trigger to be created.
	ContainerId pulumi.StringPtrInput
	// The name which should be used for this SQL Trigger. Changing this forces a new SQL Trigger to be created.
	Name pulumi.StringPtrInput
	// The operation the trigger is associated with. Possible values are `All`, `Create`, `Update`, `Delete` and `Replace`.
	Operation pulumi.StringPtrInput
	// Type of the Trigger. Possible values are `Pre` and `Post`.
	Type pulumi.StringPtrInput
}

func (SqlTriggerState) ElementType() reflect.Type {
	return reflect.TypeOf((*sqlTriggerState)(nil)).Elem()
}

type sqlTriggerArgs struct {
	// Body of the Trigger.
	Body string `pulumi:"body"`
	// The id of the Cosmos DB SQL Container to create the SQL Trigger within. Changing this forces a new SQL Trigger to be created.
	ContainerId string `pulumi:"containerId"`
	// The name which should be used for this SQL Trigger. Changing this forces a new SQL Trigger to be created.
	Name *string `pulumi:"name"`
	// The operation the trigger is associated with. Possible values are `All`, `Create`, `Update`, `Delete` and `Replace`.
	Operation string `pulumi:"operation"`
	// Type of the Trigger. Possible values are `Pre` and `Post`.
	Type string `pulumi:"type"`
}

// The set of arguments for constructing a SqlTrigger resource.
type SqlTriggerArgs struct {
	// Body of the Trigger.
	Body pulumi.StringInput
	// The id of the Cosmos DB SQL Container to create the SQL Trigger within. Changing this forces a new SQL Trigger to be created.
	ContainerId pulumi.StringInput
	// The name which should be used for this SQL Trigger. Changing this forces a new SQL Trigger to be created.
	Name pulumi.StringPtrInput
	// The operation the trigger is associated with. Possible values are `All`, `Create`, `Update`, `Delete` and `Replace`.
	Operation pulumi.StringInput
	// Type of the Trigger. Possible values are `Pre` and `Post`.
	Type pulumi.StringInput
}

func (SqlTriggerArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*sqlTriggerArgs)(nil)).Elem()
}

type SqlTriggerInput interface {
	pulumi.Input

	ToSqlTriggerOutput() SqlTriggerOutput
	ToSqlTriggerOutputWithContext(ctx context.Context) SqlTriggerOutput
}

func (*SqlTrigger) ElementType() reflect.Type {
	return reflect.TypeOf((**SqlTrigger)(nil)).Elem()
}

func (i *SqlTrigger) ToSqlTriggerOutput() SqlTriggerOutput {
	return i.ToSqlTriggerOutputWithContext(context.Background())
}

func (i *SqlTrigger) ToSqlTriggerOutputWithContext(ctx context.Context) SqlTriggerOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SqlTriggerOutput)
}

// SqlTriggerArrayInput is an input type that accepts SqlTriggerArray and SqlTriggerArrayOutput values.
// You can construct a concrete instance of `SqlTriggerArrayInput` via:
//
//	SqlTriggerArray{ SqlTriggerArgs{...} }
type SqlTriggerArrayInput interface {
	pulumi.Input

	ToSqlTriggerArrayOutput() SqlTriggerArrayOutput
	ToSqlTriggerArrayOutputWithContext(context.Context) SqlTriggerArrayOutput
}

type SqlTriggerArray []SqlTriggerInput

func (SqlTriggerArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SqlTrigger)(nil)).Elem()
}

func (i SqlTriggerArray) ToSqlTriggerArrayOutput() SqlTriggerArrayOutput {
	return i.ToSqlTriggerArrayOutputWithContext(context.Background())
}

func (i SqlTriggerArray) ToSqlTriggerArrayOutputWithContext(ctx context.Context) SqlTriggerArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SqlTriggerArrayOutput)
}

// SqlTriggerMapInput is an input type that accepts SqlTriggerMap and SqlTriggerMapOutput values.
// You can construct a concrete instance of `SqlTriggerMapInput` via:
//
//	SqlTriggerMap{ "key": SqlTriggerArgs{...} }
type SqlTriggerMapInput interface {
	pulumi.Input

	ToSqlTriggerMapOutput() SqlTriggerMapOutput
	ToSqlTriggerMapOutputWithContext(context.Context) SqlTriggerMapOutput
}

type SqlTriggerMap map[string]SqlTriggerInput

func (SqlTriggerMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SqlTrigger)(nil)).Elem()
}

func (i SqlTriggerMap) ToSqlTriggerMapOutput() SqlTriggerMapOutput {
	return i.ToSqlTriggerMapOutputWithContext(context.Background())
}

func (i SqlTriggerMap) ToSqlTriggerMapOutputWithContext(ctx context.Context) SqlTriggerMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SqlTriggerMapOutput)
}

type SqlTriggerOutput struct{ *pulumi.OutputState }

func (SqlTriggerOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SqlTrigger)(nil)).Elem()
}

func (o SqlTriggerOutput) ToSqlTriggerOutput() SqlTriggerOutput {
	return o
}

func (o SqlTriggerOutput) ToSqlTriggerOutputWithContext(ctx context.Context) SqlTriggerOutput {
	return o
}

// Body of the Trigger.
func (o SqlTriggerOutput) Body() pulumi.StringOutput {
	return o.ApplyT(func(v *SqlTrigger) pulumi.StringOutput { return v.Body }).(pulumi.StringOutput)
}

// The id of the Cosmos DB SQL Container to create the SQL Trigger within. Changing this forces a new SQL Trigger to be created.
func (o SqlTriggerOutput) ContainerId() pulumi.StringOutput {
	return o.ApplyT(func(v *SqlTrigger) pulumi.StringOutput { return v.ContainerId }).(pulumi.StringOutput)
}

// The name which should be used for this SQL Trigger. Changing this forces a new SQL Trigger to be created.
func (o SqlTriggerOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *SqlTrigger) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The operation the trigger is associated with. Possible values are `All`, `Create`, `Update`, `Delete` and `Replace`.
func (o SqlTriggerOutput) Operation() pulumi.StringOutput {
	return o.ApplyT(func(v *SqlTrigger) pulumi.StringOutput { return v.Operation }).(pulumi.StringOutput)
}

// Type of the Trigger. Possible values are `Pre` and `Post`.
func (o SqlTriggerOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v *SqlTrigger) pulumi.StringOutput { return v.Type }).(pulumi.StringOutput)
}

type SqlTriggerArrayOutput struct{ *pulumi.OutputState }

func (SqlTriggerArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SqlTrigger)(nil)).Elem()
}

func (o SqlTriggerArrayOutput) ToSqlTriggerArrayOutput() SqlTriggerArrayOutput {
	return o
}

func (o SqlTriggerArrayOutput) ToSqlTriggerArrayOutputWithContext(ctx context.Context) SqlTriggerArrayOutput {
	return o
}

func (o SqlTriggerArrayOutput) Index(i pulumi.IntInput) SqlTriggerOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *SqlTrigger {
		return vs[0].([]*SqlTrigger)[vs[1].(int)]
	}).(SqlTriggerOutput)
}

type SqlTriggerMapOutput struct{ *pulumi.OutputState }

func (SqlTriggerMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SqlTrigger)(nil)).Elem()
}

func (o SqlTriggerMapOutput) ToSqlTriggerMapOutput() SqlTriggerMapOutput {
	return o
}

func (o SqlTriggerMapOutput) ToSqlTriggerMapOutputWithContext(ctx context.Context) SqlTriggerMapOutput {
	return o
}

func (o SqlTriggerMapOutput) MapIndex(k pulumi.StringInput) SqlTriggerOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *SqlTrigger {
		return vs[0].(map[string]*SqlTrigger)[vs[1].(string)]
	}).(SqlTriggerOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SqlTriggerInput)(nil)).Elem(), &SqlTrigger{})
	pulumi.RegisterInputType(reflect.TypeOf((*SqlTriggerArrayInput)(nil)).Elem(), SqlTriggerArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SqlTriggerMapInput)(nil)).Elem(), SqlTriggerMap{})
	pulumi.RegisterOutputType(SqlTriggerOutput{})
	pulumi.RegisterOutputType(SqlTriggerArrayOutput{})
	pulumi.RegisterOutputType(SqlTriggerMapOutput{})
}
