// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package cosmosdb

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-azure/sdk/v6/go/azure/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages an SQL Trigger.
//
// ## Import
//
// SQL Triggers can be imported using the `resource id`, e.g.
//
// ```sh
// $ pulumi import azure:cosmosdb/sqlTrigger:SqlTrigger example /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/group1/providers/Microsoft.DocumentDB/databaseAccounts/account1/sqlDatabases/database1/containers/container1/triggers/trigger1
// ```
type SqlTrigger struct {
	pulumi.CustomResourceState

	// Body of the Trigger.
	Body pulumi.StringOutput `pulumi:"body"`
	// The id of the Cosmos DB SQL Container to create the SQL Trigger within. Changing this forces a new SQL Trigger to be created.
	ContainerId pulumi.StringOutput `pulumi:"containerId"`
	// The name which should be used for this SQL Trigger. Changing this forces a new SQL Trigger to be created.
	Name pulumi.StringOutput `pulumi:"name"`
	// The operation the trigger is associated with. Possible values are `All`, `Create`, `Update`, `Delete` and `Replace`.
	Operation pulumi.StringOutput `pulumi:"operation"`
	// Type of the Trigger. Possible values are `Pre` and `Post`.
	Type pulumi.StringOutput `pulumi:"type"`
}

// NewSqlTrigger registers a new resource with the given unique name, arguments, and options.
func NewSqlTrigger(ctx *pulumi.Context,
	name string, args *SqlTriggerArgs, opts ...pulumi.ResourceOption) (*SqlTrigger, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Body == nil {
		return nil, errors.New("invalid value for required argument 'Body'")
	}
	if args.ContainerId == nil {
		return nil, errors.New("invalid value for required argument 'ContainerId'")
	}
	if args.Operation == nil {
		return nil, errors.New("invalid value for required argument 'Operation'")
	}
	if args.Type == nil {
		return nil, errors.New("invalid value for required argument 'Type'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource SqlTrigger
	err := ctx.RegisterResource("azure:cosmosdb/sqlTrigger:SqlTrigger", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSqlTrigger gets an existing SqlTrigger resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSqlTrigger(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SqlTriggerState, opts ...pulumi.ResourceOption) (*SqlTrigger, error) {
	var resource SqlTrigger
	err := ctx.ReadResource("azure:cosmosdb/sqlTrigger:SqlTrigger", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering SqlTrigger resources.
type sqlTriggerState struct {
	// Body of the Trigger.
	Body *string `pulumi:"body"`
	// The id of the Cosmos DB SQL Container to create the SQL Trigger within. Changing this forces a new SQL Trigger to be created.
	ContainerId *string `pulumi:"containerId"`
	// The name which should be used for this SQL Trigger. Changing this forces a new SQL Trigger to be created.
	Name *string `pulumi:"name"`
	// The operation the trigger is associated with. Possible values are `All`, `Create`, `Update`, `Delete` and `Replace`.
	Operation *string `pulumi:"operation"`
	// Type of the Trigger. Possible values are `Pre` and `Post`.
	Type *string `pulumi:"type"`
}

type SqlTriggerState struct {
	// Body of the Trigger.
	Body pulumi.StringPtrInput
	// The id of the Cosmos DB SQL Container to create the SQL Trigger within. Changing this forces a new SQL Trigger to be created.
	ContainerId pulumi.StringPtrInput
	// The name which should be used for this SQL Trigger. Changing this forces a new SQL Trigger to be created.
	Name pulumi.StringPtrInput
	// The operation the trigger is associated with. Possible values are `All`, `Create`, `Update`, `Delete` and `Replace`.
	Operation pulumi.StringPtrInput
	// Type of the Trigger. Possible values are `Pre` and `Post`.
	Type pulumi.StringPtrInput
}

func (SqlTriggerState) ElementType() reflect.Type {
	return reflect.TypeOf((*sqlTriggerState)(nil)).Elem()
}

type sqlTriggerArgs struct {
	// Body of the Trigger.
	Body string `pulumi:"body"`
	// The id of the Cosmos DB SQL Container to create the SQL Trigger within. Changing this forces a new SQL Trigger to be created.
	ContainerId string `pulumi:"containerId"`
	// The name which should be used for this SQL Trigger. Changing this forces a new SQL Trigger to be created.
	Name *string `pulumi:"name"`
	// The operation the trigger is associated with. Possible values are `All`, `Create`, `Update`, `Delete` and `Replace`.
	Operation string `pulumi:"operation"`
	// Type of the Trigger. Possible values are `Pre` and `Post`.
	Type string `pulumi:"type"`
}

// The set of arguments for constructing a SqlTrigger resource.
type SqlTriggerArgs struct {
	// Body of the Trigger.
	Body pulumi.StringInput
	// The id of the Cosmos DB SQL Container to create the SQL Trigger within. Changing this forces a new SQL Trigger to be created.
	ContainerId pulumi.StringInput
	// The name which should be used for this SQL Trigger. Changing this forces a new SQL Trigger to be created.
	Name pulumi.StringPtrInput
	// The operation the trigger is associated with. Possible values are `All`, `Create`, `Update`, `Delete` and `Replace`.
	Operation pulumi.StringInput
	// Type of the Trigger. Possible values are `Pre` and `Post`.
	Type pulumi.StringInput
}

func (SqlTriggerArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*sqlTriggerArgs)(nil)).Elem()
}

type SqlTriggerInput interface {
	pulumi.Input

	ToSqlTriggerOutput() SqlTriggerOutput
	ToSqlTriggerOutputWithContext(ctx context.Context) SqlTriggerOutput
}

func (*SqlTrigger) ElementType() reflect.Type {
	return reflect.TypeOf((**SqlTrigger)(nil)).Elem()
}

func (i *SqlTrigger) ToSqlTriggerOutput() SqlTriggerOutput {
	return i.ToSqlTriggerOutputWithContext(context.Background())
}

func (i *SqlTrigger) ToSqlTriggerOutputWithContext(ctx context.Context) SqlTriggerOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SqlTriggerOutput)
}

// SqlTriggerArrayInput is an input type that accepts SqlTriggerArray and SqlTriggerArrayOutput values.
// You can construct a concrete instance of `SqlTriggerArrayInput` via:
//
//	SqlTriggerArray{ SqlTriggerArgs{...} }
type SqlTriggerArrayInput interface {
	pulumi.Input

	ToSqlTriggerArrayOutput() SqlTriggerArrayOutput
	ToSqlTriggerArrayOutputWithContext(context.Context) SqlTriggerArrayOutput
}

type SqlTriggerArray []SqlTriggerInput

func (SqlTriggerArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SqlTrigger)(nil)).Elem()
}

func (i SqlTriggerArray) ToSqlTriggerArrayOutput() SqlTriggerArrayOutput {
	return i.ToSqlTriggerArrayOutputWithContext(context.Background())
}

func (i SqlTriggerArray) ToSqlTriggerArrayOutputWithContext(ctx context.Context) SqlTriggerArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SqlTriggerArrayOutput)
}

// SqlTriggerMapInput is an input type that accepts SqlTriggerMap and SqlTriggerMapOutput values.
// You can construct a concrete instance of `SqlTriggerMapInput` via:
//
//	SqlTriggerMap{ "key": SqlTriggerArgs{...} }
type SqlTriggerMapInput interface {
	pulumi.Input

	ToSqlTriggerMapOutput() SqlTriggerMapOutput
	ToSqlTriggerMapOutputWithContext(context.Context) SqlTriggerMapOutput
}

type SqlTriggerMap map[string]SqlTriggerInput

func (SqlTriggerMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SqlTrigger)(nil)).Elem()
}

func (i SqlTriggerMap) ToSqlTriggerMapOutput() SqlTriggerMapOutput {
	return i.ToSqlTriggerMapOutputWithContext(context.Background())
}

func (i SqlTriggerMap) ToSqlTriggerMapOutputWithContext(ctx context.Context) SqlTriggerMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SqlTriggerMapOutput)
}

type SqlTriggerOutput struct{ *pulumi.OutputState }

func (SqlTriggerOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SqlTrigger)(nil)).Elem()
}

func (o SqlTriggerOutput) ToSqlTriggerOutput() SqlTriggerOutput {
	return o
}

func (o SqlTriggerOutput) ToSqlTriggerOutputWithContext(ctx context.Context) SqlTriggerOutput {
	return o
}

// Body of the Trigger.
func (o SqlTriggerOutput) Body() pulumi.StringOutput {
	return o.ApplyT(func(v *SqlTrigger) pulumi.StringOutput { return v.Body }).(pulumi.StringOutput)
}

// The id of the Cosmos DB SQL Container to create the SQL Trigger within. Changing this forces a new SQL Trigger to be created.
func (o SqlTriggerOutput) ContainerId() pulumi.StringOutput {
	return o.ApplyT(func(v *SqlTrigger) pulumi.StringOutput { return v.ContainerId }).(pulumi.StringOutput)
}

// The name which should be used for this SQL Trigger. Changing this forces a new SQL Trigger to be created.
func (o SqlTriggerOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *SqlTrigger) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The operation the trigger is associated with. Possible values are `All`, `Create`, `Update`, `Delete` and `Replace`.
func (o SqlTriggerOutput) Operation() pulumi.StringOutput {
	return o.ApplyT(func(v *SqlTrigger) pulumi.StringOutput { return v.Operation }).(pulumi.StringOutput)
}

// Type of the Trigger. Possible values are `Pre` and `Post`.
func (o SqlTriggerOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v *SqlTrigger) pulumi.StringOutput { return v.Type }).(pulumi.StringOutput)
}

type SqlTriggerArrayOutput struct{ *pulumi.OutputState }

func (SqlTriggerArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SqlTrigger)(nil)).Elem()
}

func (o SqlTriggerArrayOutput) ToSqlTriggerArrayOutput() SqlTriggerArrayOutput {
	return o
}

func (o SqlTriggerArrayOutput) ToSqlTriggerArrayOutputWithContext(ctx context.Context) SqlTriggerArrayOutput {
	return o
}

func (o SqlTriggerArrayOutput) Index(i pulumi.IntInput) SqlTriggerOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *SqlTrigger {
		return vs[0].([]*SqlTrigger)[vs[1].(int)]
	}).(SqlTriggerOutput)
}

type SqlTriggerMapOutput struct{ *pulumi.OutputState }

func (SqlTriggerMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SqlTrigger)(nil)).Elem()
}

func (o SqlTriggerMapOutput) ToSqlTriggerMapOutput() SqlTriggerMapOutput {
	return o
}

func (o SqlTriggerMapOutput) ToSqlTriggerMapOutputWithContext(ctx context.Context) SqlTriggerMapOutput {
	return o
}

func (o SqlTriggerMapOutput) MapIndex(k pulumi.StringInput) SqlTriggerOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *SqlTrigger {
		return vs[0].(map[string]*SqlTrigger)[vs[1].(string)]
	}).(SqlTriggerOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SqlTriggerInput)(nil)).Elem(), &SqlTrigger{})
	pulumi.RegisterInputType(reflect.TypeOf((*SqlTriggerArrayInput)(nil)).Elem(), SqlTriggerArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SqlTriggerMapInput)(nil)).Elem(), SqlTriggerMap{})
	pulumi.RegisterOutputType(SqlTriggerOutput{})
	pulumi.RegisterOutputType(SqlTriggerArrayOutput{})
	pulumi.RegisterOutputType(SqlTriggerMapOutput{})
}
