// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package keyvault

import (
	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/go/pulumi"
)

// Manages a Key Vault Access Policy.
// 
// ~> **NOTE:** It's possible to define Key Vault Access Policies both within [the `azurerm_key_vault` resource](key_vault.html) via the `access_policy` block and by using [the `azurerm_key_vault_access_policy` resource](key_vault_access_policy.html). However it's not possible to use both methods to manage Access Policies within a KeyVault, since there'll be conflicts.
// 
// -> **NOTE:** Azure permits a maximum of 16 Access Policies per Key Vault - [more information can be found in this document](https://docs.microsoft.com/en-us/azure/key-vault/key-vault-secure-your-key-vault#data-plane-access-control).
type AccessPolicy struct {
	s *pulumi.ResourceState
}

// NewAccessPolicy registers a new resource with the given unique name, arguments, and options.
func NewAccessPolicy(ctx *pulumi.Context,
	name string, args *AccessPolicyArgs, opts ...pulumi.ResourceOpt) (*AccessPolicy, error) {
	if args == nil || args.KeyPermissions == nil {
		return nil, errors.New("missing required argument 'KeyPermissions'")
	}
	if args == nil || args.ObjectId == nil {
		return nil, errors.New("missing required argument 'ObjectId'")
	}
	if args == nil || args.ResourceGroupName == nil {
		return nil, errors.New("missing required argument 'ResourceGroupName'")
	}
	if args == nil || args.SecretPermissions == nil {
		return nil, errors.New("missing required argument 'SecretPermissions'")
	}
	if args == nil || args.TenantId == nil {
		return nil, errors.New("missing required argument 'TenantId'")
	}
	if args == nil || args.VaultName == nil {
		return nil, errors.New("missing required argument 'VaultName'")
	}
	inputs := make(map[string]interface{})
	if args == nil {
		inputs["applicationId"] = nil
		inputs["certificatePermissions"] = nil
		inputs["keyPermissions"] = nil
		inputs["objectId"] = nil
		inputs["resourceGroupName"] = nil
		inputs["secretPermissions"] = nil
		inputs["tenantId"] = nil
		inputs["vaultName"] = nil
	} else {
		inputs["applicationId"] = args.ApplicationId
		inputs["certificatePermissions"] = args.CertificatePermissions
		inputs["keyPermissions"] = args.KeyPermissions
		inputs["objectId"] = args.ObjectId
		inputs["resourceGroupName"] = args.ResourceGroupName
		inputs["secretPermissions"] = args.SecretPermissions
		inputs["tenantId"] = args.TenantId
		inputs["vaultName"] = args.VaultName
	}
	s, err := ctx.RegisterResource("azure:keyvault/accessPolicy:AccessPolicy", name, true, inputs, opts...)
	if err != nil {
		return nil, err
	}
	return &AccessPolicy{s: s}, nil
}

// GetAccessPolicy gets an existing AccessPolicy resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetAccessPolicy(ctx *pulumi.Context,
	name string, id pulumi.ID, state *AccessPolicyState, opts ...pulumi.ResourceOpt) (*AccessPolicy, error) {
	inputs := make(map[string]interface{})
	if state != nil {
		inputs["applicationId"] = state.ApplicationId
		inputs["certificatePermissions"] = state.CertificatePermissions
		inputs["keyPermissions"] = state.KeyPermissions
		inputs["objectId"] = state.ObjectId
		inputs["resourceGroupName"] = state.ResourceGroupName
		inputs["secretPermissions"] = state.SecretPermissions
		inputs["tenantId"] = state.TenantId
		inputs["vaultName"] = state.VaultName
	}
	s, err := ctx.ReadResource("azure:keyvault/accessPolicy:AccessPolicy", name, id, inputs, opts...)
	if err != nil {
		return nil, err
	}
	return &AccessPolicy{s: s}, nil
}

// URN is this resource's unique name assigned by Pulumi.
func (r *AccessPolicy) URN() *pulumi.URNOutput {
	return r.s.URN
}

// ID is this resource's unique identifier assigned by its provider.
func (r *AccessPolicy) ID() *pulumi.IDOutput {
	return r.s.ID
}

// The object ID of an Application in Azure Active Directory.
func (r *AccessPolicy) ApplicationId() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["applicationId"])
}

// List of certificate permissions, must be one or more from
// the following: `create`, `delete`, `deleteissuers`, `get`, `getissuers`, `import`, `list`, `listissuers`,
// `managecontacts`, `manageissuers`, `purge`, `recover`, `setissuers` and `update`.
func (r *AccessPolicy) CertificatePermissions() *pulumi.ArrayOutput {
	return (*pulumi.ArrayOutput)(r.s.State["certificatePermissions"])
}

// List of key permissions, must be one or more from
// the following: `backup`, `create`, `decrypt`, `delete`, `encrypt`, `get`, `import`, `list`, `purge`,
// `recover`, `restore`, `sign`, `unwrapKey`, `update`, `verify` and `wrapKey`.
func (r *AccessPolicy) KeyPermissions() *pulumi.ArrayOutput {
	return (*pulumi.ArrayOutput)(r.s.State["keyPermissions"])
}

// The object ID of a user, service principal or security
// group in the Azure Active Directory tenant for the vault. The object ID must
// be unique for the list of access policies. Changing this forces a new resource
// to be created.
func (r *AccessPolicy) ObjectId() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["objectId"])
}

// The name of the resource group in which to
// create the namespace. Changing this forces a new resource to be created.
func (r *AccessPolicy) ResourceGroupName() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["resourceGroupName"])
}

// List of secret permissions, must be one or more
// from the following: `backup`, `delete`, `get`, `list`, `purge`, `recover`, `restore` and `set`.
func (r *AccessPolicy) SecretPermissions() *pulumi.ArrayOutput {
	return (*pulumi.ArrayOutput)(r.s.State["secretPermissions"])
}

// The Azure Active Directory tenant ID that should be used
// for authenticating requests to the key vault. Changing this forces a new resource
// to be created.
func (r *AccessPolicy) TenantId() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["tenantId"])
}

// Specifies the name of the Key Vault resource. Changing this
// forces a new resource to be created.
func (r *AccessPolicy) VaultName() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["vaultName"])
}

// Input properties used for looking up and filtering AccessPolicy resources.
type AccessPolicyState struct {
	// The object ID of an Application in Azure Active Directory.
	ApplicationId interface{}
	// List of certificate permissions, must be one or more from
	// the following: `create`, `delete`, `deleteissuers`, `get`, `getissuers`, `import`, `list`, `listissuers`,
	// `managecontacts`, `manageissuers`, `purge`, `recover`, `setissuers` and `update`.
	CertificatePermissions interface{}
	// List of key permissions, must be one or more from
	// the following: `backup`, `create`, `decrypt`, `delete`, `encrypt`, `get`, `import`, `list`, `purge`,
	// `recover`, `restore`, `sign`, `unwrapKey`, `update`, `verify` and `wrapKey`.
	KeyPermissions interface{}
	// The object ID of a user, service principal or security
	// group in the Azure Active Directory tenant for the vault. The object ID must
	// be unique for the list of access policies. Changing this forces a new resource
	// to be created.
	ObjectId interface{}
	// The name of the resource group in which to
	// create the namespace. Changing this forces a new resource to be created.
	ResourceGroupName interface{}
	// List of secret permissions, must be one or more
	// from the following: `backup`, `delete`, `get`, `list`, `purge`, `recover`, `restore` and `set`.
	SecretPermissions interface{}
	// The Azure Active Directory tenant ID that should be used
	// for authenticating requests to the key vault. Changing this forces a new resource
	// to be created.
	TenantId interface{}
	// Specifies the name of the Key Vault resource. Changing this
	// forces a new resource to be created.
	VaultName interface{}
}

// The set of arguments for constructing a AccessPolicy resource.
type AccessPolicyArgs struct {
	// The object ID of an Application in Azure Active Directory.
	ApplicationId interface{}
	// List of certificate permissions, must be one or more from
	// the following: `create`, `delete`, `deleteissuers`, `get`, `getissuers`, `import`, `list`, `listissuers`,
	// `managecontacts`, `manageissuers`, `purge`, `recover`, `setissuers` and `update`.
	CertificatePermissions interface{}
	// List of key permissions, must be one or more from
	// the following: `backup`, `create`, `decrypt`, `delete`, `encrypt`, `get`, `import`, `list`, `purge`,
	// `recover`, `restore`, `sign`, `unwrapKey`, `update`, `verify` and `wrapKey`.
	KeyPermissions interface{}
	// The object ID of a user, service principal or security
	// group in the Azure Active Directory tenant for the vault. The object ID must
	// be unique for the list of access policies. Changing this forces a new resource
	// to be created.
	ObjectId interface{}
	// The name of the resource group in which to
	// create the namespace. Changing this forces a new resource to be created.
	ResourceGroupName interface{}
	// List of secret permissions, must be one or more
	// from the following: `backup`, `delete`, `get`, `list`, `purge`, `recover`, `restore` and `set`.
	SecretPermissions interface{}
	// The Azure Active Directory tenant ID that should be used
	// for authenticating requests to the key vault. Changing this forces a new resource
	// to be created.
	TenantId interface{}
	// Specifies the name of the Key Vault resource. Changing this
	// forces a new resource to be created.
	VaultName interface{}
}
