// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package managedredis

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-azure/sdk/v6/go/azure/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages Managed Redis Geo-Replication by linking and unlinking databases in a geo-replication group.
//
// > **Note:** This resource manages the geo-replication group membership for Managed Redis databases. All databases to be linked must have `geoReplicationGroupName` provided with the same value. Linking will [discard cache data and cause temporary outage](https://learn.microsoft.com/azure/redis/how-to-active-geo-replication#add-an-existing-instance-to-an-active-geo-replication-group).
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-azure/sdk/v6/go/azure/core"
//	"github.com/pulumi/pulumi-azure/sdk/v6/go/azure/managedredis"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			example, err := core.NewResourceGroup(ctx, "example", &core.ResourceGroupArgs{
//				Name:     pulumi.String("example-managedredis"),
//				Location: pulumi.String("West Europe"),
//			})
//			if err != nil {
//				return err
//			}
//			amr1, err := managedredis.NewManagedRedis(ctx, "amr1", &managedredis.ManagedRedisArgs{
//				Name:              pulumi.String("example-managedredis-amr1"),
//				ResourceGroupName: example.Name,
//				Location:          pulumi.String("West Europe"),
//				SkuName:           pulumi.String("Balanced_B3"),
//				DefaultDatabase: &managedredis.ManagedRedisDefaultDatabaseArgs{
//					GeoReplicationGroupName: pulumi.String("example-geo-group"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			amr2, err := managedredis.NewManagedRedis(ctx, "amr2", &managedredis.ManagedRedisArgs{
//				Name:              pulumi.String("example-managedredis-amr2"),
//				ResourceGroupName: example.Name,
//				Location:          pulumi.String("Central US"),
//				SkuName:           pulumi.String("Balanced_B3"),
//				DefaultDatabase: &managedredis.ManagedRedisDefaultDatabaseArgs{
//					GeoReplicationGroupName: pulumi.String("example-geo-group"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = managedredis.NewGeoReplication(ctx, "example", &managedredis.GeoReplicationArgs{
//				ManagedRedisId: amr1.ID(),
//				LinkedManagedRedisIds: pulumi.StringArray{
//					amr2.ID(),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## API Providers
//
// <!-- This section is generated, changes will be overwritten -->
// This resource uses the following Azure API Providers:
//
// * `Microsoft.Cache` - 2025-07-01
//
// ## Import
//
// Managed Redis Database Geo-Replication can be imported using the Managed Redis `resource id`, e.g.
//
// ```sh
// $ pulumi import azure:managedredis/geoReplication:GeoReplication example /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/group1/providers/Microsoft.Cache/redisEnterprise/cluster1
// ```
type GeoReplication struct {
	pulumi.CustomResourceState

	// A set of other Managed Redis IDs to link together in the geo-replication group. The ID of this Managed Redis is always included by default and does not need to be provided here. Can contain up to 4 Managed Redis IDs, making up a group of 5 in total. All Managed Redis must have the same `geoReplicationGroupName` configured. Once linked, the geo-replication state of all Managed Redis will be updated.
	LinkedManagedRedisIds pulumi.StringArrayOutput `pulumi:"linkedManagedRedisIds"`
	// The ID of the Managed Redis through which geo-replication group will be managed. Linking is reciprocal, if A is linked to B, both A and B will have the same linking state. There is no need to have duplicate `managedredis.GeoReplication` resources for each. Changing this forces a new resource to be created.
	ManagedRedisId pulumi.StringOutput `pulumi:"managedRedisId"`
}

// NewGeoReplication registers a new resource with the given unique name, arguments, and options.
func NewGeoReplication(ctx *pulumi.Context,
	name string, args *GeoReplicationArgs, opts ...pulumi.ResourceOption) (*GeoReplication, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.LinkedManagedRedisIds == nil {
		return nil, errors.New("invalid value for required argument 'LinkedManagedRedisIds'")
	}
	if args.ManagedRedisId == nil {
		return nil, errors.New("invalid value for required argument 'ManagedRedisId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource GeoReplication
	err := ctx.RegisterResource("azure:managedredis/geoReplication:GeoReplication", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetGeoReplication gets an existing GeoReplication resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetGeoReplication(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *GeoReplicationState, opts ...pulumi.ResourceOption) (*GeoReplication, error) {
	var resource GeoReplication
	err := ctx.ReadResource("azure:managedredis/geoReplication:GeoReplication", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering GeoReplication resources.
type geoReplicationState struct {
	// A set of other Managed Redis IDs to link together in the geo-replication group. The ID of this Managed Redis is always included by default and does not need to be provided here. Can contain up to 4 Managed Redis IDs, making up a group of 5 in total. All Managed Redis must have the same `geoReplicationGroupName` configured. Once linked, the geo-replication state of all Managed Redis will be updated.
	LinkedManagedRedisIds []string `pulumi:"linkedManagedRedisIds"`
	// The ID of the Managed Redis through which geo-replication group will be managed. Linking is reciprocal, if A is linked to B, both A and B will have the same linking state. There is no need to have duplicate `managedredis.GeoReplication` resources for each. Changing this forces a new resource to be created.
	ManagedRedisId *string `pulumi:"managedRedisId"`
}

type GeoReplicationState struct {
	// A set of other Managed Redis IDs to link together in the geo-replication group. The ID of this Managed Redis is always included by default and does not need to be provided here. Can contain up to 4 Managed Redis IDs, making up a group of 5 in total. All Managed Redis must have the same `geoReplicationGroupName` configured. Once linked, the geo-replication state of all Managed Redis will be updated.
	LinkedManagedRedisIds pulumi.StringArrayInput
	// The ID of the Managed Redis through which geo-replication group will be managed. Linking is reciprocal, if A is linked to B, both A and B will have the same linking state. There is no need to have duplicate `managedredis.GeoReplication` resources for each. Changing this forces a new resource to be created.
	ManagedRedisId pulumi.StringPtrInput
}

func (GeoReplicationState) ElementType() reflect.Type {
	return reflect.TypeOf((*geoReplicationState)(nil)).Elem()
}

type geoReplicationArgs struct {
	// A set of other Managed Redis IDs to link together in the geo-replication group. The ID of this Managed Redis is always included by default and does not need to be provided here. Can contain up to 4 Managed Redis IDs, making up a group of 5 in total. All Managed Redis must have the same `geoReplicationGroupName` configured. Once linked, the geo-replication state of all Managed Redis will be updated.
	LinkedManagedRedisIds []string `pulumi:"linkedManagedRedisIds"`
	// The ID of the Managed Redis through which geo-replication group will be managed. Linking is reciprocal, if A is linked to B, both A and B will have the same linking state. There is no need to have duplicate `managedredis.GeoReplication` resources for each. Changing this forces a new resource to be created.
	ManagedRedisId string `pulumi:"managedRedisId"`
}

// The set of arguments for constructing a GeoReplication resource.
type GeoReplicationArgs struct {
	// A set of other Managed Redis IDs to link together in the geo-replication group. The ID of this Managed Redis is always included by default and does not need to be provided here. Can contain up to 4 Managed Redis IDs, making up a group of 5 in total. All Managed Redis must have the same `geoReplicationGroupName` configured. Once linked, the geo-replication state of all Managed Redis will be updated.
	LinkedManagedRedisIds pulumi.StringArrayInput
	// The ID of the Managed Redis through which geo-replication group will be managed. Linking is reciprocal, if A is linked to B, both A and B will have the same linking state. There is no need to have duplicate `managedredis.GeoReplication` resources for each. Changing this forces a new resource to be created.
	ManagedRedisId pulumi.StringInput
}

func (GeoReplicationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*geoReplicationArgs)(nil)).Elem()
}

type GeoReplicationInput interface {
	pulumi.Input

	ToGeoReplicationOutput() GeoReplicationOutput
	ToGeoReplicationOutputWithContext(ctx context.Context) GeoReplicationOutput
}

func (*GeoReplication) ElementType() reflect.Type {
	return reflect.TypeOf((**GeoReplication)(nil)).Elem()
}

func (i *GeoReplication) ToGeoReplicationOutput() GeoReplicationOutput {
	return i.ToGeoReplicationOutputWithContext(context.Background())
}

func (i *GeoReplication) ToGeoReplicationOutputWithContext(ctx context.Context) GeoReplicationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GeoReplicationOutput)
}

// GeoReplicationArrayInput is an input type that accepts GeoReplicationArray and GeoReplicationArrayOutput values.
// You can construct a concrete instance of `GeoReplicationArrayInput` via:
//
//	GeoReplicationArray{ GeoReplicationArgs{...} }
type GeoReplicationArrayInput interface {
	pulumi.Input

	ToGeoReplicationArrayOutput() GeoReplicationArrayOutput
	ToGeoReplicationArrayOutputWithContext(context.Context) GeoReplicationArrayOutput
}

type GeoReplicationArray []GeoReplicationInput

func (GeoReplicationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*GeoReplication)(nil)).Elem()
}

func (i GeoReplicationArray) ToGeoReplicationArrayOutput() GeoReplicationArrayOutput {
	return i.ToGeoReplicationArrayOutputWithContext(context.Background())
}

func (i GeoReplicationArray) ToGeoReplicationArrayOutputWithContext(ctx context.Context) GeoReplicationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GeoReplicationArrayOutput)
}

// GeoReplicationMapInput is an input type that accepts GeoReplicationMap and GeoReplicationMapOutput values.
// You can construct a concrete instance of `GeoReplicationMapInput` via:
//
//	GeoReplicationMap{ "key": GeoReplicationArgs{...} }
type GeoReplicationMapInput interface {
	pulumi.Input

	ToGeoReplicationMapOutput() GeoReplicationMapOutput
	ToGeoReplicationMapOutputWithContext(context.Context) GeoReplicationMapOutput
}

type GeoReplicationMap map[string]GeoReplicationInput

func (GeoReplicationMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*GeoReplication)(nil)).Elem()
}

func (i GeoReplicationMap) ToGeoReplicationMapOutput() GeoReplicationMapOutput {
	return i.ToGeoReplicationMapOutputWithContext(context.Background())
}

func (i GeoReplicationMap) ToGeoReplicationMapOutputWithContext(ctx context.Context) GeoReplicationMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GeoReplicationMapOutput)
}

type GeoReplicationOutput struct{ *pulumi.OutputState }

func (GeoReplicationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GeoReplication)(nil)).Elem()
}

func (o GeoReplicationOutput) ToGeoReplicationOutput() GeoReplicationOutput {
	return o
}

func (o GeoReplicationOutput) ToGeoReplicationOutputWithContext(ctx context.Context) GeoReplicationOutput {
	return o
}

// A set of other Managed Redis IDs to link together in the geo-replication group. The ID of this Managed Redis is always included by default and does not need to be provided here. Can contain up to 4 Managed Redis IDs, making up a group of 5 in total. All Managed Redis must have the same `geoReplicationGroupName` configured. Once linked, the geo-replication state of all Managed Redis will be updated.
func (o GeoReplicationOutput) LinkedManagedRedisIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *GeoReplication) pulumi.StringArrayOutput { return v.LinkedManagedRedisIds }).(pulumi.StringArrayOutput)
}

// The ID of the Managed Redis through which geo-replication group will be managed. Linking is reciprocal, if A is linked to B, both A and B will have the same linking state. There is no need to have duplicate `managedredis.GeoReplication` resources for each. Changing this forces a new resource to be created.
func (o GeoReplicationOutput) ManagedRedisId() pulumi.StringOutput {
	return o.ApplyT(func(v *GeoReplication) pulumi.StringOutput { return v.ManagedRedisId }).(pulumi.StringOutput)
}

type GeoReplicationArrayOutput struct{ *pulumi.OutputState }

func (GeoReplicationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*GeoReplication)(nil)).Elem()
}

func (o GeoReplicationArrayOutput) ToGeoReplicationArrayOutput() GeoReplicationArrayOutput {
	return o
}

func (o GeoReplicationArrayOutput) ToGeoReplicationArrayOutputWithContext(ctx context.Context) GeoReplicationArrayOutput {
	return o
}

func (o GeoReplicationArrayOutput) Index(i pulumi.IntInput) GeoReplicationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *GeoReplication {
		return vs[0].([]*GeoReplication)[vs[1].(int)]
	}).(GeoReplicationOutput)
}

type GeoReplicationMapOutput struct{ *pulumi.OutputState }

func (GeoReplicationMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*GeoReplication)(nil)).Elem()
}

func (o GeoReplicationMapOutput) ToGeoReplicationMapOutput() GeoReplicationMapOutput {
	return o
}

func (o GeoReplicationMapOutput) ToGeoReplicationMapOutputWithContext(ctx context.Context) GeoReplicationMapOutput {
	return o
}

func (o GeoReplicationMapOutput) MapIndex(k pulumi.StringInput) GeoReplicationOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *GeoReplication {
		return vs[0].(map[string]*GeoReplication)[vs[1].(string)]
	}).(GeoReplicationOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*GeoReplicationInput)(nil)).Elem(), &GeoReplication{})
	pulumi.RegisterInputType(reflect.TypeOf((*GeoReplicationArrayInput)(nil)).Elem(), GeoReplicationArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GeoReplicationMapInput)(nil)).Elem(), GeoReplicationMap{})
	pulumi.RegisterOutputType(GeoReplicationOutput{})
	pulumi.RegisterOutputType(GeoReplicationArrayOutput{})
	pulumi.RegisterOutputType(GeoReplicationMapOutput{})
}
