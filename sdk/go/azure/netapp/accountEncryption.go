// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package netapp

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-azure/sdk/v6/go/azure/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages a NetApp Account Encryption Resource.
//
// For more information about Azure NetApp Files Customer-Managed Keys feature, please refer to [Configure customer-managed keys for Azure NetApp Files volume encryption](https://learn.microsoft.com/en-us/azure/azure-netapp-files/configure-customer-managed-keys)
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-azure/sdk/v6/go/azure/authorization"
//	"github.com/pulumi/pulumi-azure/sdk/v6/go/azure/core"
//	"github.com/pulumi/pulumi-azure/sdk/v6/go/azure/keyvault"
//	"github.com/pulumi/pulumi-azure/sdk/v6/go/azure/netapp"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			example, err := core.NewResourceGroup(ctx, "example", &core.ResourceGroupArgs{
//				Name:     pulumi.String("example-resources"),
//				Location: pulumi.String("West Europe"),
//			})
//			if err != nil {
//				return err
//			}
//			current, err := core.GetClientConfig(ctx, map[string]interface{}{}, nil)
//			if err != nil {
//				return err
//			}
//			exampleUserAssignedIdentity, err := authorization.NewUserAssignedIdentity(ctx, "example", &authorization.UserAssignedIdentityArgs{
//				Name:              pulumi.String("anf-user-assigned-identity"),
//				Location:          example.Location,
//				ResourceGroupName: example.Name,
//			})
//			if err != nil {
//				return err
//			}
//			exampleKeyVault, err := keyvault.NewKeyVault(ctx, "example", &keyvault.KeyVaultArgs{
//				Name:                         pulumi.String("anfcmkakv"),
//				Location:                     example.Location,
//				ResourceGroupName:            example.Name,
//				EnabledForDiskEncryption:     pulumi.Bool(true),
//				EnabledForDeployment:         pulumi.Bool(true),
//				EnabledForTemplateDeployment: pulumi.Bool(true),
//				PurgeProtectionEnabled:       pulumi.Bool(true),
//				TenantId:                     pulumi.String("00000000-0000-0000-0000-000000000000"),
//				SkuName:                      pulumi.String("standard"),
//				AccessPolicies: keyvault.KeyVaultAccessPolicyArray{
//					&keyvault.KeyVaultAccessPolicyArgs{
//						TenantId: pulumi.String("00000000-0000-0000-0000-000000000000"),
//						ObjectId: pulumi.String(current.ObjectId),
//						KeyPermissions: pulumi.StringArray{
//							pulumi.String("Get"),
//							pulumi.String("Create"),
//							pulumi.String("Delete"),
//							pulumi.String("WrapKey"),
//							pulumi.String("UnwrapKey"),
//							pulumi.String("GetRotationPolicy"),
//							pulumi.String("SetRotationPolicy"),
//						},
//					},
//					&keyvault.KeyVaultAccessPolicyArgs{
//						TenantId: pulumi.String("00000000-0000-0000-0000-000000000000"),
//						ObjectId: exampleUserAssignedIdentity.PrincipalId,
//						KeyPermissions: pulumi.StringArray{
//							pulumi.String("Get"),
//							pulumi.String("Encrypt"),
//							pulumi.String("Decrypt"),
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			exampleKey, err := keyvault.NewKey(ctx, "example", &keyvault.KeyArgs{
//				Name:       pulumi.String("anfencryptionkey"),
//				KeyVaultId: exampleKeyVault.ID(),
//				KeyType:    pulumi.String("RSA"),
//				KeySize:    pulumi.Int(2048),
//				KeyOpts: pulumi.StringArray{
//					pulumi.String("decrypt"),
//					pulumi.String("encrypt"),
//					pulumi.String("sign"),
//					pulumi.String("unwrapKey"),
//					pulumi.String("verify"),
//					pulumi.String("wrapKey"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			exampleAccount, err := netapp.NewAccount(ctx, "example", &netapp.AccountArgs{
//				Name:              pulumi.String("netappaccount"),
//				Location:          example.Location,
//				ResourceGroupName: example.Name,
//				Identity: &netapp.AccountIdentityArgs{
//					Type: pulumi.String("UserAssigned"),
//					IdentityIds: pulumi.StringArray{
//						exampleUserAssignedIdentity.ID(),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = netapp.NewAccountEncryption(ctx, "example", &netapp.AccountEncryptionArgs{
//				NetappAccountId:        exampleAccount.ID(),
//				UserAssignedIdentityId: exampleUserAssignedIdentity.ID(),
//				EncryptionKey:          exampleKey.VersionlessId,
//				FederatedClientId:      exampleUserAssignedIdentity.ClientId,
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Cross-Tenant Usage
//
// For scenarios where the key vault is in a different Entra ID tenant:
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-azure/sdk/v6/go/azure/netapp"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := netapp.NewAccountEncryption(ctx, "cross_tenant", &netapp.AccountEncryptionArgs{
//				NetappAccountId:               pulumi.Any(example.Id),
//				UserAssignedIdentityId:        pulumi.Any(exampleAzurermUserAssignedIdentity.Id),
//				EncryptionKey:                 pulumi.String("https://keyvault-in-other-tenant.vault.azure.net/keys/encryption-key"),
//				FederatedClientId:             pulumi.String("12345678-1234-1234-1234-123456789012"),
//				CrossTenantKeyVaultResourceId: pulumi.String("/subscriptions/11111111-1111-1111-1111-111111111111/resourceGroups/remote-rg/providers/Microsoft.KeyVault/vaults/keyvault-in-other-tenant"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## API Providers
//
// <!-- This section is generated, changes will be overwritten -->
// This resource uses the following Azure API Providers:
//
// * `Microsoft.NetApp` - 2025-06-01
//
// ## Import
//
// Account Encryption Resources can be imported using the `resource id`, e.g.
//
// ```sh
// $ pulumi import azure:netapp/accountEncryption:AccountEncryption example /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/group1/providers/Microsoft.NetApp/netAppAccounts/account1
// ```
type AccountEncryption struct {
	pulumi.CustomResourceState

	// The full resource ID of the cross-tenant key vault. This is recommended when using `federatedClientId` for cross-tenant scenarios to ensure proper validation by Azure APIs.
	CrossTenantKeyVaultResourceId pulumi.StringPtrOutput `pulumi:"crossTenantKeyVaultResourceId"`
	// Specify the versionless ID of the encryption key.
	EncryptionKey pulumi.StringOutput `pulumi:"encryptionKey"`
	// The Client ID of the multi-tenant Entra ID application used to access cross-tenant key vaults. This is only required when accessing a key vault in a different tenant than the NetApp account.
	FederatedClientId pulumi.StringPtrOutput `pulumi:"federatedClientId"`
	// The ID of the NetApp account where volume under it will have customer managed keys-based encryption enabled.
	NetappAccountId pulumi.StringOutput `pulumi:"netappAccountId"`
	// The ID of the System Assigned Manged Identity. Conflicts with `userAssignedIdentityId`.
	SystemAssignedIdentityPrincipalId pulumi.StringPtrOutput `pulumi:"systemAssignedIdentityPrincipalId"`
	// The ID of the User Assigned Managed Identity. Conflicts with `systemAssignedIdentityPrincipalId`.
	UserAssignedIdentityId pulumi.StringPtrOutput `pulumi:"userAssignedIdentityId"`
}

// NewAccountEncryption registers a new resource with the given unique name, arguments, and options.
func NewAccountEncryption(ctx *pulumi.Context,
	name string, args *AccountEncryptionArgs, opts ...pulumi.ResourceOption) (*AccountEncryption, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.EncryptionKey == nil {
		return nil, errors.New("invalid value for required argument 'EncryptionKey'")
	}
	if args.NetappAccountId == nil {
		return nil, errors.New("invalid value for required argument 'NetappAccountId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource AccountEncryption
	err := ctx.RegisterResource("azure:netapp/accountEncryption:AccountEncryption", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetAccountEncryption gets an existing AccountEncryption resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetAccountEncryption(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *AccountEncryptionState, opts ...pulumi.ResourceOption) (*AccountEncryption, error) {
	var resource AccountEncryption
	err := ctx.ReadResource("azure:netapp/accountEncryption:AccountEncryption", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering AccountEncryption resources.
type accountEncryptionState struct {
	// The full resource ID of the cross-tenant key vault. This is recommended when using `federatedClientId` for cross-tenant scenarios to ensure proper validation by Azure APIs.
	CrossTenantKeyVaultResourceId *string `pulumi:"crossTenantKeyVaultResourceId"`
	// Specify the versionless ID of the encryption key.
	EncryptionKey *string `pulumi:"encryptionKey"`
	// The Client ID of the multi-tenant Entra ID application used to access cross-tenant key vaults. This is only required when accessing a key vault in a different tenant than the NetApp account.
	FederatedClientId *string `pulumi:"federatedClientId"`
	// The ID of the NetApp account where volume under it will have customer managed keys-based encryption enabled.
	NetappAccountId *string `pulumi:"netappAccountId"`
	// The ID of the System Assigned Manged Identity. Conflicts with `userAssignedIdentityId`.
	SystemAssignedIdentityPrincipalId *string `pulumi:"systemAssignedIdentityPrincipalId"`
	// The ID of the User Assigned Managed Identity. Conflicts with `systemAssignedIdentityPrincipalId`.
	UserAssignedIdentityId *string `pulumi:"userAssignedIdentityId"`
}

type AccountEncryptionState struct {
	// The full resource ID of the cross-tenant key vault. This is recommended when using `federatedClientId` for cross-tenant scenarios to ensure proper validation by Azure APIs.
	CrossTenantKeyVaultResourceId pulumi.StringPtrInput
	// Specify the versionless ID of the encryption key.
	EncryptionKey pulumi.StringPtrInput
	// The Client ID of the multi-tenant Entra ID application used to access cross-tenant key vaults. This is only required when accessing a key vault in a different tenant than the NetApp account.
	FederatedClientId pulumi.StringPtrInput
	// The ID of the NetApp account where volume under it will have customer managed keys-based encryption enabled.
	NetappAccountId pulumi.StringPtrInput
	// The ID of the System Assigned Manged Identity. Conflicts with `userAssignedIdentityId`.
	SystemAssignedIdentityPrincipalId pulumi.StringPtrInput
	// The ID of the User Assigned Managed Identity. Conflicts with `systemAssignedIdentityPrincipalId`.
	UserAssignedIdentityId pulumi.StringPtrInput
}

func (AccountEncryptionState) ElementType() reflect.Type {
	return reflect.TypeOf((*accountEncryptionState)(nil)).Elem()
}

type accountEncryptionArgs struct {
	// The full resource ID of the cross-tenant key vault. This is recommended when using `federatedClientId` for cross-tenant scenarios to ensure proper validation by Azure APIs.
	CrossTenantKeyVaultResourceId *string `pulumi:"crossTenantKeyVaultResourceId"`
	// Specify the versionless ID of the encryption key.
	EncryptionKey string `pulumi:"encryptionKey"`
	// The Client ID of the multi-tenant Entra ID application used to access cross-tenant key vaults. This is only required when accessing a key vault in a different tenant than the NetApp account.
	FederatedClientId *string `pulumi:"federatedClientId"`
	// The ID of the NetApp account where volume under it will have customer managed keys-based encryption enabled.
	NetappAccountId string `pulumi:"netappAccountId"`
	// The ID of the System Assigned Manged Identity. Conflicts with `userAssignedIdentityId`.
	SystemAssignedIdentityPrincipalId *string `pulumi:"systemAssignedIdentityPrincipalId"`
	// The ID of the User Assigned Managed Identity. Conflicts with `systemAssignedIdentityPrincipalId`.
	UserAssignedIdentityId *string `pulumi:"userAssignedIdentityId"`
}

// The set of arguments for constructing a AccountEncryption resource.
type AccountEncryptionArgs struct {
	// The full resource ID of the cross-tenant key vault. This is recommended when using `federatedClientId` for cross-tenant scenarios to ensure proper validation by Azure APIs.
	CrossTenantKeyVaultResourceId pulumi.StringPtrInput
	// Specify the versionless ID of the encryption key.
	EncryptionKey pulumi.StringInput
	// The Client ID of the multi-tenant Entra ID application used to access cross-tenant key vaults. This is only required when accessing a key vault in a different tenant than the NetApp account.
	FederatedClientId pulumi.StringPtrInput
	// The ID of the NetApp account where volume under it will have customer managed keys-based encryption enabled.
	NetappAccountId pulumi.StringInput
	// The ID of the System Assigned Manged Identity. Conflicts with `userAssignedIdentityId`.
	SystemAssignedIdentityPrincipalId pulumi.StringPtrInput
	// The ID of the User Assigned Managed Identity. Conflicts with `systemAssignedIdentityPrincipalId`.
	UserAssignedIdentityId pulumi.StringPtrInput
}

func (AccountEncryptionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*accountEncryptionArgs)(nil)).Elem()
}

type AccountEncryptionInput interface {
	pulumi.Input

	ToAccountEncryptionOutput() AccountEncryptionOutput
	ToAccountEncryptionOutputWithContext(ctx context.Context) AccountEncryptionOutput
}

func (*AccountEncryption) ElementType() reflect.Type {
	return reflect.TypeOf((**AccountEncryption)(nil)).Elem()
}

func (i *AccountEncryption) ToAccountEncryptionOutput() AccountEncryptionOutput {
	return i.ToAccountEncryptionOutputWithContext(context.Background())
}

func (i *AccountEncryption) ToAccountEncryptionOutputWithContext(ctx context.Context) AccountEncryptionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AccountEncryptionOutput)
}

// AccountEncryptionArrayInput is an input type that accepts AccountEncryptionArray and AccountEncryptionArrayOutput values.
// You can construct a concrete instance of `AccountEncryptionArrayInput` via:
//
//	AccountEncryptionArray{ AccountEncryptionArgs{...} }
type AccountEncryptionArrayInput interface {
	pulumi.Input

	ToAccountEncryptionArrayOutput() AccountEncryptionArrayOutput
	ToAccountEncryptionArrayOutputWithContext(context.Context) AccountEncryptionArrayOutput
}

type AccountEncryptionArray []AccountEncryptionInput

func (AccountEncryptionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AccountEncryption)(nil)).Elem()
}

func (i AccountEncryptionArray) ToAccountEncryptionArrayOutput() AccountEncryptionArrayOutput {
	return i.ToAccountEncryptionArrayOutputWithContext(context.Background())
}

func (i AccountEncryptionArray) ToAccountEncryptionArrayOutputWithContext(ctx context.Context) AccountEncryptionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AccountEncryptionArrayOutput)
}

// AccountEncryptionMapInput is an input type that accepts AccountEncryptionMap and AccountEncryptionMapOutput values.
// You can construct a concrete instance of `AccountEncryptionMapInput` via:
//
//	AccountEncryptionMap{ "key": AccountEncryptionArgs{...} }
type AccountEncryptionMapInput interface {
	pulumi.Input

	ToAccountEncryptionMapOutput() AccountEncryptionMapOutput
	ToAccountEncryptionMapOutputWithContext(context.Context) AccountEncryptionMapOutput
}

type AccountEncryptionMap map[string]AccountEncryptionInput

func (AccountEncryptionMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AccountEncryption)(nil)).Elem()
}

func (i AccountEncryptionMap) ToAccountEncryptionMapOutput() AccountEncryptionMapOutput {
	return i.ToAccountEncryptionMapOutputWithContext(context.Background())
}

func (i AccountEncryptionMap) ToAccountEncryptionMapOutputWithContext(ctx context.Context) AccountEncryptionMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AccountEncryptionMapOutput)
}

type AccountEncryptionOutput struct{ *pulumi.OutputState }

func (AccountEncryptionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AccountEncryption)(nil)).Elem()
}

func (o AccountEncryptionOutput) ToAccountEncryptionOutput() AccountEncryptionOutput {
	return o
}

func (o AccountEncryptionOutput) ToAccountEncryptionOutputWithContext(ctx context.Context) AccountEncryptionOutput {
	return o
}

// The full resource ID of the cross-tenant key vault. This is recommended when using `federatedClientId` for cross-tenant scenarios to ensure proper validation by Azure APIs.
func (o AccountEncryptionOutput) CrossTenantKeyVaultResourceId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AccountEncryption) pulumi.StringPtrOutput { return v.CrossTenantKeyVaultResourceId }).(pulumi.StringPtrOutput)
}

// Specify the versionless ID of the encryption key.
func (o AccountEncryptionOutput) EncryptionKey() pulumi.StringOutput {
	return o.ApplyT(func(v *AccountEncryption) pulumi.StringOutput { return v.EncryptionKey }).(pulumi.StringOutput)
}

// The Client ID of the multi-tenant Entra ID application used to access cross-tenant key vaults. This is only required when accessing a key vault in a different tenant than the NetApp account.
func (o AccountEncryptionOutput) FederatedClientId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AccountEncryption) pulumi.StringPtrOutput { return v.FederatedClientId }).(pulumi.StringPtrOutput)
}

// The ID of the NetApp account where volume under it will have customer managed keys-based encryption enabled.
func (o AccountEncryptionOutput) NetappAccountId() pulumi.StringOutput {
	return o.ApplyT(func(v *AccountEncryption) pulumi.StringOutput { return v.NetappAccountId }).(pulumi.StringOutput)
}

// The ID of the System Assigned Manged Identity. Conflicts with `userAssignedIdentityId`.
func (o AccountEncryptionOutput) SystemAssignedIdentityPrincipalId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AccountEncryption) pulumi.StringPtrOutput { return v.SystemAssignedIdentityPrincipalId }).(pulumi.StringPtrOutput)
}

// The ID of the User Assigned Managed Identity. Conflicts with `systemAssignedIdentityPrincipalId`.
func (o AccountEncryptionOutput) UserAssignedIdentityId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AccountEncryption) pulumi.StringPtrOutput { return v.UserAssignedIdentityId }).(pulumi.StringPtrOutput)
}

type AccountEncryptionArrayOutput struct{ *pulumi.OutputState }

func (AccountEncryptionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AccountEncryption)(nil)).Elem()
}

func (o AccountEncryptionArrayOutput) ToAccountEncryptionArrayOutput() AccountEncryptionArrayOutput {
	return o
}

func (o AccountEncryptionArrayOutput) ToAccountEncryptionArrayOutputWithContext(ctx context.Context) AccountEncryptionArrayOutput {
	return o
}

func (o AccountEncryptionArrayOutput) Index(i pulumi.IntInput) AccountEncryptionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *AccountEncryption {
		return vs[0].([]*AccountEncryption)[vs[1].(int)]
	}).(AccountEncryptionOutput)
}

type AccountEncryptionMapOutput struct{ *pulumi.OutputState }

func (AccountEncryptionMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AccountEncryption)(nil)).Elem()
}

func (o AccountEncryptionMapOutput) ToAccountEncryptionMapOutput() AccountEncryptionMapOutput {
	return o
}

func (o AccountEncryptionMapOutput) ToAccountEncryptionMapOutputWithContext(ctx context.Context) AccountEncryptionMapOutput {
	return o
}

func (o AccountEncryptionMapOutput) MapIndex(k pulumi.StringInput) AccountEncryptionOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *AccountEncryption {
		return vs[0].(map[string]*AccountEncryption)[vs[1].(string)]
	}).(AccountEncryptionOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AccountEncryptionInput)(nil)).Elem(), &AccountEncryption{})
	pulumi.RegisterInputType(reflect.TypeOf((*AccountEncryptionArrayInput)(nil)).Elem(), AccountEncryptionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AccountEncryptionMapInput)(nil)).Elem(), AccountEncryptionMap{})
	pulumi.RegisterOutputType(AccountEncryptionOutput{})
	pulumi.RegisterOutputType(AccountEncryptionArrayOutput{})
	pulumi.RegisterOutputType(AccountEncryptionMapOutput{})
}
