// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package mssql

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-azure/sdk/v5/go/azure/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages a Microsoft SQL Azure Managed Instance.
//
// > **Note:** All arguments including the administrator login and password will be stored in the raw state as plain-text. [Read more about sensitive data in state](https://www.terraform.io/docs/state/sensitive-data.html).
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-azure/sdk/v5/go/azure/core"
//	"github.com/pulumi/pulumi-azure/sdk/v5/go/azure/mssql"
//	"github.com/pulumi/pulumi-azure/sdk/v5/go/azure/network"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			exampleResourceGroup, err := core.NewResourceGroup(ctx, "exampleResourceGroup", &core.ResourceGroupArgs{
//				Location: pulumi.String("West Europe"),
//			})
//			if err != nil {
//				return err
//			}
//			exampleNetworkSecurityGroup, err := network.NewNetworkSecurityGroup(ctx, "exampleNetworkSecurityGroup", &network.NetworkSecurityGroupArgs{
//				Location:          exampleResourceGroup.Location,
//				ResourceGroupName: exampleResourceGroup.Name,
//			})
//			if err != nil {
//				return err
//			}
//			_, err = network.NewNetworkSecurityRule(ctx, "allowManagementInbound", &network.NetworkSecurityRuleArgs{
//				Priority:        pulumi.Int(106),
//				Direction:       pulumi.String("Inbound"),
//				Access:          pulumi.String("Allow"),
//				Protocol:        pulumi.String("Tcp"),
//				SourcePortRange: pulumi.String("*"),
//				DestinationPortRanges: pulumi.StringArray{
//					pulumi.String("9000"),
//					pulumi.String("9003"),
//					pulumi.String("1438"),
//					pulumi.String("1440"),
//					pulumi.String("1452"),
//				},
//				SourceAddressPrefix:      pulumi.String("*"),
//				DestinationAddressPrefix: pulumi.String("*"),
//				ResourceGroupName:        exampleResourceGroup.Name,
//				NetworkSecurityGroupName: exampleNetworkSecurityGroup.Name,
//			})
//			if err != nil {
//				return err
//			}
//			_, err = network.NewNetworkSecurityRule(ctx, "allowMisubnetInbound", &network.NetworkSecurityRuleArgs{
//				Priority:                 pulumi.Int(200),
//				Direction:                pulumi.String("Inbound"),
//				Access:                   pulumi.String("Allow"),
//				Protocol:                 pulumi.String("*"),
//				SourcePortRange:          pulumi.String("*"),
//				DestinationPortRange:     pulumi.String("*"),
//				SourceAddressPrefix:      pulumi.String("10.0.0.0/24"),
//				DestinationAddressPrefix: pulumi.String("*"),
//				ResourceGroupName:        exampleResourceGroup.Name,
//				NetworkSecurityGroupName: exampleNetworkSecurityGroup.Name,
//			})
//			if err != nil {
//				return err
//			}
//			_, err = network.NewNetworkSecurityRule(ctx, "allowHealthProbeInbound", &network.NetworkSecurityRuleArgs{
//				Priority:                 pulumi.Int(300),
//				Direction:                pulumi.String("Inbound"),
//				Access:                   pulumi.String("Allow"),
//				Protocol:                 pulumi.String("*"),
//				SourcePortRange:          pulumi.String("*"),
//				DestinationPortRange:     pulumi.String("*"),
//				SourceAddressPrefix:      pulumi.String("AzureLoadBalancer"),
//				DestinationAddressPrefix: pulumi.String("*"),
//				ResourceGroupName:        exampleResourceGroup.Name,
//				NetworkSecurityGroupName: exampleNetworkSecurityGroup.Name,
//			})
//			if err != nil {
//				return err
//			}
//			_, err = network.NewNetworkSecurityRule(ctx, "allowTdsInbound", &network.NetworkSecurityRuleArgs{
//				Priority:                 pulumi.Int(1000),
//				Direction:                pulumi.String("Inbound"),
//				Access:                   pulumi.String("Allow"),
//				Protocol:                 pulumi.String("Tcp"),
//				SourcePortRange:          pulumi.String("*"),
//				DestinationPortRange:     pulumi.String("1433"),
//				SourceAddressPrefix:      pulumi.String("VirtualNetwork"),
//				DestinationAddressPrefix: pulumi.String("*"),
//				ResourceGroupName:        exampleResourceGroup.Name,
//				NetworkSecurityGroupName: exampleNetworkSecurityGroup.Name,
//			})
//			if err != nil {
//				return err
//			}
//			_, err = network.NewNetworkSecurityRule(ctx, "denyAllInbound", &network.NetworkSecurityRuleArgs{
//				Priority:                 pulumi.Int(4096),
//				Direction:                pulumi.String("Inbound"),
//				Access:                   pulumi.String("Deny"),
//				Protocol:                 pulumi.String("*"),
//				SourcePortRange:          pulumi.String("*"),
//				DestinationPortRange:     pulumi.String("*"),
//				SourceAddressPrefix:      pulumi.String("*"),
//				DestinationAddressPrefix: pulumi.String("*"),
//				ResourceGroupName:        exampleResourceGroup.Name,
//				NetworkSecurityGroupName: exampleNetworkSecurityGroup.Name,
//			})
//			if err != nil {
//				return err
//			}
//			_, err = network.NewNetworkSecurityRule(ctx, "allowManagementOutbound", &network.NetworkSecurityRuleArgs{
//				Priority:        pulumi.Int(102),
//				Direction:       pulumi.String("Outbound"),
//				Access:          pulumi.String("Allow"),
//				Protocol:        pulumi.String("Tcp"),
//				SourcePortRange: pulumi.String("*"),
//				DestinationPortRanges: pulumi.StringArray{
//					pulumi.String("80"),
//					pulumi.String("443"),
//					pulumi.String("12000"),
//				},
//				SourceAddressPrefix:      pulumi.String("*"),
//				DestinationAddressPrefix: pulumi.String("*"),
//				ResourceGroupName:        exampleResourceGroup.Name,
//				NetworkSecurityGroupName: exampleNetworkSecurityGroup.Name,
//			})
//			if err != nil {
//				return err
//			}
//			_, err = network.NewNetworkSecurityRule(ctx, "allowMisubnetOutbound", &network.NetworkSecurityRuleArgs{
//				Priority:                 pulumi.Int(200),
//				Direction:                pulumi.String("Outbound"),
//				Access:                   pulumi.String("Allow"),
//				Protocol:                 pulumi.String("*"),
//				SourcePortRange:          pulumi.String("*"),
//				DestinationPortRange:     pulumi.String("*"),
//				SourceAddressPrefix:      pulumi.String("10.0.0.0/24"),
//				DestinationAddressPrefix: pulumi.String("*"),
//				ResourceGroupName:        exampleResourceGroup.Name,
//				NetworkSecurityGroupName: exampleNetworkSecurityGroup.Name,
//			})
//			if err != nil {
//				return err
//			}
//			_, err = network.NewNetworkSecurityRule(ctx, "denyAllOutbound", &network.NetworkSecurityRuleArgs{
//				Priority:                 pulumi.Int(4096),
//				Direction:                pulumi.String("Outbound"),
//				Access:                   pulumi.String("Deny"),
//				Protocol:                 pulumi.String("*"),
//				SourcePortRange:          pulumi.String("*"),
//				DestinationPortRange:     pulumi.String("*"),
//				SourceAddressPrefix:      pulumi.String("*"),
//				DestinationAddressPrefix: pulumi.String("*"),
//				ResourceGroupName:        exampleResourceGroup.Name,
//				NetworkSecurityGroupName: exampleNetworkSecurityGroup.Name,
//			})
//			if err != nil {
//				return err
//			}
//			exampleVirtualNetwork, err := network.NewVirtualNetwork(ctx, "exampleVirtualNetwork", &network.VirtualNetworkArgs{
//				ResourceGroupName: exampleResourceGroup.Name,
//				AddressSpaces: pulumi.StringArray{
//					pulumi.String("10.0.0.0/16"),
//				},
//				Location: exampleResourceGroup.Location,
//			})
//			if err != nil {
//				return err
//			}
//			exampleSubnet, err := network.NewSubnet(ctx, "exampleSubnet", &network.SubnetArgs{
//				ResourceGroupName:  exampleResourceGroup.Name,
//				VirtualNetworkName: exampleVirtualNetwork.Name,
//				AddressPrefixes: pulumi.StringArray{
//					pulumi.String("10.0.0.0/24"),
//				},
//				Delegations: network.SubnetDelegationArray{
//					&network.SubnetDelegationArgs{
//						Name: pulumi.String("managedinstancedelegation"),
//						ServiceDelegation: &network.SubnetDelegationServiceDelegationArgs{
//							Name: pulumi.String("Microsoft.Sql/managedInstances"),
//							Actions: pulumi.StringArray{
//								pulumi.String("Microsoft.Network/virtualNetworks/subnets/join/action"),
//								pulumi.String("Microsoft.Network/virtualNetworks/subnets/prepareNetworkPolicies/action"),
//								pulumi.String("Microsoft.Network/virtualNetworks/subnets/unprepareNetworkPolicies/action"),
//							},
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			exampleSubnetNetworkSecurityGroupAssociation, err := network.NewSubnetNetworkSecurityGroupAssociation(ctx, "exampleSubnetNetworkSecurityGroupAssociation", &network.SubnetNetworkSecurityGroupAssociationArgs{
//				SubnetId:               exampleSubnet.ID(),
//				NetworkSecurityGroupId: exampleNetworkSecurityGroup.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			exampleRouteTable, err := network.NewRouteTable(ctx, "exampleRouteTable", &network.RouteTableArgs{
//				Location:                   exampleResourceGroup.Location,
//				ResourceGroupName:          exampleResourceGroup.Name,
//				DisableBgpRoutePropagation: pulumi.Bool(false),
//			}, pulumi.DependsOn([]pulumi.Resource{
//				exampleSubnet,
//			}))
//			if err != nil {
//				return err
//			}
//			exampleSubnetRouteTableAssociation, err := network.NewSubnetRouteTableAssociation(ctx, "exampleSubnetRouteTableAssociation", &network.SubnetRouteTableAssociationArgs{
//				SubnetId:     exampleSubnet.ID(),
//				RouteTableId: exampleRouteTable.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = mssql.NewManagedInstance(ctx, "exampleManagedInstance", &mssql.ManagedInstanceArgs{
//				ResourceGroupName:          exampleResourceGroup.Name,
//				Location:                   exampleResourceGroup.Location,
//				LicenseType:                pulumi.String("BasePrice"),
//				SkuName:                    pulumi.String("GP_Gen5"),
//				StorageSizeInGb:            pulumi.Int(32),
//				SubnetId:                   exampleSubnet.ID(),
//				Vcores:                     pulumi.Int(4),
//				AdministratorLogin:         pulumi.String("mradministrator"),
//				AdministratorLoginPassword: pulumi.String("thisIsDog11"),
//			}, pulumi.DependsOn([]pulumi.Resource{
//				exampleSubnetNetworkSecurityGroupAssociation,
//				exampleSubnetRouteTableAssociation,
//			}))
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Microsoft SQL Managed Instances can be imported using the `resource id`, e.g.
//
// ```sh
//
//	$ pulumi import azure:mssql/managedInstance:ManagedInstance example /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/myresourcegroup/providers/Microsoft.Sql/managedInstances/myserver
//
// ```
type ManagedInstance struct {
	pulumi.CustomResourceState

	// The administrator login name for the new SQL Managed Instance. Changing this forces a new resource to be created.
	AdministratorLogin pulumi.StringOutput `pulumi:"administratorLogin"`
	// The password associated with the `administratorLogin` user. Needs to comply with Azure's [Password Policy](https://msdn.microsoft.com/library/ms161959.aspx)
	AdministratorLoginPassword pulumi.StringOutput `pulumi:"administratorLoginPassword"`
	// Specifies how the SQL Managed Instance will be collated. Default value is `SQL_Latin1_General_CP1_CI_AS`. Changing this forces a new resource to be created.
	Collation pulumi.StringPtrOutput `pulumi:"collation"`
	// The Dns Zone where the SQL Managed Instance is located.
	DnsZone pulumi.StringOutput `pulumi:"dnsZone"`
	// The ID of the SQL Managed Instance which will share the DNS zone. This is a prerequisite for creating an `sql.ManagedInstanceFailoverGroup`. Setting this after creation forces a new resource to be created.
	DnsZonePartnerId pulumi.StringPtrOutput `pulumi:"dnsZonePartnerId"`
	// The fully qualified domain name of the Azure Managed SQL Instance
	Fqdn pulumi.StringOutput `pulumi:"fqdn"`
	// An `identity` block as defined below.
	Identity ManagedInstanceIdentityPtrOutput `pulumi:"identity"`
	// What type of license the Managed Instance will use. Possible values are `LicenseIncluded` and `BasePrice`.
	LicenseType pulumi.StringOutput `pulumi:"licenseType"`
	// Specifies the supported Azure location where the resource exists. Changing this forces a new resource to be created.
	Location pulumi.StringOutput `pulumi:"location"`
	// The name of the Public Maintenance Configuration window to apply to the SQL Managed Instance. Valid values include `SQL_Default` or an Azure Location in the format `SQL_{Location}_MI_{Size}`(for example `SQL_EastUS_MI_1`). Defaults to `SQL_Default`.
	MaintenanceConfigurationName pulumi.StringPtrOutput `pulumi:"maintenanceConfigurationName"`
	// The Minimum TLS Version. Default value is `1.2` Valid values include `1.0`, `1.1`, `1.2`.
	MinimumTlsVersion pulumi.StringPtrOutput `pulumi:"minimumTlsVersion"`
	// The name of the SQL Managed Instance. This needs to be globally unique within Azure. Changing this forces a new resource to be created.
	Name pulumi.StringOutput `pulumi:"name"`
	// Specifies how the SQL Managed Instance will be accessed. Default value is `Default`. Valid values include `Default`, `Proxy`, and `Redirect`.
	ProxyOverride pulumi.StringPtrOutput `pulumi:"proxyOverride"`
	// Is the public data endpoint enabled? Default value is `false`.
	PublicDataEndpointEnabled pulumi.BoolPtrOutput `pulumi:"publicDataEndpointEnabled"`
	// The name of the resource group in which to create the SQL Managed Instance. Changing this forces a new resource to be created.
	ResourceGroupName pulumi.StringOutput `pulumi:"resourceGroupName"`
	// Specifies the SKU Name for the SQL Managed Instance. Valid values include `GP_Gen4`, `GP_Gen5`, `GP_Gen8IM`, `GP_Gen8IH`, `BC_Gen4`, `BC_Gen5`, `BC_Gen8IM` or `BC_Gen8IH`.
	SkuName pulumi.StringOutput `pulumi:"skuName"`
	// Specifies the storage account type used to store backups for this database. Changing this forces a new resource to be created. Possible values are `GRS`, `LRS` and `ZRS`. Defaults to `GRS`.
	StorageAccountType pulumi.StringPtrOutput `pulumi:"storageAccountType"`
	// Maximum storage space for the SQL Managed instance. This should be a multiple of 32 (GB).
	StorageSizeInGb pulumi.IntOutput `pulumi:"storageSizeInGb"`
	// The subnet resource id that the SQL Managed Instance will be associated with. Changing this forces a new resource to be created.
	SubnetId pulumi.StringOutput `pulumi:"subnetId"`
	// A mapping of tags to assign to the resource.
	Tags pulumi.StringMapOutput `pulumi:"tags"`
	// The TimeZone ID that the SQL Managed Instance will be operating in. Default value is `UTC`. Changing this forces a new resource to be created.
	TimezoneId pulumi.StringPtrOutput `pulumi:"timezoneId"`
	// Number of cores that should be assigned to the SQL Managed Instance. Values can be `8`, `16`, or `24` for Gen4 SKUs, or `4`, `6`, `8`, `10`, `12`, `16`, `20`, `24`, `32`, `40`, `48`, `56`, `64`, `80`, `96` or `128` for Gen5 SKUs.
	Vcores pulumi.IntOutput `pulumi:"vcores"`
}

// NewManagedInstance registers a new resource with the given unique name, arguments, and options.
func NewManagedInstance(ctx *pulumi.Context,
	name string, args *ManagedInstanceArgs, opts ...pulumi.ResourceOption) (*ManagedInstance, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.AdministratorLogin == nil {
		return nil, errors.New("invalid value for required argument 'AdministratorLogin'")
	}
	if args.AdministratorLoginPassword == nil {
		return nil, errors.New("invalid value for required argument 'AdministratorLoginPassword'")
	}
	if args.LicenseType == nil {
		return nil, errors.New("invalid value for required argument 'LicenseType'")
	}
	if args.ResourceGroupName == nil {
		return nil, errors.New("invalid value for required argument 'ResourceGroupName'")
	}
	if args.SkuName == nil {
		return nil, errors.New("invalid value for required argument 'SkuName'")
	}
	if args.StorageSizeInGb == nil {
		return nil, errors.New("invalid value for required argument 'StorageSizeInGb'")
	}
	if args.SubnetId == nil {
		return nil, errors.New("invalid value for required argument 'SubnetId'")
	}
	if args.Vcores == nil {
		return nil, errors.New("invalid value for required argument 'Vcores'")
	}
	if args.AdministratorLoginPassword != nil {
		args.AdministratorLoginPassword = pulumi.ToSecret(args.AdministratorLoginPassword).(pulumi.StringInput)
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"administratorLoginPassword",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ManagedInstance
	err := ctx.RegisterResource("azure:mssql/managedInstance:ManagedInstance", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetManagedInstance gets an existing ManagedInstance resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetManagedInstance(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ManagedInstanceState, opts ...pulumi.ResourceOption) (*ManagedInstance, error) {
	var resource ManagedInstance
	err := ctx.ReadResource("azure:mssql/managedInstance:ManagedInstance", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ManagedInstance resources.
type managedInstanceState struct {
	// The administrator login name for the new SQL Managed Instance. Changing this forces a new resource to be created.
	AdministratorLogin *string `pulumi:"administratorLogin"`
	// The password associated with the `administratorLogin` user. Needs to comply with Azure's [Password Policy](https://msdn.microsoft.com/library/ms161959.aspx)
	AdministratorLoginPassword *string `pulumi:"administratorLoginPassword"`
	// Specifies how the SQL Managed Instance will be collated. Default value is `SQL_Latin1_General_CP1_CI_AS`. Changing this forces a new resource to be created.
	Collation *string `pulumi:"collation"`
	// The Dns Zone where the SQL Managed Instance is located.
	DnsZone *string `pulumi:"dnsZone"`
	// The ID of the SQL Managed Instance which will share the DNS zone. This is a prerequisite for creating an `sql.ManagedInstanceFailoverGroup`. Setting this after creation forces a new resource to be created.
	DnsZonePartnerId *string `pulumi:"dnsZonePartnerId"`
	// The fully qualified domain name of the Azure Managed SQL Instance
	Fqdn *string `pulumi:"fqdn"`
	// An `identity` block as defined below.
	Identity *ManagedInstanceIdentity `pulumi:"identity"`
	// What type of license the Managed Instance will use. Possible values are `LicenseIncluded` and `BasePrice`.
	LicenseType *string `pulumi:"licenseType"`
	// Specifies the supported Azure location where the resource exists. Changing this forces a new resource to be created.
	Location *string `pulumi:"location"`
	// The name of the Public Maintenance Configuration window to apply to the SQL Managed Instance. Valid values include `SQL_Default` or an Azure Location in the format `SQL_{Location}_MI_{Size}`(for example `SQL_EastUS_MI_1`). Defaults to `SQL_Default`.
	MaintenanceConfigurationName *string `pulumi:"maintenanceConfigurationName"`
	// The Minimum TLS Version. Default value is `1.2` Valid values include `1.0`, `1.1`, `1.2`.
	MinimumTlsVersion *string `pulumi:"minimumTlsVersion"`
	// The name of the SQL Managed Instance. This needs to be globally unique within Azure. Changing this forces a new resource to be created.
	Name *string `pulumi:"name"`
	// Specifies how the SQL Managed Instance will be accessed. Default value is `Default`. Valid values include `Default`, `Proxy`, and `Redirect`.
	ProxyOverride *string `pulumi:"proxyOverride"`
	// Is the public data endpoint enabled? Default value is `false`.
	PublicDataEndpointEnabled *bool `pulumi:"publicDataEndpointEnabled"`
	// The name of the resource group in which to create the SQL Managed Instance. Changing this forces a new resource to be created.
	ResourceGroupName *string `pulumi:"resourceGroupName"`
	// Specifies the SKU Name for the SQL Managed Instance. Valid values include `GP_Gen4`, `GP_Gen5`, `GP_Gen8IM`, `GP_Gen8IH`, `BC_Gen4`, `BC_Gen5`, `BC_Gen8IM` or `BC_Gen8IH`.
	SkuName *string `pulumi:"skuName"`
	// Specifies the storage account type used to store backups for this database. Changing this forces a new resource to be created. Possible values are `GRS`, `LRS` and `ZRS`. Defaults to `GRS`.
	StorageAccountType *string `pulumi:"storageAccountType"`
	// Maximum storage space for the SQL Managed instance. This should be a multiple of 32 (GB).
	StorageSizeInGb *int `pulumi:"storageSizeInGb"`
	// The subnet resource id that the SQL Managed Instance will be associated with. Changing this forces a new resource to be created.
	SubnetId *string `pulumi:"subnetId"`
	// A mapping of tags to assign to the resource.
	Tags map[string]string `pulumi:"tags"`
	// The TimeZone ID that the SQL Managed Instance will be operating in. Default value is `UTC`. Changing this forces a new resource to be created.
	TimezoneId *string `pulumi:"timezoneId"`
	// Number of cores that should be assigned to the SQL Managed Instance. Values can be `8`, `16`, or `24` for Gen4 SKUs, or `4`, `6`, `8`, `10`, `12`, `16`, `20`, `24`, `32`, `40`, `48`, `56`, `64`, `80`, `96` or `128` for Gen5 SKUs.
	Vcores *int `pulumi:"vcores"`
}

type ManagedInstanceState struct {
	// The administrator login name for the new SQL Managed Instance. Changing this forces a new resource to be created.
	AdministratorLogin pulumi.StringPtrInput
	// The password associated with the `administratorLogin` user. Needs to comply with Azure's [Password Policy](https://msdn.microsoft.com/library/ms161959.aspx)
	AdministratorLoginPassword pulumi.StringPtrInput
	// Specifies how the SQL Managed Instance will be collated. Default value is `SQL_Latin1_General_CP1_CI_AS`. Changing this forces a new resource to be created.
	Collation pulumi.StringPtrInput
	// The Dns Zone where the SQL Managed Instance is located.
	DnsZone pulumi.StringPtrInput
	// The ID of the SQL Managed Instance which will share the DNS zone. This is a prerequisite for creating an `sql.ManagedInstanceFailoverGroup`. Setting this after creation forces a new resource to be created.
	DnsZonePartnerId pulumi.StringPtrInput
	// The fully qualified domain name of the Azure Managed SQL Instance
	Fqdn pulumi.StringPtrInput
	// An `identity` block as defined below.
	Identity ManagedInstanceIdentityPtrInput
	// What type of license the Managed Instance will use. Possible values are `LicenseIncluded` and `BasePrice`.
	LicenseType pulumi.StringPtrInput
	// Specifies the supported Azure location where the resource exists. Changing this forces a new resource to be created.
	Location pulumi.StringPtrInput
	// The name of the Public Maintenance Configuration window to apply to the SQL Managed Instance. Valid values include `SQL_Default` or an Azure Location in the format `SQL_{Location}_MI_{Size}`(for example `SQL_EastUS_MI_1`). Defaults to `SQL_Default`.
	MaintenanceConfigurationName pulumi.StringPtrInput
	// The Minimum TLS Version. Default value is `1.2` Valid values include `1.0`, `1.1`, `1.2`.
	MinimumTlsVersion pulumi.StringPtrInput
	// The name of the SQL Managed Instance. This needs to be globally unique within Azure. Changing this forces a new resource to be created.
	Name pulumi.StringPtrInput
	// Specifies how the SQL Managed Instance will be accessed. Default value is `Default`. Valid values include `Default`, `Proxy`, and `Redirect`.
	ProxyOverride pulumi.StringPtrInput
	// Is the public data endpoint enabled? Default value is `false`.
	PublicDataEndpointEnabled pulumi.BoolPtrInput
	// The name of the resource group in which to create the SQL Managed Instance. Changing this forces a new resource to be created.
	ResourceGroupName pulumi.StringPtrInput
	// Specifies the SKU Name for the SQL Managed Instance. Valid values include `GP_Gen4`, `GP_Gen5`, `GP_Gen8IM`, `GP_Gen8IH`, `BC_Gen4`, `BC_Gen5`, `BC_Gen8IM` or `BC_Gen8IH`.
	SkuName pulumi.StringPtrInput
	// Specifies the storage account type used to store backups for this database. Changing this forces a new resource to be created. Possible values are `GRS`, `LRS` and `ZRS`. Defaults to `GRS`.
	StorageAccountType pulumi.StringPtrInput
	// Maximum storage space for the SQL Managed instance. This should be a multiple of 32 (GB).
	StorageSizeInGb pulumi.IntPtrInput
	// The subnet resource id that the SQL Managed Instance will be associated with. Changing this forces a new resource to be created.
	SubnetId pulumi.StringPtrInput
	// A mapping of tags to assign to the resource.
	Tags pulumi.StringMapInput
	// The TimeZone ID that the SQL Managed Instance will be operating in. Default value is `UTC`. Changing this forces a new resource to be created.
	TimezoneId pulumi.StringPtrInput
	// Number of cores that should be assigned to the SQL Managed Instance. Values can be `8`, `16`, or `24` for Gen4 SKUs, or `4`, `6`, `8`, `10`, `12`, `16`, `20`, `24`, `32`, `40`, `48`, `56`, `64`, `80`, `96` or `128` for Gen5 SKUs.
	Vcores pulumi.IntPtrInput
}

func (ManagedInstanceState) ElementType() reflect.Type {
	return reflect.TypeOf((*managedInstanceState)(nil)).Elem()
}

type managedInstanceArgs struct {
	// The administrator login name for the new SQL Managed Instance. Changing this forces a new resource to be created.
	AdministratorLogin string `pulumi:"administratorLogin"`
	// The password associated with the `administratorLogin` user. Needs to comply with Azure's [Password Policy](https://msdn.microsoft.com/library/ms161959.aspx)
	AdministratorLoginPassword string `pulumi:"administratorLoginPassword"`
	// Specifies how the SQL Managed Instance will be collated. Default value is `SQL_Latin1_General_CP1_CI_AS`. Changing this forces a new resource to be created.
	Collation *string `pulumi:"collation"`
	// The ID of the SQL Managed Instance which will share the DNS zone. This is a prerequisite for creating an `sql.ManagedInstanceFailoverGroup`. Setting this after creation forces a new resource to be created.
	DnsZonePartnerId *string `pulumi:"dnsZonePartnerId"`
	// An `identity` block as defined below.
	Identity *ManagedInstanceIdentity `pulumi:"identity"`
	// What type of license the Managed Instance will use. Possible values are `LicenseIncluded` and `BasePrice`.
	LicenseType string `pulumi:"licenseType"`
	// Specifies the supported Azure location where the resource exists. Changing this forces a new resource to be created.
	Location *string `pulumi:"location"`
	// The name of the Public Maintenance Configuration window to apply to the SQL Managed Instance. Valid values include `SQL_Default` or an Azure Location in the format `SQL_{Location}_MI_{Size}`(for example `SQL_EastUS_MI_1`). Defaults to `SQL_Default`.
	MaintenanceConfigurationName *string `pulumi:"maintenanceConfigurationName"`
	// The Minimum TLS Version. Default value is `1.2` Valid values include `1.0`, `1.1`, `1.2`.
	MinimumTlsVersion *string `pulumi:"minimumTlsVersion"`
	// The name of the SQL Managed Instance. This needs to be globally unique within Azure. Changing this forces a new resource to be created.
	Name *string `pulumi:"name"`
	// Specifies how the SQL Managed Instance will be accessed. Default value is `Default`. Valid values include `Default`, `Proxy`, and `Redirect`.
	ProxyOverride *string `pulumi:"proxyOverride"`
	// Is the public data endpoint enabled? Default value is `false`.
	PublicDataEndpointEnabled *bool `pulumi:"publicDataEndpointEnabled"`
	// The name of the resource group in which to create the SQL Managed Instance. Changing this forces a new resource to be created.
	ResourceGroupName string `pulumi:"resourceGroupName"`
	// Specifies the SKU Name for the SQL Managed Instance. Valid values include `GP_Gen4`, `GP_Gen5`, `GP_Gen8IM`, `GP_Gen8IH`, `BC_Gen4`, `BC_Gen5`, `BC_Gen8IM` or `BC_Gen8IH`.
	SkuName string `pulumi:"skuName"`
	// Specifies the storage account type used to store backups for this database. Changing this forces a new resource to be created. Possible values are `GRS`, `LRS` and `ZRS`. Defaults to `GRS`.
	StorageAccountType *string `pulumi:"storageAccountType"`
	// Maximum storage space for the SQL Managed instance. This should be a multiple of 32 (GB).
	StorageSizeInGb int `pulumi:"storageSizeInGb"`
	// The subnet resource id that the SQL Managed Instance will be associated with. Changing this forces a new resource to be created.
	SubnetId string `pulumi:"subnetId"`
	// A mapping of tags to assign to the resource.
	Tags map[string]string `pulumi:"tags"`
	// The TimeZone ID that the SQL Managed Instance will be operating in. Default value is `UTC`. Changing this forces a new resource to be created.
	TimezoneId *string `pulumi:"timezoneId"`
	// Number of cores that should be assigned to the SQL Managed Instance. Values can be `8`, `16`, or `24` for Gen4 SKUs, or `4`, `6`, `8`, `10`, `12`, `16`, `20`, `24`, `32`, `40`, `48`, `56`, `64`, `80`, `96` or `128` for Gen5 SKUs.
	Vcores int `pulumi:"vcores"`
}

// The set of arguments for constructing a ManagedInstance resource.
type ManagedInstanceArgs struct {
	// The administrator login name for the new SQL Managed Instance. Changing this forces a new resource to be created.
	AdministratorLogin pulumi.StringInput
	// The password associated with the `administratorLogin` user. Needs to comply with Azure's [Password Policy](https://msdn.microsoft.com/library/ms161959.aspx)
	AdministratorLoginPassword pulumi.StringInput
	// Specifies how the SQL Managed Instance will be collated. Default value is `SQL_Latin1_General_CP1_CI_AS`. Changing this forces a new resource to be created.
	Collation pulumi.StringPtrInput
	// The ID of the SQL Managed Instance which will share the DNS zone. This is a prerequisite for creating an `sql.ManagedInstanceFailoverGroup`. Setting this after creation forces a new resource to be created.
	DnsZonePartnerId pulumi.StringPtrInput
	// An `identity` block as defined below.
	Identity ManagedInstanceIdentityPtrInput
	// What type of license the Managed Instance will use. Possible values are `LicenseIncluded` and `BasePrice`.
	LicenseType pulumi.StringInput
	// Specifies the supported Azure location where the resource exists. Changing this forces a new resource to be created.
	Location pulumi.StringPtrInput
	// The name of the Public Maintenance Configuration window to apply to the SQL Managed Instance. Valid values include `SQL_Default` or an Azure Location in the format `SQL_{Location}_MI_{Size}`(for example `SQL_EastUS_MI_1`). Defaults to `SQL_Default`.
	MaintenanceConfigurationName pulumi.StringPtrInput
	// The Minimum TLS Version. Default value is `1.2` Valid values include `1.0`, `1.1`, `1.2`.
	MinimumTlsVersion pulumi.StringPtrInput
	// The name of the SQL Managed Instance. This needs to be globally unique within Azure. Changing this forces a new resource to be created.
	Name pulumi.StringPtrInput
	// Specifies how the SQL Managed Instance will be accessed. Default value is `Default`. Valid values include `Default`, `Proxy`, and `Redirect`.
	ProxyOverride pulumi.StringPtrInput
	// Is the public data endpoint enabled? Default value is `false`.
	PublicDataEndpointEnabled pulumi.BoolPtrInput
	// The name of the resource group in which to create the SQL Managed Instance. Changing this forces a new resource to be created.
	ResourceGroupName pulumi.StringInput
	// Specifies the SKU Name for the SQL Managed Instance. Valid values include `GP_Gen4`, `GP_Gen5`, `GP_Gen8IM`, `GP_Gen8IH`, `BC_Gen4`, `BC_Gen5`, `BC_Gen8IM` or `BC_Gen8IH`.
	SkuName pulumi.StringInput
	// Specifies the storage account type used to store backups for this database. Changing this forces a new resource to be created. Possible values are `GRS`, `LRS` and `ZRS`. Defaults to `GRS`.
	StorageAccountType pulumi.StringPtrInput
	// Maximum storage space for the SQL Managed instance. This should be a multiple of 32 (GB).
	StorageSizeInGb pulumi.IntInput
	// The subnet resource id that the SQL Managed Instance will be associated with. Changing this forces a new resource to be created.
	SubnetId pulumi.StringInput
	// A mapping of tags to assign to the resource.
	Tags pulumi.StringMapInput
	// The TimeZone ID that the SQL Managed Instance will be operating in. Default value is `UTC`. Changing this forces a new resource to be created.
	TimezoneId pulumi.StringPtrInput
	// Number of cores that should be assigned to the SQL Managed Instance. Values can be `8`, `16`, or `24` for Gen4 SKUs, or `4`, `6`, `8`, `10`, `12`, `16`, `20`, `24`, `32`, `40`, `48`, `56`, `64`, `80`, `96` or `128` for Gen5 SKUs.
	Vcores pulumi.IntInput
}

func (ManagedInstanceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*managedInstanceArgs)(nil)).Elem()
}

type ManagedInstanceInput interface {
	pulumi.Input

	ToManagedInstanceOutput() ManagedInstanceOutput
	ToManagedInstanceOutputWithContext(ctx context.Context) ManagedInstanceOutput
}

func (*ManagedInstance) ElementType() reflect.Type {
	return reflect.TypeOf((**ManagedInstance)(nil)).Elem()
}

func (i *ManagedInstance) ToManagedInstanceOutput() ManagedInstanceOutput {
	return i.ToManagedInstanceOutputWithContext(context.Background())
}

func (i *ManagedInstance) ToManagedInstanceOutputWithContext(ctx context.Context) ManagedInstanceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedInstanceOutput)
}

// ManagedInstanceArrayInput is an input type that accepts ManagedInstanceArray and ManagedInstanceArrayOutput values.
// You can construct a concrete instance of `ManagedInstanceArrayInput` via:
//
//	ManagedInstanceArray{ ManagedInstanceArgs{...} }
type ManagedInstanceArrayInput interface {
	pulumi.Input

	ToManagedInstanceArrayOutput() ManagedInstanceArrayOutput
	ToManagedInstanceArrayOutputWithContext(context.Context) ManagedInstanceArrayOutput
}

type ManagedInstanceArray []ManagedInstanceInput

func (ManagedInstanceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ManagedInstance)(nil)).Elem()
}

func (i ManagedInstanceArray) ToManagedInstanceArrayOutput() ManagedInstanceArrayOutput {
	return i.ToManagedInstanceArrayOutputWithContext(context.Background())
}

func (i ManagedInstanceArray) ToManagedInstanceArrayOutputWithContext(ctx context.Context) ManagedInstanceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedInstanceArrayOutput)
}

// ManagedInstanceMapInput is an input type that accepts ManagedInstanceMap and ManagedInstanceMapOutput values.
// You can construct a concrete instance of `ManagedInstanceMapInput` via:
//
//	ManagedInstanceMap{ "key": ManagedInstanceArgs{...} }
type ManagedInstanceMapInput interface {
	pulumi.Input

	ToManagedInstanceMapOutput() ManagedInstanceMapOutput
	ToManagedInstanceMapOutputWithContext(context.Context) ManagedInstanceMapOutput
}

type ManagedInstanceMap map[string]ManagedInstanceInput

func (ManagedInstanceMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ManagedInstance)(nil)).Elem()
}

func (i ManagedInstanceMap) ToManagedInstanceMapOutput() ManagedInstanceMapOutput {
	return i.ToManagedInstanceMapOutputWithContext(context.Background())
}

func (i ManagedInstanceMap) ToManagedInstanceMapOutputWithContext(ctx context.Context) ManagedInstanceMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedInstanceMapOutput)
}

type ManagedInstanceOutput struct{ *pulumi.OutputState }

func (ManagedInstanceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ManagedInstance)(nil)).Elem()
}

func (o ManagedInstanceOutput) ToManagedInstanceOutput() ManagedInstanceOutput {
	return o
}

func (o ManagedInstanceOutput) ToManagedInstanceOutputWithContext(ctx context.Context) ManagedInstanceOutput {
	return o
}

// The administrator login name for the new SQL Managed Instance. Changing this forces a new resource to be created.
func (o ManagedInstanceOutput) AdministratorLogin() pulumi.StringOutput {
	return o.ApplyT(func(v *ManagedInstance) pulumi.StringOutput { return v.AdministratorLogin }).(pulumi.StringOutput)
}

// The password associated with the `administratorLogin` user. Needs to comply with Azure's [Password Policy](https://msdn.microsoft.com/library/ms161959.aspx)
func (o ManagedInstanceOutput) AdministratorLoginPassword() pulumi.StringOutput {
	return o.ApplyT(func(v *ManagedInstance) pulumi.StringOutput { return v.AdministratorLoginPassword }).(pulumi.StringOutput)
}

// Specifies how the SQL Managed Instance will be collated. Default value is `SQL_Latin1_General_CP1_CI_AS`. Changing this forces a new resource to be created.
func (o ManagedInstanceOutput) Collation() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ManagedInstance) pulumi.StringPtrOutput { return v.Collation }).(pulumi.StringPtrOutput)
}

// The Dns Zone where the SQL Managed Instance is located.
func (o ManagedInstanceOutput) DnsZone() pulumi.StringOutput {
	return o.ApplyT(func(v *ManagedInstance) pulumi.StringOutput { return v.DnsZone }).(pulumi.StringOutput)
}

// The ID of the SQL Managed Instance which will share the DNS zone. This is a prerequisite for creating an `sql.ManagedInstanceFailoverGroup`. Setting this after creation forces a new resource to be created.
func (o ManagedInstanceOutput) DnsZonePartnerId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ManagedInstance) pulumi.StringPtrOutput { return v.DnsZonePartnerId }).(pulumi.StringPtrOutput)
}

// The fully qualified domain name of the Azure Managed SQL Instance
func (o ManagedInstanceOutput) Fqdn() pulumi.StringOutput {
	return o.ApplyT(func(v *ManagedInstance) pulumi.StringOutput { return v.Fqdn }).(pulumi.StringOutput)
}

// An `identity` block as defined below.
func (o ManagedInstanceOutput) Identity() ManagedInstanceIdentityPtrOutput {
	return o.ApplyT(func(v *ManagedInstance) ManagedInstanceIdentityPtrOutput { return v.Identity }).(ManagedInstanceIdentityPtrOutput)
}

// What type of license the Managed Instance will use. Possible values are `LicenseIncluded` and `BasePrice`.
func (o ManagedInstanceOutput) LicenseType() pulumi.StringOutput {
	return o.ApplyT(func(v *ManagedInstance) pulumi.StringOutput { return v.LicenseType }).(pulumi.StringOutput)
}

// Specifies the supported Azure location where the resource exists. Changing this forces a new resource to be created.
func (o ManagedInstanceOutput) Location() pulumi.StringOutput {
	return o.ApplyT(func(v *ManagedInstance) pulumi.StringOutput { return v.Location }).(pulumi.StringOutput)
}

// The name of the Public Maintenance Configuration window to apply to the SQL Managed Instance. Valid values include `SQL_Default` or an Azure Location in the format `SQL_{Location}_MI_{Size}`(for example `SQL_EastUS_MI_1`). Defaults to `SQL_Default`.
func (o ManagedInstanceOutput) MaintenanceConfigurationName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ManagedInstance) pulumi.StringPtrOutput { return v.MaintenanceConfigurationName }).(pulumi.StringPtrOutput)
}

// The Minimum TLS Version. Default value is `1.2` Valid values include `1.0`, `1.1`, `1.2`.
func (o ManagedInstanceOutput) MinimumTlsVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ManagedInstance) pulumi.StringPtrOutput { return v.MinimumTlsVersion }).(pulumi.StringPtrOutput)
}

// The name of the SQL Managed Instance. This needs to be globally unique within Azure. Changing this forces a new resource to be created.
func (o ManagedInstanceOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *ManagedInstance) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Specifies how the SQL Managed Instance will be accessed. Default value is `Default`. Valid values include `Default`, `Proxy`, and `Redirect`.
func (o ManagedInstanceOutput) ProxyOverride() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ManagedInstance) pulumi.StringPtrOutput { return v.ProxyOverride }).(pulumi.StringPtrOutput)
}

// Is the public data endpoint enabled? Default value is `false`.
func (o ManagedInstanceOutput) PublicDataEndpointEnabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ManagedInstance) pulumi.BoolPtrOutput { return v.PublicDataEndpointEnabled }).(pulumi.BoolPtrOutput)
}

// The name of the resource group in which to create the SQL Managed Instance. Changing this forces a new resource to be created.
func (o ManagedInstanceOutput) ResourceGroupName() pulumi.StringOutput {
	return o.ApplyT(func(v *ManagedInstance) pulumi.StringOutput { return v.ResourceGroupName }).(pulumi.StringOutput)
}

// Specifies the SKU Name for the SQL Managed Instance. Valid values include `GP_Gen4`, `GP_Gen5`, `GP_Gen8IM`, `GP_Gen8IH`, `BC_Gen4`, `BC_Gen5`, `BC_Gen8IM` or `BC_Gen8IH`.
func (o ManagedInstanceOutput) SkuName() pulumi.StringOutput {
	return o.ApplyT(func(v *ManagedInstance) pulumi.StringOutput { return v.SkuName }).(pulumi.StringOutput)
}

// Specifies the storage account type used to store backups for this database. Changing this forces a new resource to be created. Possible values are `GRS`, `LRS` and `ZRS`. Defaults to `GRS`.
func (o ManagedInstanceOutput) StorageAccountType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ManagedInstance) pulumi.StringPtrOutput { return v.StorageAccountType }).(pulumi.StringPtrOutput)
}

// Maximum storage space for the SQL Managed instance. This should be a multiple of 32 (GB).
func (o ManagedInstanceOutput) StorageSizeInGb() pulumi.IntOutput {
	return o.ApplyT(func(v *ManagedInstance) pulumi.IntOutput { return v.StorageSizeInGb }).(pulumi.IntOutput)
}

// The subnet resource id that the SQL Managed Instance will be associated with. Changing this forces a new resource to be created.
func (o ManagedInstanceOutput) SubnetId() pulumi.StringOutput {
	return o.ApplyT(func(v *ManagedInstance) pulumi.StringOutput { return v.SubnetId }).(pulumi.StringOutput)
}

// A mapping of tags to assign to the resource.
func (o ManagedInstanceOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ManagedInstance) pulumi.StringMapOutput { return v.Tags }).(pulumi.StringMapOutput)
}

// The TimeZone ID that the SQL Managed Instance will be operating in. Default value is `UTC`. Changing this forces a new resource to be created.
func (o ManagedInstanceOutput) TimezoneId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ManagedInstance) pulumi.StringPtrOutput { return v.TimezoneId }).(pulumi.StringPtrOutput)
}

// Number of cores that should be assigned to the SQL Managed Instance. Values can be `8`, `16`, or `24` for Gen4 SKUs, or `4`, `6`, `8`, `10`, `12`, `16`, `20`, `24`, `32`, `40`, `48`, `56`, `64`, `80`, `96` or `128` for Gen5 SKUs.
func (o ManagedInstanceOutput) Vcores() pulumi.IntOutput {
	return o.ApplyT(func(v *ManagedInstance) pulumi.IntOutput { return v.Vcores }).(pulumi.IntOutput)
}

type ManagedInstanceArrayOutput struct{ *pulumi.OutputState }

func (ManagedInstanceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ManagedInstance)(nil)).Elem()
}

func (o ManagedInstanceArrayOutput) ToManagedInstanceArrayOutput() ManagedInstanceArrayOutput {
	return o
}

func (o ManagedInstanceArrayOutput) ToManagedInstanceArrayOutputWithContext(ctx context.Context) ManagedInstanceArrayOutput {
	return o
}

func (o ManagedInstanceArrayOutput) Index(i pulumi.IntInput) ManagedInstanceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ManagedInstance {
		return vs[0].([]*ManagedInstance)[vs[1].(int)]
	}).(ManagedInstanceOutput)
}

type ManagedInstanceMapOutput struct{ *pulumi.OutputState }

func (ManagedInstanceMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ManagedInstance)(nil)).Elem()
}

func (o ManagedInstanceMapOutput) ToManagedInstanceMapOutput() ManagedInstanceMapOutput {
	return o
}

func (o ManagedInstanceMapOutput) ToManagedInstanceMapOutputWithContext(ctx context.Context) ManagedInstanceMapOutput {
	return o
}

func (o ManagedInstanceMapOutput) MapIndex(k pulumi.StringInput) ManagedInstanceOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ManagedInstance {
		return vs[0].(map[string]*ManagedInstance)[vs[1].(string)]
	}).(ManagedInstanceOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ManagedInstanceInput)(nil)).Elem(), &ManagedInstance{})
	pulumi.RegisterInputType(reflect.TypeOf((*ManagedInstanceArrayInput)(nil)).Elem(), ManagedInstanceArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ManagedInstanceMapInput)(nil)).Elem(), ManagedInstanceMap{})
	pulumi.RegisterOutputType(ManagedInstanceOutput{})
	pulumi.RegisterOutputType(ManagedInstanceArrayOutput{})
	pulumi.RegisterOutputType(ManagedInstanceMapOutput{})
}
