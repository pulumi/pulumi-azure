// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package containerservice

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-azure/sdk/v6/go/azure/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages an Azure Container Registry Cache Rule.
//
// > **Note:** All arguments including the access key will be stored in the raw state as plain-text.
// [Read more about sensitive data in state](https://www.terraform.io/docs/state/sensitive-data.html).
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"fmt"
//
//	"github.com/pulumi/pulumi-azure/sdk/v6/go/azure/containerservice"
//	"github.com/pulumi/pulumi-azure/sdk/v6/go/azure/core"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			example, err := core.NewResourceGroup(ctx, "example", &core.ResourceGroupArgs{
//				Name:     pulumi.String("example-resources"),
//				Location: pulumi.String("West Europe"),
//			})
//			if err != nil {
//				return err
//			}
//			acr, err := containerservice.NewRegistry(ctx, "acr", &containerservice.RegistryArgs{
//				Name:              pulumi.String("containerRegistry1"),
//				ResourceGroupName: example.Name,
//				Location:          example.Location,
//				Sku:               pulumi.String("Basic"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = containerservice.NewRegistryCacheRule(ctx, "cache_rule", &containerservice.RegistryCacheRuleArgs{
//				Name:                pulumi.String("cacherule"),
//				ContainerRegistryId: acr.ID(),
//				TargetRepo:          pulumi.String("target"),
//				SourceRepo:          pulumi.String("docker.io/hello-world"),
//				CredentialSetId: acr.ID().ApplyT(func(id string) (string, error) {
//					return fmt.Sprintf("%v/credentialSets/example", id), nil
//				}).(pulumi.StringOutput),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## API Providers
//
// <!-- This section is generated, changes will be overwritten -->
// This resource uses the following Azure API Providers:
//
// * `Microsoft.ContainerRegistry`: 2023-07-01
//
// ## Import
//
// Container Registry Cache Rules can be imported using the `resource id`, e.g.
//
// ```sh
// $ pulumi import azure:containerservice/registryCacheRule:RegistryCacheRule example /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/myResourceGroup/providers/Microsoft.ContainerRegistry/registries/myRegistry/cacheRules/myCacheRule
// ```
type RegistryCacheRule struct {
	pulumi.CustomResourceState

	// The ID of the Container Registry where the Cache Rule should apply. Changing this forces a new resource to be created.
	ContainerRegistryId pulumi.StringOutput `pulumi:"containerRegistryId"`
	// The ARM resource ID of the Credential Store which is associated with the Cache Rule.
	CredentialSetId pulumi.StringPtrOutput `pulumi:"credentialSetId"`
	// Specifies the name of the Container Registry Cache Rule. Only Alphanumeric characters allowed. Changing this forces a new resource to be created.
	Name pulumi.StringOutput `pulumi:"name"`
	// The name of the source repository path. Changing this forces a new resource to be created.
	SourceRepo pulumi.StringOutput `pulumi:"sourceRepo"`
	// The name of the new repository path to store artifacts. Changing this forces a new resource to be created.
	TargetRepo pulumi.StringOutput `pulumi:"targetRepo"`
}

// NewRegistryCacheRule registers a new resource with the given unique name, arguments, and options.
func NewRegistryCacheRule(ctx *pulumi.Context,
	name string, args *RegistryCacheRuleArgs, opts ...pulumi.ResourceOption) (*RegistryCacheRule, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ContainerRegistryId == nil {
		return nil, errors.New("invalid value for required argument 'ContainerRegistryId'")
	}
	if args.SourceRepo == nil {
		return nil, errors.New("invalid value for required argument 'SourceRepo'")
	}
	if args.TargetRepo == nil {
		return nil, errors.New("invalid value for required argument 'TargetRepo'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource RegistryCacheRule
	err := ctx.RegisterResource("azure:containerservice/registryCacheRule:RegistryCacheRule", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetRegistryCacheRule gets an existing RegistryCacheRule resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetRegistryCacheRule(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *RegistryCacheRuleState, opts ...pulumi.ResourceOption) (*RegistryCacheRule, error) {
	var resource RegistryCacheRule
	err := ctx.ReadResource("azure:containerservice/registryCacheRule:RegistryCacheRule", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering RegistryCacheRule resources.
type registryCacheRuleState struct {
	// The ID of the Container Registry where the Cache Rule should apply. Changing this forces a new resource to be created.
	ContainerRegistryId *string `pulumi:"containerRegistryId"`
	// The ARM resource ID of the Credential Store which is associated with the Cache Rule.
	CredentialSetId *string `pulumi:"credentialSetId"`
	// Specifies the name of the Container Registry Cache Rule. Only Alphanumeric characters allowed. Changing this forces a new resource to be created.
	Name *string `pulumi:"name"`
	// The name of the source repository path. Changing this forces a new resource to be created.
	SourceRepo *string `pulumi:"sourceRepo"`
	// The name of the new repository path to store artifacts. Changing this forces a new resource to be created.
	TargetRepo *string `pulumi:"targetRepo"`
}

type RegistryCacheRuleState struct {
	// The ID of the Container Registry where the Cache Rule should apply. Changing this forces a new resource to be created.
	ContainerRegistryId pulumi.StringPtrInput
	// The ARM resource ID of the Credential Store which is associated with the Cache Rule.
	CredentialSetId pulumi.StringPtrInput
	// Specifies the name of the Container Registry Cache Rule. Only Alphanumeric characters allowed. Changing this forces a new resource to be created.
	Name pulumi.StringPtrInput
	// The name of the source repository path. Changing this forces a new resource to be created.
	SourceRepo pulumi.StringPtrInput
	// The name of the new repository path to store artifacts. Changing this forces a new resource to be created.
	TargetRepo pulumi.StringPtrInput
}

func (RegistryCacheRuleState) ElementType() reflect.Type {
	return reflect.TypeOf((*registryCacheRuleState)(nil)).Elem()
}

type registryCacheRuleArgs struct {
	// The ID of the Container Registry where the Cache Rule should apply. Changing this forces a new resource to be created.
	ContainerRegistryId string `pulumi:"containerRegistryId"`
	// The ARM resource ID of the Credential Store which is associated with the Cache Rule.
	CredentialSetId *string `pulumi:"credentialSetId"`
	// Specifies the name of the Container Registry Cache Rule. Only Alphanumeric characters allowed. Changing this forces a new resource to be created.
	Name *string `pulumi:"name"`
	// The name of the source repository path. Changing this forces a new resource to be created.
	SourceRepo string `pulumi:"sourceRepo"`
	// The name of the new repository path to store artifacts. Changing this forces a new resource to be created.
	TargetRepo string `pulumi:"targetRepo"`
}

// The set of arguments for constructing a RegistryCacheRule resource.
type RegistryCacheRuleArgs struct {
	// The ID of the Container Registry where the Cache Rule should apply. Changing this forces a new resource to be created.
	ContainerRegistryId pulumi.StringInput
	// The ARM resource ID of the Credential Store which is associated with the Cache Rule.
	CredentialSetId pulumi.StringPtrInput
	// Specifies the name of the Container Registry Cache Rule. Only Alphanumeric characters allowed. Changing this forces a new resource to be created.
	Name pulumi.StringPtrInput
	// The name of the source repository path. Changing this forces a new resource to be created.
	SourceRepo pulumi.StringInput
	// The name of the new repository path to store artifacts. Changing this forces a new resource to be created.
	TargetRepo pulumi.StringInput
}

func (RegistryCacheRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*registryCacheRuleArgs)(nil)).Elem()
}

type RegistryCacheRuleInput interface {
	pulumi.Input

	ToRegistryCacheRuleOutput() RegistryCacheRuleOutput
	ToRegistryCacheRuleOutputWithContext(ctx context.Context) RegistryCacheRuleOutput
}

func (*RegistryCacheRule) ElementType() reflect.Type {
	return reflect.TypeOf((**RegistryCacheRule)(nil)).Elem()
}

func (i *RegistryCacheRule) ToRegistryCacheRuleOutput() RegistryCacheRuleOutput {
	return i.ToRegistryCacheRuleOutputWithContext(context.Background())
}

func (i *RegistryCacheRule) ToRegistryCacheRuleOutputWithContext(ctx context.Context) RegistryCacheRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RegistryCacheRuleOutput)
}

// RegistryCacheRuleArrayInput is an input type that accepts RegistryCacheRuleArray and RegistryCacheRuleArrayOutput values.
// You can construct a concrete instance of `RegistryCacheRuleArrayInput` via:
//
//	RegistryCacheRuleArray{ RegistryCacheRuleArgs{...} }
type RegistryCacheRuleArrayInput interface {
	pulumi.Input

	ToRegistryCacheRuleArrayOutput() RegistryCacheRuleArrayOutput
	ToRegistryCacheRuleArrayOutputWithContext(context.Context) RegistryCacheRuleArrayOutput
}

type RegistryCacheRuleArray []RegistryCacheRuleInput

func (RegistryCacheRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*RegistryCacheRule)(nil)).Elem()
}

func (i RegistryCacheRuleArray) ToRegistryCacheRuleArrayOutput() RegistryCacheRuleArrayOutput {
	return i.ToRegistryCacheRuleArrayOutputWithContext(context.Background())
}

func (i RegistryCacheRuleArray) ToRegistryCacheRuleArrayOutputWithContext(ctx context.Context) RegistryCacheRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RegistryCacheRuleArrayOutput)
}

// RegistryCacheRuleMapInput is an input type that accepts RegistryCacheRuleMap and RegistryCacheRuleMapOutput values.
// You can construct a concrete instance of `RegistryCacheRuleMapInput` via:
//
//	RegistryCacheRuleMap{ "key": RegistryCacheRuleArgs{...} }
type RegistryCacheRuleMapInput interface {
	pulumi.Input

	ToRegistryCacheRuleMapOutput() RegistryCacheRuleMapOutput
	ToRegistryCacheRuleMapOutputWithContext(context.Context) RegistryCacheRuleMapOutput
}

type RegistryCacheRuleMap map[string]RegistryCacheRuleInput

func (RegistryCacheRuleMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*RegistryCacheRule)(nil)).Elem()
}

func (i RegistryCacheRuleMap) ToRegistryCacheRuleMapOutput() RegistryCacheRuleMapOutput {
	return i.ToRegistryCacheRuleMapOutputWithContext(context.Background())
}

func (i RegistryCacheRuleMap) ToRegistryCacheRuleMapOutputWithContext(ctx context.Context) RegistryCacheRuleMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RegistryCacheRuleMapOutput)
}

type RegistryCacheRuleOutput struct{ *pulumi.OutputState }

func (RegistryCacheRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RegistryCacheRule)(nil)).Elem()
}

func (o RegistryCacheRuleOutput) ToRegistryCacheRuleOutput() RegistryCacheRuleOutput {
	return o
}

func (o RegistryCacheRuleOutput) ToRegistryCacheRuleOutputWithContext(ctx context.Context) RegistryCacheRuleOutput {
	return o
}

// The ID of the Container Registry where the Cache Rule should apply. Changing this forces a new resource to be created.
func (o RegistryCacheRuleOutput) ContainerRegistryId() pulumi.StringOutput {
	return o.ApplyT(func(v *RegistryCacheRule) pulumi.StringOutput { return v.ContainerRegistryId }).(pulumi.StringOutput)
}

// The ARM resource ID of the Credential Store which is associated with the Cache Rule.
func (o RegistryCacheRuleOutput) CredentialSetId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RegistryCacheRule) pulumi.StringPtrOutput { return v.CredentialSetId }).(pulumi.StringPtrOutput)
}

// Specifies the name of the Container Registry Cache Rule. Only Alphanumeric characters allowed. Changing this forces a new resource to be created.
func (o RegistryCacheRuleOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *RegistryCacheRule) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The name of the source repository path. Changing this forces a new resource to be created.
func (o RegistryCacheRuleOutput) SourceRepo() pulumi.StringOutput {
	return o.ApplyT(func(v *RegistryCacheRule) pulumi.StringOutput { return v.SourceRepo }).(pulumi.StringOutput)
}

// The name of the new repository path to store artifacts. Changing this forces a new resource to be created.
func (o RegistryCacheRuleOutput) TargetRepo() pulumi.StringOutput {
	return o.ApplyT(func(v *RegistryCacheRule) pulumi.StringOutput { return v.TargetRepo }).(pulumi.StringOutput)
}

type RegistryCacheRuleArrayOutput struct{ *pulumi.OutputState }

func (RegistryCacheRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*RegistryCacheRule)(nil)).Elem()
}

func (o RegistryCacheRuleArrayOutput) ToRegistryCacheRuleArrayOutput() RegistryCacheRuleArrayOutput {
	return o
}

func (o RegistryCacheRuleArrayOutput) ToRegistryCacheRuleArrayOutputWithContext(ctx context.Context) RegistryCacheRuleArrayOutput {
	return o
}

func (o RegistryCacheRuleArrayOutput) Index(i pulumi.IntInput) RegistryCacheRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *RegistryCacheRule {
		return vs[0].([]*RegistryCacheRule)[vs[1].(int)]
	}).(RegistryCacheRuleOutput)
}

type RegistryCacheRuleMapOutput struct{ *pulumi.OutputState }

func (RegistryCacheRuleMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*RegistryCacheRule)(nil)).Elem()
}

func (o RegistryCacheRuleMapOutput) ToRegistryCacheRuleMapOutput() RegistryCacheRuleMapOutput {
	return o
}

func (o RegistryCacheRuleMapOutput) ToRegistryCacheRuleMapOutputWithContext(ctx context.Context) RegistryCacheRuleMapOutput {
	return o
}

func (o RegistryCacheRuleMapOutput) MapIndex(k pulumi.StringInput) RegistryCacheRuleOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *RegistryCacheRule {
		return vs[0].(map[string]*RegistryCacheRule)[vs[1].(string)]
	}).(RegistryCacheRuleOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*RegistryCacheRuleInput)(nil)).Elem(), &RegistryCacheRule{})
	pulumi.RegisterInputType(reflect.TypeOf((*RegistryCacheRuleArrayInput)(nil)).Elem(), RegistryCacheRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RegistryCacheRuleMapInput)(nil)).Elem(), RegistryCacheRuleMap{})
	pulumi.RegisterOutputType(RegistryCacheRuleOutput{})
	pulumi.RegisterOutputType(RegistryCacheRuleArrayOutput{})
	pulumi.RegisterOutputType(RegistryCacheRuleMapOutput{})
}
