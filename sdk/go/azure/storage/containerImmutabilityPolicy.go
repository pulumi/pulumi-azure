// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package storage

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-azure/sdk/v6/go/azure/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages an Immutability Policy for a Container within an Azure Storage Account.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-azure/sdk/v6/go/azure/core"
//	"github.com/pulumi/pulumi-azure/sdk/v6/go/azure/storage"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			example, err := core.NewResourceGroup(ctx, "example", &core.ResourceGroupArgs{
//				Name:     pulumi.String("example-resources"),
//				Location: pulumi.String("West Europe"),
//			})
//			if err != nil {
//				return err
//			}
//			exampleAccount, err := storage.NewAccount(ctx, "example", &storage.AccountArgs{
//				Name:                   pulumi.String("examplestoraccount"),
//				ResourceGroupName:      example.Name,
//				Location:               example.Location,
//				AccountTier:            pulumi.String("Standard"),
//				AccountReplicationType: pulumi.String("LRS"),
//				Tags: pulumi.StringMap{
//					"environment": pulumi.String("staging"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			exampleContainer, err := storage.NewContainer(ctx, "example", &storage.ContainerArgs{
//				Name:                pulumi.String("example"),
//				StorageAccountName:  exampleAccount.Name,
//				ContainerAccessType: pulumi.String("private"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = storage.NewContainerImmutabilityPolicy(ctx, "example", &storage.ContainerImmutabilityPolicyArgs{
//				StorageContainerResourceManagerId: exampleContainer.ResourceManagerId,
//				ImmutabilityPeriodInDays:          pulumi.Int(14),
//				ProtectedAppendWritesAllEnabled:   pulumi.Bool(false),
//				ProtectedAppendWritesEnabled:      pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## API Providers
//
// <!-- This section is generated, changes will be overwritten -->
// This resource uses the following Azure API Providers:
//
// * `Microsoft.Storage` - 2023-05-01
//
// ## Import
//
// Storage Container Immutability Policies can be imported using the `resource id`, e.g.
//
// ```sh
// $ pulumi import azure:storage/containerImmutabilityPolicy:ContainerImmutabilityPolicy example /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/myresourcegroup/providers/Microsoft.Storage/storageAccounts/myaccount/blobServices/default/containers/mycontainer/immutabilityPolicies/default
// ```
type ContainerImmutabilityPolicy struct {
	pulumi.CustomResourceState

	// The time interval in days that the data needs to be kept in a non-erasable and non-modifiable state.
	ImmutabilityPeriodInDays pulumi.IntOutput `pulumi:"immutabilityPeriodInDays"`
	// Whether to lock this immutability policy. Cannot be set to `false` once the policy has been locked.
	//
	// !> **Note:** Once an Immutability Policy has been locked, it cannot be unlocked. After locking, it will only be possible to increase the value for `retentionPeriodInDays` up to 5 times for the lifetime of the policy. No other properties will be updateable. Furthermore, the Storage Container and the Storage Account in which it resides will become protected by the policy. It will no longer be possible to delete the Storage Container or the Storage Account. Please refer to [official documentation](https://learn.microsoft.com/en-us/azure/storage/blobs/immutable-policy-configure-container-scope?tabs=azure-portal#lock-a-time-based-retention-policy) for more information.
	Locked pulumi.BoolPtrOutput `pulumi:"locked"`
	// Whether to allow protected append writes to block and append blobs to the container. Defaults to `false`. Cannot be set with `protectedAppendWritesEnabled`.
	ProtectedAppendWritesAllEnabled pulumi.BoolPtrOutput `pulumi:"protectedAppendWritesAllEnabled"`
	// Whether to allow protected append writes to append blobs to the container. Defaults to `false`. Cannot be set with `protectedAppendWritesAllEnabled`.
	ProtectedAppendWritesEnabled pulumi.BoolPtrOutput `pulumi:"protectedAppendWritesEnabled"`
	// The Resource Manager ID of the Storage Container where this Immutability Policy should be applied. Changing this forces a new resource to be created.
	StorageContainerResourceManagerId pulumi.StringOutput `pulumi:"storageContainerResourceManagerId"`
}

// NewContainerImmutabilityPolicy registers a new resource with the given unique name, arguments, and options.
func NewContainerImmutabilityPolicy(ctx *pulumi.Context,
	name string, args *ContainerImmutabilityPolicyArgs, opts ...pulumi.ResourceOption) (*ContainerImmutabilityPolicy, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ImmutabilityPeriodInDays == nil {
		return nil, errors.New("invalid value for required argument 'ImmutabilityPeriodInDays'")
	}
	if args.StorageContainerResourceManagerId == nil {
		return nil, errors.New("invalid value for required argument 'StorageContainerResourceManagerId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ContainerImmutabilityPolicy
	err := ctx.RegisterResource("azure:storage/containerImmutabilityPolicy:ContainerImmutabilityPolicy", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetContainerImmutabilityPolicy gets an existing ContainerImmutabilityPolicy resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetContainerImmutabilityPolicy(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ContainerImmutabilityPolicyState, opts ...pulumi.ResourceOption) (*ContainerImmutabilityPolicy, error) {
	var resource ContainerImmutabilityPolicy
	err := ctx.ReadResource("azure:storage/containerImmutabilityPolicy:ContainerImmutabilityPolicy", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ContainerImmutabilityPolicy resources.
type containerImmutabilityPolicyState struct {
	// The time interval in days that the data needs to be kept in a non-erasable and non-modifiable state.
	ImmutabilityPeriodInDays *int `pulumi:"immutabilityPeriodInDays"`
	// Whether to lock this immutability policy. Cannot be set to `false` once the policy has been locked.
	//
	// !> **Note:** Once an Immutability Policy has been locked, it cannot be unlocked. After locking, it will only be possible to increase the value for `retentionPeriodInDays` up to 5 times for the lifetime of the policy. No other properties will be updateable. Furthermore, the Storage Container and the Storage Account in which it resides will become protected by the policy. It will no longer be possible to delete the Storage Container or the Storage Account. Please refer to [official documentation](https://learn.microsoft.com/en-us/azure/storage/blobs/immutable-policy-configure-container-scope?tabs=azure-portal#lock-a-time-based-retention-policy) for more information.
	Locked *bool `pulumi:"locked"`
	// Whether to allow protected append writes to block and append blobs to the container. Defaults to `false`. Cannot be set with `protectedAppendWritesEnabled`.
	ProtectedAppendWritesAllEnabled *bool `pulumi:"protectedAppendWritesAllEnabled"`
	// Whether to allow protected append writes to append blobs to the container. Defaults to `false`. Cannot be set with `protectedAppendWritesAllEnabled`.
	ProtectedAppendWritesEnabled *bool `pulumi:"protectedAppendWritesEnabled"`
	// The Resource Manager ID of the Storage Container where this Immutability Policy should be applied. Changing this forces a new resource to be created.
	StorageContainerResourceManagerId *string `pulumi:"storageContainerResourceManagerId"`
}

type ContainerImmutabilityPolicyState struct {
	// The time interval in days that the data needs to be kept in a non-erasable and non-modifiable state.
	ImmutabilityPeriodInDays pulumi.IntPtrInput
	// Whether to lock this immutability policy. Cannot be set to `false` once the policy has been locked.
	//
	// !> **Note:** Once an Immutability Policy has been locked, it cannot be unlocked. After locking, it will only be possible to increase the value for `retentionPeriodInDays` up to 5 times for the lifetime of the policy. No other properties will be updateable. Furthermore, the Storage Container and the Storage Account in which it resides will become protected by the policy. It will no longer be possible to delete the Storage Container or the Storage Account. Please refer to [official documentation](https://learn.microsoft.com/en-us/azure/storage/blobs/immutable-policy-configure-container-scope?tabs=azure-portal#lock-a-time-based-retention-policy) for more information.
	Locked pulumi.BoolPtrInput
	// Whether to allow protected append writes to block and append blobs to the container. Defaults to `false`. Cannot be set with `protectedAppendWritesEnabled`.
	ProtectedAppendWritesAllEnabled pulumi.BoolPtrInput
	// Whether to allow protected append writes to append blobs to the container. Defaults to `false`. Cannot be set with `protectedAppendWritesAllEnabled`.
	ProtectedAppendWritesEnabled pulumi.BoolPtrInput
	// The Resource Manager ID of the Storage Container where this Immutability Policy should be applied. Changing this forces a new resource to be created.
	StorageContainerResourceManagerId pulumi.StringPtrInput
}

func (ContainerImmutabilityPolicyState) ElementType() reflect.Type {
	return reflect.TypeOf((*containerImmutabilityPolicyState)(nil)).Elem()
}

type containerImmutabilityPolicyArgs struct {
	// The time interval in days that the data needs to be kept in a non-erasable and non-modifiable state.
	ImmutabilityPeriodInDays int `pulumi:"immutabilityPeriodInDays"`
	// Whether to lock this immutability policy. Cannot be set to `false` once the policy has been locked.
	//
	// !> **Note:** Once an Immutability Policy has been locked, it cannot be unlocked. After locking, it will only be possible to increase the value for `retentionPeriodInDays` up to 5 times for the lifetime of the policy. No other properties will be updateable. Furthermore, the Storage Container and the Storage Account in which it resides will become protected by the policy. It will no longer be possible to delete the Storage Container or the Storage Account. Please refer to [official documentation](https://learn.microsoft.com/en-us/azure/storage/blobs/immutable-policy-configure-container-scope?tabs=azure-portal#lock-a-time-based-retention-policy) for more information.
	Locked *bool `pulumi:"locked"`
	// Whether to allow protected append writes to block and append blobs to the container. Defaults to `false`. Cannot be set with `protectedAppendWritesEnabled`.
	ProtectedAppendWritesAllEnabled *bool `pulumi:"protectedAppendWritesAllEnabled"`
	// Whether to allow protected append writes to append blobs to the container. Defaults to `false`. Cannot be set with `protectedAppendWritesAllEnabled`.
	ProtectedAppendWritesEnabled *bool `pulumi:"protectedAppendWritesEnabled"`
	// The Resource Manager ID of the Storage Container where this Immutability Policy should be applied. Changing this forces a new resource to be created.
	StorageContainerResourceManagerId string `pulumi:"storageContainerResourceManagerId"`
}

// The set of arguments for constructing a ContainerImmutabilityPolicy resource.
type ContainerImmutabilityPolicyArgs struct {
	// The time interval in days that the data needs to be kept in a non-erasable and non-modifiable state.
	ImmutabilityPeriodInDays pulumi.IntInput
	// Whether to lock this immutability policy. Cannot be set to `false` once the policy has been locked.
	//
	// !> **Note:** Once an Immutability Policy has been locked, it cannot be unlocked. After locking, it will only be possible to increase the value for `retentionPeriodInDays` up to 5 times for the lifetime of the policy. No other properties will be updateable. Furthermore, the Storage Container and the Storage Account in which it resides will become protected by the policy. It will no longer be possible to delete the Storage Container or the Storage Account. Please refer to [official documentation](https://learn.microsoft.com/en-us/azure/storage/blobs/immutable-policy-configure-container-scope?tabs=azure-portal#lock-a-time-based-retention-policy) for more information.
	Locked pulumi.BoolPtrInput
	// Whether to allow protected append writes to block and append blobs to the container. Defaults to `false`. Cannot be set with `protectedAppendWritesEnabled`.
	ProtectedAppendWritesAllEnabled pulumi.BoolPtrInput
	// Whether to allow protected append writes to append blobs to the container. Defaults to `false`. Cannot be set with `protectedAppendWritesAllEnabled`.
	ProtectedAppendWritesEnabled pulumi.BoolPtrInput
	// The Resource Manager ID of the Storage Container where this Immutability Policy should be applied. Changing this forces a new resource to be created.
	StorageContainerResourceManagerId pulumi.StringInput
}

func (ContainerImmutabilityPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*containerImmutabilityPolicyArgs)(nil)).Elem()
}

type ContainerImmutabilityPolicyInput interface {
	pulumi.Input

	ToContainerImmutabilityPolicyOutput() ContainerImmutabilityPolicyOutput
	ToContainerImmutabilityPolicyOutputWithContext(ctx context.Context) ContainerImmutabilityPolicyOutput
}

func (*ContainerImmutabilityPolicy) ElementType() reflect.Type {
	return reflect.TypeOf((**ContainerImmutabilityPolicy)(nil)).Elem()
}

func (i *ContainerImmutabilityPolicy) ToContainerImmutabilityPolicyOutput() ContainerImmutabilityPolicyOutput {
	return i.ToContainerImmutabilityPolicyOutputWithContext(context.Background())
}

func (i *ContainerImmutabilityPolicy) ToContainerImmutabilityPolicyOutputWithContext(ctx context.Context) ContainerImmutabilityPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerImmutabilityPolicyOutput)
}

// ContainerImmutabilityPolicyArrayInput is an input type that accepts ContainerImmutabilityPolicyArray and ContainerImmutabilityPolicyArrayOutput values.
// You can construct a concrete instance of `ContainerImmutabilityPolicyArrayInput` via:
//
//	ContainerImmutabilityPolicyArray{ ContainerImmutabilityPolicyArgs{...} }
type ContainerImmutabilityPolicyArrayInput interface {
	pulumi.Input

	ToContainerImmutabilityPolicyArrayOutput() ContainerImmutabilityPolicyArrayOutput
	ToContainerImmutabilityPolicyArrayOutputWithContext(context.Context) ContainerImmutabilityPolicyArrayOutput
}

type ContainerImmutabilityPolicyArray []ContainerImmutabilityPolicyInput

func (ContainerImmutabilityPolicyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ContainerImmutabilityPolicy)(nil)).Elem()
}

func (i ContainerImmutabilityPolicyArray) ToContainerImmutabilityPolicyArrayOutput() ContainerImmutabilityPolicyArrayOutput {
	return i.ToContainerImmutabilityPolicyArrayOutputWithContext(context.Background())
}

func (i ContainerImmutabilityPolicyArray) ToContainerImmutabilityPolicyArrayOutputWithContext(ctx context.Context) ContainerImmutabilityPolicyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerImmutabilityPolicyArrayOutput)
}

// ContainerImmutabilityPolicyMapInput is an input type that accepts ContainerImmutabilityPolicyMap and ContainerImmutabilityPolicyMapOutput values.
// You can construct a concrete instance of `ContainerImmutabilityPolicyMapInput` via:
//
//	ContainerImmutabilityPolicyMap{ "key": ContainerImmutabilityPolicyArgs{...} }
type ContainerImmutabilityPolicyMapInput interface {
	pulumi.Input

	ToContainerImmutabilityPolicyMapOutput() ContainerImmutabilityPolicyMapOutput
	ToContainerImmutabilityPolicyMapOutputWithContext(context.Context) ContainerImmutabilityPolicyMapOutput
}

type ContainerImmutabilityPolicyMap map[string]ContainerImmutabilityPolicyInput

func (ContainerImmutabilityPolicyMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ContainerImmutabilityPolicy)(nil)).Elem()
}

func (i ContainerImmutabilityPolicyMap) ToContainerImmutabilityPolicyMapOutput() ContainerImmutabilityPolicyMapOutput {
	return i.ToContainerImmutabilityPolicyMapOutputWithContext(context.Background())
}

func (i ContainerImmutabilityPolicyMap) ToContainerImmutabilityPolicyMapOutputWithContext(ctx context.Context) ContainerImmutabilityPolicyMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerImmutabilityPolicyMapOutput)
}

type ContainerImmutabilityPolicyOutput struct{ *pulumi.OutputState }

func (ContainerImmutabilityPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ContainerImmutabilityPolicy)(nil)).Elem()
}

func (o ContainerImmutabilityPolicyOutput) ToContainerImmutabilityPolicyOutput() ContainerImmutabilityPolicyOutput {
	return o
}

func (o ContainerImmutabilityPolicyOutput) ToContainerImmutabilityPolicyOutputWithContext(ctx context.Context) ContainerImmutabilityPolicyOutput {
	return o
}

// The time interval in days that the data needs to be kept in a non-erasable and non-modifiable state.
func (o ContainerImmutabilityPolicyOutput) ImmutabilityPeriodInDays() pulumi.IntOutput {
	return o.ApplyT(func(v *ContainerImmutabilityPolicy) pulumi.IntOutput { return v.ImmutabilityPeriodInDays }).(pulumi.IntOutput)
}

// Whether to lock this immutability policy. Cannot be set to `false` once the policy has been locked.
//
// !> **Note:** Once an Immutability Policy has been locked, it cannot be unlocked. After locking, it will only be possible to increase the value for `retentionPeriodInDays` up to 5 times for the lifetime of the policy. No other properties will be updateable. Furthermore, the Storage Container and the Storage Account in which it resides will become protected by the policy. It will no longer be possible to delete the Storage Container or the Storage Account. Please refer to [official documentation](https://learn.microsoft.com/en-us/azure/storage/blobs/immutable-policy-configure-container-scope?tabs=azure-portal#lock-a-time-based-retention-policy) for more information.
func (o ContainerImmutabilityPolicyOutput) Locked() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ContainerImmutabilityPolicy) pulumi.BoolPtrOutput { return v.Locked }).(pulumi.BoolPtrOutput)
}

// Whether to allow protected append writes to block and append blobs to the container. Defaults to `false`. Cannot be set with `protectedAppendWritesEnabled`.
func (o ContainerImmutabilityPolicyOutput) ProtectedAppendWritesAllEnabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ContainerImmutabilityPolicy) pulumi.BoolPtrOutput { return v.ProtectedAppendWritesAllEnabled }).(pulumi.BoolPtrOutput)
}

// Whether to allow protected append writes to append blobs to the container. Defaults to `false`. Cannot be set with `protectedAppendWritesAllEnabled`.
func (o ContainerImmutabilityPolicyOutput) ProtectedAppendWritesEnabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ContainerImmutabilityPolicy) pulumi.BoolPtrOutput { return v.ProtectedAppendWritesEnabled }).(pulumi.BoolPtrOutput)
}

// The Resource Manager ID of the Storage Container where this Immutability Policy should be applied. Changing this forces a new resource to be created.
func (o ContainerImmutabilityPolicyOutput) StorageContainerResourceManagerId() pulumi.StringOutput {
	return o.ApplyT(func(v *ContainerImmutabilityPolicy) pulumi.StringOutput { return v.StorageContainerResourceManagerId }).(pulumi.StringOutput)
}

type ContainerImmutabilityPolicyArrayOutput struct{ *pulumi.OutputState }

func (ContainerImmutabilityPolicyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ContainerImmutabilityPolicy)(nil)).Elem()
}

func (o ContainerImmutabilityPolicyArrayOutput) ToContainerImmutabilityPolicyArrayOutput() ContainerImmutabilityPolicyArrayOutput {
	return o
}

func (o ContainerImmutabilityPolicyArrayOutput) ToContainerImmutabilityPolicyArrayOutputWithContext(ctx context.Context) ContainerImmutabilityPolicyArrayOutput {
	return o
}

func (o ContainerImmutabilityPolicyArrayOutput) Index(i pulumi.IntInput) ContainerImmutabilityPolicyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ContainerImmutabilityPolicy {
		return vs[0].([]*ContainerImmutabilityPolicy)[vs[1].(int)]
	}).(ContainerImmutabilityPolicyOutput)
}

type ContainerImmutabilityPolicyMapOutput struct{ *pulumi.OutputState }

func (ContainerImmutabilityPolicyMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ContainerImmutabilityPolicy)(nil)).Elem()
}

func (o ContainerImmutabilityPolicyMapOutput) ToContainerImmutabilityPolicyMapOutput() ContainerImmutabilityPolicyMapOutput {
	return o
}

func (o ContainerImmutabilityPolicyMapOutput) ToContainerImmutabilityPolicyMapOutputWithContext(ctx context.Context) ContainerImmutabilityPolicyMapOutput {
	return o
}

func (o ContainerImmutabilityPolicyMapOutput) MapIndex(k pulumi.StringInput) ContainerImmutabilityPolicyOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ContainerImmutabilityPolicy {
		return vs[0].(map[string]*ContainerImmutabilityPolicy)[vs[1].(string)]
	}).(ContainerImmutabilityPolicyOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerImmutabilityPolicyInput)(nil)).Elem(), &ContainerImmutabilityPolicy{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerImmutabilityPolicyArrayInput)(nil)).Elem(), ContainerImmutabilityPolicyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerImmutabilityPolicyMapInput)(nil)).Elem(), ContainerImmutabilityPolicyMap{})
	pulumi.RegisterOutputType(ContainerImmutabilityPolicyOutput{})
	pulumi.RegisterOutputType(ContainerImmutabilityPolicyArrayOutput{})
	pulumi.RegisterOutputType(ContainerImmutabilityPolicyMapOutput{})
}
