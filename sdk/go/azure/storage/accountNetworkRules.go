// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package storage

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-azure/sdk/v6/go/azure/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages network rules inside of a Azure Storage Account.
//
// > **Note:** Network Rules can be defined either directly on the `storage.Account` resource, or using the `storage.AccountNetworkRules` resource - but the two cannot be used together. Spurious changes will occur if both are used against the same Storage Account.
//
// > **Note:** Only one `storage.AccountNetworkRules` can be tied to an `storage.Account`. Spurious changes will occur if more than `storage.AccountNetworkRules` is tied to the same `storage.Account`.
//
// > **Note:** Deleting this resource updates the storage account back to the default values it had when the storage account was created.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-azure/sdk/v6/go/azure/core"
//	"github.com/pulumi/pulumi-azure/sdk/v6/go/azure/network"
//	"github.com/pulumi/pulumi-azure/sdk/v6/go/azure/storage"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			example, err := core.NewResourceGroup(ctx, "example", &core.ResourceGroupArgs{
//				Name:     pulumi.String("example-resources"),
//				Location: pulumi.String("West Europe"),
//			})
//			if err != nil {
//				return err
//			}
//			exampleVirtualNetwork, err := network.NewVirtualNetwork(ctx, "example", &network.VirtualNetworkArgs{
//				Name: pulumi.String("example-vnet"),
//				AddressSpaces: pulumi.StringArray{
//					pulumi.String("10.0.0.0/16"),
//				},
//				Location:          example.Location,
//				ResourceGroupName: example.Name,
//			})
//			if err != nil {
//				return err
//			}
//			exampleSubnet, err := network.NewSubnet(ctx, "example", &network.SubnetArgs{
//				Name:               pulumi.String("example-subnet"),
//				ResourceGroupName:  example.Name,
//				VirtualNetworkName: exampleVirtualNetwork.Name,
//				AddressPrefixes: pulumi.StringArray{
//					pulumi.String("10.0.2.0/24"),
//				},
//				ServiceEndpoints: pulumi.StringArray{
//					pulumi.String("Microsoft.Storage"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			exampleAccount, err := storage.NewAccount(ctx, "example", &storage.AccountArgs{
//				Name:                   pulumi.String("storageaccountname"),
//				ResourceGroupName:      example.Name,
//				Location:               example.Location,
//				AccountTier:            pulumi.String("Standard"),
//				AccountReplicationType: pulumi.String("GRS"),
//				Tags: pulumi.StringMap{
//					"environment": pulumi.String("staging"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = storage.NewAccountNetworkRules(ctx, "example", &storage.AccountNetworkRulesArgs{
//				StorageAccountId: exampleAccount.ID(),
//				DefaultAction:    pulumi.String("Allow"),
//				IpRules: pulumi.StringArray{
//					pulumi.String("127.0.0.1"),
//				},
//				VirtualNetworkSubnetIds: pulumi.StringArray{
//					exampleSubnet.ID(),
//				},
//				Bypasses: pulumi.StringArray{
//					pulumi.String("Metrics"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## API Providers
//
// <!-- This section is generated, changes will be overwritten -->
// This resource uses the following Azure API Providers:
//
// * `Microsoft.Storage`: 2023-05-01
//
// ## Import
//
// Storage Account Network Rules can be imported using the `resource id`, e.g.
//
// ```sh
// $ pulumi import azure:storage/accountNetworkRules:AccountNetworkRules storageAcc1 /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/myresourcegroup/providers/Microsoft.Storage/storageAccounts/myaccount
// ```
type AccountNetworkRules struct {
	pulumi.CustomResourceState

	// Specifies whether traffic is bypassed for Logging/Metrics/AzureServices. Valid options are any combination of `Logging`, `Metrics`, `AzureServices`, or `None`. Defaults to `["AzureServices"]`.
	//
	// > **Note:** User has to explicitly set `bypass` to empty slice (`[]`) to remove it.
	Bypasses pulumi.StringArrayOutput `pulumi:"bypasses"`
	// Specifies the default action of allow or deny when no other rules match. Valid options are `Deny` or `Allow`.
	DefaultAction pulumi.StringOutput `pulumi:"defaultAction"`
	// List of public IP or IP ranges in CIDR Format. Only IPv4 addresses are allowed. Private IP address ranges (as defined in [RFC 1918](https://tools.ietf.org/html/rfc1918#section-3)) are not allowed.
	//
	// > **Note:** Small address ranges using "/31" or "/32" prefix sizes are not supported. These ranges should be configured using individual IP address rules without prefix specified.
	//
	// > **Note:** IP network rules have no effect on requests originating from the same Azure region as the storage account. Use Virtual network rules to allow same-region requests. Services deployed in the same region as the storage account use private Azure IP addresses for communication. Thus, you cannot restrict access to specific Azure services based on their public outbound IP address range.
	//
	// > **Note:** User has to explicitly set `ipRules` to empty slice (`[]`) to remove it.
	IpRules pulumi.StringArrayOutput `pulumi:"ipRules"`
	// One or more `privateLinkAccess` block as defined below.
	PrivateLinkAccessRules AccountNetworkRulesPrivateLinkAccessRuleArrayOutput `pulumi:"privateLinkAccessRules"`
	// Specifies the ID of the storage account. Changing this forces a new resource to be created.
	StorageAccountId pulumi.StringOutput `pulumi:"storageAccountId"`
	// A list of virtual network subnet ids to secure the storage account.
	//
	// > **Note:** User has to explicitly set `virtualNetworkSubnetIds` to empty slice (`[]`) to remove it.
	VirtualNetworkSubnetIds pulumi.StringArrayOutput `pulumi:"virtualNetworkSubnetIds"`
}

// NewAccountNetworkRules registers a new resource with the given unique name, arguments, and options.
func NewAccountNetworkRules(ctx *pulumi.Context,
	name string, args *AccountNetworkRulesArgs, opts ...pulumi.ResourceOption) (*AccountNetworkRules, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.DefaultAction == nil {
		return nil, errors.New("invalid value for required argument 'DefaultAction'")
	}
	if args.StorageAccountId == nil {
		return nil, errors.New("invalid value for required argument 'StorageAccountId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource AccountNetworkRules
	err := ctx.RegisterResource("azure:storage/accountNetworkRules:AccountNetworkRules", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetAccountNetworkRules gets an existing AccountNetworkRules resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetAccountNetworkRules(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *AccountNetworkRulesState, opts ...pulumi.ResourceOption) (*AccountNetworkRules, error) {
	var resource AccountNetworkRules
	err := ctx.ReadResource("azure:storage/accountNetworkRules:AccountNetworkRules", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering AccountNetworkRules resources.
type accountNetworkRulesState struct {
	// Specifies whether traffic is bypassed for Logging/Metrics/AzureServices. Valid options are any combination of `Logging`, `Metrics`, `AzureServices`, or `None`. Defaults to `["AzureServices"]`.
	//
	// > **Note:** User has to explicitly set `bypass` to empty slice (`[]`) to remove it.
	Bypasses []string `pulumi:"bypasses"`
	// Specifies the default action of allow or deny when no other rules match. Valid options are `Deny` or `Allow`.
	DefaultAction *string `pulumi:"defaultAction"`
	// List of public IP or IP ranges in CIDR Format. Only IPv4 addresses are allowed. Private IP address ranges (as defined in [RFC 1918](https://tools.ietf.org/html/rfc1918#section-3)) are not allowed.
	//
	// > **Note:** Small address ranges using "/31" or "/32" prefix sizes are not supported. These ranges should be configured using individual IP address rules without prefix specified.
	//
	// > **Note:** IP network rules have no effect on requests originating from the same Azure region as the storage account. Use Virtual network rules to allow same-region requests. Services deployed in the same region as the storage account use private Azure IP addresses for communication. Thus, you cannot restrict access to specific Azure services based on their public outbound IP address range.
	//
	// > **Note:** User has to explicitly set `ipRules` to empty slice (`[]`) to remove it.
	IpRules []string `pulumi:"ipRules"`
	// One or more `privateLinkAccess` block as defined below.
	PrivateLinkAccessRules []AccountNetworkRulesPrivateLinkAccessRule `pulumi:"privateLinkAccessRules"`
	// Specifies the ID of the storage account. Changing this forces a new resource to be created.
	StorageAccountId *string `pulumi:"storageAccountId"`
	// A list of virtual network subnet ids to secure the storage account.
	//
	// > **Note:** User has to explicitly set `virtualNetworkSubnetIds` to empty slice (`[]`) to remove it.
	VirtualNetworkSubnetIds []string `pulumi:"virtualNetworkSubnetIds"`
}

type AccountNetworkRulesState struct {
	// Specifies whether traffic is bypassed for Logging/Metrics/AzureServices. Valid options are any combination of `Logging`, `Metrics`, `AzureServices`, or `None`. Defaults to `["AzureServices"]`.
	//
	// > **Note:** User has to explicitly set `bypass` to empty slice (`[]`) to remove it.
	Bypasses pulumi.StringArrayInput
	// Specifies the default action of allow or deny when no other rules match. Valid options are `Deny` or `Allow`.
	DefaultAction pulumi.StringPtrInput
	// List of public IP or IP ranges in CIDR Format. Only IPv4 addresses are allowed. Private IP address ranges (as defined in [RFC 1918](https://tools.ietf.org/html/rfc1918#section-3)) are not allowed.
	//
	// > **Note:** Small address ranges using "/31" or "/32" prefix sizes are not supported. These ranges should be configured using individual IP address rules without prefix specified.
	//
	// > **Note:** IP network rules have no effect on requests originating from the same Azure region as the storage account. Use Virtual network rules to allow same-region requests. Services deployed in the same region as the storage account use private Azure IP addresses for communication. Thus, you cannot restrict access to specific Azure services based on their public outbound IP address range.
	//
	// > **Note:** User has to explicitly set `ipRules` to empty slice (`[]`) to remove it.
	IpRules pulumi.StringArrayInput
	// One or more `privateLinkAccess` block as defined below.
	PrivateLinkAccessRules AccountNetworkRulesPrivateLinkAccessRuleArrayInput
	// Specifies the ID of the storage account. Changing this forces a new resource to be created.
	StorageAccountId pulumi.StringPtrInput
	// A list of virtual network subnet ids to secure the storage account.
	//
	// > **Note:** User has to explicitly set `virtualNetworkSubnetIds` to empty slice (`[]`) to remove it.
	VirtualNetworkSubnetIds pulumi.StringArrayInput
}

func (AccountNetworkRulesState) ElementType() reflect.Type {
	return reflect.TypeOf((*accountNetworkRulesState)(nil)).Elem()
}

type accountNetworkRulesArgs struct {
	// Specifies whether traffic is bypassed for Logging/Metrics/AzureServices. Valid options are any combination of `Logging`, `Metrics`, `AzureServices`, or `None`. Defaults to `["AzureServices"]`.
	//
	// > **Note:** User has to explicitly set `bypass` to empty slice (`[]`) to remove it.
	Bypasses []string `pulumi:"bypasses"`
	// Specifies the default action of allow or deny when no other rules match. Valid options are `Deny` or `Allow`.
	DefaultAction string `pulumi:"defaultAction"`
	// List of public IP or IP ranges in CIDR Format. Only IPv4 addresses are allowed. Private IP address ranges (as defined in [RFC 1918](https://tools.ietf.org/html/rfc1918#section-3)) are not allowed.
	//
	// > **Note:** Small address ranges using "/31" or "/32" prefix sizes are not supported. These ranges should be configured using individual IP address rules without prefix specified.
	//
	// > **Note:** IP network rules have no effect on requests originating from the same Azure region as the storage account. Use Virtual network rules to allow same-region requests. Services deployed in the same region as the storage account use private Azure IP addresses for communication. Thus, you cannot restrict access to specific Azure services based on their public outbound IP address range.
	//
	// > **Note:** User has to explicitly set `ipRules` to empty slice (`[]`) to remove it.
	IpRules []string `pulumi:"ipRules"`
	// One or more `privateLinkAccess` block as defined below.
	PrivateLinkAccessRules []AccountNetworkRulesPrivateLinkAccessRule `pulumi:"privateLinkAccessRules"`
	// Specifies the ID of the storage account. Changing this forces a new resource to be created.
	StorageAccountId string `pulumi:"storageAccountId"`
	// A list of virtual network subnet ids to secure the storage account.
	//
	// > **Note:** User has to explicitly set `virtualNetworkSubnetIds` to empty slice (`[]`) to remove it.
	VirtualNetworkSubnetIds []string `pulumi:"virtualNetworkSubnetIds"`
}

// The set of arguments for constructing a AccountNetworkRules resource.
type AccountNetworkRulesArgs struct {
	// Specifies whether traffic is bypassed for Logging/Metrics/AzureServices. Valid options are any combination of `Logging`, `Metrics`, `AzureServices`, or `None`. Defaults to `["AzureServices"]`.
	//
	// > **Note:** User has to explicitly set `bypass` to empty slice (`[]`) to remove it.
	Bypasses pulumi.StringArrayInput
	// Specifies the default action of allow or deny when no other rules match. Valid options are `Deny` or `Allow`.
	DefaultAction pulumi.StringInput
	// List of public IP or IP ranges in CIDR Format. Only IPv4 addresses are allowed. Private IP address ranges (as defined in [RFC 1918](https://tools.ietf.org/html/rfc1918#section-3)) are not allowed.
	//
	// > **Note:** Small address ranges using "/31" or "/32" prefix sizes are not supported. These ranges should be configured using individual IP address rules without prefix specified.
	//
	// > **Note:** IP network rules have no effect on requests originating from the same Azure region as the storage account. Use Virtual network rules to allow same-region requests. Services deployed in the same region as the storage account use private Azure IP addresses for communication. Thus, you cannot restrict access to specific Azure services based on their public outbound IP address range.
	//
	// > **Note:** User has to explicitly set `ipRules` to empty slice (`[]`) to remove it.
	IpRules pulumi.StringArrayInput
	// One or more `privateLinkAccess` block as defined below.
	PrivateLinkAccessRules AccountNetworkRulesPrivateLinkAccessRuleArrayInput
	// Specifies the ID of the storage account. Changing this forces a new resource to be created.
	StorageAccountId pulumi.StringInput
	// A list of virtual network subnet ids to secure the storage account.
	//
	// > **Note:** User has to explicitly set `virtualNetworkSubnetIds` to empty slice (`[]`) to remove it.
	VirtualNetworkSubnetIds pulumi.StringArrayInput
}

func (AccountNetworkRulesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*accountNetworkRulesArgs)(nil)).Elem()
}

type AccountNetworkRulesInput interface {
	pulumi.Input

	ToAccountNetworkRulesOutput() AccountNetworkRulesOutput
	ToAccountNetworkRulesOutputWithContext(ctx context.Context) AccountNetworkRulesOutput
}

func (*AccountNetworkRules) ElementType() reflect.Type {
	return reflect.TypeOf((**AccountNetworkRules)(nil)).Elem()
}

func (i *AccountNetworkRules) ToAccountNetworkRulesOutput() AccountNetworkRulesOutput {
	return i.ToAccountNetworkRulesOutputWithContext(context.Background())
}

func (i *AccountNetworkRules) ToAccountNetworkRulesOutputWithContext(ctx context.Context) AccountNetworkRulesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AccountNetworkRulesOutput)
}

// AccountNetworkRulesArrayInput is an input type that accepts AccountNetworkRulesArray and AccountNetworkRulesArrayOutput values.
// You can construct a concrete instance of `AccountNetworkRulesArrayInput` via:
//
//	AccountNetworkRulesArray{ AccountNetworkRulesArgs{...} }
type AccountNetworkRulesArrayInput interface {
	pulumi.Input

	ToAccountNetworkRulesArrayOutput() AccountNetworkRulesArrayOutput
	ToAccountNetworkRulesArrayOutputWithContext(context.Context) AccountNetworkRulesArrayOutput
}

type AccountNetworkRulesArray []AccountNetworkRulesInput

func (AccountNetworkRulesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AccountNetworkRules)(nil)).Elem()
}

func (i AccountNetworkRulesArray) ToAccountNetworkRulesArrayOutput() AccountNetworkRulesArrayOutput {
	return i.ToAccountNetworkRulesArrayOutputWithContext(context.Background())
}

func (i AccountNetworkRulesArray) ToAccountNetworkRulesArrayOutputWithContext(ctx context.Context) AccountNetworkRulesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AccountNetworkRulesArrayOutput)
}

// AccountNetworkRulesMapInput is an input type that accepts AccountNetworkRulesMap and AccountNetworkRulesMapOutput values.
// You can construct a concrete instance of `AccountNetworkRulesMapInput` via:
//
//	AccountNetworkRulesMap{ "key": AccountNetworkRulesArgs{...} }
type AccountNetworkRulesMapInput interface {
	pulumi.Input

	ToAccountNetworkRulesMapOutput() AccountNetworkRulesMapOutput
	ToAccountNetworkRulesMapOutputWithContext(context.Context) AccountNetworkRulesMapOutput
}

type AccountNetworkRulesMap map[string]AccountNetworkRulesInput

func (AccountNetworkRulesMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AccountNetworkRules)(nil)).Elem()
}

func (i AccountNetworkRulesMap) ToAccountNetworkRulesMapOutput() AccountNetworkRulesMapOutput {
	return i.ToAccountNetworkRulesMapOutputWithContext(context.Background())
}

func (i AccountNetworkRulesMap) ToAccountNetworkRulesMapOutputWithContext(ctx context.Context) AccountNetworkRulesMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AccountNetworkRulesMapOutput)
}

type AccountNetworkRulesOutput struct{ *pulumi.OutputState }

func (AccountNetworkRulesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AccountNetworkRules)(nil)).Elem()
}

func (o AccountNetworkRulesOutput) ToAccountNetworkRulesOutput() AccountNetworkRulesOutput {
	return o
}

func (o AccountNetworkRulesOutput) ToAccountNetworkRulesOutputWithContext(ctx context.Context) AccountNetworkRulesOutput {
	return o
}

// Specifies whether traffic is bypassed for Logging/Metrics/AzureServices. Valid options are any combination of `Logging`, `Metrics`, `AzureServices`, or `None`. Defaults to `["AzureServices"]`.
//
// > **Note:** User has to explicitly set `bypass` to empty slice (`[]`) to remove it.
func (o AccountNetworkRulesOutput) Bypasses() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *AccountNetworkRules) pulumi.StringArrayOutput { return v.Bypasses }).(pulumi.StringArrayOutput)
}

// Specifies the default action of allow or deny when no other rules match. Valid options are `Deny` or `Allow`.
func (o AccountNetworkRulesOutput) DefaultAction() pulumi.StringOutput {
	return o.ApplyT(func(v *AccountNetworkRules) pulumi.StringOutput { return v.DefaultAction }).(pulumi.StringOutput)
}

// List of public IP or IP ranges in CIDR Format. Only IPv4 addresses are allowed. Private IP address ranges (as defined in [RFC 1918](https://tools.ietf.org/html/rfc1918#section-3)) are not allowed.
//
// > **Note:** Small address ranges using "/31" or "/32" prefix sizes are not supported. These ranges should be configured using individual IP address rules without prefix specified.
//
// > **Note:** IP network rules have no effect on requests originating from the same Azure region as the storage account. Use Virtual network rules to allow same-region requests. Services deployed in the same region as the storage account use private Azure IP addresses for communication. Thus, you cannot restrict access to specific Azure services based on their public outbound IP address range.
//
// > **Note:** User has to explicitly set `ipRules` to empty slice (`[]`) to remove it.
func (o AccountNetworkRulesOutput) IpRules() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *AccountNetworkRules) pulumi.StringArrayOutput { return v.IpRules }).(pulumi.StringArrayOutput)
}

// One or more `privateLinkAccess` block as defined below.
func (o AccountNetworkRulesOutput) PrivateLinkAccessRules() AccountNetworkRulesPrivateLinkAccessRuleArrayOutput {
	return o.ApplyT(func(v *AccountNetworkRules) AccountNetworkRulesPrivateLinkAccessRuleArrayOutput {
		return v.PrivateLinkAccessRules
	}).(AccountNetworkRulesPrivateLinkAccessRuleArrayOutput)
}

// Specifies the ID of the storage account. Changing this forces a new resource to be created.
func (o AccountNetworkRulesOutput) StorageAccountId() pulumi.StringOutput {
	return o.ApplyT(func(v *AccountNetworkRules) pulumi.StringOutput { return v.StorageAccountId }).(pulumi.StringOutput)
}

// A list of virtual network subnet ids to secure the storage account.
//
// > **Note:** User has to explicitly set `virtualNetworkSubnetIds` to empty slice (`[]`) to remove it.
func (o AccountNetworkRulesOutput) VirtualNetworkSubnetIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *AccountNetworkRules) pulumi.StringArrayOutput { return v.VirtualNetworkSubnetIds }).(pulumi.StringArrayOutput)
}

type AccountNetworkRulesArrayOutput struct{ *pulumi.OutputState }

func (AccountNetworkRulesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AccountNetworkRules)(nil)).Elem()
}

func (o AccountNetworkRulesArrayOutput) ToAccountNetworkRulesArrayOutput() AccountNetworkRulesArrayOutput {
	return o
}

func (o AccountNetworkRulesArrayOutput) ToAccountNetworkRulesArrayOutputWithContext(ctx context.Context) AccountNetworkRulesArrayOutput {
	return o
}

func (o AccountNetworkRulesArrayOutput) Index(i pulumi.IntInput) AccountNetworkRulesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *AccountNetworkRules {
		return vs[0].([]*AccountNetworkRules)[vs[1].(int)]
	}).(AccountNetworkRulesOutput)
}

type AccountNetworkRulesMapOutput struct{ *pulumi.OutputState }

func (AccountNetworkRulesMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AccountNetworkRules)(nil)).Elem()
}

func (o AccountNetworkRulesMapOutput) ToAccountNetworkRulesMapOutput() AccountNetworkRulesMapOutput {
	return o
}

func (o AccountNetworkRulesMapOutput) ToAccountNetworkRulesMapOutputWithContext(ctx context.Context) AccountNetworkRulesMapOutput {
	return o
}

func (o AccountNetworkRulesMapOutput) MapIndex(k pulumi.StringInput) AccountNetworkRulesOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *AccountNetworkRules {
		return vs[0].(map[string]*AccountNetworkRules)[vs[1].(string)]
	}).(AccountNetworkRulesOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AccountNetworkRulesInput)(nil)).Elem(), &AccountNetworkRules{})
	pulumi.RegisterInputType(reflect.TypeOf((*AccountNetworkRulesArrayInput)(nil)).Elem(), AccountNetworkRulesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AccountNetworkRulesMapInput)(nil)).Elem(), AccountNetworkRulesMap{})
	pulumi.RegisterOutputType(AccountNetworkRulesOutput{})
	pulumi.RegisterOutputType(AccountNetworkRulesArrayOutput{})
	pulumi.RegisterOutputType(AccountNetworkRulesMapOutput{})
}
