// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package network

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-azure/sdk/v6/go/azure/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages an Azure Route Server
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-azure/sdk/v6/go/azure/core"
//	"github.com/pulumi/pulumi-azure/sdk/v6/go/azure/network"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			example, err := core.NewResourceGroup(ctx, "example", &core.ResourceGroupArgs{
//				Name:     pulumi.String("example-resources"),
//				Location: pulumi.String("West Europe"),
//			})
//			if err != nil {
//				return err
//			}
//			exampleVirtualNetwork, err := network.NewVirtualNetwork(ctx, "example", &network.VirtualNetworkArgs{
//				Name: pulumi.String("example-vn"),
//				AddressSpaces: pulumi.StringArray{
//					pulumi.String("10.0.0.0/16"),
//				},
//				ResourceGroupName: example.Name,
//				Location:          example.Location,
//				Tags: pulumi.StringMap{
//					"environment": pulumi.String("Production"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			exampleSubnet, err := network.NewSubnet(ctx, "example", &network.SubnetArgs{
//				Name:               pulumi.String("RouteServerSubnet"),
//				VirtualNetworkName: exampleVirtualNetwork.Name,
//				ResourceGroupName:  example.Name,
//				AddressPrefixes: pulumi.StringArray{
//					pulumi.String("10.0.1.0/24"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			examplePublicIp, err := network.NewPublicIp(ctx, "example", &network.PublicIpArgs{
//				Name:              pulumi.String("example-pip"),
//				ResourceGroupName: example.Name,
//				Location:          example.Location,
//				AllocationMethod:  pulumi.String("Static"),
//				Sku:               pulumi.String("Standard"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = network.NewRouteServer(ctx, "example", &network.RouteServerArgs{
//				Name:                         pulumi.String("example-routerserver"),
//				ResourceGroupName:            example.Name,
//				Location:                     example.Location,
//				Sku:                          pulumi.String("Standard"),
//				PublicIpAddressId:            examplePublicIp.ID(),
//				SubnetId:                     exampleSubnet.ID(),
//				BranchToBranchTrafficEnabled: pulumi.Bool(true),
//				HubRoutingPreference:         pulumi.String("ASPath"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Route Server can be imported using the `resource id`, e.g.
//
// ```sh
// $ pulumi import azure:network/routeServer:RouteServer example /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/group1/providers/Microsoft.Network/virtualHubs/routeServer1
// ```
type RouteServer struct {
	pulumi.CustomResourceState

	// Whether to enable route exchange between Azure Route Server and the gateway(s).
	BranchToBranchTrafficEnabled pulumi.BoolPtrOutput `pulumi:"branchToBranchTrafficEnabled"`
	// The hub routing preference. Valid values are `ASPath`, `ExpressRoute` or `VpnGateway`. Defaults to `ExpressRoute`.
	HubRoutingPreference pulumi.StringPtrOutput `pulumi:"hubRoutingPreference"`
	// Specifies the supported Azure location where the Route Server should exist. Changing this forces a new resource to be created.
	Location pulumi.StringOutput `pulumi:"location"`
	// The name of the Route Server. Changing this forces a new resource to be created.
	Name pulumi.StringOutput `pulumi:"name"`
	// The ID of the Public IP Address. This option is required since September 1st 2021. Changing this forces a new resource to be created.
	PublicIpAddressId pulumi.StringOutput `pulumi:"publicIpAddressId"`
	// Specifies the name of the Resource Group where the Route Server should exist. Changing this forces a new resource to be created.
	ResourceGroupName pulumi.StringOutput `pulumi:"resourceGroupName"`
	RoutingState      pulumi.StringOutput `pulumi:"routingState"`
	// The SKU of the Route Server. The only possible value is `Standard`. Changing this forces a new resource to be created.
	Sku pulumi.StringOutput `pulumi:"sku"`
	// The ID of the Subnet that the Route Server will reside. Changing this forces a new resource to be created.
	//
	// > **Note:** Azure Route Server requires a dedicated subnet named RouteServerSubnet. The subnet size has to be at least /27 or short prefix (such as /26 or /25) and cannot be attached to any security group, otherwise, you'll receive an error message when deploying the Route Server.
	SubnetId pulumi.StringOutput `pulumi:"subnetId"`
	// A mapping of tags to assign to the resource.
	Tags             pulumi.StringMapOutput   `pulumi:"tags"`
	VirtualRouterAsn pulumi.IntOutput         `pulumi:"virtualRouterAsn"`
	VirtualRouterIps pulumi.StringArrayOutput `pulumi:"virtualRouterIps"`
}

// NewRouteServer registers a new resource with the given unique name, arguments, and options.
func NewRouteServer(ctx *pulumi.Context,
	name string, args *RouteServerArgs, opts ...pulumi.ResourceOption) (*RouteServer, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.PublicIpAddressId == nil {
		return nil, errors.New("invalid value for required argument 'PublicIpAddressId'")
	}
	if args.ResourceGroupName == nil {
		return nil, errors.New("invalid value for required argument 'ResourceGroupName'")
	}
	if args.Sku == nil {
		return nil, errors.New("invalid value for required argument 'Sku'")
	}
	if args.SubnetId == nil {
		return nil, errors.New("invalid value for required argument 'SubnetId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource RouteServer
	err := ctx.RegisterResource("azure:network/routeServer:RouteServer", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetRouteServer gets an existing RouteServer resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetRouteServer(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *RouteServerState, opts ...pulumi.ResourceOption) (*RouteServer, error) {
	var resource RouteServer
	err := ctx.ReadResource("azure:network/routeServer:RouteServer", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering RouteServer resources.
type routeServerState struct {
	// Whether to enable route exchange between Azure Route Server and the gateway(s).
	BranchToBranchTrafficEnabled *bool `pulumi:"branchToBranchTrafficEnabled"`
	// The hub routing preference. Valid values are `ASPath`, `ExpressRoute` or `VpnGateway`. Defaults to `ExpressRoute`.
	HubRoutingPreference *string `pulumi:"hubRoutingPreference"`
	// Specifies the supported Azure location where the Route Server should exist. Changing this forces a new resource to be created.
	Location *string `pulumi:"location"`
	// The name of the Route Server. Changing this forces a new resource to be created.
	Name *string `pulumi:"name"`
	// The ID of the Public IP Address. This option is required since September 1st 2021. Changing this forces a new resource to be created.
	PublicIpAddressId *string `pulumi:"publicIpAddressId"`
	// Specifies the name of the Resource Group where the Route Server should exist. Changing this forces a new resource to be created.
	ResourceGroupName *string `pulumi:"resourceGroupName"`
	RoutingState      *string `pulumi:"routingState"`
	// The SKU of the Route Server. The only possible value is `Standard`. Changing this forces a new resource to be created.
	Sku *string `pulumi:"sku"`
	// The ID of the Subnet that the Route Server will reside. Changing this forces a new resource to be created.
	//
	// > **Note:** Azure Route Server requires a dedicated subnet named RouteServerSubnet. The subnet size has to be at least /27 or short prefix (such as /26 or /25) and cannot be attached to any security group, otherwise, you'll receive an error message when deploying the Route Server.
	SubnetId *string `pulumi:"subnetId"`
	// A mapping of tags to assign to the resource.
	Tags             map[string]string `pulumi:"tags"`
	VirtualRouterAsn *int              `pulumi:"virtualRouterAsn"`
	VirtualRouterIps []string          `pulumi:"virtualRouterIps"`
}

type RouteServerState struct {
	// Whether to enable route exchange between Azure Route Server and the gateway(s).
	BranchToBranchTrafficEnabled pulumi.BoolPtrInput
	// The hub routing preference. Valid values are `ASPath`, `ExpressRoute` or `VpnGateway`. Defaults to `ExpressRoute`.
	HubRoutingPreference pulumi.StringPtrInput
	// Specifies the supported Azure location where the Route Server should exist. Changing this forces a new resource to be created.
	Location pulumi.StringPtrInput
	// The name of the Route Server. Changing this forces a new resource to be created.
	Name pulumi.StringPtrInput
	// The ID of the Public IP Address. This option is required since September 1st 2021. Changing this forces a new resource to be created.
	PublicIpAddressId pulumi.StringPtrInput
	// Specifies the name of the Resource Group where the Route Server should exist. Changing this forces a new resource to be created.
	ResourceGroupName pulumi.StringPtrInput
	RoutingState      pulumi.StringPtrInput
	// The SKU of the Route Server. The only possible value is `Standard`. Changing this forces a new resource to be created.
	Sku pulumi.StringPtrInput
	// The ID of the Subnet that the Route Server will reside. Changing this forces a new resource to be created.
	//
	// > **Note:** Azure Route Server requires a dedicated subnet named RouteServerSubnet. The subnet size has to be at least /27 or short prefix (such as /26 or /25) and cannot be attached to any security group, otherwise, you'll receive an error message when deploying the Route Server.
	SubnetId pulumi.StringPtrInput
	// A mapping of tags to assign to the resource.
	Tags             pulumi.StringMapInput
	VirtualRouterAsn pulumi.IntPtrInput
	VirtualRouterIps pulumi.StringArrayInput
}

func (RouteServerState) ElementType() reflect.Type {
	return reflect.TypeOf((*routeServerState)(nil)).Elem()
}

type routeServerArgs struct {
	// Whether to enable route exchange between Azure Route Server and the gateway(s).
	BranchToBranchTrafficEnabled *bool `pulumi:"branchToBranchTrafficEnabled"`
	// The hub routing preference. Valid values are `ASPath`, `ExpressRoute` or `VpnGateway`. Defaults to `ExpressRoute`.
	HubRoutingPreference *string `pulumi:"hubRoutingPreference"`
	// Specifies the supported Azure location where the Route Server should exist. Changing this forces a new resource to be created.
	Location *string `pulumi:"location"`
	// The name of the Route Server. Changing this forces a new resource to be created.
	Name *string `pulumi:"name"`
	// The ID of the Public IP Address. This option is required since September 1st 2021. Changing this forces a new resource to be created.
	PublicIpAddressId string `pulumi:"publicIpAddressId"`
	// Specifies the name of the Resource Group where the Route Server should exist. Changing this forces a new resource to be created.
	ResourceGroupName string `pulumi:"resourceGroupName"`
	// The SKU of the Route Server. The only possible value is `Standard`. Changing this forces a new resource to be created.
	Sku string `pulumi:"sku"`
	// The ID of the Subnet that the Route Server will reside. Changing this forces a new resource to be created.
	//
	// > **Note:** Azure Route Server requires a dedicated subnet named RouteServerSubnet. The subnet size has to be at least /27 or short prefix (such as /26 or /25) and cannot be attached to any security group, otherwise, you'll receive an error message when deploying the Route Server.
	SubnetId string `pulumi:"subnetId"`
	// A mapping of tags to assign to the resource.
	Tags map[string]string `pulumi:"tags"`
}

// The set of arguments for constructing a RouteServer resource.
type RouteServerArgs struct {
	// Whether to enable route exchange between Azure Route Server and the gateway(s).
	BranchToBranchTrafficEnabled pulumi.BoolPtrInput
	// The hub routing preference. Valid values are `ASPath`, `ExpressRoute` or `VpnGateway`. Defaults to `ExpressRoute`.
	HubRoutingPreference pulumi.StringPtrInput
	// Specifies the supported Azure location where the Route Server should exist. Changing this forces a new resource to be created.
	Location pulumi.StringPtrInput
	// The name of the Route Server. Changing this forces a new resource to be created.
	Name pulumi.StringPtrInput
	// The ID of the Public IP Address. This option is required since September 1st 2021. Changing this forces a new resource to be created.
	PublicIpAddressId pulumi.StringInput
	// Specifies the name of the Resource Group where the Route Server should exist. Changing this forces a new resource to be created.
	ResourceGroupName pulumi.StringInput
	// The SKU of the Route Server. The only possible value is `Standard`. Changing this forces a new resource to be created.
	Sku pulumi.StringInput
	// The ID of the Subnet that the Route Server will reside. Changing this forces a new resource to be created.
	//
	// > **Note:** Azure Route Server requires a dedicated subnet named RouteServerSubnet. The subnet size has to be at least /27 or short prefix (such as /26 or /25) and cannot be attached to any security group, otherwise, you'll receive an error message when deploying the Route Server.
	SubnetId pulumi.StringInput
	// A mapping of tags to assign to the resource.
	Tags pulumi.StringMapInput
}

func (RouteServerArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*routeServerArgs)(nil)).Elem()
}

type RouteServerInput interface {
	pulumi.Input

	ToRouteServerOutput() RouteServerOutput
	ToRouteServerOutputWithContext(ctx context.Context) RouteServerOutput
}

func (*RouteServer) ElementType() reflect.Type {
	return reflect.TypeOf((**RouteServer)(nil)).Elem()
}

func (i *RouteServer) ToRouteServerOutput() RouteServerOutput {
	return i.ToRouteServerOutputWithContext(context.Background())
}

func (i *RouteServer) ToRouteServerOutputWithContext(ctx context.Context) RouteServerOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RouteServerOutput)
}

// RouteServerArrayInput is an input type that accepts RouteServerArray and RouteServerArrayOutput values.
// You can construct a concrete instance of `RouteServerArrayInput` via:
//
//	RouteServerArray{ RouteServerArgs{...} }
type RouteServerArrayInput interface {
	pulumi.Input

	ToRouteServerArrayOutput() RouteServerArrayOutput
	ToRouteServerArrayOutputWithContext(context.Context) RouteServerArrayOutput
}

type RouteServerArray []RouteServerInput

func (RouteServerArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*RouteServer)(nil)).Elem()
}

func (i RouteServerArray) ToRouteServerArrayOutput() RouteServerArrayOutput {
	return i.ToRouteServerArrayOutputWithContext(context.Background())
}

func (i RouteServerArray) ToRouteServerArrayOutputWithContext(ctx context.Context) RouteServerArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RouteServerArrayOutput)
}

// RouteServerMapInput is an input type that accepts RouteServerMap and RouteServerMapOutput values.
// You can construct a concrete instance of `RouteServerMapInput` via:
//
//	RouteServerMap{ "key": RouteServerArgs{...} }
type RouteServerMapInput interface {
	pulumi.Input

	ToRouteServerMapOutput() RouteServerMapOutput
	ToRouteServerMapOutputWithContext(context.Context) RouteServerMapOutput
}

type RouteServerMap map[string]RouteServerInput

func (RouteServerMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*RouteServer)(nil)).Elem()
}

func (i RouteServerMap) ToRouteServerMapOutput() RouteServerMapOutput {
	return i.ToRouteServerMapOutputWithContext(context.Background())
}

func (i RouteServerMap) ToRouteServerMapOutputWithContext(ctx context.Context) RouteServerMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RouteServerMapOutput)
}

type RouteServerOutput struct{ *pulumi.OutputState }

func (RouteServerOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RouteServer)(nil)).Elem()
}

func (o RouteServerOutput) ToRouteServerOutput() RouteServerOutput {
	return o
}

func (o RouteServerOutput) ToRouteServerOutputWithContext(ctx context.Context) RouteServerOutput {
	return o
}

// Whether to enable route exchange between Azure Route Server and the gateway(s).
func (o RouteServerOutput) BranchToBranchTrafficEnabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *RouteServer) pulumi.BoolPtrOutput { return v.BranchToBranchTrafficEnabled }).(pulumi.BoolPtrOutput)
}

// The hub routing preference. Valid values are `ASPath`, `ExpressRoute` or `VpnGateway`. Defaults to `ExpressRoute`.
func (o RouteServerOutput) HubRoutingPreference() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RouteServer) pulumi.StringPtrOutput { return v.HubRoutingPreference }).(pulumi.StringPtrOutput)
}

// Specifies the supported Azure location where the Route Server should exist. Changing this forces a new resource to be created.
func (o RouteServerOutput) Location() pulumi.StringOutput {
	return o.ApplyT(func(v *RouteServer) pulumi.StringOutput { return v.Location }).(pulumi.StringOutput)
}

// The name of the Route Server. Changing this forces a new resource to be created.
func (o RouteServerOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *RouteServer) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The ID of the Public IP Address. This option is required since September 1st 2021. Changing this forces a new resource to be created.
func (o RouteServerOutput) PublicIpAddressId() pulumi.StringOutput {
	return o.ApplyT(func(v *RouteServer) pulumi.StringOutput { return v.PublicIpAddressId }).(pulumi.StringOutput)
}

// Specifies the name of the Resource Group where the Route Server should exist. Changing this forces a new resource to be created.
func (o RouteServerOutput) ResourceGroupName() pulumi.StringOutput {
	return o.ApplyT(func(v *RouteServer) pulumi.StringOutput { return v.ResourceGroupName }).(pulumi.StringOutput)
}

func (o RouteServerOutput) RoutingState() pulumi.StringOutput {
	return o.ApplyT(func(v *RouteServer) pulumi.StringOutput { return v.RoutingState }).(pulumi.StringOutput)
}

// The SKU of the Route Server. The only possible value is `Standard`. Changing this forces a new resource to be created.
func (o RouteServerOutput) Sku() pulumi.StringOutput {
	return o.ApplyT(func(v *RouteServer) pulumi.StringOutput { return v.Sku }).(pulumi.StringOutput)
}

// The ID of the Subnet that the Route Server will reside. Changing this forces a new resource to be created.
//
// > **Note:** Azure Route Server requires a dedicated subnet named RouteServerSubnet. The subnet size has to be at least /27 or short prefix (such as /26 or /25) and cannot be attached to any security group, otherwise, you'll receive an error message when deploying the Route Server.
func (o RouteServerOutput) SubnetId() pulumi.StringOutput {
	return o.ApplyT(func(v *RouteServer) pulumi.StringOutput { return v.SubnetId }).(pulumi.StringOutput)
}

// A mapping of tags to assign to the resource.
func (o RouteServerOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v *RouteServer) pulumi.StringMapOutput { return v.Tags }).(pulumi.StringMapOutput)
}

func (o RouteServerOutput) VirtualRouterAsn() pulumi.IntOutput {
	return o.ApplyT(func(v *RouteServer) pulumi.IntOutput { return v.VirtualRouterAsn }).(pulumi.IntOutput)
}

func (o RouteServerOutput) VirtualRouterIps() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *RouteServer) pulumi.StringArrayOutput { return v.VirtualRouterIps }).(pulumi.StringArrayOutput)
}

type RouteServerArrayOutput struct{ *pulumi.OutputState }

func (RouteServerArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*RouteServer)(nil)).Elem()
}

func (o RouteServerArrayOutput) ToRouteServerArrayOutput() RouteServerArrayOutput {
	return o
}

func (o RouteServerArrayOutput) ToRouteServerArrayOutputWithContext(ctx context.Context) RouteServerArrayOutput {
	return o
}

func (o RouteServerArrayOutput) Index(i pulumi.IntInput) RouteServerOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *RouteServer {
		return vs[0].([]*RouteServer)[vs[1].(int)]
	}).(RouteServerOutput)
}

type RouteServerMapOutput struct{ *pulumi.OutputState }

func (RouteServerMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*RouteServer)(nil)).Elem()
}

func (o RouteServerMapOutput) ToRouteServerMapOutput() RouteServerMapOutput {
	return o
}

func (o RouteServerMapOutput) ToRouteServerMapOutputWithContext(ctx context.Context) RouteServerMapOutput {
	return o
}

func (o RouteServerMapOutput) MapIndex(k pulumi.StringInput) RouteServerOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *RouteServer {
		return vs[0].(map[string]*RouteServer)[vs[1].(string)]
	}).(RouteServerOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*RouteServerInput)(nil)).Elem(), &RouteServer{})
	pulumi.RegisterInputType(reflect.TypeOf((*RouteServerArrayInput)(nil)).Elem(), RouteServerArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RouteServerMapInput)(nil)).Elem(), RouteServerMap{})
	pulumi.RegisterOutputType(RouteServerOutput{})
	pulumi.RegisterOutputType(RouteServerArrayOutput{})
	pulumi.RegisterOutputType(RouteServerMapOutput{})
}
