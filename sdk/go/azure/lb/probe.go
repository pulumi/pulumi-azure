// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package lb

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-azure/sdk/v5/go/azure/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
)

// Manages a LoadBalancer Probe Resource.
//
// > **NOTE** When using this resource, the Load Balancer needs to have a FrontEnd IP Configuration Attached
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-azure/sdk/v5/go/azure/core"
//	"github.com/pulumi/pulumi-azure/sdk/v5/go/azure/lb"
//	"github.com/pulumi/pulumi-azure/sdk/v5/go/azure/network"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			exampleResourceGroup, err := core.NewResourceGroup(ctx, "exampleResourceGroup", &core.ResourceGroupArgs{
//				Location: pulumi.String("West Europe"),
//			})
//			if err != nil {
//				return err
//			}
//			examplePublicIp, err := network.NewPublicIp(ctx, "examplePublicIp", &network.PublicIpArgs{
//				Location:          exampleResourceGroup.Location,
//				ResourceGroupName: exampleResourceGroup.Name,
//				AllocationMethod:  pulumi.String("Static"),
//			})
//			if err != nil {
//				return err
//			}
//			exampleLoadBalancer, err := lb.NewLoadBalancer(ctx, "exampleLoadBalancer", &lb.LoadBalancerArgs{
//				Location:          exampleResourceGroup.Location,
//				ResourceGroupName: exampleResourceGroup.Name,
//				FrontendIpConfigurations: lb.LoadBalancerFrontendIpConfigurationArray{
//					&lb.LoadBalancerFrontendIpConfigurationArgs{
//						Name:              pulumi.String("PublicIPAddress"),
//						PublicIpAddressId: examplePublicIp.ID(),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = lb.NewProbe(ctx, "exampleProbe", &lb.ProbeArgs{
//				LoadbalancerId: exampleLoadBalancer.ID(),
//				Port:           pulumi.Int(22),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Load Balancer Probes can be imported using the `resource id`, e.g.
//
// ```sh
//
//	$ pulumi import azure:lb/probe:Probe example /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/group1/providers/Microsoft.Network/loadBalancers/lb1/probes/probe1
//
// ```
type Probe struct {
	pulumi.CustomResourceState

	// The interval, in seconds between probes to the backend endpoint for health status. The default value is 15, the minimum value is 5.
	IntervalInSeconds pulumi.IntPtrOutput      `pulumi:"intervalInSeconds"`
	LoadBalancerRules pulumi.StringArrayOutput `pulumi:"loadBalancerRules"`
	// The ID of the LoadBalancer in which to create the NAT Rule. Changing this forces a new resource to be created.
	LoadbalancerId pulumi.StringOutput `pulumi:"loadbalancerId"`
	// Specifies the name of the Probe. Changing this forces a new resource to be created.
	Name pulumi.StringOutput `pulumi:"name"`
	// The number of failed probe attempts after which the backend endpoint is removed from rotation. Default to `2`. NumberOfProbes multiplied by intervalInSeconds value must be greater or equal to 10.Endpoints are returned to rotation when at least one probe is successful.
	NumberOfProbes pulumi.IntPtrOutput `pulumi:"numberOfProbes"`
	// Port on which the Probe queries the backend endpoint. Possible values range from 1 to 65535, inclusive.
	Port pulumi.IntOutput `pulumi:"port"`
	// The number of consecutive successful or failed probes that allow or deny traffic to this endpoint. Possible values range from `1` to `100`. The default value is `1`.
	ProbeThreshold pulumi.IntPtrOutput `pulumi:"probeThreshold"`
	// Specifies the protocol of the end point. Possible values are `Http`, `Https` or `Tcp`. If TCP is specified, a received ACK is required for the probe to be successful. If HTTP is specified, a 200 OK response from the specified URI is required for the probe to be successful.
	Protocol pulumi.StringOutput `pulumi:"protocol"`
	// The URI used for requesting health status from the backend endpoint. Required if protocol is set to `Http` or `Https`. Otherwise, it is not allowed.
	RequestPath pulumi.StringPtrOutput `pulumi:"requestPath"`
}

// NewProbe registers a new resource with the given unique name, arguments, and options.
func NewProbe(ctx *pulumi.Context,
	name string, args *ProbeArgs, opts ...pulumi.ResourceOption) (*Probe, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.LoadbalancerId == nil {
		return nil, errors.New("invalid value for required argument 'LoadbalancerId'")
	}
	if args.Port == nil {
		return nil, errors.New("invalid value for required argument 'Port'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Probe
	err := ctx.RegisterResource("azure:lb/probe:Probe", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetProbe gets an existing Probe resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetProbe(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ProbeState, opts ...pulumi.ResourceOption) (*Probe, error) {
	var resource Probe
	err := ctx.ReadResource("azure:lb/probe:Probe", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Probe resources.
type probeState struct {
	// The interval, in seconds between probes to the backend endpoint for health status. The default value is 15, the minimum value is 5.
	IntervalInSeconds *int     `pulumi:"intervalInSeconds"`
	LoadBalancerRules []string `pulumi:"loadBalancerRules"`
	// The ID of the LoadBalancer in which to create the NAT Rule. Changing this forces a new resource to be created.
	LoadbalancerId *string `pulumi:"loadbalancerId"`
	// Specifies the name of the Probe. Changing this forces a new resource to be created.
	Name *string `pulumi:"name"`
	// The number of failed probe attempts after which the backend endpoint is removed from rotation. Default to `2`. NumberOfProbes multiplied by intervalInSeconds value must be greater or equal to 10.Endpoints are returned to rotation when at least one probe is successful.
	NumberOfProbes *int `pulumi:"numberOfProbes"`
	// Port on which the Probe queries the backend endpoint. Possible values range from 1 to 65535, inclusive.
	Port *int `pulumi:"port"`
	// The number of consecutive successful or failed probes that allow or deny traffic to this endpoint. Possible values range from `1` to `100`. The default value is `1`.
	ProbeThreshold *int `pulumi:"probeThreshold"`
	// Specifies the protocol of the end point. Possible values are `Http`, `Https` or `Tcp`. If TCP is specified, a received ACK is required for the probe to be successful. If HTTP is specified, a 200 OK response from the specified URI is required for the probe to be successful.
	Protocol *string `pulumi:"protocol"`
	// The URI used for requesting health status from the backend endpoint. Required if protocol is set to `Http` or `Https`. Otherwise, it is not allowed.
	RequestPath *string `pulumi:"requestPath"`
}

type ProbeState struct {
	// The interval, in seconds between probes to the backend endpoint for health status. The default value is 15, the minimum value is 5.
	IntervalInSeconds pulumi.IntPtrInput
	LoadBalancerRules pulumi.StringArrayInput
	// The ID of the LoadBalancer in which to create the NAT Rule. Changing this forces a new resource to be created.
	LoadbalancerId pulumi.StringPtrInput
	// Specifies the name of the Probe. Changing this forces a new resource to be created.
	Name pulumi.StringPtrInput
	// The number of failed probe attempts after which the backend endpoint is removed from rotation. Default to `2`. NumberOfProbes multiplied by intervalInSeconds value must be greater or equal to 10.Endpoints are returned to rotation when at least one probe is successful.
	NumberOfProbes pulumi.IntPtrInput
	// Port on which the Probe queries the backend endpoint. Possible values range from 1 to 65535, inclusive.
	Port pulumi.IntPtrInput
	// The number of consecutive successful or failed probes that allow or deny traffic to this endpoint. Possible values range from `1` to `100`. The default value is `1`.
	ProbeThreshold pulumi.IntPtrInput
	// Specifies the protocol of the end point. Possible values are `Http`, `Https` or `Tcp`. If TCP is specified, a received ACK is required for the probe to be successful. If HTTP is specified, a 200 OK response from the specified URI is required for the probe to be successful.
	Protocol pulumi.StringPtrInput
	// The URI used for requesting health status from the backend endpoint. Required if protocol is set to `Http` or `Https`. Otherwise, it is not allowed.
	RequestPath pulumi.StringPtrInput
}

func (ProbeState) ElementType() reflect.Type {
	return reflect.TypeOf((*probeState)(nil)).Elem()
}

type probeArgs struct {
	// The interval, in seconds between probes to the backend endpoint for health status. The default value is 15, the minimum value is 5.
	IntervalInSeconds *int `pulumi:"intervalInSeconds"`
	// The ID of the LoadBalancer in which to create the NAT Rule. Changing this forces a new resource to be created.
	LoadbalancerId string `pulumi:"loadbalancerId"`
	// Specifies the name of the Probe. Changing this forces a new resource to be created.
	Name *string `pulumi:"name"`
	// The number of failed probe attempts after which the backend endpoint is removed from rotation. Default to `2`. NumberOfProbes multiplied by intervalInSeconds value must be greater or equal to 10.Endpoints are returned to rotation when at least one probe is successful.
	NumberOfProbes *int `pulumi:"numberOfProbes"`
	// Port on which the Probe queries the backend endpoint. Possible values range from 1 to 65535, inclusive.
	Port int `pulumi:"port"`
	// The number of consecutive successful or failed probes that allow or deny traffic to this endpoint. Possible values range from `1` to `100`. The default value is `1`.
	ProbeThreshold *int `pulumi:"probeThreshold"`
	// Specifies the protocol of the end point. Possible values are `Http`, `Https` or `Tcp`. If TCP is specified, a received ACK is required for the probe to be successful. If HTTP is specified, a 200 OK response from the specified URI is required for the probe to be successful.
	Protocol *string `pulumi:"protocol"`
	// The URI used for requesting health status from the backend endpoint. Required if protocol is set to `Http` or `Https`. Otherwise, it is not allowed.
	RequestPath *string `pulumi:"requestPath"`
}

// The set of arguments for constructing a Probe resource.
type ProbeArgs struct {
	// The interval, in seconds between probes to the backend endpoint for health status. The default value is 15, the minimum value is 5.
	IntervalInSeconds pulumi.IntPtrInput
	// The ID of the LoadBalancer in which to create the NAT Rule. Changing this forces a new resource to be created.
	LoadbalancerId pulumi.StringInput
	// Specifies the name of the Probe. Changing this forces a new resource to be created.
	Name pulumi.StringPtrInput
	// The number of failed probe attempts after which the backend endpoint is removed from rotation. Default to `2`. NumberOfProbes multiplied by intervalInSeconds value must be greater or equal to 10.Endpoints are returned to rotation when at least one probe is successful.
	NumberOfProbes pulumi.IntPtrInput
	// Port on which the Probe queries the backend endpoint. Possible values range from 1 to 65535, inclusive.
	Port pulumi.IntInput
	// The number of consecutive successful or failed probes that allow or deny traffic to this endpoint. Possible values range from `1` to `100`. The default value is `1`.
	ProbeThreshold pulumi.IntPtrInput
	// Specifies the protocol of the end point. Possible values are `Http`, `Https` or `Tcp`. If TCP is specified, a received ACK is required for the probe to be successful. If HTTP is specified, a 200 OK response from the specified URI is required for the probe to be successful.
	Protocol pulumi.StringPtrInput
	// The URI used for requesting health status from the backend endpoint. Required if protocol is set to `Http` or `Https`. Otherwise, it is not allowed.
	RequestPath pulumi.StringPtrInput
}

func (ProbeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*probeArgs)(nil)).Elem()
}

type ProbeInput interface {
	pulumi.Input

	ToProbeOutput() ProbeOutput
	ToProbeOutputWithContext(ctx context.Context) ProbeOutput
}

func (*Probe) ElementType() reflect.Type {
	return reflect.TypeOf((**Probe)(nil)).Elem()
}

func (i *Probe) ToProbeOutput() ProbeOutput {
	return i.ToProbeOutputWithContext(context.Background())
}

func (i *Probe) ToProbeOutputWithContext(ctx context.Context) ProbeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProbeOutput)
}

func (i *Probe) ToOutput(ctx context.Context) pulumix.Output[*Probe] {
	return pulumix.Output[*Probe]{
		OutputState: i.ToProbeOutputWithContext(ctx).OutputState,
	}
}

// ProbeArrayInput is an input type that accepts ProbeArray and ProbeArrayOutput values.
// You can construct a concrete instance of `ProbeArrayInput` via:
//
//	ProbeArray{ ProbeArgs{...} }
type ProbeArrayInput interface {
	pulumi.Input

	ToProbeArrayOutput() ProbeArrayOutput
	ToProbeArrayOutputWithContext(context.Context) ProbeArrayOutput
}

type ProbeArray []ProbeInput

func (ProbeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Probe)(nil)).Elem()
}

func (i ProbeArray) ToProbeArrayOutput() ProbeArrayOutput {
	return i.ToProbeArrayOutputWithContext(context.Background())
}

func (i ProbeArray) ToProbeArrayOutputWithContext(ctx context.Context) ProbeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProbeArrayOutput)
}

func (i ProbeArray) ToOutput(ctx context.Context) pulumix.Output[[]*Probe] {
	return pulumix.Output[[]*Probe]{
		OutputState: i.ToProbeArrayOutputWithContext(ctx).OutputState,
	}
}

// ProbeMapInput is an input type that accepts ProbeMap and ProbeMapOutput values.
// You can construct a concrete instance of `ProbeMapInput` via:
//
//	ProbeMap{ "key": ProbeArgs{...} }
type ProbeMapInput interface {
	pulumi.Input

	ToProbeMapOutput() ProbeMapOutput
	ToProbeMapOutputWithContext(context.Context) ProbeMapOutput
}

type ProbeMap map[string]ProbeInput

func (ProbeMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Probe)(nil)).Elem()
}

func (i ProbeMap) ToProbeMapOutput() ProbeMapOutput {
	return i.ToProbeMapOutputWithContext(context.Background())
}

func (i ProbeMap) ToProbeMapOutputWithContext(ctx context.Context) ProbeMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProbeMapOutput)
}

func (i ProbeMap) ToOutput(ctx context.Context) pulumix.Output[map[string]*Probe] {
	return pulumix.Output[map[string]*Probe]{
		OutputState: i.ToProbeMapOutputWithContext(ctx).OutputState,
	}
}

type ProbeOutput struct{ *pulumi.OutputState }

func (ProbeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Probe)(nil)).Elem()
}

func (o ProbeOutput) ToProbeOutput() ProbeOutput {
	return o
}

func (o ProbeOutput) ToProbeOutputWithContext(ctx context.Context) ProbeOutput {
	return o
}

func (o ProbeOutput) ToOutput(ctx context.Context) pulumix.Output[*Probe] {
	return pulumix.Output[*Probe]{
		OutputState: o.OutputState,
	}
}

// The interval, in seconds between probes to the backend endpoint for health status. The default value is 15, the minimum value is 5.
func (o ProbeOutput) IntervalInSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Probe) pulumi.IntPtrOutput { return v.IntervalInSeconds }).(pulumi.IntPtrOutput)
}

func (o ProbeOutput) LoadBalancerRules() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Probe) pulumi.StringArrayOutput { return v.LoadBalancerRules }).(pulumi.StringArrayOutput)
}

// The ID of the LoadBalancer in which to create the NAT Rule. Changing this forces a new resource to be created.
func (o ProbeOutput) LoadbalancerId() pulumi.StringOutput {
	return o.ApplyT(func(v *Probe) pulumi.StringOutput { return v.LoadbalancerId }).(pulumi.StringOutput)
}

// Specifies the name of the Probe. Changing this forces a new resource to be created.
func (o ProbeOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Probe) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The number of failed probe attempts after which the backend endpoint is removed from rotation. Default to `2`. NumberOfProbes multiplied by intervalInSeconds value must be greater or equal to 10.Endpoints are returned to rotation when at least one probe is successful.
func (o ProbeOutput) NumberOfProbes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Probe) pulumi.IntPtrOutput { return v.NumberOfProbes }).(pulumi.IntPtrOutput)
}

// Port on which the Probe queries the backend endpoint. Possible values range from 1 to 65535, inclusive.
func (o ProbeOutput) Port() pulumi.IntOutput {
	return o.ApplyT(func(v *Probe) pulumi.IntOutput { return v.Port }).(pulumi.IntOutput)
}

// The number of consecutive successful or failed probes that allow or deny traffic to this endpoint. Possible values range from `1` to `100`. The default value is `1`.
func (o ProbeOutput) ProbeThreshold() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Probe) pulumi.IntPtrOutput { return v.ProbeThreshold }).(pulumi.IntPtrOutput)
}

// Specifies the protocol of the end point. Possible values are `Http`, `Https` or `Tcp`. If TCP is specified, a received ACK is required for the probe to be successful. If HTTP is specified, a 200 OK response from the specified URI is required for the probe to be successful.
func (o ProbeOutput) Protocol() pulumi.StringOutput {
	return o.ApplyT(func(v *Probe) pulumi.StringOutput { return v.Protocol }).(pulumi.StringOutput)
}

// The URI used for requesting health status from the backend endpoint. Required if protocol is set to `Http` or `Https`. Otherwise, it is not allowed.
func (o ProbeOutput) RequestPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Probe) pulumi.StringPtrOutput { return v.RequestPath }).(pulumi.StringPtrOutput)
}

type ProbeArrayOutput struct{ *pulumi.OutputState }

func (ProbeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Probe)(nil)).Elem()
}

func (o ProbeArrayOutput) ToProbeArrayOutput() ProbeArrayOutput {
	return o
}

func (o ProbeArrayOutput) ToProbeArrayOutputWithContext(ctx context.Context) ProbeArrayOutput {
	return o
}

func (o ProbeArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]*Probe] {
	return pulumix.Output[[]*Probe]{
		OutputState: o.OutputState,
	}
}

func (o ProbeArrayOutput) Index(i pulumi.IntInput) ProbeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Probe {
		return vs[0].([]*Probe)[vs[1].(int)]
	}).(ProbeOutput)
}

type ProbeMapOutput struct{ *pulumi.OutputState }

func (ProbeMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Probe)(nil)).Elem()
}

func (o ProbeMapOutput) ToProbeMapOutput() ProbeMapOutput {
	return o
}

func (o ProbeMapOutput) ToProbeMapOutputWithContext(ctx context.Context) ProbeMapOutput {
	return o
}

func (o ProbeMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]*Probe] {
	return pulumix.Output[map[string]*Probe]{
		OutputState: o.OutputState,
	}
}

func (o ProbeMapOutput) MapIndex(k pulumi.StringInput) ProbeOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Probe {
		return vs[0].(map[string]*Probe)[vs[1].(string)]
	}).(ProbeOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ProbeInput)(nil)).Elem(), &Probe{})
	pulumi.RegisterInputType(reflect.TypeOf((*ProbeArrayInput)(nil)).Elem(), ProbeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ProbeMapInput)(nil)).Elem(), ProbeMap{})
	pulumi.RegisterOutputType(ProbeOutput{})
	pulumi.RegisterOutputType(ProbeArrayOutput{})
	pulumi.RegisterOutputType(ProbeMapOutput{})
}
