// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package media

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v2/go/pulumi"
)

type JobInputAsset struct {
	// A label that is assigned to a JobInputClip, that is used to satisfy a reference used in the Transform. For example, a Transform can be authored so as to take an image file with the label 'xyz' and apply it as an overlay onto the input video before it is encoded. When submitting a Job, exactly one of the JobInputs should be the image file, and it should have the label 'xyz'.
	Label *string `pulumi:"label"`
	// The name of the input Asset. Changing this forces a new Media Job to be created.
	Name string `pulumi:"name"`
}

// JobInputAssetInput is an input type that accepts JobInputAssetArgs and JobInputAssetOutput values.
// You can construct a concrete instance of `JobInputAssetInput` via:
//
//          JobInputAssetArgs{...}
type JobInputAssetInput interface {
	pulumi.Input

	ToJobInputAssetOutput() JobInputAssetOutput
	ToJobInputAssetOutputWithContext(context.Context) JobInputAssetOutput
}

type JobInputAssetArgs struct {
	// A label that is assigned to a JobInputClip, that is used to satisfy a reference used in the Transform. For example, a Transform can be authored so as to take an image file with the label 'xyz' and apply it as an overlay onto the input video before it is encoded. When submitting a Job, exactly one of the JobInputs should be the image file, and it should have the label 'xyz'.
	Label pulumi.StringPtrInput `pulumi:"label"`
	// The name of the input Asset. Changing this forces a new Media Job to be created.
	Name pulumi.StringInput `pulumi:"name"`
}

func (JobInputAssetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*JobInputAsset)(nil)).Elem()
}

func (i JobInputAssetArgs) ToJobInputAssetOutput() JobInputAssetOutput {
	return i.ToJobInputAssetOutputWithContext(context.Background())
}

func (i JobInputAssetArgs) ToJobInputAssetOutputWithContext(ctx context.Context) JobInputAssetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobInputAssetOutput)
}

func (i JobInputAssetArgs) ToJobInputAssetPtrOutput() JobInputAssetPtrOutput {
	return i.ToJobInputAssetPtrOutputWithContext(context.Background())
}

func (i JobInputAssetArgs) ToJobInputAssetPtrOutputWithContext(ctx context.Context) JobInputAssetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobInputAssetOutput).ToJobInputAssetPtrOutputWithContext(ctx)
}

// JobInputAssetPtrInput is an input type that accepts JobInputAssetArgs, JobInputAssetPtr and JobInputAssetPtrOutput values.
// You can construct a concrete instance of `JobInputAssetPtrInput` via:
//
//          JobInputAssetArgs{...}
//
//  or:
//
//          nil
type JobInputAssetPtrInput interface {
	pulumi.Input

	ToJobInputAssetPtrOutput() JobInputAssetPtrOutput
	ToJobInputAssetPtrOutputWithContext(context.Context) JobInputAssetPtrOutput
}

type jobInputAssetPtrType JobInputAssetArgs

func JobInputAssetPtr(v *JobInputAssetArgs) JobInputAssetPtrInput {
	return (*jobInputAssetPtrType)(v)
}

func (*jobInputAssetPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**JobInputAsset)(nil)).Elem()
}

func (i *jobInputAssetPtrType) ToJobInputAssetPtrOutput() JobInputAssetPtrOutput {
	return i.ToJobInputAssetPtrOutputWithContext(context.Background())
}

func (i *jobInputAssetPtrType) ToJobInputAssetPtrOutputWithContext(ctx context.Context) JobInputAssetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobInputAssetPtrOutput)
}

type JobInputAssetOutput struct{ *pulumi.OutputState }

func (JobInputAssetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*JobInputAsset)(nil)).Elem()
}

func (o JobInputAssetOutput) ToJobInputAssetOutput() JobInputAssetOutput {
	return o
}

func (o JobInputAssetOutput) ToJobInputAssetOutputWithContext(ctx context.Context) JobInputAssetOutput {
	return o
}

func (o JobInputAssetOutput) ToJobInputAssetPtrOutput() JobInputAssetPtrOutput {
	return o.ToJobInputAssetPtrOutputWithContext(context.Background())
}

func (o JobInputAssetOutput) ToJobInputAssetPtrOutputWithContext(ctx context.Context) JobInputAssetPtrOutput {
	return o.ApplyT(func(v JobInputAsset) *JobInputAsset {
		return &v
	}).(JobInputAssetPtrOutput)
}

// A label that is assigned to a JobInputClip, that is used to satisfy a reference used in the Transform. For example, a Transform can be authored so as to take an image file with the label 'xyz' and apply it as an overlay onto the input video before it is encoded. When submitting a Job, exactly one of the JobInputs should be the image file, and it should have the label 'xyz'.
func (o JobInputAssetOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobInputAsset) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// The name of the input Asset. Changing this forces a new Media Job to be created.
func (o JobInputAssetOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v JobInputAsset) string { return v.Name }).(pulumi.StringOutput)
}

type JobInputAssetPtrOutput struct{ *pulumi.OutputState }

func (JobInputAssetPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**JobInputAsset)(nil)).Elem()
}

func (o JobInputAssetPtrOutput) ToJobInputAssetPtrOutput() JobInputAssetPtrOutput {
	return o
}

func (o JobInputAssetPtrOutput) ToJobInputAssetPtrOutputWithContext(ctx context.Context) JobInputAssetPtrOutput {
	return o
}

func (o JobInputAssetPtrOutput) Elem() JobInputAssetOutput {
	return o.ApplyT(func(v *JobInputAsset) JobInputAsset { return *v }).(JobInputAssetOutput)
}

// A label that is assigned to a JobInputClip, that is used to satisfy a reference used in the Transform. For example, a Transform can be authored so as to take an image file with the label 'xyz' and apply it as an overlay onto the input video before it is encoded. When submitting a Job, exactly one of the JobInputs should be the image file, and it should have the label 'xyz'.
func (o JobInputAssetPtrOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *JobInputAsset) *string {
		if v == nil {
			return nil
		}
		return v.Label
	}).(pulumi.StringPtrOutput)
}

// The name of the input Asset. Changing this forces a new Media Job to be created.
func (o JobInputAssetPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *JobInputAsset) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

type JobOutputAsset struct {
	// A label that is assigned to a JobOutput in order to help uniquely identify it. This is useful when your Transform has more than one TransformOutput, whereby your Job has more than one JobOutput. In such cases, when you submit the Job, you will add two or more JobOutputs, in the same order as TransformOutputs in the Transform. Subsequently, when you retrieve the Job, either through events or on a GET request, you can use the label to easily identify the JobOutput. If a label is not provided, a default value of '{presetName}_{outputIndex}' will be used, where the preset name is the name of the preset in the corresponding TransformOutput and the output index is the relative index of the this JobOutput within the Job. Note that this index is the same as the relative index of the corresponding TransformOutput within its Transform.
	Label *string `pulumi:"label"`
	// The name of the output Asset. Changing this forces a new Media Job to be created.
	Name string `pulumi:"name"`
}

// JobOutputAssetInput is an input type that accepts JobOutputAssetArgs and JobOutputAssetOutput values.
// You can construct a concrete instance of `JobOutputAssetInput` via:
//
//          JobOutputAssetArgs{...}
type JobOutputAssetInput interface {
	pulumi.Input

	ToJobOutputAssetOutput() JobOutputAssetOutput
	ToJobOutputAssetOutputWithContext(context.Context) JobOutputAssetOutput
}

type JobOutputAssetArgs struct {
	// A label that is assigned to a JobOutput in order to help uniquely identify it. This is useful when your Transform has more than one TransformOutput, whereby your Job has more than one JobOutput. In such cases, when you submit the Job, you will add two or more JobOutputs, in the same order as TransformOutputs in the Transform. Subsequently, when you retrieve the Job, either through events or on a GET request, you can use the label to easily identify the JobOutput. If a label is not provided, a default value of '{presetName}_{outputIndex}' will be used, where the preset name is the name of the preset in the corresponding TransformOutput and the output index is the relative index of the this JobOutput within the Job. Note that this index is the same as the relative index of the corresponding TransformOutput within its Transform.
	Label pulumi.StringPtrInput `pulumi:"label"`
	// The name of the output Asset. Changing this forces a new Media Job to be created.
	Name pulumi.StringInput `pulumi:"name"`
}

func (JobOutputAssetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*JobOutputAsset)(nil)).Elem()
}

func (i JobOutputAssetArgs) ToJobOutputAssetOutput() JobOutputAssetOutput {
	return i.ToJobOutputAssetOutputWithContext(context.Background())
}

func (i JobOutputAssetArgs) ToJobOutputAssetOutputWithContext(ctx context.Context) JobOutputAssetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobOutputAssetOutput)
}

// JobOutputAssetArrayInput is an input type that accepts JobOutputAssetArray and JobOutputAssetArrayOutput values.
// You can construct a concrete instance of `JobOutputAssetArrayInput` via:
//
//          JobOutputAssetArray{ JobOutputAssetArgs{...} }
type JobOutputAssetArrayInput interface {
	pulumi.Input

	ToJobOutputAssetArrayOutput() JobOutputAssetArrayOutput
	ToJobOutputAssetArrayOutputWithContext(context.Context) JobOutputAssetArrayOutput
}

type JobOutputAssetArray []JobOutputAssetInput

func (JobOutputAssetArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]JobOutputAsset)(nil)).Elem()
}

func (i JobOutputAssetArray) ToJobOutputAssetArrayOutput() JobOutputAssetArrayOutput {
	return i.ToJobOutputAssetArrayOutputWithContext(context.Background())
}

func (i JobOutputAssetArray) ToJobOutputAssetArrayOutputWithContext(ctx context.Context) JobOutputAssetArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobOutputAssetArrayOutput)
}

type JobOutputAssetOutput struct{ *pulumi.OutputState }

func (JobOutputAssetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*JobOutputAsset)(nil)).Elem()
}

func (o JobOutputAssetOutput) ToJobOutputAssetOutput() JobOutputAssetOutput {
	return o
}

func (o JobOutputAssetOutput) ToJobOutputAssetOutputWithContext(ctx context.Context) JobOutputAssetOutput {
	return o
}

// A label that is assigned to a JobOutput in order to help uniquely identify it. This is useful when your Transform has more than one TransformOutput, whereby your Job has more than one JobOutput. In such cases, when you submit the Job, you will add two or more JobOutputs, in the same order as TransformOutputs in the Transform. Subsequently, when you retrieve the Job, either through events or on a GET request, you can use the label to easily identify the JobOutput. If a label is not provided, a default value of '{presetName}_{outputIndex}' will be used, where the preset name is the name of the preset in the corresponding TransformOutput and the output index is the relative index of the this JobOutput within the Job. Note that this index is the same as the relative index of the corresponding TransformOutput within its Transform.
func (o JobOutputAssetOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobOutputAsset) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// The name of the output Asset. Changing this forces a new Media Job to be created.
func (o JobOutputAssetOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v JobOutputAsset) string { return v.Name }).(pulumi.StringOutput)
}

type JobOutputAssetArrayOutput struct{ *pulumi.OutputState }

func (JobOutputAssetArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]JobOutputAsset)(nil)).Elem()
}

func (o JobOutputAssetArrayOutput) ToJobOutputAssetArrayOutput() JobOutputAssetArrayOutput {
	return o
}

func (o JobOutputAssetArrayOutput) ToJobOutputAssetArrayOutputWithContext(ctx context.Context) JobOutputAssetArrayOutput {
	return o
}

func (o JobOutputAssetArrayOutput) Index(i pulumi.IntInput) JobOutputAssetOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) JobOutputAsset {
		return vs[0].([]JobOutputAsset)[vs[1].(int)]
	}).(JobOutputAssetOutput)
}

type ServiceAccountIdentity struct {
	// The Principal ID associated with this Managed Service Identity.
	PrincipalId *string `pulumi:"principalId"`
	// The Tenant ID associated with this Managed Service Identity.
	TenantId *string `pulumi:"tenantId"`
	// Specifies the type of Managed Service Identity that should be configured on this Media Services Account. Possible value is  `SystemAssigned`.
	Type *string `pulumi:"type"`
}

// ServiceAccountIdentityInput is an input type that accepts ServiceAccountIdentityArgs and ServiceAccountIdentityOutput values.
// You can construct a concrete instance of `ServiceAccountIdentityInput` via:
//
//          ServiceAccountIdentityArgs{...}
type ServiceAccountIdentityInput interface {
	pulumi.Input

	ToServiceAccountIdentityOutput() ServiceAccountIdentityOutput
	ToServiceAccountIdentityOutputWithContext(context.Context) ServiceAccountIdentityOutput
}

type ServiceAccountIdentityArgs struct {
	// The Principal ID associated with this Managed Service Identity.
	PrincipalId pulumi.StringPtrInput `pulumi:"principalId"`
	// The Tenant ID associated with this Managed Service Identity.
	TenantId pulumi.StringPtrInput `pulumi:"tenantId"`
	// Specifies the type of Managed Service Identity that should be configured on this Media Services Account. Possible value is  `SystemAssigned`.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (ServiceAccountIdentityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceAccountIdentity)(nil)).Elem()
}

func (i ServiceAccountIdentityArgs) ToServiceAccountIdentityOutput() ServiceAccountIdentityOutput {
	return i.ToServiceAccountIdentityOutputWithContext(context.Background())
}

func (i ServiceAccountIdentityArgs) ToServiceAccountIdentityOutputWithContext(ctx context.Context) ServiceAccountIdentityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceAccountIdentityOutput)
}

func (i ServiceAccountIdentityArgs) ToServiceAccountIdentityPtrOutput() ServiceAccountIdentityPtrOutput {
	return i.ToServiceAccountIdentityPtrOutputWithContext(context.Background())
}

func (i ServiceAccountIdentityArgs) ToServiceAccountIdentityPtrOutputWithContext(ctx context.Context) ServiceAccountIdentityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceAccountIdentityOutput).ToServiceAccountIdentityPtrOutputWithContext(ctx)
}

// ServiceAccountIdentityPtrInput is an input type that accepts ServiceAccountIdentityArgs, ServiceAccountIdentityPtr and ServiceAccountIdentityPtrOutput values.
// You can construct a concrete instance of `ServiceAccountIdentityPtrInput` via:
//
//          ServiceAccountIdentityArgs{...}
//
//  or:
//
//          nil
type ServiceAccountIdentityPtrInput interface {
	pulumi.Input

	ToServiceAccountIdentityPtrOutput() ServiceAccountIdentityPtrOutput
	ToServiceAccountIdentityPtrOutputWithContext(context.Context) ServiceAccountIdentityPtrOutput
}

type serviceAccountIdentityPtrType ServiceAccountIdentityArgs

func ServiceAccountIdentityPtr(v *ServiceAccountIdentityArgs) ServiceAccountIdentityPtrInput {
	return (*serviceAccountIdentityPtrType)(v)
}

func (*serviceAccountIdentityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceAccountIdentity)(nil)).Elem()
}

func (i *serviceAccountIdentityPtrType) ToServiceAccountIdentityPtrOutput() ServiceAccountIdentityPtrOutput {
	return i.ToServiceAccountIdentityPtrOutputWithContext(context.Background())
}

func (i *serviceAccountIdentityPtrType) ToServiceAccountIdentityPtrOutputWithContext(ctx context.Context) ServiceAccountIdentityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceAccountIdentityPtrOutput)
}

type ServiceAccountIdentityOutput struct{ *pulumi.OutputState }

func (ServiceAccountIdentityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceAccountIdentity)(nil)).Elem()
}

func (o ServiceAccountIdentityOutput) ToServiceAccountIdentityOutput() ServiceAccountIdentityOutput {
	return o
}

func (o ServiceAccountIdentityOutput) ToServiceAccountIdentityOutputWithContext(ctx context.Context) ServiceAccountIdentityOutput {
	return o
}

func (o ServiceAccountIdentityOutput) ToServiceAccountIdentityPtrOutput() ServiceAccountIdentityPtrOutput {
	return o.ToServiceAccountIdentityPtrOutputWithContext(context.Background())
}

func (o ServiceAccountIdentityOutput) ToServiceAccountIdentityPtrOutputWithContext(ctx context.Context) ServiceAccountIdentityPtrOutput {
	return o.ApplyT(func(v ServiceAccountIdentity) *ServiceAccountIdentity {
		return &v
	}).(ServiceAccountIdentityPtrOutput)
}

// The Principal ID associated with this Managed Service Identity.
func (o ServiceAccountIdentityOutput) PrincipalId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ServiceAccountIdentity) *string { return v.PrincipalId }).(pulumi.StringPtrOutput)
}

// The Tenant ID associated with this Managed Service Identity.
func (o ServiceAccountIdentityOutput) TenantId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ServiceAccountIdentity) *string { return v.TenantId }).(pulumi.StringPtrOutput)
}

// Specifies the type of Managed Service Identity that should be configured on this Media Services Account. Possible value is  `SystemAssigned`.
func (o ServiceAccountIdentityOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ServiceAccountIdentity) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type ServiceAccountIdentityPtrOutput struct{ *pulumi.OutputState }

func (ServiceAccountIdentityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceAccountIdentity)(nil)).Elem()
}

func (o ServiceAccountIdentityPtrOutput) ToServiceAccountIdentityPtrOutput() ServiceAccountIdentityPtrOutput {
	return o
}

func (o ServiceAccountIdentityPtrOutput) ToServiceAccountIdentityPtrOutputWithContext(ctx context.Context) ServiceAccountIdentityPtrOutput {
	return o
}

func (o ServiceAccountIdentityPtrOutput) Elem() ServiceAccountIdentityOutput {
	return o.ApplyT(func(v *ServiceAccountIdentity) ServiceAccountIdentity { return *v }).(ServiceAccountIdentityOutput)
}

// The Principal ID associated with this Managed Service Identity.
func (o ServiceAccountIdentityPtrOutput) PrincipalId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ServiceAccountIdentity) *string {
		if v == nil {
			return nil
		}
		return v.PrincipalId
	}).(pulumi.StringPtrOutput)
}

// The Tenant ID associated with this Managed Service Identity.
func (o ServiceAccountIdentityPtrOutput) TenantId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ServiceAccountIdentity) *string {
		if v == nil {
			return nil
		}
		return v.TenantId
	}).(pulumi.StringPtrOutput)
}

// Specifies the type of Managed Service Identity that should be configured on this Media Services Account. Possible value is  `SystemAssigned`.
func (o ServiceAccountIdentityPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ServiceAccountIdentity) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

type ServiceAccountStorageAccount struct {
	// Specifies the ID of the Storage Account that will be associated with the Media Services instance.
	Id string `pulumi:"id"`
	// Specifies whether the storage account should be the primary account or not. Defaults to `false`.
	IsPrimary *bool `pulumi:"isPrimary"`
}

// ServiceAccountStorageAccountInput is an input type that accepts ServiceAccountStorageAccountArgs and ServiceAccountStorageAccountOutput values.
// You can construct a concrete instance of `ServiceAccountStorageAccountInput` via:
//
//          ServiceAccountStorageAccountArgs{...}
type ServiceAccountStorageAccountInput interface {
	pulumi.Input

	ToServiceAccountStorageAccountOutput() ServiceAccountStorageAccountOutput
	ToServiceAccountStorageAccountOutputWithContext(context.Context) ServiceAccountStorageAccountOutput
}

type ServiceAccountStorageAccountArgs struct {
	// Specifies the ID of the Storage Account that will be associated with the Media Services instance.
	Id pulumi.StringInput `pulumi:"id"`
	// Specifies whether the storage account should be the primary account or not. Defaults to `false`.
	IsPrimary pulumi.BoolPtrInput `pulumi:"isPrimary"`
}

func (ServiceAccountStorageAccountArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceAccountStorageAccount)(nil)).Elem()
}

func (i ServiceAccountStorageAccountArgs) ToServiceAccountStorageAccountOutput() ServiceAccountStorageAccountOutput {
	return i.ToServiceAccountStorageAccountOutputWithContext(context.Background())
}

func (i ServiceAccountStorageAccountArgs) ToServiceAccountStorageAccountOutputWithContext(ctx context.Context) ServiceAccountStorageAccountOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceAccountStorageAccountOutput)
}

// ServiceAccountStorageAccountArrayInput is an input type that accepts ServiceAccountStorageAccountArray and ServiceAccountStorageAccountArrayOutput values.
// You can construct a concrete instance of `ServiceAccountStorageAccountArrayInput` via:
//
//          ServiceAccountStorageAccountArray{ ServiceAccountStorageAccountArgs{...} }
type ServiceAccountStorageAccountArrayInput interface {
	pulumi.Input

	ToServiceAccountStorageAccountArrayOutput() ServiceAccountStorageAccountArrayOutput
	ToServiceAccountStorageAccountArrayOutputWithContext(context.Context) ServiceAccountStorageAccountArrayOutput
}

type ServiceAccountStorageAccountArray []ServiceAccountStorageAccountInput

func (ServiceAccountStorageAccountArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ServiceAccountStorageAccount)(nil)).Elem()
}

func (i ServiceAccountStorageAccountArray) ToServiceAccountStorageAccountArrayOutput() ServiceAccountStorageAccountArrayOutput {
	return i.ToServiceAccountStorageAccountArrayOutputWithContext(context.Background())
}

func (i ServiceAccountStorageAccountArray) ToServiceAccountStorageAccountArrayOutputWithContext(ctx context.Context) ServiceAccountStorageAccountArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceAccountStorageAccountArrayOutput)
}

type ServiceAccountStorageAccountOutput struct{ *pulumi.OutputState }

func (ServiceAccountStorageAccountOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceAccountStorageAccount)(nil)).Elem()
}

func (o ServiceAccountStorageAccountOutput) ToServiceAccountStorageAccountOutput() ServiceAccountStorageAccountOutput {
	return o
}

func (o ServiceAccountStorageAccountOutput) ToServiceAccountStorageAccountOutputWithContext(ctx context.Context) ServiceAccountStorageAccountOutput {
	return o
}

// Specifies the ID of the Storage Account that will be associated with the Media Services instance.
func (o ServiceAccountStorageAccountOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v ServiceAccountStorageAccount) string { return v.Id }).(pulumi.StringOutput)
}

// Specifies whether the storage account should be the primary account or not. Defaults to `false`.
func (o ServiceAccountStorageAccountOutput) IsPrimary() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ServiceAccountStorageAccount) *bool { return v.IsPrimary }).(pulumi.BoolPtrOutput)
}

type ServiceAccountStorageAccountArrayOutput struct{ *pulumi.OutputState }

func (ServiceAccountStorageAccountArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ServiceAccountStorageAccount)(nil)).Elem()
}

func (o ServiceAccountStorageAccountArrayOutput) ToServiceAccountStorageAccountArrayOutput() ServiceAccountStorageAccountArrayOutput {
	return o
}

func (o ServiceAccountStorageAccountArrayOutput) ToServiceAccountStorageAccountArrayOutputWithContext(ctx context.Context) ServiceAccountStorageAccountArrayOutput {
	return o
}

func (o ServiceAccountStorageAccountArrayOutput) Index(i pulumi.IntInput) ServiceAccountStorageAccountOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ServiceAccountStorageAccount {
		return vs[0].([]ServiceAccountStorageAccount)[vs[1].(int)]
	}).(ServiceAccountStorageAccountOutput)
}

type StreamingEndpointAccessControl struct {
	// One or more `akamaiSignatureHeaderAuthenticationKey` blocks as defined below.
	AkamaiSignatureHeaderAuthenticationKeys []StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKey `pulumi:"akamaiSignatureHeaderAuthenticationKeys"`
	// A `ip` block as defined below.
	IpAllows []StreamingEndpointAccessControlIpAllow `pulumi:"ipAllows"`
}

// StreamingEndpointAccessControlInput is an input type that accepts StreamingEndpointAccessControlArgs and StreamingEndpointAccessControlOutput values.
// You can construct a concrete instance of `StreamingEndpointAccessControlInput` via:
//
//          StreamingEndpointAccessControlArgs{...}
type StreamingEndpointAccessControlInput interface {
	pulumi.Input

	ToStreamingEndpointAccessControlOutput() StreamingEndpointAccessControlOutput
	ToStreamingEndpointAccessControlOutputWithContext(context.Context) StreamingEndpointAccessControlOutput
}

type StreamingEndpointAccessControlArgs struct {
	// One or more `akamaiSignatureHeaderAuthenticationKey` blocks as defined below.
	AkamaiSignatureHeaderAuthenticationKeys StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyArrayInput `pulumi:"akamaiSignatureHeaderAuthenticationKeys"`
	// A `ip` block as defined below.
	IpAllows StreamingEndpointAccessControlIpAllowArrayInput `pulumi:"ipAllows"`
}

func (StreamingEndpointAccessControlArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingEndpointAccessControl)(nil)).Elem()
}

func (i StreamingEndpointAccessControlArgs) ToStreamingEndpointAccessControlOutput() StreamingEndpointAccessControlOutput {
	return i.ToStreamingEndpointAccessControlOutputWithContext(context.Background())
}

func (i StreamingEndpointAccessControlArgs) ToStreamingEndpointAccessControlOutputWithContext(ctx context.Context) StreamingEndpointAccessControlOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingEndpointAccessControlOutput)
}

func (i StreamingEndpointAccessControlArgs) ToStreamingEndpointAccessControlPtrOutput() StreamingEndpointAccessControlPtrOutput {
	return i.ToStreamingEndpointAccessControlPtrOutputWithContext(context.Background())
}

func (i StreamingEndpointAccessControlArgs) ToStreamingEndpointAccessControlPtrOutputWithContext(ctx context.Context) StreamingEndpointAccessControlPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingEndpointAccessControlOutput).ToStreamingEndpointAccessControlPtrOutputWithContext(ctx)
}

// StreamingEndpointAccessControlPtrInput is an input type that accepts StreamingEndpointAccessControlArgs, StreamingEndpointAccessControlPtr and StreamingEndpointAccessControlPtrOutput values.
// You can construct a concrete instance of `StreamingEndpointAccessControlPtrInput` via:
//
//          StreamingEndpointAccessControlArgs{...}
//
//  or:
//
//          nil
type StreamingEndpointAccessControlPtrInput interface {
	pulumi.Input

	ToStreamingEndpointAccessControlPtrOutput() StreamingEndpointAccessControlPtrOutput
	ToStreamingEndpointAccessControlPtrOutputWithContext(context.Context) StreamingEndpointAccessControlPtrOutput
}

type streamingEndpointAccessControlPtrType StreamingEndpointAccessControlArgs

func StreamingEndpointAccessControlPtr(v *StreamingEndpointAccessControlArgs) StreamingEndpointAccessControlPtrInput {
	return (*streamingEndpointAccessControlPtrType)(v)
}

func (*streamingEndpointAccessControlPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**StreamingEndpointAccessControl)(nil)).Elem()
}

func (i *streamingEndpointAccessControlPtrType) ToStreamingEndpointAccessControlPtrOutput() StreamingEndpointAccessControlPtrOutput {
	return i.ToStreamingEndpointAccessControlPtrOutputWithContext(context.Background())
}

func (i *streamingEndpointAccessControlPtrType) ToStreamingEndpointAccessControlPtrOutputWithContext(ctx context.Context) StreamingEndpointAccessControlPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingEndpointAccessControlPtrOutput)
}

type StreamingEndpointAccessControlOutput struct{ *pulumi.OutputState }

func (StreamingEndpointAccessControlOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingEndpointAccessControl)(nil)).Elem()
}

func (o StreamingEndpointAccessControlOutput) ToStreamingEndpointAccessControlOutput() StreamingEndpointAccessControlOutput {
	return o
}

func (o StreamingEndpointAccessControlOutput) ToStreamingEndpointAccessControlOutputWithContext(ctx context.Context) StreamingEndpointAccessControlOutput {
	return o
}

func (o StreamingEndpointAccessControlOutput) ToStreamingEndpointAccessControlPtrOutput() StreamingEndpointAccessControlPtrOutput {
	return o.ToStreamingEndpointAccessControlPtrOutputWithContext(context.Background())
}

func (o StreamingEndpointAccessControlOutput) ToStreamingEndpointAccessControlPtrOutputWithContext(ctx context.Context) StreamingEndpointAccessControlPtrOutput {
	return o.ApplyT(func(v StreamingEndpointAccessControl) *StreamingEndpointAccessControl {
		return &v
	}).(StreamingEndpointAccessControlPtrOutput)
}

// One or more `akamaiSignatureHeaderAuthenticationKey` blocks as defined below.
func (o StreamingEndpointAccessControlOutput) AkamaiSignatureHeaderAuthenticationKeys() StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyArrayOutput {
	return o.ApplyT(func(v StreamingEndpointAccessControl) []StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKey {
		return v.AkamaiSignatureHeaderAuthenticationKeys
	}).(StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyArrayOutput)
}

// A `ip` block as defined below.
func (o StreamingEndpointAccessControlOutput) IpAllows() StreamingEndpointAccessControlIpAllowArrayOutput {
	return o.ApplyT(func(v StreamingEndpointAccessControl) []StreamingEndpointAccessControlIpAllow { return v.IpAllows }).(StreamingEndpointAccessControlIpAllowArrayOutput)
}

type StreamingEndpointAccessControlPtrOutput struct{ *pulumi.OutputState }

func (StreamingEndpointAccessControlPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**StreamingEndpointAccessControl)(nil)).Elem()
}

func (o StreamingEndpointAccessControlPtrOutput) ToStreamingEndpointAccessControlPtrOutput() StreamingEndpointAccessControlPtrOutput {
	return o
}

func (o StreamingEndpointAccessControlPtrOutput) ToStreamingEndpointAccessControlPtrOutputWithContext(ctx context.Context) StreamingEndpointAccessControlPtrOutput {
	return o
}

func (o StreamingEndpointAccessControlPtrOutput) Elem() StreamingEndpointAccessControlOutput {
	return o.ApplyT(func(v *StreamingEndpointAccessControl) StreamingEndpointAccessControl { return *v }).(StreamingEndpointAccessControlOutput)
}

// One or more `akamaiSignatureHeaderAuthenticationKey` blocks as defined below.
func (o StreamingEndpointAccessControlPtrOutput) AkamaiSignatureHeaderAuthenticationKeys() StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyArrayOutput {
	return o.ApplyT(func(v *StreamingEndpointAccessControl) []StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKey {
		if v == nil {
			return nil
		}
		return v.AkamaiSignatureHeaderAuthenticationKeys
	}).(StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyArrayOutput)
}

// A `ip` block as defined below.
func (o StreamingEndpointAccessControlPtrOutput) IpAllows() StreamingEndpointAccessControlIpAllowArrayOutput {
	return o.ApplyT(func(v *StreamingEndpointAccessControl) []StreamingEndpointAccessControlIpAllow {
		if v == nil {
			return nil
		}
		return v.IpAllows
	}).(StreamingEndpointAccessControlIpAllowArrayOutput)
}

type StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKey struct {
	// Authentication key.
	Base64Key *string `pulumi:"base64Key"`
	// The expiration time of the authentication key.
	Expiration *string `pulumi:"expiration"`
	// Identifier of the key.
	Identifier *string `pulumi:"identifier"`
}

// StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyInput is an input type that accepts StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyArgs and StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyOutput values.
// You can construct a concrete instance of `StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyInput` via:
//
//          StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyArgs{...}
type StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyInput interface {
	pulumi.Input

	ToStreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyOutput() StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyOutput
	ToStreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyOutputWithContext(context.Context) StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyOutput
}

type StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyArgs struct {
	// Authentication key.
	Base64Key pulumi.StringPtrInput `pulumi:"base64Key"`
	// The expiration time of the authentication key.
	Expiration pulumi.StringPtrInput `pulumi:"expiration"`
	// Identifier of the key.
	Identifier pulumi.StringPtrInput `pulumi:"identifier"`
}

func (StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKey)(nil)).Elem()
}

func (i StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyArgs) ToStreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyOutput() StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyOutput {
	return i.ToStreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyOutputWithContext(context.Background())
}

func (i StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyArgs) ToStreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyOutputWithContext(ctx context.Context) StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyOutput)
}

// StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyArrayInput is an input type that accepts StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyArray and StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyArrayOutput values.
// You can construct a concrete instance of `StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyArrayInput` via:
//
//          StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyArray{ StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyArgs{...} }
type StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyArrayInput interface {
	pulumi.Input

	ToStreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyArrayOutput() StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyArrayOutput
	ToStreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyArrayOutputWithContext(context.Context) StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyArrayOutput
}

type StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyArray []StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyInput

func (StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKey)(nil)).Elem()
}

func (i StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyArray) ToStreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyArrayOutput() StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyArrayOutput {
	return i.ToStreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyArrayOutputWithContext(context.Background())
}

func (i StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyArray) ToStreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyArrayOutputWithContext(ctx context.Context) StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyArrayOutput)
}

type StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyOutput struct{ *pulumi.OutputState }

func (StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKey)(nil)).Elem()
}

func (o StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyOutput) ToStreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyOutput() StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyOutput {
	return o
}

func (o StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyOutput) ToStreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyOutputWithContext(ctx context.Context) StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyOutput {
	return o
}

// Authentication key.
func (o StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyOutput) Base64Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKey) *string {
		return v.Base64Key
	}).(pulumi.StringPtrOutput)
}

// The expiration time of the authentication key.
func (o StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyOutput) Expiration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKey) *string {
		return v.Expiration
	}).(pulumi.StringPtrOutput)
}

// Identifier of the key.
func (o StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyOutput) Identifier() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKey) *string {
		return v.Identifier
	}).(pulumi.StringPtrOutput)
}

type StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyArrayOutput struct{ *pulumi.OutputState }

func (StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKey)(nil)).Elem()
}

func (o StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyArrayOutput) ToStreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyArrayOutput() StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyArrayOutput {
	return o
}

func (o StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyArrayOutput) ToStreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyArrayOutputWithContext(ctx context.Context) StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyArrayOutput {
	return o
}

func (o StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyArrayOutput) Index(i pulumi.IntInput) StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKey {
		return vs[0].([]StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKey)[vs[1].(int)]
	}).(StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyOutput)
}

type StreamingEndpointAccessControlIpAllow struct {
	// The IP address to allow.
	Address *string `pulumi:"address"`
	// The friendly name for the IP address range.
	Name *string `pulumi:"name"`
	// The subnet mask prefix length (see CIDR notation).
	SubnetPrefixLength *int `pulumi:"subnetPrefixLength"`
}

// StreamingEndpointAccessControlIpAllowInput is an input type that accepts StreamingEndpointAccessControlIpAllowArgs and StreamingEndpointAccessControlIpAllowOutput values.
// You can construct a concrete instance of `StreamingEndpointAccessControlIpAllowInput` via:
//
//          StreamingEndpointAccessControlIpAllowArgs{...}
type StreamingEndpointAccessControlIpAllowInput interface {
	pulumi.Input

	ToStreamingEndpointAccessControlIpAllowOutput() StreamingEndpointAccessControlIpAllowOutput
	ToStreamingEndpointAccessControlIpAllowOutputWithContext(context.Context) StreamingEndpointAccessControlIpAllowOutput
}

type StreamingEndpointAccessControlIpAllowArgs struct {
	// The IP address to allow.
	Address pulumi.StringPtrInput `pulumi:"address"`
	// The friendly name for the IP address range.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// The subnet mask prefix length (see CIDR notation).
	SubnetPrefixLength pulumi.IntPtrInput `pulumi:"subnetPrefixLength"`
}

func (StreamingEndpointAccessControlIpAllowArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingEndpointAccessControlIpAllow)(nil)).Elem()
}

func (i StreamingEndpointAccessControlIpAllowArgs) ToStreamingEndpointAccessControlIpAllowOutput() StreamingEndpointAccessControlIpAllowOutput {
	return i.ToStreamingEndpointAccessControlIpAllowOutputWithContext(context.Background())
}

func (i StreamingEndpointAccessControlIpAllowArgs) ToStreamingEndpointAccessControlIpAllowOutputWithContext(ctx context.Context) StreamingEndpointAccessControlIpAllowOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingEndpointAccessControlIpAllowOutput)
}

// StreamingEndpointAccessControlIpAllowArrayInput is an input type that accepts StreamingEndpointAccessControlIpAllowArray and StreamingEndpointAccessControlIpAllowArrayOutput values.
// You can construct a concrete instance of `StreamingEndpointAccessControlIpAllowArrayInput` via:
//
//          StreamingEndpointAccessControlIpAllowArray{ StreamingEndpointAccessControlIpAllowArgs{...} }
type StreamingEndpointAccessControlIpAllowArrayInput interface {
	pulumi.Input

	ToStreamingEndpointAccessControlIpAllowArrayOutput() StreamingEndpointAccessControlIpAllowArrayOutput
	ToStreamingEndpointAccessControlIpAllowArrayOutputWithContext(context.Context) StreamingEndpointAccessControlIpAllowArrayOutput
}

type StreamingEndpointAccessControlIpAllowArray []StreamingEndpointAccessControlIpAllowInput

func (StreamingEndpointAccessControlIpAllowArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]StreamingEndpointAccessControlIpAllow)(nil)).Elem()
}

func (i StreamingEndpointAccessControlIpAllowArray) ToStreamingEndpointAccessControlIpAllowArrayOutput() StreamingEndpointAccessControlIpAllowArrayOutput {
	return i.ToStreamingEndpointAccessControlIpAllowArrayOutputWithContext(context.Background())
}

func (i StreamingEndpointAccessControlIpAllowArray) ToStreamingEndpointAccessControlIpAllowArrayOutputWithContext(ctx context.Context) StreamingEndpointAccessControlIpAllowArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingEndpointAccessControlIpAllowArrayOutput)
}

type StreamingEndpointAccessControlIpAllowOutput struct{ *pulumi.OutputState }

func (StreamingEndpointAccessControlIpAllowOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingEndpointAccessControlIpAllow)(nil)).Elem()
}

func (o StreamingEndpointAccessControlIpAllowOutput) ToStreamingEndpointAccessControlIpAllowOutput() StreamingEndpointAccessControlIpAllowOutput {
	return o
}

func (o StreamingEndpointAccessControlIpAllowOutput) ToStreamingEndpointAccessControlIpAllowOutputWithContext(ctx context.Context) StreamingEndpointAccessControlIpAllowOutput {
	return o
}

// The IP address to allow.
func (o StreamingEndpointAccessControlIpAllowOutput) Address() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StreamingEndpointAccessControlIpAllow) *string { return v.Address }).(pulumi.StringPtrOutput)
}

// The friendly name for the IP address range.
func (o StreamingEndpointAccessControlIpAllowOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StreamingEndpointAccessControlIpAllow) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// The subnet mask prefix length (see CIDR notation).
func (o StreamingEndpointAccessControlIpAllowOutput) SubnetPrefixLength() pulumi.IntPtrOutput {
	return o.ApplyT(func(v StreamingEndpointAccessControlIpAllow) *int { return v.SubnetPrefixLength }).(pulumi.IntPtrOutput)
}

type StreamingEndpointAccessControlIpAllowArrayOutput struct{ *pulumi.OutputState }

func (StreamingEndpointAccessControlIpAllowArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]StreamingEndpointAccessControlIpAllow)(nil)).Elem()
}

func (o StreamingEndpointAccessControlIpAllowArrayOutput) ToStreamingEndpointAccessControlIpAllowArrayOutput() StreamingEndpointAccessControlIpAllowArrayOutput {
	return o
}

func (o StreamingEndpointAccessControlIpAllowArrayOutput) ToStreamingEndpointAccessControlIpAllowArrayOutputWithContext(ctx context.Context) StreamingEndpointAccessControlIpAllowArrayOutput {
	return o
}

func (o StreamingEndpointAccessControlIpAllowArrayOutput) Index(i pulumi.IntInput) StreamingEndpointAccessControlIpAllowOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) StreamingEndpointAccessControlIpAllow {
		return vs[0].([]StreamingEndpointAccessControlIpAllow)[vs[1].(int)]
	}).(StreamingEndpointAccessControlIpAllowOutput)
}

type StreamingEndpointCrossSiteAccessPolicy struct {
	// The content of clientaccesspolicy.xml used by Silverlight.
	ClientAccessPolicy *string `pulumi:"clientAccessPolicy"`
	// The content of crossdomain.xml used by Silverlight.
	CrossDomainPolicy *string `pulumi:"crossDomainPolicy"`
}

// StreamingEndpointCrossSiteAccessPolicyInput is an input type that accepts StreamingEndpointCrossSiteAccessPolicyArgs and StreamingEndpointCrossSiteAccessPolicyOutput values.
// You can construct a concrete instance of `StreamingEndpointCrossSiteAccessPolicyInput` via:
//
//          StreamingEndpointCrossSiteAccessPolicyArgs{...}
type StreamingEndpointCrossSiteAccessPolicyInput interface {
	pulumi.Input

	ToStreamingEndpointCrossSiteAccessPolicyOutput() StreamingEndpointCrossSiteAccessPolicyOutput
	ToStreamingEndpointCrossSiteAccessPolicyOutputWithContext(context.Context) StreamingEndpointCrossSiteAccessPolicyOutput
}

type StreamingEndpointCrossSiteAccessPolicyArgs struct {
	// The content of clientaccesspolicy.xml used by Silverlight.
	ClientAccessPolicy pulumi.StringPtrInput `pulumi:"clientAccessPolicy"`
	// The content of crossdomain.xml used by Silverlight.
	CrossDomainPolicy pulumi.StringPtrInput `pulumi:"crossDomainPolicy"`
}

func (StreamingEndpointCrossSiteAccessPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingEndpointCrossSiteAccessPolicy)(nil)).Elem()
}

func (i StreamingEndpointCrossSiteAccessPolicyArgs) ToStreamingEndpointCrossSiteAccessPolicyOutput() StreamingEndpointCrossSiteAccessPolicyOutput {
	return i.ToStreamingEndpointCrossSiteAccessPolicyOutputWithContext(context.Background())
}

func (i StreamingEndpointCrossSiteAccessPolicyArgs) ToStreamingEndpointCrossSiteAccessPolicyOutputWithContext(ctx context.Context) StreamingEndpointCrossSiteAccessPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingEndpointCrossSiteAccessPolicyOutput)
}

func (i StreamingEndpointCrossSiteAccessPolicyArgs) ToStreamingEndpointCrossSiteAccessPolicyPtrOutput() StreamingEndpointCrossSiteAccessPolicyPtrOutput {
	return i.ToStreamingEndpointCrossSiteAccessPolicyPtrOutputWithContext(context.Background())
}

func (i StreamingEndpointCrossSiteAccessPolicyArgs) ToStreamingEndpointCrossSiteAccessPolicyPtrOutputWithContext(ctx context.Context) StreamingEndpointCrossSiteAccessPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingEndpointCrossSiteAccessPolicyOutput).ToStreamingEndpointCrossSiteAccessPolicyPtrOutputWithContext(ctx)
}

// StreamingEndpointCrossSiteAccessPolicyPtrInput is an input type that accepts StreamingEndpointCrossSiteAccessPolicyArgs, StreamingEndpointCrossSiteAccessPolicyPtr and StreamingEndpointCrossSiteAccessPolicyPtrOutput values.
// You can construct a concrete instance of `StreamingEndpointCrossSiteAccessPolicyPtrInput` via:
//
//          StreamingEndpointCrossSiteAccessPolicyArgs{...}
//
//  or:
//
//          nil
type StreamingEndpointCrossSiteAccessPolicyPtrInput interface {
	pulumi.Input

	ToStreamingEndpointCrossSiteAccessPolicyPtrOutput() StreamingEndpointCrossSiteAccessPolicyPtrOutput
	ToStreamingEndpointCrossSiteAccessPolicyPtrOutputWithContext(context.Context) StreamingEndpointCrossSiteAccessPolicyPtrOutput
}

type streamingEndpointCrossSiteAccessPolicyPtrType StreamingEndpointCrossSiteAccessPolicyArgs

func StreamingEndpointCrossSiteAccessPolicyPtr(v *StreamingEndpointCrossSiteAccessPolicyArgs) StreamingEndpointCrossSiteAccessPolicyPtrInput {
	return (*streamingEndpointCrossSiteAccessPolicyPtrType)(v)
}

func (*streamingEndpointCrossSiteAccessPolicyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**StreamingEndpointCrossSiteAccessPolicy)(nil)).Elem()
}

func (i *streamingEndpointCrossSiteAccessPolicyPtrType) ToStreamingEndpointCrossSiteAccessPolicyPtrOutput() StreamingEndpointCrossSiteAccessPolicyPtrOutput {
	return i.ToStreamingEndpointCrossSiteAccessPolicyPtrOutputWithContext(context.Background())
}

func (i *streamingEndpointCrossSiteAccessPolicyPtrType) ToStreamingEndpointCrossSiteAccessPolicyPtrOutputWithContext(ctx context.Context) StreamingEndpointCrossSiteAccessPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingEndpointCrossSiteAccessPolicyPtrOutput)
}

type StreamingEndpointCrossSiteAccessPolicyOutput struct{ *pulumi.OutputState }

func (StreamingEndpointCrossSiteAccessPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingEndpointCrossSiteAccessPolicy)(nil)).Elem()
}

func (o StreamingEndpointCrossSiteAccessPolicyOutput) ToStreamingEndpointCrossSiteAccessPolicyOutput() StreamingEndpointCrossSiteAccessPolicyOutput {
	return o
}

func (o StreamingEndpointCrossSiteAccessPolicyOutput) ToStreamingEndpointCrossSiteAccessPolicyOutputWithContext(ctx context.Context) StreamingEndpointCrossSiteAccessPolicyOutput {
	return o
}

func (o StreamingEndpointCrossSiteAccessPolicyOutput) ToStreamingEndpointCrossSiteAccessPolicyPtrOutput() StreamingEndpointCrossSiteAccessPolicyPtrOutput {
	return o.ToStreamingEndpointCrossSiteAccessPolicyPtrOutputWithContext(context.Background())
}

func (o StreamingEndpointCrossSiteAccessPolicyOutput) ToStreamingEndpointCrossSiteAccessPolicyPtrOutputWithContext(ctx context.Context) StreamingEndpointCrossSiteAccessPolicyPtrOutput {
	return o.ApplyT(func(v StreamingEndpointCrossSiteAccessPolicy) *StreamingEndpointCrossSiteAccessPolicy {
		return &v
	}).(StreamingEndpointCrossSiteAccessPolicyPtrOutput)
}

// The content of clientaccesspolicy.xml used by Silverlight.
func (o StreamingEndpointCrossSiteAccessPolicyOutput) ClientAccessPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StreamingEndpointCrossSiteAccessPolicy) *string { return v.ClientAccessPolicy }).(pulumi.StringPtrOutput)
}

// The content of crossdomain.xml used by Silverlight.
func (o StreamingEndpointCrossSiteAccessPolicyOutput) CrossDomainPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StreamingEndpointCrossSiteAccessPolicy) *string { return v.CrossDomainPolicy }).(pulumi.StringPtrOutput)
}

type StreamingEndpointCrossSiteAccessPolicyPtrOutput struct{ *pulumi.OutputState }

func (StreamingEndpointCrossSiteAccessPolicyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**StreamingEndpointCrossSiteAccessPolicy)(nil)).Elem()
}

func (o StreamingEndpointCrossSiteAccessPolicyPtrOutput) ToStreamingEndpointCrossSiteAccessPolicyPtrOutput() StreamingEndpointCrossSiteAccessPolicyPtrOutput {
	return o
}

func (o StreamingEndpointCrossSiteAccessPolicyPtrOutput) ToStreamingEndpointCrossSiteAccessPolicyPtrOutputWithContext(ctx context.Context) StreamingEndpointCrossSiteAccessPolicyPtrOutput {
	return o
}

func (o StreamingEndpointCrossSiteAccessPolicyPtrOutput) Elem() StreamingEndpointCrossSiteAccessPolicyOutput {
	return o.ApplyT(func(v *StreamingEndpointCrossSiteAccessPolicy) StreamingEndpointCrossSiteAccessPolicy { return *v }).(StreamingEndpointCrossSiteAccessPolicyOutput)
}

// The content of clientaccesspolicy.xml used by Silverlight.
func (o StreamingEndpointCrossSiteAccessPolicyPtrOutput) ClientAccessPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StreamingEndpointCrossSiteAccessPolicy) *string {
		if v == nil {
			return nil
		}
		return v.ClientAccessPolicy
	}).(pulumi.StringPtrOutput)
}

// The content of crossdomain.xml used by Silverlight.
func (o StreamingEndpointCrossSiteAccessPolicyPtrOutput) CrossDomainPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StreamingEndpointCrossSiteAccessPolicy) *string {
		if v == nil {
			return nil
		}
		return v.CrossDomainPolicy
	}).(pulumi.StringPtrOutput)
}

type TransformOutput struct {
	// A `audioAnalyzerPreset` block as defined below.
	AudioAnalyzerPreset *TransformOutputAudioAnalyzerPreset `pulumi:"audioAnalyzerPreset"`
	// A `builtinPreset` block as defined below.
	BuiltinPreset *TransformOutputBuiltinPreset `pulumi:"builtinPreset"`
	// A `faceDetectorPreset` block as defined below.
	FaceDetectorPreset *TransformOutputFaceDetectorPreset `pulumi:"faceDetectorPreset"`
	// A Transform can define more than one outputs. This property defines what the service should do when one output fails - either continue to produce other outputs, or, stop the other outputs. The overall Job state will not reflect failures of outputs that are specified with `ContinueJob`. Possibles value are `StopProcessingJob` or `ContinueJob`.
	OnErrorAction *string `pulumi:"onErrorAction"`
	// Sets the relative priority of the TransformOutputs within a Transform. This sets the priority that the service uses for processing Transform Outputs. Possibles value are `High`, `Normal` or `Low`.
	RelativePriority *string `pulumi:"relativePriority"`
	// A `videoAnalyzerPreset` block as defined below.
	VideoAnalyzerPreset *TransformOutputVideoAnalyzerPreset `pulumi:"videoAnalyzerPreset"`
}

// TransformOutputInput is an input type that accepts TransformOutputArgs and TransformOutputOutput values.
// You can construct a concrete instance of `TransformOutputInput` via:
//
//          TransformOutputArgs{...}
type TransformOutputInput interface {
	pulumi.Input

	ToTransformOutputOutput() TransformOutputOutput
	ToTransformOutputOutputWithContext(context.Context) TransformOutputOutput
}

type TransformOutputArgs struct {
	// A `audioAnalyzerPreset` block as defined below.
	AudioAnalyzerPreset TransformOutputAudioAnalyzerPresetPtrInput `pulumi:"audioAnalyzerPreset"`
	// A `builtinPreset` block as defined below.
	BuiltinPreset TransformOutputBuiltinPresetPtrInput `pulumi:"builtinPreset"`
	// A `faceDetectorPreset` block as defined below.
	FaceDetectorPreset TransformOutputFaceDetectorPresetPtrInput `pulumi:"faceDetectorPreset"`
	// A Transform can define more than one outputs. This property defines what the service should do when one output fails - either continue to produce other outputs, or, stop the other outputs. The overall Job state will not reflect failures of outputs that are specified with `ContinueJob`. Possibles value are `StopProcessingJob` or `ContinueJob`.
	OnErrorAction pulumi.StringPtrInput `pulumi:"onErrorAction"`
	// Sets the relative priority of the TransformOutputs within a Transform. This sets the priority that the service uses for processing Transform Outputs. Possibles value are `High`, `Normal` or `Low`.
	RelativePriority pulumi.StringPtrInput `pulumi:"relativePriority"`
	// A `videoAnalyzerPreset` block as defined below.
	VideoAnalyzerPreset TransformOutputVideoAnalyzerPresetPtrInput `pulumi:"videoAnalyzerPreset"`
}

func (TransformOutputArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TransformOutput)(nil)).Elem()
}

func (i TransformOutputArgs) ToTransformOutputOutput() TransformOutputOutput {
	return i.ToTransformOutputOutputWithContext(context.Background())
}

func (i TransformOutputArgs) ToTransformOutputOutputWithContext(ctx context.Context) TransformOutputOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TransformOutputOutput)
}

// TransformOutputArrayInput is an input type that accepts TransformOutputArray and TransformOutputArrayOutput values.
// You can construct a concrete instance of `TransformOutputArrayInput` via:
//
//          TransformOutputArray{ TransformOutputArgs{...} }
type TransformOutputArrayInput interface {
	pulumi.Input

	ToTransformOutputArrayOutput() TransformOutputArrayOutput
	ToTransformOutputArrayOutputWithContext(context.Context) TransformOutputArrayOutput
}

type TransformOutputArray []TransformOutputInput

func (TransformOutputArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TransformOutput)(nil)).Elem()
}

func (i TransformOutputArray) ToTransformOutputArrayOutput() TransformOutputArrayOutput {
	return i.ToTransformOutputArrayOutputWithContext(context.Background())
}

func (i TransformOutputArray) ToTransformOutputArrayOutputWithContext(ctx context.Context) TransformOutputArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TransformOutputArrayOutput)
}

type TransformOutputOutput struct{ *pulumi.OutputState }

func (TransformOutputOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TransformOutput)(nil)).Elem()
}

func (o TransformOutputOutput) ToTransformOutputOutput() TransformOutputOutput {
	return o
}

func (o TransformOutputOutput) ToTransformOutputOutputWithContext(ctx context.Context) TransformOutputOutput {
	return o
}

// A `audioAnalyzerPreset` block as defined below.
func (o TransformOutputOutput) AudioAnalyzerPreset() TransformOutputAudioAnalyzerPresetPtrOutput {
	return o.ApplyT(func(v TransformOutput) *TransformOutputAudioAnalyzerPreset { return v.AudioAnalyzerPreset }).(TransformOutputAudioAnalyzerPresetPtrOutput)
}

// A `builtinPreset` block as defined below.
func (o TransformOutputOutput) BuiltinPreset() TransformOutputBuiltinPresetPtrOutput {
	return o.ApplyT(func(v TransformOutput) *TransformOutputBuiltinPreset { return v.BuiltinPreset }).(TransformOutputBuiltinPresetPtrOutput)
}

// A `faceDetectorPreset` block as defined below.
func (o TransformOutputOutput) FaceDetectorPreset() TransformOutputFaceDetectorPresetPtrOutput {
	return o.ApplyT(func(v TransformOutput) *TransformOutputFaceDetectorPreset { return v.FaceDetectorPreset }).(TransformOutputFaceDetectorPresetPtrOutput)
}

// A Transform can define more than one outputs. This property defines what the service should do when one output fails - either continue to produce other outputs, or, stop the other outputs. The overall Job state will not reflect failures of outputs that are specified with `ContinueJob`. Possibles value are `StopProcessingJob` or `ContinueJob`.
func (o TransformOutputOutput) OnErrorAction() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TransformOutput) *string { return v.OnErrorAction }).(pulumi.StringPtrOutput)
}

// Sets the relative priority of the TransformOutputs within a Transform. This sets the priority that the service uses for processing Transform Outputs. Possibles value are `High`, `Normal` or `Low`.
func (o TransformOutputOutput) RelativePriority() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TransformOutput) *string { return v.RelativePriority }).(pulumi.StringPtrOutput)
}

// A `videoAnalyzerPreset` block as defined below.
func (o TransformOutputOutput) VideoAnalyzerPreset() TransformOutputVideoAnalyzerPresetPtrOutput {
	return o.ApplyT(func(v TransformOutput) *TransformOutputVideoAnalyzerPreset { return v.VideoAnalyzerPreset }).(TransformOutputVideoAnalyzerPresetPtrOutput)
}

type TransformOutputArrayOutput struct{ *pulumi.OutputState }

func (TransformOutputArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TransformOutput)(nil)).Elem()
}

func (o TransformOutputArrayOutput) ToTransformOutputArrayOutput() TransformOutputArrayOutput {
	return o
}

func (o TransformOutputArrayOutput) ToTransformOutputArrayOutputWithContext(ctx context.Context) TransformOutputArrayOutput {
	return o
}

func (o TransformOutputArrayOutput) Index(i pulumi.IntInput) TransformOutputOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TransformOutput {
		return vs[0].([]TransformOutput)[vs[1].(int)]
	}).(TransformOutputOutput)
}

type TransformOutputAudioAnalyzerPreset struct {
	// Possibles value are `Basic` or `Standard`. Determines the set of audio analysis operations to be performed.
	AudioAnalysisMode *string `pulumi:"audioAnalysisMode"`
	// The language for the audio payload in the input using the BCP-47 format of 'language tag-region' (e.g: 'en-US'). If you know the language of your content, it is recommended that you specify it. The language must be specified explicitly for AudioAnalysisMode:Basic, since automatic language detection is not included in basic mode. If the language isn't specified, automatic language detection will choose the first language detected and process with the selected language for the duration of the file. It does not currently support dynamically switching between languages after the first language is detected. The automatic detection works best with audio recordings with clearly discernable speech. If automatic detection fails to find the language, transcription would fallback to 'en-US'." The list of supported languages is available here: https://go.microsoft.com/fwlink/?linkid=2109463.
	AudioLanguage *string `pulumi:"audioLanguage"`
}

// TransformOutputAudioAnalyzerPresetInput is an input type that accepts TransformOutputAudioAnalyzerPresetArgs and TransformOutputAudioAnalyzerPresetOutput values.
// You can construct a concrete instance of `TransformOutputAudioAnalyzerPresetInput` via:
//
//          TransformOutputAudioAnalyzerPresetArgs{...}
type TransformOutputAudioAnalyzerPresetInput interface {
	pulumi.Input

	ToTransformOutputAudioAnalyzerPresetOutput() TransformOutputAudioAnalyzerPresetOutput
	ToTransformOutputAudioAnalyzerPresetOutputWithContext(context.Context) TransformOutputAudioAnalyzerPresetOutput
}

type TransformOutputAudioAnalyzerPresetArgs struct {
	// Possibles value are `Basic` or `Standard`. Determines the set of audio analysis operations to be performed.
	AudioAnalysisMode pulumi.StringPtrInput `pulumi:"audioAnalysisMode"`
	// The language for the audio payload in the input using the BCP-47 format of 'language tag-region' (e.g: 'en-US'). If you know the language of your content, it is recommended that you specify it. The language must be specified explicitly for AudioAnalysisMode:Basic, since automatic language detection is not included in basic mode. If the language isn't specified, automatic language detection will choose the first language detected and process with the selected language for the duration of the file. It does not currently support dynamically switching between languages after the first language is detected. The automatic detection works best with audio recordings with clearly discernable speech. If automatic detection fails to find the language, transcription would fallback to 'en-US'." The list of supported languages is available here: https://go.microsoft.com/fwlink/?linkid=2109463.
	AudioLanguage pulumi.StringPtrInput `pulumi:"audioLanguage"`
}

func (TransformOutputAudioAnalyzerPresetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TransformOutputAudioAnalyzerPreset)(nil)).Elem()
}

func (i TransformOutputAudioAnalyzerPresetArgs) ToTransformOutputAudioAnalyzerPresetOutput() TransformOutputAudioAnalyzerPresetOutput {
	return i.ToTransformOutputAudioAnalyzerPresetOutputWithContext(context.Background())
}

func (i TransformOutputAudioAnalyzerPresetArgs) ToTransformOutputAudioAnalyzerPresetOutputWithContext(ctx context.Context) TransformOutputAudioAnalyzerPresetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TransformOutputAudioAnalyzerPresetOutput)
}

func (i TransformOutputAudioAnalyzerPresetArgs) ToTransformOutputAudioAnalyzerPresetPtrOutput() TransformOutputAudioAnalyzerPresetPtrOutput {
	return i.ToTransformOutputAudioAnalyzerPresetPtrOutputWithContext(context.Background())
}

func (i TransformOutputAudioAnalyzerPresetArgs) ToTransformOutputAudioAnalyzerPresetPtrOutputWithContext(ctx context.Context) TransformOutputAudioAnalyzerPresetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TransformOutputAudioAnalyzerPresetOutput).ToTransformOutputAudioAnalyzerPresetPtrOutputWithContext(ctx)
}

// TransformOutputAudioAnalyzerPresetPtrInput is an input type that accepts TransformOutputAudioAnalyzerPresetArgs, TransformOutputAudioAnalyzerPresetPtr and TransformOutputAudioAnalyzerPresetPtrOutput values.
// You can construct a concrete instance of `TransformOutputAudioAnalyzerPresetPtrInput` via:
//
//          TransformOutputAudioAnalyzerPresetArgs{...}
//
//  or:
//
//          nil
type TransformOutputAudioAnalyzerPresetPtrInput interface {
	pulumi.Input

	ToTransformOutputAudioAnalyzerPresetPtrOutput() TransformOutputAudioAnalyzerPresetPtrOutput
	ToTransformOutputAudioAnalyzerPresetPtrOutputWithContext(context.Context) TransformOutputAudioAnalyzerPresetPtrOutput
}

type transformOutputAudioAnalyzerPresetPtrType TransformOutputAudioAnalyzerPresetArgs

func TransformOutputAudioAnalyzerPresetPtr(v *TransformOutputAudioAnalyzerPresetArgs) TransformOutputAudioAnalyzerPresetPtrInput {
	return (*transformOutputAudioAnalyzerPresetPtrType)(v)
}

func (*transformOutputAudioAnalyzerPresetPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TransformOutputAudioAnalyzerPreset)(nil)).Elem()
}

func (i *transformOutputAudioAnalyzerPresetPtrType) ToTransformOutputAudioAnalyzerPresetPtrOutput() TransformOutputAudioAnalyzerPresetPtrOutput {
	return i.ToTransformOutputAudioAnalyzerPresetPtrOutputWithContext(context.Background())
}

func (i *transformOutputAudioAnalyzerPresetPtrType) ToTransformOutputAudioAnalyzerPresetPtrOutputWithContext(ctx context.Context) TransformOutputAudioAnalyzerPresetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TransformOutputAudioAnalyzerPresetPtrOutput)
}

type TransformOutputAudioAnalyzerPresetOutput struct{ *pulumi.OutputState }

func (TransformOutputAudioAnalyzerPresetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TransformOutputAudioAnalyzerPreset)(nil)).Elem()
}

func (o TransformOutputAudioAnalyzerPresetOutput) ToTransformOutputAudioAnalyzerPresetOutput() TransformOutputAudioAnalyzerPresetOutput {
	return o
}

func (o TransformOutputAudioAnalyzerPresetOutput) ToTransformOutputAudioAnalyzerPresetOutputWithContext(ctx context.Context) TransformOutputAudioAnalyzerPresetOutput {
	return o
}

func (o TransformOutputAudioAnalyzerPresetOutput) ToTransformOutputAudioAnalyzerPresetPtrOutput() TransformOutputAudioAnalyzerPresetPtrOutput {
	return o.ToTransformOutputAudioAnalyzerPresetPtrOutputWithContext(context.Background())
}

func (o TransformOutputAudioAnalyzerPresetOutput) ToTransformOutputAudioAnalyzerPresetPtrOutputWithContext(ctx context.Context) TransformOutputAudioAnalyzerPresetPtrOutput {
	return o.ApplyT(func(v TransformOutputAudioAnalyzerPreset) *TransformOutputAudioAnalyzerPreset {
		return &v
	}).(TransformOutputAudioAnalyzerPresetPtrOutput)
}

// Possibles value are `Basic` or `Standard`. Determines the set of audio analysis operations to be performed.
func (o TransformOutputAudioAnalyzerPresetOutput) AudioAnalysisMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TransformOutputAudioAnalyzerPreset) *string { return v.AudioAnalysisMode }).(pulumi.StringPtrOutput)
}

// The language for the audio payload in the input using the BCP-47 format of 'language tag-region' (e.g: 'en-US'). If you know the language of your content, it is recommended that you specify it. The language must be specified explicitly for AudioAnalysisMode:Basic, since automatic language detection is not included in basic mode. If the language isn't specified, automatic language detection will choose the first language detected and process with the selected language for the duration of the file. It does not currently support dynamically switching between languages after the first language is detected. The automatic detection works best with audio recordings with clearly discernable speech. If automatic detection fails to find the language, transcription would fallback to 'en-US'." The list of supported languages is available here: https://go.microsoft.com/fwlink/?linkid=2109463.
func (o TransformOutputAudioAnalyzerPresetOutput) AudioLanguage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TransformOutputAudioAnalyzerPreset) *string { return v.AudioLanguage }).(pulumi.StringPtrOutput)
}

type TransformOutputAudioAnalyzerPresetPtrOutput struct{ *pulumi.OutputState }

func (TransformOutputAudioAnalyzerPresetPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TransformOutputAudioAnalyzerPreset)(nil)).Elem()
}

func (o TransformOutputAudioAnalyzerPresetPtrOutput) ToTransformOutputAudioAnalyzerPresetPtrOutput() TransformOutputAudioAnalyzerPresetPtrOutput {
	return o
}

func (o TransformOutputAudioAnalyzerPresetPtrOutput) ToTransformOutputAudioAnalyzerPresetPtrOutputWithContext(ctx context.Context) TransformOutputAudioAnalyzerPresetPtrOutput {
	return o
}

func (o TransformOutputAudioAnalyzerPresetPtrOutput) Elem() TransformOutputAudioAnalyzerPresetOutput {
	return o.ApplyT(func(v *TransformOutputAudioAnalyzerPreset) TransformOutputAudioAnalyzerPreset { return *v }).(TransformOutputAudioAnalyzerPresetOutput)
}

// Possibles value are `Basic` or `Standard`. Determines the set of audio analysis operations to be performed.
func (o TransformOutputAudioAnalyzerPresetPtrOutput) AudioAnalysisMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TransformOutputAudioAnalyzerPreset) *string {
		if v == nil {
			return nil
		}
		return v.AudioAnalysisMode
	}).(pulumi.StringPtrOutput)
}

// The language for the audio payload in the input using the BCP-47 format of 'language tag-region' (e.g: 'en-US'). If you know the language of your content, it is recommended that you specify it. The language must be specified explicitly for AudioAnalysisMode:Basic, since automatic language detection is not included in basic mode. If the language isn't specified, automatic language detection will choose the first language detected and process with the selected language for the duration of the file. It does not currently support dynamically switching between languages after the first language is detected. The automatic detection works best with audio recordings with clearly discernable speech. If automatic detection fails to find the language, transcription would fallback to 'en-US'." The list of supported languages is available here: https://go.microsoft.com/fwlink/?linkid=2109463.
func (o TransformOutputAudioAnalyzerPresetPtrOutput) AudioLanguage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TransformOutputAudioAnalyzerPreset) *string {
		if v == nil {
			return nil
		}
		return v.AudioLanguage
	}).(pulumi.StringPtrOutput)
}

type TransformOutputBuiltinPreset struct {
	// The built-in preset to be used for encoding videos. The allowed values are `AACGoodQualityAudio`, `AdaptiveStreaming`,`ContentAwareEncoding`, `ContentAwareEncodingExperimental`,`CopyAllBitrateNonInterleaved`, `H264MultipleBitrate1080p`,`H264MultipleBitrate720p`, `H264MultipleBitrateSD`,`H264SingleBitrate1080p`, `H264SingleBitrate720p` and `H264SingleBitrateSD`.
	PresetName *string `pulumi:"presetName"`
}

// TransformOutputBuiltinPresetInput is an input type that accepts TransformOutputBuiltinPresetArgs and TransformOutputBuiltinPresetOutput values.
// You can construct a concrete instance of `TransformOutputBuiltinPresetInput` via:
//
//          TransformOutputBuiltinPresetArgs{...}
type TransformOutputBuiltinPresetInput interface {
	pulumi.Input

	ToTransformOutputBuiltinPresetOutput() TransformOutputBuiltinPresetOutput
	ToTransformOutputBuiltinPresetOutputWithContext(context.Context) TransformOutputBuiltinPresetOutput
}

type TransformOutputBuiltinPresetArgs struct {
	// The built-in preset to be used for encoding videos. The allowed values are `AACGoodQualityAudio`, `AdaptiveStreaming`,`ContentAwareEncoding`, `ContentAwareEncodingExperimental`,`CopyAllBitrateNonInterleaved`, `H264MultipleBitrate1080p`,`H264MultipleBitrate720p`, `H264MultipleBitrateSD`,`H264SingleBitrate1080p`, `H264SingleBitrate720p` and `H264SingleBitrateSD`.
	PresetName pulumi.StringPtrInput `pulumi:"presetName"`
}

func (TransformOutputBuiltinPresetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TransformOutputBuiltinPreset)(nil)).Elem()
}

func (i TransformOutputBuiltinPresetArgs) ToTransformOutputBuiltinPresetOutput() TransformOutputBuiltinPresetOutput {
	return i.ToTransformOutputBuiltinPresetOutputWithContext(context.Background())
}

func (i TransformOutputBuiltinPresetArgs) ToTransformOutputBuiltinPresetOutputWithContext(ctx context.Context) TransformOutputBuiltinPresetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TransformOutputBuiltinPresetOutput)
}

func (i TransformOutputBuiltinPresetArgs) ToTransformOutputBuiltinPresetPtrOutput() TransformOutputBuiltinPresetPtrOutput {
	return i.ToTransformOutputBuiltinPresetPtrOutputWithContext(context.Background())
}

func (i TransformOutputBuiltinPresetArgs) ToTransformOutputBuiltinPresetPtrOutputWithContext(ctx context.Context) TransformOutputBuiltinPresetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TransformOutputBuiltinPresetOutput).ToTransformOutputBuiltinPresetPtrOutputWithContext(ctx)
}

// TransformOutputBuiltinPresetPtrInput is an input type that accepts TransformOutputBuiltinPresetArgs, TransformOutputBuiltinPresetPtr and TransformOutputBuiltinPresetPtrOutput values.
// You can construct a concrete instance of `TransformOutputBuiltinPresetPtrInput` via:
//
//          TransformOutputBuiltinPresetArgs{...}
//
//  or:
//
//          nil
type TransformOutputBuiltinPresetPtrInput interface {
	pulumi.Input

	ToTransformOutputBuiltinPresetPtrOutput() TransformOutputBuiltinPresetPtrOutput
	ToTransformOutputBuiltinPresetPtrOutputWithContext(context.Context) TransformOutputBuiltinPresetPtrOutput
}

type transformOutputBuiltinPresetPtrType TransformOutputBuiltinPresetArgs

func TransformOutputBuiltinPresetPtr(v *TransformOutputBuiltinPresetArgs) TransformOutputBuiltinPresetPtrInput {
	return (*transformOutputBuiltinPresetPtrType)(v)
}

func (*transformOutputBuiltinPresetPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TransformOutputBuiltinPreset)(nil)).Elem()
}

func (i *transformOutputBuiltinPresetPtrType) ToTransformOutputBuiltinPresetPtrOutput() TransformOutputBuiltinPresetPtrOutput {
	return i.ToTransformOutputBuiltinPresetPtrOutputWithContext(context.Background())
}

func (i *transformOutputBuiltinPresetPtrType) ToTransformOutputBuiltinPresetPtrOutputWithContext(ctx context.Context) TransformOutputBuiltinPresetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TransformOutputBuiltinPresetPtrOutput)
}

type TransformOutputBuiltinPresetOutput struct{ *pulumi.OutputState }

func (TransformOutputBuiltinPresetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TransformOutputBuiltinPreset)(nil)).Elem()
}

func (o TransformOutputBuiltinPresetOutput) ToTransformOutputBuiltinPresetOutput() TransformOutputBuiltinPresetOutput {
	return o
}

func (o TransformOutputBuiltinPresetOutput) ToTransformOutputBuiltinPresetOutputWithContext(ctx context.Context) TransformOutputBuiltinPresetOutput {
	return o
}

func (o TransformOutputBuiltinPresetOutput) ToTransformOutputBuiltinPresetPtrOutput() TransformOutputBuiltinPresetPtrOutput {
	return o.ToTransformOutputBuiltinPresetPtrOutputWithContext(context.Background())
}

func (o TransformOutputBuiltinPresetOutput) ToTransformOutputBuiltinPresetPtrOutputWithContext(ctx context.Context) TransformOutputBuiltinPresetPtrOutput {
	return o.ApplyT(func(v TransformOutputBuiltinPreset) *TransformOutputBuiltinPreset {
		return &v
	}).(TransformOutputBuiltinPresetPtrOutput)
}

// The built-in preset to be used for encoding videos. The allowed values are `AACGoodQualityAudio`, `AdaptiveStreaming`,`ContentAwareEncoding`, `ContentAwareEncodingExperimental`,`CopyAllBitrateNonInterleaved`, `H264MultipleBitrate1080p`,`H264MultipleBitrate720p`, `H264MultipleBitrateSD`,`H264SingleBitrate1080p`, `H264SingleBitrate720p` and `H264SingleBitrateSD`.
func (o TransformOutputBuiltinPresetOutput) PresetName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TransformOutputBuiltinPreset) *string { return v.PresetName }).(pulumi.StringPtrOutput)
}

type TransformOutputBuiltinPresetPtrOutput struct{ *pulumi.OutputState }

func (TransformOutputBuiltinPresetPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TransformOutputBuiltinPreset)(nil)).Elem()
}

func (o TransformOutputBuiltinPresetPtrOutput) ToTransformOutputBuiltinPresetPtrOutput() TransformOutputBuiltinPresetPtrOutput {
	return o
}

func (o TransformOutputBuiltinPresetPtrOutput) ToTransformOutputBuiltinPresetPtrOutputWithContext(ctx context.Context) TransformOutputBuiltinPresetPtrOutput {
	return o
}

func (o TransformOutputBuiltinPresetPtrOutput) Elem() TransformOutputBuiltinPresetOutput {
	return o.ApplyT(func(v *TransformOutputBuiltinPreset) TransformOutputBuiltinPreset { return *v }).(TransformOutputBuiltinPresetOutput)
}

// The built-in preset to be used for encoding videos. The allowed values are `AACGoodQualityAudio`, `AdaptiveStreaming`,`ContentAwareEncoding`, `ContentAwareEncodingExperimental`,`CopyAllBitrateNonInterleaved`, `H264MultipleBitrate1080p`,`H264MultipleBitrate720p`, `H264MultipleBitrateSD`,`H264SingleBitrate1080p`, `H264SingleBitrate720p` and `H264SingleBitrateSD`.
func (o TransformOutputBuiltinPresetPtrOutput) PresetName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TransformOutputBuiltinPreset) *string {
		if v == nil {
			return nil
		}
		return v.PresetName
	}).(pulumi.StringPtrOutput)
}

type TransformOutputFaceDetectorPreset struct {
	// Possibles value are `SourceResolution` or `StandardDefinition`. Specifies the maximum resolution at which your video is analyzed. The default behavior is `SourceResolution` which will keep the input video at its original resolution when analyzed. Using `StandardDefinition` will resize input videos to standard definition while preserving the appropriate aspect ratio. It will only resize if the video is of higher resolution. For example, a 1920x1080 input would be scaled to 640x360 before processing. Switching to `StandardDefinition` will reduce the time it takes to process high resolution video. It may also reduce the cost of using this component (see https://azure.microsoft.com/en-us/pricing/details/media-services/#analytics for details). However, faces that end up being too small in the resized video may not be detected.
	AnalysisResolution *string `pulumi:"analysisResolution"`
}

// TransformOutputFaceDetectorPresetInput is an input type that accepts TransformOutputFaceDetectorPresetArgs and TransformOutputFaceDetectorPresetOutput values.
// You can construct a concrete instance of `TransformOutputFaceDetectorPresetInput` via:
//
//          TransformOutputFaceDetectorPresetArgs{...}
type TransformOutputFaceDetectorPresetInput interface {
	pulumi.Input

	ToTransformOutputFaceDetectorPresetOutput() TransformOutputFaceDetectorPresetOutput
	ToTransformOutputFaceDetectorPresetOutputWithContext(context.Context) TransformOutputFaceDetectorPresetOutput
}

type TransformOutputFaceDetectorPresetArgs struct {
	// Possibles value are `SourceResolution` or `StandardDefinition`. Specifies the maximum resolution at which your video is analyzed. The default behavior is `SourceResolution` which will keep the input video at its original resolution when analyzed. Using `StandardDefinition` will resize input videos to standard definition while preserving the appropriate aspect ratio. It will only resize if the video is of higher resolution. For example, a 1920x1080 input would be scaled to 640x360 before processing. Switching to `StandardDefinition` will reduce the time it takes to process high resolution video. It may also reduce the cost of using this component (see https://azure.microsoft.com/en-us/pricing/details/media-services/#analytics for details). However, faces that end up being too small in the resized video may not be detected.
	AnalysisResolution pulumi.StringPtrInput `pulumi:"analysisResolution"`
}

func (TransformOutputFaceDetectorPresetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TransformOutputFaceDetectorPreset)(nil)).Elem()
}

func (i TransformOutputFaceDetectorPresetArgs) ToTransformOutputFaceDetectorPresetOutput() TransformOutputFaceDetectorPresetOutput {
	return i.ToTransformOutputFaceDetectorPresetOutputWithContext(context.Background())
}

func (i TransformOutputFaceDetectorPresetArgs) ToTransformOutputFaceDetectorPresetOutputWithContext(ctx context.Context) TransformOutputFaceDetectorPresetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TransformOutputFaceDetectorPresetOutput)
}

func (i TransformOutputFaceDetectorPresetArgs) ToTransformOutputFaceDetectorPresetPtrOutput() TransformOutputFaceDetectorPresetPtrOutput {
	return i.ToTransformOutputFaceDetectorPresetPtrOutputWithContext(context.Background())
}

func (i TransformOutputFaceDetectorPresetArgs) ToTransformOutputFaceDetectorPresetPtrOutputWithContext(ctx context.Context) TransformOutputFaceDetectorPresetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TransformOutputFaceDetectorPresetOutput).ToTransformOutputFaceDetectorPresetPtrOutputWithContext(ctx)
}

// TransformOutputFaceDetectorPresetPtrInput is an input type that accepts TransformOutputFaceDetectorPresetArgs, TransformOutputFaceDetectorPresetPtr and TransformOutputFaceDetectorPresetPtrOutput values.
// You can construct a concrete instance of `TransformOutputFaceDetectorPresetPtrInput` via:
//
//          TransformOutputFaceDetectorPresetArgs{...}
//
//  or:
//
//          nil
type TransformOutputFaceDetectorPresetPtrInput interface {
	pulumi.Input

	ToTransformOutputFaceDetectorPresetPtrOutput() TransformOutputFaceDetectorPresetPtrOutput
	ToTransformOutputFaceDetectorPresetPtrOutputWithContext(context.Context) TransformOutputFaceDetectorPresetPtrOutput
}

type transformOutputFaceDetectorPresetPtrType TransformOutputFaceDetectorPresetArgs

func TransformOutputFaceDetectorPresetPtr(v *TransformOutputFaceDetectorPresetArgs) TransformOutputFaceDetectorPresetPtrInput {
	return (*transformOutputFaceDetectorPresetPtrType)(v)
}

func (*transformOutputFaceDetectorPresetPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TransformOutputFaceDetectorPreset)(nil)).Elem()
}

func (i *transformOutputFaceDetectorPresetPtrType) ToTransformOutputFaceDetectorPresetPtrOutput() TransformOutputFaceDetectorPresetPtrOutput {
	return i.ToTransformOutputFaceDetectorPresetPtrOutputWithContext(context.Background())
}

func (i *transformOutputFaceDetectorPresetPtrType) ToTransformOutputFaceDetectorPresetPtrOutputWithContext(ctx context.Context) TransformOutputFaceDetectorPresetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TransformOutputFaceDetectorPresetPtrOutput)
}

type TransformOutputFaceDetectorPresetOutput struct{ *pulumi.OutputState }

func (TransformOutputFaceDetectorPresetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TransformOutputFaceDetectorPreset)(nil)).Elem()
}

func (o TransformOutputFaceDetectorPresetOutput) ToTransformOutputFaceDetectorPresetOutput() TransformOutputFaceDetectorPresetOutput {
	return o
}

func (o TransformOutputFaceDetectorPresetOutput) ToTransformOutputFaceDetectorPresetOutputWithContext(ctx context.Context) TransformOutputFaceDetectorPresetOutput {
	return o
}

func (o TransformOutputFaceDetectorPresetOutput) ToTransformOutputFaceDetectorPresetPtrOutput() TransformOutputFaceDetectorPresetPtrOutput {
	return o.ToTransformOutputFaceDetectorPresetPtrOutputWithContext(context.Background())
}

func (o TransformOutputFaceDetectorPresetOutput) ToTransformOutputFaceDetectorPresetPtrOutputWithContext(ctx context.Context) TransformOutputFaceDetectorPresetPtrOutput {
	return o.ApplyT(func(v TransformOutputFaceDetectorPreset) *TransformOutputFaceDetectorPreset {
		return &v
	}).(TransformOutputFaceDetectorPresetPtrOutput)
}

// Possibles value are `SourceResolution` or `StandardDefinition`. Specifies the maximum resolution at which your video is analyzed. The default behavior is `SourceResolution` which will keep the input video at its original resolution when analyzed. Using `StandardDefinition` will resize input videos to standard definition while preserving the appropriate aspect ratio. It will only resize if the video is of higher resolution. For example, a 1920x1080 input would be scaled to 640x360 before processing. Switching to `StandardDefinition` will reduce the time it takes to process high resolution video. It may also reduce the cost of using this component (see https://azure.microsoft.com/en-us/pricing/details/media-services/#analytics for details). However, faces that end up being too small in the resized video may not be detected.
func (o TransformOutputFaceDetectorPresetOutput) AnalysisResolution() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TransformOutputFaceDetectorPreset) *string { return v.AnalysisResolution }).(pulumi.StringPtrOutput)
}

type TransformOutputFaceDetectorPresetPtrOutput struct{ *pulumi.OutputState }

func (TransformOutputFaceDetectorPresetPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TransformOutputFaceDetectorPreset)(nil)).Elem()
}

func (o TransformOutputFaceDetectorPresetPtrOutput) ToTransformOutputFaceDetectorPresetPtrOutput() TransformOutputFaceDetectorPresetPtrOutput {
	return o
}

func (o TransformOutputFaceDetectorPresetPtrOutput) ToTransformOutputFaceDetectorPresetPtrOutputWithContext(ctx context.Context) TransformOutputFaceDetectorPresetPtrOutput {
	return o
}

func (o TransformOutputFaceDetectorPresetPtrOutput) Elem() TransformOutputFaceDetectorPresetOutput {
	return o.ApplyT(func(v *TransformOutputFaceDetectorPreset) TransformOutputFaceDetectorPreset { return *v }).(TransformOutputFaceDetectorPresetOutput)
}

// Possibles value are `SourceResolution` or `StandardDefinition`. Specifies the maximum resolution at which your video is analyzed. The default behavior is `SourceResolution` which will keep the input video at its original resolution when analyzed. Using `StandardDefinition` will resize input videos to standard definition while preserving the appropriate aspect ratio. It will only resize if the video is of higher resolution. For example, a 1920x1080 input would be scaled to 640x360 before processing. Switching to `StandardDefinition` will reduce the time it takes to process high resolution video. It may also reduce the cost of using this component (see https://azure.microsoft.com/en-us/pricing/details/media-services/#analytics for details). However, faces that end up being too small in the resized video may not be detected.
func (o TransformOutputFaceDetectorPresetPtrOutput) AnalysisResolution() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TransformOutputFaceDetectorPreset) *string {
		if v == nil {
			return nil
		}
		return v.AnalysisResolution
	}).(pulumi.StringPtrOutput)
}

type TransformOutputVideoAnalyzerPreset struct {
	// Possibles value are `Basic` or `Standard`. Determines the set of audio analysis operations to be performed.
	AudioAnalysisMode *string `pulumi:"audioAnalysisMode"`
	// The language for the audio payload in the input using the BCP-47 format of 'language tag-region' (e.g: 'en-US'). If you know the language of your content, it is recommended that you specify it. The language must be specified explicitly for AudioAnalysisMode:Basic, since automatic language detection is not included in basic mode. If the language isn't specified, automatic language detection will choose the first language detected and process with the selected language for the duration of the file. It does not currently support dynamically switching between languages after the first language is detected. The automatic detection works best with audio recordings with clearly discernable speech. If automatic detection fails to find the language, transcription would fallback to 'en-US'." The list of supported languages is available here: https://go.microsoft.com/fwlink/?linkid=2109463.
	AudioLanguage *string `pulumi:"audioLanguage"`
	// Defines the type of insights that you want the service to generate. The allowed values are `AudioInsightsOnly`, `VideoInsightsOnly`, and `AllInsights`. If you set this to `AllInsights` and the input is audio only, then only audio insights are generated. Similarly if the input is video only, then only video insights are generated. It is recommended that you not use `AudioInsightsOnly` if you expect some of your inputs to be video only; or use `VideoInsightsOnly` if you expect some of your inputs to be audio only. Your Jobs in such conditions would error out.
	InsightsType *string `pulumi:"insightsType"`
}

// TransformOutputVideoAnalyzerPresetInput is an input type that accepts TransformOutputVideoAnalyzerPresetArgs and TransformOutputVideoAnalyzerPresetOutput values.
// You can construct a concrete instance of `TransformOutputVideoAnalyzerPresetInput` via:
//
//          TransformOutputVideoAnalyzerPresetArgs{...}
type TransformOutputVideoAnalyzerPresetInput interface {
	pulumi.Input

	ToTransformOutputVideoAnalyzerPresetOutput() TransformOutputVideoAnalyzerPresetOutput
	ToTransformOutputVideoAnalyzerPresetOutputWithContext(context.Context) TransformOutputVideoAnalyzerPresetOutput
}

type TransformOutputVideoAnalyzerPresetArgs struct {
	// Possibles value are `Basic` or `Standard`. Determines the set of audio analysis operations to be performed.
	AudioAnalysisMode pulumi.StringPtrInput `pulumi:"audioAnalysisMode"`
	// The language for the audio payload in the input using the BCP-47 format of 'language tag-region' (e.g: 'en-US'). If you know the language of your content, it is recommended that you specify it. The language must be specified explicitly for AudioAnalysisMode:Basic, since automatic language detection is not included in basic mode. If the language isn't specified, automatic language detection will choose the first language detected and process with the selected language for the duration of the file. It does not currently support dynamically switching between languages after the first language is detected. The automatic detection works best with audio recordings with clearly discernable speech. If automatic detection fails to find the language, transcription would fallback to 'en-US'." The list of supported languages is available here: https://go.microsoft.com/fwlink/?linkid=2109463.
	AudioLanguage pulumi.StringPtrInput `pulumi:"audioLanguage"`
	// Defines the type of insights that you want the service to generate. The allowed values are `AudioInsightsOnly`, `VideoInsightsOnly`, and `AllInsights`. If you set this to `AllInsights` and the input is audio only, then only audio insights are generated. Similarly if the input is video only, then only video insights are generated. It is recommended that you not use `AudioInsightsOnly` if you expect some of your inputs to be video only; or use `VideoInsightsOnly` if you expect some of your inputs to be audio only. Your Jobs in such conditions would error out.
	InsightsType pulumi.StringPtrInput `pulumi:"insightsType"`
}

func (TransformOutputVideoAnalyzerPresetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TransformOutputVideoAnalyzerPreset)(nil)).Elem()
}

func (i TransformOutputVideoAnalyzerPresetArgs) ToTransformOutputVideoAnalyzerPresetOutput() TransformOutputVideoAnalyzerPresetOutput {
	return i.ToTransformOutputVideoAnalyzerPresetOutputWithContext(context.Background())
}

func (i TransformOutputVideoAnalyzerPresetArgs) ToTransformOutputVideoAnalyzerPresetOutputWithContext(ctx context.Context) TransformOutputVideoAnalyzerPresetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TransformOutputVideoAnalyzerPresetOutput)
}

func (i TransformOutputVideoAnalyzerPresetArgs) ToTransformOutputVideoAnalyzerPresetPtrOutput() TransformOutputVideoAnalyzerPresetPtrOutput {
	return i.ToTransformOutputVideoAnalyzerPresetPtrOutputWithContext(context.Background())
}

func (i TransformOutputVideoAnalyzerPresetArgs) ToTransformOutputVideoAnalyzerPresetPtrOutputWithContext(ctx context.Context) TransformOutputVideoAnalyzerPresetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TransformOutputVideoAnalyzerPresetOutput).ToTransformOutputVideoAnalyzerPresetPtrOutputWithContext(ctx)
}

// TransformOutputVideoAnalyzerPresetPtrInput is an input type that accepts TransformOutputVideoAnalyzerPresetArgs, TransformOutputVideoAnalyzerPresetPtr and TransformOutputVideoAnalyzerPresetPtrOutput values.
// You can construct a concrete instance of `TransformOutputVideoAnalyzerPresetPtrInput` via:
//
//          TransformOutputVideoAnalyzerPresetArgs{...}
//
//  or:
//
//          nil
type TransformOutputVideoAnalyzerPresetPtrInput interface {
	pulumi.Input

	ToTransformOutputVideoAnalyzerPresetPtrOutput() TransformOutputVideoAnalyzerPresetPtrOutput
	ToTransformOutputVideoAnalyzerPresetPtrOutputWithContext(context.Context) TransformOutputVideoAnalyzerPresetPtrOutput
}

type transformOutputVideoAnalyzerPresetPtrType TransformOutputVideoAnalyzerPresetArgs

func TransformOutputVideoAnalyzerPresetPtr(v *TransformOutputVideoAnalyzerPresetArgs) TransformOutputVideoAnalyzerPresetPtrInput {
	return (*transformOutputVideoAnalyzerPresetPtrType)(v)
}

func (*transformOutputVideoAnalyzerPresetPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TransformOutputVideoAnalyzerPreset)(nil)).Elem()
}

func (i *transformOutputVideoAnalyzerPresetPtrType) ToTransformOutputVideoAnalyzerPresetPtrOutput() TransformOutputVideoAnalyzerPresetPtrOutput {
	return i.ToTransformOutputVideoAnalyzerPresetPtrOutputWithContext(context.Background())
}

func (i *transformOutputVideoAnalyzerPresetPtrType) ToTransformOutputVideoAnalyzerPresetPtrOutputWithContext(ctx context.Context) TransformOutputVideoAnalyzerPresetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TransformOutputVideoAnalyzerPresetPtrOutput)
}

type TransformOutputVideoAnalyzerPresetOutput struct{ *pulumi.OutputState }

func (TransformOutputVideoAnalyzerPresetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TransformOutputVideoAnalyzerPreset)(nil)).Elem()
}

func (o TransformOutputVideoAnalyzerPresetOutput) ToTransformOutputVideoAnalyzerPresetOutput() TransformOutputVideoAnalyzerPresetOutput {
	return o
}

func (o TransformOutputVideoAnalyzerPresetOutput) ToTransformOutputVideoAnalyzerPresetOutputWithContext(ctx context.Context) TransformOutputVideoAnalyzerPresetOutput {
	return o
}

func (o TransformOutputVideoAnalyzerPresetOutput) ToTransformOutputVideoAnalyzerPresetPtrOutput() TransformOutputVideoAnalyzerPresetPtrOutput {
	return o.ToTransformOutputVideoAnalyzerPresetPtrOutputWithContext(context.Background())
}

func (o TransformOutputVideoAnalyzerPresetOutput) ToTransformOutputVideoAnalyzerPresetPtrOutputWithContext(ctx context.Context) TransformOutputVideoAnalyzerPresetPtrOutput {
	return o.ApplyT(func(v TransformOutputVideoAnalyzerPreset) *TransformOutputVideoAnalyzerPreset {
		return &v
	}).(TransformOutputVideoAnalyzerPresetPtrOutput)
}

// Possibles value are `Basic` or `Standard`. Determines the set of audio analysis operations to be performed.
func (o TransformOutputVideoAnalyzerPresetOutput) AudioAnalysisMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TransformOutputVideoAnalyzerPreset) *string { return v.AudioAnalysisMode }).(pulumi.StringPtrOutput)
}

// The language for the audio payload in the input using the BCP-47 format of 'language tag-region' (e.g: 'en-US'). If you know the language of your content, it is recommended that you specify it. The language must be specified explicitly for AudioAnalysisMode:Basic, since automatic language detection is not included in basic mode. If the language isn't specified, automatic language detection will choose the first language detected and process with the selected language for the duration of the file. It does not currently support dynamically switching between languages after the first language is detected. The automatic detection works best with audio recordings with clearly discernable speech. If automatic detection fails to find the language, transcription would fallback to 'en-US'." The list of supported languages is available here: https://go.microsoft.com/fwlink/?linkid=2109463.
func (o TransformOutputVideoAnalyzerPresetOutput) AudioLanguage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TransformOutputVideoAnalyzerPreset) *string { return v.AudioLanguage }).(pulumi.StringPtrOutput)
}

// Defines the type of insights that you want the service to generate. The allowed values are `AudioInsightsOnly`, `VideoInsightsOnly`, and `AllInsights`. If you set this to `AllInsights` and the input is audio only, then only audio insights are generated. Similarly if the input is video only, then only video insights are generated. It is recommended that you not use `AudioInsightsOnly` if you expect some of your inputs to be video only; or use `VideoInsightsOnly` if you expect some of your inputs to be audio only. Your Jobs in such conditions would error out.
func (o TransformOutputVideoAnalyzerPresetOutput) InsightsType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TransformOutputVideoAnalyzerPreset) *string { return v.InsightsType }).(pulumi.StringPtrOutput)
}

type TransformOutputVideoAnalyzerPresetPtrOutput struct{ *pulumi.OutputState }

func (TransformOutputVideoAnalyzerPresetPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TransformOutputVideoAnalyzerPreset)(nil)).Elem()
}

func (o TransformOutputVideoAnalyzerPresetPtrOutput) ToTransformOutputVideoAnalyzerPresetPtrOutput() TransformOutputVideoAnalyzerPresetPtrOutput {
	return o
}

func (o TransformOutputVideoAnalyzerPresetPtrOutput) ToTransformOutputVideoAnalyzerPresetPtrOutputWithContext(ctx context.Context) TransformOutputVideoAnalyzerPresetPtrOutput {
	return o
}

func (o TransformOutputVideoAnalyzerPresetPtrOutput) Elem() TransformOutputVideoAnalyzerPresetOutput {
	return o.ApplyT(func(v *TransformOutputVideoAnalyzerPreset) TransformOutputVideoAnalyzerPreset { return *v }).(TransformOutputVideoAnalyzerPresetOutput)
}

// Possibles value are `Basic` or `Standard`. Determines the set of audio analysis operations to be performed.
func (o TransformOutputVideoAnalyzerPresetPtrOutput) AudioAnalysisMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TransformOutputVideoAnalyzerPreset) *string {
		if v == nil {
			return nil
		}
		return v.AudioAnalysisMode
	}).(pulumi.StringPtrOutput)
}

// The language for the audio payload in the input using the BCP-47 format of 'language tag-region' (e.g: 'en-US'). If you know the language of your content, it is recommended that you specify it. The language must be specified explicitly for AudioAnalysisMode:Basic, since automatic language detection is not included in basic mode. If the language isn't specified, automatic language detection will choose the first language detected and process with the selected language for the duration of the file. It does not currently support dynamically switching between languages after the first language is detected. The automatic detection works best with audio recordings with clearly discernable speech. If automatic detection fails to find the language, transcription would fallback to 'en-US'." The list of supported languages is available here: https://go.microsoft.com/fwlink/?linkid=2109463.
func (o TransformOutputVideoAnalyzerPresetPtrOutput) AudioLanguage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TransformOutputVideoAnalyzerPreset) *string {
		if v == nil {
			return nil
		}
		return v.AudioLanguage
	}).(pulumi.StringPtrOutput)
}

// Defines the type of insights that you want the service to generate. The allowed values are `AudioInsightsOnly`, `VideoInsightsOnly`, and `AllInsights`. If you set this to `AllInsights` and the input is audio only, then only audio insights are generated. Similarly if the input is video only, then only video insights are generated. It is recommended that you not use `AudioInsightsOnly` if you expect some of your inputs to be video only; or use `VideoInsightsOnly` if you expect some of your inputs to be audio only. Your Jobs in such conditions would error out.
func (o TransformOutputVideoAnalyzerPresetPtrOutput) InsightsType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TransformOutputVideoAnalyzerPreset) *string {
		if v == nil {
			return nil
		}
		return v.InsightsType
	}).(pulumi.StringPtrOutput)
}

func init() {
	pulumi.RegisterOutputType(JobInputAssetOutput{})
	pulumi.RegisterOutputType(JobInputAssetPtrOutput{})
	pulumi.RegisterOutputType(JobOutputAssetOutput{})
	pulumi.RegisterOutputType(JobOutputAssetArrayOutput{})
	pulumi.RegisterOutputType(ServiceAccountIdentityOutput{})
	pulumi.RegisterOutputType(ServiceAccountIdentityPtrOutput{})
	pulumi.RegisterOutputType(ServiceAccountStorageAccountOutput{})
	pulumi.RegisterOutputType(ServiceAccountStorageAccountArrayOutput{})
	pulumi.RegisterOutputType(StreamingEndpointAccessControlOutput{})
	pulumi.RegisterOutputType(StreamingEndpointAccessControlPtrOutput{})
	pulumi.RegisterOutputType(StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyOutput{})
	pulumi.RegisterOutputType(StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKeyArrayOutput{})
	pulumi.RegisterOutputType(StreamingEndpointAccessControlIpAllowOutput{})
	pulumi.RegisterOutputType(StreamingEndpointAccessControlIpAllowArrayOutput{})
	pulumi.RegisterOutputType(StreamingEndpointCrossSiteAccessPolicyOutput{})
	pulumi.RegisterOutputType(StreamingEndpointCrossSiteAccessPolicyPtrOutput{})
	pulumi.RegisterOutputType(TransformOutputOutput{})
	pulumi.RegisterOutputType(TransformOutputArrayOutput{})
	pulumi.RegisterOutputType(TransformOutputAudioAnalyzerPresetOutput{})
	pulumi.RegisterOutputType(TransformOutputAudioAnalyzerPresetPtrOutput{})
	pulumi.RegisterOutputType(TransformOutputBuiltinPresetOutput{})
	pulumi.RegisterOutputType(TransformOutputBuiltinPresetPtrOutput{})
	pulumi.RegisterOutputType(TransformOutputFaceDetectorPresetOutput{})
	pulumi.RegisterOutputType(TransformOutputFaceDetectorPresetPtrOutput{})
	pulumi.RegisterOutputType(TransformOutputVideoAnalyzerPresetOutput{})
	pulumi.RegisterOutputType(TransformOutputVideoAnalyzerPresetPtrOutput{})
}
