// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package media

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-azure/sdk/v5/go/azure/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages a Transform.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	core/resourceGroup "github.com/pulumi/pulumi-azure/sdk/v1/go/azure/core/resourceGroup"
//	media/serviceAccount "github.com/pulumi/pulumi-azure/sdk/v1/go/azure/media/serviceAccount"
//	media/transform "github.com/pulumi/pulumi-azure/sdk/v1/go/azure/media/transform"
//	storage/account "github.com/pulumi/pulumi-azure/sdk/v1/go/azure/storage/account"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
// func main() {
// pulumi.Run(func(ctx *pulumi.Context) error {
// example, err := core/resourceGroup.NewResourceGroup(ctx, "example", &core/resourceGroup.ResourceGroupArgs{
// Name: "media-resources",
// Location: "West Europe",
// })
// if err != nil {
// return err
// }
// exampleAccount, err := storage/account.NewAccount(ctx, "example", &storage/account.AccountArgs{
// Name: "examplestoracc",
// ResourceGroupName: example.Name,
// Location: example.Location,
// AccountTier: "Standard",
// AccountReplicationType: "GRS",
// })
// if err != nil {
// return err
// }
// exampleServiceAccount, err := media/serviceAccount.NewServiceAccount(ctx, "example", &media/serviceAccount.ServiceAccountArgs{
// Name: "examplemediaacc",
// Location: example.Location,
// ResourceGroupName: example.Name,
// StorageAccounts: []map[string]interface{}{
// map[string]interface{}{
// "id": exampleAccount.Id,
// "isPrimary": true,
// },
// },
// })
// if err != nil {
// return err
// }
// _, err = media/transform.NewTransform(ctx, "example", &media/transform.TransformArgs{
// Name: "transform1",
// ResourceGroupName: example.Name,
// MediaServicesAccountName: exampleServiceAccount.Name,
// Description: "My transform description",
// Outputs: []map[string]interface{}{
// map[string]interface{}{
// "relativePriority": "Normal",
// "onErrorAction": "ContinueJob",
// "builtinPreset": map[string]interface{}{
// "presetName": "AACGoodQualityAudio",
// },
// },
// },
// })
// if err != nil {
// return err
// }
// return nil
// })
// }
// ```
// ### With Multiple Outputs
//
// ```go
// package main
//
// import (
//
//	core/resourceGroup "github.com/pulumi/pulumi-azure/sdk/v1/go/azure/core/resourceGroup"
//	media/serviceAccount "github.com/pulumi/pulumi-azure/sdk/v1/go/azure/media/serviceAccount"
//	media/transform "github.com/pulumi/pulumi-azure/sdk/v1/go/azure/media/transform"
//	storage/account "github.com/pulumi/pulumi-azure/sdk/v1/go/azure/storage/account"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
// func main() {
// pulumi.Run(func(ctx *pulumi.Context) error {
// example, err := core/resourceGroup.NewResourceGroup(ctx, "example", &core/resourceGroup.ResourceGroupArgs{
// Name: "media-resources",
// Location: "West Europe",
// })
// if err != nil {
// return err
// }
// exampleAccount, err := storage/account.NewAccount(ctx, "example", &storage/account.AccountArgs{
// Name: "examplestoracc",
// ResourceGroupName: example.Name,
// Location: example.Location,
// AccountTier: "Standard",
// AccountReplicationType: "GRS",
// })
// if err != nil {
// return err
// }
// exampleServiceAccount, err := media/serviceAccount.NewServiceAccount(ctx, "example", &media/serviceAccount.ServiceAccountArgs{
// Name: "examplemediaacc",
// Location: example.Location,
// ResourceGroupName: example.Name,
// StorageAccounts: []map[string]interface{}{
// map[string]interface{}{
// "id": exampleAccount.Id,
// "isPrimary": true,
// },
// },
// })
// if err != nil {
// return err
// }
// _, err = media/transform.NewTransform(ctx, "example", &media/transform.TransformArgs{
// Name: "transform1",
// ResourceGroupName: example.Name,
// MediaServicesAccountName: exampleServiceAccount.Name,
// Description: "My transform description",
// Outputs: []interface{}{
// map[string]interface{}{
// "relativePriority": "Normal",
// "onErrorAction": "ContinueJob",
// "builtinPreset": map[string]interface{}{
// "presetName": "AACGoodQualityAudio",
// "presetConfiguration": map[string]interface{}{
// "complexity": "Balanced",
// "interleaveOutput": "NonInterleavedOutput",
// "keyFrameIntervalInSeconds": 123122.5,
// "maxBitrateBps": 300000,
// "maxHeight": 480,
// "maxLayers": 14,
// "minBitrateBps": 200000,
// "minHeight": 360,
// },
// },
// },
// map[string]interface{}{
// "relativePriority": "Low",
// "onErrorAction": "ContinueJob",
// "audioAnalyzerPreset": map[string]interface{}{
// "audioLanguage": "en-US",
// "audioAnalysisMode": "Basic",
// "experimentalOptions": map[string]interface{}{
// "env": "test",
// },
// },
// },
// map[string]interface{}{
// "relativePriority": "Low",
// "onErrorAction": "StopProcessingJob",
// "faceDetectorPreset": map[string]interface{}{
// "analysisResolution": "StandardDefinition",
// "blurType": "Med",
// "faceRedactorMode": "Combined",
// "experimentalOptions": map[string]interface{}{
// "env": "test",
// },
// },
// },
// map[string]interface{}{
// "relativePriority": "Normal",
// "onErrorAction": "StopProcessingJob",
// "videoAnalyzerPreset": map[string]interface{}{
// "audioLanguage": "en-US",
// "audioAnalysisMode": "Basic",
// "insightsType": "AllInsights",
// "experimentalOptions": map[string]interface{}{
// "env": "test",
// },
// },
// },
// map[string]interface{}{
// "relativePriority": "Low",
// "onErrorAction": "ContinueJob",
// "customPreset": map[string]interface{}{
// "codecs": []interface{}{
// map[string]interface{}{
// "aacAudio": map[string]interface{}{
// "bitrate": 128000,
// "channels": 2,
// "samplingRate": 48000,
// "profile": "AacLc",
// },
// },
// map[string]interface{}{
// "copyAudio": map[string]interface{}{
// "label": "test",
// },
// },
// map[string]interface{}{
// "copyVideo": map[string]interface{}{
// "label": "test",
// },
// },
// map[string]interface{}{
// "h264Video": map[string]interface{}{
// "keyFrameInterval": "PT1S",
// "stretchMode": "AutoSize",
// "syncMode": "Auto",
// "sceneChangeDetectionEnabled": false,
// "rateControlMode": "ABR",
// "complexity": "Quality",
// "layers": []interface{}{
// map[string]interface{}{
// "width": "64",
// "height": "64",
// "bitrate": 1045000,
// "maxBitrate": 1045000,
// "bFrames": 3,
// "slices": 0,
// "adaptiveBFrameEnabled": true,
// "profile": "Auto",
// "level": "auto",
// "bufferWindow": "PT5S",
// "referenceFrames": 4,
// "crf": 23,
// "entropyMode": "Cabac",
// },
// map[string]interface{}{
// "width": "64",
// "height": "64",
// "bitrate": 1000,
// "maxBitrate": 1000,
// "bFrames": 3,
// "frameRate": "32",
// "slices": 1,
// "adaptiveBFrameEnabled": true,
// "profile": "High444",
// "level": "auto",
// "bufferWindow": "PT5S",
// "referenceFrames": 4,
// "crf": 23,
// "entropyMode": "Cavlc",
// },
// },
// },
// },
// map[string]interface{}{
// "h265Video": map[string]interface{}{
// "keyFrameInterval": "PT2S",
// "stretchMode": "AutoSize",
// "syncMode": "Auto",
// "sceneChangeDetectionEnabled": false,
// "complexity": "Speed",
// "layers": []map[string]interface{}{
// map[string]interface{}{
// "width": "64",
// "height": "64",
// "bitrate": 1045000,
// "maxBitrate": 1045000,
// "bFrames": 3,
// "slices": 5,
// "adaptiveBFrameEnabled": true,
// "profile": "Auto",
// "label": "test",
// "level": "auto",
// "bufferWindow": "PT5S",
// "frameRate": "32",
// "referenceFrames": 4,
// "crf": 23,
// },
// },
// },
// },
// map[string]interface{}{
// "jpgImage": map[string]interface{}{
// "stretchMode": "AutoSize",
// "syncMode": "Auto",
// "start": "10",
// "range": "100%%",
// "spriteColumn": 1,
// "step": "10",
// "layers": []map[string]interface{}{
// map[string]interface{}{
// "quality": 70,
// "height": "180",
// "label": "test",
// "width": "120",
// },
// },
// },
// },
// map[string]interface{}{
// "pngImage": map[string]interface{}{
// "stretchMode": "AutoSize",
// "syncMode": "Auto",
// "start": "{Best}",
// "range": "80",
// "step": "10",
// "layers": []map[string]interface{}{
// map[string]interface{}{
// "height": "180",
// "label": "test",
// "width": "120",
// },
// },
// },
// },
// },
// "formats": []interface{}{
// map[string]interface{}{
// "jpg": map[string]interface{}{
// "filenamePattern": "test{Basename}",
// },
// },
// map[string]interface{}{
// "mp4": map[string]interface{}{
// "filenamePattern": "test{Bitrate}",
// "outputFiles": []map[string]interface{}{
// map[string]interface{}{
// "labels": []string{
// "test",
// "ppe",
// },
// },
// },
// },
// },
// map[string]interface{}{
// "png": map[string]interface{}{
// "filenamePattern": "test{Basename}",
// },
// },
// map[string]interface{}{
// "transportStream": map[string]interface{}{
// "filenamePattern": "test{Bitrate}",
// "outputFiles": []map[string]interface{}{
// map[string]interface{}{
// "labels": []string{
// "prod",
// },
// },
// },
// },
// },
// },
// "filter": map[string]interface{}{
// "cropRectangle": map[string]interface{}{
// "height": "240",
// "left": "30",
// "top": "360",
// "width": "70",
// },
// "deinterlace": map[string]interface{}{
// "parity": "TopFieldFirst",
// "mode": "AutoPixelAdaptive",
// },
// "fadeIn": map[string]interface{}{
// "duration": "PT5S",
// "fadeColor": "0xFF0000",
// "start": "10",
// },
// "fadeOut": map[string]interface{}{
// "duration": "90%%",
// "fadeColor": "#FF0C7B",
// "start": "10%%",
// },
// "rotation": "Auto",
// "overlays": []interface{}{
// map[string]interface{}{
// "audio": map[string]interface{}{
// "inputLabel": "label.jpg",
// "start": "PT5S",
// "end": "PT30S",
// "fadeInDuration": "PT1S",
// "fadeOutDuration": "PT2S",
// "audioGainLevel": 1,
// },
// },
// map[string]interface{}{
// "video": map[string]interface{}{
// "inputLabel": "label.jpg",
// "start": "PT5S",
// "end": "PT30S",
// "fadeInDuration": "PT1S",
// "fadeOutDuration": "PT2S",
// "audioGainLevel": 1,
// "opacity": 1,
// "position": map[string]interface{}{
// "height": "180",
// "left": "20",
// "top": "240",
// "width": "140",
// },
// "cropRectangle": map[string]interface{}{
// "height": "240",
// "left": "30",
// "top": "360",
// "width": "70",
// },
// },
// },
// },
// },
// },
// },
// },
// })
// if err != nil {
// return err
// }
// return nil
// })
// }
// ```
//
// ## Import
//
// Transforms can be imported using the `resource id`, e.g.
//
// ```sh
// $ pulumi import azure:media/transform:Transform example /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/group1/providers/Microsoft.Media/mediaServices/media1/transforms/transform1
// ```
type Transform struct {
	pulumi.CustomResourceState

	// An optional verbose description of the Transform.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// The Media Services account name. Changing this forces a new Transform to be created.
	MediaServicesAccountName pulumi.StringOutput `pulumi:"mediaServicesAccountName"`
	// The name which should be used for this Transform. Changing this forces a new Transform to be created.
	Name pulumi.StringOutput `pulumi:"name"`
	// One or more `output` blocks as defined below. At least one `output` must be defined.
	Outputs TransformOutputTypeArrayOutput `pulumi:"outputs"`
	// The name of the Resource Group where the Transform should exist. Changing this forces a new Transform to be created.
	ResourceGroupName pulumi.StringOutput `pulumi:"resourceGroupName"`
}

// NewTransform registers a new resource with the given unique name, arguments, and options.
func NewTransform(ctx *pulumi.Context,
	name string, args *TransformArgs, opts ...pulumi.ResourceOption) (*Transform, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.MediaServicesAccountName == nil {
		return nil, errors.New("invalid value for required argument 'MediaServicesAccountName'")
	}
	if args.ResourceGroupName == nil {
		return nil, errors.New("invalid value for required argument 'ResourceGroupName'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Transform
	err := ctx.RegisterResource("azure:media/transform:Transform", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetTransform gets an existing Transform resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetTransform(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *TransformState, opts ...pulumi.ResourceOption) (*Transform, error) {
	var resource Transform
	err := ctx.ReadResource("azure:media/transform:Transform", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Transform resources.
type transformState struct {
	// An optional verbose description of the Transform.
	Description *string `pulumi:"description"`
	// The Media Services account name. Changing this forces a new Transform to be created.
	MediaServicesAccountName *string `pulumi:"mediaServicesAccountName"`
	// The name which should be used for this Transform. Changing this forces a new Transform to be created.
	Name *string `pulumi:"name"`
	// One or more `output` blocks as defined below. At least one `output` must be defined.
	Outputs []TransformOutputType `pulumi:"outputs"`
	// The name of the Resource Group where the Transform should exist. Changing this forces a new Transform to be created.
	ResourceGroupName *string `pulumi:"resourceGroupName"`
}

type TransformState struct {
	// An optional verbose description of the Transform.
	Description pulumi.StringPtrInput
	// The Media Services account name. Changing this forces a new Transform to be created.
	MediaServicesAccountName pulumi.StringPtrInput
	// The name which should be used for this Transform. Changing this forces a new Transform to be created.
	Name pulumi.StringPtrInput
	// One or more `output` blocks as defined below. At least one `output` must be defined.
	Outputs TransformOutputTypeArrayInput
	// The name of the Resource Group where the Transform should exist. Changing this forces a new Transform to be created.
	ResourceGroupName pulumi.StringPtrInput
}

func (TransformState) ElementType() reflect.Type {
	return reflect.TypeOf((*transformState)(nil)).Elem()
}

type transformArgs struct {
	// An optional verbose description of the Transform.
	Description *string `pulumi:"description"`
	// The Media Services account name. Changing this forces a new Transform to be created.
	MediaServicesAccountName string `pulumi:"mediaServicesAccountName"`
	// The name which should be used for this Transform. Changing this forces a new Transform to be created.
	Name *string `pulumi:"name"`
	// One or more `output` blocks as defined below. At least one `output` must be defined.
	Outputs []TransformOutputType `pulumi:"outputs"`
	// The name of the Resource Group where the Transform should exist. Changing this forces a new Transform to be created.
	ResourceGroupName string `pulumi:"resourceGroupName"`
}

// The set of arguments for constructing a Transform resource.
type TransformArgs struct {
	// An optional verbose description of the Transform.
	Description pulumi.StringPtrInput
	// The Media Services account name. Changing this forces a new Transform to be created.
	MediaServicesAccountName pulumi.StringInput
	// The name which should be used for this Transform. Changing this forces a new Transform to be created.
	Name pulumi.StringPtrInput
	// One or more `output` blocks as defined below. At least one `output` must be defined.
	Outputs TransformOutputTypeArrayInput
	// The name of the Resource Group where the Transform should exist. Changing this forces a new Transform to be created.
	ResourceGroupName pulumi.StringInput
}

func (TransformArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*transformArgs)(nil)).Elem()
}

type TransformInput interface {
	pulumi.Input

	ToTransformOutput() TransformOutput
	ToTransformOutputWithContext(ctx context.Context) TransformOutput
}

func (*Transform) ElementType() reflect.Type {
	return reflect.TypeOf((**Transform)(nil)).Elem()
}

func (i *Transform) ToTransformOutput() TransformOutput {
	return i.ToTransformOutputWithContext(context.Background())
}

func (i *Transform) ToTransformOutputWithContext(ctx context.Context) TransformOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TransformOutput)
}

// TransformArrayInput is an input type that accepts TransformArray and TransformArrayOutput values.
// You can construct a concrete instance of `TransformArrayInput` via:
//
//	TransformArray{ TransformArgs{...} }
type TransformArrayInput interface {
	pulumi.Input

	ToTransformArrayOutput() TransformArrayOutput
	ToTransformArrayOutputWithContext(context.Context) TransformArrayOutput
}

type TransformArray []TransformInput

func (TransformArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Transform)(nil)).Elem()
}

func (i TransformArray) ToTransformArrayOutput() TransformArrayOutput {
	return i.ToTransformArrayOutputWithContext(context.Background())
}

func (i TransformArray) ToTransformArrayOutputWithContext(ctx context.Context) TransformArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TransformArrayOutput)
}

// TransformMapInput is an input type that accepts TransformMap and TransformMapOutput values.
// You can construct a concrete instance of `TransformMapInput` via:
//
//	TransformMap{ "key": TransformArgs{...} }
type TransformMapInput interface {
	pulumi.Input

	ToTransformMapOutput() TransformMapOutput
	ToTransformMapOutputWithContext(context.Context) TransformMapOutput
}

type TransformMap map[string]TransformInput

func (TransformMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Transform)(nil)).Elem()
}

func (i TransformMap) ToTransformMapOutput() TransformMapOutput {
	return i.ToTransformMapOutputWithContext(context.Background())
}

func (i TransformMap) ToTransformMapOutputWithContext(ctx context.Context) TransformMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TransformMapOutput)
}

type TransformOutput struct{ *pulumi.OutputState }

func (TransformOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Transform)(nil)).Elem()
}

func (o TransformOutput) ToTransformOutput() TransformOutput {
	return o
}

func (o TransformOutput) ToTransformOutputWithContext(ctx context.Context) TransformOutput {
	return o
}

// An optional verbose description of the Transform.
func (o TransformOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Transform) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// The Media Services account name. Changing this forces a new Transform to be created.
func (o TransformOutput) MediaServicesAccountName() pulumi.StringOutput {
	return o.ApplyT(func(v *Transform) pulumi.StringOutput { return v.MediaServicesAccountName }).(pulumi.StringOutput)
}

// The name which should be used for this Transform. Changing this forces a new Transform to be created.
func (o TransformOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Transform) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// One or more `output` blocks as defined below. At least one `output` must be defined.
func (o TransformOutput) Outputs() TransformOutputTypeArrayOutput {
	return o.ApplyT(func(v *Transform) TransformOutputTypeArrayOutput { return v.Outputs }).(TransformOutputTypeArrayOutput)
}

// The name of the Resource Group where the Transform should exist. Changing this forces a new Transform to be created.
func (o TransformOutput) ResourceGroupName() pulumi.StringOutput {
	return o.ApplyT(func(v *Transform) pulumi.StringOutput { return v.ResourceGroupName }).(pulumi.StringOutput)
}

type TransformArrayOutput struct{ *pulumi.OutputState }

func (TransformArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Transform)(nil)).Elem()
}

func (o TransformArrayOutput) ToTransformArrayOutput() TransformArrayOutput {
	return o
}

func (o TransformArrayOutput) ToTransformArrayOutputWithContext(ctx context.Context) TransformArrayOutput {
	return o
}

func (o TransformArrayOutput) Index(i pulumi.IntInput) TransformOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Transform {
		return vs[0].([]*Transform)[vs[1].(int)]
	}).(TransformOutput)
}

type TransformMapOutput struct{ *pulumi.OutputState }

func (TransformMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Transform)(nil)).Elem()
}

func (o TransformMapOutput) ToTransformMapOutput() TransformMapOutput {
	return o
}

func (o TransformMapOutput) ToTransformMapOutputWithContext(ctx context.Context) TransformMapOutput {
	return o
}

func (o TransformMapOutput) MapIndex(k pulumi.StringInput) TransformOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Transform {
		return vs[0].(map[string]*Transform)[vs[1].(string)]
	}).(TransformOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*TransformInput)(nil)).Elem(), &Transform{})
	pulumi.RegisterInputType(reflect.TypeOf((*TransformArrayInput)(nil)).Elem(), TransformArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TransformMapInput)(nil)).Elem(), TransformMap{})
	pulumi.RegisterOutputType(TransformOutput{})
	pulumi.RegisterOutputType(TransformArrayOutput{})
	pulumi.RegisterOutputType(TransformMapOutput{})
}
