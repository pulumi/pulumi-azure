// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package media

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-azure/sdk/v5/go/azure/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
)

// Manages a Live Event.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-azure/sdk/v5/go/azure/core"
//	"github.com/pulumi/pulumi-azure/sdk/v5/go/azure/media"
//	"github.com/pulumi/pulumi-azure/sdk/v5/go/azure/storage"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			exampleResourceGroup, err := core.NewResourceGroup(ctx, "exampleResourceGroup", &core.ResourceGroupArgs{
//				Location: pulumi.String("West Europe"),
//			})
//			if err != nil {
//				return err
//			}
//			exampleAccount, err := storage.NewAccount(ctx, "exampleAccount", &storage.AccountArgs{
//				ResourceGroupName:      exampleResourceGroup.Name,
//				Location:               exampleResourceGroup.Location,
//				AccountTier:            pulumi.String("Standard"),
//				AccountReplicationType: pulumi.String("GRS"),
//			})
//			if err != nil {
//				return err
//			}
//			exampleServiceAccount, err := media.NewServiceAccount(ctx, "exampleServiceAccount", &media.ServiceAccountArgs{
//				Location:          exampleResourceGroup.Location,
//				ResourceGroupName: exampleResourceGroup.Name,
//				StorageAccounts: media.ServiceAccountStorageAccountArray{
//					&media.ServiceAccountStorageAccountArgs{
//						Id:        exampleAccount.ID(),
//						IsPrimary: pulumi.Bool(true),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = media.NewLiveEvent(ctx, "exampleLiveEvent", &media.LiveEventArgs{
//				ResourceGroupName:        exampleResourceGroup.Name,
//				Location:                 exampleResourceGroup.Location,
//				MediaServicesAccountName: exampleServiceAccount.Name,
//				Description:              pulumi.String("My Event Description"),
//				Input: &media.LiveEventInputTypeArgs{
//					StreamingProtocol: pulumi.String("RTMP"),
//					IpAccessControlAllows: media.LiveEventInputIpAccessControlAllowArray{
//						&media.LiveEventInputIpAccessControlAllowArgs{
//							Name:               pulumi.String("AllowAll"),
//							Address:            pulumi.String("0.0.0.0"),
//							SubnetPrefixLength: pulumi.Int(0),
//						},
//					},
//				},
//				Encoding: &media.LiveEventEncodingArgs{
//					Type:             pulumi.String("Standard"),
//					PresetName:       pulumi.String("Default720p"),
//					StretchMode:      pulumi.String("AutoFit"),
//					KeyFrameInterval: pulumi.String("PT2S"),
//				},
//				Preview: &media.LiveEventPreviewArgs{
//					IpAccessControlAllows: media.LiveEventPreviewIpAccessControlAllowArray{
//						&media.LiveEventPreviewIpAccessControlAllowArgs{
//							Name:               pulumi.String("AllowAll"),
//							Address:            pulumi.String("0.0.0.0"),
//							SubnetPrefixLength: pulumi.Int(0),
//						},
//					},
//				},
//				StreamOptions: pulumi.StringArray{
//					pulumi.String("LowLatency"),
//				},
//				UseStaticHostname: pulumi.Bool(true),
//				HostnamePrefix:    pulumi.String("special-event"),
//				TranscriptionLanguages: pulumi.StringArray{
//					pulumi.String("en-US"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Live Events can be imported using the `resource id`, e.g.
//
// ```sh
//
//	$ pulumi import azure:media/liveEvent:LiveEvent example /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/resGroup1/providers/Microsoft.Media/mediaServices/account1/liveEvents/event1
//
// ```
type LiveEvent struct {
	pulumi.CustomResourceState

	// The flag indicates if the resource should be automatically started on creation. Changing this forces a new resource to be created.
	AutoStartEnabled pulumi.BoolPtrOutput `pulumi:"autoStartEnabled"`
	// A `crossSiteAccessPolicy` block as defined below.
	CrossSiteAccessPolicy LiveEventCrossSiteAccessPolicyPtrOutput `pulumi:"crossSiteAccessPolicy"`
	// A description for the live event.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// A `encoding` block as defined below.
	Encoding LiveEventEncodingPtrOutput `pulumi:"encoding"`
	// When `useStaticHostname` is set to true, the `hostnamePrefix` specifies the first part of the hostname assigned to the live event preview and ingest endpoints. The final hostname would be a combination of this prefix, the media service account name and a short code for the Azure Media Services data center.
	HostnamePrefix pulumi.StringPtrOutput `pulumi:"hostnamePrefix"`
	// A `input` block as defined below.
	Input LiveEventInputTypeOutput `pulumi:"input"`
	// The Azure Region where the Live Event should exist. Changing this forces a new Live Event to be created.
	Location pulumi.StringOutput `pulumi:"location"`
	// The Media Services account name. Changing this forces a new Live Event to be created.
	MediaServicesAccountName pulumi.StringOutput `pulumi:"mediaServicesAccountName"`
	// The name which should be used for this Live Event. Changing this forces a new Live Event to be created.
	Name pulumi.StringOutput `pulumi:"name"`
	// A `preview` block as defined below.
	Preview LiveEventPreviewOutput `pulumi:"preview"`
	// The name of the Resource Group where the Live Event should exist. Changing this forces a new Live Event to be created.
	ResourceGroupName pulumi.StringOutput `pulumi:"resourceGroupName"`
	// A list of options to use for the LiveEvent. Possible values are `Default`, `LowLatency`, `LowLatencyV2`. Please see more at this [document](https://learn.microsoft.com/en-us/azure/media-services/latest/live-event-latency-reference#lowlatency-and-lowlatencyv2-options). Changing this forces a new resource to be created.
	StreamOptions pulumi.StringArrayOutput `pulumi:"streamOptions"`
	// A mapping of tags which should be assigned to the Live Event.
	Tags pulumi.StringMapOutput `pulumi:"tags"`
	// Specifies a list of languages (locale) to be used for speech-to-text transcription – it should match the spoken language in the audio track. The value should be in `BCP-47` format (e.g: `en-US`). [See the Microsoft Documentation for more information about the live transcription feature and the list of supported languages](https://go.microsoft.com/fwlink/?linkid=2133742).
	TranscriptionLanguages pulumi.StringArrayOutput `pulumi:"transcriptionLanguages"`
	// Specifies whether a static hostname would be assigned to the live event preview and ingest endpoints. Changing this forces a new Live Event to be created.
	UseStaticHostname pulumi.BoolPtrOutput `pulumi:"useStaticHostname"`
}

// NewLiveEvent registers a new resource with the given unique name, arguments, and options.
func NewLiveEvent(ctx *pulumi.Context,
	name string, args *LiveEventArgs, opts ...pulumi.ResourceOption) (*LiveEvent, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Input == nil {
		return nil, errors.New("invalid value for required argument 'Input'")
	}
	if args.MediaServicesAccountName == nil {
		return nil, errors.New("invalid value for required argument 'MediaServicesAccountName'")
	}
	if args.ResourceGroupName == nil {
		return nil, errors.New("invalid value for required argument 'ResourceGroupName'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource LiveEvent
	err := ctx.RegisterResource("azure:media/liveEvent:LiveEvent", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetLiveEvent gets an existing LiveEvent resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetLiveEvent(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *LiveEventState, opts ...pulumi.ResourceOption) (*LiveEvent, error) {
	var resource LiveEvent
	err := ctx.ReadResource("azure:media/liveEvent:LiveEvent", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering LiveEvent resources.
type liveEventState struct {
	// The flag indicates if the resource should be automatically started on creation. Changing this forces a new resource to be created.
	AutoStartEnabled *bool `pulumi:"autoStartEnabled"`
	// A `crossSiteAccessPolicy` block as defined below.
	CrossSiteAccessPolicy *LiveEventCrossSiteAccessPolicy `pulumi:"crossSiteAccessPolicy"`
	// A description for the live event.
	Description *string `pulumi:"description"`
	// A `encoding` block as defined below.
	Encoding *LiveEventEncoding `pulumi:"encoding"`
	// When `useStaticHostname` is set to true, the `hostnamePrefix` specifies the first part of the hostname assigned to the live event preview and ingest endpoints. The final hostname would be a combination of this prefix, the media service account name and a short code for the Azure Media Services data center.
	HostnamePrefix *string `pulumi:"hostnamePrefix"`
	// A `input` block as defined below.
	Input *LiveEventInputType `pulumi:"input"`
	// The Azure Region where the Live Event should exist. Changing this forces a new Live Event to be created.
	Location *string `pulumi:"location"`
	// The Media Services account name. Changing this forces a new Live Event to be created.
	MediaServicesAccountName *string `pulumi:"mediaServicesAccountName"`
	// The name which should be used for this Live Event. Changing this forces a new Live Event to be created.
	Name *string `pulumi:"name"`
	// A `preview` block as defined below.
	Preview *LiveEventPreview `pulumi:"preview"`
	// The name of the Resource Group where the Live Event should exist. Changing this forces a new Live Event to be created.
	ResourceGroupName *string `pulumi:"resourceGroupName"`
	// A list of options to use for the LiveEvent. Possible values are `Default`, `LowLatency`, `LowLatencyV2`. Please see more at this [document](https://learn.microsoft.com/en-us/azure/media-services/latest/live-event-latency-reference#lowlatency-and-lowlatencyv2-options). Changing this forces a new resource to be created.
	StreamOptions []string `pulumi:"streamOptions"`
	// A mapping of tags which should be assigned to the Live Event.
	Tags map[string]string `pulumi:"tags"`
	// Specifies a list of languages (locale) to be used for speech-to-text transcription – it should match the spoken language in the audio track. The value should be in `BCP-47` format (e.g: `en-US`). [See the Microsoft Documentation for more information about the live transcription feature and the list of supported languages](https://go.microsoft.com/fwlink/?linkid=2133742).
	TranscriptionLanguages []string `pulumi:"transcriptionLanguages"`
	// Specifies whether a static hostname would be assigned to the live event preview and ingest endpoints. Changing this forces a new Live Event to be created.
	UseStaticHostname *bool `pulumi:"useStaticHostname"`
}

type LiveEventState struct {
	// The flag indicates if the resource should be automatically started on creation. Changing this forces a new resource to be created.
	AutoStartEnabled pulumi.BoolPtrInput
	// A `crossSiteAccessPolicy` block as defined below.
	CrossSiteAccessPolicy LiveEventCrossSiteAccessPolicyPtrInput
	// A description for the live event.
	Description pulumi.StringPtrInput
	// A `encoding` block as defined below.
	Encoding LiveEventEncodingPtrInput
	// When `useStaticHostname` is set to true, the `hostnamePrefix` specifies the first part of the hostname assigned to the live event preview and ingest endpoints. The final hostname would be a combination of this prefix, the media service account name and a short code for the Azure Media Services data center.
	HostnamePrefix pulumi.StringPtrInput
	// A `input` block as defined below.
	Input LiveEventInputTypePtrInput
	// The Azure Region where the Live Event should exist. Changing this forces a new Live Event to be created.
	Location pulumi.StringPtrInput
	// The Media Services account name. Changing this forces a new Live Event to be created.
	MediaServicesAccountName pulumi.StringPtrInput
	// The name which should be used for this Live Event. Changing this forces a new Live Event to be created.
	Name pulumi.StringPtrInput
	// A `preview` block as defined below.
	Preview LiveEventPreviewPtrInput
	// The name of the Resource Group where the Live Event should exist. Changing this forces a new Live Event to be created.
	ResourceGroupName pulumi.StringPtrInput
	// A list of options to use for the LiveEvent. Possible values are `Default`, `LowLatency`, `LowLatencyV2`. Please see more at this [document](https://learn.microsoft.com/en-us/azure/media-services/latest/live-event-latency-reference#lowlatency-and-lowlatencyv2-options). Changing this forces a new resource to be created.
	StreamOptions pulumi.StringArrayInput
	// A mapping of tags which should be assigned to the Live Event.
	Tags pulumi.StringMapInput
	// Specifies a list of languages (locale) to be used for speech-to-text transcription – it should match the spoken language in the audio track. The value should be in `BCP-47` format (e.g: `en-US`). [See the Microsoft Documentation for more information about the live transcription feature and the list of supported languages](https://go.microsoft.com/fwlink/?linkid=2133742).
	TranscriptionLanguages pulumi.StringArrayInput
	// Specifies whether a static hostname would be assigned to the live event preview and ingest endpoints. Changing this forces a new Live Event to be created.
	UseStaticHostname pulumi.BoolPtrInput
}

func (LiveEventState) ElementType() reflect.Type {
	return reflect.TypeOf((*liveEventState)(nil)).Elem()
}

type liveEventArgs struct {
	// The flag indicates if the resource should be automatically started on creation. Changing this forces a new resource to be created.
	AutoStartEnabled *bool `pulumi:"autoStartEnabled"`
	// A `crossSiteAccessPolicy` block as defined below.
	CrossSiteAccessPolicy *LiveEventCrossSiteAccessPolicy `pulumi:"crossSiteAccessPolicy"`
	// A description for the live event.
	Description *string `pulumi:"description"`
	// A `encoding` block as defined below.
	Encoding *LiveEventEncoding `pulumi:"encoding"`
	// When `useStaticHostname` is set to true, the `hostnamePrefix` specifies the first part of the hostname assigned to the live event preview and ingest endpoints. The final hostname would be a combination of this prefix, the media service account name and a short code for the Azure Media Services data center.
	HostnamePrefix *string `pulumi:"hostnamePrefix"`
	// A `input` block as defined below.
	Input LiveEventInputType `pulumi:"input"`
	// The Azure Region where the Live Event should exist. Changing this forces a new Live Event to be created.
	Location *string `pulumi:"location"`
	// The Media Services account name. Changing this forces a new Live Event to be created.
	MediaServicesAccountName string `pulumi:"mediaServicesAccountName"`
	// The name which should be used for this Live Event. Changing this forces a new Live Event to be created.
	Name *string `pulumi:"name"`
	// A `preview` block as defined below.
	Preview *LiveEventPreview `pulumi:"preview"`
	// The name of the Resource Group where the Live Event should exist. Changing this forces a new Live Event to be created.
	ResourceGroupName string `pulumi:"resourceGroupName"`
	// A list of options to use for the LiveEvent. Possible values are `Default`, `LowLatency`, `LowLatencyV2`. Please see more at this [document](https://learn.microsoft.com/en-us/azure/media-services/latest/live-event-latency-reference#lowlatency-and-lowlatencyv2-options). Changing this forces a new resource to be created.
	StreamOptions []string `pulumi:"streamOptions"`
	// A mapping of tags which should be assigned to the Live Event.
	Tags map[string]string `pulumi:"tags"`
	// Specifies a list of languages (locale) to be used for speech-to-text transcription – it should match the spoken language in the audio track. The value should be in `BCP-47` format (e.g: `en-US`). [See the Microsoft Documentation for more information about the live transcription feature and the list of supported languages](https://go.microsoft.com/fwlink/?linkid=2133742).
	TranscriptionLanguages []string `pulumi:"transcriptionLanguages"`
	// Specifies whether a static hostname would be assigned to the live event preview and ingest endpoints. Changing this forces a new Live Event to be created.
	UseStaticHostname *bool `pulumi:"useStaticHostname"`
}

// The set of arguments for constructing a LiveEvent resource.
type LiveEventArgs struct {
	// The flag indicates if the resource should be automatically started on creation. Changing this forces a new resource to be created.
	AutoStartEnabled pulumi.BoolPtrInput
	// A `crossSiteAccessPolicy` block as defined below.
	CrossSiteAccessPolicy LiveEventCrossSiteAccessPolicyPtrInput
	// A description for the live event.
	Description pulumi.StringPtrInput
	// A `encoding` block as defined below.
	Encoding LiveEventEncodingPtrInput
	// When `useStaticHostname` is set to true, the `hostnamePrefix` specifies the first part of the hostname assigned to the live event preview and ingest endpoints. The final hostname would be a combination of this prefix, the media service account name and a short code for the Azure Media Services data center.
	HostnamePrefix pulumi.StringPtrInput
	// A `input` block as defined below.
	Input LiveEventInputTypeInput
	// The Azure Region where the Live Event should exist. Changing this forces a new Live Event to be created.
	Location pulumi.StringPtrInput
	// The Media Services account name. Changing this forces a new Live Event to be created.
	MediaServicesAccountName pulumi.StringInput
	// The name which should be used for this Live Event. Changing this forces a new Live Event to be created.
	Name pulumi.StringPtrInput
	// A `preview` block as defined below.
	Preview LiveEventPreviewPtrInput
	// The name of the Resource Group where the Live Event should exist. Changing this forces a new Live Event to be created.
	ResourceGroupName pulumi.StringInput
	// A list of options to use for the LiveEvent. Possible values are `Default`, `LowLatency`, `LowLatencyV2`. Please see more at this [document](https://learn.microsoft.com/en-us/azure/media-services/latest/live-event-latency-reference#lowlatency-and-lowlatencyv2-options). Changing this forces a new resource to be created.
	StreamOptions pulumi.StringArrayInput
	// A mapping of tags which should be assigned to the Live Event.
	Tags pulumi.StringMapInput
	// Specifies a list of languages (locale) to be used for speech-to-text transcription – it should match the spoken language in the audio track. The value should be in `BCP-47` format (e.g: `en-US`). [See the Microsoft Documentation for more information about the live transcription feature and the list of supported languages](https://go.microsoft.com/fwlink/?linkid=2133742).
	TranscriptionLanguages pulumi.StringArrayInput
	// Specifies whether a static hostname would be assigned to the live event preview and ingest endpoints. Changing this forces a new Live Event to be created.
	UseStaticHostname pulumi.BoolPtrInput
}

func (LiveEventArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*liveEventArgs)(nil)).Elem()
}

type LiveEventInput interface {
	pulumi.Input

	ToLiveEventOutput() LiveEventOutput
	ToLiveEventOutputWithContext(ctx context.Context) LiveEventOutput
}

func (*LiveEvent) ElementType() reflect.Type {
	return reflect.TypeOf((**LiveEvent)(nil)).Elem()
}

func (i *LiveEvent) ToLiveEventOutput() LiveEventOutput {
	return i.ToLiveEventOutputWithContext(context.Background())
}

func (i *LiveEvent) ToLiveEventOutputWithContext(ctx context.Context) LiveEventOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventOutput)
}

func (i *LiveEvent) ToOutput(ctx context.Context) pulumix.Output[*LiveEvent] {
	return pulumix.Output[*LiveEvent]{
		OutputState: i.ToLiveEventOutputWithContext(ctx).OutputState,
	}
}

// LiveEventArrayInput is an input type that accepts LiveEventArray and LiveEventArrayOutput values.
// You can construct a concrete instance of `LiveEventArrayInput` via:
//
//	LiveEventArray{ LiveEventArgs{...} }
type LiveEventArrayInput interface {
	pulumi.Input

	ToLiveEventArrayOutput() LiveEventArrayOutput
	ToLiveEventArrayOutputWithContext(context.Context) LiveEventArrayOutput
}

type LiveEventArray []LiveEventInput

func (LiveEventArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*LiveEvent)(nil)).Elem()
}

func (i LiveEventArray) ToLiveEventArrayOutput() LiveEventArrayOutput {
	return i.ToLiveEventArrayOutputWithContext(context.Background())
}

func (i LiveEventArray) ToLiveEventArrayOutputWithContext(ctx context.Context) LiveEventArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventArrayOutput)
}

func (i LiveEventArray) ToOutput(ctx context.Context) pulumix.Output[[]*LiveEvent] {
	return pulumix.Output[[]*LiveEvent]{
		OutputState: i.ToLiveEventArrayOutputWithContext(ctx).OutputState,
	}
}

// LiveEventMapInput is an input type that accepts LiveEventMap and LiveEventMapOutput values.
// You can construct a concrete instance of `LiveEventMapInput` via:
//
//	LiveEventMap{ "key": LiveEventArgs{...} }
type LiveEventMapInput interface {
	pulumi.Input

	ToLiveEventMapOutput() LiveEventMapOutput
	ToLiveEventMapOutputWithContext(context.Context) LiveEventMapOutput
}

type LiveEventMap map[string]LiveEventInput

func (LiveEventMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*LiveEvent)(nil)).Elem()
}

func (i LiveEventMap) ToLiveEventMapOutput() LiveEventMapOutput {
	return i.ToLiveEventMapOutputWithContext(context.Background())
}

func (i LiveEventMap) ToLiveEventMapOutputWithContext(ctx context.Context) LiveEventMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventMapOutput)
}

func (i LiveEventMap) ToOutput(ctx context.Context) pulumix.Output[map[string]*LiveEvent] {
	return pulumix.Output[map[string]*LiveEvent]{
		OutputState: i.ToLiveEventMapOutputWithContext(ctx).OutputState,
	}
}

type LiveEventOutput struct{ *pulumi.OutputState }

func (LiveEventOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LiveEvent)(nil)).Elem()
}

func (o LiveEventOutput) ToLiveEventOutput() LiveEventOutput {
	return o
}

func (o LiveEventOutput) ToLiveEventOutputWithContext(ctx context.Context) LiveEventOutput {
	return o
}

func (o LiveEventOutput) ToOutput(ctx context.Context) pulumix.Output[*LiveEvent] {
	return pulumix.Output[*LiveEvent]{
		OutputState: o.OutputState,
	}
}

// The flag indicates if the resource should be automatically started on creation. Changing this forces a new resource to be created.
func (o LiveEventOutput) AutoStartEnabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *LiveEvent) pulumi.BoolPtrOutput { return v.AutoStartEnabled }).(pulumi.BoolPtrOutput)
}

// A `crossSiteAccessPolicy` block as defined below.
func (o LiveEventOutput) CrossSiteAccessPolicy() LiveEventCrossSiteAccessPolicyPtrOutput {
	return o.ApplyT(func(v *LiveEvent) LiveEventCrossSiteAccessPolicyPtrOutput { return v.CrossSiteAccessPolicy }).(LiveEventCrossSiteAccessPolicyPtrOutput)
}

// A description for the live event.
func (o LiveEventOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEvent) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// A `encoding` block as defined below.
func (o LiveEventOutput) Encoding() LiveEventEncodingPtrOutput {
	return o.ApplyT(func(v *LiveEvent) LiveEventEncodingPtrOutput { return v.Encoding }).(LiveEventEncodingPtrOutput)
}

// When `useStaticHostname` is set to true, the `hostnamePrefix` specifies the first part of the hostname assigned to the live event preview and ingest endpoints. The final hostname would be a combination of this prefix, the media service account name and a short code for the Azure Media Services data center.
func (o LiveEventOutput) HostnamePrefix() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEvent) pulumi.StringPtrOutput { return v.HostnamePrefix }).(pulumi.StringPtrOutput)
}

// A `input` block as defined below.
func (o LiveEventOutput) Input() LiveEventInputTypeOutput {
	return o.ApplyT(func(v *LiveEvent) LiveEventInputTypeOutput { return v.Input }).(LiveEventInputTypeOutput)
}

// The Azure Region where the Live Event should exist. Changing this forces a new Live Event to be created.
func (o LiveEventOutput) Location() pulumi.StringOutput {
	return o.ApplyT(func(v *LiveEvent) pulumi.StringOutput { return v.Location }).(pulumi.StringOutput)
}

// The Media Services account name. Changing this forces a new Live Event to be created.
func (o LiveEventOutput) MediaServicesAccountName() pulumi.StringOutput {
	return o.ApplyT(func(v *LiveEvent) pulumi.StringOutput { return v.MediaServicesAccountName }).(pulumi.StringOutput)
}

// The name which should be used for this Live Event. Changing this forces a new Live Event to be created.
func (o LiveEventOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *LiveEvent) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// A `preview` block as defined below.
func (o LiveEventOutput) Preview() LiveEventPreviewOutput {
	return o.ApplyT(func(v *LiveEvent) LiveEventPreviewOutput { return v.Preview }).(LiveEventPreviewOutput)
}

// The name of the Resource Group where the Live Event should exist. Changing this forces a new Live Event to be created.
func (o LiveEventOutput) ResourceGroupName() pulumi.StringOutput {
	return o.ApplyT(func(v *LiveEvent) pulumi.StringOutput { return v.ResourceGroupName }).(pulumi.StringOutput)
}

// A list of options to use for the LiveEvent. Possible values are `Default`, `LowLatency`, `LowLatencyV2`. Please see more at this [document](https://learn.microsoft.com/en-us/azure/media-services/latest/live-event-latency-reference#lowlatency-and-lowlatencyv2-options). Changing this forces a new resource to be created.
func (o LiveEventOutput) StreamOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *LiveEvent) pulumi.StringArrayOutput { return v.StreamOptions }).(pulumi.StringArrayOutput)
}

// A mapping of tags which should be assigned to the Live Event.
func (o LiveEventOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v *LiveEvent) pulumi.StringMapOutput { return v.Tags }).(pulumi.StringMapOutput)
}

// Specifies a list of languages (locale) to be used for speech-to-text transcription – it should match the spoken language in the audio track. The value should be in `BCP-47` format (e.g: `en-US`). [See the Microsoft Documentation for more information about the live transcription feature and the list of supported languages](https://go.microsoft.com/fwlink/?linkid=2133742).
func (o LiveEventOutput) TranscriptionLanguages() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *LiveEvent) pulumi.StringArrayOutput { return v.TranscriptionLanguages }).(pulumi.StringArrayOutput)
}

// Specifies whether a static hostname would be assigned to the live event preview and ingest endpoints. Changing this forces a new Live Event to be created.
func (o LiveEventOutput) UseStaticHostname() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *LiveEvent) pulumi.BoolPtrOutput { return v.UseStaticHostname }).(pulumi.BoolPtrOutput)
}

type LiveEventArrayOutput struct{ *pulumi.OutputState }

func (LiveEventArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*LiveEvent)(nil)).Elem()
}

func (o LiveEventArrayOutput) ToLiveEventArrayOutput() LiveEventArrayOutput {
	return o
}

func (o LiveEventArrayOutput) ToLiveEventArrayOutputWithContext(ctx context.Context) LiveEventArrayOutput {
	return o
}

func (o LiveEventArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]*LiveEvent] {
	return pulumix.Output[[]*LiveEvent]{
		OutputState: o.OutputState,
	}
}

func (o LiveEventArrayOutput) Index(i pulumi.IntInput) LiveEventOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *LiveEvent {
		return vs[0].([]*LiveEvent)[vs[1].(int)]
	}).(LiveEventOutput)
}

type LiveEventMapOutput struct{ *pulumi.OutputState }

func (LiveEventMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*LiveEvent)(nil)).Elem()
}

func (o LiveEventMapOutput) ToLiveEventMapOutput() LiveEventMapOutput {
	return o
}

func (o LiveEventMapOutput) ToLiveEventMapOutputWithContext(ctx context.Context) LiveEventMapOutput {
	return o
}

func (o LiveEventMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]*LiveEvent] {
	return pulumix.Output[map[string]*LiveEvent]{
		OutputState: o.OutputState,
	}
}

func (o LiveEventMapOutput) MapIndex(k pulumi.StringInput) LiveEventOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *LiveEvent {
		return vs[0].(map[string]*LiveEvent)[vs[1].(string)]
	}).(LiveEventOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*LiveEventInput)(nil)).Elem(), &LiveEvent{})
	pulumi.RegisterInputType(reflect.TypeOf((*LiveEventArrayInput)(nil)).Elem(), LiveEventArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LiveEventMapInput)(nil)).Elem(), LiveEventMap{})
	pulumi.RegisterOutputType(LiveEventOutput{})
	pulumi.RegisterOutputType(LiveEventArrayOutput{})
	pulumi.RegisterOutputType(LiveEventMapOutput{})
}
