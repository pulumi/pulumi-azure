// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package media

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages a Live Event.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-azure/sdk/v4/go/azure/core"
// 	"github.com/pulumi/pulumi-azure/sdk/v4/go/azure/media"
// 	"github.com/pulumi/pulumi-azure/sdk/v4/go/azure/storage"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		exampleResourceGroup, err := core.NewResourceGroup(ctx, "exampleResourceGroup", &core.ResourceGroupArgs{
// 			Location: pulumi.String("West Europe"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		exampleAccount, err := storage.NewAccount(ctx, "exampleAccount", &storage.AccountArgs{
// 			ResourceGroupName:      exampleResourceGroup.Name,
// 			Location:               exampleResourceGroup.Location,
// 			AccountTier:            pulumi.String("Standard"),
// 			AccountReplicationType: pulumi.String("GRS"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		exampleServiceAccount, err := media.NewServiceAccount(ctx, "exampleServiceAccount", &media.ServiceAccountArgs{
// 			Location:          exampleResourceGroup.Location,
// 			ResourceGroupName: exampleResourceGroup.Name,
// 			StorageAccounts: media.ServiceAccountStorageAccountArray{
// 				&media.ServiceAccountStorageAccountArgs{
// 					Id:        exampleAccount.ID(),
// 					IsPrimary: pulumi.Bool(true),
// 				},
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = media.NewLiveEvent(ctx, "exampleLiveEvent", &media.LiveEventArgs{
// 			ResourceGroupName:        exampleResourceGroup.Name,
// 			Location:                 exampleResourceGroup.Location,
// 			MediaServicesAccountName: exampleServiceAccount.Name,
// 			Description:              pulumi.String("My Event Description"),
// 			Input: &media.LiveEventInputArgs{
// 				StreamingProtocol: pulumi.String("RTMP"),
// 				IpAccessControlAllows: media.LiveEventInputIpAccessControlAllowArray{
// 					&media.LiveEventInputIpAccessControlAllowArgs{
// 						Name:               pulumi.String("AllowAll"),
// 						Address:            pulumi.String("0.0.0.0"),
// 						SubnetPrefixLength: pulumi.Int(0),
// 					},
// 				},
// 			},
// 			Encoding: &media.LiveEventEncodingArgs{
// 				Type:             pulumi.String("Standard"),
// 				PresetName:       pulumi.String("Default720p"),
// 				StretchMode:      pulumi.String("AutoFit"),
// 				KeyFrameInterval: pulumi.String("PT2S"),
// 			},
// 			Preview: &media.LiveEventPreviewArgs{
// 				IpAccessControlAllows: media.LiveEventPreviewIpAccessControlAllowArray{
// 					&media.LiveEventPreviewIpAccessControlAllowArgs{
// 						Name:               pulumi.String("AllowAll"),
// 						Address:            pulumi.String("0.0.0.0"),
// 						SubnetPrefixLength: pulumi.Int(0),
// 					},
// 				},
// 			},
// 			UseStaticHostname: pulumi.Bool(true),
// 			HostnamePrefix:    pulumi.String("special-event"),
// 			TranscriptionLanguages: pulumi.StringArray{
// 				pulumi.String("en-US"),
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
//
// ## Import
//
// Live Events can be imported using the `resource id`, e.g.
//
// ```sh
//  $ pulumi import azure:media/liveEvent:LiveEvent example /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/resGroup1/providers/Microsoft.Media/mediaservices/account1/liveevents/event1
// ```
type LiveEvent struct {
	pulumi.CustomResourceState

	// The flag indicates if the resource should be automatically started on creation. Default is `false`.
	AutoStartEnabled pulumi.BoolPtrOutput `pulumi:"autoStartEnabled"`
	// A `crossSiteAccessPolicy` block as defined below.
	CrossSiteAccessPolicy LiveEventCrossSiteAccessPolicyPtrOutput `pulumi:"crossSiteAccessPolicy"`
	// A description for the live event.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// A `encoding` block as defined below.
	Encoding LiveEventEncodingPtrOutput `pulumi:"encoding"`
	// When `useStaticHostname` is set to true, the `hostnamePrefix` specifies the first part of the hostname assigned to the live event preview and ingest endpoints. The final hostname would be a combination of this prefix, the media service account name and a short code for the Azure Media Services data center.
	HostnamePrefix pulumi.StringPtrOutput `pulumi:"hostnamePrefix"`
	// A `input` block as defined below.
	Input LiveEventInputTypeOutput `pulumi:"input"`
	// The Azure Region where the Live Event should exist. Changing this forces a new Live Event to be created.
	Location pulumi.StringOutput `pulumi:"location"`
	// The Media Services account name. Changing this forces a new Live Event to be created.
	MediaServicesAccountName pulumi.StringOutput `pulumi:"mediaServicesAccountName"`
	// The name which should be used for this Live Event. Changing this forces a new Live Event to be created.
	Name pulumi.StringOutput `pulumi:"name"`
	// A `preview` block as defined below.
	Preview LiveEventPreviewOutput `pulumi:"preview"`
	// The name of the Resource Group where the Live Event should exist. Changing this forces a new Live Event to be created.
	ResourceGroupName pulumi.StringOutput `pulumi:"resourceGroupName"`
	// A mapping of tags which should be assigned to the Live Event.
	Tags pulumi.StringMapOutput `pulumi:"tags"`
	// Specifies a list of languages (locale) to be used for speech-to-text transcription – it should match the spoken language in the audio track. The value should be in `BCP-47` format (e.g: `en-US`). [See the Microsoft Documentation for more information about the live transcription feature and the list of supported languages](https://go.microsoft.com/fwlink/?linkid=2133742).
	TranscriptionLanguages pulumi.StringArrayOutput `pulumi:"transcriptionLanguages"`
	// Specifies whether a static hostname would be assigned to the live event preview and ingest endpoints. Changing this forces a new Live Event to be created.
	// ---
	UseStaticHostname pulumi.BoolPtrOutput `pulumi:"useStaticHostname"`
}

// NewLiveEvent registers a new resource with the given unique name, arguments, and options.
func NewLiveEvent(ctx *pulumi.Context,
	name string, args *LiveEventArgs, opts ...pulumi.ResourceOption) (*LiveEvent, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Input == nil {
		return nil, errors.New("invalid value for required argument 'Input'")
	}
	if args.MediaServicesAccountName == nil {
		return nil, errors.New("invalid value for required argument 'MediaServicesAccountName'")
	}
	if args.ResourceGroupName == nil {
		return nil, errors.New("invalid value for required argument 'ResourceGroupName'")
	}
	var resource LiveEvent
	err := ctx.RegisterResource("azure:media/liveEvent:LiveEvent", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetLiveEvent gets an existing LiveEvent resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetLiveEvent(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *LiveEventState, opts ...pulumi.ResourceOption) (*LiveEvent, error) {
	var resource LiveEvent
	err := ctx.ReadResource("azure:media/liveEvent:LiveEvent", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering LiveEvent resources.
type liveEventState struct {
	// The flag indicates if the resource should be automatically started on creation. Default is `false`.
	AutoStartEnabled *bool `pulumi:"autoStartEnabled"`
	// A `crossSiteAccessPolicy` block as defined below.
	CrossSiteAccessPolicy *LiveEventCrossSiteAccessPolicy `pulumi:"crossSiteAccessPolicy"`
	// A description for the live event.
	Description *string `pulumi:"description"`
	// A `encoding` block as defined below.
	Encoding *LiveEventEncoding `pulumi:"encoding"`
	// When `useStaticHostname` is set to true, the `hostnamePrefix` specifies the first part of the hostname assigned to the live event preview and ingest endpoints. The final hostname would be a combination of this prefix, the media service account name and a short code for the Azure Media Services data center.
	HostnamePrefix *string `pulumi:"hostnamePrefix"`
	// A `input` block as defined below.
	Input *LiveEventInputType `pulumi:"input"`
	// The Azure Region where the Live Event should exist. Changing this forces a new Live Event to be created.
	Location *string `pulumi:"location"`
	// The Media Services account name. Changing this forces a new Live Event to be created.
	MediaServicesAccountName *string `pulumi:"mediaServicesAccountName"`
	// The name which should be used for this Live Event. Changing this forces a new Live Event to be created.
	Name *string `pulumi:"name"`
	// A `preview` block as defined below.
	Preview *LiveEventPreview `pulumi:"preview"`
	// The name of the Resource Group where the Live Event should exist. Changing this forces a new Live Event to be created.
	ResourceGroupName *string `pulumi:"resourceGroupName"`
	// A mapping of tags which should be assigned to the Live Event.
	Tags map[string]string `pulumi:"tags"`
	// Specifies a list of languages (locale) to be used for speech-to-text transcription – it should match the spoken language in the audio track. The value should be in `BCP-47` format (e.g: `en-US`). [See the Microsoft Documentation for more information about the live transcription feature and the list of supported languages](https://go.microsoft.com/fwlink/?linkid=2133742).
	TranscriptionLanguages []string `pulumi:"transcriptionLanguages"`
	// Specifies whether a static hostname would be assigned to the live event preview and ingest endpoints. Changing this forces a new Live Event to be created.
	// ---
	UseStaticHostname *bool `pulumi:"useStaticHostname"`
}

type LiveEventState struct {
	// The flag indicates if the resource should be automatically started on creation. Default is `false`.
	AutoStartEnabled pulumi.BoolPtrInput
	// A `crossSiteAccessPolicy` block as defined below.
	CrossSiteAccessPolicy LiveEventCrossSiteAccessPolicyPtrInput
	// A description for the live event.
	Description pulumi.StringPtrInput
	// A `encoding` block as defined below.
	Encoding LiveEventEncodingPtrInput
	// When `useStaticHostname` is set to true, the `hostnamePrefix` specifies the first part of the hostname assigned to the live event preview and ingest endpoints. The final hostname would be a combination of this prefix, the media service account name and a short code for the Azure Media Services data center.
	HostnamePrefix pulumi.StringPtrInput
	// A `input` block as defined below.
	Input LiveEventInputTypePtrInput
	// The Azure Region where the Live Event should exist. Changing this forces a new Live Event to be created.
	Location pulumi.StringPtrInput
	// The Media Services account name. Changing this forces a new Live Event to be created.
	MediaServicesAccountName pulumi.StringPtrInput
	// The name which should be used for this Live Event. Changing this forces a new Live Event to be created.
	Name pulumi.StringPtrInput
	// A `preview` block as defined below.
	Preview LiveEventPreviewPtrInput
	// The name of the Resource Group where the Live Event should exist. Changing this forces a new Live Event to be created.
	ResourceGroupName pulumi.StringPtrInput
	// A mapping of tags which should be assigned to the Live Event.
	Tags pulumi.StringMapInput
	// Specifies a list of languages (locale) to be used for speech-to-text transcription – it should match the spoken language in the audio track. The value should be in `BCP-47` format (e.g: `en-US`). [See the Microsoft Documentation for more information about the live transcription feature and the list of supported languages](https://go.microsoft.com/fwlink/?linkid=2133742).
	TranscriptionLanguages pulumi.StringArrayInput
	// Specifies whether a static hostname would be assigned to the live event preview and ingest endpoints. Changing this forces a new Live Event to be created.
	// ---
	UseStaticHostname pulumi.BoolPtrInput
}

func (LiveEventState) ElementType() reflect.Type {
	return reflect.TypeOf((*liveEventState)(nil)).Elem()
}

type liveEventArgs struct {
	// The flag indicates if the resource should be automatically started on creation. Default is `false`.
	AutoStartEnabled *bool `pulumi:"autoStartEnabled"`
	// A `crossSiteAccessPolicy` block as defined below.
	CrossSiteAccessPolicy *LiveEventCrossSiteAccessPolicy `pulumi:"crossSiteAccessPolicy"`
	// A description for the live event.
	Description *string `pulumi:"description"`
	// A `encoding` block as defined below.
	Encoding *LiveEventEncoding `pulumi:"encoding"`
	// When `useStaticHostname` is set to true, the `hostnamePrefix` specifies the first part of the hostname assigned to the live event preview and ingest endpoints. The final hostname would be a combination of this prefix, the media service account name and a short code for the Azure Media Services data center.
	HostnamePrefix *string `pulumi:"hostnamePrefix"`
	// A `input` block as defined below.
	Input LiveEventInputType `pulumi:"input"`
	// The Azure Region where the Live Event should exist. Changing this forces a new Live Event to be created.
	Location *string `pulumi:"location"`
	// The Media Services account name. Changing this forces a new Live Event to be created.
	MediaServicesAccountName string `pulumi:"mediaServicesAccountName"`
	// The name which should be used for this Live Event. Changing this forces a new Live Event to be created.
	Name *string `pulumi:"name"`
	// A `preview` block as defined below.
	Preview *LiveEventPreview `pulumi:"preview"`
	// The name of the Resource Group where the Live Event should exist. Changing this forces a new Live Event to be created.
	ResourceGroupName string `pulumi:"resourceGroupName"`
	// A mapping of tags which should be assigned to the Live Event.
	Tags map[string]string `pulumi:"tags"`
	// Specifies a list of languages (locale) to be used for speech-to-text transcription – it should match the spoken language in the audio track. The value should be in `BCP-47` format (e.g: `en-US`). [See the Microsoft Documentation for more information about the live transcription feature and the list of supported languages](https://go.microsoft.com/fwlink/?linkid=2133742).
	TranscriptionLanguages []string `pulumi:"transcriptionLanguages"`
	// Specifies whether a static hostname would be assigned to the live event preview and ingest endpoints. Changing this forces a new Live Event to be created.
	// ---
	UseStaticHostname *bool `pulumi:"useStaticHostname"`
}

// The set of arguments for constructing a LiveEvent resource.
type LiveEventArgs struct {
	// The flag indicates if the resource should be automatically started on creation. Default is `false`.
	AutoStartEnabled pulumi.BoolPtrInput
	// A `crossSiteAccessPolicy` block as defined below.
	CrossSiteAccessPolicy LiveEventCrossSiteAccessPolicyPtrInput
	// A description for the live event.
	Description pulumi.StringPtrInput
	// A `encoding` block as defined below.
	Encoding LiveEventEncodingPtrInput
	// When `useStaticHostname` is set to true, the `hostnamePrefix` specifies the first part of the hostname assigned to the live event preview and ingest endpoints. The final hostname would be a combination of this prefix, the media service account name and a short code for the Azure Media Services data center.
	HostnamePrefix pulumi.StringPtrInput
	// A `input` block as defined below.
	Input LiveEventInputTypeInput
	// The Azure Region where the Live Event should exist. Changing this forces a new Live Event to be created.
	Location pulumi.StringPtrInput
	// The Media Services account name. Changing this forces a new Live Event to be created.
	MediaServicesAccountName pulumi.StringInput
	// The name which should be used for this Live Event. Changing this forces a new Live Event to be created.
	Name pulumi.StringPtrInput
	// A `preview` block as defined below.
	Preview LiveEventPreviewPtrInput
	// The name of the Resource Group where the Live Event should exist. Changing this forces a new Live Event to be created.
	ResourceGroupName pulumi.StringInput
	// A mapping of tags which should be assigned to the Live Event.
	Tags pulumi.StringMapInput
	// Specifies a list of languages (locale) to be used for speech-to-text transcription – it should match the spoken language in the audio track. The value should be in `BCP-47` format (e.g: `en-US`). [See the Microsoft Documentation for more information about the live transcription feature and the list of supported languages](https://go.microsoft.com/fwlink/?linkid=2133742).
	TranscriptionLanguages pulumi.StringArrayInput
	// Specifies whether a static hostname would be assigned to the live event preview and ingest endpoints. Changing this forces a new Live Event to be created.
	// ---
	UseStaticHostname pulumi.BoolPtrInput
}

func (LiveEventArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*liveEventArgs)(nil)).Elem()
}

type LiveEventInput interface {
	pulumi.Input

	ToLiveEventOutput() LiveEventOutput
	ToLiveEventOutputWithContext(ctx context.Context) LiveEventOutput
}

func (*LiveEvent) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEvent)(nil))
}

func (i *LiveEvent) ToLiveEventOutput() LiveEventOutput {
	return i.ToLiveEventOutputWithContext(context.Background())
}

func (i *LiveEvent) ToLiveEventOutputWithContext(ctx context.Context) LiveEventOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventOutput)
}

func (i *LiveEvent) ToLiveEventPtrOutput() LiveEventPtrOutput {
	return i.ToLiveEventPtrOutputWithContext(context.Background())
}

func (i *LiveEvent) ToLiveEventPtrOutputWithContext(ctx context.Context) LiveEventPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventPtrOutput)
}

type LiveEventPtrInput interface {
	pulumi.Input

	ToLiveEventPtrOutput() LiveEventPtrOutput
	ToLiveEventPtrOutputWithContext(ctx context.Context) LiveEventPtrOutput
}

type liveEventPtrType LiveEventArgs

func (*liveEventPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LiveEvent)(nil))
}

func (i *liveEventPtrType) ToLiveEventPtrOutput() LiveEventPtrOutput {
	return i.ToLiveEventPtrOutputWithContext(context.Background())
}

func (i *liveEventPtrType) ToLiveEventPtrOutputWithContext(ctx context.Context) LiveEventPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventPtrOutput)
}

// LiveEventArrayInput is an input type that accepts LiveEventArray and LiveEventArrayOutput values.
// You can construct a concrete instance of `LiveEventArrayInput` via:
//
//          LiveEventArray{ LiveEventArgs{...} }
type LiveEventArrayInput interface {
	pulumi.Input

	ToLiveEventArrayOutput() LiveEventArrayOutput
	ToLiveEventArrayOutputWithContext(context.Context) LiveEventArrayOutput
}

type LiveEventArray []LiveEventInput

func (LiveEventArray) ElementType() reflect.Type {
	return reflect.TypeOf(([]*LiveEvent)(nil))
}

func (i LiveEventArray) ToLiveEventArrayOutput() LiveEventArrayOutput {
	return i.ToLiveEventArrayOutputWithContext(context.Background())
}

func (i LiveEventArray) ToLiveEventArrayOutputWithContext(ctx context.Context) LiveEventArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventArrayOutput)
}

// LiveEventMapInput is an input type that accepts LiveEventMap and LiveEventMapOutput values.
// You can construct a concrete instance of `LiveEventMapInput` via:
//
//          LiveEventMap{ "key": LiveEventArgs{...} }
type LiveEventMapInput interface {
	pulumi.Input

	ToLiveEventMapOutput() LiveEventMapOutput
	ToLiveEventMapOutputWithContext(context.Context) LiveEventMapOutput
}

type LiveEventMap map[string]LiveEventInput

func (LiveEventMap) ElementType() reflect.Type {
	return reflect.TypeOf((map[string]*LiveEvent)(nil))
}

func (i LiveEventMap) ToLiveEventMapOutput() LiveEventMapOutput {
	return i.ToLiveEventMapOutputWithContext(context.Background())
}

func (i LiveEventMap) ToLiveEventMapOutputWithContext(ctx context.Context) LiveEventMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventMapOutput)
}

type LiveEventOutput struct {
	*pulumi.OutputState
}

func (LiveEventOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEvent)(nil))
}

func (o LiveEventOutput) ToLiveEventOutput() LiveEventOutput {
	return o
}

func (o LiveEventOutput) ToLiveEventOutputWithContext(ctx context.Context) LiveEventOutput {
	return o
}

func (o LiveEventOutput) ToLiveEventPtrOutput() LiveEventPtrOutput {
	return o.ToLiveEventPtrOutputWithContext(context.Background())
}

func (o LiveEventOutput) ToLiveEventPtrOutputWithContext(ctx context.Context) LiveEventPtrOutput {
	return o.ApplyT(func(v LiveEvent) *LiveEvent {
		return &v
	}).(LiveEventPtrOutput)
}

type LiveEventPtrOutput struct {
	*pulumi.OutputState
}

func (LiveEventPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LiveEvent)(nil))
}

func (o LiveEventPtrOutput) ToLiveEventPtrOutput() LiveEventPtrOutput {
	return o
}

func (o LiveEventPtrOutput) ToLiveEventPtrOutputWithContext(ctx context.Context) LiveEventPtrOutput {
	return o
}

type LiveEventArrayOutput struct{ *pulumi.OutputState }

func (LiveEventArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LiveEvent)(nil))
}

func (o LiveEventArrayOutput) ToLiveEventArrayOutput() LiveEventArrayOutput {
	return o
}

func (o LiveEventArrayOutput) ToLiveEventArrayOutputWithContext(ctx context.Context) LiveEventArrayOutput {
	return o
}

func (o LiveEventArrayOutput) Index(i pulumi.IntInput) LiveEventOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LiveEvent {
		return vs[0].([]LiveEvent)[vs[1].(int)]
	}).(LiveEventOutput)
}

type LiveEventMapOutput struct{ *pulumi.OutputState }

func (LiveEventMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]LiveEvent)(nil))
}

func (o LiveEventMapOutput) ToLiveEventMapOutput() LiveEventMapOutput {
	return o
}

func (o LiveEventMapOutput) ToLiveEventMapOutputWithContext(ctx context.Context) LiveEventMapOutput {
	return o
}

func (o LiveEventMapOutput) MapIndex(k pulumi.StringInput) LiveEventOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) LiveEvent {
		return vs[0].(map[string]LiveEvent)[vs[1].(string)]
	}).(LiveEventOutput)
}

func init() {
	pulumi.RegisterOutputType(LiveEventOutput{})
	pulumi.RegisterOutputType(LiveEventPtrOutput{})
	pulumi.RegisterOutputType(LiveEventArrayOutput{})
	pulumi.RegisterOutputType(LiveEventMapOutput{})
}
