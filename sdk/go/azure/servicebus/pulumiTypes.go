// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package servicebus

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-azure/sdk/v6/go/azure/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = internal.GetEnvOrDefault

type NamespaceCustomerManagedKeyType struct {
	// The ID of the User Assigned Identity that has access to the key.
	IdentityId string `pulumi:"identityId"`
	// Used to specify whether enable Infrastructure Encryption (Double Encryption). Changing this forces a new resource to be created.
	InfrastructureEncryptionEnabled *bool `pulumi:"infrastructureEncryptionEnabled"`
	// The ID of the Key Vault Key which should be used to Encrypt the data in this Service Bus Namespace.
	KeyVaultKeyId string `pulumi:"keyVaultKeyId"`
}

// NamespaceCustomerManagedKeyTypeInput is an input type that accepts NamespaceCustomerManagedKeyTypeArgs and NamespaceCustomerManagedKeyTypeOutput values.
// You can construct a concrete instance of `NamespaceCustomerManagedKeyTypeInput` via:
//
//	NamespaceCustomerManagedKeyTypeArgs{...}
type NamespaceCustomerManagedKeyTypeInput interface {
	pulumi.Input

	ToNamespaceCustomerManagedKeyTypeOutput() NamespaceCustomerManagedKeyTypeOutput
	ToNamespaceCustomerManagedKeyTypeOutputWithContext(context.Context) NamespaceCustomerManagedKeyTypeOutput
}

type NamespaceCustomerManagedKeyTypeArgs struct {
	// The ID of the User Assigned Identity that has access to the key.
	IdentityId pulumi.StringInput `pulumi:"identityId"`
	// Used to specify whether enable Infrastructure Encryption (Double Encryption). Changing this forces a new resource to be created.
	InfrastructureEncryptionEnabled pulumi.BoolPtrInput `pulumi:"infrastructureEncryptionEnabled"`
	// The ID of the Key Vault Key which should be used to Encrypt the data in this Service Bus Namespace.
	KeyVaultKeyId pulumi.StringInput `pulumi:"keyVaultKeyId"`
}

func (NamespaceCustomerManagedKeyTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NamespaceCustomerManagedKeyType)(nil)).Elem()
}

func (i NamespaceCustomerManagedKeyTypeArgs) ToNamespaceCustomerManagedKeyTypeOutput() NamespaceCustomerManagedKeyTypeOutput {
	return i.ToNamespaceCustomerManagedKeyTypeOutputWithContext(context.Background())
}

func (i NamespaceCustomerManagedKeyTypeArgs) ToNamespaceCustomerManagedKeyTypeOutputWithContext(ctx context.Context) NamespaceCustomerManagedKeyTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceCustomerManagedKeyTypeOutput)
}

func (i NamespaceCustomerManagedKeyTypeArgs) ToNamespaceCustomerManagedKeyTypePtrOutput() NamespaceCustomerManagedKeyTypePtrOutput {
	return i.ToNamespaceCustomerManagedKeyTypePtrOutputWithContext(context.Background())
}

func (i NamespaceCustomerManagedKeyTypeArgs) ToNamespaceCustomerManagedKeyTypePtrOutputWithContext(ctx context.Context) NamespaceCustomerManagedKeyTypePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceCustomerManagedKeyTypeOutput).ToNamespaceCustomerManagedKeyTypePtrOutputWithContext(ctx)
}

// NamespaceCustomerManagedKeyTypePtrInput is an input type that accepts NamespaceCustomerManagedKeyTypeArgs, NamespaceCustomerManagedKeyTypePtr and NamespaceCustomerManagedKeyTypePtrOutput values.
// You can construct a concrete instance of `NamespaceCustomerManagedKeyTypePtrInput` via:
//
//	        NamespaceCustomerManagedKeyTypeArgs{...}
//
//	or:
//
//	        nil
type NamespaceCustomerManagedKeyTypePtrInput interface {
	pulumi.Input

	ToNamespaceCustomerManagedKeyTypePtrOutput() NamespaceCustomerManagedKeyTypePtrOutput
	ToNamespaceCustomerManagedKeyTypePtrOutputWithContext(context.Context) NamespaceCustomerManagedKeyTypePtrOutput
}

type namespaceCustomerManagedKeyTypePtrType NamespaceCustomerManagedKeyTypeArgs

func NamespaceCustomerManagedKeyTypePtr(v *NamespaceCustomerManagedKeyTypeArgs) NamespaceCustomerManagedKeyTypePtrInput {
	return (*namespaceCustomerManagedKeyTypePtrType)(v)
}

func (*namespaceCustomerManagedKeyTypePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**NamespaceCustomerManagedKeyType)(nil)).Elem()
}

func (i *namespaceCustomerManagedKeyTypePtrType) ToNamespaceCustomerManagedKeyTypePtrOutput() NamespaceCustomerManagedKeyTypePtrOutput {
	return i.ToNamespaceCustomerManagedKeyTypePtrOutputWithContext(context.Background())
}

func (i *namespaceCustomerManagedKeyTypePtrType) ToNamespaceCustomerManagedKeyTypePtrOutputWithContext(ctx context.Context) NamespaceCustomerManagedKeyTypePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceCustomerManagedKeyTypePtrOutput)
}

type NamespaceCustomerManagedKeyTypeOutput struct{ *pulumi.OutputState }

func (NamespaceCustomerManagedKeyTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NamespaceCustomerManagedKeyType)(nil)).Elem()
}

func (o NamespaceCustomerManagedKeyTypeOutput) ToNamespaceCustomerManagedKeyTypeOutput() NamespaceCustomerManagedKeyTypeOutput {
	return o
}

func (o NamespaceCustomerManagedKeyTypeOutput) ToNamespaceCustomerManagedKeyTypeOutputWithContext(ctx context.Context) NamespaceCustomerManagedKeyTypeOutput {
	return o
}

func (o NamespaceCustomerManagedKeyTypeOutput) ToNamespaceCustomerManagedKeyTypePtrOutput() NamespaceCustomerManagedKeyTypePtrOutput {
	return o.ToNamespaceCustomerManagedKeyTypePtrOutputWithContext(context.Background())
}

func (o NamespaceCustomerManagedKeyTypeOutput) ToNamespaceCustomerManagedKeyTypePtrOutputWithContext(ctx context.Context) NamespaceCustomerManagedKeyTypePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v NamespaceCustomerManagedKeyType) *NamespaceCustomerManagedKeyType {
		return &v
	}).(NamespaceCustomerManagedKeyTypePtrOutput)
}

// The ID of the User Assigned Identity that has access to the key.
func (o NamespaceCustomerManagedKeyTypeOutput) IdentityId() pulumi.StringOutput {
	return o.ApplyT(func(v NamespaceCustomerManagedKeyType) string { return v.IdentityId }).(pulumi.StringOutput)
}

// Used to specify whether enable Infrastructure Encryption (Double Encryption). Changing this forces a new resource to be created.
func (o NamespaceCustomerManagedKeyTypeOutput) InfrastructureEncryptionEnabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v NamespaceCustomerManagedKeyType) *bool { return v.InfrastructureEncryptionEnabled }).(pulumi.BoolPtrOutput)
}

// The ID of the Key Vault Key which should be used to Encrypt the data in this Service Bus Namespace.
func (o NamespaceCustomerManagedKeyTypeOutput) KeyVaultKeyId() pulumi.StringOutput {
	return o.ApplyT(func(v NamespaceCustomerManagedKeyType) string { return v.KeyVaultKeyId }).(pulumi.StringOutput)
}

type NamespaceCustomerManagedKeyTypePtrOutput struct{ *pulumi.OutputState }

func (NamespaceCustomerManagedKeyTypePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NamespaceCustomerManagedKeyType)(nil)).Elem()
}

func (o NamespaceCustomerManagedKeyTypePtrOutput) ToNamespaceCustomerManagedKeyTypePtrOutput() NamespaceCustomerManagedKeyTypePtrOutput {
	return o
}

func (o NamespaceCustomerManagedKeyTypePtrOutput) ToNamespaceCustomerManagedKeyTypePtrOutputWithContext(ctx context.Context) NamespaceCustomerManagedKeyTypePtrOutput {
	return o
}

func (o NamespaceCustomerManagedKeyTypePtrOutput) Elem() NamespaceCustomerManagedKeyTypeOutput {
	return o.ApplyT(func(v *NamespaceCustomerManagedKeyType) NamespaceCustomerManagedKeyType {
		if v != nil {
			return *v
		}
		var ret NamespaceCustomerManagedKeyType
		return ret
	}).(NamespaceCustomerManagedKeyTypeOutput)
}

// The ID of the User Assigned Identity that has access to the key.
func (o NamespaceCustomerManagedKeyTypePtrOutput) IdentityId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NamespaceCustomerManagedKeyType) *string {
		if v == nil {
			return nil
		}
		return &v.IdentityId
	}).(pulumi.StringPtrOutput)
}

// Used to specify whether enable Infrastructure Encryption (Double Encryption). Changing this forces a new resource to be created.
func (o NamespaceCustomerManagedKeyTypePtrOutput) InfrastructureEncryptionEnabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *NamespaceCustomerManagedKeyType) *bool {
		if v == nil {
			return nil
		}
		return v.InfrastructureEncryptionEnabled
	}).(pulumi.BoolPtrOutput)
}

// The ID of the Key Vault Key which should be used to Encrypt the data in this Service Bus Namespace.
func (o NamespaceCustomerManagedKeyTypePtrOutput) KeyVaultKeyId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NamespaceCustomerManagedKeyType) *string {
		if v == nil {
			return nil
		}
		return &v.KeyVaultKeyId
	}).(pulumi.StringPtrOutput)
}

type NamespaceIdentity struct {
	// Specifies a list of User Assigned Managed Identity IDs to be assigned to this Service Bus namespace.
	//
	// > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
	IdentityIds []string `pulumi:"identityIds"`
	// The Principal ID for the Service Principal associated with the Managed Service Identity of this Service Bus Namespace.
	PrincipalId *string `pulumi:"principalId"`
	// The Tenant ID for the Service Principal associated with the Managed Service Identity of this Service Bus Namespace.
	TenantId *string `pulumi:"tenantId"`
	// Specifies the type of Managed Service Identity that should be configured on this Service Bus Namespace. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
	Type string `pulumi:"type"`
}

// NamespaceIdentityInput is an input type that accepts NamespaceIdentityArgs and NamespaceIdentityOutput values.
// You can construct a concrete instance of `NamespaceIdentityInput` via:
//
//	NamespaceIdentityArgs{...}
type NamespaceIdentityInput interface {
	pulumi.Input

	ToNamespaceIdentityOutput() NamespaceIdentityOutput
	ToNamespaceIdentityOutputWithContext(context.Context) NamespaceIdentityOutput
}

type NamespaceIdentityArgs struct {
	// Specifies a list of User Assigned Managed Identity IDs to be assigned to this Service Bus namespace.
	//
	// > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
	IdentityIds pulumi.StringArrayInput `pulumi:"identityIds"`
	// The Principal ID for the Service Principal associated with the Managed Service Identity of this Service Bus Namespace.
	PrincipalId pulumi.StringPtrInput `pulumi:"principalId"`
	// The Tenant ID for the Service Principal associated with the Managed Service Identity of this Service Bus Namespace.
	TenantId pulumi.StringPtrInput `pulumi:"tenantId"`
	// Specifies the type of Managed Service Identity that should be configured on this Service Bus Namespace. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
	Type pulumi.StringInput `pulumi:"type"`
}

func (NamespaceIdentityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NamespaceIdentity)(nil)).Elem()
}

func (i NamespaceIdentityArgs) ToNamespaceIdentityOutput() NamespaceIdentityOutput {
	return i.ToNamespaceIdentityOutputWithContext(context.Background())
}

func (i NamespaceIdentityArgs) ToNamespaceIdentityOutputWithContext(ctx context.Context) NamespaceIdentityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceIdentityOutput)
}

func (i NamespaceIdentityArgs) ToNamespaceIdentityPtrOutput() NamespaceIdentityPtrOutput {
	return i.ToNamespaceIdentityPtrOutputWithContext(context.Background())
}

func (i NamespaceIdentityArgs) ToNamespaceIdentityPtrOutputWithContext(ctx context.Context) NamespaceIdentityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceIdentityOutput).ToNamespaceIdentityPtrOutputWithContext(ctx)
}

// NamespaceIdentityPtrInput is an input type that accepts NamespaceIdentityArgs, NamespaceIdentityPtr and NamespaceIdentityPtrOutput values.
// You can construct a concrete instance of `NamespaceIdentityPtrInput` via:
//
//	        NamespaceIdentityArgs{...}
//
//	or:
//
//	        nil
type NamespaceIdentityPtrInput interface {
	pulumi.Input

	ToNamespaceIdentityPtrOutput() NamespaceIdentityPtrOutput
	ToNamespaceIdentityPtrOutputWithContext(context.Context) NamespaceIdentityPtrOutput
}

type namespaceIdentityPtrType NamespaceIdentityArgs

func NamespaceIdentityPtr(v *NamespaceIdentityArgs) NamespaceIdentityPtrInput {
	return (*namespaceIdentityPtrType)(v)
}

func (*namespaceIdentityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**NamespaceIdentity)(nil)).Elem()
}

func (i *namespaceIdentityPtrType) ToNamespaceIdentityPtrOutput() NamespaceIdentityPtrOutput {
	return i.ToNamespaceIdentityPtrOutputWithContext(context.Background())
}

func (i *namespaceIdentityPtrType) ToNamespaceIdentityPtrOutputWithContext(ctx context.Context) NamespaceIdentityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceIdentityPtrOutput)
}

type NamespaceIdentityOutput struct{ *pulumi.OutputState }

func (NamespaceIdentityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NamespaceIdentity)(nil)).Elem()
}

func (o NamespaceIdentityOutput) ToNamespaceIdentityOutput() NamespaceIdentityOutput {
	return o
}

func (o NamespaceIdentityOutput) ToNamespaceIdentityOutputWithContext(ctx context.Context) NamespaceIdentityOutput {
	return o
}

func (o NamespaceIdentityOutput) ToNamespaceIdentityPtrOutput() NamespaceIdentityPtrOutput {
	return o.ToNamespaceIdentityPtrOutputWithContext(context.Background())
}

func (o NamespaceIdentityOutput) ToNamespaceIdentityPtrOutputWithContext(ctx context.Context) NamespaceIdentityPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v NamespaceIdentity) *NamespaceIdentity {
		return &v
	}).(NamespaceIdentityPtrOutput)
}

// Specifies a list of User Assigned Managed Identity IDs to be assigned to this Service Bus namespace.
//
// > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
func (o NamespaceIdentityOutput) IdentityIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NamespaceIdentity) []string { return v.IdentityIds }).(pulumi.StringArrayOutput)
}

// The Principal ID for the Service Principal associated with the Managed Service Identity of this Service Bus Namespace.
func (o NamespaceIdentityOutput) PrincipalId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NamespaceIdentity) *string { return v.PrincipalId }).(pulumi.StringPtrOutput)
}

// The Tenant ID for the Service Principal associated with the Managed Service Identity of this Service Bus Namespace.
func (o NamespaceIdentityOutput) TenantId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NamespaceIdentity) *string { return v.TenantId }).(pulumi.StringPtrOutput)
}

// Specifies the type of Managed Service Identity that should be configured on this Service Bus Namespace. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
func (o NamespaceIdentityOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v NamespaceIdentity) string { return v.Type }).(pulumi.StringOutput)
}

type NamespaceIdentityPtrOutput struct{ *pulumi.OutputState }

func (NamespaceIdentityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NamespaceIdentity)(nil)).Elem()
}

func (o NamespaceIdentityPtrOutput) ToNamespaceIdentityPtrOutput() NamespaceIdentityPtrOutput {
	return o
}

func (o NamespaceIdentityPtrOutput) ToNamespaceIdentityPtrOutputWithContext(ctx context.Context) NamespaceIdentityPtrOutput {
	return o
}

func (o NamespaceIdentityPtrOutput) Elem() NamespaceIdentityOutput {
	return o.ApplyT(func(v *NamespaceIdentity) NamespaceIdentity {
		if v != nil {
			return *v
		}
		var ret NamespaceIdentity
		return ret
	}).(NamespaceIdentityOutput)
}

// Specifies a list of User Assigned Managed Identity IDs to be assigned to this Service Bus namespace.
//
// > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
func (o NamespaceIdentityPtrOutput) IdentityIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *NamespaceIdentity) []string {
		if v == nil {
			return nil
		}
		return v.IdentityIds
	}).(pulumi.StringArrayOutput)
}

// The Principal ID for the Service Principal associated with the Managed Service Identity of this Service Bus Namespace.
func (o NamespaceIdentityPtrOutput) PrincipalId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NamespaceIdentity) *string {
		if v == nil {
			return nil
		}
		return v.PrincipalId
	}).(pulumi.StringPtrOutput)
}

// The Tenant ID for the Service Principal associated with the Managed Service Identity of this Service Bus Namespace.
func (o NamespaceIdentityPtrOutput) TenantId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NamespaceIdentity) *string {
		if v == nil {
			return nil
		}
		return v.TenantId
	}).(pulumi.StringPtrOutput)
}

// Specifies the type of Managed Service Identity that should be configured on this Service Bus Namespace. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
func (o NamespaceIdentityPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NamespaceIdentity) *string {
		if v == nil {
			return nil
		}
		return &v.Type
	}).(pulumi.StringPtrOutput)
}

type NamespaceNetworkRuleSet struct {
	// Specifies the default action for the Network Rule Set. Possible values are `Allow` and `Deny`. Defaults to `Allow`.
	DefaultAction *string `pulumi:"defaultAction"`
	// One or more IP Addresses, or CIDR Blocks which should be able to access the Service Bus Namespace.
	IpRules []string `pulumi:"ipRules"`
	// One or more `networkRules` blocks as defined below.
	NetworkRules []NamespaceNetworkRuleSetNetworkRule `pulumi:"networkRules"`
	// Whether to allow traffic over public network. Possible values are `true` and `false`. Defaults to `true`.
	//
	// > **Note:** To disable public network access, you must also configure the property `publicNetworkAccessEnabled`.
	PublicNetworkAccessEnabled *bool `pulumi:"publicNetworkAccessEnabled"`
	// Are Azure Services that are known and trusted for this resource type are allowed to bypass firewall configuration? See [Trusted Microsoft Services](https://github.com/MicrosoftDocs/azure-docs/blob/master/articles/service-bus-messaging/includes/service-bus-trusted-services.md)
	TrustedServicesAllowed *bool `pulumi:"trustedServicesAllowed"`
}

// NamespaceNetworkRuleSetInput is an input type that accepts NamespaceNetworkRuleSetArgs and NamespaceNetworkRuleSetOutput values.
// You can construct a concrete instance of `NamespaceNetworkRuleSetInput` via:
//
//	NamespaceNetworkRuleSetArgs{...}
type NamespaceNetworkRuleSetInput interface {
	pulumi.Input

	ToNamespaceNetworkRuleSetOutput() NamespaceNetworkRuleSetOutput
	ToNamespaceNetworkRuleSetOutputWithContext(context.Context) NamespaceNetworkRuleSetOutput
}

type NamespaceNetworkRuleSetArgs struct {
	// Specifies the default action for the Network Rule Set. Possible values are `Allow` and `Deny`. Defaults to `Allow`.
	DefaultAction pulumi.StringPtrInput `pulumi:"defaultAction"`
	// One or more IP Addresses, or CIDR Blocks which should be able to access the Service Bus Namespace.
	IpRules pulumi.StringArrayInput `pulumi:"ipRules"`
	// One or more `networkRules` blocks as defined below.
	NetworkRules NamespaceNetworkRuleSetNetworkRuleArrayInput `pulumi:"networkRules"`
	// Whether to allow traffic over public network. Possible values are `true` and `false`. Defaults to `true`.
	//
	// > **Note:** To disable public network access, you must also configure the property `publicNetworkAccessEnabled`.
	PublicNetworkAccessEnabled pulumi.BoolPtrInput `pulumi:"publicNetworkAccessEnabled"`
	// Are Azure Services that are known and trusted for this resource type are allowed to bypass firewall configuration? See [Trusted Microsoft Services](https://github.com/MicrosoftDocs/azure-docs/blob/master/articles/service-bus-messaging/includes/service-bus-trusted-services.md)
	TrustedServicesAllowed pulumi.BoolPtrInput `pulumi:"trustedServicesAllowed"`
}

func (NamespaceNetworkRuleSetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NamespaceNetworkRuleSet)(nil)).Elem()
}

func (i NamespaceNetworkRuleSetArgs) ToNamespaceNetworkRuleSetOutput() NamespaceNetworkRuleSetOutput {
	return i.ToNamespaceNetworkRuleSetOutputWithContext(context.Background())
}

func (i NamespaceNetworkRuleSetArgs) ToNamespaceNetworkRuleSetOutputWithContext(ctx context.Context) NamespaceNetworkRuleSetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceNetworkRuleSetOutput)
}

func (i NamespaceNetworkRuleSetArgs) ToNamespaceNetworkRuleSetPtrOutput() NamespaceNetworkRuleSetPtrOutput {
	return i.ToNamespaceNetworkRuleSetPtrOutputWithContext(context.Background())
}

func (i NamespaceNetworkRuleSetArgs) ToNamespaceNetworkRuleSetPtrOutputWithContext(ctx context.Context) NamespaceNetworkRuleSetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceNetworkRuleSetOutput).ToNamespaceNetworkRuleSetPtrOutputWithContext(ctx)
}

// NamespaceNetworkRuleSetPtrInput is an input type that accepts NamespaceNetworkRuleSetArgs, NamespaceNetworkRuleSetPtr and NamespaceNetworkRuleSetPtrOutput values.
// You can construct a concrete instance of `NamespaceNetworkRuleSetPtrInput` via:
//
//	        NamespaceNetworkRuleSetArgs{...}
//
//	or:
//
//	        nil
type NamespaceNetworkRuleSetPtrInput interface {
	pulumi.Input

	ToNamespaceNetworkRuleSetPtrOutput() NamespaceNetworkRuleSetPtrOutput
	ToNamespaceNetworkRuleSetPtrOutputWithContext(context.Context) NamespaceNetworkRuleSetPtrOutput
}

type namespaceNetworkRuleSetPtrType NamespaceNetworkRuleSetArgs

func NamespaceNetworkRuleSetPtr(v *NamespaceNetworkRuleSetArgs) NamespaceNetworkRuleSetPtrInput {
	return (*namespaceNetworkRuleSetPtrType)(v)
}

func (*namespaceNetworkRuleSetPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**NamespaceNetworkRuleSet)(nil)).Elem()
}

func (i *namespaceNetworkRuleSetPtrType) ToNamespaceNetworkRuleSetPtrOutput() NamespaceNetworkRuleSetPtrOutput {
	return i.ToNamespaceNetworkRuleSetPtrOutputWithContext(context.Background())
}

func (i *namespaceNetworkRuleSetPtrType) ToNamespaceNetworkRuleSetPtrOutputWithContext(ctx context.Context) NamespaceNetworkRuleSetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceNetworkRuleSetPtrOutput)
}

type NamespaceNetworkRuleSetOutput struct{ *pulumi.OutputState }

func (NamespaceNetworkRuleSetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NamespaceNetworkRuleSet)(nil)).Elem()
}

func (o NamespaceNetworkRuleSetOutput) ToNamespaceNetworkRuleSetOutput() NamespaceNetworkRuleSetOutput {
	return o
}

func (o NamespaceNetworkRuleSetOutput) ToNamespaceNetworkRuleSetOutputWithContext(ctx context.Context) NamespaceNetworkRuleSetOutput {
	return o
}

func (o NamespaceNetworkRuleSetOutput) ToNamespaceNetworkRuleSetPtrOutput() NamespaceNetworkRuleSetPtrOutput {
	return o.ToNamespaceNetworkRuleSetPtrOutputWithContext(context.Background())
}

func (o NamespaceNetworkRuleSetOutput) ToNamespaceNetworkRuleSetPtrOutputWithContext(ctx context.Context) NamespaceNetworkRuleSetPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v NamespaceNetworkRuleSet) *NamespaceNetworkRuleSet {
		return &v
	}).(NamespaceNetworkRuleSetPtrOutput)
}

// Specifies the default action for the Network Rule Set. Possible values are `Allow` and `Deny`. Defaults to `Allow`.
func (o NamespaceNetworkRuleSetOutput) DefaultAction() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NamespaceNetworkRuleSet) *string { return v.DefaultAction }).(pulumi.StringPtrOutput)
}

// One or more IP Addresses, or CIDR Blocks which should be able to access the Service Bus Namespace.
func (o NamespaceNetworkRuleSetOutput) IpRules() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NamespaceNetworkRuleSet) []string { return v.IpRules }).(pulumi.StringArrayOutput)
}

// One or more `networkRules` blocks as defined below.
func (o NamespaceNetworkRuleSetOutput) NetworkRules() NamespaceNetworkRuleSetNetworkRuleArrayOutput {
	return o.ApplyT(func(v NamespaceNetworkRuleSet) []NamespaceNetworkRuleSetNetworkRule { return v.NetworkRules }).(NamespaceNetworkRuleSetNetworkRuleArrayOutput)
}

// Whether to allow traffic over public network. Possible values are `true` and `false`. Defaults to `true`.
//
// > **Note:** To disable public network access, you must also configure the property `publicNetworkAccessEnabled`.
func (o NamespaceNetworkRuleSetOutput) PublicNetworkAccessEnabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v NamespaceNetworkRuleSet) *bool { return v.PublicNetworkAccessEnabled }).(pulumi.BoolPtrOutput)
}

// Are Azure Services that are known and trusted for this resource type are allowed to bypass firewall configuration? See [Trusted Microsoft Services](https://github.com/MicrosoftDocs/azure-docs/blob/master/articles/service-bus-messaging/includes/service-bus-trusted-services.md)
func (o NamespaceNetworkRuleSetOutput) TrustedServicesAllowed() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v NamespaceNetworkRuleSet) *bool { return v.TrustedServicesAllowed }).(pulumi.BoolPtrOutput)
}

type NamespaceNetworkRuleSetPtrOutput struct{ *pulumi.OutputState }

func (NamespaceNetworkRuleSetPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NamespaceNetworkRuleSet)(nil)).Elem()
}

func (o NamespaceNetworkRuleSetPtrOutput) ToNamespaceNetworkRuleSetPtrOutput() NamespaceNetworkRuleSetPtrOutput {
	return o
}

func (o NamespaceNetworkRuleSetPtrOutput) ToNamespaceNetworkRuleSetPtrOutputWithContext(ctx context.Context) NamespaceNetworkRuleSetPtrOutput {
	return o
}

func (o NamespaceNetworkRuleSetPtrOutput) Elem() NamespaceNetworkRuleSetOutput {
	return o.ApplyT(func(v *NamespaceNetworkRuleSet) NamespaceNetworkRuleSet {
		if v != nil {
			return *v
		}
		var ret NamespaceNetworkRuleSet
		return ret
	}).(NamespaceNetworkRuleSetOutput)
}

// Specifies the default action for the Network Rule Set. Possible values are `Allow` and `Deny`. Defaults to `Allow`.
func (o NamespaceNetworkRuleSetPtrOutput) DefaultAction() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NamespaceNetworkRuleSet) *string {
		if v == nil {
			return nil
		}
		return v.DefaultAction
	}).(pulumi.StringPtrOutput)
}

// One or more IP Addresses, or CIDR Blocks which should be able to access the Service Bus Namespace.
func (o NamespaceNetworkRuleSetPtrOutput) IpRules() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *NamespaceNetworkRuleSet) []string {
		if v == nil {
			return nil
		}
		return v.IpRules
	}).(pulumi.StringArrayOutput)
}

// One or more `networkRules` blocks as defined below.
func (o NamespaceNetworkRuleSetPtrOutput) NetworkRules() NamespaceNetworkRuleSetNetworkRuleArrayOutput {
	return o.ApplyT(func(v *NamespaceNetworkRuleSet) []NamespaceNetworkRuleSetNetworkRule {
		if v == nil {
			return nil
		}
		return v.NetworkRules
	}).(NamespaceNetworkRuleSetNetworkRuleArrayOutput)
}

// Whether to allow traffic over public network. Possible values are `true` and `false`. Defaults to `true`.
//
// > **Note:** To disable public network access, you must also configure the property `publicNetworkAccessEnabled`.
func (o NamespaceNetworkRuleSetPtrOutput) PublicNetworkAccessEnabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *NamespaceNetworkRuleSet) *bool {
		if v == nil {
			return nil
		}
		return v.PublicNetworkAccessEnabled
	}).(pulumi.BoolPtrOutput)
}

// Are Azure Services that are known and trusted for this resource type are allowed to bypass firewall configuration? See [Trusted Microsoft Services](https://github.com/MicrosoftDocs/azure-docs/blob/master/articles/service-bus-messaging/includes/service-bus-trusted-services.md)
func (o NamespaceNetworkRuleSetPtrOutput) TrustedServicesAllowed() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *NamespaceNetworkRuleSet) *bool {
		if v == nil {
			return nil
		}
		return v.TrustedServicesAllowed
	}).(pulumi.BoolPtrOutput)
}

type NamespaceNetworkRuleSetNetworkRule struct {
	// Should the Service Bus Namespace Network Rule Set ignore missing Virtual Network Service Endpoint option in the Subnet? Defaults to `false`.
	IgnoreMissingVnetServiceEndpoint *bool `pulumi:"ignoreMissingVnetServiceEndpoint"`
	// The Subnet ID which should be able to access this Service Bus Namespace.
	SubnetId string `pulumi:"subnetId"`
}

// NamespaceNetworkRuleSetNetworkRuleInput is an input type that accepts NamespaceNetworkRuleSetNetworkRuleArgs and NamespaceNetworkRuleSetNetworkRuleOutput values.
// You can construct a concrete instance of `NamespaceNetworkRuleSetNetworkRuleInput` via:
//
//	NamespaceNetworkRuleSetNetworkRuleArgs{...}
type NamespaceNetworkRuleSetNetworkRuleInput interface {
	pulumi.Input

	ToNamespaceNetworkRuleSetNetworkRuleOutput() NamespaceNetworkRuleSetNetworkRuleOutput
	ToNamespaceNetworkRuleSetNetworkRuleOutputWithContext(context.Context) NamespaceNetworkRuleSetNetworkRuleOutput
}

type NamespaceNetworkRuleSetNetworkRuleArgs struct {
	// Should the Service Bus Namespace Network Rule Set ignore missing Virtual Network Service Endpoint option in the Subnet? Defaults to `false`.
	IgnoreMissingVnetServiceEndpoint pulumi.BoolPtrInput `pulumi:"ignoreMissingVnetServiceEndpoint"`
	// The Subnet ID which should be able to access this Service Bus Namespace.
	SubnetId pulumi.StringInput `pulumi:"subnetId"`
}

func (NamespaceNetworkRuleSetNetworkRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NamespaceNetworkRuleSetNetworkRule)(nil)).Elem()
}

func (i NamespaceNetworkRuleSetNetworkRuleArgs) ToNamespaceNetworkRuleSetNetworkRuleOutput() NamespaceNetworkRuleSetNetworkRuleOutput {
	return i.ToNamespaceNetworkRuleSetNetworkRuleOutputWithContext(context.Background())
}

func (i NamespaceNetworkRuleSetNetworkRuleArgs) ToNamespaceNetworkRuleSetNetworkRuleOutputWithContext(ctx context.Context) NamespaceNetworkRuleSetNetworkRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceNetworkRuleSetNetworkRuleOutput)
}

// NamespaceNetworkRuleSetNetworkRuleArrayInput is an input type that accepts NamespaceNetworkRuleSetNetworkRuleArray and NamespaceNetworkRuleSetNetworkRuleArrayOutput values.
// You can construct a concrete instance of `NamespaceNetworkRuleSetNetworkRuleArrayInput` via:
//
//	NamespaceNetworkRuleSetNetworkRuleArray{ NamespaceNetworkRuleSetNetworkRuleArgs{...} }
type NamespaceNetworkRuleSetNetworkRuleArrayInput interface {
	pulumi.Input

	ToNamespaceNetworkRuleSetNetworkRuleArrayOutput() NamespaceNetworkRuleSetNetworkRuleArrayOutput
	ToNamespaceNetworkRuleSetNetworkRuleArrayOutputWithContext(context.Context) NamespaceNetworkRuleSetNetworkRuleArrayOutput
}

type NamespaceNetworkRuleSetNetworkRuleArray []NamespaceNetworkRuleSetNetworkRuleInput

func (NamespaceNetworkRuleSetNetworkRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NamespaceNetworkRuleSetNetworkRule)(nil)).Elem()
}

func (i NamespaceNetworkRuleSetNetworkRuleArray) ToNamespaceNetworkRuleSetNetworkRuleArrayOutput() NamespaceNetworkRuleSetNetworkRuleArrayOutput {
	return i.ToNamespaceNetworkRuleSetNetworkRuleArrayOutputWithContext(context.Background())
}

func (i NamespaceNetworkRuleSetNetworkRuleArray) ToNamespaceNetworkRuleSetNetworkRuleArrayOutputWithContext(ctx context.Context) NamespaceNetworkRuleSetNetworkRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceNetworkRuleSetNetworkRuleArrayOutput)
}

type NamespaceNetworkRuleSetNetworkRuleOutput struct{ *pulumi.OutputState }

func (NamespaceNetworkRuleSetNetworkRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NamespaceNetworkRuleSetNetworkRule)(nil)).Elem()
}

func (o NamespaceNetworkRuleSetNetworkRuleOutput) ToNamespaceNetworkRuleSetNetworkRuleOutput() NamespaceNetworkRuleSetNetworkRuleOutput {
	return o
}

func (o NamespaceNetworkRuleSetNetworkRuleOutput) ToNamespaceNetworkRuleSetNetworkRuleOutputWithContext(ctx context.Context) NamespaceNetworkRuleSetNetworkRuleOutput {
	return o
}

// Should the Service Bus Namespace Network Rule Set ignore missing Virtual Network Service Endpoint option in the Subnet? Defaults to `false`.
func (o NamespaceNetworkRuleSetNetworkRuleOutput) IgnoreMissingVnetServiceEndpoint() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v NamespaceNetworkRuleSetNetworkRule) *bool { return v.IgnoreMissingVnetServiceEndpoint }).(pulumi.BoolPtrOutput)
}

// The Subnet ID which should be able to access this Service Bus Namespace.
func (o NamespaceNetworkRuleSetNetworkRuleOutput) SubnetId() pulumi.StringOutput {
	return o.ApplyT(func(v NamespaceNetworkRuleSetNetworkRule) string { return v.SubnetId }).(pulumi.StringOutput)
}

type NamespaceNetworkRuleSetNetworkRuleArrayOutput struct{ *pulumi.OutputState }

func (NamespaceNetworkRuleSetNetworkRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NamespaceNetworkRuleSetNetworkRule)(nil)).Elem()
}

func (o NamespaceNetworkRuleSetNetworkRuleArrayOutput) ToNamespaceNetworkRuleSetNetworkRuleArrayOutput() NamespaceNetworkRuleSetNetworkRuleArrayOutput {
	return o
}

func (o NamespaceNetworkRuleSetNetworkRuleArrayOutput) ToNamespaceNetworkRuleSetNetworkRuleArrayOutputWithContext(ctx context.Context) NamespaceNetworkRuleSetNetworkRuleArrayOutput {
	return o
}

func (o NamespaceNetworkRuleSetNetworkRuleArrayOutput) Index(i pulumi.IntInput) NamespaceNetworkRuleSetNetworkRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) NamespaceNetworkRuleSetNetworkRule {
		return vs[0].([]NamespaceNetworkRuleSetNetworkRule)[vs[1].(int)]
	}).(NamespaceNetworkRuleSetNetworkRuleOutput)
}

type SubscriptionClientScopedSubscription struct {
	// Specifies the Client ID of the application that created the client-scoped subscription. Changing this forces a new resource to be created.
	//
	// > **NOTE:** Client ID can be null or empty, but it must match the client ID set on the JMS client application. From the Azure Service Bus perspective, a null client ID and an empty client id have the same behavior. If the client ID is set to null or empty, it is only accessible to client applications whose client ID is also set to null or empty.
	ClientId *string `pulumi:"clientId"`
	// Whether the client scoped subscription is durable. This property can only be controlled from the application side.
	IsClientScopedSubscriptionDurable *bool `pulumi:"isClientScopedSubscriptionDurable"`
	// Whether the client scoped subscription is shareable. Defaults to `true` Changing this forces a new resource to be created.
	IsClientScopedSubscriptionShareable *bool `pulumi:"isClientScopedSubscriptionShareable"`
}

// SubscriptionClientScopedSubscriptionInput is an input type that accepts SubscriptionClientScopedSubscriptionArgs and SubscriptionClientScopedSubscriptionOutput values.
// You can construct a concrete instance of `SubscriptionClientScopedSubscriptionInput` via:
//
//	SubscriptionClientScopedSubscriptionArgs{...}
type SubscriptionClientScopedSubscriptionInput interface {
	pulumi.Input

	ToSubscriptionClientScopedSubscriptionOutput() SubscriptionClientScopedSubscriptionOutput
	ToSubscriptionClientScopedSubscriptionOutputWithContext(context.Context) SubscriptionClientScopedSubscriptionOutput
}

type SubscriptionClientScopedSubscriptionArgs struct {
	// Specifies the Client ID of the application that created the client-scoped subscription. Changing this forces a new resource to be created.
	//
	// > **NOTE:** Client ID can be null or empty, but it must match the client ID set on the JMS client application. From the Azure Service Bus perspective, a null client ID and an empty client id have the same behavior. If the client ID is set to null or empty, it is only accessible to client applications whose client ID is also set to null or empty.
	ClientId pulumi.StringPtrInput `pulumi:"clientId"`
	// Whether the client scoped subscription is durable. This property can only be controlled from the application side.
	IsClientScopedSubscriptionDurable pulumi.BoolPtrInput `pulumi:"isClientScopedSubscriptionDurable"`
	// Whether the client scoped subscription is shareable. Defaults to `true` Changing this forces a new resource to be created.
	IsClientScopedSubscriptionShareable pulumi.BoolPtrInput `pulumi:"isClientScopedSubscriptionShareable"`
}

func (SubscriptionClientScopedSubscriptionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionClientScopedSubscription)(nil)).Elem()
}

func (i SubscriptionClientScopedSubscriptionArgs) ToSubscriptionClientScopedSubscriptionOutput() SubscriptionClientScopedSubscriptionOutput {
	return i.ToSubscriptionClientScopedSubscriptionOutputWithContext(context.Background())
}

func (i SubscriptionClientScopedSubscriptionArgs) ToSubscriptionClientScopedSubscriptionOutputWithContext(ctx context.Context) SubscriptionClientScopedSubscriptionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionClientScopedSubscriptionOutput)
}

func (i SubscriptionClientScopedSubscriptionArgs) ToSubscriptionClientScopedSubscriptionPtrOutput() SubscriptionClientScopedSubscriptionPtrOutput {
	return i.ToSubscriptionClientScopedSubscriptionPtrOutputWithContext(context.Background())
}

func (i SubscriptionClientScopedSubscriptionArgs) ToSubscriptionClientScopedSubscriptionPtrOutputWithContext(ctx context.Context) SubscriptionClientScopedSubscriptionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionClientScopedSubscriptionOutput).ToSubscriptionClientScopedSubscriptionPtrOutputWithContext(ctx)
}

// SubscriptionClientScopedSubscriptionPtrInput is an input type that accepts SubscriptionClientScopedSubscriptionArgs, SubscriptionClientScopedSubscriptionPtr and SubscriptionClientScopedSubscriptionPtrOutput values.
// You can construct a concrete instance of `SubscriptionClientScopedSubscriptionPtrInput` via:
//
//	        SubscriptionClientScopedSubscriptionArgs{...}
//
//	or:
//
//	        nil
type SubscriptionClientScopedSubscriptionPtrInput interface {
	pulumi.Input

	ToSubscriptionClientScopedSubscriptionPtrOutput() SubscriptionClientScopedSubscriptionPtrOutput
	ToSubscriptionClientScopedSubscriptionPtrOutputWithContext(context.Context) SubscriptionClientScopedSubscriptionPtrOutput
}

type subscriptionClientScopedSubscriptionPtrType SubscriptionClientScopedSubscriptionArgs

func SubscriptionClientScopedSubscriptionPtr(v *SubscriptionClientScopedSubscriptionArgs) SubscriptionClientScopedSubscriptionPtrInput {
	return (*subscriptionClientScopedSubscriptionPtrType)(v)
}

func (*subscriptionClientScopedSubscriptionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SubscriptionClientScopedSubscription)(nil)).Elem()
}

func (i *subscriptionClientScopedSubscriptionPtrType) ToSubscriptionClientScopedSubscriptionPtrOutput() SubscriptionClientScopedSubscriptionPtrOutput {
	return i.ToSubscriptionClientScopedSubscriptionPtrOutputWithContext(context.Background())
}

func (i *subscriptionClientScopedSubscriptionPtrType) ToSubscriptionClientScopedSubscriptionPtrOutputWithContext(ctx context.Context) SubscriptionClientScopedSubscriptionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionClientScopedSubscriptionPtrOutput)
}

type SubscriptionClientScopedSubscriptionOutput struct{ *pulumi.OutputState }

func (SubscriptionClientScopedSubscriptionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionClientScopedSubscription)(nil)).Elem()
}

func (o SubscriptionClientScopedSubscriptionOutput) ToSubscriptionClientScopedSubscriptionOutput() SubscriptionClientScopedSubscriptionOutput {
	return o
}

func (o SubscriptionClientScopedSubscriptionOutput) ToSubscriptionClientScopedSubscriptionOutputWithContext(ctx context.Context) SubscriptionClientScopedSubscriptionOutput {
	return o
}

func (o SubscriptionClientScopedSubscriptionOutput) ToSubscriptionClientScopedSubscriptionPtrOutput() SubscriptionClientScopedSubscriptionPtrOutput {
	return o.ToSubscriptionClientScopedSubscriptionPtrOutputWithContext(context.Background())
}

func (o SubscriptionClientScopedSubscriptionOutput) ToSubscriptionClientScopedSubscriptionPtrOutputWithContext(ctx context.Context) SubscriptionClientScopedSubscriptionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v SubscriptionClientScopedSubscription) *SubscriptionClientScopedSubscription {
		return &v
	}).(SubscriptionClientScopedSubscriptionPtrOutput)
}

// Specifies the Client ID of the application that created the client-scoped subscription. Changing this forces a new resource to be created.
//
// > **NOTE:** Client ID can be null or empty, but it must match the client ID set on the JMS client application. From the Azure Service Bus perspective, a null client ID and an empty client id have the same behavior. If the client ID is set to null or empty, it is only accessible to client applications whose client ID is also set to null or empty.
func (o SubscriptionClientScopedSubscriptionOutput) ClientId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionClientScopedSubscription) *string { return v.ClientId }).(pulumi.StringPtrOutput)
}

// Whether the client scoped subscription is durable. This property can only be controlled from the application side.
func (o SubscriptionClientScopedSubscriptionOutput) IsClientScopedSubscriptionDurable() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v SubscriptionClientScopedSubscription) *bool { return v.IsClientScopedSubscriptionDurable }).(pulumi.BoolPtrOutput)
}

// Whether the client scoped subscription is shareable. Defaults to `true` Changing this forces a new resource to be created.
func (o SubscriptionClientScopedSubscriptionOutput) IsClientScopedSubscriptionShareable() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v SubscriptionClientScopedSubscription) *bool { return v.IsClientScopedSubscriptionShareable }).(pulumi.BoolPtrOutput)
}

type SubscriptionClientScopedSubscriptionPtrOutput struct{ *pulumi.OutputState }

func (SubscriptionClientScopedSubscriptionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SubscriptionClientScopedSubscription)(nil)).Elem()
}

func (o SubscriptionClientScopedSubscriptionPtrOutput) ToSubscriptionClientScopedSubscriptionPtrOutput() SubscriptionClientScopedSubscriptionPtrOutput {
	return o
}

func (o SubscriptionClientScopedSubscriptionPtrOutput) ToSubscriptionClientScopedSubscriptionPtrOutputWithContext(ctx context.Context) SubscriptionClientScopedSubscriptionPtrOutput {
	return o
}

func (o SubscriptionClientScopedSubscriptionPtrOutput) Elem() SubscriptionClientScopedSubscriptionOutput {
	return o.ApplyT(func(v *SubscriptionClientScopedSubscription) SubscriptionClientScopedSubscription {
		if v != nil {
			return *v
		}
		var ret SubscriptionClientScopedSubscription
		return ret
	}).(SubscriptionClientScopedSubscriptionOutput)
}

// Specifies the Client ID of the application that created the client-scoped subscription. Changing this forces a new resource to be created.
//
// > **NOTE:** Client ID can be null or empty, but it must match the client ID set on the JMS client application. From the Azure Service Bus perspective, a null client ID and an empty client id have the same behavior. If the client ID is set to null or empty, it is only accessible to client applications whose client ID is also set to null or empty.
func (o SubscriptionClientScopedSubscriptionPtrOutput) ClientId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubscriptionClientScopedSubscription) *string {
		if v == nil {
			return nil
		}
		return v.ClientId
	}).(pulumi.StringPtrOutput)
}

// Whether the client scoped subscription is durable. This property can only be controlled from the application side.
func (o SubscriptionClientScopedSubscriptionPtrOutput) IsClientScopedSubscriptionDurable() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *SubscriptionClientScopedSubscription) *bool {
		if v == nil {
			return nil
		}
		return v.IsClientScopedSubscriptionDurable
	}).(pulumi.BoolPtrOutput)
}

// Whether the client scoped subscription is shareable. Defaults to `true` Changing this forces a new resource to be created.
func (o SubscriptionClientScopedSubscriptionPtrOutput) IsClientScopedSubscriptionShareable() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *SubscriptionClientScopedSubscription) *bool {
		if v == nil {
			return nil
		}
		return v.IsClientScopedSubscriptionShareable
	}).(pulumi.BoolPtrOutput)
}

type SubscriptionRuleCorrelationFilter struct {
	// Content type of the message.
	ContentType *string `pulumi:"contentType"`
	// Identifier of the correlation.
	CorrelationId *string `pulumi:"correlationId"`
	// Application specific label.
	Label *string `pulumi:"label"`
	// Identifier of the message.
	MessageId *string `pulumi:"messageId"`
	// A list of user defined properties to be included in the filter. Specified as a map of name/value pairs.
	//
	// > **NOTE:** When creating a subscription rule of type `CorrelationFilter` at least one property must be set in the `correlationFilter` block.
	Properties map[string]string `pulumi:"properties"`
	// Address of the queue to reply to.
	ReplyTo *string `pulumi:"replyTo"`
	// Session identifier to reply to.
	ReplyToSessionId *string `pulumi:"replyToSessionId"`
	// Session identifier.
	SessionId *string `pulumi:"sessionId"`
	// Address to send to.
	To *string `pulumi:"to"`
}

// SubscriptionRuleCorrelationFilterInput is an input type that accepts SubscriptionRuleCorrelationFilterArgs and SubscriptionRuleCorrelationFilterOutput values.
// You can construct a concrete instance of `SubscriptionRuleCorrelationFilterInput` via:
//
//	SubscriptionRuleCorrelationFilterArgs{...}
type SubscriptionRuleCorrelationFilterInput interface {
	pulumi.Input

	ToSubscriptionRuleCorrelationFilterOutput() SubscriptionRuleCorrelationFilterOutput
	ToSubscriptionRuleCorrelationFilterOutputWithContext(context.Context) SubscriptionRuleCorrelationFilterOutput
}

type SubscriptionRuleCorrelationFilterArgs struct {
	// Content type of the message.
	ContentType pulumi.StringPtrInput `pulumi:"contentType"`
	// Identifier of the correlation.
	CorrelationId pulumi.StringPtrInput `pulumi:"correlationId"`
	// Application specific label.
	Label pulumi.StringPtrInput `pulumi:"label"`
	// Identifier of the message.
	MessageId pulumi.StringPtrInput `pulumi:"messageId"`
	// A list of user defined properties to be included in the filter. Specified as a map of name/value pairs.
	//
	// > **NOTE:** When creating a subscription rule of type `CorrelationFilter` at least one property must be set in the `correlationFilter` block.
	Properties pulumi.StringMapInput `pulumi:"properties"`
	// Address of the queue to reply to.
	ReplyTo pulumi.StringPtrInput `pulumi:"replyTo"`
	// Session identifier to reply to.
	ReplyToSessionId pulumi.StringPtrInput `pulumi:"replyToSessionId"`
	// Session identifier.
	SessionId pulumi.StringPtrInput `pulumi:"sessionId"`
	// Address to send to.
	To pulumi.StringPtrInput `pulumi:"to"`
}

func (SubscriptionRuleCorrelationFilterArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionRuleCorrelationFilter)(nil)).Elem()
}

func (i SubscriptionRuleCorrelationFilterArgs) ToSubscriptionRuleCorrelationFilterOutput() SubscriptionRuleCorrelationFilterOutput {
	return i.ToSubscriptionRuleCorrelationFilterOutputWithContext(context.Background())
}

func (i SubscriptionRuleCorrelationFilterArgs) ToSubscriptionRuleCorrelationFilterOutputWithContext(ctx context.Context) SubscriptionRuleCorrelationFilterOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionRuleCorrelationFilterOutput)
}

func (i SubscriptionRuleCorrelationFilterArgs) ToSubscriptionRuleCorrelationFilterPtrOutput() SubscriptionRuleCorrelationFilterPtrOutput {
	return i.ToSubscriptionRuleCorrelationFilterPtrOutputWithContext(context.Background())
}

func (i SubscriptionRuleCorrelationFilterArgs) ToSubscriptionRuleCorrelationFilterPtrOutputWithContext(ctx context.Context) SubscriptionRuleCorrelationFilterPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionRuleCorrelationFilterOutput).ToSubscriptionRuleCorrelationFilterPtrOutputWithContext(ctx)
}

// SubscriptionRuleCorrelationFilterPtrInput is an input type that accepts SubscriptionRuleCorrelationFilterArgs, SubscriptionRuleCorrelationFilterPtr and SubscriptionRuleCorrelationFilterPtrOutput values.
// You can construct a concrete instance of `SubscriptionRuleCorrelationFilterPtrInput` via:
//
//	        SubscriptionRuleCorrelationFilterArgs{...}
//
//	or:
//
//	        nil
type SubscriptionRuleCorrelationFilterPtrInput interface {
	pulumi.Input

	ToSubscriptionRuleCorrelationFilterPtrOutput() SubscriptionRuleCorrelationFilterPtrOutput
	ToSubscriptionRuleCorrelationFilterPtrOutputWithContext(context.Context) SubscriptionRuleCorrelationFilterPtrOutput
}

type subscriptionRuleCorrelationFilterPtrType SubscriptionRuleCorrelationFilterArgs

func SubscriptionRuleCorrelationFilterPtr(v *SubscriptionRuleCorrelationFilterArgs) SubscriptionRuleCorrelationFilterPtrInput {
	return (*subscriptionRuleCorrelationFilterPtrType)(v)
}

func (*subscriptionRuleCorrelationFilterPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SubscriptionRuleCorrelationFilter)(nil)).Elem()
}

func (i *subscriptionRuleCorrelationFilterPtrType) ToSubscriptionRuleCorrelationFilterPtrOutput() SubscriptionRuleCorrelationFilterPtrOutput {
	return i.ToSubscriptionRuleCorrelationFilterPtrOutputWithContext(context.Background())
}

func (i *subscriptionRuleCorrelationFilterPtrType) ToSubscriptionRuleCorrelationFilterPtrOutputWithContext(ctx context.Context) SubscriptionRuleCorrelationFilterPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionRuleCorrelationFilterPtrOutput)
}

type SubscriptionRuleCorrelationFilterOutput struct{ *pulumi.OutputState }

func (SubscriptionRuleCorrelationFilterOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionRuleCorrelationFilter)(nil)).Elem()
}

func (o SubscriptionRuleCorrelationFilterOutput) ToSubscriptionRuleCorrelationFilterOutput() SubscriptionRuleCorrelationFilterOutput {
	return o
}

func (o SubscriptionRuleCorrelationFilterOutput) ToSubscriptionRuleCorrelationFilterOutputWithContext(ctx context.Context) SubscriptionRuleCorrelationFilterOutput {
	return o
}

func (o SubscriptionRuleCorrelationFilterOutput) ToSubscriptionRuleCorrelationFilterPtrOutput() SubscriptionRuleCorrelationFilterPtrOutput {
	return o.ToSubscriptionRuleCorrelationFilterPtrOutputWithContext(context.Background())
}

func (o SubscriptionRuleCorrelationFilterOutput) ToSubscriptionRuleCorrelationFilterPtrOutputWithContext(ctx context.Context) SubscriptionRuleCorrelationFilterPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v SubscriptionRuleCorrelationFilter) *SubscriptionRuleCorrelationFilter {
		return &v
	}).(SubscriptionRuleCorrelationFilterPtrOutput)
}

// Content type of the message.
func (o SubscriptionRuleCorrelationFilterOutput) ContentType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionRuleCorrelationFilter) *string { return v.ContentType }).(pulumi.StringPtrOutput)
}

// Identifier of the correlation.
func (o SubscriptionRuleCorrelationFilterOutput) CorrelationId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionRuleCorrelationFilter) *string { return v.CorrelationId }).(pulumi.StringPtrOutput)
}

// Application specific label.
func (o SubscriptionRuleCorrelationFilterOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionRuleCorrelationFilter) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// Identifier of the message.
func (o SubscriptionRuleCorrelationFilterOutput) MessageId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionRuleCorrelationFilter) *string { return v.MessageId }).(pulumi.StringPtrOutput)
}

// A list of user defined properties to be included in the filter. Specified as a map of name/value pairs.
//
// > **NOTE:** When creating a subscription rule of type `CorrelationFilter` at least one property must be set in the `correlationFilter` block.
func (o SubscriptionRuleCorrelationFilterOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v SubscriptionRuleCorrelationFilter) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Address of the queue to reply to.
func (o SubscriptionRuleCorrelationFilterOutput) ReplyTo() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionRuleCorrelationFilter) *string { return v.ReplyTo }).(pulumi.StringPtrOutput)
}

// Session identifier to reply to.
func (o SubscriptionRuleCorrelationFilterOutput) ReplyToSessionId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionRuleCorrelationFilter) *string { return v.ReplyToSessionId }).(pulumi.StringPtrOutput)
}

// Session identifier.
func (o SubscriptionRuleCorrelationFilterOutput) SessionId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionRuleCorrelationFilter) *string { return v.SessionId }).(pulumi.StringPtrOutput)
}

// Address to send to.
func (o SubscriptionRuleCorrelationFilterOutput) To() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionRuleCorrelationFilter) *string { return v.To }).(pulumi.StringPtrOutput)
}

type SubscriptionRuleCorrelationFilterPtrOutput struct{ *pulumi.OutputState }

func (SubscriptionRuleCorrelationFilterPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SubscriptionRuleCorrelationFilter)(nil)).Elem()
}

func (o SubscriptionRuleCorrelationFilterPtrOutput) ToSubscriptionRuleCorrelationFilterPtrOutput() SubscriptionRuleCorrelationFilterPtrOutput {
	return o
}

func (o SubscriptionRuleCorrelationFilterPtrOutput) ToSubscriptionRuleCorrelationFilterPtrOutputWithContext(ctx context.Context) SubscriptionRuleCorrelationFilterPtrOutput {
	return o
}

func (o SubscriptionRuleCorrelationFilterPtrOutput) Elem() SubscriptionRuleCorrelationFilterOutput {
	return o.ApplyT(func(v *SubscriptionRuleCorrelationFilter) SubscriptionRuleCorrelationFilter {
		if v != nil {
			return *v
		}
		var ret SubscriptionRuleCorrelationFilter
		return ret
	}).(SubscriptionRuleCorrelationFilterOutput)
}

// Content type of the message.
func (o SubscriptionRuleCorrelationFilterPtrOutput) ContentType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubscriptionRuleCorrelationFilter) *string {
		if v == nil {
			return nil
		}
		return v.ContentType
	}).(pulumi.StringPtrOutput)
}

// Identifier of the correlation.
func (o SubscriptionRuleCorrelationFilterPtrOutput) CorrelationId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubscriptionRuleCorrelationFilter) *string {
		if v == nil {
			return nil
		}
		return v.CorrelationId
	}).(pulumi.StringPtrOutput)
}

// Application specific label.
func (o SubscriptionRuleCorrelationFilterPtrOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubscriptionRuleCorrelationFilter) *string {
		if v == nil {
			return nil
		}
		return v.Label
	}).(pulumi.StringPtrOutput)
}

// Identifier of the message.
func (o SubscriptionRuleCorrelationFilterPtrOutput) MessageId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubscriptionRuleCorrelationFilter) *string {
		if v == nil {
			return nil
		}
		return v.MessageId
	}).(pulumi.StringPtrOutput)
}

// A list of user defined properties to be included in the filter. Specified as a map of name/value pairs.
//
// > **NOTE:** When creating a subscription rule of type `CorrelationFilter` at least one property must be set in the `correlationFilter` block.
func (o SubscriptionRuleCorrelationFilterPtrOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v *SubscriptionRuleCorrelationFilter) map[string]string {
		if v == nil {
			return nil
		}
		return v.Properties
	}).(pulumi.StringMapOutput)
}

// Address of the queue to reply to.
func (o SubscriptionRuleCorrelationFilterPtrOutput) ReplyTo() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubscriptionRuleCorrelationFilter) *string {
		if v == nil {
			return nil
		}
		return v.ReplyTo
	}).(pulumi.StringPtrOutput)
}

// Session identifier to reply to.
func (o SubscriptionRuleCorrelationFilterPtrOutput) ReplyToSessionId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubscriptionRuleCorrelationFilter) *string {
		if v == nil {
			return nil
		}
		return v.ReplyToSessionId
	}).(pulumi.StringPtrOutput)
}

// Session identifier.
func (o SubscriptionRuleCorrelationFilterPtrOutput) SessionId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubscriptionRuleCorrelationFilter) *string {
		if v == nil {
			return nil
		}
		return v.SessionId
	}).(pulumi.StringPtrOutput)
}

// Address to send to.
func (o SubscriptionRuleCorrelationFilterPtrOutput) To() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubscriptionRuleCorrelationFilter) *string {
		if v == nil {
			return nil
		}
		return v.To
	}).(pulumi.StringPtrOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*NamespaceCustomerManagedKeyTypeInput)(nil)).Elem(), NamespaceCustomerManagedKeyTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NamespaceCustomerManagedKeyTypePtrInput)(nil)).Elem(), NamespaceCustomerManagedKeyTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NamespaceIdentityInput)(nil)).Elem(), NamespaceIdentityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NamespaceIdentityPtrInput)(nil)).Elem(), NamespaceIdentityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NamespaceNetworkRuleSetInput)(nil)).Elem(), NamespaceNetworkRuleSetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NamespaceNetworkRuleSetPtrInput)(nil)).Elem(), NamespaceNetworkRuleSetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NamespaceNetworkRuleSetNetworkRuleInput)(nil)).Elem(), NamespaceNetworkRuleSetNetworkRuleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NamespaceNetworkRuleSetNetworkRuleArrayInput)(nil)).Elem(), NamespaceNetworkRuleSetNetworkRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SubscriptionClientScopedSubscriptionInput)(nil)).Elem(), SubscriptionClientScopedSubscriptionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SubscriptionClientScopedSubscriptionPtrInput)(nil)).Elem(), SubscriptionClientScopedSubscriptionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SubscriptionRuleCorrelationFilterInput)(nil)).Elem(), SubscriptionRuleCorrelationFilterArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SubscriptionRuleCorrelationFilterPtrInput)(nil)).Elem(), SubscriptionRuleCorrelationFilterArgs{})
	pulumi.RegisterOutputType(NamespaceCustomerManagedKeyTypeOutput{})
	pulumi.RegisterOutputType(NamespaceCustomerManagedKeyTypePtrOutput{})
	pulumi.RegisterOutputType(NamespaceIdentityOutput{})
	pulumi.RegisterOutputType(NamespaceIdentityPtrOutput{})
	pulumi.RegisterOutputType(NamespaceNetworkRuleSetOutput{})
	pulumi.RegisterOutputType(NamespaceNetworkRuleSetPtrOutput{})
	pulumi.RegisterOutputType(NamespaceNetworkRuleSetNetworkRuleOutput{})
	pulumi.RegisterOutputType(NamespaceNetworkRuleSetNetworkRuleArrayOutput{})
	pulumi.RegisterOutputType(SubscriptionClientScopedSubscriptionOutput{})
	pulumi.RegisterOutputType(SubscriptionClientScopedSubscriptionPtrOutput{})
	pulumi.RegisterOutputType(SubscriptionRuleCorrelationFilterOutput{})
	pulumi.RegisterOutputType(SubscriptionRuleCorrelationFilterPtrOutput{})
}
