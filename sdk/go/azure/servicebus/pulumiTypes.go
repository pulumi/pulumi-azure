// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package servicebus

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-azure/sdk/v5/go/azure/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
)

var _ = internal.GetEnvOrDefault

type NamespaceCustomerManagedKey struct {
	// The ID of the User Assigned Identity that has access to the key.
	IdentityId string `pulumi:"identityId"`
	// Used to specify whether enable Infrastructure Encryption (Double Encryption). Changing this forces a new resource to be created.
	InfrastructureEncryptionEnabled *bool `pulumi:"infrastructureEncryptionEnabled"`
	// The ID of the Key Vault Key which should be used to Encrypt the data in this ServiceBus Namespace.
	KeyVaultKeyId string `pulumi:"keyVaultKeyId"`
}

// NamespaceCustomerManagedKeyInput is an input type that accepts NamespaceCustomerManagedKeyArgs and NamespaceCustomerManagedKeyOutput values.
// You can construct a concrete instance of `NamespaceCustomerManagedKeyInput` via:
//
//	NamespaceCustomerManagedKeyArgs{...}
type NamespaceCustomerManagedKeyInput interface {
	pulumi.Input

	ToNamespaceCustomerManagedKeyOutput() NamespaceCustomerManagedKeyOutput
	ToNamespaceCustomerManagedKeyOutputWithContext(context.Context) NamespaceCustomerManagedKeyOutput
}

type NamespaceCustomerManagedKeyArgs struct {
	// The ID of the User Assigned Identity that has access to the key.
	IdentityId pulumi.StringInput `pulumi:"identityId"`
	// Used to specify whether enable Infrastructure Encryption (Double Encryption). Changing this forces a new resource to be created.
	InfrastructureEncryptionEnabled pulumi.BoolPtrInput `pulumi:"infrastructureEncryptionEnabled"`
	// The ID of the Key Vault Key which should be used to Encrypt the data in this ServiceBus Namespace.
	KeyVaultKeyId pulumi.StringInput `pulumi:"keyVaultKeyId"`
}

func (NamespaceCustomerManagedKeyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NamespaceCustomerManagedKey)(nil)).Elem()
}

func (i NamespaceCustomerManagedKeyArgs) ToNamespaceCustomerManagedKeyOutput() NamespaceCustomerManagedKeyOutput {
	return i.ToNamespaceCustomerManagedKeyOutputWithContext(context.Background())
}

func (i NamespaceCustomerManagedKeyArgs) ToNamespaceCustomerManagedKeyOutputWithContext(ctx context.Context) NamespaceCustomerManagedKeyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceCustomerManagedKeyOutput)
}

func (i NamespaceCustomerManagedKeyArgs) ToOutput(ctx context.Context) pulumix.Output[NamespaceCustomerManagedKey] {
	return pulumix.Output[NamespaceCustomerManagedKey]{
		OutputState: i.ToNamespaceCustomerManagedKeyOutputWithContext(ctx).OutputState,
	}
}

func (i NamespaceCustomerManagedKeyArgs) ToNamespaceCustomerManagedKeyPtrOutput() NamespaceCustomerManagedKeyPtrOutput {
	return i.ToNamespaceCustomerManagedKeyPtrOutputWithContext(context.Background())
}

func (i NamespaceCustomerManagedKeyArgs) ToNamespaceCustomerManagedKeyPtrOutputWithContext(ctx context.Context) NamespaceCustomerManagedKeyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceCustomerManagedKeyOutput).ToNamespaceCustomerManagedKeyPtrOutputWithContext(ctx)
}

// NamespaceCustomerManagedKeyPtrInput is an input type that accepts NamespaceCustomerManagedKeyArgs, NamespaceCustomerManagedKeyPtr and NamespaceCustomerManagedKeyPtrOutput values.
// You can construct a concrete instance of `NamespaceCustomerManagedKeyPtrInput` via:
//
//	        NamespaceCustomerManagedKeyArgs{...}
//
//	or:
//
//	        nil
type NamespaceCustomerManagedKeyPtrInput interface {
	pulumi.Input

	ToNamespaceCustomerManagedKeyPtrOutput() NamespaceCustomerManagedKeyPtrOutput
	ToNamespaceCustomerManagedKeyPtrOutputWithContext(context.Context) NamespaceCustomerManagedKeyPtrOutput
}

type namespaceCustomerManagedKeyPtrType NamespaceCustomerManagedKeyArgs

func NamespaceCustomerManagedKeyPtr(v *NamespaceCustomerManagedKeyArgs) NamespaceCustomerManagedKeyPtrInput {
	return (*namespaceCustomerManagedKeyPtrType)(v)
}

func (*namespaceCustomerManagedKeyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**NamespaceCustomerManagedKey)(nil)).Elem()
}

func (i *namespaceCustomerManagedKeyPtrType) ToNamespaceCustomerManagedKeyPtrOutput() NamespaceCustomerManagedKeyPtrOutput {
	return i.ToNamespaceCustomerManagedKeyPtrOutputWithContext(context.Background())
}

func (i *namespaceCustomerManagedKeyPtrType) ToNamespaceCustomerManagedKeyPtrOutputWithContext(ctx context.Context) NamespaceCustomerManagedKeyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceCustomerManagedKeyPtrOutput)
}

func (i *namespaceCustomerManagedKeyPtrType) ToOutput(ctx context.Context) pulumix.Output[*NamespaceCustomerManagedKey] {
	return pulumix.Output[*NamespaceCustomerManagedKey]{
		OutputState: i.ToNamespaceCustomerManagedKeyPtrOutputWithContext(ctx).OutputState,
	}
}

type NamespaceCustomerManagedKeyOutput struct{ *pulumi.OutputState }

func (NamespaceCustomerManagedKeyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NamespaceCustomerManagedKey)(nil)).Elem()
}

func (o NamespaceCustomerManagedKeyOutput) ToNamespaceCustomerManagedKeyOutput() NamespaceCustomerManagedKeyOutput {
	return o
}

func (o NamespaceCustomerManagedKeyOutput) ToNamespaceCustomerManagedKeyOutputWithContext(ctx context.Context) NamespaceCustomerManagedKeyOutput {
	return o
}

func (o NamespaceCustomerManagedKeyOutput) ToNamespaceCustomerManagedKeyPtrOutput() NamespaceCustomerManagedKeyPtrOutput {
	return o.ToNamespaceCustomerManagedKeyPtrOutputWithContext(context.Background())
}

func (o NamespaceCustomerManagedKeyOutput) ToNamespaceCustomerManagedKeyPtrOutputWithContext(ctx context.Context) NamespaceCustomerManagedKeyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v NamespaceCustomerManagedKey) *NamespaceCustomerManagedKey {
		return &v
	}).(NamespaceCustomerManagedKeyPtrOutput)
}

func (o NamespaceCustomerManagedKeyOutput) ToOutput(ctx context.Context) pulumix.Output[NamespaceCustomerManagedKey] {
	return pulumix.Output[NamespaceCustomerManagedKey]{
		OutputState: o.OutputState,
	}
}

// The ID of the User Assigned Identity that has access to the key.
func (o NamespaceCustomerManagedKeyOutput) IdentityId() pulumi.StringOutput {
	return o.ApplyT(func(v NamespaceCustomerManagedKey) string { return v.IdentityId }).(pulumi.StringOutput)
}

// Used to specify whether enable Infrastructure Encryption (Double Encryption). Changing this forces a new resource to be created.
func (o NamespaceCustomerManagedKeyOutput) InfrastructureEncryptionEnabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v NamespaceCustomerManagedKey) *bool { return v.InfrastructureEncryptionEnabled }).(pulumi.BoolPtrOutput)
}

// The ID of the Key Vault Key which should be used to Encrypt the data in this ServiceBus Namespace.
func (o NamespaceCustomerManagedKeyOutput) KeyVaultKeyId() pulumi.StringOutput {
	return o.ApplyT(func(v NamespaceCustomerManagedKey) string { return v.KeyVaultKeyId }).(pulumi.StringOutput)
}

type NamespaceCustomerManagedKeyPtrOutput struct{ *pulumi.OutputState }

func (NamespaceCustomerManagedKeyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NamespaceCustomerManagedKey)(nil)).Elem()
}

func (o NamespaceCustomerManagedKeyPtrOutput) ToNamespaceCustomerManagedKeyPtrOutput() NamespaceCustomerManagedKeyPtrOutput {
	return o
}

func (o NamespaceCustomerManagedKeyPtrOutput) ToNamespaceCustomerManagedKeyPtrOutputWithContext(ctx context.Context) NamespaceCustomerManagedKeyPtrOutput {
	return o
}

func (o NamespaceCustomerManagedKeyPtrOutput) ToOutput(ctx context.Context) pulumix.Output[*NamespaceCustomerManagedKey] {
	return pulumix.Output[*NamespaceCustomerManagedKey]{
		OutputState: o.OutputState,
	}
}

func (o NamespaceCustomerManagedKeyPtrOutput) Elem() NamespaceCustomerManagedKeyOutput {
	return o.ApplyT(func(v *NamespaceCustomerManagedKey) NamespaceCustomerManagedKey {
		if v != nil {
			return *v
		}
		var ret NamespaceCustomerManagedKey
		return ret
	}).(NamespaceCustomerManagedKeyOutput)
}

// The ID of the User Assigned Identity that has access to the key.
func (o NamespaceCustomerManagedKeyPtrOutput) IdentityId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NamespaceCustomerManagedKey) *string {
		if v == nil {
			return nil
		}
		return &v.IdentityId
	}).(pulumi.StringPtrOutput)
}

// Used to specify whether enable Infrastructure Encryption (Double Encryption). Changing this forces a new resource to be created.
func (o NamespaceCustomerManagedKeyPtrOutput) InfrastructureEncryptionEnabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *NamespaceCustomerManagedKey) *bool {
		if v == nil {
			return nil
		}
		return v.InfrastructureEncryptionEnabled
	}).(pulumi.BoolPtrOutput)
}

// The ID of the Key Vault Key which should be used to Encrypt the data in this ServiceBus Namespace.
func (o NamespaceCustomerManagedKeyPtrOutput) KeyVaultKeyId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NamespaceCustomerManagedKey) *string {
		if v == nil {
			return nil
		}
		return &v.KeyVaultKeyId
	}).(pulumi.StringPtrOutput)
}

type NamespaceIdentity struct {
	// Specifies a list of User Assigned Managed Identity IDs to be assigned to this ServiceBus namespace.
	//
	// > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
	IdentityIds []string `pulumi:"identityIds"`
	// The Principal ID for the Service Principal associated with the Managed Service Identity of this ServiceBus Namespace.
	PrincipalId *string `pulumi:"principalId"`
	// The Tenant ID for the Service Principal associated with the Managed Service Identity of this ServiceBus Namespace.
	TenantId *string `pulumi:"tenantId"`
	// Specifies the type of Managed Service Identity that should be configured on this ServiceBus Namespace. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
	Type string `pulumi:"type"`
}

// NamespaceIdentityInput is an input type that accepts NamespaceIdentityArgs and NamespaceIdentityOutput values.
// You can construct a concrete instance of `NamespaceIdentityInput` via:
//
//	NamespaceIdentityArgs{...}
type NamespaceIdentityInput interface {
	pulumi.Input

	ToNamespaceIdentityOutput() NamespaceIdentityOutput
	ToNamespaceIdentityOutputWithContext(context.Context) NamespaceIdentityOutput
}

type NamespaceIdentityArgs struct {
	// Specifies a list of User Assigned Managed Identity IDs to be assigned to this ServiceBus namespace.
	//
	// > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
	IdentityIds pulumi.StringArrayInput `pulumi:"identityIds"`
	// The Principal ID for the Service Principal associated with the Managed Service Identity of this ServiceBus Namespace.
	PrincipalId pulumi.StringPtrInput `pulumi:"principalId"`
	// The Tenant ID for the Service Principal associated with the Managed Service Identity of this ServiceBus Namespace.
	TenantId pulumi.StringPtrInput `pulumi:"tenantId"`
	// Specifies the type of Managed Service Identity that should be configured on this ServiceBus Namespace. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
	Type pulumi.StringInput `pulumi:"type"`
}

func (NamespaceIdentityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NamespaceIdentity)(nil)).Elem()
}

func (i NamespaceIdentityArgs) ToNamespaceIdentityOutput() NamespaceIdentityOutput {
	return i.ToNamespaceIdentityOutputWithContext(context.Background())
}

func (i NamespaceIdentityArgs) ToNamespaceIdentityOutputWithContext(ctx context.Context) NamespaceIdentityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceIdentityOutput)
}

func (i NamespaceIdentityArgs) ToOutput(ctx context.Context) pulumix.Output[NamespaceIdentity] {
	return pulumix.Output[NamespaceIdentity]{
		OutputState: i.ToNamespaceIdentityOutputWithContext(ctx).OutputState,
	}
}

func (i NamespaceIdentityArgs) ToNamespaceIdentityPtrOutput() NamespaceIdentityPtrOutput {
	return i.ToNamespaceIdentityPtrOutputWithContext(context.Background())
}

func (i NamespaceIdentityArgs) ToNamespaceIdentityPtrOutputWithContext(ctx context.Context) NamespaceIdentityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceIdentityOutput).ToNamespaceIdentityPtrOutputWithContext(ctx)
}

// NamespaceIdentityPtrInput is an input type that accepts NamespaceIdentityArgs, NamespaceIdentityPtr and NamespaceIdentityPtrOutput values.
// You can construct a concrete instance of `NamespaceIdentityPtrInput` via:
//
//	        NamespaceIdentityArgs{...}
//
//	or:
//
//	        nil
type NamespaceIdentityPtrInput interface {
	pulumi.Input

	ToNamespaceIdentityPtrOutput() NamespaceIdentityPtrOutput
	ToNamespaceIdentityPtrOutputWithContext(context.Context) NamespaceIdentityPtrOutput
}

type namespaceIdentityPtrType NamespaceIdentityArgs

func NamespaceIdentityPtr(v *NamespaceIdentityArgs) NamespaceIdentityPtrInput {
	return (*namespaceIdentityPtrType)(v)
}

func (*namespaceIdentityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**NamespaceIdentity)(nil)).Elem()
}

func (i *namespaceIdentityPtrType) ToNamespaceIdentityPtrOutput() NamespaceIdentityPtrOutput {
	return i.ToNamespaceIdentityPtrOutputWithContext(context.Background())
}

func (i *namespaceIdentityPtrType) ToNamespaceIdentityPtrOutputWithContext(ctx context.Context) NamespaceIdentityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceIdentityPtrOutput)
}

func (i *namespaceIdentityPtrType) ToOutput(ctx context.Context) pulumix.Output[*NamespaceIdentity] {
	return pulumix.Output[*NamespaceIdentity]{
		OutputState: i.ToNamespaceIdentityPtrOutputWithContext(ctx).OutputState,
	}
}

type NamespaceIdentityOutput struct{ *pulumi.OutputState }

func (NamespaceIdentityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NamespaceIdentity)(nil)).Elem()
}

func (o NamespaceIdentityOutput) ToNamespaceIdentityOutput() NamespaceIdentityOutput {
	return o
}

func (o NamespaceIdentityOutput) ToNamespaceIdentityOutputWithContext(ctx context.Context) NamespaceIdentityOutput {
	return o
}

func (o NamespaceIdentityOutput) ToNamespaceIdentityPtrOutput() NamespaceIdentityPtrOutput {
	return o.ToNamespaceIdentityPtrOutputWithContext(context.Background())
}

func (o NamespaceIdentityOutput) ToNamespaceIdentityPtrOutputWithContext(ctx context.Context) NamespaceIdentityPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v NamespaceIdentity) *NamespaceIdentity {
		return &v
	}).(NamespaceIdentityPtrOutput)
}

func (o NamespaceIdentityOutput) ToOutput(ctx context.Context) pulumix.Output[NamespaceIdentity] {
	return pulumix.Output[NamespaceIdentity]{
		OutputState: o.OutputState,
	}
}

// Specifies a list of User Assigned Managed Identity IDs to be assigned to this ServiceBus namespace.
//
// > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
func (o NamespaceIdentityOutput) IdentityIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NamespaceIdentity) []string { return v.IdentityIds }).(pulumi.StringArrayOutput)
}

// The Principal ID for the Service Principal associated with the Managed Service Identity of this ServiceBus Namespace.
func (o NamespaceIdentityOutput) PrincipalId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NamespaceIdentity) *string { return v.PrincipalId }).(pulumi.StringPtrOutput)
}

// The Tenant ID for the Service Principal associated with the Managed Service Identity of this ServiceBus Namespace.
func (o NamespaceIdentityOutput) TenantId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NamespaceIdentity) *string { return v.TenantId }).(pulumi.StringPtrOutput)
}

// Specifies the type of Managed Service Identity that should be configured on this ServiceBus Namespace. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
func (o NamespaceIdentityOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v NamespaceIdentity) string { return v.Type }).(pulumi.StringOutput)
}

type NamespaceIdentityPtrOutput struct{ *pulumi.OutputState }

func (NamespaceIdentityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NamespaceIdentity)(nil)).Elem()
}

func (o NamespaceIdentityPtrOutput) ToNamespaceIdentityPtrOutput() NamespaceIdentityPtrOutput {
	return o
}

func (o NamespaceIdentityPtrOutput) ToNamespaceIdentityPtrOutputWithContext(ctx context.Context) NamespaceIdentityPtrOutput {
	return o
}

func (o NamespaceIdentityPtrOutput) ToOutput(ctx context.Context) pulumix.Output[*NamespaceIdentity] {
	return pulumix.Output[*NamespaceIdentity]{
		OutputState: o.OutputState,
	}
}

func (o NamespaceIdentityPtrOutput) Elem() NamespaceIdentityOutput {
	return o.ApplyT(func(v *NamespaceIdentity) NamespaceIdentity {
		if v != nil {
			return *v
		}
		var ret NamespaceIdentity
		return ret
	}).(NamespaceIdentityOutput)
}

// Specifies a list of User Assigned Managed Identity IDs to be assigned to this ServiceBus namespace.
//
// > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
func (o NamespaceIdentityPtrOutput) IdentityIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *NamespaceIdentity) []string {
		if v == nil {
			return nil
		}
		return v.IdentityIds
	}).(pulumi.StringArrayOutput)
}

// The Principal ID for the Service Principal associated with the Managed Service Identity of this ServiceBus Namespace.
func (o NamespaceIdentityPtrOutput) PrincipalId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NamespaceIdentity) *string {
		if v == nil {
			return nil
		}
		return v.PrincipalId
	}).(pulumi.StringPtrOutput)
}

// The Tenant ID for the Service Principal associated with the Managed Service Identity of this ServiceBus Namespace.
func (o NamespaceIdentityPtrOutput) TenantId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NamespaceIdentity) *string {
		if v == nil {
			return nil
		}
		return v.TenantId
	}).(pulumi.StringPtrOutput)
}

// Specifies the type of Managed Service Identity that should be configured on this ServiceBus Namespace. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
func (o NamespaceIdentityPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NamespaceIdentity) *string {
		if v == nil {
			return nil
		}
		return &v.Type
	}).(pulumi.StringPtrOutput)
}

type NamespaceNetworkRuleSetType struct {
	// Specifies the default action for the Network Rule Set. Possible values are `Allow` and `Deny`. Defaults to `Allow`.
	DefaultAction *string `pulumi:"defaultAction"`
	// One or more IP Addresses, or CIDR Blocks which should be able to access the ServiceBus Namespace.
	IpRules []string `pulumi:"ipRules"`
	// One or more `networkRules` blocks as defined below.
	NetworkRules []NamespaceNetworkRuleSetNetworkRule `pulumi:"networkRules"`
	// Whether to allow traffic over public network. Possible values are `true` and `false`. Defaults to `true`.
	PublicNetworkAccessEnabled *bool `pulumi:"publicNetworkAccessEnabled"`
	// Are Azure Services that are known and trusted for this resource type are allowed to bypass firewall configuration? See [Trusted Microsoft Services](https://github.com/MicrosoftDocs/azure-docs/blob/master/articles/service-bus-messaging/includes/service-bus-trusted-services.md)
	TrustedServicesAllowed *bool `pulumi:"trustedServicesAllowed"`
}

// NamespaceNetworkRuleSetTypeInput is an input type that accepts NamespaceNetworkRuleSetTypeArgs and NamespaceNetworkRuleSetTypeOutput values.
// You can construct a concrete instance of `NamespaceNetworkRuleSetTypeInput` via:
//
//	NamespaceNetworkRuleSetTypeArgs{...}
type NamespaceNetworkRuleSetTypeInput interface {
	pulumi.Input

	ToNamespaceNetworkRuleSetTypeOutput() NamespaceNetworkRuleSetTypeOutput
	ToNamespaceNetworkRuleSetTypeOutputWithContext(context.Context) NamespaceNetworkRuleSetTypeOutput
}

type NamespaceNetworkRuleSetTypeArgs struct {
	// Specifies the default action for the Network Rule Set. Possible values are `Allow` and `Deny`. Defaults to `Allow`.
	DefaultAction pulumi.StringPtrInput `pulumi:"defaultAction"`
	// One or more IP Addresses, or CIDR Blocks which should be able to access the ServiceBus Namespace.
	IpRules pulumi.StringArrayInput `pulumi:"ipRules"`
	// One or more `networkRules` blocks as defined below.
	NetworkRules NamespaceNetworkRuleSetNetworkRuleArrayInput `pulumi:"networkRules"`
	// Whether to allow traffic over public network. Possible values are `true` and `false`. Defaults to `true`.
	PublicNetworkAccessEnabled pulumi.BoolPtrInput `pulumi:"publicNetworkAccessEnabled"`
	// Are Azure Services that are known and trusted for this resource type are allowed to bypass firewall configuration? See [Trusted Microsoft Services](https://github.com/MicrosoftDocs/azure-docs/blob/master/articles/service-bus-messaging/includes/service-bus-trusted-services.md)
	TrustedServicesAllowed pulumi.BoolPtrInput `pulumi:"trustedServicesAllowed"`
}

func (NamespaceNetworkRuleSetTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NamespaceNetworkRuleSetType)(nil)).Elem()
}

func (i NamespaceNetworkRuleSetTypeArgs) ToNamespaceNetworkRuleSetTypeOutput() NamespaceNetworkRuleSetTypeOutput {
	return i.ToNamespaceNetworkRuleSetTypeOutputWithContext(context.Background())
}

func (i NamespaceNetworkRuleSetTypeArgs) ToNamespaceNetworkRuleSetTypeOutputWithContext(ctx context.Context) NamespaceNetworkRuleSetTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceNetworkRuleSetTypeOutput)
}

func (i NamespaceNetworkRuleSetTypeArgs) ToOutput(ctx context.Context) pulumix.Output[NamespaceNetworkRuleSetType] {
	return pulumix.Output[NamespaceNetworkRuleSetType]{
		OutputState: i.ToNamespaceNetworkRuleSetTypeOutputWithContext(ctx).OutputState,
	}
}

func (i NamespaceNetworkRuleSetTypeArgs) ToNamespaceNetworkRuleSetTypePtrOutput() NamespaceNetworkRuleSetTypePtrOutput {
	return i.ToNamespaceNetworkRuleSetTypePtrOutputWithContext(context.Background())
}

func (i NamespaceNetworkRuleSetTypeArgs) ToNamespaceNetworkRuleSetTypePtrOutputWithContext(ctx context.Context) NamespaceNetworkRuleSetTypePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceNetworkRuleSetTypeOutput).ToNamespaceNetworkRuleSetTypePtrOutputWithContext(ctx)
}

// NamespaceNetworkRuleSetTypePtrInput is an input type that accepts NamespaceNetworkRuleSetTypeArgs, NamespaceNetworkRuleSetTypePtr and NamespaceNetworkRuleSetTypePtrOutput values.
// You can construct a concrete instance of `NamespaceNetworkRuleSetTypePtrInput` via:
//
//	        NamespaceNetworkRuleSetTypeArgs{...}
//
//	or:
//
//	        nil
type NamespaceNetworkRuleSetTypePtrInput interface {
	pulumi.Input

	ToNamespaceNetworkRuleSetTypePtrOutput() NamespaceNetworkRuleSetTypePtrOutput
	ToNamespaceNetworkRuleSetTypePtrOutputWithContext(context.Context) NamespaceNetworkRuleSetTypePtrOutput
}

type namespaceNetworkRuleSetTypePtrType NamespaceNetworkRuleSetTypeArgs

func NamespaceNetworkRuleSetTypePtr(v *NamespaceNetworkRuleSetTypeArgs) NamespaceNetworkRuleSetTypePtrInput {
	return (*namespaceNetworkRuleSetTypePtrType)(v)
}

func (*namespaceNetworkRuleSetTypePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**NamespaceNetworkRuleSetType)(nil)).Elem()
}

func (i *namespaceNetworkRuleSetTypePtrType) ToNamespaceNetworkRuleSetTypePtrOutput() NamespaceNetworkRuleSetTypePtrOutput {
	return i.ToNamespaceNetworkRuleSetTypePtrOutputWithContext(context.Background())
}

func (i *namespaceNetworkRuleSetTypePtrType) ToNamespaceNetworkRuleSetTypePtrOutputWithContext(ctx context.Context) NamespaceNetworkRuleSetTypePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceNetworkRuleSetTypePtrOutput)
}

func (i *namespaceNetworkRuleSetTypePtrType) ToOutput(ctx context.Context) pulumix.Output[*NamespaceNetworkRuleSetType] {
	return pulumix.Output[*NamespaceNetworkRuleSetType]{
		OutputState: i.ToNamespaceNetworkRuleSetTypePtrOutputWithContext(ctx).OutputState,
	}
}

type NamespaceNetworkRuleSetTypeOutput struct{ *pulumi.OutputState }

func (NamespaceNetworkRuleSetTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NamespaceNetworkRuleSetType)(nil)).Elem()
}

func (o NamespaceNetworkRuleSetTypeOutput) ToNamespaceNetworkRuleSetTypeOutput() NamespaceNetworkRuleSetTypeOutput {
	return o
}

func (o NamespaceNetworkRuleSetTypeOutput) ToNamespaceNetworkRuleSetTypeOutputWithContext(ctx context.Context) NamespaceNetworkRuleSetTypeOutput {
	return o
}

func (o NamespaceNetworkRuleSetTypeOutput) ToNamespaceNetworkRuleSetTypePtrOutput() NamespaceNetworkRuleSetTypePtrOutput {
	return o.ToNamespaceNetworkRuleSetTypePtrOutputWithContext(context.Background())
}

func (o NamespaceNetworkRuleSetTypeOutput) ToNamespaceNetworkRuleSetTypePtrOutputWithContext(ctx context.Context) NamespaceNetworkRuleSetTypePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v NamespaceNetworkRuleSetType) *NamespaceNetworkRuleSetType {
		return &v
	}).(NamespaceNetworkRuleSetTypePtrOutput)
}

func (o NamespaceNetworkRuleSetTypeOutput) ToOutput(ctx context.Context) pulumix.Output[NamespaceNetworkRuleSetType] {
	return pulumix.Output[NamespaceNetworkRuleSetType]{
		OutputState: o.OutputState,
	}
}

// Specifies the default action for the Network Rule Set. Possible values are `Allow` and `Deny`. Defaults to `Allow`.
func (o NamespaceNetworkRuleSetTypeOutput) DefaultAction() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NamespaceNetworkRuleSetType) *string { return v.DefaultAction }).(pulumi.StringPtrOutput)
}

// One or more IP Addresses, or CIDR Blocks which should be able to access the ServiceBus Namespace.
func (o NamespaceNetworkRuleSetTypeOutput) IpRules() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NamespaceNetworkRuleSetType) []string { return v.IpRules }).(pulumi.StringArrayOutput)
}

// One or more `networkRules` blocks as defined below.
func (o NamespaceNetworkRuleSetTypeOutput) NetworkRules() NamespaceNetworkRuleSetNetworkRuleArrayOutput {
	return o.ApplyT(func(v NamespaceNetworkRuleSetType) []NamespaceNetworkRuleSetNetworkRule { return v.NetworkRules }).(NamespaceNetworkRuleSetNetworkRuleArrayOutput)
}

// Whether to allow traffic over public network. Possible values are `true` and `false`. Defaults to `true`.
func (o NamespaceNetworkRuleSetTypeOutput) PublicNetworkAccessEnabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v NamespaceNetworkRuleSetType) *bool { return v.PublicNetworkAccessEnabled }).(pulumi.BoolPtrOutput)
}

// Are Azure Services that are known and trusted for this resource type are allowed to bypass firewall configuration? See [Trusted Microsoft Services](https://github.com/MicrosoftDocs/azure-docs/blob/master/articles/service-bus-messaging/includes/service-bus-trusted-services.md)
func (o NamespaceNetworkRuleSetTypeOutput) TrustedServicesAllowed() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v NamespaceNetworkRuleSetType) *bool { return v.TrustedServicesAllowed }).(pulumi.BoolPtrOutput)
}

type NamespaceNetworkRuleSetTypePtrOutput struct{ *pulumi.OutputState }

func (NamespaceNetworkRuleSetTypePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NamespaceNetworkRuleSetType)(nil)).Elem()
}

func (o NamespaceNetworkRuleSetTypePtrOutput) ToNamespaceNetworkRuleSetTypePtrOutput() NamespaceNetworkRuleSetTypePtrOutput {
	return o
}

func (o NamespaceNetworkRuleSetTypePtrOutput) ToNamespaceNetworkRuleSetTypePtrOutputWithContext(ctx context.Context) NamespaceNetworkRuleSetTypePtrOutput {
	return o
}

func (o NamespaceNetworkRuleSetTypePtrOutput) ToOutput(ctx context.Context) pulumix.Output[*NamespaceNetworkRuleSetType] {
	return pulumix.Output[*NamespaceNetworkRuleSetType]{
		OutputState: o.OutputState,
	}
}

func (o NamespaceNetworkRuleSetTypePtrOutput) Elem() NamespaceNetworkRuleSetTypeOutput {
	return o.ApplyT(func(v *NamespaceNetworkRuleSetType) NamespaceNetworkRuleSetType {
		if v != nil {
			return *v
		}
		var ret NamespaceNetworkRuleSetType
		return ret
	}).(NamespaceNetworkRuleSetTypeOutput)
}

// Specifies the default action for the Network Rule Set. Possible values are `Allow` and `Deny`. Defaults to `Allow`.
func (o NamespaceNetworkRuleSetTypePtrOutput) DefaultAction() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NamespaceNetworkRuleSetType) *string {
		if v == nil {
			return nil
		}
		return v.DefaultAction
	}).(pulumi.StringPtrOutput)
}

// One or more IP Addresses, or CIDR Blocks which should be able to access the ServiceBus Namespace.
func (o NamespaceNetworkRuleSetTypePtrOutput) IpRules() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *NamespaceNetworkRuleSetType) []string {
		if v == nil {
			return nil
		}
		return v.IpRules
	}).(pulumi.StringArrayOutput)
}

// One or more `networkRules` blocks as defined below.
func (o NamespaceNetworkRuleSetTypePtrOutput) NetworkRules() NamespaceNetworkRuleSetNetworkRuleArrayOutput {
	return o.ApplyT(func(v *NamespaceNetworkRuleSetType) []NamespaceNetworkRuleSetNetworkRule {
		if v == nil {
			return nil
		}
		return v.NetworkRules
	}).(NamespaceNetworkRuleSetNetworkRuleArrayOutput)
}

// Whether to allow traffic over public network. Possible values are `true` and `false`. Defaults to `true`.
func (o NamespaceNetworkRuleSetTypePtrOutput) PublicNetworkAccessEnabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *NamespaceNetworkRuleSetType) *bool {
		if v == nil {
			return nil
		}
		return v.PublicNetworkAccessEnabled
	}).(pulumi.BoolPtrOutput)
}

// Are Azure Services that are known and trusted for this resource type are allowed to bypass firewall configuration? See [Trusted Microsoft Services](https://github.com/MicrosoftDocs/azure-docs/blob/master/articles/service-bus-messaging/includes/service-bus-trusted-services.md)
func (o NamespaceNetworkRuleSetTypePtrOutput) TrustedServicesAllowed() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *NamespaceNetworkRuleSetType) *bool {
		if v == nil {
			return nil
		}
		return v.TrustedServicesAllowed
	}).(pulumi.BoolPtrOutput)
}

type NamespaceNetworkRuleSetNetworkRule struct {
	// Should the ServiceBus Namespace Network Rule Set ignore missing Virtual Network Service Endpoint option in the Subnet? Defaults to `false`.
	IgnoreMissingVnetServiceEndpoint *bool `pulumi:"ignoreMissingVnetServiceEndpoint"`
	// The Subnet ID which should be able to access this ServiceBus Namespace.
	SubnetId string `pulumi:"subnetId"`
}

// NamespaceNetworkRuleSetNetworkRuleInput is an input type that accepts NamespaceNetworkRuleSetNetworkRuleArgs and NamespaceNetworkRuleSetNetworkRuleOutput values.
// You can construct a concrete instance of `NamespaceNetworkRuleSetNetworkRuleInput` via:
//
//	NamespaceNetworkRuleSetNetworkRuleArgs{...}
type NamespaceNetworkRuleSetNetworkRuleInput interface {
	pulumi.Input

	ToNamespaceNetworkRuleSetNetworkRuleOutput() NamespaceNetworkRuleSetNetworkRuleOutput
	ToNamespaceNetworkRuleSetNetworkRuleOutputWithContext(context.Context) NamespaceNetworkRuleSetNetworkRuleOutput
}

type NamespaceNetworkRuleSetNetworkRuleArgs struct {
	// Should the ServiceBus Namespace Network Rule Set ignore missing Virtual Network Service Endpoint option in the Subnet? Defaults to `false`.
	IgnoreMissingVnetServiceEndpoint pulumi.BoolPtrInput `pulumi:"ignoreMissingVnetServiceEndpoint"`
	// The Subnet ID which should be able to access this ServiceBus Namespace.
	SubnetId pulumi.StringInput `pulumi:"subnetId"`
}

func (NamespaceNetworkRuleSetNetworkRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NamespaceNetworkRuleSetNetworkRule)(nil)).Elem()
}

func (i NamespaceNetworkRuleSetNetworkRuleArgs) ToNamespaceNetworkRuleSetNetworkRuleOutput() NamespaceNetworkRuleSetNetworkRuleOutput {
	return i.ToNamespaceNetworkRuleSetNetworkRuleOutputWithContext(context.Background())
}

func (i NamespaceNetworkRuleSetNetworkRuleArgs) ToNamespaceNetworkRuleSetNetworkRuleOutputWithContext(ctx context.Context) NamespaceNetworkRuleSetNetworkRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceNetworkRuleSetNetworkRuleOutput)
}

func (i NamespaceNetworkRuleSetNetworkRuleArgs) ToOutput(ctx context.Context) pulumix.Output[NamespaceNetworkRuleSetNetworkRule] {
	return pulumix.Output[NamespaceNetworkRuleSetNetworkRule]{
		OutputState: i.ToNamespaceNetworkRuleSetNetworkRuleOutputWithContext(ctx).OutputState,
	}
}

// NamespaceNetworkRuleSetNetworkRuleArrayInput is an input type that accepts NamespaceNetworkRuleSetNetworkRuleArray and NamespaceNetworkRuleSetNetworkRuleArrayOutput values.
// You can construct a concrete instance of `NamespaceNetworkRuleSetNetworkRuleArrayInput` via:
//
//	NamespaceNetworkRuleSetNetworkRuleArray{ NamespaceNetworkRuleSetNetworkRuleArgs{...} }
type NamespaceNetworkRuleSetNetworkRuleArrayInput interface {
	pulumi.Input

	ToNamespaceNetworkRuleSetNetworkRuleArrayOutput() NamespaceNetworkRuleSetNetworkRuleArrayOutput
	ToNamespaceNetworkRuleSetNetworkRuleArrayOutputWithContext(context.Context) NamespaceNetworkRuleSetNetworkRuleArrayOutput
}

type NamespaceNetworkRuleSetNetworkRuleArray []NamespaceNetworkRuleSetNetworkRuleInput

func (NamespaceNetworkRuleSetNetworkRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NamespaceNetworkRuleSetNetworkRule)(nil)).Elem()
}

func (i NamespaceNetworkRuleSetNetworkRuleArray) ToNamespaceNetworkRuleSetNetworkRuleArrayOutput() NamespaceNetworkRuleSetNetworkRuleArrayOutput {
	return i.ToNamespaceNetworkRuleSetNetworkRuleArrayOutputWithContext(context.Background())
}

func (i NamespaceNetworkRuleSetNetworkRuleArray) ToNamespaceNetworkRuleSetNetworkRuleArrayOutputWithContext(ctx context.Context) NamespaceNetworkRuleSetNetworkRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceNetworkRuleSetNetworkRuleArrayOutput)
}

func (i NamespaceNetworkRuleSetNetworkRuleArray) ToOutput(ctx context.Context) pulumix.Output[[]NamespaceNetworkRuleSetNetworkRule] {
	return pulumix.Output[[]NamespaceNetworkRuleSetNetworkRule]{
		OutputState: i.ToNamespaceNetworkRuleSetNetworkRuleArrayOutputWithContext(ctx).OutputState,
	}
}

type NamespaceNetworkRuleSetNetworkRuleOutput struct{ *pulumi.OutputState }

func (NamespaceNetworkRuleSetNetworkRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NamespaceNetworkRuleSetNetworkRule)(nil)).Elem()
}

func (o NamespaceNetworkRuleSetNetworkRuleOutput) ToNamespaceNetworkRuleSetNetworkRuleOutput() NamespaceNetworkRuleSetNetworkRuleOutput {
	return o
}

func (o NamespaceNetworkRuleSetNetworkRuleOutput) ToNamespaceNetworkRuleSetNetworkRuleOutputWithContext(ctx context.Context) NamespaceNetworkRuleSetNetworkRuleOutput {
	return o
}

func (o NamespaceNetworkRuleSetNetworkRuleOutput) ToOutput(ctx context.Context) pulumix.Output[NamespaceNetworkRuleSetNetworkRule] {
	return pulumix.Output[NamespaceNetworkRuleSetNetworkRule]{
		OutputState: o.OutputState,
	}
}

// Should the ServiceBus Namespace Network Rule Set ignore missing Virtual Network Service Endpoint option in the Subnet? Defaults to `false`.
func (o NamespaceNetworkRuleSetNetworkRuleOutput) IgnoreMissingVnetServiceEndpoint() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v NamespaceNetworkRuleSetNetworkRule) *bool { return v.IgnoreMissingVnetServiceEndpoint }).(pulumi.BoolPtrOutput)
}

// The Subnet ID which should be able to access this ServiceBus Namespace.
func (o NamespaceNetworkRuleSetNetworkRuleOutput) SubnetId() pulumi.StringOutput {
	return o.ApplyT(func(v NamespaceNetworkRuleSetNetworkRule) string { return v.SubnetId }).(pulumi.StringOutput)
}

type NamespaceNetworkRuleSetNetworkRuleArrayOutput struct{ *pulumi.OutputState }

func (NamespaceNetworkRuleSetNetworkRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NamespaceNetworkRuleSetNetworkRule)(nil)).Elem()
}

func (o NamespaceNetworkRuleSetNetworkRuleArrayOutput) ToNamespaceNetworkRuleSetNetworkRuleArrayOutput() NamespaceNetworkRuleSetNetworkRuleArrayOutput {
	return o
}

func (o NamespaceNetworkRuleSetNetworkRuleArrayOutput) ToNamespaceNetworkRuleSetNetworkRuleArrayOutputWithContext(ctx context.Context) NamespaceNetworkRuleSetNetworkRuleArrayOutput {
	return o
}

func (o NamespaceNetworkRuleSetNetworkRuleArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]NamespaceNetworkRuleSetNetworkRule] {
	return pulumix.Output[[]NamespaceNetworkRuleSetNetworkRule]{
		OutputState: o.OutputState,
	}
}

func (o NamespaceNetworkRuleSetNetworkRuleArrayOutput) Index(i pulumi.IntInput) NamespaceNetworkRuleSetNetworkRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) NamespaceNetworkRuleSetNetworkRule {
		return vs[0].([]NamespaceNetworkRuleSetNetworkRule)[vs[1].(int)]
	}).(NamespaceNetworkRuleSetNetworkRuleOutput)
}

type SubscriptionClientScopedSubscription struct {
	// Specifies the Client ID of the application that created the client-scoped subscription. Changing this forces a new resource to be created.
	//
	// > **NOTE:** Client ID can be null or empty, but it must match the client ID set on the JMS client application. From the Azure Service Bus perspective, a null client ID and an empty client id have the same behavior. If the client ID is set to null or empty, it is only accessible to client applications whose client ID is also set to null or empty.
	ClientId *string `pulumi:"clientId"`
	// Whether the client scoped subscription is durable. This property can only be controlled from the application side.
	IsClientScopedSubscriptionDurable *bool `pulumi:"isClientScopedSubscriptionDurable"`
	// Whether the client scoped subscription is shareable. Defaults to `true` Changing this forces a new resource to be created.
	IsClientScopedSubscriptionShareable *bool `pulumi:"isClientScopedSubscriptionShareable"`
}

// SubscriptionClientScopedSubscriptionInput is an input type that accepts SubscriptionClientScopedSubscriptionArgs and SubscriptionClientScopedSubscriptionOutput values.
// You can construct a concrete instance of `SubscriptionClientScopedSubscriptionInput` via:
//
//	SubscriptionClientScopedSubscriptionArgs{...}
type SubscriptionClientScopedSubscriptionInput interface {
	pulumi.Input

	ToSubscriptionClientScopedSubscriptionOutput() SubscriptionClientScopedSubscriptionOutput
	ToSubscriptionClientScopedSubscriptionOutputWithContext(context.Context) SubscriptionClientScopedSubscriptionOutput
}

type SubscriptionClientScopedSubscriptionArgs struct {
	// Specifies the Client ID of the application that created the client-scoped subscription. Changing this forces a new resource to be created.
	//
	// > **NOTE:** Client ID can be null or empty, but it must match the client ID set on the JMS client application. From the Azure Service Bus perspective, a null client ID and an empty client id have the same behavior. If the client ID is set to null or empty, it is only accessible to client applications whose client ID is also set to null or empty.
	ClientId pulumi.StringPtrInput `pulumi:"clientId"`
	// Whether the client scoped subscription is durable. This property can only be controlled from the application side.
	IsClientScopedSubscriptionDurable pulumi.BoolPtrInput `pulumi:"isClientScopedSubscriptionDurable"`
	// Whether the client scoped subscription is shareable. Defaults to `true` Changing this forces a new resource to be created.
	IsClientScopedSubscriptionShareable pulumi.BoolPtrInput `pulumi:"isClientScopedSubscriptionShareable"`
}

func (SubscriptionClientScopedSubscriptionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionClientScopedSubscription)(nil)).Elem()
}

func (i SubscriptionClientScopedSubscriptionArgs) ToSubscriptionClientScopedSubscriptionOutput() SubscriptionClientScopedSubscriptionOutput {
	return i.ToSubscriptionClientScopedSubscriptionOutputWithContext(context.Background())
}

func (i SubscriptionClientScopedSubscriptionArgs) ToSubscriptionClientScopedSubscriptionOutputWithContext(ctx context.Context) SubscriptionClientScopedSubscriptionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionClientScopedSubscriptionOutput)
}

func (i SubscriptionClientScopedSubscriptionArgs) ToOutput(ctx context.Context) pulumix.Output[SubscriptionClientScopedSubscription] {
	return pulumix.Output[SubscriptionClientScopedSubscription]{
		OutputState: i.ToSubscriptionClientScopedSubscriptionOutputWithContext(ctx).OutputState,
	}
}

func (i SubscriptionClientScopedSubscriptionArgs) ToSubscriptionClientScopedSubscriptionPtrOutput() SubscriptionClientScopedSubscriptionPtrOutput {
	return i.ToSubscriptionClientScopedSubscriptionPtrOutputWithContext(context.Background())
}

func (i SubscriptionClientScopedSubscriptionArgs) ToSubscriptionClientScopedSubscriptionPtrOutputWithContext(ctx context.Context) SubscriptionClientScopedSubscriptionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionClientScopedSubscriptionOutput).ToSubscriptionClientScopedSubscriptionPtrOutputWithContext(ctx)
}

// SubscriptionClientScopedSubscriptionPtrInput is an input type that accepts SubscriptionClientScopedSubscriptionArgs, SubscriptionClientScopedSubscriptionPtr and SubscriptionClientScopedSubscriptionPtrOutput values.
// You can construct a concrete instance of `SubscriptionClientScopedSubscriptionPtrInput` via:
//
//	        SubscriptionClientScopedSubscriptionArgs{...}
//
//	or:
//
//	        nil
type SubscriptionClientScopedSubscriptionPtrInput interface {
	pulumi.Input

	ToSubscriptionClientScopedSubscriptionPtrOutput() SubscriptionClientScopedSubscriptionPtrOutput
	ToSubscriptionClientScopedSubscriptionPtrOutputWithContext(context.Context) SubscriptionClientScopedSubscriptionPtrOutput
}

type subscriptionClientScopedSubscriptionPtrType SubscriptionClientScopedSubscriptionArgs

func SubscriptionClientScopedSubscriptionPtr(v *SubscriptionClientScopedSubscriptionArgs) SubscriptionClientScopedSubscriptionPtrInput {
	return (*subscriptionClientScopedSubscriptionPtrType)(v)
}

func (*subscriptionClientScopedSubscriptionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SubscriptionClientScopedSubscription)(nil)).Elem()
}

func (i *subscriptionClientScopedSubscriptionPtrType) ToSubscriptionClientScopedSubscriptionPtrOutput() SubscriptionClientScopedSubscriptionPtrOutput {
	return i.ToSubscriptionClientScopedSubscriptionPtrOutputWithContext(context.Background())
}

func (i *subscriptionClientScopedSubscriptionPtrType) ToSubscriptionClientScopedSubscriptionPtrOutputWithContext(ctx context.Context) SubscriptionClientScopedSubscriptionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionClientScopedSubscriptionPtrOutput)
}

func (i *subscriptionClientScopedSubscriptionPtrType) ToOutput(ctx context.Context) pulumix.Output[*SubscriptionClientScopedSubscription] {
	return pulumix.Output[*SubscriptionClientScopedSubscription]{
		OutputState: i.ToSubscriptionClientScopedSubscriptionPtrOutputWithContext(ctx).OutputState,
	}
}

type SubscriptionClientScopedSubscriptionOutput struct{ *pulumi.OutputState }

func (SubscriptionClientScopedSubscriptionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionClientScopedSubscription)(nil)).Elem()
}

func (o SubscriptionClientScopedSubscriptionOutput) ToSubscriptionClientScopedSubscriptionOutput() SubscriptionClientScopedSubscriptionOutput {
	return o
}

func (o SubscriptionClientScopedSubscriptionOutput) ToSubscriptionClientScopedSubscriptionOutputWithContext(ctx context.Context) SubscriptionClientScopedSubscriptionOutput {
	return o
}

func (o SubscriptionClientScopedSubscriptionOutput) ToSubscriptionClientScopedSubscriptionPtrOutput() SubscriptionClientScopedSubscriptionPtrOutput {
	return o.ToSubscriptionClientScopedSubscriptionPtrOutputWithContext(context.Background())
}

func (o SubscriptionClientScopedSubscriptionOutput) ToSubscriptionClientScopedSubscriptionPtrOutputWithContext(ctx context.Context) SubscriptionClientScopedSubscriptionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v SubscriptionClientScopedSubscription) *SubscriptionClientScopedSubscription {
		return &v
	}).(SubscriptionClientScopedSubscriptionPtrOutput)
}

func (o SubscriptionClientScopedSubscriptionOutput) ToOutput(ctx context.Context) pulumix.Output[SubscriptionClientScopedSubscription] {
	return pulumix.Output[SubscriptionClientScopedSubscription]{
		OutputState: o.OutputState,
	}
}

// Specifies the Client ID of the application that created the client-scoped subscription. Changing this forces a new resource to be created.
//
// > **NOTE:** Client ID can be null or empty, but it must match the client ID set on the JMS client application. From the Azure Service Bus perspective, a null client ID and an empty client id have the same behavior. If the client ID is set to null or empty, it is only accessible to client applications whose client ID is also set to null or empty.
func (o SubscriptionClientScopedSubscriptionOutput) ClientId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionClientScopedSubscription) *string { return v.ClientId }).(pulumi.StringPtrOutput)
}

// Whether the client scoped subscription is durable. This property can only be controlled from the application side.
func (o SubscriptionClientScopedSubscriptionOutput) IsClientScopedSubscriptionDurable() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v SubscriptionClientScopedSubscription) *bool { return v.IsClientScopedSubscriptionDurable }).(pulumi.BoolPtrOutput)
}

// Whether the client scoped subscription is shareable. Defaults to `true` Changing this forces a new resource to be created.
func (o SubscriptionClientScopedSubscriptionOutput) IsClientScopedSubscriptionShareable() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v SubscriptionClientScopedSubscription) *bool { return v.IsClientScopedSubscriptionShareable }).(pulumi.BoolPtrOutput)
}

type SubscriptionClientScopedSubscriptionPtrOutput struct{ *pulumi.OutputState }

func (SubscriptionClientScopedSubscriptionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SubscriptionClientScopedSubscription)(nil)).Elem()
}

func (o SubscriptionClientScopedSubscriptionPtrOutput) ToSubscriptionClientScopedSubscriptionPtrOutput() SubscriptionClientScopedSubscriptionPtrOutput {
	return o
}

func (o SubscriptionClientScopedSubscriptionPtrOutput) ToSubscriptionClientScopedSubscriptionPtrOutputWithContext(ctx context.Context) SubscriptionClientScopedSubscriptionPtrOutput {
	return o
}

func (o SubscriptionClientScopedSubscriptionPtrOutput) ToOutput(ctx context.Context) pulumix.Output[*SubscriptionClientScopedSubscription] {
	return pulumix.Output[*SubscriptionClientScopedSubscription]{
		OutputState: o.OutputState,
	}
}

func (o SubscriptionClientScopedSubscriptionPtrOutput) Elem() SubscriptionClientScopedSubscriptionOutput {
	return o.ApplyT(func(v *SubscriptionClientScopedSubscription) SubscriptionClientScopedSubscription {
		if v != nil {
			return *v
		}
		var ret SubscriptionClientScopedSubscription
		return ret
	}).(SubscriptionClientScopedSubscriptionOutput)
}

// Specifies the Client ID of the application that created the client-scoped subscription. Changing this forces a new resource to be created.
//
// > **NOTE:** Client ID can be null or empty, but it must match the client ID set on the JMS client application. From the Azure Service Bus perspective, a null client ID and an empty client id have the same behavior. If the client ID is set to null or empty, it is only accessible to client applications whose client ID is also set to null or empty.
func (o SubscriptionClientScopedSubscriptionPtrOutput) ClientId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubscriptionClientScopedSubscription) *string {
		if v == nil {
			return nil
		}
		return v.ClientId
	}).(pulumi.StringPtrOutput)
}

// Whether the client scoped subscription is durable. This property can only be controlled from the application side.
func (o SubscriptionClientScopedSubscriptionPtrOutput) IsClientScopedSubscriptionDurable() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *SubscriptionClientScopedSubscription) *bool {
		if v == nil {
			return nil
		}
		return v.IsClientScopedSubscriptionDurable
	}).(pulumi.BoolPtrOutput)
}

// Whether the client scoped subscription is shareable. Defaults to `true` Changing this forces a new resource to be created.
func (o SubscriptionClientScopedSubscriptionPtrOutput) IsClientScopedSubscriptionShareable() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *SubscriptionClientScopedSubscription) *bool {
		if v == nil {
			return nil
		}
		return v.IsClientScopedSubscriptionShareable
	}).(pulumi.BoolPtrOutput)
}

type SubscriptionRuleCorrelationFilter struct {
	// Content type of the message.
	ContentType *string `pulumi:"contentType"`
	// Identifier of the correlation.
	CorrelationId *string `pulumi:"correlationId"`
	// Application specific label.
	Label *string `pulumi:"label"`
	// Identifier of the message.
	MessageId *string `pulumi:"messageId"`
	// A list of user defined properties to be included in the filter. Specified as a map of name/value pairs.
	//
	// > **NOTE:** When creating a subscription rule of type `CorrelationFilter` at least one property must be set in the `correlationFilter` block.
	Properties map[string]string `pulumi:"properties"`
	// Address of the queue to reply to.
	ReplyTo *string `pulumi:"replyTo"`
	// Session identifier to reply to.
	ReplyToSessionId *string `pulumi:"replyToSessionId"`
	// Session identifier.
	SessionId *string `pulumi:"sessionId"`
	// Address to send to.
	To *string `pulumi:"to"`
}

// SubscriptionRuleCorrelationFilterInput is an input type that accepts SubscriptionRuleCorrelationFilterArgs and SubscriptionRuleCorrelationFilterOutput values.
// You can construct a concrete instance of `SubscriptionRuleCorrelationFilterInput` via:
//
//	SubscriptionRuleCorrelationFilterArgs{...}
type SubscriptionRuleCorrelationFilterInput interface {
	pulumi.Input

	ToSubscriptionRuleCorrelationFilterOutput() SubscriptionRuleCorrelationFilterOutput
	ToSubscriptionRuleCorrelationFilterOutputWithContext(context.Context) SubscriptionRuleCorrelationFilterOutput
}

type SubscriptionRuleCorrelationFilterArgs struct {
	// Content type of the message.
	ContentType pulumi.StringPtrInput `pulumi:"contentType"`
	// Identifier of the correlation.
	CorrelationId pulumi.StringPtrInput `pulumi:"correlationId"`
	// Application specific label.
	Label pulumi.StringPtrInput `pulumi:"label"`
	// Identifier of the message.
	MessageId pulumi.StringPtrInput `pulumi:"messageId"`
	// A list of user defined properties to be included in the filter. Specified as a map of name/value pairs.
	//
	// > **NOTE:** When creating a subscription rule of type `CorrelationFilter` at least one property must be set in the `correlationFilter` block.
	Properties pulumi.StringMapInput `pulumi:"properties"`
	// Address of the queue to reply to.
	ReplyTo pulumi.StringPtrInput `pulumi:"replyTo"`
	// Session identifier to reply to.
	ReplyToSessionId pulumi.StringPtrInput `pulumi:"replyToSessionId"`
	// Session identifier.
	SessionId pulumi.StringPtrInput `pulumi:"sessionId"`
	// Address to send to.
	To pulumi.StringPtrInput `pulumi:"to"`
}

func (SubscriptionRuleCorrelationFilterArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionRuleCorrelationFilter)(nil)).Elem()
}

func (i SubscriptionRuleCorrelationFilterArgs) ToSubscriptionRuleCorrelationFilterOutput() SubscriptionRuleCorrelationFilterOutput {
	return i.ToSubscriptionRuleCorrelationFilterOutputWithContext(context.Background())
}

func (i SubscriptionRuleCorrelationFilterArgs) ToSubscriptionRuleCorrelationFilterOutputWithContext(ctx context.Context) SubscriptionRuleCorrelationFilterOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionRuleCorrelationFilterOutput)
}

func (i SubscriptionRuleCorrelationFilterArgs) ToOutput(ctx context.Context) pulumix.Output[SubscriptionRuleCorrelationFilter] {
	return pulumix.Output[SubscriptionRuleCorrelationFilter]{
		OutputState: i.ToSubscriptionRuleCorrelationFilterOutputWithContext(ctx).OutputState,
	}
}

func (i SubscriptionRuleCorrelationFilterArgs) ToSubscriptionRuleCorrelationFilterPtrOutput() SubscriptionRuleCorrelationFilterPtrOutput {
	return i.ToSubscriptionRuleCorrelationFilterPtrOutputWithContext(context.Background())
}

func (i SubscriptionRuleCorrelationFilterArgs) ToSubscriptionRuleCorrelationFilterPtrOutputWithContext(ctx context.Context) SubscriptionRuleCorrelationFilterPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionRuleCorrelationFilterOutput).ToSubscriptionRuleCorrelationFilterPtrOutputWithContext(ctx)
}

// SubscriptionRuleCorrelationFilterPtrInput is an input type that accepts SubscriptionRuleCorrelationFilterArgs, SubscriptionRuleCorrelationFilterPtr and SubscriptionRuleCorrelationFilterPtrOutput values.
// You can construct a concrete instance of `SubscriptionRuleCorrelationFilterPtrInput` via:
//
//	        SubscriptionRuleCorrelationFilterArgs{...}
//
//	or:
//
//	        nil
type SubscriptionRuleCorrelationFilterPtrInput interface {
	pulumi.Input

	ToSubscriptionRuleCorrelationFilterPtrOutput() SubscriptionRuleCorrelationFilterPtrOutput
	ToSubscriptionRuleCorrelationFilterPtrOutputWithContext(context.Context) SubscriptionRuleCorrelationFilterPtrOutput
}

type subscriptionRuleCorrelationFilterPtrType SubscriptionRuleCorrelationFilterArgs

func SubscriptionRuleCorrelationFilterPtr(v *SubscriptionRuleCorrelationFilterArgs) SubscriptionRuleCorrelationFilterPtrInput {
	return (*subscriptionRuleCorrelationFilterPtrType)(v)
}

func (*subscriptionRuleCorrelationFilterPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SubscriptionRuleCorrelationFilter)(nil)).Elem()
}

func (i *subscriptionRuleCorrelationFilterPtrType) ToSubscriptionRuleCorrelationFilterPtrOutput() SubscriptionRuleCorrelationFilterPtrOutput {
	return i.ToSubscriptionRuleCorrelationFilterPtrOutputWithContext(context.Background())
}

func (i *subscriptionRuleCorrelationFilterPtrType) ToSubscriptionRuleCorrelationFilterPtrOutputWithContext(ctx context.Context) SubscriptionRuleCorrelationFilterPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionRuleCorrelationFilterPtrOutput)
}

func (i *subscriptionRuleCorrelationFilterPtrType) ToOutput(ctx context.Context) pulumix.Output[*SubscriptionRuleCorrelationFilter] {
	return pulumix.Output[*SubscriptionRuleCorrelationFilter]{
		OutputState: i.ToSubscriptionRuleCorrelationFilterPtrOutputWithContext(ctx).OutputState,
	}
}

type SubscriptionRuleCorrelationFilterOutput struct{ *pulumi.OutputState }

func (SubscriptionRuleCorrelationFilterOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionRuleCorrelationFilter)(nil)).Elem()
}

func (o SubscriptionRuleCorrelationFilterOutput) ToSubscriptionRuleCorrelationFilterOutput() SubscriptionRuleCorrelationFilterOutput {
	return o
}

func (o SubscriptionRuleCorrelationFilterOutput) ToSubscriptionRuleCorrelationFilterOutputWithContext(ctx context.Context) SubscriptionRuleCorrelationFilterOutput {
	return o
}

func (o SubscriptionRuleCorrelationFilterOutput) ToSubscriptionRuleCorrelationFilterPtrOutput() SubscriptionRuleCorrelationFilterPtrOutput {
	return o.ToSubscriptionRuleCorrelationFilterPtrOutputWithContext(context.Background())
}

func (o SubscriptionRuleCorrelationFilterOutput) ToSubscriptionRuleCorrelationFilterPtrOutputWithContext(ctx context.Context) SubscriptionRuleCorrelationFilterPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v SubscriptionRuleCorrelationFilter) *SubscriptionRuleCorrelationFilter {
		return &v
	}).(SubscriptionRuleCorrelationFilterPtrOutput)
}

func (o SubscriptionRuleCorrelationFilterOutput) ToOutput(ctx context.Context) pulumix.Output[SubscriptionRuleCorrelationFilter] {
	return pulumix.Output[SubscriptionRuleCorrelationFilter]{
		OutputState: o.OutputState,
	}
}

// Content type of the message.
func (o SubscriptionRuleCorrelationFilterOutput) ContentType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionRuleCorrelationFilter) *string { return v.ContentType }).(pulumi.StringPtrOutput)
}

// Identifier of the correlation.
func (o SubscriptionRuleCorrelationFilterOutput) CorrelationId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionRuleCorrelationFilter) *string { return v.CorrelationId }).(pulumi.StringPtrOutput)
}

// Application specific label.
func (o SubscriptionRuleCorrelationFilterOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionRuleCorrelationFilter) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// Identifier of the message.
func (o SubscriptionRuleCorrelationFilterOutput) MessageId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionRuleCorrelationFilter) *string { return v.MessageId }).(pulumi.StringPtrOutput)
}

// A list of user defined properties to be included in the filter. Specified as a map of name/value pairs.
//
// > **NOTE:** When creating a subscription rule of type `CorrelationFilter` at least one property must be set in the `correlationFilter` block.
func (o SubscriptionRuleCorrelationFilterOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v SubscriptionRuleCorrelationFilter) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Address of the queue to reply to.
func (o SubscriptionRuleCorrelationFilterOutput) ReplyTo() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionRuleCorrelationFilter) *string { return v.ReplyTo }).(pulumi.StringPtrOutput)
}

// Session identifier to reply to.
func (o SubscriptionRuleCorrelationFilterOutput) ReplyToSessionId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionRuleCorrelationFilter) *string { return v.ReplyToSessionId }).(pulumi.StringPtrOutput)
}

// Session identifier.
func (o SubscriptionRuleCorrelationFilterOutput) SessionId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionRuleCorrelationFilter) *string { return v.SessionId }).(pulumi.StringPtrOutput)
}

// Address to send to.
func (o SubscriptionRuleCorrelationFilterOutput) To() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionRuleCorrelationFilter) *string { return v.To }).(pulumi.StringPtrOutput)
}

type SubscriptionRuleCorrelationFilterPtrOutput struct{ *pulumi.OutputState }

func (SubscriptionRuleCorrelationFilterPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SubscriptionRuleCorrelationFilter)(nil)).Elem()
}

func (o SubscriptionRuleCorrelationFilterPtrOutput) ToSubscriptionRuleCorrelationFilterPtrOutput() SubscriptionRuleCorrelationFilterPtrOutput {
	return o
}

func (o SubscriptionRuleCorrelationFilterPtrOutput) ToSubscriptionRuleCorrelationFilterPtrOutputWithContext(ctx context.Context) SubscriptionRuleCorrelationFilterPtrOutput {
	return o
}

func (o SubscriptionRuleCorrelationFilterPtrOutput) ToOutput(ctx context.Context) pulumix.Output[*SubscriptionRuleCorrelationFilter] {
	return pulumix.Output[*SubscriptionRuleCorrelationFilter]{
		OutputState: o.OutputState,
	}
}

func (o SubscriptionRuleCorrelationFilterPtrOutput) Elem() SubscriptionRuleCorrelationFilterOutput {
	return o.ApplyT(func(v *SubscriptionRuleCorrelationFilter) SubscriptionRuleCorrelationFilter {
		if v != nil {
			return *v
		}
		var ret SubscriptionRuleCorrelationFilter
		return ret
	}).(SubscriptionRuleCorrelationFilterOutput)
}

// Content type of the message.
func (o SubscriptionRuleCorrelationFilterPtrOutput) ContentType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubscriptionRuleCorrelationFilter) *string {
		if v == nil {
			return nil
		}
		return v.ContentType
	}).(pulumi.StringPtrOutput)
}

// Identifier of the correlation.
func (o SubscriptionRuleCorrelationFilterPtrOutput) CorrelationId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubscriptionRuleCorrelationFilter) *string {
		if v == nil {
			return nil
		}
		return v.CorrelationId
	}).(pulumi.StringPtrOutput)
}

// Application specific label.
func (o SubscriptionRuleCorrelationFilterPtrOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubscriptionRuleCorrelationFilter) *string {
		if v == nil {
			return nil
		}
		return v.Label
	}).(pulumi.StringPtrOutput)
}

// Identifier of the message.
func (o SubscriptionRuleCorrelationFilterPtrOutput) MessageId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubscriptionRuleCorrelationFilter) *string {
		if v == nil {
			return nil
		}
		return v.MessageId
	}).(pulumi.StringPtrOutput)
}

// A list of user defined properties to be included in the filter. Specified as a map of name/value pairs.
//
// > **NOTE:** When creating a subscription rule of type `CorrelationFilter` at least one property must be set in the `correlationFilter` block.
func (o SubscriptionRuleCorrelationFilterPtrOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v *SubscriptionRuleCorrelationFilter) map[string]string {
		if v == nil {
			return nil
		}
		return v.Properties
	}).(pulumi.StringMapOutput)
}

// Address of the queue to reply to.
func (o SubscriptionRuleCorrelationFilterPtrOutput) ReplyTo() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubscriptionRuleCorrelationFilter) *string {
		if v == nil {
			return nil
		}
		return v.ReplyTo
	}).(pulumi.StringPtrOutput)
}

// Session identifier to reply to.
func (o SubscriptionRuleCorrelationFilterPtrOutput) ReplyToSessionId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubscriptionRuleCorrelationFilter) *string {
		if v == nil {
			return nil
		}
		return v.ReplyToSessionId
	}).(pulumi.StringPtrOutput)
}

// Session identifier.
func (o SubscriptionRuleCorrelationFilterPtrOutput) SessionId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubscriptionRuleCorrelationFilter) *string {
		if v == nil {
			return nil
		}
		return v.SessionId
	}).(pulumi.StringPtrOutput)
}

// Address to send to.
func (o SubscriptionRuleCorrelationFilterPtrOutput) To() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubscriptionRuleCorrelationFilter) *string {
		if v == nil {
			return nil
		}
		return v.To
	}).(pulumi.StringPtrOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*NamespaceCustomerManagedKeyInput)(nil)).Elem(), NamespaceCustomerManagedKeyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NamespaceCustomerManagedKeyPtrInput)(nil)).Elem(), NamespaceCustomerManagedKeyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NamespaceIdentityInput)(nil)).Elem(), NamespaceIdentityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NamespaceIdentityPtrInput)(nil)).Elem(), NamespaceIdentityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NamespaceNetworkRuleSetTypeInput)(nil)).Elem(), NamespaceNetworkRuleSetTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NamespaceNetworkRuleSetTypePtrInput)(nil)).Elem(), NamespaceNetworkRuleSetTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NamespaceNetworkRuleSetNetworkRuleInput)(nil)).Elem(), NamespaceNetworkRuleSetNetworkRuleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NamespaceNetworkRuleSetNetworkRuleArrayInput)(nil)).Elem(), NamespaceNetworkRuleSetNetworkRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SubscriptionClientScopedSubscriptionInput)(nil)).Elem(), SubscriptionClientScopedSubscriptionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SubscriptionClientScopedSubscriptionPtrInput)(nil)).Elem(), SubscriptionClientScopedSubscriptionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SubscriptionRuleCorrelationFilterInput)(nil)).Elem(), SubscriptionRuleCorrelationFilterArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SubscriptionRuleCorrelationFilterPtrInput)(nil)).Elem(), SubscriptionRuleCorrelationFilterArgs{})
	pulumi.RegisterOutputType(NamespaceCustomerManagedKeyOutput{})
	pulumi.RegisterOutputType(NamespaceCustomerManagedKeyPtrOutput{})
	pulumi.RegisterOutputType(NamespaceIdentityOutput{})
	pulumi.RegisterOutputType(NamespaceIdentityPtrOutput{})
	pulumi.RegisterOutputType(NamespaceNetworkRuleSetTypeOutput{})
	pulumi.RegisterOutputType(NamespaceNetworkRuleSetTypePtrOutput{})
	pulumi.RegisterOutputType(NamespaceNetworkRuleSetNetworkRuleOutput{})
	pulumi.RegisterOutputType(NamespaceNetworkRuleSetNetworkRuleArrayOutput{})
	pulumi.RegisterOutputType(SubscriptionClientScopedSubscriptionOutput{})
	pulumi.RegisterOutputType(SubscriptionClientScopedSubscriptionPtrOutput{})
	pulumi.RegisterOutputType(SubscriptionRuleCorrelationFilterOutput{})
	pulumi.RegisterOutputType(SubscriptionRuleCorrelationFilterPtrOutput{})
}
