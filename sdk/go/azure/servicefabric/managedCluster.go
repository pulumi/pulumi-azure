// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package servicefabric

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-azure/sdk/v5/go/azure/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages a Resource Group.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-azure/sdk/v5/go/azure/servicefabric"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := servicefabric.NewManagedCluster(ctx, "example", &servicefabric.ManagedClusterArgs{
//				ClientConnectionPort: pulumi.Int(12345),
//				HttpGatewayPort:      pulumi.Int(4567),
//				LbRules: servicefabric.ManagedClusterLbRuleArray{
//					&servicefabric.ManagedClusterLbRuleArgs{
//						BackendPort:      pulumi.Int(38080),
//						FrontendPort:     pulumi.Int(80),
//						ProbeProtocol:    pulumi.String("http"),
//						ProbeRequestPath: pulumi.String("/test"),
//						Protocol:         pulumi.String("tcp"),
//					},
//				},
//				Location: pulumi.String("West Europe"),
//				NodeTypes: servicefabric.ManagedClusterNodeTypeArray{
//					&servicefabric.ManagedClusterNodeTypeArgs{
//						ApplicationPortRange: pulumi.String("30000-49000"),
//						DataDiskSizeGb:       pulumi.Int(130),
//						EphemeralPortRange:   pulumi.String("10000-20000"),
//						Name:                 pulumi.String("test1"),
//						Primary:              pulumi.Bool(true),
//						VmImageOffer:         pulumi.String("WindowsServer"),
//						VmImagePublisher:     pulumi.String("MicrosoftWindowsServer"),
//						VmImageSku:           pulumi.String("2019-Datacenter-with-Containers"),
//						VmImageVersion:       pulumi.String("latest"),
//						VmInstanceCount:      pulumi.Int(5),
//						VmSize:               pulumi.String("Standard_DS1_v2"),
//					},
//				},
//				ResourceGroupName: pulumi.String("example"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Resource Groups can be imported using the `resource id`, e.g.
//
// ```sh
//
//	$ pulumi import azure:servicefabric/managedCluster:ManagedCluster example /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/resourceGroup1/providers/Microsoft.ServiceFabric/managedClusters/clusterName1
//
// ```
type ManagedCluster struct {
	pulumi.CustomResourceState

	// Controls how connections to the cluster are authenticated. A `authentication` block as defined below.
	Authentication ManagedClusterAuthenticationPtrOutput `pulumi:"authentication"`
	// If true, backup service is enabled.
	BackupServiceEnabled pulumi.BoolPtrOutput `pulumi:"backupServiceEnabled"`
	// Port to use when connecting to the cluster.
	ClientConnectionPort pulumi.IntOutput `pulumi:"clientConnectionPort"`
	// One or more `customFabricSetting` blocks as defined below.
	CustomFabricSettings ManagedClusterCustomFabricSettingArrayOutput `pulumi:"customFabricSettings"`
	// Hostname for the cluster. If unset the cluster's name will be used..
	DnsName pulumi.StringOutput `pulumi:"dnsName"`
	// If true, DNS service is enabled.
	DnsServiceEnabled pulumi.BoolPtrOutput `pulumi:"dnsServiceEnabled"`
	// Port that should be used by the Service Fabric Explorer to visualize applications and cluster status.
	HttpGatewayPort pulumi.IntOutput `pulumi:"httpGatewayPort"`
	// One or more `lbRule` blocks as defined below.
	LbRules ManagedClusterLbRuleArrayOutput `pulumi:"lbRules"`
	// The Azure Region where the Resource Group should exist. Changing this forces a new Resource Group to be created.
	Location pulumi.StringOutput `pulumi:"location"`
	// The name which should be used for this Resource Group. Changing this forces a new Resource Group to be created.
	Name pulumi.StringOutput `pulumi:"name"`
	// One or more `nodeType` blocks as defined below.
	NodeTypes ManagedClusterNodeTypeArrayOutput `pulumi:"nodeTypes"`
	// Administrator password for the VMs that will be created as part of this cluster.
	Password pulumi.StringPtrOutput `pulumi:"password"`
	// The name of the Resource Group where the Resource Group should exist. Changing this forces a new Resource Group to be created.
	ResourceGroupName pulumi.StringOutput `pulumi:"resourceGroupName"`
	// SKU for this cluster. Changing this forces a new resource to be created. Default is `Basic`, allowed values are either `Basic` or `Standard`.
	Sku pulumi.StringPtrOutput `pulumi:"sku"`
	// A mapping of tags which should be assigned to the Resource Group.
	Tags pulumi.StringMapOutput `pulumi:"tags"`
	// Upgrade wave for the fabric runtime. Default is `Wave0`, allowed value must be one of `Wave0`, `Wave1`, or `Wave2`.
	UpgradeWave pulumi.StringPtrOutput `pulumi:"upgradeWave"`
	// Administrator password for the VMs that will be created as part of this cluster.
	Username pulumi.StringPtrOutput `pulumi:"username"`
}

// NewManagedCluster registers a new resource with the given unique name, arguments, and options.
func NewManagedCluster(ctx *pulumi.Context,
	name string, args *ManagedClusterArgs, opts ...pulumi.ResourceOption) (*ManagedCluster, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ClientConnectionPort == nil {
		return nil, errors.New("invalid value for required argument 'ClientConnectionPort'")
	}
	if args.HttpGatewayPort == nil {
		return nil, errors.New("invalid value for required argument 'HttpGatewayPort'")
	}
	if args.LbRules == nil {
		return nil, errors.New("invalid value for required argument 'LbRules'")
	}
	if args.ResourceGroupName == nil {
		return nil, errors.New("invalid value for required argument 'ResourceGroupName'")
	}
	if args.Password != nil {
		args.Password = pulumi.ToSecret(args.Password).(pulumi.StringPtrInput)
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"password",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ManagedCluster
	err := ctx.RegisterResource("azure:servicefabric/managedCluster:ManagedCluster", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetManagedCluster gets an existing ManagedCluster resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetManagedCluster(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ManagedClusterState, opts ...pulumi.ResourceOption) (*ManagedCluster, error) {
	var resource ManagedCluster
	err := ctx.ReadResource("azure:servicefabric/managedCluster:ManagedCluster", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ManagedCluster resources.
type managedClusterState struct {
	// Controls how connections to the cluster are authenticated. A `authentication` block as defined below.
	Authentication *ManagedClusterAuthentication `pulumi:"authentication"`
	// If true, backup service is enabled.
	BackupServiceEnabled *bool `pulumi:"backupServiceEnabled"`
	// Port to use when connecting to the cluster.
	ClientConnectionPort *int `pulumi:"clientConnectionPort"`
	// One or more `customFabricSetting` blocks as defined below.
	CustomFabricSettings []ManagedClusterCustomFabricSetting `pulumi:"customFabricSettings"`
	// Hostname for the cluster. If unset the cluster's name will be used..
	DnsName *string `pulumi:"dnsName"`
	// If true, DNS service is enabled.
	DnsServiceEnabled *bool `pulumi:"dnsServiceEnabled"`
	// Port that should be used by the Service Fabric Explorer to visualize applications and cluster status.
	HttpGatewayPort *int `pulumi:"httpGatewayPort"`
	// One or more `lbRule` blocks as defined below.
	LbRules []ManagedClusterLbRule `pulumi:"lbRules"`
	// The Azure Region where the Resource Group should exist. Changing this forces a new Resource Group to be created.
	Location *string `pulumi:"location"`
	// The name which should be used for this Resource Group. Changing this forces a new Resource Group to be created.
	Name *string `pulumi:"name"`
	// One or more `nodeType` blocks as defined below.
	NodeTypes []ManagedClusterNodeType `pulumi:"nodeTypes"`
	// Administrator password for the VMs that will be created as part of this cluster.
	Password *string `pulumi:"password"`
	// The name of the Resource Group where the Resource Group should exist. Changing this forces a new Resource Group to be created.
	ResourceGroupName *string `pulumi:"resourceGroupName"`
	// SKU for this cluster. Changing this forces a new resource to be created. Default is `Basic`, allowed values are either `Basic` or `Standard`.
	Sku *string `pulumi:"sku"`
	// A mapping of tags which should be assigned to the Resource Group.
	Tags map[string]string `pulumi:"tags"`
	// Upgrade wave for the fabric runtime. Default is `Wave0`, allowed value must be one of `Wave0`, `Wave1`, or `Wave2`.
	UpgradeWave *string `pulumi:"upgradeWave"`
	// Administrator password for the VMs that will be created as part of this cluster.
	Username *string `pulumi:"username"`
}

type ManagedClusterState struct {
	// Controls how connections to the cluster are authenticated. A `authentication` block as defined below.
	Authentication ManagedClusterAuthenticationPtrInput
	// If true, backup service is enabled.
	BackupServiceEnabled pulumi.BoolPtrInput
	// Port to use when connecting to the cluster.
	ClientConnectionPort pulumi.IntPtrInput
	// One or more `customFabricSetting` blocks as defined below.
	CustomFabricSettings ManagedClusterCustomFabricSettingArrayInput
	// Hostname for the cluster. If unset the cluster's name will be used..
	DnsName pulumi.StringPtrInput
	// If true, DNS service is enabled.
	DnsServiceEnabled pulumi.BoolPtrInput
	// Port that should be used by the Service Fabric Explorer to visualize applications and cluster status.
	HttpGatewayPort pulumi.IntPtrInput
	// One or more `lbRule` blocks as defined below.
	LbRules ManagedClusterLbRuleArrayInput
	// The Azure Region where the Resource Group should exist. Changing this forces a new Resource Group to be created.
	Location pulumi.StringPtrInput
	// The name which should be used for this Resource Group. Changing this forces a new Resource Group to be created.
	Name pulumi.StringPtrInput
	// One or more `nodeType` blocks as defined below.
	NodeTypes ManagedClusterNodeTypeArrayInput
	// Administrator password for the VMs that will be created as part of this cluster.
	Password pulumi.StringPtrInput
	// The name of the Resource Group where the Resource Group should exist. Changing this forces a new Resource Group to be created.
	ResourceGroupName pulumi.StringPtrInput
	// SKU for this cluster. Changing this forces a new resource to be created. Default is `Basic`, allowed values are either `Basic` or `Standard`.
	Sku pulumi.StringPtrInput
	// A mapping of tags which should be assigned to the Resource Group.
	Tags pulumi.StringMapInput
	// Upgrade wave for the fabric runtime. Default is `Wave0`, allowed value must be one of `Wave0`, `Wave1`, or `Wave2`.
	UpgradeWave pulumi.StringPtrInput
	// Administrator password for the VMs that will be created as part of this cluster.
	Username pulumi.StringPtrInput
}

func (ManagedClusterState) ElementType() reflect.Type {
	return reflect.TypeOf((*managedClusterState)(nil)).Elem()
}

type managedClusterArgs struct {
	// Controls how connections to the cluster are authenticated. A `authentication` block as defined below.
	Authentication *ManagedClusterAuthentication `pulumi:"authentication"`
	// If true, backup service is enabled.
	BackupServiceEnabled *bool `pulumi:"backupServiceEnabled"`
	// Port to use when connecting to the cluster.
	ClientConnectionPort int `pulumi:"clientConnectionPort"`
	// One or more `customFabricSetting` blocks as defined below.
	CustomFabricSettings []ManagedClusterCustomFabricSetting `pulumi:"customFabricSettings"`
	// Hostname for the cluster. If unset the cluster's name will be used..
	DnsName *string `pulumi:"dnsName"`
	// If true, DNS service is enabled.
	DnsServiceEnabled *bool `pulumi:"dnsServiceEnabled"`
	// Port that should be used by the Service Fabric Explorer to visualize applications and cluster status.
	HttpGatewayPort int `pulumi:"httpGatewayPort"`
	// One or more `lbRule` blocks as defined below.
	LbRules []ManagedClusterLbRule `pulumi:"lbRules"`
	// The Azure Region where the Resource Group should exist. Changing this forces a new Resource Group to be created.
	Location *string `pulumi:"location"`
	// The name which should be used for this Resource Group. Changing this forces a new Resource Group to be created.
	Name *string `pulumi:"name"`
	// One or more `nodeType` blocks as defined below.
	NodeTypes []ManagedClusterNodeType `pulumi:"nodeTypes"`
	// Administrator password for the VMs that will be created as part of this cluster.
	Password *string `pulumi:"password"`
	// The name of the Resource Group where the Resource Group should exist. Changing this forces a new Resource Group to be created.
	ResourceGroupName string `pulumi:"resourceGroupName"`
	// SKU for this cluster. Changing this forces a new resource to be created. Default is `Basic`, allowed values are either `Basic` or `Standard`.
	Sku *string `pulumi:"sku"`
	// A mapping of tags which should be assigned to the Resource Group.
	Tags map[string]string `pulumi:"tags"`
	// Upgrade wave for the fabric runtime. Default is `Wave0`, allowed value must be one of `Wave0`, `Wave1`, or `Wave2`.
	UpgradeWave *string `pulumi:"upgradeWave"`
	// Administrator password for the VMs that will be created as part of this cluster.
	Username *string `pulumi:"username"`
}

// The set of arguments for constructing a ManagedCluster resource.
type ManagedClusterArgs struct {
	// Controls how connections to the cluster are authenticated. A `authentication` block as defined below.
	Authentication ManagedClusterAuthenticationPtrInput
	// If true, backup service is enabled.
	BackupServiceEnabled pulumi.BoolPtrInput
	// Port to use when connecting to the cluster.
	ClientConnectionPort pulumi.IntInput
	// One or more `customFabricSetting` blocks as defined below.
	CustomFabricSettings ManagedClusterCustomFabricSettingArrayInput
	// Hostname for the cluster. If unset the cluster's name will be used..
	DnsName pulumi.StringPtrInput
	// If true, DNS service is enabled.
	DnsServiceEnabled pulumi.BoolPtrInput
	// Port that should be used by the Service Fabric Explorer to visualize applications and cluster status.
	HttpGatewayPort pulumi.IntInput
	// One or more `lbRule` blocks as defined below.
	LbRules ManagedClusterLbRuleArrayInput
	// The Azure Region where the Resource Group should exist. Changing this forces a new Resource Group to be created.
	Location pulumi.StringPtrInput
	// The name which should be used for this Resource Group. Changing this forces a new Resource Group to be created.
	Name pulumi.StringPtrInput
	// One or more `nodeType` blocks as defined below.
	NodeTypes ManagedClusterNodeTypeArrayInput
	// Administrator password for the VMs that will be created as part of this cluster.
	Password pulumi.StringPtrInput
	// The name of the Resource Group where the Resource Group should exist. Changing this forces a new Resource Group to be created.
	ResourceGroupName pulumi.StringInput
	// SKU for this cluster. Changing this forces a new resource to be created. Default is `Basic`, allowed values are either `Basic` or `Standard`.
	Sku pulumi.StringPtrInput
	// A mapping of tags which should be assigned to the Resource Group.
	Tags pulumi.StringMapInput
	// Upgrade wave for the fabric runtime. Default is `Wave0`, allowed value must be one of `Wave0`, `Wave1`, or `Wave2`.
	UpgradeWave pulumi.StringPtrInput
	// Administrator password for the VMs that will be created as part of this cluster.
	Username pulumi.StringPtrInput
}

func (ManagedClusterArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*managedClusterArgs)(nil)).Elem()
}

type ManagedClusterInput interface {
	pulumi.Input

	ToManagedClusterOutput() ManagedClusterOutput
	ToManagedClusterOutputWithContext(ctx context.Context) ManagedClusterOutput
}

func (*ManagedCluster) ElementType() reflect.Type {
	return reflect.TypeOf((**ManagedCluster)(nil)).Elem()
}

func (i *ManagedCluster) ToManagedClusterOutput() ManagedClusterOutput {
	return i.ToManagedClusterOutputWithContext(context.Background())
}

func (i *ManagedCluster) ToManagedClusterOutputWithContext(ctx context.Context) ManagedClusterOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedClusterOutput)
}

// ManagedClusterArrayInput is an input type that accepts ManagedClusterArray and ManagedClusterArrayOutput values.
// You can construct a concrete instance of `ManagedClusterArrayInput` via:
//
//	ManagedClusterArray{ ManagedClusterArgs{...} }
type ManagedClusterArrayInput interface {
	pulumi.Input

	ToManagedClusterArrayOutput() ManagedClusterArrayOutput
	ToManagedClusterArrayOutputWithContext(context.Context) ManagedClusterArrayOutput
}

type ManagedClusterArray []ManagedClusterInput

func (ManagedClusterArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ManagedCluster)(nil)).Elem()
}

func (i ManagedClusterArray) ToManagedClusterArrayOutput() ManagedClusterArrayOutput {
	return i.ToManagedClusterArrayOutputWithContext(context.Background())
}

func (i ManagedClusterArray) ToManagedClusterArrayOutputWithContext(ctx context.Context) ManagedClusterArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedClusterArrayOutput)
}

// ManagedClusterMapInput is an input type that accepts ManagedClusterMap and ManagedClusterMapOutput values.
// You can construct a concrete instance of `ManagedClusterMapInput` via:
//
//	ManagedClusterMap{ "key": ManagedClusterArgs{...} }
type ManagedClusterMapInput interface {
	pulumi.Input

	ToManagedClusterMapOutput() ManagedClusterMapOutput
	ToManagedClusterMapOutputWithContext(context.Context) ManagedClusterMapOutput
}

type ManagedClusterMap map[string]ManagedClusterInput

func (ManagedClusterMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ManagedCluster)(nil)).Elem()
}

func (i ManagedClusterMap) ToManagedClusterMapOutput() ManagedClusterMapOutput {
	return i.ToManagedClusterMapOutputWithContext(context.Background())
}

func (i ManagedClusterMap) ToManagedClusterMapOutputWithContext(ctx context.Context) ManagedClusterMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedClusterMapOutput)
}

type ManagedClusterOutput struct{ *pulumi.OutputState }

func (ManagedClusterOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ManagedCluster)(nil)).Elem()
}

func (o ManagedClusterOutput) ToManagedClusterOutput() ManagedClusterOutput {
	return o
}

func (o ManagedClusterOutput) ToManagedClusterOutputWithContext(ctx context.Context) ManagedClusterOutput {
	return o
}

// Controls how connections to the cluster are authenticated. A `authentication` block as defined below.
func (o ManagedClusterOutput) Authentication() ManagedClusterAuthenticationPtrOutput {
	return o.ApplyT(func(v *ManagedCluster) ManagedClusterAuthenticationPtrOutput { return v.Authentication }).(ManagedClusterAuthenticationPtrOutput)
}

// If true, backup service is enabled.
func (o ManagedClusterOutput) BackupServiceEnabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ManagedCluster) pulumi.BoolPtrOutput { return v.BackupServiceEnabled }).(pulumi.BoolPtrOutput)
}

// Port to use when connecting to the cluster.
func (o ManagedClusterOutput) ClientConnectionPort() pulumi.IntOutput {
	return o.ApplyT(func(v *ManagedCluster) pulumi.IntOutput { return v.ClientConnectionPort }).(pulumi.IntOutput)
}

// One or more `customFabricSetting` blocks as defined below.
func (o ManagedClusterOutput) CustomFabricSettings() ManagedClusterCustomFabricSettingArrayOutput {
	return o.ApplyT(func(v *ManagedCluster) ManagedClusterCustomFabricSettingArrayOutput { return v.CustomFabricSettings }).(ManagedClusterCustomFabricSettingArrayOutput)
}

// Hostname for the cluster. If unset the cluster's name will be used..
func (o ManagedClusterOutput) DnsName() pulumi.StringOutput {
	return o.ApplyT(func(v *ManagedCluster) pulumi.StringOutput { return v.DnsName }).(pulumi.StringOutput)
}

// If true, DNS service is enabled.
func (o ManagedClusterOutput) DnsServiceEnabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ManagedCluster) pulumi.BoolPtrOutput { return v.DnsServiceEnabled }).(pulumi.BoolPtrOutput)
}

// Port that should be used by the Service Fabric Explorer to visualize applications and cluster status.
func (o ManagedClusterOutput) HttpGatewayPort() pulumi.IntOutput {
	return o.ApplyT(func(v *ManagedCluster) pulumi.IntOutput { return v.HttpGatewayPort }).(pulumi.IntOutput)
}

// One or more `lbRule` blocks as defined below.
func (o ManagedClusterOutput) LbRules() ManagedClusterLbRuleArrayOutput {
	return o.ApplyT(func(v *ManagedCluster) ManagedClusterLbRuleArrayOutput { return v.LbRules }).(ManagedClusterLbRuleArrayOutput)
}

// The Azure Region where the Resource Group should exist. Changing this forces a new Resource Group to be created.
func (o ManagedClusterOutput) Location() pulumi.StringOutput {
	return o.ApplyT(func(v *ManagedCluster) pulumi.StringOutput { return v.Location }).(pulumi.StringOutput)
}

// The name which should be used for this Resource Group. Changing this forces a new Resource Group to be created.
func (o ManagedClusterOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *ManagedCluster) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// One or more `nodeType` blocks as defined below.
func (o ManagedClusterOutput) NodeTypes() ManagedClusterNodeTypeArrayOutput {
	return o.ApplyT(func(v *ManagedCluster) ManagedClusterNodeTypeArrayOutput { return v.NodeTypes }).(ManagedClusterNodeTypeArrayOutput)
}

// Administrator password for the VMs that will be created as part of this cluster.
func (o ManagedClusterOutput) Password() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ManagedCluster) pulumi.StringPtrOutput { return v.Password }).(pulumi.StringPtrOutput)
}

// The name of the Resource Group where the Resource Group should exist. Changing this forces a new Resource Group to be created.
func (o ManagedClusterOutput) ResourceGroupName() pulumi.StringOutput {
	return o.ApplyT(func(v *ManagedCluster) pulumi.StringOutput { return v.ResourceGroupName }).(pulumi.StringOutput)
}

// SKU for this cluster. Changing this forces a new resource to be created. Default is `Basic`, allowed values are either `Basic` or `Standard`.
func (o ManagedClusterOutput) Sku() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ManagedCluster) pulumi.StringPtrOutput { return v.Sku }).(pulumi.StringPtrOutput)
}

// A mapping of tags which should be assigned to the Resource Group.
func (o ManagedClusterOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ManagedCluster) pulumi.StringMapOutput { return v.Tags }).(pulumi.StringMapOutput)
}

// Upgrade wave for the fabric runtime. Default is `Wave0`, allowed value must be one of `Wave0`, `Wave1`, or `Wave2`.
func (o ManagedClusterOutput) UpgradeWave() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ManagedCluster) pulumi.StringPtrOutput { return v.UpgradeWave }).(pulumi.StringPtrOutput)
}

// Administrator password for the VMs that will be created as part of this cluster.
func (o ManagedClusterOutput) Username() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ManagedCluster) pulumi.StringPtrOutput { return v.Username }).(pulumi.StringPtrOutput)
}

type ManagedClusterArrayOutput struct{ *pulumi.OutputState }

func (ManagedClusterArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ManagedCluster)(nil)).Elem()
}

func (o ManagedClusterArrayOutput) ToManagedClusterArrayOutput() ManagedClusterArrayOutput {
	return o
}

func (o ManagedClusterArrayOutput) ToManagedClusterArrayOutputWithContext(ctx context.Context) ManagedClusterArrayOutput {
	return o
}

func (o ManagedClusterArrayOutput) Index(i pulumi.IntInput) ManagedClusterOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ManagedCluster {
		return vs[0].([]*ManagedCluster)[vs[1].(int)]
	}).(ManagedClusterOutput)
}

type ManagedClusterMapOutput struct{ *pulumi.OutputState }

func (ManagedClusterMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ManagedCluster)(nil)).Elem()
}

func (o ManagedClusterMapOutput) ToManagedClusterMapOutput() ManagedClusterMapOutput {
	return o
}

func (o ManagedClusterMapOutput) ToManagedClusterMapOutputWithContext(ctx context.Context) ManagedClusterMapOutput {
	return o
}

func (o ManagedClusterMapOutput) MapIndex(k pulumi.StringInput) ManagedClusterOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ManagedCluster {
		return vs[0].(map[string]*ManagedCluster)[vs[1].(string)]
	}).(ManagedClusterOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ManagedClusterInput)(nil)).Elem(), &ManagedCluster{})
	pulumi.RegisterInputType(reflect.TypeOf((*ManagedClusterArrayInput)(nil)).Elem(), ManagedClusterArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ManagedClusterMapInput)(nil)).Elem(), ManagedClusterMap{})
	pulumi.RegisterOutputType(ManagedClusterOutput{})
	pulumi.RegisterOutputType(ManagedClusterArrayOutput{})
	pulumi.RegisterOutputType(ManagedClusterMapOutput{})
}
