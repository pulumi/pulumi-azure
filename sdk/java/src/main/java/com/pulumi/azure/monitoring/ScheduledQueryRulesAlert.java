// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.azure.monitoring;

import com.pulumi.azure.Utilities;
import com.pulumi.azure.monitoring.ScheduledQueryRulesAlertArgs;
import com.pulumi.azure.monitoring.inputs.ScheduledQueryRulesAlertState;
import com.pulumi.azure.monitoring.outputs.ScheduledQueryRulesAlertAction;
import com.pulumi.azure.monitoring.outputs.ScheduledQueryRulesAlertTrigger;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * Manages an AlertingAction Scheduled Query Rules resource within Azure Monitor.
 * 
 * &gt; **Note:** This resource is using an older AzureRM API version which is known to cause problems e.g. with custom webhook properties not included in triggered alerts. This resource is superseded by the azure.monitoring.ScheduledQueryRulesAlertV2 resource using newer API versions.
 * 
 * ## Example Usage
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.azure.core.ResourceGroup;
 * import com.pulumi.azure.core.ResourceGroupArgs;
 * import com.pulumi.azure.appinsights.Insights;
 * import com.pulumi.azure.appinsights.InsightsArgs;
 * import com.pulumi.azure.monitoring.ScheduledQueryRulesAlert;
 * import com.pulumi.azure.monitoring.ScheduledQueryRulesAlertArgs;
 * import com.pulumi.azure.monitoring.inputs.ScheduledQueryRulesAlertActionArgs;
 * import com.pulumi.azure.monitoring.inputs.ScheduledQueryRulesAlertTriggerArgs;
 * import com.pulumi.std.StdFunctions;
 * import com.pulumi.std.inputs.FormatArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var example = new ResourceGroup("example", ResourceGroupArgs.builder()
 *             .name("monitoring-resources")
 *             .location("West Europe")
 *             .build());
 * 
 *         var exampleInsights = new Insights("exampleInsights", InsightsArgs.builder()
 *             .name("appinsights")
 *             .location(example.location())
 *             .resourceGroupName(example.name())
 *             .applicationType("web")
 *             .build());
 * 
 *         var example2 = new Insights("example2", InsightsArgs.builder()
 *             .name("appinsights2")
 *             .location(example.location())
 *             .resourceGroupName(example.name())
 *             .applicationType("web")
 *             .build());
 * 
 *         // Example: Alerting Action with result count trigger
 *         var exampleScheduledQueryRulesAlert = new ScheduledQueryRulesAlert("exampleScheduledQueryRulesAlert", ScheduledQueryRulesAlertArgs.builder()
 *             .name("example")
 *             .location(example.location())
 *             .resourceGroupName(example.name())
 *             .action(ScheduledQueryRulesAlertActionArgs.builder()
 *                 .actionGroups()
 *                 .emailSubject("Email Header")
 *                 .customWebhookPayload("{}")
 *                 .build())
 *             .dataSourceId(exampleInsights.id())
 *             .description("Alert when total results cross threshold")
 *             .enabled(true)
 *             .query("""
 * requests
 *   | where tolong(resultCode) >= 500
 *   | summarize count() by bin(timestamp, 5m)
 *             """)
 *             .severity(1)
 *             .frequency(5)
 *             .timeWindow(30)
 *             .trigger(ScheduledQueryRulesAlertTriggerArgs.builder()
 *                 .operator("GreaterThan")
 *                 .threshold(3.0)
 *                 .build())
 *             .tags(Map.of("foo", "bar"))
 *             .build());
 * 
 *         // Example: Alerting Action Cross-Resource
 *         var example2ScheduledQueryRulesAlert = new ScheduledQueryRulesAlert("example2ScheduledQueryRulesAlert", ScheduledQueryRulesAlertArgs.builder()
 *             .name("example")
 *             .location(example.location())
 *             .resourceGroupName(example.name())
 *             .authorizedResourceIds(example2.id())
 *             .action(ScheduledQueryRulesAlertActionArgs.builder()
 *                 .actionGroups()
 *                 .emailSubject("Email Header")
 *                 .customWebhookPayload("{}")
 *                 .build())
 *             .dataSourceId(exampleInsights.id())
 *             .description("Query may access data within multiple resources")
 *             .enabled(true)
 *             .query(StdFunctions.format(FormatArgs.builder()
 *                 .input("""
 * let a=requests
 *   | where toint(resultCode) >= 500
 *   | extend fail=1; let b=app('%s').requests
 *   | where toint(resultCode) >= 500 | extend fail=1; a
 *   | join b on fail
 *                 """)
 *                 .args(example2.id())
 *                 .build()).result())
 *             .severity(1)
 *             .frequency(5)
 *             .timeWindow(30)
 *             .trigger(ScheduledQueryRulesAlertTriggerArgs.builder()
 *                 .operator("GreaterThan")
 *                 .threshold(3.0)
 *                 .build())
 *             .tags(Map.of("foo", "bar"))
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ## API Providers
 * 
 * &lt;!-- This section is generated, changes will be overwritten --&gt;
 * This resource uses the following Azure API Providers:
 * 
 * * `Microsoft.Insights` - 2018-04-16
 * 
 * ## Import
 * 
 * Scheduled Query Rule Alerts can be imported using the `resource id`, e.g.
 * 
 * ```sh
 * $ pulumi import azure:monitoring/scheduledQueryRulesAlert:ScheduledQueryRulesAlert example /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/group1/providers/Microsoft.Insights/scheduledQueryRules/myrulename
 * ```
 * 
 */
@ResourceType(type="azure:monitoring/scheduledQueryRulesAlert:ScheduledQueryRulesAlert")
public class ScheduledQueryRulesAlert extends com.pulumi.resources.CustomResource {
    /**
     * An `action` block as defined below.
     * 
     */
    @Export(name="action", refs={ScheduledQueryRulesAlertAction.class}, tree="[0]")
    private Output<ScheduledQueryRulesAlertAction> action;

    /**
     * @return An `action` block as defined below.
     * 
     */
    public Output<ScheduledQueryRulesAlertAction> action() {
        return this.action;
    }
    /**
     * List of Resource IDs referred into query.
     * 
     */
    @Export(name="authorizedResourceIds", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> authorizedResourceIds;

    /**
     * @return List of Resource IDs referred into query.
     * 
     */
    public Output<Optional<List<String>>> authorizedResourceIds() {
        return Codegen.optional(this.authorizedResourceIds);
    }
    /**
     * Should the alerts in this Metric Alert be auto resolved? Defaults to `false`.
     * &gt; **Note:** `autoMitigationEnabled` and `throttling` are mutually exclusive and cannot both be set.
     * 
     */
    @Export(name="autoMitigationEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> autoMitigationEnabled;

    /**
     * @return Should the alerts in this Metric Alert be auto resolved? Defaults to `false`.
     * &gt; **Note:** `autoMitigationEnabled` and `throttling` are mutually exclusive and cannot both be set.
     * 
     */
    public Output<Optional<Boolean>> autoMitigationEnabled() {
        return Codegen.optional(this.autoMitigationEnabled);
    }
    /**
     * The resource URI over which log search query is to be run. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="dataSourceId", refs={String.class}, tree="[0]")
    private Output<String> dataSourceId;

    /**
     * @return The resource URI over which log search query is to be run. Changing this forces a new resource to be created.
     * 
     */
    public Output<String> dataSourceId() {
        return this.dataSourceId;
    }
    /**
     * The description of the scheduled query rule.
     * 
     */
    @Export(name="description", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> description;

    /**
     * @return The description of the scheduled query rule.
     * 
     */
    public Output<Optional<String>> description() {
        return Codegen.optional(this.description);
    }
    /**
     * Whether this scheduled query rule is enabled. Default is `true`.
     * 
     */
    @Export(name="enabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> enabled;

    /**
     * @return Whether this scheduled query rule is enabled. Default is `true`.
     * 
     */
    public Output<Optional<Boolean>> enabled() {
        return Codegen.optional(this.enabled);
    }
    /**
     * Frequency (in minutes) at which rule condition should be evaluated. Values must be between 5 and 1440 (inclusive).
     * 
     */
    @Export(name="frequency", refs={Integer.class}, tree="[0]")
    private Output<Integer> frequency;

    /**
     * @return Frequency (in minutes) at which rule condition should be evaluated. Values must be between 5 and 1440 (inclusive).
     * 
     */
    public Output<Integer> frequency() {
        return this.frequency;
    }
    /**
     * Specifies the Azure Region where the resource should exist. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="location", refs={String.class}, tree="[0]")
    private Output<String> location;

    /**
     * @return Specifies the Azure Region where the resource should exist. Changing this forces a new resource to be created.
     * 
     */
    public Output<String> location() {
        return this.location;
    }
    /**
     * The name of the scheduled query rule. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    /**
     * @return The name of the scheduled query rule. Changing this forces a new resource to be created.
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * Log search query.
     * 
     */
    @Export(name="query", refs={String.class}, tree="[0]")
    private Output<String> query;

    /**
     * @return Log search query.
     * 
     */
    public Output<String> query() {
        return this.query;
    }
    /**
     * The type of query results. Possible values are `ResultCount` and `Number`. Default is `ResultCount`. If set to `ResultCount`, `query` must include an `AggregatedValue` column of a numeric type, for example, `Heartbeat | summarize AggregatedValue = count() by bin(TimeGenerated, 5m)`.
     * 
     */
    @Export(name="queryType", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> queryType;

    /**
     * @return The type of query results. Possible values are `ResultCount` and `Number`. Default is `ResultCount`. If set to `ResultCount`, `query` must include an `AggregatedValue` column of a numeric type, for example, `Heartbeat | summarize AggregatedValue = count() by bin(TimeGenerated, 5m)`.
     * 
     */
    public Output<Optional<String>> queryType() {
        return Codegen.optional(this.queryType);
    }
    /**
     * The name of the resource group in which to create the scheduled query rule instance. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="resourceGroupName", refs={String.class}, tree="[0]")
    private Output<String> resourceGroupName;

    /**
     * @return The name of the resource group in which to create the scheduled query rule instance. Changing this forces a new resource to be created.
     * 
     */
    public Output<String> resourceGroupName() {
        return this.resourceGroupName;
    }
    /**
     * Severity of the alert. Possible values include: 0, 1, 2, 3, or 4.
     * 
     */
    @Export(name="severity", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> severity;

    /**
     * @return Severity of the alert. Possible values include: 0, 1, 2, 3, or 4.
     * 
     */
    public Output<Optional<Integer>> severity() {
        return Codegen.optional(this.severity);
    }
    /**
     * A mapping of tags to assign to the resource.
     * 
     */
    @Export(name="tags", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output</* @Nullable */ Map<String,String>> tags;

    /**
     * @return A mapping of tags to assign to the resource.
     * 
     */
    public Output<Optional<Map<String,String>>> tags() {
        return Codegen.optional(this.tags);
    }
    /**
     * Time (in minutes) for which Alerts should be throttled or suppressed. Values must be between 0 and 10000 (inclusive).
     * 
     */
    @Export(name="throttling", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> throttling;

    /**
     * @return Time (in minutes) for which Alerts should be throttled or suppressed. Values must be between 0 and 10000 (inclusive).
     * 
     */
    public Output<Optional<Integer>> throttling() {
        return Codegen.optional(this.throttling);
    }
    /**
     * Time window for which data needs to be fetched for query (must be greater than or equal to `frequency`). Values must be between 5 and 2880 (inclusive).
     * 
     */
    @Export(name="timeWindow", refs={Integer.class}, tree="[0]")
    private Output<Integer> timeWindow;

    /**
     * @return Time window for which data needs to be fetched for query (must be greater than or equal to `frequency`). Values must be between 5 and 2880 (inclusive).
     * 
     */
    public Output<Integer> timeWindow() {
        return this.timeWindow;
    }
    /**
     * A `trigger` block as defined below.
     * 
     */
    @Export(name="trigger", refs={ScheduledQueryRulesAlertTrigger.class}, tree="[0]")
    private Output<ScheduledQueryRulesAlertTrigger> trigger;

    /**
     * @return A `trigger` block as defined below.
     * 
     */
    public Output<ScheduledQueryRulesAlertTrigger> trigger() {
        return this.trigger;
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public ScheduledQueryRulesAlert(java.lang.String name) {
        this(name, ScheduledQueryRulesAlertArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public ScheduledQueryRulesAlert(java.lang.String name, ScheduledQueryRulesAlertArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public ScheduledQueryRulesAlert(java.lang.String name, ScheduledQueryRulesAlertArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("azure:monitoring/scheduledQueryRulesAlert:ScheduledQueryRulesAlert", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private ScheduledQueryRulesAlert(java.lang.String name, Output<java.lang.String> id, @Nullable ScheduledQueryRulesAlertState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("azure:monitoring/scheduledQueryRulesAlert:ScheduledQueryRulesAlert", name, state, makeResourceOptions(options, id), false);
    }

    private static ScheduledQueryRulesAlertArgs makeArgs(ScheduledQueryRulesAlertArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? ScheduledQueryRulesAlertArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static ScheduledQueryRulesAlert get(java.lang.String name, Output<java.lang.String> id, @Nullable ScheduledQueryRulesAlertState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new ScheduledQueryRulesAlert(name, id, state, options);
    }
}
