// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.azure.search;

import com.pulumi.azure.Utilities;
import com.pulumi.azure.search.ServiceArgs;
import com.pulumi.azure.search.inputs.ServiceState;
import com.pulumi.azure.search.outputs.ServiceIdentity;
import com.pulumi.azure.search.outputs.ServiceQueryKey;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * Manages a Search Service.
 * 
 * ## Example Usage
 * 
 * ### Supporting API Keys)
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.azure.core.ResourceGroup;
 * import com.pulumi.azure.core.ResourceGroupArgs;
 * import com.pulumi.azure.search.Service;
 * import com.pulumi.azure.search.ServiceArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var example = new ResourceGroup("example", ResourceGroupArgs.builder()
 *             .name("example-resources")
 *             .location("West Europe")
 *             .build());
 * 
 *         var exampleService = new Service("exampleService", ServiceArgs.builder()
 *             .name("example-resource")
 *             .resourceGroupName(example.name())
 *             .location(example.location())
 *             .sku("standard")
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ### Using Both AzureAD And API Keys)
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.azure.core.ResourceGroup;
 * import com.pulumi.azure.core.ResourceGroupArgs;
 * import com.pulumi.azure.search.Service;
 * import com.pulumi.azure.search.ServiceArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var example = new ResourceGroup("example", ResourceGroupArgs.builder()
 *             .name("example-resources")
 *             .location("West Europe")
 *             .build());
 * 
 *         var exampleService = new Service("exampleService", ServiceArgs.builder()
 *             .name("example-resource")
 *             .resourceGroupName(example.name())
 *             .location(example.location())
 *             .sku("standard")
 *             .localAuthenticationEnabled(true)
 *             .authenticationFailureMode("http403")
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ### Supporting Only AzureAD Authentication)
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.azure.core.ResourceGroup;
 * import com.pulumi.azure.core.ResourceGroupArgs;
 * import com.pulumi.azure.search.Service;
 * import com.pulumi.azure.search.ServiceArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var example = new ResourceGroup("example", ResourceGroupArgs.builder()
 *             .name("example-resources")
 *             .location("West Europe")
 *             .build());
 * 
 *         var exampleService = new Service("exampleService", ServiceArgs.builder()
 *             .name("example-resource")
 *             .resourceGroupName(example.name())
 *             .location(example.location())
 *             .sku("standard")
 *             .localAuthenticationEnabled(false)
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ## API Providers
 * 
 * &lt;!-- This section is generated, changes will be overwritten --&gt;
 * This resource uses the following Azure API Providers:
 * 
 * * `Microsoft.Search` - 2024-06-01-preview
 * 
 * ## Import
 * 
 * Search Services can be imported using the `resource id`, e.g.
 * 
 * ```sh
 * $ pulumi import azure:search/service:Service example /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/group1/providers/Microsoft.Search/searchServices/service1
 * ```
 * 
 */
@ResourceType(type="azure:search/service:Service")
public class Service extends com.pulumi.resources.CustomResource {
    /**
     * Specifies a list of inbound IPv4 or CIDRs that are allowed to access the Search Service. If the incoming IP request is from an IP address which is not included in the `allowed_ips` it will be blocked by the Search Services firewall.
     * 
     * &gt; **Note:** The `allowed_ips` are only applied if the `public_network_access_enabled` field has been set to `true`, else all traffic over the public interface will be rejected, even if the `allowed_ips` field has been defined. When the `public_network_access_enabled` field has been set to `false` the private endpoint connections are the only allowed access point to the Search Service.
     * 
     */
    @Export(name="allowedIps", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> allowedIps;

    /**
     * @return Specifies a list of inbound IPv4 or CIDRs that are allowed to access the Search Service. If the incoming IP request is from an IP address which is not included in the `allowed_ips` it will be blocked by the Search Services firewall.
     * 
     * &gt; **Note:** The `allowed_ips` are only applied if the `public_network_access_enabled` field has been set to `true`, else all traffic over the public interface will be rejected, even if the `allowed_ips` field has been defined. When the `public_network_access_enabled` field has been set to `false` the private endpoint connections are the only allowed access point to the Search Service.
     * 
     */
    public Output<Optional<List<String>>> allowedIps() {
        return Codegen.optional(this.allowedIps);
    }
    /**
     * Specifies the response that the Search Service should return for requests that fail authentication. Possible values include `http401WithBearerChallenge` or `http403`.
     * 
     * &gt; **Note:** `authentication_failure_mode` can only be configured when using `local_authentication_enabled` is set to `true` - which when set together specifies that both API Keys and AzureAD Authentication should be supported.
     * 
     */
    @Export(name="authenticationFailureMode", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> authenticationFailureMode;

    /**
     * @return Specifies the response that the Search Service should return for requests that fail authentication. Possible values include `http401WithBearerChallenge` or `http403`.
     * 
     * &gt; **Note:** `authentication_failure_mode` can only be configured when using `local_authentication_enabled` is set to `true` - which when set together specifies that both API Keys and AzureAD Authentication should be supported.
     * 
     */
    public Output<Optional<String>> authenticationFailureMode() {
        return Codegen.optional(this.authenticationFailureMode);
    }
    /**
     * Describes whether the search service is compliant or not with respect to having non-customer encrypted resources. If a service has more than one non-customer encrypted resource and `Enforcement` is `enabled` then the service will be marked as `NonCompliant`. If all the resources are customer encrypted, then the service will be marked as `Compliant`.
     * 
     */
    @Export(name="customerManagedKeyEncryptionComplianceStatus", refs={String.class}, tree="[0]")
    private Output<String> customerManagedKeyEncryptionComplianceStatus;

    /**
     * @return Describes whether the search service is compliant or not with respect to having non-customer encrypted resources. If a service has more than one non-customer encrypted resource and `Enforcement` is `enabled` then the service will be marked as `NonCompliant`. If all the resources are customer encrypted, then the service will be marked as `Compliant`.
     * 
     */
    public Output<String> customerManagedKeyEncryptionComplianceStatus() {
        return this.customerManagedKeyEncryptionComplianceStatus;
    }
    /**
     * Specifies whether the Search Service should enforce that non-customer resources are encrypted. Defaults to `false`.
     * 
     */
    @Export(name="customerManagedKeyEnforcementEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> customerManagedKeyEnforcementEnabled;

    /**
     * @return Specifies whether the Search Service should enforce that non-customer resources are encrypted. Defaults to `false`.
     * 
     */
    public Output<Optional<Boolean>> customerManagedKeyEnforcementEnabled() {
        return Codegen.optional(this.customerManagedKeyEnforcementEnabled);
    }
    /**
     * Specifies the Hosting Mode, which allows for High Density partitions (that allow for up to 1000 indexes) should be supported. Possible values are `highDensity` or `default`. Defaults to `default`. Changing this forces a new Search Service to be created.
     * 
     * &gt; **Note:** `hosting_mode` can only be configured when `sku` is set to `standard3`.
     * 
     */
    @Export(name="hostingMode", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> hostingMode;

    /**
     * @return Specifies the Hosting Mode, which allows for High Density partitions (that allow for up to 1000 indexes) should be supported. Possible values are `highDensity` or `default`. Defaults to `default`. Changing this forces a new Search Service to be created.
     * 
     * &gt; **Note:** `hosting_mode` can only be configured when `sku` is set to `standard3`.
     * 
     */
    public Output<Optional<String>> hostingMode() {
        return Codegen.optional(this.hostingMode);
    }
    /**
     * An `identity` block as defined below.
     * 
     */
    @Export(name="identity", refs={ServiceIdentity.class}, tree="[0]")
    private Output</* @Nullable */ ServiceIdentity> identity;

    /**
     * @return An `identity` block as defined below.
     * 
     */
    public Output<Optional<ServiceIdentity>> identity() {
        return Codegen.optional(this.identity);
    }
    /**
     * Specifies whether the Search Service allows authenticating using API Keys? Defaults to `true`.
     * 
     */
    @Export(name="localAuthenticationEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> localAuthenticationEnabled;

    /**
     * @return Specifies whether the Search Service allows authenticating using API Keys? Defaults to `true`.
     * 
     */
    public Output<Optional<Boolean>> localAuthenticationEnabled() {
        return Codegen.optional(this.localAuthenticationEnabled);
    }
    /**
     * The Azure Region where the Search Service should exist. Changing this forces a new Search Service to be created.
     * 
     */
    @Export(name="location", refs={String.class}, tree="[0]")
    private Output<String> location;

    /**
     * @return The Azure Region where the Search Service should exist. Changing this forces a new Search Service to be created.
     * 
     */
    public Output<String> location() {
        return this.location;
    }
    /**
     * The Name which should be used for this Search Service. Changing this forces a new Search Service to be created.
     * 
     */
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    /**
     * @return The Name which should be used for this Search Service. Changing this forces a new Search Service to be created.
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * Whether to allow trusted Azure services to access a network restricted Container Registry? Possible values are `None` and `AzureServices`. Defaults to `None`.
     * 
     */
    @Export(name="networkRuleBypassOption", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> networkRuleBypassOption;

    /**
     * @return Whether to allow trusted Azure services to access a network restricted Container Registry? Possible values are `None` and `AzureServices`. Defaults to `None`.
     * 
     */
    public Output<Optional<String>> networkRuleBypassOption() {
        return Codegen.optional(this.networkRuleBypassOption);
    }
    /**
     * Specifies the number of partitions which should be created. This field cannot be set when using a `free` sku ([see the Microsoft documentation](https://learn.microsoft.com/azure/search/search-sku-tier)). Possible values include `1`, `2`, `3`, `4`, `6`, or `12`. Defaults to `1`.
     * 
     * &gt; **Note:** when `hosting_mode` is set to `highDensity` the maximum number of partitions allowed is `3`.
     * 
     */
    @Export(name="partitionCount", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> partitionCount;

    /**
     * @return Specifies the number of partitions which should be created. This field cannot be set when using a `free` sku ([see the Microsoft documentation](https://learn.microsoft.com/azure/search/search-sku-tier)). Possible values include `1`, `2`, `3`, `4`, `6`, or `12`. Defaults to `1`.
     * 
     * &gt; **Note:** when `hosting_mode` is set to `highDensity` the maximum number of partitions allowed is `3`.
     * 
     */
    public Output<Optional<Integer>> partitionCount() {
        return Codegen.optional(this.partitionCount);
    }
    /**
     * The Primary Key used for Search Service Administration.
     * 
     */
    @Export(name="primaryKey", refs={String.class}, tree="[0]")
    private Output<String> primaryKey;

    /**
     * @return The Primary Key used for Search Service Administration.
     * 
     */
    public Output<String> primaryKey() {
        return this.primaryKey;
    }
    /**
     * Specifies whether Public Network Access is allowed for this resource. Defaults to `true`.
     * 
     */
    @Export(name="publicNetworkAccessEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> publicNetworkAccessEnabled;

    /**
     * @return Specifies whether Public Network Access is allowed for this resource. Defaults to `true`.
     * 
     */
    public Output<Optional<Boolean>> publicNetworkAccessEnabled() {
        return Codegen.optional(this.publicNetworkAccessEnabled);
    }
    /**
     * A `query_keys` block as defined below.
     * 
     */
    @Export(name="queryKeys", refs={List.class,ServiceQueryKey.class}, tree="[0,1]")
    private Output<List<ServiceQueryKey>> queryKeys;

    /**
     * @return A `query_keys` block as defined below.
     * 
     */
    public Output<List<ServiceQueryKey>> queryKeys() {
        return this.queryKeys;
    }
    /**
     * Specifies the number of Replica&#39;s which should be created for this Search Service. This field cannot be set when using a `free` sku ([see the Microsoft documentation](https://learn.microsoft.com/azure/search/search-sku-tier)).
     * 
     */
    @Export(name="replicaCount", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> replicaCount;

    /**
     * @return Specifies the number of Replica&#39;s which should be created for this Search Service. This field cannot be set when using a `free` sku ([see the Microsoft documentation](https://learn.microsoft.com/azure/search/search-sku-tier)).
     * 
     */
    public Output<Optional<Integer>> replicaCount() {
        return Codegen.optional(this.replicaCount);
    }
    /**
     * The name of the Resource Group where the Search Service should exist. Changing this forces a new Search Service to be created.
     * 
     */
    @Export(name="resourceGroupName", refs={String.class}, tree="[0]")
    private Output<String> resourceGroupName;

    /**
     * @return The name of the Resource Group where the Search Service should exist. Changing this forces a new Search Service to be created.
     * 
     */
    public Output<String> resourceGroupName() {
        return this.resourceGroupName;
    }
    /**
     * The Secondary Key used for Search Service Administration.
     * 
     */
    @Export(name="secondaryKey", refs={String.class}, tree="[0]")
    private Output<String> secondaryKey;

    /**
     * @return The Secondary Key used for Search Service Administration.
     * 
     */
    public Output<String> secondaryKey() {
        return this.secondaryKey;
    }
    /**
     * Specifies the Semantic Search SKU which should be used for this Search Service. Possible values include `free` and `standard`.
     * 
     * &gt; **Note:** The `semantic_search_sku` cannot be defined if your Search Services `sku` is set to `free`. The Semantic Search feature is only available in certain regions, please see the [product documentation](https://learn.microsoft.com/azure/search/semantic-search-overview#availability-and-pricing) for more information.
     * 
     */
    @Export(name="semanticSearchSku", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> semanticSearchSku;

    /**
     * @return Specifies the Semantic Search SKU which should be used for this Search Service. Possible values include `free` and `standard`.
     * 
     * &gt; **Note:** The `semantic_search_sku` cannot be defined if your Search Services `sku` is set to `free`. The Semantic Search feature is only available in certain regions, please see the [product documentation](https://learn.microsoft.com/azure/search/semantic-search-overview#availability-and-pricing) for more information.
     * 
     */
    public Output<Optional<String>> semanticSearchSku() {
        return Codegen.optional(this.semanticSearchSku);
    }
    /**
     * The SKU which should be used for this Search Service. Possible values include `basic`, `free`, `standard`, `standard2`, `standard3`, `storage_optimized_l1` and `storage_optimized_l2`. Changing this forces a new Search Service to be created.
     * 
     * &gt; **Note:** The `basic` and `free` SKUs provision the Search Service in a Shared Cluster - the `standard` SKUs use a Dedicated Cluster.
     * 
     * &gt; **Note:** The SKUs `standard2`, `standard3`, `storage_optimized_l1` and `storage_optimized_l2` are only available by submitting a quota increase request to Microsoft. Please see the [product documentation](https://learn.microsoft.com/azure/azure-resource-manager/troubleshooting/error-resource-quota?tabs=azure-cli) on how to submit a quota increase request.
     * 
     */
    @Export(name="sku", refs={String.class}, tree="[0]")
    private Output<String> sku;

    /**
     * @return The SKU which should be used for this Search Service. Possible values include `basic`, `free`, `standard`, `standard2`, `standard3`, `storage_optimized_l1` and `storage_optimized_l2`. Changing this forces a new Search Service to be created.
     * 
     * &gt; **Note:** The `basic` and `free` SKUs provision the Search Service in a Shared Cluster - the `standard` SKUs use a Dedicated Cluster.
     * 
     * &gt; **Note:** The SKUs `standard2`, `standard3`, `storage_optimized_l1` and `storage_optimized_l2` are only available by submitting a quota increase request to Microsoft. Please see the [product documentation](https://learn.microsoft.com/azure/azure-resource-manager/troubleshooting/error-resource-quota?tabs=azure-cli) on how to submit a quota increase request.
     * 
     */
    public Output<String> sku() {
        return this.sku;
    }
    /**
     * Specifies a mapping of tags which should be assigned to this Search Service.
     * 
     */
    @Export(name="tags", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output</* @Nullable */ Map<String,String>> tags;

    /**
     * @return Specifies a mapping of tags which should be assigned to this Search Service.
     * 
     */
    public Output<Optional<Map<String,String>>> tags() {
        return Codegen.optional(this.tags);
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public Service(java.lang.String name) {
        this(name, ServiceArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public Service(java.lang.String name, ServiceArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public Service(java.lang.String name, ServiceArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("azure:search/service:Service", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private Service(java.lang.String name, Output<java.lang.String> id, @Nullable ServiceState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("azure:search/service:Service", name, state, makeResourceOptions(options, id), false);
    }

    private static ServiceArgs makeArgs(ServiceArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? ServiceArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .additionalSecretOutputs(List.of(
                "primaryKey",
                "secondaryKey"
            ))
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static Service get(java.lang.String name, Output<java.lang.String> id, @Nullable ServiceState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new Service(name, id, state, options);
    }
}
