// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.azure.siterecovery;

import com.pulumi.azure.Utilities;
import com.pulumi.azure.siterecovery.VmwareReplicatedVmArgs;
import com.pulumi.azure.siterecovery.inputs.VmwareReplicatedVmState;
import com.pulumi.azure.siterecovery.outputs.VmwareReplicatedVmManagedDisk;
import com.pulumi.azure.siterecovery.outputs.VmwareReplicatedVmNetworkInterface;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import java.lang.String;
import java.util.List;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * Manages a VMWare replicated VM using Azure Site Recovery (VMWare to Azure only). A replicated VM keeps a copiously updated image of the VM in Azure in order to be able to start the VM in Azure in case of a disaster.
 * 
 * ## Example Usage
 * ```java
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.azure.core.ResourceGroup;
 * import com.pulumi.azure.core.ResourceGroupArgs;
 * import com.pulumi.azure.recoveryservices_vault.Vault;
 * import com.pulumi.azure.recoveryservices_vault.VaultArgs;
 * import com.pulumi.azure.siterecovery_vMWareReplicationPolicy.VMWareReplicationPolicy;
 * import com.pulumi.azure.siterecovery_vMWareReplicationPolicy.VMWareReplicationPolicyArgs;
 * import com.pulumi.azure.siterecovery_vmwareReplicationPolicyAssociation.VmwareReplicationPolicyAssociation;
 * import com.pulumi.azure.siterecovery_vmwareReplicationPolicyAssociation.VmwareReplicationPolicyAssociationArgs;
 * import com.pulumi.azure.storage.Account;
 * import com.pulumi.azure.storage.AccountArgs;
 * import com.pulumi.azure.network_virtualNetwork.VirtualNetwork;
 * import com.pulumi.azure.network_virtualNetwork.VirtualNetworkArgs;
 * import com.pulumi.azure.network.Subnet;
 * import com.pulumi.azure.network.SubnetArgs;
 * import com.pulumi.azure.siterecovery_vmwareReplicatedVm.VmwareReplicatedVm;
 * import com.pulumi.azure.siterecovery_vmwareReplicatedVm.VmwareReplicatedVmArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var example = new ResourceGroup(&#34;example&#34;, ResourceGroupArgs.builder()        
 *             .name(&#34;example-rg&#34;)
 *             .location(&#34;West US&#34;)
 *             .build());
 * 
 *         var exampleVault = new Vault(&#34;exampleVault&#34;, VaultArgs.builder()        
 *             .name(&#34;example-recovery-vault&#34;)
 *             .location(example.location())
 *             .resourceGroupName(example.name())
 *             .sku(&#34;Standard&#34;)
 *             .build());
 * 
 *         var exampleVMWareReplicationPolicy = new VMWareReplicationPolicy(&#34;exampleVMWareReplicationPolicy&#34;, VMWareReplicationPolicyArgs.builder()        
 *             .recoveryVaultId(exampleVault.id())
 *             .name(&#34;example-policy&#34;)
 *             .recoveryPointRetentionInMinutes(1440)
 *             .applicationConsistentSnapshotFrequencyInMinutes(240)
 *             .build());
 * 
 *         var test = new VmwareReplicationPolicyAssociation(&#34;test&#34;, VmwareReplicationPolicyAssociationArgs.builder()        
 *             .name(&#34;example-association&#34;)
 *             .recoveryVaultId(exampleVault.id())
 *             .policyId(exampleVMWareReplicationPolicy.id())
 *             .build());
 * 
 *         var exampleAccount = new Account(&#34;exampleAccount&#34;, AccountArgs.builder()        
 *             .name(&#34;examplestorageacc&#34;)
 *             .resourceGroupName(example.name())
 *             .location(example.location())
 *             .accountTier(&#34;Standard&#34;)
 *             .accountKind(&#34;StorageV2&#34;)
 *             .accountReplicationType(&#34;LRS&#34;)
 *             .build());
 * 
 *         var exampleVirtualNetwork = new VirtualNetwork(&#34;exampleVirtualNetwork&#34;, VirtualNetworkArgs.builder()        
 *             .name(&#34;example-net&#34;)
 *             .resourceGroupName(example.name())
 *             .addressSpaces(&#34;192.168.2.0/24&#34;)
 *             .location(example.location())
 *             .build());
 * 
 *         var exampleSubnet = new Subnet(&#34;exampleSubnet&#34;, SubnetArgs.builder()        
 *             .name(&#34;example-subnet&#34;)
 *             .resourceGroupName(example.name())
 *             .virtualNetworkName(exampleVirtualNetwork.name())
 *             .addressPrefixes(&#34;192.168.2.0/24&#34;)
 *             .build());
 * 
 *         var exampleVmwareReplicatedVm = new VmwareReplicatedVm(&#34;exampleVmwareReplicatedVm&#34;, VmwareReplicatedVmArgs.builder()        
 *             .name(&#34;example-vmware-vm&#34;)
 *             .recoveryVaultId(exampleVault.id())
 *             .sourceVmName(&#34;example-vm&#34;)
 *             .applianceName(&#34;example-appliance&#34;)
 *             .recoveryReplicationPolicyId(exampleAzurermSiteRecoveryVmwareReplicationPolicyAssociation.policyId())
 *             .physicalServerCredentialName(&#34;example-creds&#34;)
 *             .licenseType(&#34;NotSpecified&#34;)
 *             .targetBootDiagnosticsStorageAccountId(exampleAccount.id())
 *             .targetVmName(&#34;example_replicated_vm&#34;)
 *             .targetResourceGroupId(example.id())
 *             .defaultLogStorageAccountId(exampleAccount.id())
 *             .defaultRecoveryDiskType(&#34;Standard_LRS&#34;)
 *             .targetNetworkId(exampleVirtualNetwork.id())
 *             .networkInterfaces(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
 *             .build());
 * 
 *     }
 * }
 * ```
 * 
 * ## Import
 * 
 * Site Recovery VMWare Replicated VM&#39;s can be imported using the `resource id`, e.g.
 * 
 * ```sh
 * $ pulumi import azure:siterecovery/vmwareReplicatedVm:VmwareReplicatedVm vmreplication /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/resource-group-name/providers/Microsoft.RecoveryServices/vaults/recovery-vault-name/replicationFabrics/fabric-name/replicationProtectionContainers/protection-container-name/replicationProtectedItems/vm-replication-name
 * ```
 * 
 */
@ResourceType(type="azure:siterecovery/vmwareReplicatedVm:VmwareReplicatedVm")
public class VmwareReplicatedVm extends com.pulumi.resources.CustomResource {
    /**
     * The name of VMWare appliance which handles the replication. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="applianceName", refs={String.class}, tree="[0]")
    private Output<String> applianceName;

    /**
     * @return The name of VMWare appliance which handles the replication. Changing this forces a new resource to be created.
     * 
     */
    public Output<String> applianceName() {
        return this.applianceName;
    }
    /**
     * The ID of the stroage account that should be used for logging during replication.
     * 
     * **Note:** Only standard types of storage accounts are allowed.
     * 
     * **Note:** Only one of `default_log_storage_account_id` or `managed_disk` must be specified.
     * 
     * **Note:** Changing `default_log_storage_account_id` forces a new resource to be created. But removing it does not.
     * 
     * **Note:** When `default_log_storage_account_id` co-exist with `managed_disk`, the value of `default_log_storage_account_id` must be as same as `log_storage_account_id` of every `managed_disk` or it forces a new resource to be created.
     * 
     */
    @Export(name="defaultLogStorageAccountId", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> defaultLogStorageAccountId;

    /**
     * @return The ID of the stroage account that should be used for logging during replication.
     * 
     * **Note:** Only standard types of storage accounts are allowed.
     * 
     * **Note:** Only one of `default_log_storage_account_id` or `managed_disk` must be specified.
     * 
     * **Note:** Changing `default_log_storage_account_id` forces a new resource to be created. But removing it does not.
     * 
     * **Note:** When `default_log_storage_account_id` co-exist with `managed_disk`, the value of `default_log_storage_account_id` must be as same as `log_storage_account_id` of every `managed_disk` or it forces a new resource to be created.
     * 
     */
    public Output<Optional<String>> defaultLogStorageAccountId() {
        return Codegen.optional(this.defaultLogStorageAccountId);
    }
    /**
     * The type of storage account that should be used for recovery disks when a failover is done. Possible values are `Standard_LRS`, `Standard_LRS` and `StandardSSD_LRS`.
     * 
     * **Note:** Only one of `default_recovery_disk_type` or `managed_disk` must be specified.
     * 
     * **Note:** Changing `default_recovery_disk_type` forces a new resource to be created. But removing it does not.
     * 
     * **Note:** When `default_recovery_disk_type` co-exist with `managed_disk`, the value of `default_recovery_disk_type` must be as same as `target_disk_type` of every `managed_disk` or it forces a new resource to be created.
     * 
     */
    @Export(name="defaultRecoveryDiskType", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> defaultRecoveryDiskType;

    /**
     * @return The type of storage account that should be used for recovery disks when a failover is done. Possible values are `Standard_LRS`, `Standard_LRS` and `StandardSSD_LRS`.
     * 
     * **Note:** Only one of `default_recovery_disk_type` or `managed_disk` must be specified.
     * 
     * **Note:** Changing `default_recovery_disk_type` forces a new resource to be created. But removing it does not.
     * 
     * **Note:** When `default_recovery_disk_type` co-exist with `managed_disk`, the value of `default_recovery_disk_type` must be as same as `target_disk_type` of every `managed_disk` or it forces a new resource to be created.
     * 
     */
    public Output<Optional<String>> defaultRecoveryDiskType() {
        return Codegen.optional(this.defaultRecoveryDiskType);
    }
    /**
     * The ID of the default Disk Encryption Set that should be used for the disks when a failover is done.
     * 
     * **Note:** Changing `default_target_disk_encryption_set_id` forces a new resource to be created. But removing it does not.
     * 
     * **Note:** When `default_target_disk_encryption_set_id` co-exist with `managed_disk`, the value of `default_target_disk_encryption_set_id` must be as same as `target_disk_encryption_set_id` of every `managed_disk` or it forces a new resource to be created.
     * 
     */
    @Export(name="defaultTargetDiskEncryptionSetId", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> defaultTargetDiskEncryptionSetId;

    /**
     * @return The ID of the default Disk Encryption Set that should be used for the disks when a failover is done.
     * 
     * **Note:** Changing `default_target_disk_encryption_set_id` forces a new resource to be created. But removing it does not.
     * 
     * **Note:** When `default_target_disk_encryption_set_id` co-exist with `managed_disk`, the value of `default_target_disk_encryption_set_id` must be as same as `target_disk_encryption_set_id` of every `managed_disk` or it forces a new resource to be created.
     * 
     */
    public Output<Optional<String>> defaultTargetDiskEncryptionSetId() {
        return Codegen.optional(this.defaultTargetDiskEncryptionSetId);
    }
    /**
     * The license type of the VM. Possible values are `NoLicenseType`, `NotSpecified` and `WindowsServer`. Defaults to `NotSpecified`.
     * 
     */
    @Export(name="licenseType", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> licenseType;

    /**
     * @return The license type of the VM. Possible values are `NoLicenseType`, `NotSpecified` and `WindowsServer`. Defaults to `NotSpecified`.
     * 
     */
    public Output<Optional<String>> licenseType() {
        return Codegen.optional(this.licenseType);
    }
    /**
     * One or more `managed_disk` block as defined below. It&#39;s available only if mobility service is already installed on the source VM.
     * 
     * **Note:** A replicated VM could be created without `managed_disk` block, once the block has been specified, changing it expect removing it forces a new resource to be created.
     * 
     */
    @Export(name="managedDisks", refs={List.class,VmwareReplicatedVmManagedDisk.class}, tree="[0,1]")
    private Output</* @Nullable */ List<VmwareReplicatedVmManagedDisk>> managedDisks;

    /**
     * @return One or more `managed_disk` block as defined below. It&#39;s available only if mobility service is already installed on the source VM.
     * 
     * **Note:** A replicated VM could be created without `managed_disk` block, once the block has been specified, changing it expect removing it forces a new resource to be created.
     * 
     */
    public Output<Optional<List<VmwareReplicatedVmManagedDisk>>> managedDisks() {
        return Codegen.optional(this.managedDisks);
    }
    /**
     * Name of group in which all machines will replicate together and have shared crash consistent and app-consistent recovery points when failed over. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="multiVmGroupName", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> multiVmGroupName;

    /**
     * @return Name of group in which all machines will replicate together and have shared crash consistent and app-consistent recovery points when failed over. Changing this forces a new resource to be created.
     * 
     */
    public Output<Optional<String>> multiVmGroupName() {
        return Codegen.optional(this.multiVmGroupName);
    }
    /**
     * The name of the replicated VM. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    /**
     * @return The name of the replicated VM. Changing this forces a new resource to be created.
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * One or more `network_interface` block as defined below.
     * 
     */
    @Export(name="networkInterfaces", refs={List.class,VmwareReplicatedVmNetworkInterface.class}, tree="[0,1]")
    private Output</* @Nullable */ List<VmwareReplicatedVmNetworkInterface>> networkInterfaces;

    /**
     * @return One or more `network_interface` block as defined below.
     * 
     */
    public Output<Optional<List<VmwareReplicatedVmNetworkInterface>>> networkInterfaces() {
        return Codegen.optional(this.networkInterfaces);
    }
    /**
     * The name of the credential to access the source VM. Changing this forces a new resource to be created. More information about the credentials could be found [here](https://learn.microsoft.com/en-us/azure/site-recovery/deploy-vmware-azure-replication-appliance-modernized).
     * 
     */
    @Export(name="physicalServerCredentialName", refs={String.class}, tree="[0]")
    private Output<String> physicalServerCredentialName;

    /**
     * @return The name of the credential to access the source VM. Changing this forces a new resource to be created. More information about the credentials could be found [here](https://learn.microsoft.com/en-us/azure/site-recovery/deploy-vmware-azure-replication-appliance-modernized).
     * 
     */
    public Output<String> physicalServerCredentialName() {
        return this.physicalServerCredentialName;
    }
    /**
     * The ID of the policy to use for this replicated VM. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="recoveryReplicationPolicyId", refs={String.class}, tree="[0]")
    private Output<String> recoveryReplicationPolicyId;

    /**
     * @return The ID of the policy to use for this replicated VM. Changing this forces a new resource to be created.
     * 
     */
    public Output<String> recoveryReplicationPolicyId() {
        return this.recoveryReplicationPolicyId;
    }
    /**
     * The ID of the Recovery Services Vault where the replicated VM is created. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="recoveryVaultId", refs={String.class}, tree="[0]")
    private Output<String> recoveryVaultId;

    /**
     * @return The ID of the Recovery Services Vault where the replicated VM is created. Changing this forces a new resource to be created.
     * 
     */
    public Output<String> recoveryVaultId() {
        return this.recoveryVaultId;
    }
    /**
     * The name of the source VM in VMWare. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="sourceVmName", refs={String.class}, tree="[0]")
    private Output<String> sourceVmName;

    /**
     * @return The name of the source VM in VMWare. Changing this forces a new resource to be created.
     * 
     */
    public Output<String> sourceVmName() {
        return this.sourceVmName;
    }
    /**
     * The ID of availability set that the new VM should belong to when a failover is done. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="targetAvailabilitySetId", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> targetAvailabilitySetId;

    /**
     * @return The ID of availability set that the new VM should belong to when a failover is done. Changing this forces a new resource to be created.
     * 
     */
    public Output<Optional<String>> targetAvailabilitySetId() {
        return Codegen.optional(this.targetAvailabilitySetId);
    }
    /**
     * The ID of the storage account that should be used for boot diagnostics when a failover is done.
     * 
     */
    @Export(name="targetBootDiagnosticsStorageAccountId", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> targetBootDiagnosticsStorageAccountId;

    /**
     * @return The ID of the storage account that should be used for boot diagnostics when a failover is done.
     * 
     */
    public Output<Optional<String>> targetBootDiagnosticsStorageAccountId() {
        return Codegen.optional(this.targetBootDiagnosticsStorageAccountId);
    }
    /**
     * The ID of network to use when a failover is done.
     * 
     * **Note:** `target_network_id` is required when `network_interface` is specified.
     * 
     */
    @Export(name="targetNetworkId", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> targetNetworkId;

    /**
     * @return The ID of network to use when a failover is done.
     * 
     * **Note:** `target_network_id` is required when `network_interface` is specified.
     * 
     */
    public Output<Optional<String>> targetNetworkId() {
        return Codegen.optional(this.targetNetworkId);
    }
    /**
     * The ID of Proximity Placement Group the new VM should belong to when a failover is done.
     * 
     * **Note:** Only one of `target_availability_set_id` or `target_zone` can be specified.
     * 
     */
    @Export(name="targetProximityPlacementGroupId", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> targetProximityPlacementGroupId;

    /**
     * @return The ID of Proximity Placement Group the new VM should belong to when a failover is done.
     * 
     * **Note:** Only one of `target_availability_set_id` or `target_zone` can be specified.
     * 
     */
    public Output<Optional<String>> targetProximityPlacementGroupId() {
        return Codegen.optional(this.targetProximityPlacementGroupId);
    }
    /**
     * The ID of resource group where the VM should be created when a failover is done. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="targetResourceGroupId", refs={String.class}, tree="[0]")
    private Output<String> targetResourceGroupId;

    /**
     * @return The ID of resource group where the VM should be created when a failover is done. Changing this forces a new resource to be created.
     * 
     */
    public Output<String> targetResourceGroupId() {
        return this.targetResourceGroupId;
    }
    /**
     * Name of the VM that should be created when a failover is done. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="targetVmName", refs={String.class}, tree="[0]")
    private Output<String> targetVmName;

    /**
     * @return Name of the VM that should be created when a failover is done. Changing this forces a new resource to be created.
     * 
     */
    public Output<String> targetVmName() {
        return this.targetVmName;
    }
    /**
     * Size of the VM that should be created when a failover is done, such as `Standard_F2`. If it&#39;s not specified, it will automatically be set by detecting the source VM size.
     * 
     */
    @Export(name="targetVmSize", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> targetVmSize;

    /**
     * @return Size of the VM that should be created when a failover is done, such as `Standard_F2`. If it&#39;s not specified, it will automatically be set by detecting the source VM size.
     * 
     */
    public Output<Optional<String>> targetVmSize() {
        return Codegen.optional(this.targetVmSize);
    }
    /**
     * Specifies the Availability Zone where the Failover VM should exist.
     * 
     */
    @Export(name="targetZone", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> targetZone;

    /**
     * @return Specifies the Availability Zone where the Failover VM should exist.
     * 
     */
    public Output<Optional<String>> targetZone() {
        return Codegen.optional(this.targetZone);
    }
    /**
     * The ID of network to use when a test failover is done.
     * 
     */
    @Export(name="testNetworkId", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> testNetworkId;

    /**
     * @return The ID of network to use when a test failover is done.
     * 
     */
    public Output<Optional<String>> testNetworkId() {
        return Codegen.optional(this.testNetworkId);
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public VmwareReplicatedVm(String name) {
        this(name, VmwareReplicatedVmArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public VmwareReplicatedVm(String name, VmwareReplicatedVmArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public VmwareReplicatedVm(String name, VmwareReplicatedVmArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("azure:siterecovery/vmwareReplicatedVm:VmwareReplicatedVm", name, args == null ? VmwareReplicatedVmArgs.Empty : args, makeResourceOptions(options, Codegen.empty()));
    }

    private VmwareReplicatedVm(String name, Output<String> id, @Nullable VmwareReplicatedVmState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("azure:siterecovery/vmwareReplicatedVm:VmwareReplicatedVm", name, state, makeResourceOptions(options, id));
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static VmwareReplicatedVm get(String name, Output<String> id, @Nullable VmwareReplicatedVmState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new VmwareReplicatedVm(name, id, state, options);
    }
}
