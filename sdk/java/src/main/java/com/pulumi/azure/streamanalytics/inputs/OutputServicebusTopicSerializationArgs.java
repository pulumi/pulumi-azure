// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.azure.streamanalytics.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class OutputServicebusTopicSerializationArgs extends com.pulumi.resources.ResourceArgs {

    public static final OutputServicebusTopicSerializationArgs Empty = new OutputServicebusTopicSerializationArgs();

    /**
     * The encoding of the incoming data in the case of input and the encoding of outgoing data in the case of output. It currently can only be set to `UTF8`.
     * 
     * &gt; **Note:** This is required when `type` is set to `Csv` or `Json`.
     * 
     */
    @Import(name="encoding")
    private @Nullable Output<String> encoding;

    /**
     * @return The encoding of the incoming data in the case of input and the encoding of outgoing data in the case of output. It currently can only be set to `UTF8`.
     * 
     * &gt; **Note:** This is required when `type` is set to `Csv` or `Json`.
     * 
     */
    public Optional<Output<String>> encoding() {
        return Optional.ofNullable(this.encoding);
    }

    /**
     * The delimiter that will be used to separate comma-separated value (CSV) records. Possible values are ` ` (space), `,` (comma), `	` (tab), `|` (pipe) and `;`.
     * 
     * &gt; **Note:** This is required when `type` is set to `Csv`.
     * 
     */
    @Import(name="fieldDelimiter")
    private @Nullable Output<String> fieldDelimiter;

    /**
     * @return The delimiter that will be used to separate comma-separated value (CSV) records. Possible values are ` ` (space), `,` (comma), `	` (tab), `|` (pipe) and `;`.
     * 
     * &gt; **Note:** This is required when `type` is set to `Csv`.
     * 
     */
    public Optional<Output<String>> fieldDelimiter() {
        return Optional.ofNullable(this.fieldDelimiter);
    }

    /**
     * Specifies the format of the JSON the output will be written in. Possible values are `Array` and `LineSeparated`.
     * 
     * &gt; **Note:** This is Required and can only be specified when `type` is set to `Json`.
     * 
     */
    @Import(name="format")
    private @Nullable Output<String> format;

    /**
     * @return Specifies the format of the JSON the output will be written in. Possible values are `Array` and `LineSeparated`.
     * 
     * &gt; **Note:** This is Required and can only be specified when `type` is set to `Json`.
     * 
     */
    public Optional<Output<String>> format() {
        return Optional.ofNullable(this.format);
    }

    /**
     * The serialization format used for outgoing data streams. Possible values are `Avro`, `Csv`, `Json` and `Parquet`.
     * 
     */
    @Import(name="type", required=true)
    private Output<String> type;

    /**
     * @return The serialization format used for outgoing data streams. Possible values are `Avro`, `Csv`, `Json` and `Parquet`.
     * 
     */
    public Output<String> type() {
        return this.type;
    }

    private OutputServicebusTopicSerializationArgs() {}

    private OutputServicebusTopicSerializationArgs(OutputServicebusTopicSerializationArgs $) {
        this.encoding = $.encoding;
        this.fieldDelimiter = $.fieldDelimiter;
        this.format = $.format;
        this.type = $.type;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(OutputServicebusTopicSerializationArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private OutputServicebusTopicSerializationArgs $;

        public Builder() {
            $ = new OutputServicebusTopicSerializationArgs();
        }

        public Builder(OutputServicebusTopicSerializationArgs defaults) {
            $ = new OutputServicebusTopicSerializationArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param encoding The encoding of the incoming data in the case of input and the encoding of outgoing data in the case of output. It currently can only be set to `UTF8`.
         * 
         * &gt; **Note:** This is required when `type` is set to `Csv` or `Json`.
         * 
         * @return builder
         * 
         */
        public Builder encoding(@Nullable Output<String> encoding) {
            $.encoding = encoding;
            return this;
        }

        /**
         * @param encoding The encoding of the incoming data in the case of input and the encoding of outgoing data in the case of output. It currently can only be set to `UTF8`.
         * 
         * &gt; **Note:** This is required when `type` is set to `Csv` or `Json`.
         * 
         * @return builder
         * 
         */
        public Builder encoding(String encoding) {
            return encoding(Output.of(encoding));
        }

        /**
         * @param fieldDelimiter The delimiter that will be used to separate comma-separated value (CSV) records. Possible values are ` ` (space), `,` (comma), `	` (tab), `|` (pipe) and `;`.
         * 
         * &gt; **Note:** This is required when `type` is set to `Csv`.
         * 
         * @return builder
         * 
         */
        public Builder fieldDelimiter(@Nullable Output<String> fieldDelimiter) {
            $.fieldDelimiter = fieldDelimiter;
            return this;
        }

        /**
         * @param fieldDelimiter The delimiter that will be used to separate comma-separated value (CSV) records. Possible values are ` ` (space), `,` (comma), `	` (tab), `|` (pipe) and `;`.
         * 
         * &gt; **Note:** This is required when `type` is set to `Csv`.
         * 
         * @return builder
         * 
         */
        public Builder fieldDelimiter(String fieldDelimiter) {
            return fieldDelimiter(Output.of(fieldDelimiter));
        }

        /**
         * @param format Specifies the format of the JSON the output will be written in. Possible values are `Array` and `LineSeparated`.
         * 
         * &gt; **Note:** This is Required and can only be specified when `type` is set to `Json`.
         * 
         * @return builder
         * 
         */
        public Builder format(@Nullable Output<String> format) {
            $.format = format;
            return this;
        }

        /**
         * @param format Specifies the format of the JSON the output will be written in. Possible values are `Array` and `LineSeparated`.
         * 
         * &gt; **Note:** This is Required and can only be specified when `type` is set to `Json`.
         * 
         * @return builder
         * 
         */
        public Builder format(String format) {
            return format(Output.of(format));
        }

        /**
         * @param type The serialization format used for outgoing data streams. Possible values are `Avro`, `Csv`, `Json` and `Parquet`.
         * 
         * @return builder
         * 
         */
        public Builder type(Output<String> type) {
            $.type = type;
            return this;
        }

        /**
         * @param type The serialization format used for outgoing data streams. Possible values are `Avro`, `Csv`, `Json` and `Parquet`.
         * 
         * @return builder
         * 
         */
        public Builder type(String type) {
            return type(Output.of(type));
        }

        public OutputServicebusTopicSerializationArgs build() {
            if ($.type == null) {
                throw new MissingRequiredPropertyException("OutputServicebusTopicSerializationArgs", "type");
            }
            return $;
        }
    }

}
