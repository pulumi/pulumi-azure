// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.azure.redis;

import com.pulumi.azure.Utilities;
import com.pulumi.azure.redis.CacheArgs;
import com.pulumi.azure.redis.inputs.CacheState;
import com.pulumi.azure.redis.outputs.CacheIdentity;
import com.pulumi.azure.redis.outputs.CachePatchSchedule;
import com.pulumi.azure.redis.outputs.CacheRedisConfiguration;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * Manages a Redis Cache.
 * 
 * &gt; **Note:** Redis version 4 is being retired and no longer supports creating new instances. Version 4 will be removed in a future release. [Redis Version 4 Retirement](https://learn.microsoft.com/azure/azure-cache-for-redis/cache-retired-features#important-upgrade-timelines)
 * 
 * ## Example Usage
 * 
 * This example provisions a Standard Redis Cache.
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.azure.core.ResourceGroup;
 * import com.pulumi.azure.core.ResourceGroupArgs;
 * import com.pulumi.azure.redis.Cache;
 * import com.pulumi.azure.redis.CacheArgs;
 * import com.pulumi.azure.redis.inputs.CacheRedisConfigurationArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var example = new ResourceGroup("example", ResourceGroupArgs.builder()
 *             .name("example-resources")
 *             .location("West Europe")
 *             .build());
 * 
 *         // NOTE: the Name used for Redis needs to be globally unique
 *         var exampleCache = new Cache("exampleCache", CacheArgs.builder()
 *             .name("example-cache")
 *             .location(example.location())
 *             .resourceGroupName(example.name())
 *             .capacity(2)
 *             .family("C")
 *             .skuName("Standard")
 *             .nonSslPortEnabled(false)
 *             .minimumTlsVersion("1.2")
 *             .redisConfiguration(CacheRedisConfigurationArgs.builder()
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * 
 * ## Relevant Links
 * 
 * * [Azure Cache for Redis planning](https://docs.microsoft.com/azure/azure-cache-for-redis/cache-planning-faq)
 * * [Redis: Available Configuration Settings](https://redis.io/topics/config)
 * 
 * ## Import
 * 
 * Redis Cache&#39;s can be imported using the `resource id`, e.g.
 * 
 * ```sh
 * $ pulumi import azure:redis/cache:Cache cache1 /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/group1/providers/Microsoft.Cache/redis/cache1
 * ```
 * 
 */
@ResourceType(type="azure:redis/cache:Cache")
public class Cache extends com.pulumi.resources.CustomResource {
    /**
     * Whether access key authentication is enabled? Defaults to `true`. `active_directory_authentication_enabled` must be set to `true` to disable access key authentication.
     * 
     */
    @Export(name="accessKeysAuthenticationEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> accessKeysAuthenticationEnabled;

    /**
     * @return Whether access key authentication is enabled? Defaults to `true`. `active_directory_authentication_enabled` must be set to `true` to disable access key authentication.
     * 
     */
    public Output<Optional<Boolean>> accessKeysAuthenticationEnabled() {
        return Codegen.optional(this.accessKeysAuthenticationEnabled);
    }
    /**
     * The size of the Redis cache to deploy. Valid values for a SKU `family` of C (Basic/Standard) are `0, 1, 2, 3, 4, 5, 6`, and for P (Premium) `family` are `1, 2, 3, 4, 5`.
     * 
     */
    @Export(name="capacity", refs={Integer.class}, tree="[0]")
    private Output<Integer> capacity;

    /**
     * @return The size of the Redis cache to deploy. Valid values for a SKU `family` of C (Basic/Standard) are `0, 1, 2, 3, 4, 5, 6`, and for P (Premium) `family` are `1, 2, 3, 4, 5`.
     * 
     */
    public Output<Integer> capacity() {
        return this.capacity;
    }
    /**
     * The SKU family/pricing group to use. Valid values are `C` (for Basic/Standard SKU family) and `P` (for `Premium`)
     * 
     */
    @Export(name="family", refs={String.class}, tree="[0]")
    private Output<String> family;

    /**
     * @return The SKU family/pricing group to use. Valid values are `C` (for Basic/Standard SKU family) and `P` (for `Premium`)
     * 
     */
    public Output<String> family() {
        return this.family;
    }
    /**
     * The Hostname of the Redis Instance
     * 
     */
    @Export(name="hostname", refs={String.class}, tree="[0]")
    private Output<String> hostname;

    /**
     * @return The Hostname of the Redis Instance
     * 
     */
    public Output<String> hostname() {
        return this.hostname;
    }
    /**
     * An `identity` block as defined below.
     * 
     */
    @Export(name="identity", refs={CacheIdentity.class}, tree="[0]")
    private Output</* @Nullable */ CacheIdentity> identity;

    /**
     * @return An `identity` block as defined below.
     * 
     */
    public Output<Optional<CacheIdentity>> identity() {
        return Codegen.optional(this.identity);
    }
    /**
     * The location of the resource group. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="location", refs={String.class}, tree="[0]")
    private Output<String> location;

    /**
     * @return The location of the resource group. Changing this forces a new resource to be created.
     * 
     */
    public Output<String> location() {
        return this.location;
    }
    /**
     * The minimum TLS version. Possible values are `1.0`, `1.1` and `1.2`. Defaults to `1.0`.
     * 
     * &gt; **NOTE:** Azure Services will require TLS 1.2+ by August 2025, please see this [announcement](https://azure.microsoft.com/en-us/updates/v2/update-retirement-tls1-0-tls1-1-versions-azure-services/) for more.
     * 
     */
    @Export(name="minimumTlsVersion", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> minimumTlsVersion;

    /**
     * @return The minimum TLS version. Possible values are `1.0`, `1.1` and `1.2`. Defaults to `1.0`.
     * 
     * &gt; **NOTE:** Azure Services will require TLS 1.2+ by August 2025, please see this [announcement](https://azure.microsoft.com/en-us/updates/v2/update-retirement-tls1-0-tls1-1-versions-azure-services/) for more.
     * 
     */
    public Output<Optional<String>> minimumTlsVersion() {
        return Codegen.optional(this.minimumTlsVersion);
    }
    /**
     * The name of the Redis instance. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    /**
     * @return The name of the Redis instance. Changing this forces a new resource to be created.
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * Enable the non-SSL port (6379) - disabled by default.
     * 
     */
    @Export(name="nonSslPortEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> nonSslPortEnabled;

    /**
     * @return Enable the non-SSL port (6379) - disabled by default.
     * 
     */
    public Output<Optional<Boolean>> nonSslPortEnabled() {
        return Codegen.optional(this.nonSslPortEnabled);
    }
    /**
     * A list of `patch_schedule` blocks as defined below.
     * 
     */
    @Export(name="patchSchedules", refs={List.class,CachePatchSchedule.class}, tree="[0,1]")
    private Output</* @Nullable */ List<CachePatchSchedule>> patchSchedules;

    /**
     * @return A list of `patch_schedule` blocks as defined below.
     * 
     */
    public Output<Optional<List<CachePatchSchedule>>> patchSchedules() {
        return Codegen.optional(this.patchSchedules);
    }
    /**
     * The non-SSL Port of the Redis Instance
     * 
     */
    @Export(name="port", refs={Integer.class}, tree="[0]")
    private Output<Integer> port;

    /**
     * @return The non-SSL Port of the Redis Instance
     * 
     */
    public Output<Integer> port() {
        return this.port;
    }
    /**
     * The Primary Access Key for the Redis Instance
     * 
     */
    @Export(name="primaryAccessKey", refs={String.class}, tree="[0]")
    private Output<String> primaryAccessKey;

    /**
     * @return The Primary Access Key for the Redis Instance
     * 
     */
    public Output<String> primaryAccessKey() {
        return this.primaryAccessKey;
    }
    /**
     * The primary connection string of the Redis Instance.
     * 
     */
    @Export(name="primaryConnectionString", refs={String.class}, tree="[0]")
    private Output<String> primaryConnectionString;

    /**
     * @return The primary connection string of the Redis Instance.
     * 
     */
    public Output<String> primaryConnectionString() {
        return this.primaryConnectionString;
    }
    /**
     * The Static IP Address to assign to the Redis Cache when hosted inside the Virtual Network. This argument implies the use of `subnet_id`. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="privateStaticIpAddress", refs={String.class}, tree="[0]")
    private Output<String> privateStaticIpAddress;

    /**
     * @return The Static IP Address to assign to the Redis Cache when hosted inside the Virtual Network. This argument implies the use of `subnet_id`. Changing this forces a new resource to be created.
     * 
     */
    public Output<String> privateStaticIpAddress() {
        return this.privateStaticIpAddress;
    }
    /**
     * Whether or not public network access is allowed for this Redis Cache. `true` means this resource could be accessed by both public and private endpoint. `false` means only private endpoint access is allowed. Defaults to `true`.
     * 
     */
    @Export(name="publicNetworkAccessEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> publicNetworkAccessEnabled;

    /**
     * @return Whether or not public network access is allowed for this Redis Cache. `true` means this resource could be accessed by both public and private endpoint. `false` means only private endpoint access is allowed. Defaults to `true`.
     * 
     */
    public Output<Optional<Boolean>> publicNetworkAccessEnabled() {
        return Codegen.optional(this.publicNetworkAccessEnabled);
    }
    /**
     * A `redis_configuration` block as defined below - with some limitations by SKU - defaults/details are shown below.
     * 
     */
    @Export(name="redisConfiguration", refs={CacheRedisConfiguration.class}, tree="[0]")
    private Output<CacheRedisConfiguration> redisConfiguration;

    /**
     * @return A `redis_configuration` block as defined below - with some limitations by SKU - defaults/details are shown below.
     * 
     */
    public Output<CacheRedisConfiguration> redisConfiguration() {
        return this.redisConfiguration;
    }
    /**
     * Redis version. Only major version needed. Possible values are `4` and `6`. Defaults to `6`.
     * 
     */
    @Export(name="redisVersion", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> redisVersion;

    /**
     * @return Redis version. Only major version needed. Possible values are `4` and `6`. Defaults to `6`.
     * 
     */
    public Output<Optional<String>> redisVersion() {
        return Codegen.optional(this.redisVersion);
    }
    /**
     * Amount of replicas to create per master for this Redis Cache.
     * 
     * &gt; **Note:** Configuring the number of replicas per master is only available when using the Premium SKU and cannot be used in conjunction with shards.
     * 
     */
    @Export(name="replicasPerMaster", refs={Integer.class}, tree="[0]")
    private Output<Integer> replicasPerMaster;

    /**
     * @return Amount of replicas to create per master for this Redis Cache.
     * 
     * &gt; **Note:** Configuring the number of replicas per master is only available when using the Premium SKU and cannot be used in conjunction with shards.
     * 
     */
    public Output<Integer> replicasPerMaster() {
        return this.replicasPerMaster;
    }
    /**
     * Amount of replicas to create per primary for this Redis Cache. If both `replicas_per_primary` and `replicas_per_master` are set, they need to be equal.
     * 
     */
    @Export(name="replicasPerPrimary", refs={Integer.class}, tree="[0]")
    private Output<Integer> replicasPerPrimary;

    /**
     * @return Amount of replicas to create per primary for this Redis Cache. If both `replicas_per_primary` and `replicas_per_master` are set, they need to be equal.
     * 
     */
    public Output<Integer> replicasPerPrimary() {
        return this.replicasPerPrimary;
    }
    /**
     * The name of the resource group in which to create the Redis instance. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="resourceGroupName", refs={String.class}, tree="[0]")
    private Output<String> resourceGroupName;

    /**
     * @return The name of the resource group in which to create the Redis instance. Changing this forces a new resource to be created.
     * 
     */
    public Output<String> resourceGroupName() {
        return this.resourceGroupName;
    }
    /**
     * The Secondary Access Key for the Redis Instance
     * 
     */
    @Export(name="secondaryAccessKey", refs={String.class}, tree="[0]")
    private Output<String> secondaryAccessKey;

    /**
     * @return The Secondary Access Key for the Redis Instance
     * 
     */
    public Output<String> secondaryAccessKey() {
        return this.secondaryAccessKey;
    }
    /**
     * The secondary connection string of the Redis Instance.
     * 
     */
    @Export(name="secondaryConnectionString", refs={String.class}, tree="[0]")
    private Output<String> secondaryConnectionString;

    /**
     * @return The secondary connection string of the Redis Instance.
     * 
     */
    public Output<String> secondaryConnectionString() {
        return this.secondaryConnectionString;
    }
    /**
     * *Only available when using the Premium SKU* The number of Shards to create on the Redis Cluster.
     * 
     */
    @Export(name="shardCount", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> shardCount;

    /**
     * @return *Only available when using the Premium SKU* The number of Shards to create on the Redis Cluster.
     * 
     */
    public Output<Optional<Integer>> shardCount() {
        return Codegen.optional(this.shardCount);
    }
    /**
     * The SKU of Redis to use. Possible values are `Basic`, `Standard` and `Premium`.
     * 
     * &gt; **Note** Downgrading the SKU will force a new resource to be created.
     * 
     */
    @Export(name="skuName", refs={String.class}, tree="[0]")
    private Output<String> skuName;

    /**
     * @return The SKU of Redis to use. Possible values are `Basic`, `Standard` and `Premium`.
     * 
     * &gt; **Note** Downgrading the SKU will force a new resource to be created.
     * 
     */
    public Output<String> skuName() {
        return this.skuName;
    }
    /**
     * The SSL Port of the Redis Instance
     * 
     */
    @Export(name="sslPort", refs={Integer.class}, tree="[0]")
    private Output<Integer> sslPort;

    /**
     * @return The SSL Port of the Redis Instance
     * 
     */
    public Output<Integer> sslPort() {
        return this.sslPort;
    }
    /**
     * *Only available when using the Premium SKU* The ID of the Subnet within which the Redis Cache should be deployed. This Subnet must only contain Azure Cache for Redis instances without any other type of resources. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="subnetId", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> subnetId;

    /**
     * @return *Only available when using the Premium SKU* The ID of the Subnet within which the Redis Cache should be deployed. This Subnet must only contain Azure Cache for Redis instances without any other type of resources. Changing this forces a new resource to be created.
     * 
     */
    public Output<Optional<String>> subnetId() {
        return Codegen.optional(this.subnetId);
    }
    /**
     * A mapping of tags to assign to the resource.
     * 
     */
    @Export(name="tags", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output</* @Nullable */ Map<String,String>> tags;

    /**
     * @return A mapping of tags to assign to the resource.
     * 
     */
    public Output<Optional<Map<String,String>>> tags() {
        return Codegen.optional(this.tags);
    }
    /**
     * A mapping of tenant settings to assign to the resource.
     * 
     */
    @Export(name="tenantSettings", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output</* @Nullable */ Map<String,String>> tenantSettings;

    /**
     * @return A mapping of tenant settings to assign to the resource.
     * 
     */
    public Output<Optional<Map<String,String>>> tenantSettings() {
        return Codegen.optional(this.tenantSettings);
    }
    /**
     * Specifies a list of Availability Zones in which this Redis Cache should be located. Changing this forces a new Redis Cache to be created.
     * 
     * &gt; **Please Note:** Availability Zones are [in Preview and only supported in several regions at this time](https://docs.microsoft.com/azure/availability-zones/az-overview) - as such you must be opted into the Preview to use this functionality. You can [opt into the Availability Zones Preview in the Azure Portal](https://aka.ms/azenroll).
     * 
     */
    @Export(name="zones", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> zones;

    /**
     * @return Specifies a list of Availability Zones in which this Redis Cache should be located. Changing this forces a new Redis Cache to be created.
     * 
     * &gt; **Please Note:** Availability Zones are [in Preview and only supported in several regions at this time](https://docs.microsoft.com/azure/availability-zones/az-overview) - as such you must be opted into the Preview to use this functionality. You can [opt into the Availability Zones Preview in the Azure Portal](https://aka.ms/azenroll).
     * 
     */
    public Output<Optional<List<String>>> zones() {
        return Codegen.optional(this.zones);
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public Cache(java.lang.String name) {
        this(name, CacheArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public Cache(java.lang.String name, CacheArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public Cache(java.lang.String name, CacheArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("azure:redis/cache:Cache", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private Cache(java.lang.String name, Output<java.lang.String> id, @Nullable CacheState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("azure:redis/cache:Cache", name, state, makeResourceOptions(options, id), false);
    }

    private static CacheArgs makeArgs(CacheArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? CacheArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .additionalSecretOutputs(List.of(
                "primaryAccessKey",
                "primaryConnectionString",
                "secondaryAccessKey",
                "secondaryConnectionString"
            ))
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static Cache get(java.lang.String name, Output<java.lang.String> id, @Nullable CacheState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new Cache(name, id, state, options);
    }
}
