// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.azure.servicefabric.inputs;

import com.pulumi.azure.servicefabric.inputs.ManagedClusterNodeTypeVmSecretArgs;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class ManagedClusterNodeTypeArgs extends com.pulumi.resources.ResourceArgs {

    public static final ManagedClusterNodeTypeArgs Empty = new ManagedClusterNodeTypeArgs();

    /**
     * Sets the port range available for applications. Format is `&lt;from_port&gt;-&lt;to_port&gt;`, for example `10000-20000`.
     * 
     */
    @Import(name="applicationPortRange", required=true)
    private Output<String> applicationPortRange;

    /**
     * @return Sets the port range available for applications. Format is `&lt;from_port&gt;-&lt;to_port&gt;`, for example `10000-20000`.
     * 
     */
    public Output<String> applicationPortRange() {
        return this.applicationPortRange;
    }

    /**
     * Specifies a list of key/value pairs used to set capacity tags for this node type.
     * 
     */
    @Import(name="capacities")
    private @Nullable Output<Map<String,String>> capacities;

    /**
     * @return Specifies a list of key/value pairs used to set capacity tags for this node type.
     * 
     */
    public Optional<Output<Map<String,String>>> capacities() {
        return Optional.ofNullable(this.capacities);
    }

    /**
     * The size of the data disk in gigabytes..
     * 
     */
    @Import(name="dataDiskSizeGb", required=true)
    private Output<Integer> dataDiskSizeGb;

    /**
     * @return The size of the data disk in gigabytes..
     * 
     */
    public Output<Integer> dataDiskSizeGb() {
        return this.dataDiskSizeGb;
    }

    /**
     * The type of the disk to use for storing data. It can be one of `Premium_LRS`, `Standard_LRS`, or `StandardSSD_LRS`. Defaults to `Standard_LRS`.
     * 
     */
    @Import(name="dataDiskType")
    private @Nullable Output<String> dataDiskType;

    /**
     * @return The type of the disk to use for storing data. It can be one of `Premium_LRS`, `Standard_LRS`, or `StandardSSD_LRS`. Defaults to `Standard_LRS`.
     * 
     */
    public Optional<Output<String>> dataDiskType() {
        return Optional.ofNullable(this.dataDiskType);
    }

    /**
     * Sets the port range available for the OS. Format is `&lt;from_port&gt;-&lt;to_port&gt;`, for example `10000-20000`. There has to be at least 255 ports available and cannot overlap with `application_port_range`..
     * 
     */
    @Import(name="ephemeralPortRange", required=true)
    private Output<String> ephemeralPortRange;

    /**
     * @return Sets the port range available for the OS. Format is `&lt;from_port&gt;-&lt;to_port&gt;`, for example `10000-20000`. There has to be at least 255 ports available and cannot overlap with `application_port_range`..
     * 
     */
    public Output<String> ephemeralPortRange() {
        return this.ephemeralPortRange;
    }

    /**
     * The ID of the Resource Group.
     * 
     */
    @Import(name="id")
    private @Nullable Output<String> id;

    /**
     * @return The ID of the Resource Group.
     * 
     */
    public Optional<Output<String>> id() {
        return Optional.ofNullable(this.id);
    }

    /**
     * If set the node type can be composed of multiple placement groups.
     * 
     */
    @Import(name="multiplePlacementGroupsEnabled")
    private @Nullable Output<Boolean> multiplePlacementGroupsEnabled;

    /**
     * @return If set the node type can be composed of multiple placement groups.
     * 
     */
    public Optional<Output<Boolean>> multiplePlacementGroupsEnabled() {
        return Optional.ofNullable(this.multiplePlacementGroupsEnabled);
    }

    /**
     * The name which should be used for this node type.
     * 
     */
    @Import(name="name", required=true)
    private Output<String> name;

    /**
     * @return The name which should be used for this node type.
     * 
     */
    public Output<String> name() {
        return this.name;
    }

    /**
     * Specifies a list of placement tags that can be used to indicate where services should run..
     * 
     */
    @Import(name="placementProperties")
    private @Nullable Output<Map<String,String>> placementProperties;

    /**
     * @return Specifies a list of placement tags that can be used to indicate where services should run..
     * 
     */
    public Optional<Output<Map<String,String>>> placementProperties() {
        return Optional.ofNullable(this.placementProperties);
    }

    /**
     * If set to true, system services will run on this node type. Only one node type should be marked as primary. Primary node type cannot be deleted or changed once they&#39;re created.
     * 
     */
    @Import(name="primary")
    private @Nullable Output<Boolean> primary;

    /**
     * @return If set to true, system services will run on this node type. Only one node type should be marked as primary. Primary node type cannot be deleted or changed once they&#39;re created.
     * 
     */
    public Optional<Output<Boolean>> primary() {
        return Optional.ofNullable(this.primary);
    }

    /**
     * If set to true, only stateless workloads can run on this node type.
     * 
     */
    @Import(name="stateless")
    private @Nullable Output<Boolean> stateless;

    /**
     * @return If set to true, only stateless workloads can run on this node type.
     * 
     */
    public Optional<Output<Boolean>> stateless() {
        return Optional.ofNullable(this.stateless);
    }

    /**
     * The offer type of the marketplace image cluster VMs will use.
     * 
     */
    @Import(name="vmImageOffer", required=true)
    private Output<String> vmImageOffer;

    /**
     * @return The offer type of the marketplace image cluster VMs will use.
     * 
     */
    public Output<String> vmImageOffer() {
        return this.vmImageOffer;
    }

    /**
     * The publisher of the marketplace image cluster VMs will use.
     * 
     */
    @Import(name="vmImagePublisher", required=true)
    private Output<String> vmImagePublisher;

    /**
     * @return The publisher of the marketplace image cluster VMs will use.
     * 
     */
    public Output<String> vmImagePublisher() {
        return this.vmImagePublisher;
    }

    /**
     * The SKU of the marketplace image cluster VMs will use.
     * 
     */
    @Import(name="vmImageSku", required=true)
    private Output<String> vmImageSku;

    /**
     * @return The SKU of the marketplace image cluster VMs will use.
     * 
     */
    public Output<String> vmImageSku() {
        return this.vmImageSku;
    }

    /**
     * The version of the marketplace image cluster VMs will use.
     * 
     */
    @Import(name="vmImageVersion", required=true)
    private Output<String> vmImageVersion;

    /**
     * @return The version of the marketplace image cluster VMs will use.
     * 
     */
    public Output<String> vmImageVersion() {
        return this.vmImageVersion;
    }

    /**
     * The number of instances this node type will launch.
     * 
     */
    @Import(name="vmInstanceCount", required=true)
    private Output<Integer> vmInstanceCount;

    /**
     * @return The number of instances this node type will launch.
     * 
     */
    public Output<Integer> vmInstanceCount() {
        return this.vmInstanceCount;
    }

    /**
     * One or more `vm_secrets` blocks as defined below.
     * 
     */
    @Import(name="vmSecrets")
    private @Nullable Output<List<ManagedClusterNodeTypeVmSecretArgs>> vmSecrets;

    /**
     * @return One or more `vm_secrets` blocks as defined below.
     * 
     */
    public Optional<Output<List<ManagedClusterNodeTypeVmSecretArgs>>> vmSecrets() {
        return Optional.ofNullable(this.vmSecrets);
    }

    /**
     * The size of the instances in this node type.
     * 
     */
    @Import(name="vmSize", required=true)
    private Output<String> vmSize;

    /**
     * @return The size of the instances in this node type.
     * 
     */
    public Output<String> vmSize() {
        return this.vmSize;
    }

    private ManagedClusterNodeTypeArgs() {}

    private ManagedClusterNodeTypeArgs(ManagedClusterNodeTypeArgs $) {
        this.applicationPortRange = $.applicationPortRange;
        this.capacities = $.capacities;
        this.dataDiskSizeGb = $.dataDiskSizeGb;
        this.dataDiskType = $.dataDiskType;
        this.ephemeralPortRange = $.ephemeralPortRange;
        this.id = $.id;
        this.multiplePlacementGroupsEnabled = $.multiplePlacementGroupsEnabled;
        this.name = $.name;
        this.placementProperties = $.placementProperties;
        this.primary = $.primary;
        this.stateless = $.stateless;
        this.vmImageOffer = $.vmImageOffer;
        this.vmImagePublisher = $.vmImagePublisher;
        this.vmImageSku = $.vmImageSku;
        this.vmImageVersion = $.vmImageVersion;
        this.vmInstanceCount = $.vmInstanceCount;
        this.vmSecrets = $.vmSecrets;
        this.vmSize = $.vmSize;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(ManagedClusterNodeTypeArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private ManagedClusterNodeTypeArgs $;

        public Builder() {
            $ = new ManagedClusterNodeTypeArgs();
        }

        public Builder(ManagedClusterNodeTypeArgs defaults) {
            $ = new ManagedClusterNodeTypeArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param applicationPortRange Sets the port range available for applications. Format is `&lt;from_port&gt;-&lt;to_port&gt;`, for example `10000-20000`.
         * 
         * @return builder
         * 
         */
        public Builder applicationPortRange(Output<String> applicationPortRange) {
            $.applicationPortRange = applicationPortRange;
            return this;
        }

        /**
         * @param applicationPortRange Sets the port range available for applications. Format is `&lt;from_port&gt;-&lt;to_port&gt;`, for example `10000-20000`.
         * 
         * @return builder
         * 
         */
        public Builder applicationPortRange(String applicationPortRange) {
            return applicationPortRange(Output.of(applicationPortRange));
        }

        /**
         * @param capacities Specifies a list of key/value pairs used to set capacity tags for this node type.
         * 
         * @return builder
         * 
         */
        public Builder capacities(@Nullable Output<Map<String,String>> capacities) {
            $.capacities = capacities;
            return this;
        }

        /**
         * @param capacities Specifies a list of key/value pairs used to set capacity tags for this node type.
         * 
         * @return builder
         * 
         */
        public Builder capacities(Map<String,String> capacities) {
            return capacities(Output.of(capacities));
        }

        /**
         * @param dataDiskSizeGb The size of the data disk in gigabytes..
         * 
         * @return builder
         * 
         */
        public Builder dataDiskSizeGb(Output<Integer> dataDiskSizeGb) {
            $.dataDiskSizeGb = dataDiskSizeGb;
            return this;
        }

        /**
         * @param dataDiskSizeGb The size of the data disk in gigabytes..
         * 
         * @return builder
         * 
         */
        public Builder dataDiskSizeGb(Integer dataDiskSizeGb) {
            return dataDiskSizeGb(Output.of(dataDiskSizeGb));
        }

        /**
         * @param dataDiskType The type of the disk to use for storing data. It can be one of `Premium_LRS`, `Standard_LRS`, or `StandardSSD_LRS`. Defaults to `Standard_LRS`.
         * 
         * @return builder
         * 
         */
        public Builder dataDiskType(@Nullable Output<String> dataDiskType) {
            $.dataDiskType = dataDiskType;
            return this;
        }

        /**
         * @param dataDiskType The type of the disk to use for storing data. It can be one of `Premium_LRS`, `Standard_LRS`, or `StandardSSD_LRS`. Defaults to `Standard_LRS`.
         * 
         * @return builder
         * 
         */
        public Builder dataDiskType(String dataDiskType) {
            return dataDiskType(Output.of(dataDiskType));
        }

        /**
         * @param ephemeralPortRange Sets the port range available for the OS. Format is `&lt;from_port&gt;-&lt;to_port&gt;`, for example `10000-20000`. There has to be at least 255 ports available and cannot overlap with `application_port_range`..
         * 
         * @return builder
         * 
         */
        public Builder ephemeralPortRange(Output<String> ephemeralPortRange) {
            $.ephemeralPortRange = ephemeralPortRange;
            return this;
        }

        /**
         * @param ephemeralPortRange Sets the port range available for the OS. Format is `&lt;from_port&gt;-&lt;to_port&gt;`, for example `10000-20000`. There has to be at least 255 ports available and cannot overlap with `application_port_range`..
         * 
         * @return builder
         * 
         */
        public Builder ephemeralPortRange(String ephemeralPortRange) {
            return ephemeralPortRange(Output.of(ephemeralPortRange));
        }

        /**
         * @param id The ID of the Resource Group.
         * 
         * @return builder
         * 
         */
        public Builder id(@Nullable Output<String> id) {
            $.id = id;
            return this;
        }

        /**
         * @param id The ID of the Resource Group.
         * 
         * @return builder
         * 
         */
        public Builder id(String id) {
            return id(Output.of(id));
        }

        /**
         * @param multiplePlacementGroupsEnabled If set the node type can be composed of multiple placement groups.
         * 
         * @return builder
         * 
         */
        public Builder multiplePlacementGroupsEnabled(@Nullable Output<Boolean> multiplePlacementGroupsEnabled) {
            $.multiplePlacementGroupsEnabled = multiplePlacementGroupsEnabled;
            return this;
        }

        /**
         * @param multiplePlacementGroupsEnabled If set the node type can be composed of multiple placement groups.
         * 
         * @return builder
         * 
         */
        public Builder multiplePlacementGroupsEnabled(Boolean multiplePlacementGroupsEnabled) {
            return multiplePlacementGroupsEnabled(Output.of(multiplePlacementGroupsEnabled));
        }

        /**
         * @param name The name which should be used for this node type.
         * 
         * @return builder
         * 
         */
        public Builder name(Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name The name which should be used for this node type.
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param placementProperties Specifies a list of placement tags that can be used to indicate where services should run..
         * 
         * @return builder
         * 
         */
        public Builder placementProperties(@Nullable Output<Map<String,String>> placementProperties) {
            $.placementProperties = placementProperties;
            return this;
        }

        /**
         * @param placementProperties Specifies a list of placement tags that can be used to indicate where services should run..
         * 
         * @return builder
         * 
         */
        public Builder placementProperties(Map<String,String> placementProperties) {
            return placementProperties(Output.of(placementProperties));
        }

        /**
         * @param primary If set to true, system services will run on this node type. Only one node type should be marked as primary. Primary node type cannot be deleted or changed once they&#39;re created.
         * 
         * @return builder
         * 
         */
        public Builder primary(@Nullable Output<Boolean> primary) {
            $.primary = primary;
            return this;
        }

        /**
         * @param primary If set to true, system services will run on this node type. Only one node type should be marked as primary. Primary node type cannot be deleted or changed once they&#39;re created.
         * 
         * @return builder
         * 
         */
        public Builder primary(Boolean primary) {
            return primary(Output.of(primary));
        }

        /**
         * @param stateless If set to true, only stateless workloads can run on this node type.
         * 
         * @return builder
         * 
         */
        public Builder stateless(@Nullable Output<Boolean> stateless) {
            $.stateless = stateless;
            return this;
        }

        /**
         * @param stateless If set to true, only stateless workloads can run on this node type.
         * 
         * @return builder
         * 
         */
        public Builder stateless(Boolean stateless) {
            return stateless(Output.of(stateless));
        }

        /**
         * @param vmImageOffer The offer type of the marketplace image cluster VMs will use.
         * 
         * @return builder
         * 
         */
        public Builder vmImageOffer(Output<String> vmImageOffer) {
            $.vmImageOffer = vmImageOffer;
            return this;
        }

        /**
         * @param vmImageOffer The offer type of the marketplace image cluster VMs will use.
         * 
         * @return builder
         * 
         */
        public Builder vmImageOffer(String vmImageOffer) {
            return vmImageOffer(Output.of(vmImageOffer));
        }

        /**
         * @param vmImagePublisher The publisher of the marketplace image cluster VMs will use.
         * 
         * @return builder
         * 
         */
        public Builder vmImagePublisher(Output<String> vmImagePublisher) {
            $.vmImagePublisher = vmImagePublisher;
            return this;
        }

        /**
         * @param vmImagePublisher The publisher of the marketplace image cluster VMs will use.
         * 
         * @return builder
         * 
         */
        public Builder vmImagePublisher(String vmImagePublisher) {
            return vmImagePublisher(Output.of(vmImagePublisher));
        }

        /**
         * @param vmImageSku The SKU of the marketplace image cluster VMs will use.
         * 
         * @return builder
         * 
         */
        public Builder vmImageSku(Output<String> vmImageSku) {
            $.vmImageSku = vmImageSku;
            return this;
        }

        /**
         * @param vmImageSku The SKU of the marketplace image cluster VMs will use.
         * 
         * @return builder
         * 
         */
        public Builder vmImageSku(String vmImageSku) {
            return vmImageSku(Output.of(vmImageSku));
        }

        /**
         * @param vmImageVersion The version of the marketplace image cluster VMs will use.
         * 
         * @return builder
         * 
         */
        public Builder vmImageVersion(Output<String> vmImageVersion) {
            $.vmImageVersion = vmImageVersion;
            return this;
        }

        /**
         * @param vmImageVersion The version of the marketplace image cluster VMs will use.
         * 
         * @return builder
         * 
         */
        public Builder vmImageVersion(String vmImageVersion) {
            return vmImageVersion(Output.of(vmImageVersion));
        }

        /**
         * @param vmInstanceCount The number of instances this node type will launch.
         * 
         * @return builder
         * 
         */
        public Builder vmInstanceCount(Output<Integer> vmInstanceCount) {
            $.vmInstanceCount = vmInstanceCount;
            return this;
        }

        /**
         * @param vmInstanceCount The number of instances this node type will launch.
         * 
         * @return builder
         * 
         */
        public Builder vmInstanceCount(Integer vmInstanceCount) {
            return vmInstanceCount(Output.of(vmInstanceCount));
        }

        /**
         * @param vmSecrets One or more `vm_secrets` blocks as defined below.
         * 
         * @return builder
         * 
         */
        public Builder vmSecrets(@Nullable Output<List<ManagedClusterNodeTypeVmSecretArgs>> vmSecrets) {
            $.vmSecrets = vmSecrets;
            return this;
        }

        /**
         * @param vmSecrets One or more `vm_secrets` blocks as defined below.
         * 
         * @return builder
         * 
         */
        public Builder vmSecrets(List<ManagedClusterNodeTypeVmSecretArgs> vmSecrets) {
            return vmSecrets(Output.of(vmSecrets));
        }

        /**
         * @param vmSecrets One or more `vm_secrets` blocks as defined below.
         * 
         * @return builder
         * 
         */
        public Builder vmSecrets(ManagedClusterNodeTypeVmSecretArgs... vmSecrets) {
            return vmSecrets(List.of(vmSecrets));
        }

        /**
         * @param vmSize The size of the instances in this node type.
         * 
         * @return builder
         * 
         */
        public Builder vmSize(Output<String> vmSize) {
            $.vmSize = vmSize;
            return this;
        }

        /**
         * @param vmSize The size of the instances in this node type.
         * 
         * @return builder
         * 
         */
        public Builder vmSize(String vmSize) {
            return vmSize(Output.of(vmSize));
        }

        public ManagedClusterNodeTypeArgs build() {
            if ($.applicationPortRange == null) {
                throw new MissingRequiredPropertyException("ManagedClusterNodeTypeArgs", "applicationPortRange");
            }
            if ($.dataDiskSizeGb == null) {
                throw new MissingRequiredPropertyException("ManagedClusterNodeTypeArgs", "dataDiskSizeGb");
            }
            if ($.ephemeralPortRange == null) {
                throw new MissingRequiredPropertyException("ManagedClusterNodeTypeArgs", "ephemeralPortRange");
            }
            if ($.name == null) {
                throw new MissingRequiredPropertyException("ManagedClusterNodeTypeArgs", "name");
            }
            if ($.vmImageOffer == null) {
                throw new MissingRequiredPropertyException("ManagedClusterNodeTypeArgs", "vmImageOffer");
            }
            if ($.vmImagePublisher == null) {
                throw new MissingRequiredPropertyException("ManagedClusterNodeTypeArgs", "vmImagePublisher");
            }
            if ($.vmImageSku == null) {
                throw new MissingRequiredPropertyException("ManagedClusterNodeTypeArgs", "vmImageSku");
            }
            if ($.vmImageVersion == null) {
                throw new MissingRequiredPropertyException("ManagedClusterNodeTypeArgs", "vmImageVersion");
            }
            if ($.vmInstanceCount == null) {
                throw new MissingRequiredPropertyException("ManagedClusterNodeTypeArgs", "vmInstanceCount");
            }
            if ($.vmSize == null) {
                throw new MissingRequiredPropertyException("ManagedClusterNodeTypeArgs", "vmSize");
            }
            return $;
        }
    }

}
