// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.azure.core;

import com.pulumi.azure.Utilities;
import com.pulumi.azure.core.TemplateDeploymentArgs;
import com.pulumi.azure.core.inputs.TemplateDeploymentState;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import java.lang.String;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * Manages a template deployment of resources
 * 
 * &gt; **Note on ARM Template Deployments:** Due to the way the underlying Azure API is designed, this provider can only manage the deployment of the ARM Template - and not any resources which are created by it.
 * This means that when deleting the `azure.core.TemplateDeployment` resource, this provider will only remove the reference to the deployment, whilst leaving any resources created by that ARM Template Deployment.
 * One workaround for this is to use a unique Resource Group for each ARM Template Deployment, which means deleting the Resource Group would contain any resources created within it - however this isn&#39;t ideal. [More information](https://docs.microsoft.com/en-us/rest/api/resources/deployments#Deployments_Delete).
 * 
 * ## Example Usage
 * 
 * &gt; **Note:** This example uses Storage Accounts and Public IP&#39;s which are natively supported by this provider - we&#39;d highly recommend using the Native Resources where possible instead rather than an ARM Template, for the reasons outlined above.
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.azure.core.ResourceGroup;
 * import com.pulumi.azure.core.ResourceGroupArgs;
 * import com.pulumi.azure.core.TemplateDeployment;
 * import com.pulumi.azure.core.TemplateDeploymentArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var example = new ResourceGroup("example", ResourceGroupArgs.builder()        
 *             .name("example-resources")
 *             .location("West Europe")
 *             .build());
 * 
 *         var exampleTemplateDeployment = new TemplateDeployment("exampleTemplateDeployment", TemplateDeploymentArgs.builder()        
 *             .name("acctesttemplate-01")
 *             .resourceGroupName(example.name())
 *             .templateBody("""
 * {
 *   "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
 *   "contentVersion": "1.0.0.0",
 *   "parameters": {
 *     "storageAccountType": {
 *       "type": "string",
 *       "defaultValue": "Standard_LRS",
 *       "allowedValues": [
 *         "Standard_LRS",
 *         "Standard_GRS",
 *         "Standard_ZRS"
 *       ],
 *       "metadata": {
 *         "description": "Storage Account type"
 *       }
 *     }
 *   },
 *   "variables": {
 *     "location": "[resourceGroup().location]",
 *     "storageAccountName": "[concat(uniquestring(resourceGroup().id), 'storage')]",
 *     "publicIPAddressName": "[concat('myPublicIp', uniquestring(resourceGroup().id))]",
 *     "publicIPAddressType": "Dynamic",
 *     "apiVersion": "2015-06-15",
 *     "dnsLabelPrefix": "example-acctest"
 *   },
 *   "resources": [
 *     {
 *       "type": "Microsoft.Storage/storageAccounts",
 *       "name": "[variables('storageAccountName')]",
 *       "apiVersion": "[variables('apiVersion')]",
 *       "location": "[variables('location')]",
 *       "properties": {
 *         "accountType": "[parameters('storageAccountType')]"
 *       }
 *     },
 *     {
 *       "type": "Microsoft.Network/publicIPAddresses",
 *       "apiVersion": "[variables('apiVersion')]",
 *       "name": "[variables('publicIPAddressName')]",
 *       "location": "[variables('location')]",
 *       "properties": {
 *         "publicIPAllocationMethod": "[variables('publicIPAddressType')]",
 *         "dnsSettings": {
 *           "domainNameLabel": "[variables('dnsLabelPrefix')]"
 *         }
 *       }
 *     }
 *   ],
 *   "outputs": {
 *     "storageAccountName": {
 *       "type": "string",
 *       "value": "[variables('storageAccountName')]"
 *     }
 *   }
 * }
 *             """)
 *             .parameters(Map.of("storageAccountType", "Standard_GRS"))
 *             .deploymentMode("Incremental")
 *             .build());
 * 
 *         ctx.export("storageAccountName", exampleTemplateDeployment.outputs().applyValue(outputs -> outputs.storageAccountName()));
 *     }
 * }
 * }
 * &lt;!--End PulumiCodeChooser --&gt;
 * 
 * ## Note
 * 
 * This provider does not know about the individual resources created by Azure using a deployment template and therefore cannot delete these resources during a destroy. Destroying a template deployment removes the associated deployment operations, but will not delete the Azure resources created by the deployment. In order to delete these resources, the containing resource group must also be destroyed. [More information](https://docs.microsoft.com/rest/api/resources/deployments#Deployments_Delete).
 * 
 */
@ResourceType(type="azure:core/templateDeployment:TemplateDeployment")
public class TemplateDeployment extends com.pulumi.resources.CustomResource {
    /**
     * Specifies the mode that is used to deploy resources. This value could be either `Incremental` or `Complete`.
     * Note that you will almost *always* want this to be set to `Incremental` otherwise the deployment will destroy all infrastructure not
     * specified within the template, and this provider will not be aware of this.
     * 
     */
    @Export(name="deploymentMode", refs={String.class}, tree="[0]")
    private Output<String> deploymentMode;

    /**
     * @return Specifies the mode that is used to deploy resources. This value could be either `Incremental` or `Complete`.
     * Note that you will almost *always* want this to be set to `Incremental` otherwise the deployment will destroy all infrastructure not
     * specified within the template, and this provider will not be aware of this.
     * 
     */
    public Output<String> deploymentMode() {
        return this.deploymentMode;
    }
    /**
     * Specifies the name of the template deployment. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    /**
     * @return Specifies the name of the template deployment. Changing this forces a new resource to be created.
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * A map of supported scalar output types returned from the deployment (currently, Azure Template Deployment outputs of type String, Int and Bool are supported, and are converted to strings - others will be ignored) and can be accessed using `.outputs[&#34;name&#34;]`.
     * 
     */
    @Export(name="outputs", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output<Map<String,String>> outputs;

    /**
     * @return A map of supported scalar output types returned from the deployment (currently, Azure Template Deployment outputs of type String, Int and Bool are supported, and are converted to strings - others will be ignored) and can be accessed using `.outputs[&#34;name&#34;]`.
     * 
     */
    public Output<Map<String,String>> outputs() {
        return this.outputs;
    }
    /**
     * Specifies the name and value pairs that define the deployment parameters for the template.
     * 
     */
    @Export(name="parameters", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output</* @Nullable */ Map<String,String>> parameters;

    /**
     * @return Specifies the name and value pairs that define the deployment parameters for the template.
     * 
     */
    public Output<Optional<Map<String,String>>> parameters() {
        return Codegen.optional(this.parameters);
    }
    /**
     * Specifies a valid Azure JSON parameters file that define the deployment parameters. It can contain KeyVault references
     * 
     */
    @Export(name="parametersBody", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> parametersBody;

    /**
     * @return Specifies a valid Azure JSON parameters file that define the deployment parameters. It can contain KeyVault references
     * 
     */
    public Output<Optional<String>> parametersBody() {
        return Codegen.optional(this.parametersBody);
    }
    /**
     * The name of the resource group in which to create the template deployment. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="resourceGroupName", refs={String.class}, tree="[0]")
    private Output<String> resourceGroupName;

    /**
     * @return The name of the resource group in which to create the template deployment. Changing this forces a new resource to be created.
     * 
     */
    public Output<String> resourceGroupName() {
        return this.resourceGroupName;
    }
    /**
     * Specifies the JSON definition for the template.
     * 
     */
    @Export(name="templateBody", refs={String.class}, tree="[0]")
    private Output<String> templateBody;

    /**
     * @return Specifies the JSON definition for the template.
     * 
     */
    public Output<String> templateBody() {
        return this.templateBody;
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public TemplateDeployment(String name) {
        this(name, TemplateDeploymentArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public TemplateDeployment(String name, TemplateDeploymentArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public TemplateDeployment(String name, TemplateDeploymentArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("azure:core/templateDeployment:TemplateDeployment", name, args == null ? TemplateDeploymentArgs.Empty : args, makeResourceOptions(options, Codegen.empty()));
    }

    private TemplateDeployment(String name, Output<String> id, @Nullable TemplateDeploymentState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("azure:core/templateDeployment:TemplateDeployment", name, state, makeResourceOptions(options, id));
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static TemplateDeployment get(String name, Output<String> id, @Nullable TemplateDeploymentState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new TemplateDeployment(name, id, state, options);
    }
}
