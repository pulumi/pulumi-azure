// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.azure.containerservice;

import com.pulumi.azure.Utilities;
import com.pulumi.azure.containerservice.KubernetesClusterArgs;
import com.pulumi.azure.containerservice.inputs.KubernetesClusterState;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterAciConnectorLinux;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterApiServerAccessProfile;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterAutoScalerProfile;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterAzureActiveDirectoryRoleBasedAccessControl;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterConfidentialComputing;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterDefaultNodePool;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterHttpProxyConfig;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterIdentity;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterIngressApplicationGateway;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterKeyManagementService;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterKeyVaultSecretsProvider;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterKubeAdminConfig;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterKubeConfig;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterKubeletIdentity;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterLinuxProfile;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterMaintenanceWindow;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterMicrosoftDefender;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterMonitorMetrics;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterNetworkProfile;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterOmsAgent;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterServicePrincipal;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterStorageProfile;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterWebAppRouting;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterWindowsProfile;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterWorkloadAutoscalerProfile;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * Manages a Managed Kubernetes Cluster (also known as AKS / Azure Kubernetes Service)
 * 
 * ## Example Usage
 * 
 * This example provisions a basic Managed Kubernetes Cluster.
 * ```java
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.azure.core.ResourceGroup;
 * import com.pulumi.azure.core.ResourceGroupArgs;
 * import com.pulumi.azure.containerservice.KubernetesCluster;
 * import com.pulumi.azure.containerservice.KubernetesClusterArgs;
 * import com.pulumi.azure.containerservice.inputs.KubernetesClusterDefaultNodePoolArgs;
 * import com.pulumi.azure.containerservice.inputs.KubernetesClusterIdentityArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var exampleResourceGroup = new ResourceGroup(&#34;exampleResourceGroup&#34;, ResourceGroupArgs.builder()        
 *             .location(&#34;West Europe&#34;)
 *             .build());
 * 
 *         var exampleKubernetesCluster = new KubernetesCluster(&#34;exampleKubernetesCluster&#34;, KubernetesClusterArgs.builder()        
 *             .location(exampleResourceGroup.location())
 *             .resourceGroupName(exampleResourceGroup.name())
 *             .dnsPrefix(&#34;exampleaks1&#34;)
 *             .defaultNodePool(KubernetesClusterDefaultNodePoolArgs.builder()
 *                 .name(&#34;default&#34;)
 *                 .nodeCount(1)
 *                 .vmSize(&#34;Standard_D2_v2&#34;)
 *                 .build())
 *             .identity(KubernetesClusterIdentityArgs.builder()
 *                 .type(&#34;SystemAssigned&#34;)
 *                 .build())
 *             .tags(Map.of(&#34;Environment&#34;, &#34;Production&#34;))
 *             .build());
 * 
 *         ctx.export(&#34;clientCertificate&#34;, exampleKubernetesCluster.kubeConfigs().applyValue(kubeConfigs -&gt; kubeConfigs[0].clientCertificate()));
 *         ctx.export(&#34;kubeConfig&#34;, exampleKubernetesCluster.kubeConfigRaw());
 *     }
 * }
 * ```
 * 
 * ## Import
 * 
 * Managed Kubernetes Clusters can be imported using the `resource id`, e.g.
 * 
 * ```sh
 *  $ pulumi import azure:containerservice/kubernetesCluster:KubernetesCluster cluster1 /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/group1/providers/Microsoft.ContainerService/managedClusters/cluster1
 * ```
 * 
 */
@ResourceType(type="azure:containerservice/kubernetesCluster:KubernetesCluster")
public class KubernetesCluster extends com.pulumi.resources.CustomResource {
    /**
     * A `aci_connector_linux` block as defined below. For more details, please visit [Create and configure an AKS cluster to use virtual nodes](https://docs.microsoft.com/azure/aks/virtual-nodes-portal).
     * 
     */
    @Export(name="aciConnectorLinux", type=KubernetesClusterAciConnectorLinux.class, parameters={})
    private Output</* @Nullable */ KubernetesClusterAciConnectorLinux> aciConnectorLinux;

    /**
     * @return A `aci_connector_linux` block as defined below. For more details, please visit [Create and configure an AKS cluster to use virtual nodes](https://docs.microsoft.com/azure/aks/virtual-nodes-portal).
     * 
     */
    public Output<Optional<KubernetesClusterAciConnectorLinux>> aciConnectorLinux() {
        return Codegen.optional(this.aciConnectorLinux);
    }
    /**
     * An `api_server_access_profile` block as defined below.
     * 
     */
    @Export(name="apiServerAccessProfile", type=KubernetesClusterApiServerAccessProfile.class, parameters={})
    private Output<KubernetesClusterApiServerAccessProfile> apiServerAccessProfile;

    /**
     * @return An `api_server_access_profile` block as defined below.
     * 
     */
    public Output<KubernetesClusterApiServerAccessProfile> apiServerAccessProfile() {
        return this.apiServerAccessProfile;
    }
    /**
     * @deprecated
     * This property has been renamed to `authorized_ip_ranges` within the `api_server_access_profile` block and will be removed in v4.0 of the provider
     * 
     */
    @Deprecated /* This property has been renamed to `authorized_ip_ranges` within the `api_server_access_profile` block and will be removed in v4.0 of the provider */
    @Export(name="apiServerAuthorizedIpRanges", type=List.class, parameters={String.class})
    private Output<List<String>> apiServerAuthorizedIpRanges;

    public Output<List<String>> apiServerAuthorizedIpRanges() {
        return this.apiServerAuthorizedIpRanges;
    }
    /**
     * A `auto_scaler_profile` block as defined below.
     * 
     */
    @Export(name="autoScalerProfile", type=KubernetesClusterAutoScalerProfile.class, parameters={})
    private Output<KubernetesClusterAutoScalerProfile> autoScalerProfile;

    /**
     * @return A `auto_scaler_profile` block as defined below.
     * 
     */
    public Output<KubernetesClusterAutoScalerProfile> autoScalerProfile() {
        return this.autoScalerProfile;
    }
    /**
     * The upgrade channel for this Kubernetes Cluster. Possible values are `patch`, `rapid`, `node-image` and `stable`. Omitting this field sets this value to `none`.
     * 
     */
    @Export(name="automaticChannelUpgrade", type=String.class, parameters={})
    private Output</* @Nullable */ String> automaticChannelUpgrade;

    /**
     * @return The upgrade channel for this Kubernetes Cluster. Possible values are `patch`, `rapid`, `node-image` and `stable`. Omitting this field sets this value to `none`.
     * 
     */
    public Output<Optional<String>> automaticChannelUpgrade() {
        return Codegen.optional(this.automaticChannelUpgrade);
    }
    /**
     * A `azure_active_directory_role_based_access_control` block as defined below.
     * 
     */
    @Export(name="azureActiveDirectoryRoleBasedAccessControl", type=KubernetesClusterAzureActiveDirectoryRoleBasedAccessControl.class, parameters={})
    private Output</* @Nullable */ KubernetesClusterAzureActiveDirectoryRoleBasedAccessControl> azureActiveDirectoryRoleBasedAccessControl;

    /**
     * @return A `azure_active_directory_role_based_access_control` block as defined below.
     * 
     */
    public Output<Optional<KubernetesClusterAzureActiveDirectoryRoleBasedAccessControl>> azureActiveDirectoryRoleBasedAccessControl() {
        return Codegen.optional(this.azureActiveDirectoryRoleBasedAccessControl);
    }
    /**
     * Should the Azure Policy Add-On be enabled? For more details please visit [Understand Azure Policy for Azure Kubernetes Service](https://docs.microsoft.com/en-ie/azure/governance/policy/concepts/rego-for-aks)
     * 
     */
    @Export(name="azurePolicyEnabled", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> azurePolicyEnabled;

    /**
     * @return Should the Azure Policy Add-On be enabled? For more details please visit [Understand Azure Policy for Azure Kubernetes Service](https://docs.microsoft.com/en-ie/azure/governance/policy/concepts/rego-for-aks)
     * 
     */
    public Output<Optional<Boolean>> azurePolicyEnabled() {
        return Codegen.optional(this.azurePolicyEnabled);
    }
    /**
     * A `confidential_computing` block as defined below. For more details please [the documentation](https://learn.microsoft.com/en-us/azure/confidential-computing/confidential-nodes-aks-overview)
     * 
     */
    @Export(name="confidentialComputing", type=KubernetesClusterConfidentialComputing.class, parameters={})
    private Output</* @Nullable */ KubernetesClusterConfidentialComputing> confidentialComputing;

    /**
     * @return A `confidential_computing` block as defined below. For more details please [the documentation](https://learn.microsoft.com/en-us/azure/confidential-computing/confidential-nodes-aks-overview)
     * 
     */
    public Output<Optional<KubernetesClusterConfidentialComputing>> confidentialComputing() {
        return Codegen.optional(this.confidentialComputing);
    }
    /**
     * A `default_node_pool` block as defined below.
     * 
     */
    @Export(name="defaultNodePool", type=KubernetesClusterDefaultNodePool.class, parameters={})
    private Output<KubernetesClusterDefaultNodePool> defaultNodePool;

    /**
     * @return A `default_node_pool` block as defined below.
     * 
     */
    public Output<KubernetesClusterDefaultNodePool> defaultNodePool() {
        return this.defaultNodePool;
    }
    /**
     * The ID of the Disk Encryption Set which should be used for the Nodes and Volumes. More information [can be found in the documentation](https://docs.microsoft.com/azure/aks/azure-disk-customer-managed-keys). Changing this forces a new resource to be created.
     * 
     */
    @Export(name="diskEncryptionSetId", type=String.class, parameters={})
    private Output</* @Nullable */ String> diskEncryptionSetId;

    /**
     * @return The ID of the Disk Encryption Set which should be used for the Nodes and Volumes. More information [can be found in the documentation](https://docs.microsoft.com/azure/aks/azure-disk-customer-managed-keys). Changing this forces a new resource to be created.
     * 
     */
    public Output<Optional<String>> diskEncryptionSetId() {
        return Codegen.optional(this.diskEncryptionSetId);
    }
    /**
     * DNS prefix specified when creating the managed cluster. Possible values must begin and end with a letter or number, contain only letters, numbers, and hyphens and be between 1 and 54 characters in length. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="dnsPrefix", type=String.class, parameters={})
    private Output</* @Nullable */ String> dnsPrefix;

    /**
     * @return DNS prefix specified when creating the managed cluster. Possible values must begin and end with a letter or number, contain only letters, numbers, and hyphens and be between 1 and 54 characters in length. Changing this forces a new resource to be created.
     * 
     */
    public Output<Optional<String>> dnsPrefix() {
        return Codegen.optional(this.dnsPrefix);
    }
    /**
     * Specifies the DNS prefix to use with private clusters. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="dnsPrefixPrivateCluster", type=String.class, parameters={})
    private Output</* @Nullable */ String> dnsPrefixPrivateCluster;

    /**
     * @return Specifies the DNS prefix to use with private clusters. Changing this forces a new resource to be created.
     * 
     */
    public Output<Optional<String>> dnsPrefixPrivateCluster() {
        return Codegen.optional(this.dnsPrefixPrivateCluster);
    }
    /**
     * Specifies the Edge Zone within the Azure Region where this Managed Kubernetes Cluster should exist. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="edgeZone", type=String.class, parameters={})
    private Output</* @Nullable */ String> edgeZone;

    /**
     * @return Specifies the Edge Zone within the Azure Region where this Managed Kubernetes Cluster should exist. Changing this forces a new resource to be created.
     * 
     */
    public Output<Optional<String>> edgeZone() {
        return Codegen.optional(this.edgeZone);
    }
    /**
     * @deprecated
     * The AKS API has removed support for this field on 2020-10-15 and is no longer possible to configure this the Pod Security Policy.
     * 
     */
    @Deprecated /* The AKS API has removed support for this field on 2020-10-15 and is no longer possible to configure this the Pod Security Policy. */
    @Export(name="enablePodSecurityPolicy", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> enablePodSecurityPolicy;

    public Output<Optional<Boolean>> enablePodSecurityPolicy() {
        return Codegen.optional(this.enablePodSecurityPolicy);
    }
    /**
     * The FQDN of the Azure Kubernetes Managed Cluster.
     * 
     */
    @Export(name="fqdn", type=String.class, parameters={})
    private Output<String> fqdn;

    /**
     * @return The FQDN of the Azure Kubernetes Managed Cluster.
     * 
     */
    public Output<String> fqdn() {
        return this.fqdn;
    }
    /**
     * Should HTTP Application Routing be enabled?
     * 
     */
    @Export(name="httpApplicationRoutingEnabled", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> httpApplicationRoutingEnabled;

    /**
     * @return Should HTTP Application Routing be enabled?
     * 
     */
    public Output<Optional<Boolean>> httpApplicationRoutingEnabled() {
        return Codegen.optional(this.httpApplicationRoutingEnabled);
    }
    /**
     * The Zone Name of the HTTP Application Routing.
     * 
     */
    @Export(name="httpApplicationRoutingZoneName", type=String.class, parameters={})
    private Output<String> httpApplicationRoutingZoneName;

    /**
     * @return The Zone Name of the HTTP Application Routing.
     * 
     */
    public Output<String> httpApplicationRoutingZoneName() {
        return this.httpApplicationRoutingZoneName;
    }
    /**
     * A `http_proxy_config` block as defined below.
     * 
     */
    @Export(name="httpProxyConfig", type=KubernetesClusterHttpProxyConfig.class, parameters={})
    private Output</* @Nullable */ KubernetesClusterHttpProxyConfig> httpProxyConfig;

    /**
     * @return A `http_proxy_config` block as defined below.
     * 
     */
    public Output<Optional<KubernetesClusterHttpProxyConfig>> httpProxyConfig() {
        return Codegen.optional(this.httpProxyConfig);
    }
    /**
     * An `identity` block as defined below. One of either `identity` or `service_principal` must be specified.
     * 
     */
    @Export(name="identity", type=KubernetesClusterIdentity.class, parameters={})
    private Output</* @Nullable */ KubernetesClusterIdentity> identity;

    /**
     * @return An `identity` block as defined below. One of either `identity` or `service_principal` must be specified.
     * 
     */
    public Output<Optional<KubernetesClusterIdentity>> identity() {
        return Codegen.optional(this.identity);
    }
    /**
     * Specifies whether Image Cleaner is enabled.
     * 
     */
    @Export(name="imageCleanerEnabled", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> imageCleanerEnabled;

    /**
     * @return Specifies whether Image Cleaner is enabled.
     * 
     */
    public Output<Optional<Boolean>> imageCleanerEnabled() {
        return Codegen.optional(this.imageCleanerEnabled);
    }
    /**
     * Specifies the interval in hours when images should be cleaned up. Defaults to `48`.
     * 
     */
    @Export(name="imageCleanerIntervalHours", type=Integer.class, parameters={})
    private Output</* @Nullable */ Integer> imageCleanerIntervalHours;

    /**
     * @return Specifies the interval in hours when images should be cleaned up. Defaults to `48`.
     * 
     */
    public Output<Optional<Integer>> imageCleanerIntervalHours() {
        return Codegen.optional(this.imageCleanerIntervalHours);
    }
    /**
     * A `ingress_application_gateway` block as defined below.
     * 
     */
    @Export(name="ingressApplicationGateway", type=KubernetesClusterIngressApplicationGateway.class, parameters={})
    private Output</* @Nullable */ KubernetesClusterIngressApplicationGateway> ingressApplicationGateway;

    /**
     * @return A `ingress_application_gateway` block as defined below.
     * 
     */
    public Output<Optional<KubernetesClusterIngressApplicationGateway>> ingressApplicationGateway() {
        return Codegen.optional(this.ingressApplicationGateway);
    }
    /**
     * A `key_management_service` block as defined below. For more details, please visit [Key Management Service (KMS) etcd encryption to an AKS cluster](https://learn.microsoft.com/en-us/azure/aks/use-kms-etcd-encryption).
     * 
     */
    @Export(name="keyManagementService", type=KubernetesClusterKeyManagementService.class, parameters={})
    private Output</* @Nullable */ KubernetesClusterKeyManagementService> keyManagementService;

    /**
     * @return A `key_management_service` block as defined below. For more details, please visit [Key Management Service (KMS) etcd encryption to an AKS cluster](https://learn.microsoft.com/en-us/azure/aks/use-kms-etcd-encryption).
     * 
     */
    public Output<Optional<KubernetesClusterKeyManagementService>> keyManagementService() {
        return Codegen.optional(this.keyManagementService);
    }
    /**
     * A `key_vault_secrets_provider` block as defined below. For more details, please visit [Azure Keyvault Secrets Provider for AKS](https://docs.microsoft.com/azure/aks/csi-secrets-store-driver).
     * 
     */
    @Export(name="keyVaultSecretsProvider", type=KubernetesClusterKeyVaultSecretsProvider.class, parameters={})
    private Output</* @Nullable */ KubernetesClusterKeyVaultSecretsProvider> keyVaultSecretsProvider;

    /**
     * @return A `key_vault_secrets_provider` block as defined below. For more details, please visit [Azure Keyvault Secrets Provider for AKS](https://docs.microsoft.com/azure/aks/csi-secrets-store-driver).
     * 
     */
    public Output<Optional<KubernetesClusterKeyVaultSecretsProvider>> keyVaultSecretsProvider() {
        return Codegen.optional(this.keyVaultSecretsProvider);
    }
    /**
     * Raw Kubernetes config for the admin account to be used by [kubectl](https://kubernetes.io/docs/reference/kubectl/overview/) and other compatible tools. This is only available when Role Based Access Control with Azure Active Directory is enabled and local accounts enabled.
     * 
     */
    @Export(name="kubeAdminConfigRaw", type=String.class, parameters={})
    private Output<String> kubeAdminConfigRaw;

    /**
     * @return Raw Kubernetes config for the admin account to be used by [kubectl](https://kubernetes.io/docs/reference/kubectl/overview/) and other compatible tools. This is only available when Role Based Access Control with Azure Active Directory is enabled and local accounts enabled.
     * 
     */
    public Output<String> kubeAdminConfigRaw() {
        return this.kubeAdminConfigRaw;
    }
    /**
     * A `kube_admin_config` block as defined below. This is only available when Role Based Access Control with Azure Active Directory is enabled and local accounts enabled.
     * 
     */
    @Export(name="kubeAdminConfigs", type=List.class, parameters={KubernetesClusterKubeAdminConfig.class})
    private Output<List<KubernetesClusterKubeAdminConfig>> kubeAdminConfigs;

    /**
     * @return A `kube_admin_config` block as defined below. This is only available when Role Based Access Control with Azure Active Directory is enabled and local accounts enabled.
     * 
     */
    public Output<List<KubernetesClusterKubeAdminConfig>> kubeAdminConfigs() {
        return this.kubeAdminConfigs;
    }
    /**
     * Raw Kubernetes config to be used by [kubectl](https://kubernetes.io/docs/reference/kubectl/overview/) and other compatible tools.
     * 
     */
    @Export(name="kubeConfigRaw", type=String.class, parameters={})
    private Output<String> kubeConfigRaw;

    /**
     * @return Raw Kubernetes config to be used by [kubectl](https://kubernetes.io/docs/reference/kubectl/overview/) and other compatible tools.
     * 
     */
    public Output<String> kubeConfigRaw() {
        return this.kubeConfigRaw;
    }
    /**
     * A `kube_config` block as defined below.
     * 
     */
    @Export(name="kubeConfigs", type=List.class, parameters={KubernetesClusterKubeConfig.class})
    private Output<List<KubernetesClusterKubeConfig>> kubeConfigs;

    /**
     * @return A `kube_config` block as defined below.
     * 
     */
    public Output<List<KubernetesClusterKubeConfig>> kubeConfigs() {
        return this.kubeConfigs;
    }
    /**
     * A `kubelet_identity` block as defined below.
     * 
     */
    @Export(name="kubeletIdentity", type=KubernetesClusterKubeletIdentity.class, parameters={})
    private Output<KubernetesClusterKubeletIdentity> kubeletIdentity;

    /**
     * @return A `kubelet_identity` block as defined below.
     * 
     */
    public Output<KubernetesClusterKubeletIdentity> kubeletIdentity() {
        return this.kubeletIdentity;
    }
    /**
     * Version of Kubernetes specified when creating the AKS managed cluster. If not specified, the latest recommended version will be used at provisioning time (but won&#39;t auto-upgrade). AKS does not require an exact patch version to be specified, minor version aliases such as `1.22` are also supported. - The minor version&#39;s latest GA patch is automatically chosen in that case. More details can be found in [the documentation](https://docs.microsoft.com/en-us/azure/aks/supported-kubernetes-versions?tabs=azure-cli#alias-minor-version).
     * 
     */
    @Export(name="kubernetesVersion", type=String.class, parameters={})
    private Output<String> kubernetesVersion;

    /**
     * @return Version of Kubernetes specified when creating the AKS managed cluster. If not specified, the latest recommended version will be used at provisioning time (but won&#39;t auto-upgrade). AKS does not require an exact patch version to be specified, minor version aliases such as `1.22` are also supported. - The minor version&#39;s latest GA patch is automatically chosen in that case. More details can be found in [the documentation](https://docs.microsoft.com/en-us/azure/aks/supported-kubernetes-versions?tabs=azure-cli#alias-minor-version).
     * 
     */
    public Output<String> kubernetesVersion() {
        return this.kubernetesVersion;
    }
    /**
     * A `linux_profile` block as defined below.
     * 
     */
    @Export(name="linuxProfile", type=KubernetesClusterLinuxProfile.class, parameters={})
    private Output</* @Nullable */ KubernetesClusterLinuxProfile> linuxProfile;

    /**
     * @return A `linux_profile` block as defined below.
     * 
     */
    public Output<Optional<KubernetesClusterLinuxProfile>> linuxProfile() {
        return Codegen.optional(this.linuxProfile);
    }
    /**
     * If `true` local accounts will be disabled. See [the documentation](https://docs.microsoft.com/azure/aks/managed-aad#disable-local-accounts) for more information.
     * 
     */
    @Export(name="localAccountDisabled", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> localAccountDisabled;

    /**
     * @return If `true` local accounts will be disabled. See [the documentation](https://docs.microsoft.com/azure/aks/managed-aad#disable-local-accounts) for more information.
     * 
     */
    public Output<Optional<Boolean>> localAccountDisabled() {
        return Codegen.optional(this.localAccountDisabled);
    }
    /**
     * The location where the Managed Kubernetes Cluster should be created. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="location", type=String.class, parameters={})
    private Output<String> location;

    /**
     * @return The location where the Managed Kubernetes Cluster should be created. Changing this forces a new resource to be created.
     * 
     */
    public Output<String> location() {
        return this.location;
    }
    /**
     * A `maintenance_window` block as defined below.
     * 
     */
    @Export(name="maintenanceWindow", type=KubernetesClusterMaintenanceWindow.class, parameters={})
    private Output</* @Nullable */ KubernetesClusterMaintenanceWindow> maintenanceWindow;

    /**
     * @return A `maintenance_window` block as defined below.
     * 
     */
    public Output<Optional<KubernetesClusterMaintenanceWindow>> maintenanceWindow() {
        return Codegen.optional(this.maintenanceWindow);
    }
    /**
     * A `microsoft_defender` block as defined below.
     * 
     */
    @Export(name="microsoftDefender", type=KubernetesClusterMicrosoftDefender.class, parameters={})
    private Output</* @Nullable */ KubernetesClusterMicrosoftDefender> microsoftDefender;

    /**
     * @return A `microsoft_defender` block as defined below.
     * 
     */
    public Output<Optional<KubernetesClusterMicrosoftDefender>> microsoftDefender() {
        return Codegen.optional(this.microsoftDefender);
    }
    /**
     * Specifies a Prometheus add-on profile for the Kubernetes Cluster. A `monitor_metrics` block as defined below.
     * 
     */
    @Export(name="monitorMetrics", type=KubernetesClusterMonitorMetrics.class, parameters={})
    private Output</* @Nullable */ KubernetesClusterMonitorMetrics> monitorMetrics;

    /**
     * @return Specifies a Prometheus add-on profile for the Kubernetes Cluster. A `monitor_metrics` block as defined below.
     * 
     */
    public Output<Optional<KubernetesClusterMonitorMetrics>> monitorMetrics() {
        return Codegen.optional(this.monitorMetrics);
    }
    /**
     * The name of the Managed Kubernetes Cluster to create. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="name", type=String.class, parameters={})
    private Output<String> name;

    /**
     * @return The name of the Managed Kubernetes Cluster to create. Changing this forces a new resource to be created.
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * A `network_profile` block as defined below. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="networkProfile", type=KubernetesClusterNetworkProfile.class, parameters={})
    private Output<KubernetesClusterNetworkProfile> networkProfile;

    /**
     * @return A `network_profile` block as defined below. Changing this forces a new resource to be created.
     * 
     */
    public Output<KubernetesClusterNetworkProfile> networkProfile() {
        return this.networkProfile;
    }
    /**
     * The name of the Resource Group where the Kubernetes Nodes should exist. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="nodeResourceGroup", type=String.class, parameters={})
    private Output<String> nodeResourceGroup;

    /**
     * @return The name of the Resource Group where the Kubernetes Nodes should exist. Changing this forces a new resource to be created.
     * 
     */
    public Output<String> nodeResourceGroup() {
        return this.nodeResourceGroup;
    }
    /**
     * The ID of the Resource Group containing the resources for this Managed Kubernetes Cluster.
     * 
     */
    @Export(name="nodeResourceGroupId", type=String.class, parameters={})
    private Output<String> nodeResourceGroupId;

    /**
     * @return The ID of the Resource Group containing the resources for this Managed Kubernetes Cluster.
     * 
     */
    public Output<String> nodeResourceGroupId() {
        return this.nodeResourceGroupId;
    }
    /**
     * Enable or Disable the [OIDC issuer URL](https://learn.microsoft.com/en-gb/azure/aks/use-oidc-issuer)
     * 
     */
    @Export(name="oidcIssuerEnabled", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> oidcIssuerEnabled;

    /**
     * @return Enable or Disable the [OIDC issuer URL](https://learn.microsoft.com/en-gb/azure/aks/use-oidc-issuer)
     * 
     */
    public Output<Optional<Boolean>> oidcIssuerEnabled() {
        return Codegen.optional(this.oidcIssuerEnabled);
    }
    /**
     * The OIDC issuer URL that is associated with the cluster.
     * 
     */
    @Export(name="oidcIssuerUrl", type=String.class, parameters={})
    private Output<String> oidcIssuerUrl;

    /**
     * @return The OIDC issuer URL that is associated with the cluster.
     * 
     */
    public Output<String> oidcIssuerUrl() {
        return this.oidcIssuerUrl;
    }
    /**
     * A `oms_agent` block as defined below.
     * 
     */
    @Export(name="omsAgent", type=KubernetesClusterOmsAgent.class, parameters={})
    private Output</* @Nullable */ KubernetesClusterOmsAgent> omsAgent;

    /**
     * @return A `oms_agent` block as defined below.
     * 
     */
    public Output<Optional<KubernetesClusterOmsAgent>> omsAgent() {
        return Codegen.optional(this.omsAgent);
    }
    /**
     * Is Open Service Mesh enabled? For more details, please visit [Open Service Mesh for AKS](https://docs.microsoft.com/azure/aks/open-service-mesh-about).
     * 
     */
    @Export(name="openServiceMeshEnabled", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> openServiceMeshEnabled;

    /**
     * @return Is Open Service Mesh enabled? For more details, please visit [Open Service Mesh for AKS](https://docs.microsoft.com/azure/aks/open-service-mesh-about).
     * 
     */
    public Output<Optional<Boolean>> openServiceMeshEnabled() {
        return Codegen.optional(this.openServiceMeshEnabled);
    }
    /**
     * The FQDN for the Azure Portal resources when private link has been enabled, which is only resolvable inside the Virtual Network used by the Kubernetes Cluster.
     * 
     */
    @Export(name="portalFqdn", type=String.class, parameters={})
    private Output<String> portalFqdn;

    /**
     * @return The FQDN for the Azure Portal resources when private link has been enabled, which is only resolvable inside the Virtual Network used by the Kubernetes Cluster.
     * 
     */
    public Output<String> portalFqdn() {
        return this.portalFqdn;
    }
    /**
     * Should this Kubernetes Cluster have its API server only exposed on internal IP addresses? This provides a Private IP Address for the Kubernetes API on the Virtual Network where the Kubernetes Cluster is located. Defaults to `false`. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="privateClusterEnabled", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> privateClusterEnabled;

    /**
     * @return Should this Kubernetes Cluster have its API server only exposed on internal IP addresses? This provides a Private IP Address for the Kubernetes API on the Virtual Network where the Kubernetes Cluster is located. Defaults to `false`. Changing this forces a new resource to be created.
     * 
     */
    public Output<Optional<Boolean>> privateClusterEnabled() {
        return Codegen.optional(this.privateClusterEnabled);
    }
    /**
     * Specifies whether a Public FQDN for this Private Cluster should be added. Defaults to `false`.
     * 
     */
    @Export(name="privateClusterPublicFqdnEnabled", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> privateClusterPublicFqdnEnabled;

    /**
     * @return Specifies whether a Public FQDN for this Private Cluster should be added. Defaults to `false`.
     * 
     */
    public Output<Optional<Boolean>> privateClusterPublicFqdnEnabled() {
        return Codegen.optional(this.privateClusterPublicFqdnEnabled);
    }
    /**
     * Either the ID of Private DNS Zone which should be delegated to this Cluster, `System` to have AKS manage this or `None`. In case of `None` you will need to bring your own DNS server and set up resolving, otherwise, the cluster will have issues after provisioning. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="privateDnsZoneId", type=String.class, parameters={})
    private Output<String> privateDnsZoneId;

    /**
     * @return Either the ID of Private DNS Zone which should be delegated to this Cluster, `System` to have AKS manage this or `None`. In case of `None` you will need to bring your own DNS server and set up resolving, otherwise, the cluster will have issues after provisioning. Changing this forces a new resource to be created.
     * 
     */
    public Output<String> privateDnsZoneId() {
        return this.privateDnsZoneId;
    }
    /**
     * The FQDN for the Kubernetes Cluster when private link has been enabled, which is only resolvable inside the Virtual Network used by the Kubernetes Cluster.
     * 
     */
    @Export(name="privateFqdn", type=String.class, parameters={})
    private Output<String> privateFqdn;

    /**
     * @return The FQDN for the Kubernetes Cluster when private link has been enabled, which is only resolvable inside the Virtual Network used by the Kubernetes Cluster.
     * 
     */
    public Output<String> privateFqdn() {
        return this.privateFqdn;
    }
    /**
     * Whether public network access is allowed for this Kubernetes Cluster. Defaults to `true`. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="publicNetworkAccessEnabled", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> publicNetworkAccessEnabled;

    /**
     * @return Whether public network access is allowed for this Kubernetes Cluster. Defaults to `true`. Changing this forces a new resource to be created.
     * 
     */
    public Output<Optional<Boolean>> publicNetworkAccessEnabled() {
        return Codegen.optional(this.publicNetworkAccessEnabled);
    }
    /**
     * Specifies the Resource Group where the Managed Kubernetes Cluster should exist. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="resourceGroupName", type=String.class, parameters={})
    private Output<String> resourceGroupName;

    /**
     * @return Specifies the Resource Group where the Managed Kubernetes Cluster should exist. Changing this forces a new resource to be created.
     * 
     */
    public Output<String> resourceGroupName() {
        return this.resourceGroupName;
    }
    /**
     * Whether Role Based Access Control for the Kubernetes Cluster should be enabled. Defaults to `true`. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="roleBasedAccessControlEnabled", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> roleBasedAccessControlEnabled;

    /**
     * @return Whether Role Based Access Control for the Kubernetes Cluster should be enabled. Defaults to `true`. Changing this forces a new resource to be created.
     * 
     */
    public Output<Optional<Boolean>> roleBasedAccessControlEnabled() {
        return Codegen.optional(this.roleBasedAccessControlEnabled);
    }
    /**
     * Whether to enable run command for the cluster or not. Defaults to `true`.
     * 
     */
    @Export(name="runCommandEnabled", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> runCommandEnabled;

    /**
     * @return Whether to enable run command for the cluster or not. Defaults to `true`.
     * 
     */
    public Output<Optional<Boolean>> runCommandEnabled() {
        return Codegen.optional(this.runCommandEnabled);
    }
    /**
     * A `service_principal` block as documented below. One of either `identity` or `service_principal` must be specified.
     * 
     */
    @Export(name="servicePrincipal", type=KubernetesClusterServicePrincipal.class, parameters={})
    private Output</* @Nullable */ KubernetesClusterServicePrincipal> servicePrincipal;

    /**
     * @return A `service_principal` block as documented below. One of either `identity` or `service_principal` must be specified.
     * 
     */
    public Output<Optional<KubernetesClusterServicePrincipal>> servicePrincipal() {
        return Codegen.optional(this.servicePrincipal);
    }
    /**
     * The SKU Tier that should be used for this Kubernetes Cluster. Possible values are `Free`, `Paid` and `Standard` (which includes the Uptime SLA). Defaults to `Free`.
     * 
     */
    @Export(name="skuTier", type=String.class, parameters={})
    private Output</* @Nullable */ String> skuTier;

    /**
     * @return The SKU Tier that should be used for this Kubernetes Cluster. Possible values are `Free`, `Paid` and `Standard` (which includes the Uptime SLA). Defaults to `Free`.
     * 
     */
    public Output<Optional<String>> skuTier() {
        return Codegen.optional(this.skuTier);
    }
    /**
     * A `storage_profile` block as defined below.
     * 
     */
    @Export(name="storageProfile", type=KubernetesClusterStorageProfile.class, parameters={})
    private Output</* @Nullable */ KubernetesClusterStorageProfile> storageProfile;

    /**
     * @return A `storage_profile` block as defined below.
     * 
     */
    public Output<Optional<KubernetesClusterStorageProfile>> storageProfile() {
        return Codegen.optional(this.storageProfile);
    }
    /**
     * A mapping of tags to assign to the resource.
     * 
     */
    @Export(name="tags", type=Map.class, parameters={String.class, String.class})
    private Output</* @Nullable */ Map<String,String>> tags;

    /**
     * @return A mapping of tags to assign to the resource.
     * 
     */
    public Output<Optional<Map<String,String>>> tags() {
        return Codegen.optional(this.tags);
    }
    /**
     * A `web_app_routing` block as defined below.
     * 
     */
    @Export(name="webAppRouting", type=KubernetesClusterWebAppRouting.class, parameters={})
    private Output</* @Nullable */ KubernetesClusterWebAppRouting> webAppRouting;

    /**
     * @return A `web_app_routing` block as defined below.
     * 
     */
    public Output<Optional<KubernetesClusterWebAppRouting>> webAppRouting() {
        return Codegen.optional(this.webAppRouting);
    }
    /**
     * A `windows_profile` block as defined below.
     * 
     */
    @Export(name="windowsProfile", type=KubernetesClusterWindowsProfile.class, parameters={})
    private Output<KubernetesClusterWindowsProfile> windowsProfile;

    /**
     * @return A `windows_profile` block as defined below.
     * 
     */
    public Output<KubernetesClusterWindowsProfile> windowsProfile() {
        return this.windowsProfile;
    }
    /**
     * A `workload_autoscaler_profile` block defined below.
     * 
     */
    @Export(name="workloadAutoscalerProfile", type=KubernetesClusterWorkloadAutoscalerProfile.class, parameters={})
    private Output</* @Nullable */ KubernetesClusterWorkloadAutoscalerProfile> workloadAutoscalerProfile;

    /**
     * @return A `workload_autoscaler_profile` block defined below.
     * 
     */
    public Output<Optional<KubernetesClusterWorkloadAutoscalerProfile>> workloadAutoscalerProfile() {
        return Codegen.optional(this.workloadAutoscalerProfile);
    }
    /**
     * Specifies whether Azure AD Workload Identity should be enabled for the Cluster. Defaults to `false`.
     * 
     */
    @Export(name="workloadIdentityEnabled", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> workloadIdentityEnabled;

    /**
     * @return Specifies whether Azure AD Workload Identity should be enabled for the Cluster. Defaults to `false`.
     * 
     */
    public Output<Optional<Boolean>> workloadIdentityEnabled() {
        return Codegen.optional(this.workloadIdentityEnabled);
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public KubernetesCluster(String name) {
        this(name, KubernetesClusterArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public KubernetesCluster(String name, KubernetesClusterArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public KubernetesCluster(String name, KubernetesClusterArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("azure:containerservice/kubernetesCluster:KubernetesCluster", name, args == null ? KubernetesClusterArgs.Empty : args, makeResourceOptions(options, Codegen.empty()));
    }

    private KubernetesCluster(String name, Output<String> id, @Nullable KubernetesClusterState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("azure:containerservice/kubernetesCluster:KubernetesCluster", name, state, makeResourceOptions(options, id));
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .additionalSecretOutputs(List.of(
                "kubeAdminConfigRaw",
                "kubeAdminConfigs",
                "kubeConfigRaw",
                "kubeConfigs"
            ))
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static KubernetesCluster get(String name, Output<String> id, @Nullable KubernetesClusterState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new KubernetesCluster(name, id, state, options);
    }
}
