// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.azure.containerservice;

import com.pulumi.azure.Utilities;
import com.pulumi.azure.containerservice.KubernetesClusterArgs;
import com.pulumi.azure.containerservice.inputs.KubernetesClusterState;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterAciConnectorLinux;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterApiServerAccessProfile;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterAutoScalerProfile;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterAzureActiveDirectoryRoleBasedAccessControl;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterConfidentialComputing;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterDefaultNodePool;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterHttpProxyConfig;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterIdentity;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterIngressApplicationGateway;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterKeyManagementService;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterKeyVaultSecretsProvider;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterKubeAdminConfig;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterKubeConfig;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterKubeletIdentity;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterLinuxProfile;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterMaintenanceWindow;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterMaintenanceWindowAutoUpgrade;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterMaintenanceWindowNodeOs;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterMicrosoftDefender;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterMonitorMetrics;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterNetworkProfile;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterOmsAgent;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterServiceMeshProfile;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterServicePrincipal;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterStorageProfile;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterUpgradeOverride;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterWebAppRouting;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterWindowsProfile;
import com.pulumi.azure.containerservice.outputs.KubernetesClusterWorkloadAutoscalerProfile;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * Manages a Managed Kubernetes Cluster (also known as AKS / Azure Kubernetes Service)
 * 
 * &gt; **Note:** Due to the fast-moving nature of AKS, we recommend using the latest version of the Azure Provider when using AKS.
 * 
 * ## Example Usage
 * 
 * This example provisions a basic Managed Kubernetes Cluster.
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.azure.core.ResourceGroup;
 * import com.pulumi.azure.core.ResourceGroupArgs;
 * import com.pulumi.azure.containerservice.KubernetesCluster;
 * import com.pulumi.azure.containerservice.KubernetesClusterArgs;
 * import com.pulumi.azure.containerservice.inputs.KubernetesClusterDefaultNodePoolArgs;
 * import com.pulumi.azure.containerservice.inputs.KubernetesClusterIdentityArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var example = new ResourceGroup("example", ResourceGroupArgs.builder()
 *             .name("example-resources")
 *             .location("West Europe")
 *             .build());
 * 
 *         var exampleKubernetesCluster = new KubernetesCluster("exampleKubernetesCluster", KubernetesClusterArgs.builder()
 *             .name("example-aks1")
 *             .location(example.location())
 *             .resourceGroupName(example.name())
 *             .dnsPrefix("exampleaks1")
 *             .defaultNodePool(KubernetesClusterDefaultNodePoolArgs.builder()
 *                 .name("default")
 *                 .nodeCount(1)
 *                 .vmSize("Standard_D2_v2")
 *                 .build())
 *             .identity(KubernetesClusterIdentityArgs.builder()
 *                 .type("SystemAssigned")
 *                 .build())
 *             .tags(Map.of("Environment", "Production"))
 *             .build());
 * 
 *         ctx.export("clientCertificate", exampleKubernetesCluster.kubeConfigs().applyValue(_kubeConfigs -> _kubeConfigs[0].clientCertificate()));
 *         ctx.export("kubeConfig", exampleKubernetesCluster.kubeConfigRaw());
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * 
 * ## Import
 * 
 * Managed Kubernetes Clusters can be imported using the `resource id`, e.g.
 * 
 * ```sh
 * $ pulumi import azure:containerservice/kubernetesCluster:KubernetesCluster cluster1 /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/group1/providers/Microsoft.ContainerService/managedClusters/cluster1
 * ```
 * 
 */
@ResourceType(type="azure:containerservice/kubernetesCluster:KubernetesCluster")
public class KubernetesCluster extends com.pulumi.resources.CustomResource {
    /**
     * A `aci_connector_linux` block as defined below. For more details, please visit [Create and configure an AKS cluster to use virtual nodes](https://docs.microsoft.com/azure/aks/virtual-nodes-portal).
     * 
     */
    @Export(name="aciConnectorLinux", refs={KubernetesClusterAciConnectorLinux.class}, tree="[0]")
    private Output</* @Nullable */ KubernetesClusterAciConnectorLinux> aciConnectorLinux;

    /**
     * @return A `aci_connector_linux` block as defined below. For more details, please visit [Create and configure an AKS cluster to use virtual nodes](https://docs.microsoft.com/azure/aks/virtual-nodes-portal).
     * 
     */
    public Output<Optional<KubernetesClusterAciConnectorLinux>> aciConnectorLinux() {
        return Codegen.optional(this.aciConnectorLinux);
    }
    /**
     * An `api_server_access_profile` block as defined below.
     * 
     */
    @Export(name="apiServerAccessProfile", refs={KubernetesClusterApiServerAccessProfile.class}, tree="[0]")
    private Output</* @Nullable */ KubernetesClusterApiServerAccessProfile> apiServerAccessProfile;

    /**
     * @return An `api_server_access_profile` block as defined below.
     * 
     */
    public Output<Optional<KubernetesClusterApiServerAccessProfile>> apiServerAccessProfile() {
        return Codegen.optional(this.apiServerAccessProfile);
    }
    /**
     * A `auto_scaler_profile` block as defined below.
     * 
     */
    @Export(name="autoScalerProfile", refs={KubernetesClusterAutoScalerProfile.class}, tree="[0]")
    private Output<KubernetesClusterAutoScalerProfile> autoScalerProfile;

    /**
     * @return A `auto_scaler_profile` block as defined below.
     * 
     */
    public Output<KubernetesClusterAutoScalerProfile> autoScalerProfile() {
        return this.autoScalerProfile;
    }
    /**
     * The upgrade channel for this Kubernetes Cluster. Possible values are `patch`, `rapid`, `node-image` and `stable`. Omitting this field sets this value to `none`.
     * 
     * !&gt; **Note:** Cluster Auto-Upgrade will update the Kubernetes Cluster (and its Node Pools) to the latest GA version of Kubernetes automatically - please [see the Azure documentation for more information](https://docs.microsoft.com/azure/aks/upgrade-cluster#set-auto-upgrade-channel).
     * 
     * &gt; **Note:** Cluster Auto-Upgrade only updates to GA versions of Kubernetes and will not update to Preview versions.
     * 
     */
    @Export(name="automaticUpgradeChannel", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> automaticUpgradeChannel;

    /**
     * @return The upgrade channel for this Kubernetes Cluster. Possible values are `patch`, `rapid`, `node-image` and `stable`. Omitting this field sets this value to `none`.
     * 
     * !&gt; **Note:** Cluster Auto-Upgrade will update the Kubernetes Cluster (and its Node Pools) to the latest GA version of Kubernetes automatically - please [see the Azure documentation for more information](https://docs.microsoft.com/azure/aks/upgrade-cluster#set-auto-upgrade-channel).
     * 
     * &gt; **Note:** Cluster Auto-Upgrade only updates to GA versions of Kubernetes and will not update to Preview versions.
     * 
     */
    public Output<Optional<String>> automaticUpgradeChannel() {
        return Codegen.optional(this.automaticUpgradeChannel);
    }
    /**
     * A `azure_active_directory_role_based_access_control` block as defined below.
     * 
     */
    @Export(name="azureActiveDirectoryRoleBasedAccessControl", refs={KubernetesClusterAzureActiveDirectoryRoleBasedAccessControl.class}, tree="[0]")
    private Output</* @Nullable */ KubernetesClusterAzureActiveDirectoryRoleBasedAccessControl> azureActiveDirectoryRoleBasedAccessControl;

    /**
     * @return A `azure_active_directory_role_based_access_control` block as defined below.
     * 
     */
    public Output<Optional<KubernetesClusterAzureActiveDirectoryRoleBasedAccessControl>> azureActiveDirectoryRoleBasedAccessControl() {
        return Codegen.optional(this.azureActiveDirectoryRoleBasedAccessControl);
    }
    /**
     * Should the Azure Policy Add-On be enabled? For more details please visit [Understand Azure Policy for Azure Kubernetes Service](https://docs.microsoft.com/en-ie/azure/governance/policy/concepts/rego-for-aks)
     * 
     */
    @Export(name="azurePolicyEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> azurePolicyEnabled;

    /**
     * @return Should the Azure Policy Add-On be enabled? For more details please visit [Understand Azure Policy for Azure Kubernetes Service](https://docs.microsoft.com/en-ie/azure/governance/policy/concepts/rego-for-aks)
     * 
     */
    public Output<Optional<Boolean>> azurePolicyEnabled() {
        return Codegen.optional(this.azurePolicyEnabled);
    }
    /**
     * A `confidential_computing` block as defined below. For more details please [the documentation](https://learn.microsoft.com/en-us/azure/confidential-computing/confidential-nodes-aks-overview)
     * 
     */
    @Export(name="confidentialComputing", refs={KubernetesClusterConfidentialComputing.class}, tree="[0]")
    private Output</* @Nullable */ KubernetesClusterConfidentialComputing> confidentialComputing;

    /**
     * @return A `confidential_computing` block as defined below. For more details please [the documentation](https://learn.microsoft.com/en-us/azure/confidential-computing/confidential-nodes-aks-overview)
     * 
     */
    public Output<Optional<KubernetesClusterConfidentialComputing>> confidentialComputing() {
        return Codegen.optional(this.confidentialComputing);
    }
    /**
     * Should cost analysis be enabled for this Kubernetes Cluster? Defaults to `false`. The `sku_tier` must be set to `Standard` or `Premium` to enable this feature. Enabling this will add Kubernetes Namespace and Deployment details to the Cost Analysis views in the Azure portal.
     * 
     */
    @Export(name="costAnalysisEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> costAnalysisEnabled;

    /**
     * @return Should cost analysis be enabled for this Kubernetes Cluster? Defaults to `false`. The `sku_tier` must be set to `Standard` or `Premium` to enable this feature. Enabling this will add Kubernetes Namespace and Deployment details to the Cost Analysis views in the Azure portal.
     * 
     */
    public Output<Optional<Boolean>> costAnalysisEnabled() {
        return Codegen.optional(this.costAnalysisEnabled);
    }
    /**
     * The current version running on the Azure Kubernetes Managed Cluster.
     * 
     */
    @Export(name="currentKubernetesVersion", refs={String.class}, tree="[0]")
    private Output<String> currentKubernetesVersion;

    /**
     * @return The current version running on the Azure Kubernetes Managed Cluster.
     * 
     */
    public Output<String> currentKubernetesVersion() {
        return this.currentKubernetesVersion;
    }
    /**
     * Specifies configuration for &#34;System&#34; mode node pool. A `default_node_pool` block as defined below.
     * 
     */
    @Export(name="defaultNodePool", refs={KubernetesClusterDefaultNodePool.class}, tree="[0]")
    private Output<KubernetesClusterDefaultNodePool> defaultNodePool;

    /**
     * @return Specifies configuration for &#34;System&#34; mode node pool. A `default_node_pool` block as defined below.
     * 
     */
    public Output<KubernetesClusterDefaultNodePool> defaultNodePool() {
        return this.defaultNodePool;
    }
    /**
     * The ID of the Disk Encryption Set which should be used for the Nodes and Volumes. More information [can be found in the documentation](https://docs.microsoft.com/azure/aks/azure-disk-customer-managed-keys). Changing this forces a new resource to be created.
     * 
     */
    @Export(name="diskEncryptionSetId", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> diskEncryptionSetId;

    /**
     * @return The ID of the Disk Encryption Set which should be used for the Nodes and Volumes. More information [can be found in the documentation](https://docs.microsoft.com/azure/aks/azure-disk-customer-managed-keys). Changing this forces a new resource to be created.
     * 
     */
    public Output<Optional<String>> diskEncryptionSetId() {
        return Codegen.optional(this.diskEncryptionSetId);
    }
    /**
     * DNS prefix specified when creating the managed cluster. Possible values must begin and end with a letter or number, contain only letters, numbers, and hyphens and be between 1 and 54 characters in length. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="dnsPrefix", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> dnsPrefix;

    /**
     * @return DNS prefix specified when creating the managed cluster. Possible values must begin and end with a letter or number, contain only letters, numbers, and hyphens and be between 1 and 54 characters in length. Changing this forces a new resource to be created.
     * 
     */
    public Output<Optional<String>> dnsPrefix() {
        return Codegen.optional(this.dnsPrefix);
    }
    /**
     * Specifies the DNS prefix to use with private clusters. Changing this forces a new resource to be created.
     * 
     * &gt; **Note:** You must define either a `dns_prefix` or a `dns_prefix_private_cluster` field.
     * 
     * In addition, one of either `identity` or `service_principal` blocks must be specified.
     * 
     */
    @Export(name="dnsPrefixPrivateCluster", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> dnsPrefixPrivateCluster;

    /**
     * @return Specifies the DNS prefix to use with private clusters. Changing this forces a new resource to be created.
     * 
     * &gt; **Note:** You must define either a `dns_prefix` or a `dns_prefix_private_cluster` field.
     * 
     * In addition, one of either `identity` or `service_principal` blocks must be specified.
     * 
     */
    public Output<Optional<String>> dnsPrefixPrivateCluster() {
        return Codegen.optional(this.dnsPrefixPrivateCluster);
    }
    /**
     * Specifies the Extended Zone (formerly called Edge Zone) within the Azure Region where this Managed Kubernetes Cluster should exist. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="edgeZone", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> edgeZone;

    /**
     * @return Specifies the Extended Zone (formerly called Edge Zone) within the Azure Region where this Managed Kubernetes Cluster should exist. Changing this forces a new resource to be created.
     * 
     */
    public Output<Optional<String>> edgeZone() {
        return Codegen.optional(this.edgeZone);
    }
    /**
     * The FQDN of the Azure Kubernetes Managed Cluster.
     * 
     */
    @Export(name="fqdn", refs={String.class}, tree="[0]")
    private Output<String> fqdn;

    /**
     * @return The FQDN of the Azure Kubernetes Managed Cluster.
     * 
     */
    public Output<String> fqdn() {
        return this.fqdn;
    }
    /**
     * Should HTTP Application Routing be enabled?
     * 
     * &gt; **Note:** At this time HTTP Application Routing is not supported in Azure China or Azure US Government.
     * 
     */
    @Export(name="httpApplicationRoutingEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> httpApplicationRoutingEnabled;

    /**
     * @return Should HTTP Application Routing be enabled?
     * 
     * &gt; **Note:** At this time HTTP Application Routing is not supported in Azure China or Azure US Government.
     * 
     */
    public Output<Optional<Boolean>> httpApplicationRoutingEnabled() {
        return Codegen.optional(this.httpApplicationRoutingEnabled);
    }
    /**
     * The Zone Name of the HTTP Application Routing.
     * 
     */
    @Export(name="httpApplicationRoutingZoneName", refs={String.class}, tree="[0]")
    private Output<String> httpApplicationRoutingZoneName;

    /**
     * @return The Zone Name of the HTTP Application Routing.
     * 
     */
    public Output<String> httpApplicationRoutingZoneName() {
        return this.httpApplicationRoutingZoneName;
    }
    /**
     * A `http_proxy_config` block as defined below.
     * 
     */
    @Export(name="httpProxyConfig", refs={KubernetesClusterHttpProxyConfig.class}, tree="[0]")
    private Output</* @Nullable */ KubernetesClusterHttpProxyConfig> httpProxyConfig;

    /**
     * @return A `http_proxy_config` block as defined below.
     * 
     */
    public Output<Optional<KubernetesClusterHttpProxyConfig>> httpProxyConfig() {
        return Codegen.optional(this.httpProxyConfig);
    }
    /**
     * An `identity` block as defined below. One of either `identity` or `service_principal` must be specified.
     * 
     * !&gt; **Note:** A migration scenario from `service_principal` to `identity` is supported. When upgrading `service_principal` to `identity`, your cluster&#39;s control plane and addon pods will switch to use managed identity, but the kubelets will keep using your configured `service_principal` until you upgrade your Node Pool.
     * 
     */
    @Export(name="identity", refs={KubernetesClusterIdentity.class}, tree="[0]")
    private Output</* @Nullable */ KubernetesClusterIdentity> identity;

    /**
     * @return An `identity` block as defined below. One of either `identity` or `service_principal` must be specified.
     * 
     * !&gt; **Note:** A migration scenario from `service_principal` to `identity` is supported. When upgrading `service_principal` to `identity`, your cluster&#39;s control plane and addon pods will switch to use managed identity, but the kubelets will keep using your configured `service_principal` until you upgrade your Node Pool.
     * 
     */
    public Output<Optional<KubernetesClusterIdentity>> identity() {
        return Codegen.optional(this.identity);
    }
    /**
     * Specifies whether Image Cleaner is enabled.
     * 
     */
    @Export(name="imageCleanerEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> imageCleanerEnabled;

    /**
     * @return Specifies whether Image Cleaner is enabled.
     * 
     */
    public Output<Optional<Boolean>> imageCleanerEnabled() {
        return Codegen.optional(this.imageCleanerEnabled);
    }
    /**
     * Specifies the interval in hours when images should be cleaned up. Defaults to `0`.
     * 
     */
    @Export(name="imageCleanerIntervalHours", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> imageCleanerIntervalHours;

    /**
     * @return Specifies the interval in hours when images should be cleaned up. Defaults to `0`.
     * 
     */
    public Output<Optional<Integer>> imageCleanerIntervalHours() {
        return Codegen.optional(this.imageCleanerIntervalHours);
    }
    /**
     * A `ingress_application_gateway` block as defined below.
     * 
     * &gt; **Note:** Since the Application Gateway is deployed inside a Virtual Network, users (and Service Principals) that are operating the Application Gateway must have the `Microsoft.Network/virtualNetworks/subnets/join/action` permission on the Virtual Network or Subnet. For more details, please visit [Virtual Network Permission](https://learn.microsoft.com/en-us/azure/application-gateway/configuration-infrastructure#virtual-network-permission).
     * 
     */
    @Export(name="ingressApplicationGateway", refs={KubernetesClusterIngressApplicationGateway.class}, tree="[0]")
    private Output</* @Nullable */ KubernetesClusterIngressApplicationGateway> ingressApplicationGateway;

    /**
     * @return A `ingress_application_gateway` block as defined below.
     * 
     * &gt; **Note:** Since the Application Gateway is deployed inside a Virtual Network, users (and Service Principals) that are operating the Application Gateway must have the `Microsoft.Network/virtualNetworks/subnets/join/action` permission on the Virtual Network or Subnet. For more details, please visit [Virtual Network Permission](https://learn.microsoft.com/en-us/azure/application-gateway/configuration-infrastructure#virtual-network-permission).
     * 
     */
    public Output<Optional<KubernetesClusterIngressApplicationGateway>> ingressApplicationGateway() {
        return Codegen.optional(this.ingressApplicationGateway);
    }
    /**
     * A `key_management_service` block as defined below. For more details, please visit [Key Management Service (KMS) etcd encryption to an AKS cluster](https://learn.microsoft.com/en-us/azure/aks/use-kms-etcd-encryption).
     * 
     */
    @Export(name="keyManagementService", refs={KubernetesClusterKeyManagementService.class}, tree="[0]")
    private Output</* @Nullable */ KubernetesClusterKeyManagementService> keyManagementService;

    /**
     * @return A `key_management_service` block as defined below. For more details, please visit [Key Management Service (KMS) etcd encryption to an AKS cluster](https://learn.microsoft.com/en-us/azure/aks/use-kms-etcd-encryption).
     * 
     */
    public Output<Optional<KubernetesClusterKeyManagementService>> keyManagementService() {
        return Codegen.optional(this.keyManagementService);
    }
    /**
     * A `key_vault_secrets_provider` block as defined below. For more details, please visit [Azure Keyvault Secrets Provider for AKS](https://docs.microsoft.com/azure/aks/csi-secrets-store-driver).
     * 
     */
    @Export(name="keyVaultSecretsProvider", refs={KubernetesClusterKeyVaultSecretsProvider.class}, tree="[0]")
    private Output</* @Nullable */ KubernetesClusterKeyVaultSecretsProvider> keyVaultSecretsProvider;

    /**
     * @return A `key_vault_secrets_provider` block as defined below. For more details, please visit [Azure Keyvault Secrets Provider for AKS](https://docs.microsoft.com/azure/aks/csi-secrets-store-driver).
     * 
     */
    public Output<Optional<KubernetesClusterKeyVaultSecretsProvider>> keyVaultSecretsProvider() {
        return Codegen.optional(this.keyVaultSecretsProvider);
    }
    /**
     * Raw Kubernetes config for the admin account to be used by [kubectl](https://kubernetes.io/docs/reference/kubectl/overview/) and other compatible tools. This is only available when Role Based Access Control with Azure Active Directory is enabled and local accounts enabled.
     * 
     */
    @Export(name="kubeAdminConfigRaw", refs={String.class}, tree="[0]")
    private Output<String> kubeAdminConfigRaw;

    /**
     * @return Raw Kubernetes config for the admin account to be used by [kubectl](https://kubernetes.io/docs/reference/kubectl/overview/) and other compatible tools. This is only available when Role Based Access Control with Azure Active Directory is enabled and local accounts enabled.
     * 
     */
    public Output<String> kubeAdminConfigRaw() {
        return this.kubeAdminConfigRaw;
    }
    /**
     * A `kube_admin_config` block as defined below. This is only available when Role Based Access Control with Azure Active Directory is enabled and local accounts enabled.
     * 
     */
    @Export(name="kubeAdminConfigs", refs={List.class,KubernetesClusterKubeAdminConfig.class}, tree="[0,1]")
    private Output<List<KubernetesClusterKubeAdminConfig>> kubeAdminConfigs;

    /**
     * @return A `kube_admin_config` block as defined below. This is only available when Role Based Access Control with Azure Active Directory is enabled and local accounts enabled.
     * 
     */
    public Output<List<KubernetesClusterKubeAdminConfig>> kubeAdminConfigs() {
        return this.kubeAdminConfigs;
    }
    /**
     * Raw Kubernetes config to be used by [kubectl](https://kubernetes.io/docs/reference/kubectl/overview/) and other compatible tools.
     * 
     */
    @Export(name="kubeConfigRaw", refs={String.class}, tree="[0]")
    private Output<String> kubeConfigRaw;

    /**
     * @return Raw Kubernetes config to be used by [kubectl](https://kubernetes.io/docs/reference/kubectl/overview/) and other compatible tools.
     * 
     */
    public Output<String> kubeConfigRaw() {
        return this.kubeConfigRaw;
    }
    /**
     * A `kube_config` block as defined below.
     * 
     */
    @Export(name="kubeConfigs", refs={List.class,KubernetesClusterKubeConfig.class}, tree="[0,1]")
    private Output<List<KubernetesClusterKubeConfig>> kubeConfigs;

    /**
     * @return A `kube_config` block as defined below.
     * 
     */
    public Output<List<KubernetesClusterKubeConfig>> kubeConfigs() {
        return this.kubeConfigs;
    }
    /**
     * A `kubelet_identity` block as defined below.
     * 
     */
    @Export(name="kubeletIdentity", refs={KubernetesClusterKubeletIdentity.class}, tree="[0]")
    private Output<KubernetesClusterKubeletIdentity> kubeletIdentity;

    /**
     * @return A `kubelet_identity` block as defined below.
     * 
     */
    public Output<KubernetesClusterKubeletIdentity> kubeletIdentity() {
        return this.kubeletIdentity;
    }
    /**
     * Version of Kubernetes specified when creating the AKS managed cluster. If not specified, the latest recommended version will be used at provisioning time (but won&#39;t auto-upgrade). AKS does not require an exact patch version to be specified, minor version aliases such as `1.22` are also supported. - The minor version&#39;s latest GA patch is automatically chosen in that case. More details can be found in [the documentation](https://docs.microsoft.com/en-us/azure/aks/supported-kubernetes-versions?tabs=azure-cli#alias-minor-version).
     * 
     * &gt; **Note:** Upgrading your cluster may take up to 10 minutes per node.
     * 
     */
    @Export(name="kubernetesVersion", refs={String.class}, tree="[0]")
    private Output<String> kubernetesVersion;

    /**
     * @return Version of Kubernetes specified when creating the AKS managed cluster. If not specified, the latest recommended version will be used at provisioning time (but won&#39;t auto-upgrade). AKS does not require an exact patch version to be specified, minor version aliases such as `1.22` are also supported. - The minor version&#39;s latest GA patch is automatically chosen in that case. More details can be found in [the documentation](https://docs.microsoft.com/en-us/azure/aks/supported-kubernetes-versions?tabs=azure-cli#alias-minor-version).
     * 
     * &gt; **Note:** Upgrading your cluster may take up to 10 minutes per node.
     * 
     */
    public Output<String> kubernetesVersion() {
        return this.kubernetesVersion;
    }
    /**
     * A `linux_profile` block as defined below.
     * 
     */
    @Export(name="linuxProfile", refs={KubernetesClusterLinuxProfile.class}, tree="[0]")
    private Output</* @Nullable */ KubernetesClusterLinuxProfile> linuxProfile;

    /**
     * @return A `linux_profile` block as defined below.
     * 
     */
    public Output<Optional<KubernetesClusterLinuxProfile>> linuxProfile() {
        return Codegen.optional(this.linuxProfile);
    }
    /**
     * If `true` local accounts will be disabled. See [the documentation](https://docs.microsoft.com/azure/aks/managed-aad#disable-local-accounts) for more information.
     * 
     * &gt; **Note:** If `local_account_disabled` is set to `true`, it is required to enable Kubernetes RBAC and AKS-managed Azure AD integration. See [the documentation](https://docs.microsoft.com/azure/aks/managed-aad#azure-ad-authentication-overview) for more information.
     * 
     */
    @Export(name="localAccountDisabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> localAccountDisabled;

    /**
     * @return If `true` local accounts will be disabled. See [the documentation](https://docs.microsoft.com/azure/aks/managed-aad#disable-local-accounts) for more information.
     * 
     * &gt; **Note:** If `local_account_disabled` is set to `true`, it is required to enable Kubernetes RBAC and AKS-managed Azure AD integration. See [the documentation](https://docs.microsoft.com/azure/aks/managed-aad#azure-ad-authentication-overview) for more information.
     * 
     */
    public Output<Optional<Boolean>> localAccountDisabled() {
        return Codegen.optional(this.localAccountDisabled);
    }
    /**
     * The location where the Managed Kubernetes Cluster should be created. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="location", refs={String.class}, tree="[0]")
    private Output<String> location;

    /**
     * @return The location where the Managed Kubernetes Cluster should be created. Changing this forces a new resource to be created.
     * 
     */
    public Output<String> location() {
        return this.location;
    }
    /**
     * A `maintenance_window` block as defined below.
     * 
     */
    @Export(name="maintenanceWindow", refs={KubernetesClusterMaintenanceWindow.class}, tree="[0]")
    private Output</* @Nullable */ KubernetesClusterMaintenanceWindow> maintenanceWindow;

    /**
     * @return A `maintenance_window` block as defined below.
     * 
     */
    public Output<Optional<KubernetesClusterMaintenanceWindow>> maintenanceWindow() {
        return Codegen.optional(this.maintenanceWindow);
    }
    /**
     * A `maintenance_window_auto_upgrade` block as defined below.
     * 
     */
    @Export(name="maintenanceWindowAutoUpgrade", refs={KubernetesClusterMaintenanceWindowAutoUpgrade.class}, tree="[0]")
    private Output</* @Nullable */ KubernetesClusterMaintenanceWindowAutoUpgrade> maintenanceWindowAutoUpgrade;

    /**
     * @return A `maintenance_window_auto_upgrade` block as defined below.
     * 
     */
    public Output<Optional<KubernetesClusterMaintenanceWindowAutoUpgrade>> maintenanceWindowAutoUpgrade() {
        return Codegen.optional(this.maintenanceWindowAutoUpgrade);
    }
    /**
     * A `maintenance_window_node_os` block as defined below.
     * 
     */
    @Export(name="maintenanceWindowNodeOs", refs={KubernetesClusterMaintenanceWindowNodeOs.class}, tree="[0]")
    private Output</* @Nullable */ KubernetesClusterMaintenanceWindowNodeOs> maintenanceWindowNodeOs;

    /**
     * @return A `maintenance_window_node_os` block as defined below.
     * 
     */
    public Output<Optional<KubernetesClusterMaintenanceWindowNodeOs>> maintenanceWindowNodeOs() {
        return Codegen.optional(this.maintenanceWindowNodeOs);
    }
    /**
     * A `microsoft_defender` block as defined below.
     * 
     */
    @Export(name="microsoftDefender", refs={KubernetesClusterMicrosoftDefender.class}, tree="[0]")
    private Output</* @Nullable */ KubernetesClusterMicrosoftDefender> microsoftDefender;

    /**
     * @return A `microsoft_defender` block as defined below.
     * 
     */
    public Output<Optional<KubernetesClusterMicrosoftDefender>> microsoftDefender() {
        return Codegen.optional(this.microsoftDefender);
    }
    /**
     * Specifies a Prometheus add-on profile for the Kubernetes Cluster. A `monitor_metrics` block as defined below.
     * 
     * &gt; **Note:** If deploying Managed Prometheus, the `monitor_metrics` properties are required to configure the cluster for metrics collection. If no value is needed, set properties to `null`.
     * 
     */
    @Export(name="monitorMetrics", refs={KubernetesClusterMonitorMetrics.class}, tree="[0]")
    private Output</* @Nullable */ KubernetesClusterMonitorMetrics> monitorMetrics;

    /**
     * @return Specifies a Prometheus add-on profile for the Kubernetes Cluster. A `monitor_metrics` block as defined below.
     * 
     * &gt; **Note:** If deploying Managed Prometheus, the `monitor_metrics` properties are required to configure the cluster for metrics collection. If no value is needed, set properties to `null`.
     * 
     */
    public Output<Optional<KubernetesClusterMonitorMetrics>> monitorMetrics() {
        return Codegen.optional(this.monitorMetrics);
    }
    /**
     * The name of the Managed Kubernetes Cluster to create. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    /**
     * @return The name of the Managed Kubernetes Cluster to create. Changing this forces a new resource to be created.
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * A `network_profile` block as defined below. Changing this forces a new resource to be created.
     * 
     * &gt; **Note:** If `network_profile` is not defined, `kubenet` profile will be used by default.
     * 
     */
    @Export(name="networkProfile", refs={KubernetesClusterNetworkProfile.class}, tree="[0]")
    private Output<KubernetesClusterNetworkProfile> networkProfile;

    /**
     * @return A `network_profile` block as defined below. Changing this forces a new resource to be created.
     * 
     * &gt; **Note:** If `network_profile` is not defined, `kubenet` profile will be used by default.
     * 
     */
    public Output<KubernetesClusterNetworkProfile> networkProfile() {
        return this.networkProfile;
    }
    /**
     * The upgrade channel for this Kubernetes Cluster Nodes&#39; OS Image. Possible values are `Unmanaged`, `SecurityPatch`, `NodeImage` and `None`. Defaults to `NodeImage`.
     * 
     * &gt; **Note:** `node_os_upgrade_channel` must be set to `NodeImage` if `automatic_upgrade_channel` has been set to `node-image`
     * 
     */
    @Export(name="nodeOsUpgradeChannel", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> nodeOsUpgradeChannel;

    /**
     * @return The upgrade channel for this Kubernetes Cluster Nodes&#39; OS Image. Possible values are `Unmanaged`, `SecurityPatch`, `NodeImage` and `None`. Defaults to `NodeImage`.
     * 
     * &gt; **Note:** `node_os_upgrade_channel` must be set to `NodeImage` if `automatic_upgrade_channel` has been set to `node-image`
     * 
     */
    public Output<Optional<String>> nodeOsUpgradeChannel() {
        return Codegen.optional(this.nodeOsUpgradeChannel);
    }
    /**
     * The name of the Resource Group where the Kubernetes Nodes should exist. Changing this forces a new resource to be created.
     * 
     * &gt; **Note:** Azure requires that a new, non-existent Resource Group is used, as otherwise, the provisioning of the Kubernetes Service will fail.
     * 
     */
    @Export(name="nodeResourceGroup", refs={String.class}, tree="[0]")
    private Output<String> nodeResourceGroup;

    /**
     * @return The name of the Resource Group where the Kubernetes Nodes should exist. Changing this forces a new resource to be created.
     * 
     * &gt; **Note:** Azure requires that a new, non-existent Resource Group is used, as otherwise, the provisioning of the Kubernetes Service will fail.
     * 
     */
    public Output<String> nodeResourceGroup() {
        return this.nodeResourceGroup;
    }
    /**
     * The ID of the Resource Group containing the resources for this Managed Kubernetes Cluster.
     * 
     */
    @Export(name="nodeResourceGroupId", refs={String.class}, tree="[0]")
    private Output<String> nodeResourceGroupId;

    /**
     * @return The ID of the Resource Group containing the resources for this Managed Kubernetes Cluster.
     * 
     */
    public Output<String> nodeResourceGroupId() {
        return this.nodeResourceGroupId;
    }
    /**
     * Enable or Disable the [OIDC issuer URL](https://learn.microsoft.com/en-gb/azure/aks/use-oidc-issuer)
     * 
     */
    @Export(name="oidcIssuerEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> oidcIssuerEnabled;

    /**
     * @return Enable or Disable the [OIDC issuer URL](https://learn.microsoft.com/en-gb/azure/aks/use-oidc-issuer)
     * 
     */
    public Output<Optional<Boolean>> oidcIssuerEnabled() {
        return Codegen.optional(this.oidcIssuerEnabled);
    }
    /**
     * The OIDC issuer URL that is associated with the cluster.
     * 
     */
    @Export(name="oidcIssuerUrl", refs={String.class}, tree="[0]")
    private Output<String> oidcIssuerUrl;

    /**
     * @return The OIDC issuer URL that is associated with the cluster.
     * 
     */
    public Output<String> oidcIssuerUrl() {
        return this.oidcIssuerUrl;
    }
    /**
     * A `oms_agent` block as defined below.
     * 
     */
    @Export(name="omsAgent", refs={KubernetesClusterOmsAgent.class}, tree="[0]")
    private Output</* @Nullable */ KubernetesClusterOmsAgent> omsAgent;

    /**
     * @return A `oms_agent` block as defined below.
     * 
     */
    public Output<Optional<KubernetesClusterOmsAgent>> omsAgent() {
        return Codegen.optional(this.omsAgent);
    }
    /**
     * Is Open Service Mesh enabled? For more details, please visit [Open Service Mesh for AKS](https://docs.microsoft.com/azure/aks/open-service-mesh-about).
     * 
     */
    @Export(name="openServiceMeshEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> openServiceMeshEnabled;

    /**
     * @return Is Open Service Mesh enabled? For more details, please visit [Open Service Mesh for AKS](https://docs.microsoft.com/azure/aks/open-service-mesh-about).
     * 
     */
    public Output<Optional<Boolean>> openServiceMeshEnabled() {
        return Codegen.optional(this.openServiceMeshEnabled);
    }
    /**
     * The FQDN for the Azure Portal resources when private link has been enabled, which is only resolvable inside the Virtual Network used by the Kubernetes Cluster.
     * 
     */
    @Export(name="portalFqdn", refs={String.class}, tree="[0]")
    private Output<String> portalFqdn;

    /**
     * @return The FQDN for the Azure Portal resources when private link has been enabled, which is only resolvable inside the Virtual Network used by the Kubernetes Cluster.
     * 
     */
    public Output<String> portalFqdn() {
        return this.portalFqdn;
    }
    /**
     * Should this Kubernetes Cluster have its API server only exposed on internal IP addresses? This provides a Private IP Address for the Kubernetes API on the Virtual Network where the Kubernetes Cluster is located. Defaults to `false`. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="privateClusterEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> privateClusterEnabled;

    /**
     * @return Should this Kubernetes Cluster have its API server only exposed on internal IP addresses? This provides a Private IP Address for the Kubernetes API on the Virtual Network where the Kubernetes Cluster is located. Defaults to `false`. Changing this forces a new resource to be created.
     * 
     */
    public Output<Optional<Boolean>> privateClusterEnabled() {
        return Codegen.optional(this.privateClusterEnabled);
    }
    /**
     * Specifies whether a Public FQDN for this Private Cluster should be added. Defaults to `false`.
     * 
     * &gt; **Note:** If you use BYO DNS Zone, the AKS cluster should either use a User Assigned Identity or a service principal (which is deprecated) with the `Private DNS Zone Contributor` role and access to this Private DNS Zone. If `UserAssigned` identity is used - to prevent improper resource order destruction - the cluster should depend on the role assignment, like in this example:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.azure.core.ResourceGroup;
     * import com.pulumi.azure.core.ResourceGroupArgs;
     * import com.pulumi.azure.privatedns.Zone;
     * import com.pulumi.azure.privatedns.ZoneArgs;
     * import com.pulumi.azure.authorization.UserAssignedIdentity;
     * import com.pulumi.azure.authorization.UserAssignedIdentityArgs;
     * import com.pulumi.azure.authorization.Assignment;
     * import com.pulumi.azure.authorization.AssignmentArgs;
     * import com.pulumi.azure.containerservice.KubernetesCluster;
     * import com.pulumi.azure.containerservice.KubernetesClusterArgs;
     * import com.pulumi.resources.CustomResourceOptions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         var example = new ResourceGroup("example", ResourceGroupArgs.builder()
     *             .name("example")
     *             .location("West Europe")
     *             .build());
     * 
     *         var exampleZone = new Zone("exampleZone", ZoneArgs.builder()
     *             .name("privatelink.eastus2.azmk8s.io")
     *             .resourceGroupName(example.name())
     *             .build());
     * 
     *         var exampleUserAssignedIdentity = new UserAssignedIdentity("exampleUserAssignedIdentity", UserAssignedIdentityArgs.builder()
     *             .name("aks-example-identity")
     *             .resourceGroupName(example.name())
     *             .location(example.location())
     *             .build());
     * 
     *         var exampleAssignment = new Assignment("exampleAssignment", AssignmentArgs.builder()
     *             .scope(exampleZone.id())
     *             .roleDefinitionName("Private DNS Zone Contributor")
     *             .principalId(exampleUserAssignedIdentity.principalId())
     *             .build());
     * 
     *         var exampleKubernetesCluster = new KubernetesCluster("exampleKubernetesCluster", KubernetesClusterArgs.builder()
     *             .name("aksexamplewithprivatednszone1")
     *             .location(example.location())
     *             .resourceGroupName(example.name())
     *             .dnsPrefix("aksexamplednsprefix1")
     *             .privateClusterEnabled(true)
     *             .privateDnsZoneId(exampleZone.id())
     *             .build(), CustomResourceOptions.builder()
     *                 .dependsOn(exampleAssignment)
     *                 .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    @Export(name="privateClusterPublicFqdnEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> privateClusterPublicFqdnEnabled;

    /**
     * @return Specifies whether a Public FQDN for this Private Cluster should be added. Defaults to `false`.
     * 
     * &gt; **Note:** If you use BYO DNS Zone, the AKS cluster should either use a User Assigned Identity or a service principal (which is deprecated) with the `Private DNS Zone Contributor` role and access to this Private DNS Zone. If `UserAssigned` identity is used - to prevent improper resource order destruction - the cluster should depend on the role assignment, like in this example:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.azure.core.ResourceGroup;
     * import com.pulumi.azure.core.ResourceGroupArgs;
     * import com.pulumi.azure.privatedns.Zone;
     * import com.pulumi.azure.privatedns.ZoneArgs;
     * import com.pulumi.azure.authorization.UserAssignedIdentity;
     * import com.pulumi.azure.authorization.UserAssignedIdentityArgs;
     * import com.pulumi.azure.authorization.Assignment;
     * import com.pulumi.azure.authorization.AssignmentArgs;
     * import com.pulumi.azure.containerservice.KubernetesCluster;
     * import com.pulumi.azure.containerservice.KubernetesClusterArgs;
     * import com.pulumi.resources.CustomResourceOptions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         var example = new ResourceGroup("example", ResourceGroupArgs.builder()
     *             .name("example")
     *             .location("West Europe")
     *             .build());
     * 
     *         var exampleZone = new Zone("exampleZone", ZoneArgs.builder()
     *             .name("privatelink.eastus2.azmk8s.io")
     *             .resourceGroupName(example.name())
     *             .build());
     * 
     *         var exampleUserAssignedIdentity = new UserAssignedIdentity("exampleUserAssignedIdentity", UserAssignedIdentityArgs.builder()
     *             .name("aks-example-identity")
     *             .resourceGroupName(example.name())
     *             .location(example.location())
     *             .build());
     * 
     *         var exampleAssignment = new Assignment("exampleAssignment", AssignmentArgs.builder()
     *             .scope(exampleZone.id())
     *             .roleDefinitionName("Private DNS Zone Contributor")
     *             .principalId(exampleUserAssignedIdentity.principalId())
     *             .build());
     * 
     *         var exampleKubernetesCluster = new KubernetesCluster("exampleKubernetesCluster", KubernetesClusterArgs.builder()
     *             .name("aksexamplewithprivatednszone1")
     *             .location(example.location())
     *             .resourceGroupName(example.name())
     *             .dnsPrefix("aksexamplednsprefix1")
     *             .privateClusterEnabled(true)
     *             .privateDnsZoneId(exampleZone.id())
     *             .build(), CustomResourceOptions.builder()
     *                 .dependsOn(exampleAssignment)
     *                 .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public Output<Optional<Boolean>> privateClusterPublicFqdnEnabled() {
        return Codegen.optional(this.privateClusterPublicFqdnEnabled);
    }
    /**
     * Either the ID of Private DNS Zone which should be delegated to this Cluster, `System` to have AKS manage this or `None`. In case of `None` you will need to bring your own DNS server and set up resolving, otherwise, the cluster will have issues after provisioning. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="privateDnsZoneId", refs={String.class}, tree="[0]")
    private Output<String> privateDnsZoneId;

    /**
     * @return Either the ID of Private DNS Zone which should be delegated to this Cluster, `System` to have AKS manage this or `None`. In case of `None` you will need to bring your own DNS server and set up resolving, otherwise, the cluster will have issues after provisioning. Changing this forces a new resource to be created.
     * 
     */
    public Output<String> privateDnsZoneId() {
        return this.privateDnsZoneId;
    }
    /**
     * The FQDN for the Kubernetes Cluster when private link has been enabled, which is only resolvable inside the Virtual Network used by the Kubernetes Cluster.
     * 
     */
    @Export(name="privateFqdn", refs={String.class}, tree="[0]")
    private Output<String> privateFqdn;

    /**
     * @return The FQDN for the Kubernetes Cluster when private link has been enabled, which is only resolvable inside the Virtual Network used by the Kubernetes Cluster.
     * 
     */
    public Output<String> privateFqdn() {
        return this.privateFqdn;
    }
    /**
     * Specifies the Resource Group where the Managed Kubernetes Cluster should exist. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="resourceGroupName", refs={String.class}, tree="[0]")
    private Output<String> resourceGroupName;

    /**
     * @return Specifies the Resource Group where the Managed Kubernetes Cluster should exist. Changing this forces a new resource to be created.
     * 
     */
    public Output<String> resourceGroupName() {
        return this.resourceGroupName;
    }
    /**
     * Whether Role Based Access Control for the Kubernetes Cluster should be enabled. Defaults to `true`. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="roleBasedAccessControlEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> roleBasedAccessControlEnabled;

    /**
     * @return Whether Role Based Access Control for the Kubernetes Cluster should be enabled. Defaults to `true`. Changing this forces a new resource to be created.
     * 
     */
    public Output<Optional<Boolean>> roleBasedAccessControlEnabled() {
        return Codegen.optional(this.roleBasedAccessControlEnabled);
    }
    /**
     * Whether to enable run command for the cluster or not. Defaults to `true`.
     * 
     */
    @Export(name="runCommandEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> runCommandEnabled;

    /**
     * @return Whether to enable run command for the cluster or not. Defaults to `true`.
     * 
     */
    public Output<Optional<Boolean>> runCommandEnabled() {
        return Codegen.optional(this.runCommandEnabled);
    }
    /**
     * A `service_mesh_profile` block as defined below.
     * 
     */
    @Export(name="serviceMeshProfile", refs={KubernetesClusterServiceMeshProfile.class}, tree="[0]")
    private Output</* @Nullable */ KubernetesClusterServiceMeshProfile> serviceMeshProfile;

    /**
     * @return A `service_mesh_profile` block as defined below.
     * 
     */
    public Output<Optional<KubernetesClusterServiceMeshProfile>> serviceMeshProfile() {
        return Codegen.optional(this.serviceMeshProfile);
    }
    /**
     * A `service_principal` block as documented below. One of either `identity` or `service_principal` must be specified.
     * 
     * !&gt; **Note:** A migration scenario from `service_principal` to `identity` is supported. When upgrading `service_principal` to `identity`, your cluster&#39;s control plane and addon pods will switch to use managed identity, but the kubelets will keep using your configured `service_principal` until you upgrade your Node Pool.
     * 
     */
    @Export(name="servicePrincipal", refs={KubernetesClusterServicePrincipal.class}, tree="[0]")
    private Output</* @Nullable */ KubernetesClusterServicePrincipal> servicePrincipal;

    /**
     * @return A `service_principal` block as documented below. One of either `identity` or `service_principal` must be specified.
     * 
     * !&gt; **Note:** A migration scenario from `service_principal` to `identity` is supported. When upgrading `service_principal` to `identity`, your cluster&#39;s control plane and addon pods will switch to use managed identity, but the kubelets will keep using your configured `service_principal` until you upgrade your Node Pool.
     * 
     */
    public Output<Optional<KubernetesClusterServicePrincipal>> servicePrincipal() {
        return Codegen.optional(this.servicePrincipal);
    }
    /**
     * The SKU Tier that should be used for this Kubernetes Cluster. Possible values are `Free`, `Standard` (which includes the Uptime SLA) and `Premium`. Defaults to `Free`.
     * 
     * &gt; **Note:** Whilst the AKS API previously supported the `Paid` SKU - the AKS API introduced a breaking change in API Version `2023-02-01` (used in v3.51.0 and later) where the value `Paid` must now be set to `Standard`.
     * 
     */
    @Export(name="skuTier", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> skuTier;

    /**
     * @return The SKU Tier that should be used for this Kubernetes Cluster. Possible values are `Free`, `Standard` (which includes the Uptime SLA) and `Premium`. Defaults to `Free`.
     * 
     * &gt; **Note:** Whilst the AKS API previously supported the `Paid` SKU - the AKS API introduced a breaking change in API Version `2023-02-01` (used in v3.51.0 and later) where the value `Paid` must now be set to `Standard`.
     * 
     */
    public Output<Optional<String>> skuTier() {
        return Codegen.optional(this.skuTier);
    }
    /**
     * A `storage_profile` block as defined below.
     * 
     */
    @Export(name="storageProfile", refs={KubernetesClusterStorageProfile.class}, tree="[0]")
    private Output</* @Nullable */ KubernetesClusterStorageProfile> storageProfile;

    /**
     * @return A `storage_profile` block as defined below.
     * 
     */
    public Output<Optional<KubernetesClusterStorageProfile>> storageProfile() {
        return Codegen.optional(this.storageProfile);
    }
    /**
     * Specifies the support plan which should be used for this Kubernetes Cluster. Possible values are `KubernetesOfficial` and `AKSLongTermSupport`. Defaults to `KubernetesOfficial`.
     * 
     */
    @Export(name="supportPlan", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> supportPlan;

    /**
     * @return Specifies the support plan which should be used for this Kubernetes Cluster. Possible values are `KubernetesOfficial` and `AKSLongTermSupport`. Defaults to `KubernetesOfficial`.
     * 
     */
    public Output<Optional<String>> supportPlan() {
        return Codegen.optional(this.supportPlan);
    }
    /**
     * A mapping of tags to assign to the resource.
     * 
     */
    @Export(name="tags", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output</* @Nullable */ Map<String,String>> tags;

    /**
     * @return A mapping of tags to assign to the resource.
     * 
     */
    public Output<Optional<Map<String,String>>> tags() {
        return Codegen.optional(this.tags);
    }
    /**
     * A `upgrade_override` block as defined below.
     * 
     */
    @Export(name="upgradeOverride", refs={KubernetesClusterUpgradeOverride.class}, tree="[0]")
    private Output</* @Nullable */ KubernetesClusterUpgradeOverride> upgradeOverride;

    /**
     * @return A `upgrade_override` block as defined below.
     * 
     */
    public Output<Optional<KubernetesClusterUpgradeOverride>> upgradeOverride() {
        return Codegen.optional(this.upgradeOverride);
    }
    /**
     * A `web_app_routing` block as defined below.
     * 
     */
    @Export(name="webAppRouting", refs={KubernetesClusterWebAppRouting.class}, tree="[0]")
    private Output</* @Nullable */ KubernetesClusterWebAppRouting> webAppRouting;

    /**
     * @return A `web_app_routing` block as defined below.
     * 
     */
    public Output<Optional<KubernetesClusterWebAppRouting>> webAppRouting() {
        return Codegen.optional(this.webAppRouting);
    }
    /**
     * A `windows_profile` block as defined below.
     * 
     */
    @Export(name="windowsProfile", refs={KubernetesClusterWindowsProfile.class}, tree="[0]")
    private Output<KubernetesClusterWindowsProfile> windowsProfile;

    /**
     * @return A `windows_profile` block as defined below.
     * 
     */
    public Output<KubernetesClusterWindowsProfile> windowsProfile() {
        return this.windowsProfile;
    }
    /**
     * A `workload_autoscaler_profile` block defined below.
     * 
     */
    @Export(name="workloadAutoscalerProfile", refs={KubernetesClusterWorkloadAutoscalerProfile.class}, tree="[0]")
    private Output</* @Nullable */ KubernetesClusterWorkloadAutoscalerProfile> workloadAutoscalerProfile;

    /**
     * @return A `workload_autoscaler_profile` block defined below.
     * 
     */
    public Output<Optional<KubernetesClusterWorkloadAutoscalerProfile>> workloadAutoscalerProfile() {
        return Codegen.optional(this.workloadAutoscalerProfile);
    }
    /**
     * Specifies whether Azure AD Workload Identity should be enabled for the Cluster. Defaults to `false`.
     * 
     * &gt; **Note:** To enable Azure AD Workload Identity `oidc_issuer_enabled` must be set to `true`.
     * 
     * &gt; **Note:** Enabling this option will allocate Workload Identity resources to the `kube-system` namespace in Kubernetes. If you wish to customize the deployment of Workload Identity, you can refer to [the documentation on Azure AD Workload Identity.](https://azure.github.io/azure-workload-identity/docs/installation/mutating-admission-webhook.html) The documentation provides guidance on how to install the mutating admission webhook, which allows for the customization of Workload Identity deployment.
     * 
     */
    @Export(name="workloadIdentityEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> workloadIdentityEnabled;

    /**
     * @return Specifies whether Azure AD Workload Identity should be enabled for the Cluster. Defaults to `false`.
     * 
     * &gt; **Note:** To enable Azure AD Workload Identity `oidc_issuer_enabled` must be set to `true`.
     * 
     * &gt; **Note:** Enabling this option will allocate Workload Identity resources to the `kube-system` namespace in Kubernetes. If you wish to customize the deployment of Workload Identity, you can refer to [the documentation on Azure AD Workload Identity.](https://azure.github.io/azure-workload-identity/docs/installation/mutating-admission-webhook.html) The documentation provides guidance on how to install the mutating admission webhook, which allows for the customization of Workload Identity deployment.
     * 
     */
    public Output<Optional<Boolean>> workloadIdentityEnabled() {
        return Codegen.optional(this.workloadIdentityEnabled);
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public KubernetesCluster(java.lang.String name) {
        this(name, KubernetesClusterArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public KubernetesCluster(java.lang.String name, KubernetesClusterArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public KubernetesCluster(java.lang.String name, KubernetesClusterArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("azure:containerservice/kubernetesCluster:KubernetesCluster", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private KubernetesCluster(java.lang.String name, Output<java.lang.String> id, @Nullable KubernetesClusterState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("azure:containerservice/kubernetesCluster:KubernetesCluster", name, state, makeResourceOptions(options, id), false);
    }

    private static KubernetesClusterArgs makeArgs(KubernetesClusterArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? KubernetesClusterArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .additionalSecretOutputs(List.of(
                "kubeAdminConfigRaw",
                "kubeAdminConfigs",
                "kubeConfigRaw",
                "kubeConfigs"
            ))
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static KubernetesCluster get(java.lang.String name, Output<java.lang.String> id, @Nullable KubernetesClusterState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new KubernetesCluster(name, id, state, options);
    }
}
