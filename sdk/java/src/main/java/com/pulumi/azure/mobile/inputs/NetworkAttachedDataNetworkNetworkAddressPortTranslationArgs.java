// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.azure.mobile.inputs;

import com.pulumi.azure.mobile.inputs.NetworkAttachedDataNetworkNetworkAddressPortTranslationPortRangeArgs;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.Integer;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class NetworkAttachedDataNetworkNetworkAddressPortTranslationArgs extends com.pulumi.resources.ResourceArgs {

    public static final NetworkAttachedDataNetworkNetworkAddressPortTranslationArgs Empty = new NetworkAttachedDataNetworkNetworkAddressPortTranslationArgs();

    /**
     * Pinhole timeout for ICMP pinholes in seconds. Must between `1` to `180`, Default to `180`.
     * 
     */
    @Import(name="icmpPinholeTimeoutInSeconds")
    private @Nullable Output<Integer> icmpPinholeTimeoutInSeconds;

    /**
     * @return Pinhole timeout for ICMP pinholes in seconds. Must between `1` to `180`, Default to `180`.
     * 
     */
    public Optional<Output<Integer>> icmpPinholeTimeoutInSeconds() {
        return Optional.ofNullable(this.icmpPinholeTimeoutInSeconds);
    }

    /**
     * Maximum number of UDP and TCP pinholes that can be open simultaneously on the core interface. For 5G networks, this is the N6 interface. For 4G networks, this is the SGi interface. Must be between 1 and 65536.
     * 
     */
    @Import(name="pinholeMaximumNumber")
    private @Nullable Output<Integer> pinholeMaximumNumber;

    /**
     * @return Maximum number of UDP and TCP pinholes that can be open simultaneously on the core interface. For 5G networks, this is the N6 interface. For 4G networks, this is the SGi interface. Must be between 1 and 65536.
     * 
     */
    public Optional<Output<Integer>> pinholeMaximumNumber() {
        return Optional.ofNullable(this.pinholeMaximumNumber);
    }

    /**
     * A `port_range` block as defined below.
     * 
     */
    @Import(name="portRange")
    private @Nullable Output<NetworkAttachedDataNetworkNetworkAddressPortTranslationPortRangeArgs> portRange;

    /**
     * @return A `port_range` block as defined below.
     * 
     */
    public Optional<Output<NetworkAttachedDataNetworkNetworkAddressPortTranslationPortRangeArgs>> portRange() {
        return Optional.ofNullable(this.portRange);
    }

    /**
     * Pinhole timeout for TCP pinholes in seconds. Must between `1` to `180`, Default to `180`.
     * 
     */
    @Import(name="tcpPinholeTimeoutInSeconds")
    private @Nullable Output<Integer> tcpPinholeTimeoutInSeconds;

    /**
     * @return Pinhole timeout for TCP pinholes in seconds. Must between `1` to `180`, Default to `180`.
     * 
     */
    public Optional<Output<Integer>> tcpPinholeTimeoutInSeconds() {
        return Optional.ofNullable(this.tcpPinholeTimeoutInSeconds);
    }

    /**
     * Minimum time in seconds that will pass before a TCP port that was used by a closed pinhole can be reused. Defaults to `120`.
     * 
     */
    @Import(name="tcpPortReuseMinimumHoldTimeInSeconds")
    private @Nullable Output<Integer> tcpPortReuseMinimumHoldTimeInSeconds;

    /**
     * @return Minimum time in seconds that will pass before a TCP port that was used by a closed pinhole can be reused. Defaults to `120`.
     * 
     */
    public Optional<Output<Integer>> tcpPortReuseMinimumHoldTimeInSeconds() {
        return Optional.ofNullable(this.tcpPortReuseMinimumHoldTimeInSeconds);
    }

    /**
     * Pinhole timeout for UDP pinholes in seconds. Must between `1` to `180`, Default to `180`.
     * 
     */
    @Import(name="udpPinholeTimeoutInSeconds")
    private @Nullable Output<Integer> udpPinholeTimeoutInSeconds;

    /**
     * @return Pinhole timeout for UDP pinholes in seconds. Must between `1` to `180`, Default to `180`.
     * 
     */
    public Optional<Output<Integer>> udpPinholeTimeoutInSeconds() {
        return Optional.ofNullable(this.udpPinholeTimeoutInSeconds);
    }

    /**
     * Minimum time in seconds that will pass before a UDP port that was used by a closed pinhole can be reused. Defaults to `60`.
     * 
     */
    @Import(name="udpPortReuseMinimumHoldTimeInSeconds")
    private @Nullable Output<Integer> udpPortReuseMinimumHoldTimeInSeconds;

    /**
     * @return Minimum time in seconds that will pass before a UDP port that was used by a closed pinhole can be reused. Defaults to `60`.
     * 
     */
    public Optional<Output<Integer>> udpPortReuseMinimumHoldTimeInSeconds() {
        return Optional.ofNullable(this.udpPortReuseMinimumHoldTimeInSeconds);
    }

    private NetworkAttachedDataNetworkNetworkAddressPortTranslationArgs() {}

    private NetworkAttachedDataNetworkNetworkAddressPortTranslationArgs(NetworkAttachedDataNetworkNetworkAddressPortTranslationArgs $) {
        this.icmpPinholeTimeoutInSeconds = $.icmpPinholeTimeoutInSeconds;
        this.pinholeMaximumNumber = $.pinholeMaximumNumber;
        this.portRange = $.portRange;
        this.tcpPinholeTimeoutInSeconds = $.tcpPinholeTimeoutInSeconds;
        this.tcpPortReuseMinimumHoldTimeInSeconds = $.tcpPortReuseMinimumHoldTimeInSeconds;
        this.udpPinholeTimeoutInSeconds = $.udpPinholeTimeoutInSeconds;
        this.udpPortReuseMinimumHoldTimeInSeconds = $.udpPortReuseMinimumHoldTimeInSeconds;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(NetworkAttachedDataNetworkNetworkAddressPortTranslationArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private NetworkAttachedDataNetworkNetworkAddressPortTranslationArgs $;

        public Builder() {
            $ = new NetworkAttachedDataNetworkNetworkAddressPortTranslationArgs();
        }

        public Builder(NetworkAttachedDataNetworkNetworkAddressPortTranslationArgs defaults) {
            $ = new NetworkAttachedDataNetworkNetworkAddressPortTranslationArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param icmpPinholeTimeoutInSeconds Pinhole timeout for ICMP pinholes in seconds. Must between `1` to `180`, Default to `180`.
         * 
         * @return builder
         * 
         */
        public Builder icmpPinholeTimeoutInSeconds(@Nullable Output<Integer> icmpPinholeTimeoutInSeconds) {
            $.icmpPinholeTimeoutInSeconds = icmpPinholeTimeoutInSeconds;
            return this;
        }

        /**
         * @param icmpPinholeTimeoutInSeconds Pinhole timeout for ICMP pinholes in seconds. Must between `1` to `180`, Default to `180`.
         * 
         * @return builder
         * 
         */
        public Builder icmpPinholeTimeoutInSeconds(Integer icmpPinholeTimeoutInSeconds) {
            return icmpPinholeTimeoutInSeconds(Output.of(icmpPinholeTimeoutInSeconds));
        }

        /**
         * @param pinholeMaximumNumber Maximum number of UDP and TCP pinholes that can be open simultaneously on the core interface. For 5G networks, this is the N6 interface. For 4G networks, this is the SGi interface. Must be between 1 and 65536.
         * 
         * @return builder
         * 
         */
        public Builder pinholeMaximumNumber(@Nullable Output<Integer> pinholeMaximumNumber) {
            $.pinholeMaximumNumber = pinholeMaximumNumber;
            return this;
        }

        /**
         * @param pinholeMaximumNumber Maximum number of UDP and TCP pinholes that can be open simultaneously on the core interface. For 5G networks, this is the N6 interface. For 4G networks, this is the SGi interface. Must be between 1 and 65536.
         * 
         * @return builder
         * 
         */
        public Builder pinholeMaximumNumber(Integer pinholeMaximumNumber) {
            return pinholeMaximumNumber(Output.of(pinholeMaximumNumber));
        }

        /**
         * @param portRange A `port_range` block as defined below.
         * 
         * @return builder
         * 
         */
        public Builder portRange(@Nullable Output<NetworkAttachedDataNetworkNetworkAddressPortTranslationPortRangeArgs> portRange) {
            $.portRange = portRange;
            return this;
        }

        /**
         * @param portRange A `port_range` block as defined below.
         * 
         * @return builder
         * 
         */
        public Builder portRange(NetworkAttachedDataNetworkNetworkAddressPortTranslationPortRangeArgs portRange) {
            return portRange(Output.of(portRange));
        }

        /**
         * @param tcpPinholeTimeoutInSeconds Pinhole timeout for TCP pinholes in seconds. Must between `1` to `180`, Default to `180`.
         * 
         * @return builder
         * 
         */
        public Builder tcpPinholeTimeoutInSeconds(@Nullable Output<Integer> tcpPinholeTimeoutInSeconds) {
            $.tcpPinholeTimeoutInSeconds = tcpPinholeTimeoutInSeconds;
            return this;
        }

        /**
         * @param tcpPinholeTimeoutInSeconds Pinhole timeout for TCP pinholes in seconds. Must between `1` to `180`, Default to `180`.
         * 
         * @return builder
         * 
         */
        public Builder tcpPinholeTimeoutInSeconds(Integer tcpPinholeTimeoutInSeconds) {
            return tcpPinholeTimeoutInSeconds(Output.of(tcpPinholeTimeoutInSeconds));
        }

        /**
         * @param tcpPortReuseMinimumHoldTimeInSeconds Minimum time in seconds that will pass before a TCP port that was used by a closed pinhole can be reused. Defaults to `120`.
         * 
         * @return builder
         * 
         */
        public Builder tcpPortReuseMinimumHoldTimeInSeconds(@Nullable Output<Integer> tcpPortReuseMinimumHoldTimeInSeconds) {
            $.tcpPortReuseMinimumHoldTimeInSeconds = tcpPortReuseMinimumHoldTimeInSeconds;
            return this;
        }

        /**
         * @param tcpPortReuseMinimumHoldTimeInSeconds Minimum time in seconds that will pass before a TCP port that was used by a closed pinhole can be reused. Defaults to `120`.
         * 
         * @return builder
         * 
         */
        public Builder tcpPortReuseMinimumHoldTimeInSeconds(Integer tcpPortReuseMinimumHoldTimeInSeconds) {
            return tcpPortReuseMinimumHoldTimeInSeconds(Output.of(tcpPortReuseMinimumHoldTimeInSeconds));
        }

        /**
         * @param udpPinholeTimeoutInSeconds Pinhole timeout for UDP pinholes in seconds. Must between `1` to `180`, Default to `180`.
         * 
         * @return builder
         * 
         */
        public Builder udpPinholeTimeoutInSeconds(@Nullable Output<Integer> udpPinholeTimeoutInSeconds) {
            $.udpPinholeTimeoutInSeconds = udpPinholeTimeoutInSeconds;
            return this;
        }

        /**
         * @param udpPinholeTimeoutInSeconds Pinhole timeout for UDP pinholes in seconds. Must between `1` to `180`, Default to `180`.
         * 
         * @return builder
         * 
         */
        public Builder udpPinholeTimeoutInSeconds(Integer udpPinholeTimeoutInSeconds) {
            return udpPinholeTimeoutInSeconds(Output.of(udpPinholeTimeoutInSeconds));
        }

        /**
         * @param udpPortReuseMinimumHoldTimeInSeconds Minimum time in seconds that will pass before a UDP port that was used by a closed pinhole can be reused. Defaults to `60`.
         * 
         * @return builder
         * 
         */
        public Builder udpPortReuseMinimumHoldTimeInSeconds(@Nullable Output<Integer> udpPortReuseMinimumHoldTimeInSeconds) {
            $.udpPortReuseMinimumHoldTimeInSeconds = udpPortReuseMinimumHoldTimeInSeconds;
            return this;
        }

        /**
         * @param udpPortReuseMinimumHoldTimeInSeconds Minimum time in seconds that will pass before a UDP port that was used by a closed pinhole can be reused. Defaults to `60`.
         * 
         * @return builder
         * 
         */
        public Builder udpPortReuseMinimumHoldTimeInSeconds(Integer udpPortReuseMinimumHoldTimeInSeconds) {
            return udpPortReuseMinimumHoldTimeInSeconds(Output.of(udpPortReuseMinimumHoldTimeInSeconds));
        }

        public NetworkAttachedDataNetworkNetworkAddressPortTranslationArgs build() {
            return $;
        }
    }

}
