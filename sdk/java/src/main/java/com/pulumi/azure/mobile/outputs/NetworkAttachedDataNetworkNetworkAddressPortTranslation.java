// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.azure.mobile.outputs;

import com.pulumi.azure.mobile.outputs.NetworkAttachedDataNetworkNetworkAddressPortTranslationPortRange;
import com.pulumi.core.annotations.CustomType;
import java.lang.Integer;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class NetworkAttachedDataNetworkNetworkAddressPortTranslation {
    /**
     * @return Pinhole timeout for ICMP pinholes in seconds. Must between `1` to `180`, Default to `180`.
     * 
     */
    private @Nullable Integer icmpPinholeTimeoutInSeconds;
    /**
     * @return Maximum number of UDP and TCP pinholes that can be open simultaneously on the core interface. For 5G networks, this is the N6 interface. For 4G networks, this is the SGi interface. Must be between 1 and 65536.
     * 
     */
    private @Nullable Integer pinholeMaximumNumber;
    /**
     * @return A `port_range` block as defined below.
     * 
     */
    private @Nullable NetworkAttachedDataNetworkNetworkAddressPortTranslationPortRange portRange;
    /**
     * @return Pinhole timeout for TCP pinholes in seconds. Must between `1` to `180`, Default to `180`.
     * 
     */
    private @Nullable Integer tcpPinholeTimeoutInSeconds;
    /**
     * @return Minimum time in seconds that will pass before a TCP port that was used by a closed pinhole can be reused. Defaults to `120`.
     * 
     */
    private @Nullable Integer tcpPortReuseMinimumHoldTimeInSeconds;
    /**
     * @return Pinhole timeout for UDP pinholes in seconds. Must between `1` to `180`, Default to `180`.
     * 
     */
    private @Nullable Integer udpPinholeTimeoutInSeconds;
    /**
     * @return Minimum time in seconds that will pass before a UDP port that was used by a closed pinhole can be reused. Defaults to `60`.
     * 
     */
    private @Nullable Integer udpPortReuseMinimumHoldTimeInSeconds;

    private NetworkAttachedDataNetworkNetworkAddressPortTranslation() {}
    /**
     * @return Pinhole timeout for ICMP pinholes in seconds. Must between `1` to `180`, Default to `180`.
     * 
     */
    public Optional<Integer> icmpPinholeTimeoutInSeconds() {
        return Optional.ofNullable(this.icmpPinholeTimeoutInSeconds);
    }
    /**
     * @return Maximum number of UDP and TCP pinholes that can be open simultaneously on the core interface. For 5G networks, this is the N6 interface. For 4G networks, this is the SGi interface. Must be between 1 and 65536.
     * 
     */
    public Optional<Integer> pinholeMaximumNumber() {
        return Optional.ofNullable(this.pinholeMaximumNumber);
    }
    /**
     * @return A `port_range` block as defined below.
     * 
     */
    public Optional<NetworkAttachedDataNetworkNetworkAddressPortTranslationPortRange> portRange() {
        return Optional.ofNullable(this.portRange);
    }
    /**
     * @return Pinhole timeout for TCP pinholes in seconds. Must between `1` to `180`, Default to `180`.
     * 
     */
    public Optional<Integer> tcpPinholeTimeoutInSeconds() {
        return Optional.ofNullable(this.tcpPinholeTimeoutInSeconds);
    }
    /**
     * @return Minimum time in seconds that will pass before a TCP port that was used by a closed pinhole can be reused. Defaults to `120`.
     * 
     */
    public Optional<Integer> tcpPortReuseMinimumHoldTimeInSeconds() {
        return Optional.ofNullable(this.tcpPortReuseMinimumHoldTimeInSeconds);
    }
    /**
     * @return Pinhole timeout for UDP pinholes in seconds. Must between `1` to `180`, Default to `180`.
     * 
     */
    public Optional<Integer> udpPinholeTimeoutInSeconds() {
        return Optional.ofNullable(this.udpPinholeTimeoutInSeconds);
    }
    /**
     * @return Minimum time in seconds that will pass before a UDP port that was used by a closed pinhole can be reused. Defaults to `60`.
     * 
     */
    public Optional<Integer> udpPortReuseMinimumHoldTimeInSeconds() {
        return Optional.ofNullable(this.udpPortReuseMinimumHoldTimeInSeconds);
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(NetworkAttachedDataNetworkNetworkAddressPortTranslation defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private @Nullable Integer icmpPinholeTimeoutInSeconds;
        private @Nullable Integer pinholeMaximumNumber;
        private @Nullable NetworkAttachedDataNetworkNetworkAddressPortTranslationPortRange portRange;
        private @Nullable Integer tcpPinholeTimeoutInSeconds;
        private @Nullable Integer tcpPortReuseMinimumHoldTimeInSeconds;
        private @Nullable Integer udpPinholeTimeoutInSeconds;
        private @Nullable Integer udpPortReuseMinimumHoldTimeInSeconds;
        public Builder() {}
        public Builder(NetworkAttachedDataNetworkNetworkAddressPortTranslation defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.icmpPinholeTimeoutInSeconds = defaults.icmpPinholeTimeoutInSeconds;
    	      this.pinholeMaximumNumber = defaults.pinholeMaximumNumber;
    	      this.portRange = defaults.portRange;
    	      this.tcpPinholeTimeoutInSeconds = defaults.tcpPinholeTimeoutInSeconds;
    	      this.tcpPortReuseMinimumHoldTimeInSeconds = defaults.tcpPortReuseMinimumHoldTimeInSeconds;
    	      this.udpPinholeTimeoutInSeconds = defaults.udpPinholeTimeoutInSeconds;
    	      this.udpPortReuseMinimumHoldTimeInSeconds = defaults.udpPortReuseMinimumHoldTimeInSeconds;
        }

        @CustomType.Setter
        public Builder icmpPinholeTimeoutInSeconds(@Nullable Integer icmpPinholeTimeoutInSeconds) {
            this.icmpPinholeTimeoutInSeconds = icmpPinholeTimeoutInSeconds;
            return this;
        }
        @CustomType.Setter
        public Builder pinholeMaximumNumber(@Nullable Integer pinholeMaximumNumber) {
            this.pinholeMaximumNumber = pinholeMaximumNumber;
            return this;
        }
        @CustomType.Setter
        public Builder portRange(@Nullable NetworkAttachedDataNetworkNetworkAddressPortTranslationPortRange portRange) {
            this.portRange = portRange;
            return this;
        }
        @CustomType.Setter
        public Builder tcpPinholeTimeoutInSeconds(@Nullable Integer tcpPinholeTimeoutInSeconds) {
            this.tcpPinholeTimeoutInSeconds = tcpPinholeTimeoutInSeconds;
            return this;
        }
        @CustomType.Setter
        public Builder tcpPortReuseMinimumHoldTimeInSeconds(@Nullable Integer tcpPortReuseMinimumHoldTimeInSeconds) {
            this.tcpPortReuseMinimumHoldTimeInSeconds = tcpPortReuseMinimumHoldTimeInSeconds;
            return this;
        }
        @CustomType.Setter
        public Builder udpPinholeTimeoutInSeconds(@Nullable Integer udpPinholeTimeoutInSeconds) {
            this.udpPinholeTimeoutInSeconds = udpPinholeTimeoutInSeconds;
            return this;
        }
        @CustomType.Setter
        public Builder udpPortReuseMinimumHoldTimeInSeconds(@Nullable Integer udpPortReuseMinimumHoldTimeInSeconds) {
            this.udpPortReuseMinimumHoldTimeInSeconds = udpPortReuseMinimumHoldTimeInSeconds;
            return this;
        }
        public NetworkAttachedDataNetworkNetworkAddressPortTranslation build() {
            final var _resultValue = new NetworkAttachedDataNetworkNetworkAddressPortTranslation();
            _resultValue.icmpPinholeTimeoutInSeconds = icmpPinholeTimeoutInSeconds;
            _resultValue.pinholeMaximumNumber = pinholeMaximumNumber;
            _resultValue.portRange = portRange;
            _resultValue.tcpPinholeTimeoutInSeconds = tcpPinholeTimeoutInSeconds;
            _resultValue.tcpPortReuseMinimumHoldTimeInSeconds = tcpPortReuseMinimumHoldTimeInSeconds;
            _resultValue.udpPinholeTimeoutInSeconds = udpPinholeTimeoutInSeconds;
            _resultValue.udpPortReuseMinimumHoldTimeInSeconds = udpPortReuseMinimumHoldTimeInSeconds;
            return _resultValue;
        }
    }
}
