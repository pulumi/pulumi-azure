// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.azure.containerservice.inputs;

import com.pulumi.azure.containerservice.inputs.KubernetesClusterAciConnectorLinuxArgs;
import com.pulumi.azure.containerservice.inputs.KubernetesClusterApiServerAccessProfileArgs;
import com.pulumi.azure.containerservice.inputs.KubernetesClusterAutoScalerProfileArgs;
import com.pulumi.azure.containerservice.inputs.KubernetesClusterAzureActiveDirectoryRoleBasedAccessControlArgs;
import com.pulumi.azure.containerservice.inputs.KubernetesClusterConfidentialComputingArgs;
import com.pulumi.azure.containerservice.inputs.KubernetesClusterDefaultNodePoolArgs;
import com.pulumi.azure.containerservice.inputs.KubernetesClusterHttpProxyConfigArgs;
import com.pulumi.azure.containerservice.inputs.KubernetesClusterIdentityArgs;
import com.pulumi.azure.containerservice.inputs.KubernetesClusterIngressApplicationGatewayArgs;
import com.pulumi.azure.containerservice.inputs.KubernetesClusterKeyManagementServiceArgs;
import com.pulumi.azure.containerservice.inputs.KubernetesClusterKeyVaultSecretsProviderArgs;
import com.pulumi.azure.containerservice.inputs.KubernetesClusterKubeAdminConfigArgs;
import com.pulumi.azure.containerservice.inputs.KubernetesClusterKubeConfigArgs;
import com.pulumi.azure.containerservice.inputs.KubernetesClusterKubeletIdentityArgs;
import com.pulumi.azure.containerservice.inputs.KubernetesClusterLinuxProfileArgs;
import com.pulumi.azure.containerservice.inputs.KubernetesClusterMaintenanceWindowArgs;
import com.pulumi.azure.containerservice.inputs.KubernetesClusterMaintenanceWindowAutoUpgradeArgs;
import com.pulumi.azure.containerservice.inputs.KubernetesClusterMaintenanceWindowNodeOsArgs;
import com.pulumi.azure.containerservice.inputs.KubernetesClusterMicrosoftDefenderArgs;
import com.pulumi.azure.containerservice.inputs.KubernetesClusterMonitorMetricsArgs;
import com.pulumi.azure.containerservice.inputs.KubernetesClusterNetworkProfileArgs;
import com.pulumi.azure.containerservice.inputs.KubernetesClusterOmsAgentArgs;
import com.pulumi.azure.containerservice.inputs.KubernetesClusterServiceMeshProfileArgs;
import com.pulumi.azure.containerservice.inputs.KubernetesClusterServicePrincipalArgs;
import com.pulumi.azure.containerservice.inputs.KubernetesClusterStorageProfileArgs;
import com.pulumi.azure.containerservice.inputs.KubernetesClusterUpgradeOverrideArgs;
import com.pulumi.azure.containerservice.inputs.KubernetesClusterWebAppRoutingArgs;
import com.pulumi.azure.containerservice.inputs.KubernetesClusterWindowsProfileArgs;
import com.pulumi.azure.containerservice.inputs.KubernetesClusterWorkloadAutoscalerProfileArgs;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class KubernetesClusterState extends com.pulumi.resources.ResourceArgs {

    public static final KubernetesClusterState Empty = new KubernetesClusterState();

    /**
     * A `aci_connector_linux` block as defined below. For more details, please visit [Create and configure an AKS cluster to use virtual nodes](https://docs.microsoft.com/azure/aks/virtual-nodes-portal).
     * 
     */
    @Import(name="aciConnectorLinux")
    private @Nullable Output<KubernetesClusterAciConnectorLinuxArgs> aciConnectorLinux;

    /**
     * @return A `aci_connector_linux` block as defined below. For more details, please visit [Create and configure an AKS cluster to use virtual nodes](https://docs.microsoft.com/azure/aks/virtual-nodes-portal).
     * 
     */
    public Optional<Output<KubernetesClusterAciConnectorLinuxArgs>> aciConnectorLinux() {
        return Optional.ofNullable(this.aciConnectorLinux);
    }

    /**
     * An `api_server_access_profile` block as defined below.
     * 
     */
    @Import(name="apiServerAccessProfile")
    private @Nullable Output<KubernetesClusterApiServerAccessProfileArgs> apiServerAccessProfile;

    /**
     * @return An `api_server_access_profile` block as defined below.
     * 
     */
    public Optional<Output<KubernetesClusterApiServerAccessProfileArgs>> apiServerAccessProfile() {
        return Optional.ofNullable(this.apiServerAccessProfile);
    }

    /**
     * A `auto_scaler_profile` block as defined below.
     * 
     */
    @Import(name="autoScalerProfile")
    private @Nullable Output<KubernetesClusterAutoScalerProfileArgs> autoScalerProfile;

    /**
     * @return A `auto_scaler_profile` block as defined below.
     * 
     */
    public Optional<Output<KubernetesClusterAutoScalerProfileArgs>> autoScalerProfile() {
        return Optional.ofNullable(this.autoScalerProfile);
    }

    /**
     * The upgrade channel for this Kubernetes Cluster. Possible values are `patch`, `rapid`, `node-image` and `stable`. Omitting this field sets this value to `none`.
     * 
     * !&gt; **Note:** Cluster Auto-Upgrade will update the Kubernetes Cluster (and its Node Pools) to the latest GA version of Kubernetes automatically - please [see the Azure documentation for more information](https://docs.microsoft.com/azure/aks/upgrade-cluster#set-auto-upgrade-channel).
     * 
     * &gt; **Note:** Cluster Auto-Upgrade only updates to GA versions of Kubernetes and will not update to Preview versions.
     * 
     */
    @Import(name="automaticUpgradeChannel")
    private @Nullable Output<String> automaticUpgradeChannel;

    /**
     * @return The upgrade channel for this Kubernetes Cluster. Possible values are `patch`, `rapid`, `node-image` and `stable`. Omitting this field sets this value to `none`.
     * 
     * !&gt; **Note:** Cluster Auto-Upgrade will update the Kubernetes Cluster (and its Node Pools) to the latest GA version of Kubernetes automatically - please [see the Azure documentation for more information](https://docs.microsoft.com/azure/aks/upgrade-cluster#set-auto-upgrade-channel).
     * 
     * &gt; **Note:** Cluster Auto-Upgrade only updates to GA versions of Kubernetes and will not update to Preview versions.
     * 
     */
    public Optional<Output<String>> automaticUpgradeChannel() {
        return Optional.ofNullable(this.automaticUpgradeChannel);
    }

    /**
     * A `azure_active_directory_role_based_access_control` block as defined below.
     * 
     */
    @Import(name="azureActiveDirectoryRoleBasedAccessControl")
    private @Nullable Output<KubernetesClusterAzureActiveDirectoryRoleBasedAccessControlArgs> azureActiveDirectoryRoleBasedAccessControl;

    /**
     * @return A `azure_active_directory_role_based_access_control` block as defined below.
     * 
     */
    public Optional<Output<KubernetesClusterAzureActiveDirectoryRoleBasedAccessControlArgs>> azureActiveDirectoryRoleBasedAccessControl() {
        return Optional.ofNullable(this.azureActiveDirectoryRoleBasedAccessControl);
    }

    /**
     * Should the Azure Policy Add-On be enabled? For more details please visit [Understand Azure Policy for Azure Kubernetes Service](https://docs.microsoft.com/en-ie/azure/governance/policy/concepts/rego-for-aks)
     * 
     */
    @Import(name="azurePolicyEnabled")
    private @Nullable Output<Boolean> azurePolicyEnabled;

    /**
     * @return Should the Azure Policy Add-On be enabled? For more details please visit [Understand Azure Policy for Azure Kubernetes Service](https://docs.microsoft.com/en-ie/azure/governance/policy/concepts/rego-for-aks)
     * 
     */
    public Optional<Output<Boolean>> azurePolicyEnabled() {
        return Optional.ofNullable(this.azurePolicyEnabled);
    }

    /**
     * A `confidential_computing` block as defined below. For more details please [the documentation](https://learn.microsoft.com/en-us/azure/confidential-computing/confidential-nodes-aks-overview)
     * 
     */
    @Import(name="confidentialComputing")
    private @Nullable Output<KubernetesClusterConfidentialComputingArgs> confidentialComputing;

    /**
     * @return A `confidential_computing` block as defined below. For more details please [the documentation](https://learn.microsoft.com/en-us/azure/confidential-computing/confidential-nodes-aks-overview)
     * 
     */
    public Optional<Output<KubernetesClusterConfidentialComputingArgs>> confidentialComputing() {
        return Optional.ofNullable(this.confidentialComputing);
    }

    /**
     * Should cost analysis be enabled for this Kubernetes Cluster? Defaults to `false`. The `sku_tier` must be set to `Standard` or `Premium` to enable this feature. Enabling this will add Kubernetes Namespace and Deployment details to the Cost Analysis views in the Azure portal.
     * 
     */
    @Import(name="costAnalysisEnabled")
    private @Nullable Output<Boolean> costAnalysisEnabled;

    /**
     * @return Should cost analysis be enabled for this Kubernetes Cluster? Defaults to `false`. The `sku_tier` must be set to `Standard` or `Premium` to enable this feature. Enabling this will add Kubernetes Namespace and Deployment details to the Cost Analysis views in the Azure portal.
     * 
     */
    public Optional<Output<Boolean>> costAnalysisEnabled() {
        return Optional.ofNullable(this.costAnalysisEnabled);
    }

    /**
     * The current version running on the Azure Kubernetes Managed Cluster.
     * 
     */
    @Import(name="currentKubernetesVersion")
    private @Nullable Output<String> currentKubernetesVersion;

    /**
     * @return The current version running on the Azure Kubernetes Managed Cluster.
     * 
     */
    public Optional<Output<String>> currentKubernetesVersion() {
        return Optional.ofNullable(this.currentKubernetesVersion);
    }

    /**
     * Specifies configuration for &#34;System&#34; mode node pool. A `default_node_pool` block as defined below.
     * 
     */
    @Import(name="defaultNodePool")
    private @Nullable Output<KubernetesClusterDefaultNodePoolArgs> defaultNodePool;

    /**
     * @return Specifies configuration for &#34;System&#34; mode node pool. A `default_node_pool` block as defined below.
     * 
     */
    public Optional<Output<KubernetesClusterDefaultNodePoolArgs>> defaultNodePool() {
        return Optional.ofNullable(this.defaultNodePool);
    }

    /**
     * The ID of the Disk Encryption Set which should be used for the Nodes and Volumes. More information [can be found in the documentation](https://docs.microsoft.com/azure/aks/azure-disk-customer-managed-keys). Changing this forces a new resource to be created.
     * 
     */
    @Import(name="diskEncryptionSetId")
    private @Nullable Output<String> diskEncryptionSetId;

    /**
     * @return The ID of the Disk Encryption Set which should be used for the Nodes and Volumes. More information [can be found in the documentation](https://docs.microsoft.com/azure/aks/azure-disk-customer-managed-keys). Changing this forces a new resource to be created.
     * 
     */
    public Optional<Output<String>> diskEncryptionSetId() {
        return Optional.ofNullable(this.diskEncryptionSetId);
    }

    /**
     * DNS prefix specified when creating the managed cluster. Possible values must begin and end with a letter or number, contain only letters, numbers, and hyphens and be between 1 and 54 characters in length. Changing this forces a new resource to be created.
     * 
     */
    @Import(name="dnsPrefix")
    private @Nullable Output<String> dnsPrefix;

    /**
     * @return DNS prefix specified when creating the managed cluster. Possible values must begin and end with a letter or number, contain only letters, numbers, and hyphens and be between 1 and 54 characters in length. Changing this forces a new resource to be created.
     * 
     */
    public Optional<Output<String>> dnsPrefix() {
        return Optional.ofNullable(this.dnsPrefix);
    }

    /**
     * Specifies the DNS prefix to use with private clusters. Changing this forces a new resource to be created.
     * 
     * &gt; **Note:** You must define either a `dns_prefix` or a `dns_prefix_private_cluster` field.
     * 
     * In addition, one of either `identity` or `service_principal` blocks must be specified.
     * 
     */
    @Import(name="dnsPrefixPrivateCluster")
    private @Nullable Output<String> dnsPrefixPrivateCluster;

    /**
     * @return Specifies the DNS prefix to use with private clusters. Changing this forces a new resource to be created.
     * 
     * &gt; **Note:** You must define either a `dns_prefix` or a `dns_prefix_private_cluster` field.
     * 
     * In addition, one of either `identity` or `service_principal` blocks must be specified.
     * 
     */
    public Optional<Output<String>> dnsPrefixPrivateCluster() {
        return Optional.ofNullable(this.dnsPrefixPrivateCluster);
    }

    /**
     * Specifies the Extended Zone (formerly called Edge Zone) within the Azure Region where this Managed Kubernetes Cluster should exist. Changing this forces a new resource to be created.
     * 
     */
    @Import(name="edgeZone")
    private @Nullable Output<String> edgeZone;

    /**
     * @return Specifies the Extended Zone (formerly called Edge Zone) within the Azure Region where this Managed Kubernetes Cluster should exist. Changing this forces a new resource to be created.
     * 
     */
    public Optional<Output<String>> edgeZone() {
        return Optional.ofNullable(this.edgeZone);
    }

    /**
     * The FQDN of the Azure Kubernetes Managed Cluster.
     * 
     */
    @Import(name="fqdn")
    private @Nullable Output<String> fqdn;

    /**
     * @return The FQDN of the Azure Kubernetes Managed Cluster.
     * 
     */
    public Optional<Output<String>> fqdn() {
        return Optional.ofNullable(this.fqdn);
    }

    /**
     * Should HTTP Application Routing be enabled?
     * 
     * &gt; **Note:** At this time HTTP Application Routing is not supported in Azure China or Azure US Government.
     * 
     */
    @Import(name="httpApplicationRoutingEnabled")
    private @Nullable Output<Boolean> httpApplicationRoutingEnabled;

    /**
     * @return Should HTTP Application Routing be enabled?
     * 
     * &gt; **Note:** At this time HTTP Application Routing is not supported in Azure China or Azure US Government.
     * 
     */
    public Optional<Output<Boolean>> httpApplicationRoutingEnabled() {
        return Optional.ofNullable(this.httpApplicationRoutingEnabled);
    }

    /**
     * The Zone Name of the HTTP Application Routing.
     * 
     */
    @Import(name="httpApplicationRoutingZoneName")
    private @Nullable Output<String> httpApplicationRoutingZoneName;

    /**
     * @return The Zone Name of the HTTP Application Routing.
     * 
     */
    public Optional<Output<String>> httpApplicationRoutingZoneName() {
        return Optional.ofNullable(this.httpApplicationRoutingZoneName);
    }

    /**
     * A `http_proxy_config` block as defined below.
     * 
     */
    @Import(name="httpProxyConfig")
    private @Nullable Output<KubernetesClusterHttpProxyConfigArgs> httpProxyConfig;

    /**
     * @return A `http_proxy_config` block as defined below.
     * 
     */
    public Optional<Output<KubernetesClusterHttpProxyConfigArgs>> httpProxyConfig() {
        return Optional.ofNullable(this.httpProxyConfig);
    }

    /**
     * An `identity` block as defined below. One of either `identity` or `service_principal` must be specified.
     * 
     * !&gt; **Note:** A migration scenario from `service_principal` to `identity` is supported. When upgrading `service_principal` to `identity`, your cluster&#39;s control plane and addon pods will switch to use managed identity, but the kubelets will keep using your configured `service_principal` until you upgrade your Node Pool.
     * 
     */
    @Import(name="identity")
    private @Nullable Output<KubernetesClusterIdentityArgs> identity;

    /**
     * @return An `identity` block as defined below. One of either `identity` or `service_principal` must be specified.
     * 
     * !&gt; **Note:** A migration scenario from `service_principal` to `identity` is supported. When upgrading `service_principal` to `identity`, your cluster&#39;s control plane and addon pods will switch to use managed identity, but the kubelets will keep using your configured `service_principal` until you upgrade your Node Pool.
     * 
     */
    public Optional<Output<KubernetesClusterIdentityArgs>> identity() {
        return Optional.ofNullable(this.identity);
    }

    /**
     * Specifies whether Image Cleaner is enabled.
     * 
     */
    @Import(name="imageCleanerEnabled")
    private @Nullable Output<Boolean> imageCleanerEnabled;

    /**
     * @return Specifies whether Image Cleaner is enabled.
     * 
     */
    public Optional<Output<Boolean>> imageCleanerEnabled() {
        return Optional.ofNullable(this.imageCleanerEnabled);
    }

    /**
     * Specifies the interval in hours when images should be cleaned up. Defaults to `0`.
     * 
     */
    @Import(name="imageCleanerIntervalHours")
    private @Nullable Output<Integer> imageCleanerIntervalHours;

    /**
     * @return Specifies the interval in hours when images should be cleaned up. Defaults to `0`.
     * 
     */
    public Optional<Output<Integer>> imageCleanerIntervalHours() {
        return Optional.ofNullable(this.imageCleanerIntervalHours);
    }

    /**
     * A `ingress_application_gateway` block as defined below.
     * 
     * &gt; **Note:** Since the Application Gateway is deployed inside a Virtual Network, users (and Service Principals) that are operating the Application Gateway must have the `Microsoft.Network/virtualNetworks/subnets/join/action` permission on the Virtual Network or Subnet. For more details, please visit [Virtual Network Permission](https://learn.microsoft.com/en-us/azure/application-gateway/configuration-infrastructure#virtual-network-permission).
     * 
     */
    @Import(name="ingressApplicationGateway")
    private @Nullable Output<KubernetesClusterIngressApplicationGatewayArgs> ingressApplicationGateway;

    /**
     * @return A `ingress_application_gateway` block as defined below.
     * 
     * &gt; **Note:** Since the Application Gateway is deployed inside a Virtual Network, users (and Service Principals) that are operating the Application Gateway must have the `Microsoft.Network/virtualNetworks/subnets/join/action` permission on the Virtual Network or Subnet. For more details, please visit [Virtual Network Permission](https://learn.microsoft.com/en-us/azure/application-gateway/configuration-infrastructure#virtual-network-permission).
     * 
     */
    public Optional<Output<KubernetesClusterIngressApplicationGatewayArgs>> ingressApplicationGateway() {
        return Optional.ofNullable(this.ingressApplicationGateway);
    }

    /**
     * A `key_management_service` block as defined below. For more details, please visit [Key Management Service (KMS) etcd encryption to an AKS cluster](https://learn.microsoft.com/en-us/azure/aks/use-kms-etcd-encryption).
     * 
     */
    @Import(name="keyManagementService")
    private @Nullable Output<KubernetesClusterKeyManagementServiceArgs> keyManagementService;

    /**
     * @return A `key_management_service` block as defined below. For more details, please visit [Key Management Service (KMS) etcd encryption to an AKS cluster](https://learn.microsoft.com/en-us/azure/aks/use-kms-etcd-encryption).
     * 
     */
    public Optional<Output<KubernetesClusterKeyManagementServiceArgs>> keyManagementService() {
        return Optional.ofNullable(this.keyManagementService);
    }

    /**
     * A `key_vault_secrets_provider` block as defined below. For more details, please visit [Azure Keyvault Secrets Provider for AKS](https://docs.microsoft.com/azure/aks/csi-secrets-store-driver).
     * 
     */
    @Import(name="keyVaultSecretsProvider")
    private @Nullable Output<KubernetesClusterKeyVaultSecretsProviderArgs> keyVaultSecretsProvider;

    /**
     * @return A `key_vault_secrets_provider` block as defined below. For more details, please visit [Azure Keyvault Secrets Provider for AKS](https://docs.microsoft.com/azure/aks/csi-secrets-store-driver).
     * 
     */
    public Optional<Output<KubernetesClusterKeyVaultSecretsProviderArgs>> keyVaultSecretsProvider() {
        return Optional.ofNullable(this.keyVaultSecretsProvider);
    }

    /**
     * Raw Kubernetes config for the admin account to be used by [kubectl](https://kubernetes.io/docs/reference/kubectl/overview/) and other compatible tools. This is only available when Role Based Access Control with Azure Active Directory is enabled and local accounts enabled.
     * 
     */
    @Import(name="kubeAdminConfigRaw")
    private @Nullable Output<String> kubeAdminConfigRaw;

    /**
     * @return Raw Kubernetes config for the admin account to be used by [kubectl](https://kubernetes.io/docs/reference/kubectl/overview/) and other compatible tools. This is only available when Role Based Access Control with Azure Active Directory is enabled and local accounts enabled.
     * 
     */
    public Optional<Output<String>> kubeAdminConfigRaw() {
        return Optional.ofNullable(this.kubeAdminConfigRaw);
    }

    /**
     * A `kube_admin_config` block as defined below. This is only available when Role Based Access Control with Azure Active Directory is enabled and local accounts enabled.
     * 
     */
    @Import(name="kubeAdminConfigs")
    private @Nullable Output<List<KubernetesClusterKubeAdminConfigArgs>> kubeAdminConfigs;

    /**
     * @return A `kube_admin_config` block as defined below. This is only available when Role Based Access Control with Azure Active Directory is enabled and local accounts enabled.
     * 
     */
    public Optional<Output<List<KubernetesClusterKubeAdminConfigArgs>>> kubeAdminConfigs() {
        return Optional.ofNullable(this.kubeAdminConfigs);
    }

    /**
     * Raw Kubernetes config to be used by [kubectl](https://kubernetes.io/docs/reference/kubectl/overview/) and other compatible tools.
     * 
     */
    @Import(name="kubeConfigRaw")
    private @Nullable Output<String> kubeConfigRaw;

    /**
     * @return Raw Kubernetes config to be used by [kubectl](https://kubernetes.io/docs/reference/kubectl/overview/) and other compatible tools.
     * 
     */
    public Optional<Output<String>> kubeConfigRaw() {
        return Optional.ofNullable(this.kubeConfigRaw);
    }

    /**
     * A `kube_config` block as defined below.
     * 
     */
    @Import(name="kubeConfigs")
    private @Nullable Output<List<KubernetesClusterKubeConfigArgs>> kubeConfigs;

    /**
     * @return A `kube_config` block as defined below.
     * 
     */
    public Optional<Output<List<KubernetesClusterKubeConfigArgs>>> kubeConfigs() {
        return Optional.ofNullable(this.kubeConfigs);
    }

    /**
     * A `kubelet_identity` block as defined below.
     * 
     */
    @Import(name="kubeletIdentity")
    private @Nullable Output<KubernetesClusterKubeletIdentityArgs> kubeletIdentity;

    /**
     * @return A `kubelet_identity` block as defined below.
     * 
     */
    public Optional<Output<KubernetesClusterKubeletIdentityArgs>> kubeletIdentity() {
        return Optional.ofNullable(this.kubeletIdentity);
    }

    /**
     * Version of Kubernetes specified when creating the AKS managed cluster. If not specified, the latest recommended version will be used at provisioning time (but won&#39;t auto-upgrade). AKS does not require an exact patch version to be specified, minor version aliases such as `1.22` are also supported. - The minor version&#39;s latest GA patch is automatically chosen in that case. More details can be found in [the documentation](https://docs.microsoft.com/en-us/azure/aks/supported-kubernetes-versions?tabs=azure-cli#alias-minor-version).
     * 
     * &gt; **Note:** Upgrading your cluster may take up to 10 minutes per node.
     * 
     */
    @Import(name="kubernetesVersion")
    private @Nullable Output<String> kubernetesVersion;

    /**
     * @return Version of Kubernetes specified when creating the AKS managed cluster. If not specified, the latest recommended version will be used at provisioning time (but won&#39;t auto-upgrade). AKS does not require an exact patch version to be specified, minor version aliases such as `1.22` are also supported. - The minor version&#39;s latest GA patch is automatically chosen in that case. More details can be found in [the documentation](https://docs.microsoft.com/en-us/azure/aks/supported-kubernetes-versions?tabs=azure-cli#alias-minor-version).
     * 
     * &gt; **Note:** Upgrading your cluster may take up to 10 minutes per node.
     * 
     */
    public Optional<Output<String>> kubernetesVersion() {
        return Optional.ofNullable(this.kubernetesVersion);
    }

    /**
     * A `linux_profile` block as defined below.
     * 
     */
    @Import(name="linuxProfile")
    private @Nullable Output<KubernetesClusterLinuxProfileArgs> linuxProfile;

    /**
     * @return A `linux_profile` block as defined below.
     * 
     */
    public Optional<Output<KubernetesClusterLinuxProfileArgs>> linuxProfile() {
        return Optional.ofNullable(this.linuxProfile);
    }

    /**
     * If `true` local accounts will be disabled. See [the documentation](https://docs.microsoft.com/azure/aks/managed-aad#disable-local-accounts) for more information.
     * 
     * &gt; **Note:** If `local_account_disabled` is set to `true`, it is required to enable Kubernetes RBAC and AKS-managed Azure AD integration. See [the documentation](https://docs.microsoft.com/azure/aks/managed-aad#azure-ad-authentication-overview) for more information.
     * 
     */
    @Import(name="localAccountDisabled")
    private @Nullable Output<Boolean> localAccountDisabled;

    /**
     * @return If `true` local accounts will be disabled. See [the documentation](https://docs.microsoft.com/azure/aks/managed-aad#disable-local-accounts) for more information.
     * 
     * &gt; **Note:** If `local_account_disabled` is set to `true`, it is required to enable Kubernetes RBAC and AKS-managed Azure AD integration. See [the documentation](https://docs.microsoft.com/azure/aks/managed-aad#azure-ad-authentication-overview) for more information.
     * 
     */
    public Optional<Output<Boolean>> localAccountDisabled() {
        return Optional.ofNullable(this.localAccountDisabled);
    }

    /**
     * The location where the Managed Kubernetes Cluster should be created. Changing this forces a new resource to be created.
     * 
     */
    @Import(name="location")
    private @Nullable Output<String> location;

    /**
     * @return The location where the Managed Kubernetes Cluster should be created. Changing this forces a new resource to be created.
     * 
     */
    public Optional<Output<String>> location() {
        return Optional.ofNullable(this.location);
    }

    /**
     * A `maintenance_window` block as defined below.
     * 
     */
    @Import(name="maintenanceWindow")
    private @Nullable Output<KubernetesClusterMaintenanceWindowArgs> maintenanceWindow;

    /**
     * @return A `maintenance_window` block as defined below.
     * 
     */
    public Optional<Output<KubernetesClusterMaintenanceWindowArgs>> maintenanceWindow() {
        return Optional.ofNullable(this.maintenanceWindow);
    }

    /**
     * A `maintenance_window_auto_upgrade` block as defined below.
     * 
     */
    @Import(name="maintenanceWindowAutoUpgrade")
    private @Nullable Output<KubernetesClusterMaintenanceWindowAutoUpgradeArgs> maintenanceWindowAutoUpgrade;

    /**
     * @return A `maintenance_window_auto_upgrade` block as defined below.
     * 
     */
    public Optional<Output<KubernetesClusterMaintenanceWindowAutoUpgradeArgs>> maintenanceWindowAutoUpgrade() {
        return Optional.ofNullable(this.maintenanceWindowAutoUpgrade);
    }

    /**
     * A `maintenance_window_node_os` block as defined below.
     * 
     */
    @Import(name="maintenanceWindowNodeOs")
    private @Nullable Output<KubernetesClusterMaintenanceWindowNodeOsArgs> maintenanceWindowNodeOs;

    /**
     * @return A `maintenance_window_node_os` block as defined below.
     * 
     */
    public Optional<Output<KubernetesClusterMaintenanceWindowNodeOsArgs>> maintenanceWindowNodeOs() {
        return Optional.ofNullable(this.maintenanceWindowNodeOs);
    }

    /**
     * A `microsoft_defender` block as defined below.
     * 
     */
    @Import(name="microsoftDefender")
    private @Nullable Output<KubernetesClusterMicrosoftDefenderArgs> microsoftDefender;

    /**
     * @return A `microsoft_defender` block as defined below.
     * 
     */
    public Optional<Output<KubernetesClusterMicrosoftDefenderArgs>> microsoftDefender() {
        return Optional.ofNullable(this.microsoftDefender);
    }

    /**
     * Specifies a Prometheus add-on profile for the Kubernetes Cluster. A `monitor_metrics` block as defined below.
     * 
     * &gt; **Note:** If deploying Managed Prometheus, the `monitor_metrics` properties are required to configure the cluster for metrics collection. If no value is needed, set properties to `null`.
     * 
     */
    @Import(name="monitorMetrics")
    private @Nullable Output<KubernetesClusterMonitorMetricsArgs> monitorMetrics;

    /**
     * @return Specifies a Prometheus add-on profile for the Kubernetes Cluster. A `monitor_metrics` block as defined below.
     * 
     * &gt; **Note:** If deploying Managed Prometheus, the `monitor_metrics` properties are required to configure the cluster for metrics collection. If no value is needed, set properties to `null`.
     * 
     */
    public Optional<Output<KubernetesClusterMonitorMetricsArgs>> monitorMetrics() {
        return Optional.ofNullable(this.monitorMetrics);
    }

    /**
     * The name of the Managed Kubernetes Cluster to create. Changing this forces a new resource to be created.
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return The name of the Managed Kubernetes Cluster to create. Changing this forces a new resource to be created.
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * A `network_profile` block as defined below. Changing this forces a new resource to be created.
     * 
     * &gt; **Note:** If `network_profile` is not defined, `kubenet` profile will be used by default.
     * 
     */
    @Import(name="networkProfile")
    private @Nullable Output<KubernetesClusterNetworkProfileArgs> networkProfile;

    /**
     * @return A `network_profile` block as defined below. Changing this forces a new resource to be created.
     * 
     * &gt; **Note:** If `network_profile` is not defined, `kubenet` profile will be used by default.
     * 
     */
    public Optional<Output<KubernetesClusterNetworkProfileArgs>> networkProfile() {
        return Optional.ofNullable(this.networkProfile);
    }

    /**
     * The upgrade channel for this Kubernetes Cluster Nodes&#39; OS Image. Possible values are `Unmanaged`, `SecurityPatch`, `NodeImage` and `None`. Defaults to `NodeImage`.
     * 
     * &gt; **Note:** `node_os_upgrade_channel` must be set to `NodeImage` if `automatic_upgrade_channel` has been set to `node-image`
     * 
     */
    @Import(name="nodeOsUpgradeChannel")
    private @Nullable Output<String> nodeOsUpgradeChannel;

    /**
     * @return The upgrade channel for this Kubernetes Cluster Nodes&#39; OS Image. Possible values are `Unmanaged`, `SecurityPatch`, `NodeImage` and `None`. Defaults to `NodeImage`.
     * 
     * &gt; **Note:** `node_os_upgrade_channel` must be set to `NodeImage` if `automatic_upgrade_channel` has been set to `node-image`
     * 
     */
    public Optional<Output<String>> nodeOsUpgradeChannel() {
        return Optional.ofNullable(this.nodeOsUpgradeChannel);
    }

    /**
     * The name of the Resource Group where the Kubernetes Nodes should exist. Changing this forces a new resource to be created.
     * 
     * &gt; **Note:** Azure requires that a new, non-existent Resource Group is used, as otherwise, the provisioning of the Kubernetes Service will fail.
     * 
     */
    @Import(name="nodeResourceGroup")
    private @Nullable Output<String> nodeResourceGroup;

    /**
     * @return The name of the Resource Group where the Kubernetes Nodes should exist. Changing this forces a new resource to be created.
     * 
     * &gt; **Note:** Azure requires that a new, non-existent Resource Group is used, as otherwise, the provisioning of the Kubernetes Service will fail.
     * 
     */
    public Optional<Output<String>> nodeResourceGroup() {
        return Optional.ofNullable(this.nodeResourceGroup);
    }

    /**
     * The ID of the Resource Group containing the resources for this Managed Kubernetes Cluster.
     * 
     */
    @Import(name="nodeResourceGroupId")
    private @Nullable Output<String> nodeResourceGroupId;

    /**
     * @return The ID of the Resource Group containing the resources for this Managed Kubernetes Cluster.
     * 
     */
    public Optional<Output<String>> nodeResourceGroupId() {
        return Optional.ofNullable(this.nodeResourceGroupId);
    }

    /**
     * Enable or Disable the [OIDC issuer URL](https://learn.microsoft.com/en-gb/azure/aks/use-oidc-issuer)
     * 
     */
    @Import(name="oidcIssuerEnabled")
    private @Nullable Output<Boolean> oidcIssuerEnabled;

    /**
     * @return Enable or Disable the [OIDC issuer URL](https://learn.microsoft.com/en-gb/azure/aks/use-oidc-issuer)
     * 
     */
    public Optional<Output<Boolean>> oidcIssuerEnabled() {
        return Optional.ofNullable(this.oidcIssuerEnabled);
    }

    /**
     * The OIDC issuer URL that is associated with the cluster.
     * 
     */
    @Import(name="oidcIssuerUrl")
    private @Nullable Output<String> oidcIssuerUrl;

    /**
     * @return The OIDC issuer URL that is associated with the cluster.
     * 
     */
    public Optional<Output<String>> oidcIssuerUrl() {
        return Optional.ofNullable(this.oidcIssuerUrl);
    }

    /**
     * A `oms_agent` block as defined below.
     * 
     */
    @Import(name="omsAgent")
    private @Nullable Output<KubernetesClusterOmsAgentArgs> omsAgent;

    /**
     * @return A `oms_agent` block as defined below.
     * 
     */
    public Optional<Output<KubernetesClusterOmsAgentArgs>> omsAgent() {
        return Optional.ofNullable(this.omsAgent);
    }

    /**
     * Is Open Service Mesh enabled? For more details, please visit [Open Service Mesh for AKS](https://docs.microsoft.com/azure/aks/open-service-mesh-about).
     * 
     */
    @Import(name="openServiceMeshEnabled")
    private @Nullable Output<Boolean> openServiceMeshEnabled;

    /**
     * @return Is Open Service Mesh enabled? For more details, please visit [Open Service Mesh for AKS](https://docs.microsoft.com/azure/aks/open-service-mesh-about).
     * 
     */
    public Optional<Output<Boolean>> openServiceMeshEnabled() {
        return Optional.ofNullable(this.openServiceMeshEnabled);
    }

    /**
     * The FQDN for the Azure Portal resources when private link has been enabled, which is only resolvable inside the Virtual Network used by the Kubernetes Cluster.
     * 
     */
    @Import(name="portalFqdn")
    private @Nullable Output<String> portalFqdn;

    /**
     * @return The FQDN for the Azure Portal resources when private link has been enabled, which is only resolvable inside the Virtual Network used by the Kubernetes Cluster.
     * 
     */
    public Optional<Output<String>> portalFqdn() {
        return Optional.ofNullable(this.portalFqdn);
    }

    /**
     * Should this Kubernetes Cluster have its API server only exposed on internal IP addresses? This provides a Private IP Address for the Kubernetes API on the Virtual Network where the Kubernetes Cluster is located. Defaults to `false`. Changing this forces a new resource to be created.
     * 
     */
    @Import(name="privateClusterEnabled")
    private @Nullable Output<Boolean> privateClusterEnabled;

    /**
     * @return Should this Kubernetes Cluster have its API server only exposed on internal IP addresses? This provides a Private IP Address for the Kubernetes API on the Virtual Network where the Kubernetes Cluster is located. Defaults to `false`. Changing this forces a new resource to be created.
     * 
     */
    public Optional<Output<Boolean>> privateClusterEnabled() {
        return Optional.ofNullable(this.privateClusterEnabled);
    }

    /**
     * Specifies whether a Public FQDN for this Private Cluster should be added. Defaults to `false`.
     * 
     * &gt; **Note:** If you use BYO DNS Zone, the AKS cluster should either use a User Assigned Identity or a service principal (which is deprecated) with the `Private DNS Zone Contributor` role and access to this Private DNS Zone. If `UserAssigned` identity is used - to prevent improper resource order destruction - the cluster should depend on the role assignment, like in this example:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.azure.core.ResourceGroup;
     * import com.pulumi.azure.core.ResourceGroupArgs;
     * import com.pulumi.azure.privatedns.Zone;
     * import com.pulumi.azure.privatedns.ZoneArgs;
     * import com.pulumi.azure.authorization.UserAssignedIdentity;
     * import com.pulumi.azure.authorization.UserAssignedIdentityArgs;
     * import com.pulumi.azure.authorization.Assignment;
     * import com.pulumi.azure.authorization.AssignmentArgs;
     * import com.pulumi.azure.containerservice.KubernetesCluster;
     * import com.pulumi.azure.containerservice.KubernetesClusterArgs;
     * import com.pulumi.resources.CustomResourceOptions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         var example = new ResourceGroup("example", ResourceGroupArgs.builder()
     *             .name("example")
     *             .location("West Europe")
     *             .build());
     * 
     *         var exampleZone = new Zone("exampleZone", ZoneArgs.builder()
     *             .name("privatelink.eastus2.azmk8s.io")
     *             .resourceGroupName(example.name())
     *             .build());
     * 
     *         var exampleUserAssignedIdentity = new UserAssignedIdentity("exampleUserAssignedIdentity", UserAssignedIdentityArgs.builder()
     *             .name("aks-example-identity")
     *             .resourceGroupName(example.name())
     *             .location(example.location())
     *             .build());
     * 
     *         var exampleAssignment = new Assignment("exampleAssignment", AssignmentArgs.builder()
     *             .scope(exampleZone.id())
     *             .roleDefinitionName("Private DNS Zone Contributor")
     *             .principalId(exampleUserAssignedIdentity.principalId())
     *             .build());
     * 
     *         var exampleKubernetesCluster = new KubernetesCluster("exampleKubernetesCluster", KubernetesClusterArgs.builder()
     *             .name("aksexamplewithprivatednszone1")
     *             .location(example.location())
     *             .resourceGroupName(example.name())
     *             .dnsPrefix("aksexamplednsprefix1")
     *             .privateClusterEnabled(true)
     *             .privateDnsZoneId(exampleZone.id())
     *             .build(), CustomResourceOptions.builder()
     *                 .dependsOn(exampleAssignment)
     *                 .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    @Import(name="privateClusterPublicFqdnEnabled")
    private @Nullable Output<Boolean> privateClusterPublicFqdnEnabled;

    /**
     * @return Specifies whether a Public FQDN for this Private Cluster should be added. Defaults to `false`.
     * 
     * &gt; **Note:** If you use BYO DNS Zone, the AKS cluster should either use a User Assigned Identity or a service principal (which is deprecated) with the `Private DNS Zone Contributor` role and access to this Private DNS Zone. If `UserAssigned` identity is used - to prevent improper resource order destruction - the cluster should depend on the role assignment, like in this example:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.azure.core.ResourceGroup;
     * import com.pulumi.azure.core.ResourceGroupArgs;
     * import com.pulumi.azure.privatedns.Zone;
     * import com.pulumi.azure.privatedns.ZoneArgs;
     * import com.pulumi.azure.authorization.UserAssignedIdentity;
     * import com.pulumi.azure.authorization.UserAssignedIdentityArgs;
     * import com.pulumi.azure.authorization.Assignment;
     * import com.pulumi.azure.authorization.AssignmentArgs;
     * import com.pulumi.azure.containerservice.KubernetesCluster;
     * import com.pulumi.azure.containerservice.KubernetesClusterArgs;
     * import com.pulumi.resources.CustomResourceOptions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         var example = new ResourceGroup("example", ResourceGroupArgs.builder()
     *             .name("example")
     *             .location("West Europe")
     *             .build());
     * 
     *         var exampleZone = new Zone("exampleZone", ZoneArgs.builder()
     *             .name("privatelink.eastus2.azmk8s.io")
     *             .resourceGroupName(example.name())
     *             .build());
     * 
     *         var exampleUserAssignedIdentity = new UserAssignedIdentity("exampleUserAssignedIdentity", UserAssignedIdentityArgs.builder()
     *             .name("aks-example-identity")
     *             .resourceGroupName(example.name())
     *             .location(example.location())
     *             .build());
     * 
     *         var exampleAssignment = new Assignment("exampleAssignment", AssignmentArgs.builder()
     *             .scope(exampleZone.id())
     *             .roleDefinitionName("Private DNS Zone Contributor")
     *             .principalId(exampleUserAssignedIdentity.principalId())
     *             .build());
     * 
     *         var exampleKubernetesCluster = new KubernetesCluster("exampleKubernetesCluster", KubernetesClusterArgs.builder()
     *             .name("aksexamplewithprivatednszone1")
     *             .location(example.location())
     *             .resourceGroupName(example.name())
     *             .dnsPrefix("aksexamplednsprefix1")
     *             .privateClusterEnabled(true)
     *             .privateDnsZoneId(exampleZone.id())
     *             .build(), CustomResourceOptions.builder()
     *                 .dependsOn(exampleAssignment)
     *                 .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public Optional<Output<Boolean>> privateClusterPublicFqdnEnabled() {
        return Optional.ofNullable(this.privateClusterPublicFqdnEnabled);
    }

    /**
     * Either the ID of Private DNS Zone which should be delegated to this Cluster, `System` to have AKS manage this or `None`. In case of `None` you will need to bring your own DNS server and set up resolving, otherwise, the cluster will have issues after provisioning. Changing this forces a new resource to be created.
     * 
     */
    @Import(name="privateDnsZoneId")
    private @Nullable Output<String> privateDnsZoneId;

    /**
     * @return Either the ID of Private DNS Zone which should be delegated to this Cluster, `System` to have AKS manage this or `None`. In case of `None` you will need to bring your own DNS server and set up resolving, otherwise, the cluster will have issues after provisioning. Changing this forces a new resource to be created.
     * 
     */
    public Optional<Output<String>> privateDnsZoneId() {
        return Optional.ofNullable(this.privateDnsZoneId);
    }

    /**
     * The FQDN for the Kubernetes Cluster when private link has been enabled, which is only resolvable inside the Virtual Network used by the Kubernetes Cluster.
     * 
     */
    @Import(name="privateFqdn")
    private @Nullable Output<String> privateFqdn;

    /**
     * @return The FQDN for the Kubernetes Cluster when private link has been enabled, which is only resolvable inside the Virtual Network used by the Kubernetes Cluster.
     * 
     */
    public Optional<Output<String>> privateFqdn() {
        return Optional.ofNullable(this.privateFqdn);
    }

    /**
     * Specifies the Resource Group where the Managed Kubernetes Cluster should exist. Changing this forces a new resource to be created.
     * 
     */
    @Import(name="resourceGroupName")
    private @Nullable Output<String> resourceGroupName;

    /**
     * @return Specifies the Resource Group where the Managed Kubernetes Cluster should exist. Changing this forces a new resource to be created.
     * 
     */
    public Optional<Output<String>> resourceGroupName() {
        return Optional.ofNullable(this.resourceGroupName);
    }

    /**
     * Whether Role Based Access Control for the Kubernetes Cluster should be enabled. Defaults to `true`. Changing this forces a new resource to be created.
     * 
     */
    @Import(name="roleBasedAccessControlEnabled")
    private @Nullable Output<Boolean> roleBasedAccessControlEnabled;

    /**
     * @return Whether Role Based Access Control for the Kubernetes Cluster should be enabled. Defaults to `true`. Changing this forces a new resource to be created.
     * 
     */
    public Optional<Output<Boolean>> roleBasedAccessControlEnabled() {
        return Optional.ofNullable(this.roleBasedAccessControlEnabled);
    }

    /**
     * Whether to enable run command for the cluster or not. Defaults to `true`.
     * 
     */
    @Import(name="runCommandEnabled")
    private @Nullable Output<Boolean> runCommandEnabled;

    /**
     * @return Whether to enable run command for the cluster or not. Defaults to `true`.
     * 
     */
    public Optional<Output<Boolean>> runCommandEnabled() {
        return Optional.ofNullable(this.runCommandEnabled);
    }

    /**
     * A `service_mesh_profile` block as defined below.
     * 
     */
    @Import(name="serviceMeshProfile")
    private @Nullable Output<KubernetesClusterServiceMeshProfileArgs> serviceMeshProfile;

    /**
     * @return A `service_mesh_profile` block as defined below.
     * 
     */
    public Optional<Output<KubernetesClusterServiceMeshProfileArgs>> serviceMeshProfile() {
        return Optional.ofNullable(this.serviceMeshProfile);
    }

    /**
     * A `service_principal` block as documented below. One of either `identity` or `service_principal` must be specified.
     * 
     * !&gt; **Note:** A migration scenario from `service_principal` to `identity` is supported. When upgrading `service_principal` to `identity`, your cluster&#39;s control plane and addon pods will switch to use managed identity, but the kubelets will keep using your configured `service_principal` until you upgrade your Node Pool.
     * 
     */
    @Import(name="servicePrincipal")
    private @Nullable Output<KubernetesClusterServicePrincipalArgs> servicePrincipal;

    /**
     * @return A `service_principal` block as documented below. One of either `identity` or `service_principal` must be specified.
     * 
     * !&gt; **Note:** A migration scenario from `service_principal` to `identity` is supported. When upgrading `service_principal` to `identity`, your cluster&#39;s control plane and addon pods will switch to use managed identity, but the kubelets will keep using your configured `service_principal` until you upgrade your Node Pool.
     * 
     */
    public Optional<Output<KubernetesClusterServicePrincipalArgs>> servicePrincipal() {
        return Optional.ofNullable(this.servicePrincipal);
    }

    /**
     * The SKU Tier that should be used for this Kubernetes Cluster. Possible values are `Free`, `Standard` (which includes the Uptime SLA) and `Premium`. Defaults to `Free`.
     * 
     * &gt; **Note:** Whilst the AKS API previously supported the `Paid` SKU - the AKS API introduced a breaking change in API Version `2023-02-01` (used in v3.51.0 and later) where the value `Paid` must now be set to `Standard`.
     * 
     */
    @Import(name="skuTier")
    private @Nullable Output<String> skuTier;

    /**
     * @return The SKU Tier that should be used for this Kubernetes Cluster. Possible values are `Free`, `Standard` (which includes the Uptime SLA) and `Premium`. Defaults to `Free`.
     * 
     * &gt; **Note:** Whilst the AKS API previously supported the `Paid` SKU - the AKS API introduced a breaking change in API Version `2023-02-01` (used in v3.51.0 and later) where the value `Paid` must now be set to `Standard`.
     * 
     */
    public Optional<Output<String>> skuTier() {
        return Optional.ofNullable(this.skuTier);
    }

    /**
     * A `storage_profile` block as defined below.
     * 
     */
    @Import(name="storageProfile")
    private @Nullable Output<KubernetesClusterStorageProfileArgs> storageProfile;

    /**
     * @return A `storage_profile` block as defined below.
     * 
     */
    public Optional<Output<KubernetesClusterStorageProfileArgs>> storageProfile() {
        return Optional.ofNullable(this.storageProfile);
    }

    /**
     * Specifies the support plan which should be used for this Kubernetes Cluster. Possible values are `KubernetesOfficial` and `AKSLongTermSupport`. Defaults to `KubernetesOfficial`.
     * 
     */
    @Import(name="supportPlan")
    private @Nullable Output<String> supportPlan;

    /**
     * @return Specifies the support plan which should be used for this Kubernetes Cluster. Possible values are `KubernetesOfficial` and `AKSLongTermSupport`. Defaults to `KubernetesOfficial`.
     * 
     */
    public Optional<Output<String>> supportPlan() {
        return Optional.ofNullable(this.supportPlan);
    }

    /**
     * A mapping of tags to assign to the resource.
     * 
     */
    @Import(name="tags")
    private @Nullable Output<Map<String,String>> tags;

    /**
     * @return A mapping of tags to assign to the resource.
     * 
     */
    public Optional<Output<Map<String,String>>> tags() {
        return Optional.ofNullable(this.tags);
    }

    /**
     * A `upgrade_override` block as defined below.
     * 
     */
    @Import(name="upgradeOverride")
    private @Nullable Output<KubernetesClusterUpgradeOverrideArgs> upgradeOverride;

    /**
     * @return A `upgrade_override` block as defined below.
     * 
     */
    public Optional<Output<KubernetesClusterUpgradeOverrideArgs>> upgradeOverride() {
        return Optional.ofNullable(this.upgradeOverride);
    }

    /**
     * A `web_app_routing` block as defined below.
     * 
     */
    @Import(name="webAppRouting")
    private @Nullable Output<KubernetesClusterWebAppRoutingArgs> webAppRouting;

    /**
     * @return A `web_app_routing` block as defined below.
     * 
     */
    public Optional<Output<KubernetesClusterWebAppRoutingArgs>> webAppRouting() {
        return Optional.ofNullable(this.webAppRouting);
    }

    /**
     * A `windows_profile` block as defined below.
     * 
     */
    @Import(name="windowsProfile")
    private @Nullable Output<KubernetesClusterWindowsProfileArgs> windowsProfile;

    /**
     * @return A `windows_profile` block as defined below.
     * 
     */
    public Optional<Output<KubernetesClusterWindowsProfileArgs>> windowsProfile() {
        return Optional.ofNullable(this.windowsProfile);
    }

    /**
     * A `workload_autoscaler_profile` block defined below.
     * 
     */
    @Import(name="workloadAutoscalerProfile")
    private @Nullable Output<KubernetesClusterWorkloadAutoscalerProfileArgs> workloadAutoscalerProfile;

    /**
     * @return A `workload_autoscaler_profile` block defined below.
     * 
     */
    public Optional<Output<KubernetesClusterWorkloadAutoscalerProfileArgs>> workloadAutoscalerProfile() {
        return Optional.ofNullable(this.workloadAutoscalerProfile);
    }

    /**
     * Specifies whether Azure AD Workload Identity should be enabled for the Cluster. Defaults to `false`.
     * 
     * &gt; **Note:** To enable Azure AD Workload Identity `oidc_issuer_enabled` must be set to `true`.
     * 
     * &gt; **Note:** Enabling this option will allocate Workload Identity resources to the `kube-system` namespace in Kubernetes. If you wish to customize the deployment of Workload Identity, you can refer to [the documentation on Azure AD Workload Identity.](https://azure.github.io/azure-workload-identity/docs/installation/mutating-admission-webhook.html) The documentation provides guidance on how to install the mutating admission webhook, which allows for the customization of Workload Identity deployment.
     * 
     */
    @Import(name="workloadIdentityEnabled")
    private @Nullable Output<Boolean> workloadIdentityEnabled;

    /**
     * @return Specifies whether Azure AD Workload Identity should be enabled for the Cluster. Defaults to `false`.
     * 
     * &gt; **Note:** To enable Azure AD Workload Identity `oidc_issuer_enabled` must be set to `true`.
     * 
     * &gt; **Note:** Enabling this option will allocate Workload Identity resources to the `kube-system` namespace in Kubernetes. If you wish to customize the deployment of Workload Identity, you can refer to [the documentation on Azure AD Workload Identity.](https://azure.github.io/azure-workload-identity/docs/installation/mutating-admission-webhook.html) The documentation provides guidance on how to install the mutating admission webhook, which allows for the customization of Workload Identity deployment.
     * 
     */
    public Optional<Output<Boolean>> workloadIdentityEnabled() {
        return Optional.ofNullable(this.workloadIdentityEnabled);
    }

    private KubernetesClusterState() {}

    private KubernetesClusterState(KubernetesClusterState $) {
        this.aciConnectorLinux = $.aciConnectorLinux;
        this.apiServerAccessProfile = $.apiServerAccessProfile;
        this.autoScalerProfile = $.autoScalerProfile;
        this.automaticUpgradeChannel = $.automaticUpgradeChannel;
        this.azureActiveDirectoryRoleBasedAccessControl = $.azureActiveDirectoryRoleBasedAccessControl;
        this.azurePolicyEnabled = $.azurePolicyEnabled;
        this.confidentialComputing = $.confidentialComputing;
        this.costAnalysisEnabled = $.costAnalysisEnabled;
        this.currentKubernetesVersion = $.currentKubernetesVersion;
        this.defaultNodePool = $.defaultNodePool;
        this.diskEncryptionSetId = $.diskEncryptionSetId;
        this.dnsPrefix = $.dnsPrefix;
        this.dnsPrefixPrivateCluster = $.dnsPrefixPrivateCluster;
        this.edgeZone = $.edgeZone;
        this.fqdn = $.fqdn;
        this.httpApplicationRoutingEnabled = $.httpApplicationRoutingEnabled;
        this.httpApplicationRoutingZoneName = $.httpApplicationRoutingZoneName;
        this.httpProxyConfig = $.httpProxyConfig;
        this.identity = $.identity;
        this.imageCleanerEnabled = $.imageCleanerEnabled;
        this.imageCleanerIntervalHours = $.imageCleanerIntervalHours;
        this.ingressApplicationGateway = $.ingressApplicationGateway;
        this.keyManagementService = $.keyManagementService;
        this.keyVaultSecretsProvider = $.keyVaultSecretsProvider;
        this.kubeAdminConfigRaw = $.kubeAdminConfigRaw;
        this.kubeAdminConfigs = $.kubeAdminConfigs;
        this.kubeConfigRaw = $.kubeConfigRaw;
        this.kubeConfigs = $.kubeConfigs;
        this.kubeletIdentity = $.kubeletIdentity;
        this.kubernetesVersion = $.kubernetesVersion;
        this.linuxProfile = $.linuxProfile;
        this.localAccountDisabled = $.localAccountDisabled;
        this.location = $.location;
        this.maintenanceWindow = $.maintenanceWindow;
        this.maintenanceWindowAutoUpgrade = $.maintenanceWindowAutoUpgrade;
        this.maintenanceWindowNodeOs = $.maintenanceWindowNodeOs;
        this.microsoftDefender = $.microsoftDefender;
        this.monitorMetrics = $.monitorMetrics;
        this.name = $.name;
        this.networkProfile = $.networkProfile;
        this.nodeOsUpgradeChannel = $.nodeOsUpgradeChannel;
        this.nodeResourceGroup = $.nodeResourceGroup;
        this.nodeResourceGroupId = $.nodeResourceGroupId;
        this.oidcIssuerEnabled = $.oidcIssuerEnabled;
        this.oidcIssuerUrl = $.oidcIssuerUrl;
        this.omsAgent = $.omsAgent;
        this.openServiceMeshEnabled = $.openServiceMeshEnabled;
        this.portalFqdn = $.portalFqdn;
        this.privateClusterEnabled = $.privateClusterEnabled;
        this.privateClusterPublicFqdnEnabled = $.privateClusterPublicFqdnEnabled;
        this.privateDnsZoneId = $.privateDnsZoneId;
        this.privateFqdn = $.privateFqdn;
        this.resourceGroupName = $.resourceGroupName;
        this.roleBasedAccessControlEnabled = $.roleBasedAccessControlEnabled;
        this.runCommandEnabled = $.runCommandEnabled;
        this.serviceMeshProfile = $.serviceMeshProfile;
        this.servicePrincipal = $.servicePrincipal;
        this.skuTier = $.skuTier;
        this.storageProfile = $.storageProfile;
        this.supportPlan = $.supportPlan;
        this.tags = $.tags;
        this.upgradeOverride = $.upgradeOverride;
        this.webAppRouting = $.webAppRouting;
        this.windowsProfile = $.windowsProfile;
        this.workloadAutoscalerProfile = $.workloadAutoscalerProfile;
        this.workloadIdentityEnabled = $.workloadIdentityEnabled;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(KubernetesClusterState defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private KubernetesClusterState $;

        public Builder() {
            $ = new KubernetesClusterState();
        }

        public Builder(KubernetesClusterState defaults) {
            $ = new KubernetesClusterState(Objects.requireNonNull(defaults));
        }

        /**
         * @param aciConnectorLinux A `aci_connector_linux` block as defined below. For more details, please visit [Create and configure an AKS cluster to use virtual nodes](https://docs.microsoft.com/azure/aks/virtual-nodes-portal).
         * 
         * @return builder
         * 
         */
        public Builder aciConnectorLinux(@Nullable Output<KubernetesClusterAciConnectorLinuxArgs> aciConnectorLinux) {
            $.aciConnectorLinux = aciConnectorLinux;
            return this;
        }

        /**
         * @param aciConnectorLinux A `aci_connector_linux` block as defined below. For more details, please visit [Create and configure an AKS cluster to use virtual nodes](https://docs.microsoft.com/azure/aks/virtual-nodes-portal).
         * 
         * @return builder
         * 
         */
        public Builder aciConnectorLinux(KubernetesClusterAciConnectorLinuxArgs aciConnectorLinux) {
            return aciConnectorLinux(Output.of(aciConnectorLinux));
        }

        /**
         * @param apiServerAccessProfile An `api_server_access_profile` block as defined below.
         * 
         * @return builder
         * 
         */
        public Builder apiServerAccessProfile(@Nullable Output<KubernetesClusterApiServerAccessProfileArgs> apiServerAccessProfile) {
            $.apiServerAccessProfile = apiServerAccessProfile;
            return this;
        }

        /**
         * @param apiServerAccessProfile An `api_server_access_profile` block as defined below.
         * 
         * @return builder
         * 
         */
        public Builder apiServerAccessProfile(KubernetesClusterApiServerAccessProfileArgs apiServerAccessProfile) {
            return apiServerAccessProfile(Output.of(apiServerAccessProfile));
        }

        /**
         * @param autoScalerProfile A `auto_scaler_profile` block as defined below.
         * 
         * @return builder
         * 
         */
        public Builder autoScalerProfile(@Nullable Output<KubernetesClusterAutoScalerProfileArgs> autoScalerProfile) {
            $.autoScalerProfile = autoScalerProfile;
            return this;
        }

        /**
         * @param autoScalerProfile A `auto_scaler_profile` block as defined below.
         * 
         * @return builder
         * 
         */
        public Builder autoScalerProfile(KubernetesClusterAutoScalerProfileArgs autoScalerProfile) {
            return autoScalerProfile(Output.of(autoScalerProfile));
        }

        /**
         * @param automaticUpgradeChannel The upgrade channel for this Kubernetes Cluster. Possible values are `patch`, `rapid`, `node-image` and `stable`. Omitting this field sets this value to `none`.
         * 
         * !&gt; **Note:** Cluster Auto-Upgrade will update the Kubernetes Cluster (and its Node Pools) to the latest GA version of Kubernetes automatically - please [see the Azure documentation for more information](https://docs.microsoft.com/azure/aks/upgrade-cluster#set-auto-upgrade-channel).
         * 
         * &gt; **Note:** Cluster Auto-Upgrade only updates to GA versions of Kubernetes and will not update to Preview versions.
         * 
         * @return builder
         * 
         */
        public Builder automaticUpgradeChannel(@Nullable Output<String> automaticUpgradeChannel) {
            $.automaticUpgradeChannel = automaticUpgradeChannel;
            return this;
        }

        /**
         * @param automaticUpgradeChannel The upgrade channel for this Kubernetes Cluster. Possible values are `patch`, `rapid`, `node-image` and `stable`. Omitting this field sets this value to `none`.
         * 
         * !&gt; **Note:** Cluster Auto-Upgrade will update the Kubernetes Cluster (and its Node Pools) to the latest GA version of Kubernetes automatically - please [see the Azure documentation for more information](https://docs.microsoft.com/azure/aks/upgrade-cluster#set-auto-upgrade-channel).
         * 
         * &gt; **Note:** Cluster Auto-Upgrade only updates to GA versions of Kubernetes and will not update to Preview versions.
         * 
         * @return builder
         * 
         */
        public Builder automaticUpgradeChannel(String automaticUpgradeChannel) {
            return automaticUpgradeChannel(Output.of(automaticUpgradeChannel));
        }

        /**
         * @param azureActiveDirectoryRoleBasedAccessControl A `azure_active_directory_role_based_access_control` block as defined below.
         * 
         * @return builder
         * 
         */
        public Builder azureActiveDirectoryRoleBasedAccessControl(@Nullable Output<KubernetesClusterAzureActiveDirectoryRoleBasedAccessControlArgs> azureActiveDirectoryRoleBasedAccessControl) {
            $.azureActiveDirectoryRoleBasedAccessControl = azureActiveDirectoryRoleBasedAccessControl;
            return this;
        }

        /**
         * @param azureActiveDirectoryRoleBasedAccessControl A `azure_active_directory_role_based_access_control` block as defined below.
         * 
         * @return builder
         * 
         */
        public Builder azureActiveDirectoryRoleBasedAccessControl(KubernetesClusterAzureActiveDirectoryRoleBasedAccessControlArgs azureActiveDirectoryRoleBasedAccessControl) {
            return azureActiveDirectoryRoleBasedAccessControl(Output.of(azureActiveDirectoryRoleBasedAccessControl));
        }

        /**
         * @param azurePolicyEnabled Should the Azure Policy Add-On be enabled? For more details please visit [Understand Azure Policy for Azure Kubernetes Service](https://docs.microsoft.com/en-ie/azure/governance/policy/concepts/rego-for-aks)
         * 
         * @return builder
         * 
         */
        public Builder azurePolicyEnabled(@Nullable Output<Boolean> azurePolicyEnabled) {
            $.azurePolicyEnabled = azurePolicyEnabled;
            return this;
        }

        /**
         * @param azurePolicyEnabled Should the Azure Policy Add-On be enabled? For more details please visit [Understand Azure Policy for Azure Kubernetes Service](https://docs.microsoft.com/en-ie/azure/governance/policy/concepts/rego-for-aks)
         * 
         * @return builder
         * 
         */
        public Builder azurePolicyEnabled(Boolean azurePolicyEnabled) {
            return azurePolicyEnabled(Output.of(azurePolicyEnabled));
        }

        /**
         * @param confidentialComputing A `confidential_computing` block as defined below. For more details please [the documentation](https://learn.microsoft.com/en-us/azure/confidential-computing/confidential-nodes-aks-overview)
         * 
         * @return builder
         * 
         */
        public Builder confidentialComputing(@Nullable Output<KubernetesClusterConfidentialComputingArgs> confidentialComputing) {
            $.confidentialComputing = confidentialComputing;
            return this;
        }

        /**
         * @param confidentialComputing A `confidential_computing` block as defined below. For more details please [the documentation](https://learn.microsoft.com/en-us/azure/confidential-computing/confidential-nodes-aks-overview)
         * 
         * @return builder
         * 
         */
        public Builder confidentialComputing(KubernetesClusterConfidentialComputingArgs confidentialComputing) {
            return confidentialComputing(Output.of(confidentialComputing));
        }

        /**
         * @param costAnalysisEnabled Should cost analysis be enabled for this Kubernetes Cluster? Defaults to `false`. The `sku_tier` must be set to `Standard` or `Premium` to enable this feature. Enabling this will add Kubernetes Namespace and Deployment details to the Cost Analysis views in the Azure portal.
         * 
         * @return builder
         * 
         */
        public Builder costAnalysisEnabled(@Nullable Output<Boolean> costAnalysisEnabled) {
            $.costAnalysisEnabled = costAnalysisEnabled;
            return this;
        }

        /**
         * @param costAnalysisEnabled Should cost analysis be enabled for this Kubernetes Cluster? Defaults to `false`. The `sku_tier` must be set to `Standard` or `Premium` to enable this feature. Enabling this will add Kubernetes Namespace and Deployment details to the Cost Analysis views in the Azure portal.
         * 
         * @return builder
         * 
         */
        public Builder costAnalysisEnabled(Boolean costAnalysisEnabled) {
            return costAnalysisEnabled(Output.of(costAnalysisEnabled));
        }

        /**
         * @param currentKubernetesVersion The current version running on the Azure Kubernetes Managed Cluster.
         * 
         * @return builder
         * 
         */
        public Builder currentKubernetesVersion(@Nullable Output<String> currentKubernetesVersion) {
            $.currentKubernetesVersion = currentKubernetesVersion;
            return this;
        }

        /**
         * @param currentKubernetesVersion The current version running on the Azure Kubernetes Managed Cluster.
         * 
         * @return builder
         * 
         */
        public Builder currentKubernetesVersion(String currentKubernetesVersion) {
            return currentKubernetesVersion(Output.of(currentKubernetesVersion));
        }

        /**
         * @param defaultNodePool Specifies configuration for &#34;System&#34; mode node pool. A `default_node_pool` block as defined below.
         * 
         * @return builder
         * 
         */
        public Builder defaultNodePool(@Nullable Output<KubernetesClusterDefaultNodePoolArgs> defaultNodePool) {
            $.defaultNodePool = defaultNodePool;
            return this;
        }

        /**
         * @param defaultNodePool Specifies configuration for &#34;System&#34; mode node pool. A `default_node_pool` block as defined below.
         * 
         * @return builder
         * 
         */
        public Builder defaultNodePool(KubernetesClusterDefaultNodePoolArgs defaultNodePool) {
            return defaultNodePool(Output.of(defaultNodePool));
        }

        /**
         * @param diskEncryptionSetId The ID of the Disk Encryption Set which should be used for the Nodes and Volumes. More information [can be found in the documentation](https://docs.microsoft.com/azure/aks/azure-disk-customer-managed-keys). Changing this forces a new resource to be created.
         * 
         * @return builder
         * 
         */
        public Builder diskEncryptionSetId(@Nullable Output<String> diskEncryptionSetId) {
            $.diskEncryptionSetId = diskEncryptionSetId;
            return this;
        }

        /**
         * @param diskEncryptionSetId The ID of the Disk Encryption Set which should be used for the Nodes and Volumes. More information [can be found in the documentation](https://docs.microsoft.com/azure/aks/azure-disk-customer-managed-keys). Changing this forces a new resource to be created.
         * 
         * @return builder
         * 
         */
        public Builder diskEncryptionSetId(String diskEncryptionSetId) {
            return diskEncryptionSetId(Output.of(diskEncryptionSetId));
        }

        /**
         * @param dnsPrefix DNS prefix specified when creating the managed cluster. Possible values must begin and end with a letter or number, contain only letters, numbers, and hyphens and be between 1 and 54 characters in length. Changing this forces a new resource to be created.
         * 
         * @return builder
         * 
         */
        public Builder dnsPrefix(@Nullable Output<String> dnsPrefix) {
            $.dnsPrefix = dnsPrefix;
            return this;
        }

        /**
         * @param dnsPrefix DNS prefix specified when creating the managed cluster. Possible values must begin and end with a letter or number, contain only letters, numbers, and hyphens and be between 1 and 54 characters in length. Changing this forces a new resource to be created.
         * 
         * @return builder
         * 
         */
        public Builder dnsPrefix(String dnsPrefix) {
            return dnsPrefix(Output.of(dnsPrefix));
        }

        /**
         * @param dnsPrefixPrivateCluster Specifies the DNS prefix to use with private clusters. Changing this forces a new resource to be created.
         * 
         * &gt; **Note:** You must define either a `dns_prefix` or a `dns_prefix_private_cluster` field.
         * 
         * In addition, one of either `identity` or `service_principal` blocks must be specified.
         * 
         * @return builder
         * 
         */
        public Builder dnsPrefixPrivateCluster(@Nullable Output<String> dnsPrefixPrivateCluster) {
            $.dnsPrefixPrivateCluster = dnsPrefixPrivateCluster;
            return this;
        }

        /**
         * @param dnsPrefixPrivateCluster Specifies the DNS prefix to use with private clusters. Changing this forces a new resource to be created.
         * 
         * &gt; **Note:** You must define either a `dns_prefix` or a `dns_prefix_private_cluster` field.
         * 
         * In addition, one of either `identity` or `service_principal` blocks must be specified.
         * 
         * @return builder
         * 
         */
        public Builder dnsPrefixPrivateCluster(String dnsPrefixPrivateCluster) {
            return dnsPrefixPrivateCluster(Output.of(dnsPrefixPrivateCluster));
        }

        /**
         * @param edgeZone Specifies the Extended Zone (formerly called Edge Zone) within the Azure Region where this Managed Kubernetes Cluster should exist. Changing this forces a new resource to be created.
         * 
         * @return builder
         * 
         */
        public Builder edgeZone(@Nullable Output<String> edgeZone) {
            $.edgeZone = edgeZone;
            return this;
        }

        /**
         * @param edgeZone Specifies the Extended Zone (formerly called Edge Zone) within the Azure Region where this Managed Kubernetes Cluster should exist. Changing this forces a new resource to be created.
         * 
         * @return builder
         * 
         */
        public Builder edgeZone(String edgeZone) {
            return edgeZone(Output.of(edgeZone));
        }

        /**
         * @param fqdn The FQDN of the Azure Kubernetes Managed Cluster.
         * 
         * @return builder
         * 
         */
        public Builder fqdn(@Nullable Output<String> fqdn) {
            $.fqdn = fqdn;
            return this;
        }

        /**
         * @param fqdn The FQDN of the Azure Kubernetes Managed Cluster.
         * 
         * @return builder
         * 
         */
        public Builder fqdn(String fqdn) {
            return fqdn(Output.of(fqdn));
        }

        /**
         * @param httpApplicationRoutingEnabled Should HTTP Application Routing be enabled?
         * 
         * &gt; **Note:** At this time HTTP Application Routing is not supported in Azure China or Azure US Government.
         * 
         * @return builder
         * 
         */
        public Builder httpApplicationRoutingEnabled(@Nullable Output<Boolean> httpApplicationRoutingEnabled) {
            $.httpApplicationRoutingEnabled = httpApplicationRoutingEnabled;
            return this;
        }

        /**
         * @param httpApplicationRoutingEnabled Should HTTP Application Routing be enabled?
         * 
         * &gt; **Note:** At this time HTTP Application Routing is not supported in Azure China or Azure US Government.
         * 
         * @return builder
         * 
         */
        public Builder httpApplicationRoutingEnabled(Boolean httpApplicationRoutingEnabled) {
            return httpApplicationRoutingEnabled(Output.of(httpApplicationRoutingEnabled));
        }

        /**
         * @param httpApplicationRoutingZoneName The Zone Name of the HTTP Application Routing.
         * 
         * @return builder
         * 
         */
        public Builder httpApplicationRoutingZoneName(@Nullable Output<String> httpApplicationRoutingZoneName) {
            $.httpApplicationRoutingZoneName = httpApplicationRoutingZoneName;
            return this;
        }

        /**
         * @param httpApplicationRoutingZoneName The Zone Name of the HTTP Application Routing.
         * 
         * @return builder
         * 
         */
        public Builder httpApplicationRoutingZoneName(String httpApplicationRoutingZoneName) {
            return httpApplicationRoutingZoneName(Output.of(httpApplicationRoutingZoneName));
        }

        /**
         * @param httpProxyConfig A `http_proxy_config` block as defined below.
         * 
         * @return builder
         * 
         */
        public Builder httpProxyConfig(@Nullable Output<KubernetesClusterHttpProxyConfigArgs> httpProxyConfig) {
            $.httpProxyConfig = httpProxyConfig;
            return this;
        }

        /**
         * @param httpProxyConfig A `http_proxy_config` block as defined below.
         * 
         * @return builder
         * 
         */
        public Builder httpProxyConfig(KubernetesClusterHttpProxyConfigArgs httpProxyConfig) {
            return httpProxyConfig(Output.of(httpProxyConfig));
        }

        /**
         * @param identity An `identity` block as defined below. One of either `identity` or `service_principal` must be specified.
         * 
         * !&gt; **Note:** A migration scenario from `service_principal` to `identity` is supported. When upgrading `service_principal` to `identity`, your cluster&#39;s control plane and addon pods will switch to use managed identity, but the kubelets will keep using your configured `service_principal` until you upgrade your Node Pool.
         * 
         * @return builder
         * 
         */
        public Builder identity(@Nullable Output<KubernetesClusterIdentityArgs> identity) {
            $.identity = identity;
            return this;
        }

        /**
         * @param identity An `identity` block as defined below. One of either `identity` or `service_principal` must be specified.
         * 
         * !&gt; **Note:** A migration scenario from `service_principal` to `identity` is supported. When upgrading `service_principal` to `identity`, your cluster&#39;s control plane and addon pods will switch to use managed identity, but the kubelets will keep using your configured `service_principal` until you upgrade your Node Pool.
         * 
         * @return builder
         * 
         */
        public Builder identity(KubernetesClusterIdentityArgs identity) {
            return identity(Output.of(identity));
        }

        /**
         * @param imageCleanerEnabled Specifies whether Image Cleaner is enabled.
         * 
         * @return builder
         * 
         */
        public Builder imageCleanerEnabled(@Nullable Output<Boolean> imageCleanerEnabled) {
            $.imageCleanerEnabled = imageCleanerEnabled;
            return this;
        }

        /**
         * @param imageCleanerEnabled Specifies whether Image Cleaner is enabled.
         * 
         * @return builder
         * 
         */
        public Builder imageCleanerEnabled(Boolean imageCleanerEnabled) {
            return imageCleanerEnabled(Output.of(imageCleanerEnabled));
        }

        /**
         * @param imageCleanerIntervalHours Specifies the interval in hours when images should be cleaned up. Defaults to `0`.
         * 
         * @return builder
         * 
         */
        public Builder imageCleanerIntervalHours(@Nullable Output<Integer> imageCleanerIntervalHours) {
            $.imageCleanerIntervalHours = imageCleanerIntervalHours;
            return this;
        }

        /**
         * @param imageCleanerIntervalHours Specifies the interval in hours when images should be cleaned up. Defaults to `0`.
         * 
         * @return builder
         * 
         */
        public Builder imageCleanerIntervalHours(Integer imageCleanerIntervalHours) {
            return imageCleanerIntervalHours(Output.of(imageCleanerIntervalHours));
        }

        /**
         * @param ingressApplicationGateway A `ingress_application_gateway` block as defined below.
         * 
         * &gt; **Note:** Since the Application Gateway is deployed inside a Virtual Network, users (and Service Principals) that are operating the Application Gateway must have the `Microsoft.Network/virtualNetworks/subnets/join/action` permission on the Virtual Network or Subnet. For more details, please visit [Virtual Network Permission](https://learn.microsoft.com/en-us/azure/application-gateway/configuration-infrastructure#virtual-network-permission).
         * 
         * @return builder
         * 
         */
        public Builder ingressApplicationGateway(@Nullable Output<KubernetesClusterIngressApplicationGatewayArgs> ingressApplicationGateway) {
            $.ingressApplicationGateway = ingressApplicationGateway;
            return this;
        }

        /**
         * @param ingressApplicationGateway A `ingress_application_gateway` block as defined below.
         * 
         * &gt; **Note:** Since the Application Gateway is deployed inside a Virtual Network, users (and Service Principals) that are operating the Application Gateway must have the `Microsoft.Network/virtualNetworks/subnets/join/action` permission on the Virtual Network or Subnet. For more details, please visit [Virtual Network Permission](https://learn.microsoft.com/en-us/azure/application-gateway/configuration-infrastructure#virtual-network-permission).
         * 
         * @return builder
         * 
         */
        public Builder ingressApplicationGateway(KubernetesClusterIngressApplicationGatewayArgs ingressApplicationGateway) {
            return ingressApplicationGateway(Output.of(ingressApplicationGateway));
        }

        /**
         * @param keyManagementService A `key_management_service` block as defined below. For more details, please visit [Key Management Service (KMS) etcd encryption to an AKS cluster](https://learn.microsoft.com/en-us/azure/aks/use-kms-etcd-encryption).
         * 
         * @return builder
         * 
         */
        public Builder keyManagementService(@Nullable Output<KubernetesClusterKeyManagementServiceArgs> keyManagementService) {
            $.keyManagementService = keyManagementService;
            return this;
        }

        /**
         * @param keyManagementService A `key_management_service` block as defined below. For more details, please visit [Key Management Service (KMS) etcd encryption to an AKS cluster](https://learn.microsoft.com/en-us/azure/aks/use-kms-etcd-encryption).
         * 
         * @return builder
         * 
         */
        public Builder keyManagementService(KubernetesClusterKeyManagementServiceArgs keyManagementService) {
            return keyManagementService(Output.of(keyManagementService));
        }

        /**
         * @param keyVaultSecretsProvider A `key_vault_secrets_provider` block as defined below. For more details, please visit [Azure Keyvault Secrets Provider for AKS](https://docs.microsoft.com/azure/aks/csi-secrets-store-driver).
         * 
         * @return builder
         * 
         */
        public Builder keyVaultSecretsProvider(@Nullable Output<KubernetesClusterKeyVaultSecretsProviderArgs> keyVaultSecretsProvider) {
            $.keyVaultSecretsProvider = keyVaultSecretsProvider;
            return this;
        }

        /**
         * @param keyVaultSecretsProvider A `key_vault_secrets_provider` block as defined below. For more details, please visit [Azure Keyvault Secrets Provider for AKS](https://docs.microsoft.com/azure/aks/csi-secrets-store-driver).
         * 
         * @return builder
         * 
         */
        public Builder keyVaultSecretsProvider(KubernetesClusterKeyVaultSecretsProviderArgs keyVaultSecretsProvider) {
            return keyVaultSecretsProvider(Output.of(keyVaultSecretsProvider));
        }

        /**
         * @param kubeAdminConfigRaw Raw Kubernetes config for the admin account to be used by [kubectl](https://kubernetes.io/docs/reference/kubectl/overview/) and other compatible tools. This is only available when Role Based Access Control with Azure Active Directory is enabled and local accounts enabled.
         * 
         * @return builder
         * 
         */
        public Builder kubeAdminConfigRaw(@Nullable Output<String> kubeAdminConfigRaw) {
            $.kubeAdminConfigRaw = kubeAdminConfigRaw;
            return this;
        }

        /**
         * @param kubeAdminConfigRaw Raw Kubernetes config for the admin account to be used by [kubectl](https://kubernetes.io/docs/reference/kubectl/overview/) and other compatible tools. This is only available when Role Based Access Control with Azure Active Directory is enabled and local accounts enabled.
         * 
         * @return builder
         * 
         */
        public Builder kubeAdminConfigRaw(String kubeAdminConfigRaw) {
            return kubeAdminConfigRaw(Output.of(kubeAdminConfigRaw));
        }

        /**
         * @param kubeAdminConfigs A `kube_admin_config` block as defined below. This is only available when Role Based Access Control with Azure Active Directory is enabled and local accounts enabled.
         * 
         * @return builder
         * 
         */
        public Builder kubeAdminConfigs(@Nullable Output<List<KubernetesClusterKubeAdminConfigArgs>> kubeAdminConfigs) {
            $.kubeAdminConfigs = kubeAdminConfigs;
            return this;
        }

        /**
         * @param kubeAdminConfigs A `kube_admin_config` block as defined below. This is only available when Role Based Access Control with Azure Active Directory is enabled and local accounts enabled.
         * 
         * @return builder
         * 
         */
        public Builder kubeAdminConfigs(List<KubernetesClusterKubeAdminConfigArgs> kubeAdminConfigs) {
            return kubeAdminConfigs(Output.of(kubeAdminConfigs));
        }

        /**
         * @param kubeAdminConfigs A `kube_admin_config` block as defined below. This is only available when Role Based Access Control with Azure Active Directory is enabled and local accounts enabled.
         * 
         * @return builder
         * 
         */
        public Builder kubeAdminConfigs(KubernetesClusterKubeAdminConfigArgs... kubeAdminConfigs) {
            return kubeAdminConfigs(List.of(kubeAdminConfigs));
        }

        /**
         * @param kubeConfigRaw Raw Kubernetes config to be used by [kubectl](https://kubernetes.io/docs/reference/kubectl/overview/) and other compatible tools.
         * 
         * @return builder
         * 
         */
        public Builder kubeConfigRaw(@Nullable Output<String> kubeConfigRaw) {
            $.kubeConfigRaw = kubeConfigRaw;
            return this;
        }

        /**
         * @param kubeConfigRaw Raw Kubernetes config to be used by [kubectl](https://kubernetes.io/docs/reference/kubectl/overview/) and other compatible tools.
         * 
         * @return builder
         * 
         */
        public Builder kubeConfigRaw(String kubeConfigRaw) {
            return kubeConfigRaw(Output.of(kubeConfigRaw));
        }

        /**
         * @param kubeConfigs A `kube_config` block as defined below.
         * 
         * @return builder
         * 
         */
        public Builder kubeConfigs(@Nullable Output<List<KubernetesClusterKubeConfigArgs>> kubeConfigs) {
            $.kubeConfigs = kubeConfigs;
            return this;
        }

        /**
         * @param kubeConfigs A `kube_config` block as defined below.
         * 
         * @return builder
         * 
         */
        public Builder kubeConfigs(List<KubernetesClusterKubeConfigArgs> kubeConfigs) {
            return kubeConfigs(Output.of(kubeConfigs));
        }

        /**
         * @param kubeConfigs A `kube_config` block as defined below.
         * 
         * @return builder
         * 
         */
        public Builder kubeConfigs(KubernetesClusterKubeConfigArgs... kubeConfigs) {
            return kubeConfigs(List.of(kubeConfigs));
        }

        /**
         * @param kubeletIdentity A `kubelet_identity` block as defined below.
         * 
         * @return builder
         * 
         */
        public Builder kubeletIdentity(@Nullable Output<KubernetesClusterKubeletIdentityArgs> kubeletIdentity) {
            $.kubeletIdentity = kubeletIdentity;
            return this;
        }

        /**
         * @param kubeletIdentity A `kubelet_identity` block as defined below.
         * 
         * @return builder
         * 
         */
        public Builder kubeletIdentity(KubernetesClusterKubeletIdentityArgs kubeletIdentity) {
            return kubeletIdentity(Output.of(kubeletIdentity));
        }

        /**
         * @param kubernetesVersion Version of Kubernetes specified when creating the AKS managed cluster. If not specified, the latest recommended version will be used at provisioning time (but won&#39;t auto-upgrade). AKS does not require an exact patch version to be specified, minor version aliases such as `1.22` are also supported. - The minor version&#39;s latest GA patch is automatically chosen in that case. More details can be found in [the documentation](https://docs.microsoft.com/en-us/azure/aks/supported-kubernetes-versions?tabs=azure-cli#alias-minor-version).
         * 
         * &gt; **Note:** Upgrading your cluster may take up to 10 minutes per node.
         * 
         * @return builder
         * 
         */
        public Builder kubernetesVersion(@Nullable Output<String> kubernetesVersion) {
            $.kubernetesVersion = kubernetesVersion;
            return this;
        }

        /**
         * @param kubernetesVersion Version of Kubernetes specified when creating the AKS managed cluster. If not specified, the latest recommended version will be used at provisioning time (but won&#39;t auto-upgrade). AKS does not require an exact patch version to be specified, minor version aliases such as `1.22` are also supported. - The minor version&#39;s latest GA patch is automatically chosen in that case. More details can be found in [the documentation](https://docs.microsoft.com/en-us/azure/aks/supported-kubernetes-versions?tabs=azure-cli#alias-minor-version).
         * 
         * &gt; **Note:** Upgrading your cluster may take up to 10 minutes per node.
         * 
         * @return builder
         * 
         */
        public Builder kubernetesVersion(String kubernetesVersion) {
            return kubernetesVersion(Output.of(kubernetesVersion));
        }

        /**
         * @param linuxProfile A `linux_profile` block as defined below.
         * 
         * @return builder
         * 
         */
        public Builder linuxProfile(@Nullable Output<KubernetesClusterLinuxProfileArgs> linuxProfile) {
            $.linuxProfile = linuxProfile;
            return this;
        }

        /**
         * @param linuxProfile A `linux_profile` block as defined below.
         * 
         * @return builder
         * 
         */
        public Builder linuxProfile(KubernetesClusterLinuxProfileArgs linuxProfile) {
            return linuxProfile(Output.of(linuxProfile));
        }

        /**
         * @param localAccountDisabled If `true` local accounts will be disabled. See [the documentation](https://docs.microsoft.com/azure/aks/managed-aad#disable-local-accounts) for more information.
         * 
         * &gt; **Note:** If `local_account_disabled` is set to `true`, it is required to enable Kubernetes RBAC and AKS-managed Azure AD integration. See [the documentation](https://docs.microsoft.com/azure/aks/managed-aad#azure-ad-authentication-overview) for more information.
         * 
         * @return builder
         * 
         */
        public Builder localAccountDisabled(@Nullable Output<Boolean> localAccountDisabled) {
            $.localAccountDisabled = localAccountDisabled;
            return this;
        }

        /**
         * @param localAccountDisabled If `true` local accounts will be disabled. See [the documentation](https://docs.microsoft.com/azure/aks/managed-aad#disable-local-accounts) for more information.
         * 
         * &gt; **Note:** If `local_account_disabled` is set to `true`, it is required to enable Kubernetes RBAC and AKS-managed Azure AD integration. See [the documentation](https://docs.microsoft.com/azure/aks/managed-aad#azure-ad-authentication-overview) for more information.
         * 
         * @return builder
         * 
         */
        public Builder localAccountDisabled(Boolean localAccountDisabled) {
            return localAccountDisabled(Output.of(localAccountDisabled));
        }

        /**
         * @param location The location where the Managed Kubernetes Cluster should be created. Changing this forces a new resource to be created.
         * 
         * @return builder
         * 
         */
        public Builder location(@Nullable Output<String> location) {
            $.location = location;
            return this;
        }

        /**
         * @param location The location where the Managed Kubernetes Cluster should be created. Changing this forces a new resource to be created.
         * 
         * @return builder
         * 
         */
        public Builder location(String location) {
            return location(Output.of(location));
        }

        /**
         * @param maintenanceWindow A `maintenance_window` block as defined below.
         * 
         * @return builder
         * 
         */
        public Builder maintenanceWindow(@Nullable Output<KubernetesClusterMaintenanceWindowArgs> maintenanceWindow) {
            $.maintenanceWindow = maintenanceWindow;
            return this;
        }

        /**
         * @param maintenanceWindow A `maintenance_window` block as defined below.
         * 
         * @return builder
         * 
         */
        public Builder maintenanceWindow(KubernetesClusterMaintenanceWindowArgs maintenanceWindow) {
            return maintenanceWindow(Output.of(maintenanceWindow));
        }

        /**
         * @param maintenanceWindowAutoUpgrade A `maintenance_window_auto_upgrade` block as defined below.
         * 
         * @return builder
         * 
         */
        public Builder maintenanceWindowAutoUpgrade(@Nullable Output<KubernetesClusterMaintenanceWindowAutoUpgradeArgs> maintenanceWindowAutoUpgrade) {
            $.maintenanceWindowAutoUpgrade = maintenanceWindowAutoUpgrade;
            return this;
        }

        /**
         * @param maintenanceWindowAutoUpgrade A `maintenance_window_auto_upgrade` block as defined below.
         * 
         * @return builder
         * 
         */
        public Builder maintenanceWindowAutoUpgrade(KubernetesClusterMaintenanceWindowAutoUpgradeArgs maintenanceWindowAutoUpgrade) {
            return maintenanceWindowAutoUpgrade(Output.of(maintenanceWindowAutoUpgrade));
        }

        /**
         * @param maintenanceWindowNodeOs A `maintenance_window_node_os` block as defined below.
         * 
         * @return builder
         * 
         */
        public Builder maintenanceWindowNodeOs(@Nullable Output<KubernetesClusterMaintenanceWindowNodeOsArgs> maintenanceWindowNodeOs) {
            $.maintenanceWindowNodeOs = maintenanceWindowNodeOs;
            return this;
        }

        /**
         * @param maintenanceWindowNodeOs A `maintenance_window_node_os` block as defined below.
         * 
         * @return builder
         * 
         */
        public Builder maintenanceWindowNodeOs(KubernetesClusterMaintenanceWindowNodeOsArgs maintenanceWindowNodeOs) {
            return maintenanceWindowNodeOs(Output.of(maintenanceWindowNodeOs));
        }

        /**
         * @param microsoftDefender A `microsoft_defender` block as defined below.
         * 
         * @return builder
         * 
         */
        public Builder microsoftDefender(@Nullable Output<KubernetesClusterMicrosoftDefenderArgs> microsoftDefender) {
            $.microsoftDefender = microsoftDefender;
            return this;
        }

        /**
         * @param microsoftDefender A `microsoft_defender` block as defined below.
         * 
         * @return builder
         * 
         */
        public Builder microsoftDefender(KubernetesClusterMicrosoftDefenderArgs microsoftDefender) {
            return microsoftDefender(Output.of(microsoftDefender));
        }

        /**
         * @param monitorMetrics Specifies a Prometheus add-on profile for the Kubernetes Cluster. A `monitor_metrics` block as defined below.
         * 
         * &gt; **Note:** If deploying Managed Prometheus, the `monitor_metrics` properties are required to configure the cluster for metrics collection. If no value is needed, set properties to `null`.
         * 
         * @return builder
         * 
         */
        public Builder monitorMetrics(@Nullable Output<KubernetesClusterMonitorMetricsArgs> monitorMetrics) {
            $.monitorMetrics = monitorMetrics;
            return this;
        }

        /**
         * @param monitorMetrics Specifies a Prometheus add-on profile for the Kubernetes Cluster. A `monitor_metrics` block as defined below.
         * 
         * &gt; **Note:** If deploying Managed Prometheus, the `monitor_metrics` properties are required to configure the cluster for metrics collection. If no value is needed, set properties to `null`.
         * 
         * @return builder
         * 
         */
        public Builder monitorMetrics(KubernetesClusterMonitorMetricsArgs monitorMetrics) {
            return monitorMetrics(Output.of(monitorMetrics));
        }

        /**
         * @param name The name of the Managed Kubernetes Cluster to create. Changing this forces a new resource to be created.
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name The name of the Managed Kubernetes Cluster to create. Changing this forces a new resource to be created.
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param networkProfile A `network_profile` block as defined below. Changing this forces a new resource to be created.
         * 
         * &gt; **Note:** If `network_profile` is not defined, `kubenet` profile will be used by default.
         * 
         * @return builder
         * 
         */
        public Builder networkProfile(@Nullable Output<KubernetesClusterNetworkProfileArgs> networkProfile) {
            $.networkProfile = networkProfile;
            return this;
        }

        /**
         * @param networkProfile A `network_profile` block as defined below. Changing this forces a new resource to be created.
         * 
         * &gt; **Note:** If `network_profile` is not defined, `kubenet` profile will be used by default.
         * 
         * @return builder
         * 
         */
        public Builder networkProfile(KubernetesClusterNetworkProfileArgs networkProfile) {
            return networkProfile(Output.of(networkProfile));
        }

        /**
         * @param nodeOsUpgradeChannel The upgrade channel for this Kubernetes Cluster Nodes&#39; OS Image. Possible values are `Unmanaged`, `SecurityPatch`, `NodeImage` and `None`. Defaults to `NodeImage`.
         * 
         * &gt; **Note:** `node_os_upgrade_channel` must be set to `NodeImage` if `automatic_upgrade_channel` has been set to `node-image`
         * 
         * @return builder
         * 
         */
        public Builder nodeOsUpgradeChannel(@Nullable Output<String> nodeOsUpgradeChannel) {
            $.nodeOsUpgradeChannel = nodeOsUpgradeChannel;
            return this;
        }

        /**
         * @param nodeOsUpgradeChannel The upgrade channel for this Kubernetes Cluster Nodes&#39; OS Image. Possible values are `Unmanaged`, `SecurityPatch`, `NodeImage` and `None`. Defaults to `NodeImage`.
         * 
         * &gt; **Note:** `node_os_upgrade_channel` must be set to `NodeImage` if `automatic_upgrade_channel` has been set to `node-image`
         * 
         * @return builder
         * 
         */
        public Builder nodeOsUpgradeChannel(String nodeOsUpgradeChannel) {
            return nodeOsUpgradeChannel(Output.of(nodeOsUpgradeChannel));
        }

        /**
         * @param nodeResourceGroup The name of the Resource Group where the Kubernetes Nodes should exist. Changing this forces a new resource to be created.
         * 
         * &gt; **Note:** Azure requires that a new, non-existent Resource Group is used, as otherwise, the provisioning of the Kubernetes Service will fail.
         * 
         * @return builder
         * 
         */
        public Builder nodeResourceGroup(@Nullable Output<String> nodeResourceGroup) {
            $.nodeResourceGroup = nodeResourceGroup;
            return this;
        }

        /**
         * @param nodeResourceGroup The name of the Resource Group where the Kubernetes Nodes should exist. Changing this forces a new resource to be created.
         * 
         * &gt; **Note:** Azure requires that a new, non-existent Resource Group is used, as otherwise, the provisioning of the Kubernetes Service will fail.
         * 
         * @return builder
         * 
         */
        public Builder nodeResourceGroup(String nodeResourceGroup) {
            return nodeResourceGroup(Output.of(nodeResourceGroup));
        }

        /**
         * @param nodeResourceGroupId The ID of the Resource Group containing the resources for this Managed Kubernetes Cluster.
         * 
         * @return builder
         * 
         */
        public Builder nodeResourceGroupId(@Nullable Output<String> nodeResourceGroupId) {
            $.nodeResourceGroupId = nodeResourceGroupId;
            return this;
        }

        /**
         * @param nodeResourceGroupId The ID of the Resource Group containing the resources for this Managed Kubernetes Cluster.
         * 
         * @return builder
         * 
         */
        public Builder nodeResourceGroupId(String nodeResourceGroupId) {
            return nodeResourceGroupId(Output.of(nodeResourceGroupId));
        }

        /**
         * @param oidcIssuerEnabled Enable or Disable the [OIDC issuer URL](https://learn.microsoft.com/en-gb/azure/aks/use-oidc-issuer)
         * 
         * @return builder
         * 
         */
        public Builder oidcIssuerEnabled(@Nullable Output<Boolean> oidcIssuerEnabled) {
            $.oidcIssuerEnabled = oidcIssuerEnabled;
            return this;
        }

        /**
         * @param oidcIssuerEnabled Enable or Disable the [OIDC issuer URL](https://learn.microsoft.com/en-gb/azure/aks/use-oidc-issuer)
         * 
         * @return builder
         * 
         */
        public Builder oidcIssuerEnabled(Boolean oidcIssuerEnabled) {
            return oidcIssuerEnabled(Output.of(oidcIssuerEnabled));
        }

        /**
         * @param oidcIssuerUrl The OIDC issuer URL that is associated with the cluster.
         * 
         * @return builder
         * 
         */
        public Builder oidcIssuerUrl(@Nullable Output<String> oidcIssuerUrl) {
            $.oidcIssuerUrl = oidcIssuerUrl;
            return this;
        }

        /**
         * @param oidcIssuerUrl The OIDC issuer URL that is associated with the cluster.
         * 
         * @return builder
         * 
         */
        public Builder oidcIssuerUrl(String oidcIssuerUrl) {
            return oidcIssuerUrl(Output.of(oidcIssuerUrl));
        }

        /**
         * @param omsAgent A `oms_agent` block as defined below.
         * 
         * @return builder
         * 
         */
        public Builder omsAgent(@Nullable Output<KubernetesClusterOmsAgentArgs> omsAgent) {
            $.omsAgent = omsAgent;
            return this;
        }

        /**
         * @param omsAgent A `oms_agent` block as defined below.
         * 
         * @return builder
         * 
         */
        public Builder omsAgent(KubernetesClusterOmsAgentArgs omsAgent) {
            return omsAgent(Output.of(omsAgent));
        }

        /**
         * @param openServiceMeshEnabled Is Open Service Mesh enabled? For more details, please visit [Open Service Mesh for AKS](https://docs.microsoft.com/azure/aks/open-service-mesh-about).
         * 
         * @return builder
         * 
         */
        public Builder openServiceMeshEnabled(@Nullable Output<Boolean> openServiceMeshEnabled) {
            $.openServiceMeshEnabled = openServiceMeshEnabled;
            return this;
        }

        /**
         * @param openServiceMeshEnabled Is Open Service Mesh enabled? For more details, please visit [Open Service Mesh for AKS](https://docs.microsoft.com/azure/aks/open-service-mesh-about).
         * 
         * @return builder
         * 
         */
        public Builder openServiceMeshEnabled(Boolean openServiceMeshEnabled) {
            return openServiceMeshEnabled(Output.of(openServiceMeshEnabled));
        }

        /**
         * @param portalFqdn The FQDN for the Azure Portal resources when private link has been enabled, which is only resolvable inside the Virtual Network used by the Kubernetes Cluster.
         * 
         * @return builder
         * 
         */
        public Builder portalFqdn(@Nullable Output<String> portalFqdn) {
            $.portalFqdn = portalFqdn;
            return this;
        }

        /**
         * @param portalFqdn The FQDN for the Azure Portal resources when private link has been enabled, which is only resolvable inside the Virtual Network used by the Kubernetes Cluster.
         * 
         * @return builder
         * 
         */
        public Builder portalFqdn(String portalFqdn) {
            return portalFqdn(Output.of(portalFqdn));
        }

        /**
         * @param privateClusterEnabled Should this Kubernetes Cluster have its API server only exposed on internal IP addresses? This provides a Private IP Address for the Kubernetes API on the Virtual Network where the Kubernetes Cluster is located. Defaults to `false`. Changing this forces a new resource to be created.
         * 
         * @return builder
         * 
         */
        public Builder privateClusterEnabled(@Nullable Output<Boolean> privateClusterEnabled) {
            $.privateClusterEnabled = privateClusterEnabled;
            return this;
        }

        /**
         * @param privateClusterEnabled Should this Kubernetes Cluster have its API server only exposed on internal IP addresses? This provides a Private IP Address for the Kubernetes API on the Virtual Network where the Kubernetes Cluster is located. Defaults to `false`. Changing this forces a new resource to be created.
         * 
         * @return builder
         * 
         */
        public Builder privateClusterEnabled(Boolean privateClusterEnabled) {
            return privateClusterEnabled(Output.of(privateClusterEnabled));
        }

        /**
         * @param privateClusterPublicFqdnEnabled Specifies whether a Public FQDN for this Private Cluster should be added. Defaults to `false`.
         * 
         * &gt; **Note:** If you use BYO DNS Zone, the AKS cluster should either use a User Assigned Identity or a service principal (which is deprecated) with the `Private DNS Zone Contributor` role and access to this Private DNS Zone. If `UserAssigned` identity is used - to prevent improper resource order destruction - the cluster should depend on the role assignment, like in this example:
         * 
         * &lt;!--Start PulumiCodeChooser --&gt;
         * <pre>
         * {@code
         * package generated_program;
         * 
         * import com.pulumi.Context;
         * import com.pulumi.Pulumi;
         * import com.pulumi.core.Output;
         * import com.pulumi.azure.core.ResourceGroup;
         * import com.pulumi.azure.core.ResourceGroupArgs;
         * import com.pulumi.azure.privatedns.Zone;
         * import com.pulumi.azure.privatedns.ZoneArgs;
         * import com.pulumi.azure.authorization.UserAssignedIdentity;
         * import com.pulumi.azure.authorization.UserAssignedIdentityArgs;
         * import com.pulumi.azure.authorization.Assignment;
         * import com.pulumi.azure.authorization.AssignmentArgs;
         * import com.pulumi.azure.containerservice.KubernetesCluster;
         * import com.pulumi.azure.containerservice.KubernetesClusterArgs;
         * import com.pulumi.resources.CustomResourceOptions;
         * import java.util.List;
         * import java.util.ArrayList;
         * import java.util.Map;
         * import java.io.File;
         * import java.nio.file.Files;
         * import java.nio.file.Paths;
         * 
         * public class App {
         *     public static void main(String[] args) {
         *         Pulumi.run(App::stack);
         *     }
         * 
         *     public static void stack(Context ctx) {
         *         var example = new ResourceGroup("example", ResourceGroupArgs.builder()
         *             .name("example")
         *             .location("West Europe")
         *             .build());
         * 
         *         var exampleZone = new Zone("exampleZone", ZoneArgs.builder()
         *             .name("privatelink.eastus2.azmk8s.io")
         *             .resourceGroupName(example.name())
         *             .build());
         * 
         *         var exampleUserAssignedIdentity = new UserAssignedIdentity("exampleUserAssignedIdentity", UserAssignedIdentityArgs.builder()
         *             .name("aks-example-identity")
         *             .resourceGroupName(example.name())
         *             .location(example.location())
         *             .build());
         * 
         *         var exampleAssignment = new Assignment("exampleAssignment", AssignmentArgs.builder()
         *             .scope(exampleZone.id())
         *             .roleDefinitionName("Private DNS Zone Contributor")
         *             .principalId(exampleUserAssignedIdentity.principalId())
         *             .build());
         * 
         *         var exampleKubernetesCluster = new KubernetesCluster("exampleKubernetesCluster", KubernetesClusterArgs.builder()
         *             .name("aksexamplewithprivatednszone1")
         *             .location(example.location())
         *             .resourceGroupName(example.name())
         *             .dnsPrefix("aksexamplednsprefix1")
         *             .privateClusterEnabled(true)
         *             .privateDnsZoneId(exampleZone.id())
         *             .build(), CustomResourceOptions.builder()
         *                 .dependsOn(exampleAssignment)
         *                 .build());
         * 
         *     }
         * }
         * }
         * </pre>
         * &lt;!--End PulumiCodeChooser --&gt;
         * 
         * @return builder
         * 
         */
        public Builder privateClusterPublicFqdnEnabled(@Nullable Output<Boolean> privateClusterPublicFqdnEnabled) {
            $.privateClusterPublicFqdnEnabled = privateClusterPublicFqdnEnabled;
            return this;
        }

        /**
         * @param privateClusterPublicFqdnEnabled Specifies whether a Public FQDN for this Private Cluster should be added. Defaults to `false`.
         * 
         * &gt; **Note:** If you use BYO DNS Zone, the AKS cluster should either use a User Assigned Identity or a service principal (which is deprecated) with the `Private DNS Zone Contributor` role and access to this Private DNS Zone. If `UserAssigned` identity is used - to prevent improper resource order destruction - the cluster should depend on the role assignment, like in this example:
         * 
         * &lt;!--Start PulumiCodeChooser --&gt;
         * <pre>
         * {@code
         * package generated_program;
         * 
         * import com.pulumi.Context;
         * import com.pulumi.Pulumi;
         * import com.pulumi.core.Output;
         * import com.pulumi.azure.core.ResourceGroup;
         * import com.pulumi.azure.core.ResourceGroupArgs;
         * import com.pulumi.azure.privatedns.Zone;
         * import com.pulumi.azure.privatedns.ZoneArgs;
         * import com.pulumi.azure.authorization.UserAssignedIdentity;
         * import com.pulumi.azure.authorization.UserAssignedIdentityArgs;
         * import com.pulumi.azure.authorization.Assignment;
         * import com.pulumi.azure.authorization.AssignmentArgs;
         * import com.pulumi.azure.containerservice.KubernetesCluster;
         * import com.pulumi.azure.containerservice.KubernetesClusterArgs;
         * import com.pulumi.resources.CustomResourceOptions;
         * import java.util.List;
         * import java.util.ArrayList;
         * import java.util.Map;
         * import java.io.File;
         * import java.nio.file.Files;
         * import java.nio.file.Paths;
         * 
         * public class App {
         *     public static void main(String[] args) {
         *         Pulumi.run(App::stack);
         *     }
         * 
         *     public static void stack(Context ctx) {
         *         var example = new ResourceGroup("example", ResourceGroupArgs.builder()
         *             .name("example")
         *             .location("West Europe")
         *             .build());
         * 
         *         var exampleZone = new Zone("exampleZone", ZoneArgs.builder()
         *             .name("privatelink.eastus2.azmk8s.io")
         *             .resourceGroupName(example.name())
         *             .build());
         * 
         *         var exampleUserAssignedIdentity = new UserAssignedIdentity("exampleUserAssignedIdentity", UserAssignedIdentityArgs.builder()
         *             .name("aks-example-identity")
         *             .resourceGroupName(example.name())
         *             .location(example.location())
         *             .build());
         * 
         *         var exampleAssignment = new Assignment("exampleAssignment", AssignmentArgs.builder()
         *             .scope(exampleZone.id())
         *             .roleDefinitionName("Private DNS Zone Contributor")
         *             .principalId(exampleUserAssignedIdentity.principalId())
         *             .build());
         * 
         *         var exampleKubernetesCluster = new KubernetesCluster("exampleKubernetesCluster", KubernetesClusterArgs.builder()
         *             .name("aksexamplewithprivatednszone1")
         *             .location(example.location())
         *             .resourceGroupName(example.name())
         *             .dnsPrefix("aksexamplednsprefix1")
         *             .privateClusterEnabled(true)
         *             .privateDnsZoneId(exampleZone.id())
         *             .build(), CustomResourceOptions.builder()
         *                 .dependsOn(exampleAssignment)
         *                 .build());
         * 
         *     }
         * }
         * }
         * </pre>
         * &lt;!--End PulumiCodeChooser --&gt;
         * 
         * @return builder
         * 
         */
        public Builder privateClusterPublicFqdnEnabled(Boolean privateClusterPublicFqdnEnabled) {
            return privateClusterPublicFqdnEnabled(Output.of(privateClusterPublicFqdnEnabled));
        }

        /**
         * @param privateDnsZoneId Either the ID of Private DNS Zone which should be delegated to this Cluster, `System` to have AKS manage this or `None`. In case of `None` you will need to bring your own DNS server and set up resolving, otherwise, the cluster will have issues after provisioning. Changing this forces a new resource to be created.
         * 
         * @return builder
         * 
         */
        public Builder privateDnsZoneId(@Nullable Output<String> privateDnsZoneId) {
            $.privateDnsZoneId = privateDnsZoneId;
            return this;
        }

        /**
         * @param privateDnsZoneId Either the ID of Private DNS Zone which should be delegated to this Cluster, `System` to have AKS manage this or `None`. In case of `None` you will need to bring your own DNS server and set up resolving, otherwise, the cluster will have issues after provisioning. Changing this forces a new resource to be created.
         * 
         * @return builder
         * 
         */
        public Builder privateDnsZoneId(String privateDnsZoneId) {
            return privateDnsZoneId(Output.of(privateDnsZoneId));
        }

        /**
         * @param privateFqdn The FQDN for the Kubernetes Cluster when private link has been enabled, which is only resolvable inside the Virtual Network used by the Kubernetes Cluster.
         * 
         * @return builder
         * 
         */
        public Builder privateFqdn(@Nullable Output<String> privateFqdn) {
            $.privateFqdn = privateFqdn;
            return this;
        }

        /**
         * @param privateFqdn The FQDN for the Kubernetes Cluster when private link has been enabled, which is only resolvable inside the Virtual Network used by the Kubernetes Cluster.
         * 
         * @return builder
         * 
         */
        public Builder privateFqdn(String privateFqdn) {
            return privateFqdn(Output.of(privateFqdn));
        }

        /**
         * @param resourceGroupName Specifies the Resource Group where the Managed Kubernetes Cluster should exist. Changing this forces a new resource to be created.
         * 
         * @return builder
         * 
         */
        public Builder resourceGroupName(@Nullable Output<String> resourceGroupName) {
            $.resourceGroupName = resourceGroupName;
            return this;
        }

        /**
         * @param resourceGroupName Specifies the Resource Group where the Managed Kubernetes Cluster should exist. Changing this forces a new resource to be created.
         * 
         * @return builder
         * 
         */
        public Builder resourceGroupName(String resourceGroupName) {
            return resourceGroupName(Output.of(resourceGroupName));
        }

        /**
         * @param roleBasedAccessControlEnabled Whether Role Based Access Control for the Kubernetes Cluster should be enabled. Defaults to `true`. Changing this forces a new resource to be created.
         * 
         * @return builder
         * 
         */
        public Builder roleBasedAccessControlEnabled(@Nullable Output<Boolean> roleBasedAccessControlEnabled) {
            $.roleBasedAccessControlEnabled = roleBasedAccessControlEnabled;
            return this;
        }

        /**
         * @param roleBasedAccessControlEnabled Whether Role Based Access Control for the Kubernetes Cluster should be enabled. Defaults to `true`. Changing this forces a new resource to be created.
         * 
         * @return builder
         * 
         */
        public Builder roleBasedAccessControlEnabled(Boolean roleBasedAccessControlEnabled) {
            return roleBasedAccessControlEnabled(Output.of(roleBasedAccessControlEnabled));
        }

        /**
         * @param runCommandEnabled Whether to enable run command for the cluster or not. Defaults to `true`.
         * 
         * @return builder
         * 
         */
        public Builder runCommandEnabled(@Nullable Output<Boolean> runCommandEnabled) {
            $.runCommandEnabled = runCommandEnabled;
            return this;
        }

        /**
         * @param runCommandEnabled Whether to enable run command for the cluster or not. Defaults to `true`.
         * 
         * @return builder
         * 
         */
        public Builder runCommandEnabled(Boolean runCommandEnabled) {
            return runCommandEnabled(Output.of(runCommandEnabled));
        }

        /**
         * @param serviceMeshProfile A `service_mesh_profile` block as defined below.
         * 
         * @return builder
         * 
         */
        public Builder serviceMeshProfile(@Nullable Output<KubernetesClusterServiceMeshProfileArgs> serviceMeshProfile) {
            $.serviceMeshProfile = serviceMeshProfile;
            return this;
        }

        /**
         * @param serviceMeshProfile A `service_mesh_profile` block as defined below.
         * 
         * @return builder
         * 
         */
        public Builder serviceMeshProfile(KubernetesClusterServiceMeshProfileArgs serviceMeshProfile) {
            return serviceMeshProfile(Output.of(serviceMeshProfile));
        }

        /**
         * @param servicePrincipal A `service_principal` block as documented below. One of either `identity` or `service_principal` must be specified.
         * 
         * !&gt; **Note:** A migration scenario from `service_principal` to `identity` is supported. When upgrading `service_principal` to `identity`, your cluster&#39;s control plane and addon pods will switch to use managed identity, but the kubelets will keep using your configured `service_principal` until you upgrade your Node Pool.
         * 
         * @return builder
         * 
         */
        public Builder servicePrincipal(@Nullable Output<KubernetesClusterServicePrincipalArgs> servicePrincipal) {
            $.servicePrincipal = servicePrincipal;
            return this;
        }

        /**
         * @param servicePrincipal A `service_principal` block as documented below. One of either `identity` or `service_principal` must be specified.
         * 
         * !&gt; **Note:** A migration scenario from `service_principal` to `identity` is supported. When upgrading `service_principal` to `identity`, your cluster&#39;s control plane and addon pods will switch to use managed identity, but the kubelets will keep using your configured `service_principal` until you upgrade your Node Pool.
         * 
         * @return builder
         * 
         */
        public Builder servicePrincipal(KubernetesClusterServicePrincipalArgs servicePrincipal) {
            return servicePrincipal(Output.of(servicePrincipal));
        }

        /**
         * @param skuTier The SKU Tier that should be used for this Kubernetes Cluster. Possible values are `Free`, `Standard` (which includes the Uptime SLA) and `Premium`. Defaults to `Free`.
         * 
         * &gt; **Note:** Whilst the AKS API previously supported the `Paid` SKU - the AKS API introduced a breaking change in API Version `2023-02-01` (used in v3.51.0 and later) where the value `Paid` must now be set to `Standard`.
         * 
         * @return builder
         * 
         */
        public Builder skuTier(@Nullable Output<String> skuTier) {
            $.skuTier = skuTier;
            return this;
        }

        /**
         * @param skuTier The SKU Tier that should be used for this Kubernetes Cluster. Possible values are `Free`, `Standard` (which includes the Uptime SLA) and `Premium`. Defaults to `Free`.
         * 
         * &gt; **Note:** Whilst the AKS API previously supported the `Paid` SKU - the AKS API introduced a breaking change in API Version `2023-02-01` (used in v3.51.0 and later) where the value `Paid` must now be set to `Standard`.
         * 
         * @return builder
         * 
         */
        public Builder skuTier(String skuTier) {
            return skuTier(Output.of(skuTier));
        }

        /**
         * @param storageProfile A `storage_profile` block as defined below.
         * 
         * @return builder
         * 
         */
        public Builder storageProfile(@Nullable Output<KubernetesClusterStorageProfileArgs> storageProfile) {
            $.storageProfile = storageProfile;
            return this;
        }

        /**
         * @param storageProfile A `storage_profile` block as defined below.
         * 
         * @return builder
         * 
         */
        public Builder storageProfile(KubernetesClusterStorageProfileArgs storageProfile) {
            return storageProfile(Output.of(storageProfile));
        }

        /**
         * @param supportPlan Specifies the support plan which should be used for this Kubernetes Cluster. Possible values are `KubernetesOfficial` and `AKSLongTermSupport`. Defaults to `KubernetesOfficial`.
         * 
         * @return builder
         * 
         */
        public Builder supportPlan(@Nullable Output<String> supportPlan) {
            $.supportPlan = supportPlan;
            return this;
        }

        /**
         * @param supportPlan Specifies the support plan which should be used for this Kubernetes Cluster. Possible values are `KubernetesOfficial` and `AKSLongTermSupport`. Defaults to `KubernetesOfficial`.
         * 
         * @return builder
         * 
         */
        public Builder supportPlan(String supportPlan) {
            return supportPlan(Output.of(supportPlan));
        }

        /**
         * @param tags A mapping of tags to assign to the resource.
         * 
         * @return builder
         * 
         */
        public Builder tags(@Nullable Output<Map<String,String>> tags) {
            $.tags = tags;
            return this;
        }

        /**
         * @param tags A mapping of tags to assign to the resource.
         * 
         * @return builder
         * 
         */
        public Builder tags(Map<String,String> tags) {
            return tags(Output.of(tags));
        }

        /**
         * @param upgradeOverride A `upgrade_override` block as defined below.
         * 
         * @return builder
         * 
         */
        public Builder upgradeOverride(@Nullable Output<KubernetesClusterUpgradeOverrideArgs> upgradeOverride) {
            $.upgradeOverride = upgradeOverride;
            return this;
        }

        /**
         * @param upgradeOverride A `upgrade_override` block as defined below.
         * 
         * @return builder
         * 
         */
        public Builder upgradeOverride(KubernetesClusterUpgradeOverrideArgs upgradeOverride) {
            return upgradeOverride(Output.of(upgradeOverride));
        }

        /**
         * @param webAppRouting A `web_app_routing` block as defined below.
         * 
         * @return builder
         * 
         */
        public Builder webAppRouting(@Nullable Output<KubernetesClusterWebAppRoutingArgs> webAppRouting) {
            $.webAppRouting = webAppRouting;
            return this;
        }

        /**
         * @param webAppRouting A `web_app_routing` block as defined below.
         * 
         * @return builder
         * 
         */
        public Builder webAppRouting(KubernetesClusterWebAppRoutingArgs webAppRouting) {
            return webAppRouting(Output.of(webAppRouting));
        }

        /**
         * @param windowsProfile A `windows_profile` block as defined below.
         * 
         * @return builder
         * 
         */
        public Builder windowsProfile(@Nullable Output<KubernetesClusterWindowsProfileArgs> windowsProfile) {
            $.windowsProfile = windowsProfile;
            return this;
        }

        /**
         * @param windowsProfile A `windows_profile` block as defined below.
         * 
         * @return builder
         * 
         */
        public Builder windowsProfile(KubernetesClusterWindowsProfileArgs windowsProfile) {
            return windowsProfile(Output.of(windowsProfile));
        }

        /**
         * @param workloadAutoscalerProfile A `workload_autoscaler_profile` block defined below.
         * 
         * @return builder
         * 
         */
        public Builder workloadAutoscalerProfile(@Nullable Output<KubernetesClusterWorkloadAutoscalerProfileArgs> workloadAutoscalerProfile) {
            $.workloadAutoscalerProfile = workloadAutoscalerProfile;
            return this;
        }

        /**
         * @param workloadAutoscalerProfile A `workload_autoscaler_profile` block defined below.
         * 
         * @return builder
         * 
         */
        public Builder workloadAutoscalerProfile(KubernetesClusterWorkloadAutoscalerProfileArgs workloadAutoscalerProfile) {
            return workloadAutoscalerProfile(Output.of(workloadAutoscalerProfile));
        }

        /**
         * @param workloadIdentityEnabled Specifies whether Azure AD Workload Identity should be enabled for the Cluster. Defaults to `false`.
         * 
         * &gt; **Note:** To enable Azure AD Workload Identity `oidc_issuer_enabled` must be set to `true`.
         * 
         * &gt; **Note:** Enabling this option will allocate Workload Identity resources to the `kube-system` namespace in Kubernetes. If you wish to customize the deployment of Workload Identity, you can refer to [the documentation on Azure AD Workload Identity.](https://azure.github.io/azure-workload-identity/docs/installation/mutating-admission-webhook.html) The documentation provides guidance on how to install the mutating admission webhook, which allows for the customization of Workload Identity deployment.
         * 
         * @return builder
         * 
         */
        public Builder workloadIdentityEnabled(@Nullable Output<Boolean> workloadIdentityEnabled) {
            $.workloadIdentityEnabled = workloadIdentityEnabled;
            return this;
        }

        /**
         * @param workloadIdentityEnabled Specifies whether Azure AD Workload Identity should be enabled for the Cluster. Defaults to `false`.
         * 
         * &gt; **Note:** To enable Azure AD Workload Identity `oidc_issuer_enabled` must be set to `true`.
         * 
         * &gt; **Note:** Enabling this option will allocate Workload Identity resources to the `kube-system` namespace in Kubernetes. If you wish to customize the deployment of Workload Identity, you can refer to [the documentation on Azure AD Workload Identity.](https://azure.github.io/azure-workload-identity/docs/installation/mutating-admission-webhook.html) The documentation provides guidance on how to install the mutating admission webhook, which allows for the customization of Workload Identity deployment.
         * 
         * @return builder
         * 
         */
        public Builder workloadIdentityEnabled(Boolean workloadIdentityEnabled) {
            return workloadIdentityEnabled(Output.of(workloadIdentityEnabled));
        }

        public KubernetesClusterState build() {
            return $;
        }
    }

}
