// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.azure.storage;

import com.pulumi.azure.Utilities;
import com.pulumi.azure.storage.AccountArgs;
import com.pulumi.azure.storage.inputs.AccountState;
import com.pulumi.azure.storage.outputs.AccountAzureFilesAuthentication;
import com.pulumi.azure.storage.outputs.AccountBlobProperties;
import com.pulumi.azure.storage.outputs.AccountCustomDomain;
import com.pulumi.azure.storage.outputs.AccountCustomerManagedKey;
import com.pulumi.azure.storage.outputs.AccountIdentity;
import com.pulumi.azure.storage.outputs.AccountImmutabilityPolicy;
import com.pulumi.azure.storage.outputs.AccountNetworkRules;
import com.pulumi.azure.storage.outputs.AccountQueueProperties;
import com.pulumi.azure.storage.outputs.AccountRouting;
import com.pulumi.azure.storage.outputs.AccountSasPolicy;
import com.pulumi.azure.storage.outputs.AccountShareProperties;
import com.pulumi.azure.storage.outputs.AccountStaticWebsite;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * Manages an Azure Storage Account.
 * 
 * ## Example Usage
 * ```java
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.azure.core.ResourceGroup;
 * import com.pulumi.azure.core.ResourceGroupArgs;
 * import com.pulumi.azure.storage.Account;
 * import com.pulumi.azure.storage.AccountArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var exampleResourceGroup = new ResourceGroup(&#34;exampleResourceGroup&#34;, ResourceGroupArgs.builder()        
 *             .location(&#34;West Europe&#34;)
 *             .build());
 * 
 *         var exampleAccount = new Account(&#34;exampleAccount&#34;, AccountArgs.builder()        
 *             .resourceGroupName(exampleResourceGroup.name())
 *             .location(exampleResourceGroup.location())
 *             .accountTier(&#34;Standard&#34;)
 *             .accountReplicationType(&#34;GRS&#34;)
 *             .tags(Map.of(&#34;environment&#34;, &#34;staging&#34;))
 *             .build());
 * 
 *     }
 * }
 * ```
 * ### With Network Rules
 * ```java
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.azure.core.ResourceGroup;
 * import com.pulumi.azure.core.ResourceGroupArgs;
 * import com.pulumi.azure.network.VirtualNetwork;
 * import com.pulumi.azure.network.VirtualNetworkArgs;
 * import com.pulumi.azure.network.Subnet;
 * import com.pulumi.azure.network.SubnetArgs;
 * import com.pulumi.azure.storage.Account;
 * import com.pulumi.azure.storage.AccountArgs;
 * import com.pulumi.azure.storage.inputs.AccountNetworkRulesArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var exampleResourceGroup = new ResourceGroup(&#34;exampleResourceGroup&#34;, ResourceGroupArgs.builder()        
 *             .location(&#34;West Europe&#34;)
 *             .build());
 * 
 *         var exampleVirtualNetwork = new VirtualNetwork(&#34;exampleVirtualNetwork&#34;, VirtualNetworkArgs.builder()        
 *             .addressSpaces(&#34;10.0.0.0/16&#34;)
 *             .location(exampleResourceGroup.location())
 *             .resourceGroupName(exampleResourceGroup.name())
 *             .build());
 * 
 *         var exampleSubnet = new Subnet(&#34;exampleSubnet&#34;, SubnetArgs.builder()        
 *             .resourceGroupName(exampleResourceGroup.name())
 *             .virtualNetworkName(exampleVirtualNetwork.name())
 *             .addressPrefixes(&#34;10.0.2.0/24&#34;)
 *             .serviceEndpoints(            
 *                 &#34;Microsoft.Sql&#34;,
 *                 &#34;Microsoft.Storage&#34;)
 *             .build());
 * 
 *         var exampleAccount = new Account(&#34;exampleAccount&#34;, AccountArgs.builder()        
 *             .resourceGroupName(exampleResourceGroup.name())
 *             .location(exampleResourceGroup.location())
 *             .accountTier(&#34;Standard&#34;)
 *             .accountReplicationType(&#34;LRS&#34;)
 *             .networkRules(AccountNetworkRulesArgs.builder()
 *                 .defaultAction(&#34;Deny&#34;)
 *                 .ipRules(&#34;100.0.0.1&#34;)
 *                 .virtualNetworkSubnetIds(exampleSubnet.id())
 *                 .build())
 *             .tags(Map.of(&#34;environment&#34;, &#34;staging&#34;))
 *             .build());
 * 
 *     }
 * }
 * ```
 * 
 * ## Import
 * 
 * Storage Accounts can be imported using the `resource id`, e.g.
 * 
 * ```sh
 *  $ pulumi import azure:storage/account:Account storageAcc1 /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/myresourcegroup/providers/Microsoft.Storage/storageAccounts/myaccount
 * ```
 * 
 */
@ResourceType(type="azure:storage/account:Account")
public class Account extends com.pulumi.resources.CustomResource {
    /**
     * Defines the access tier for `BlobStorage`, `FileStorage` and `StorageV2` accounts. Valid options are `Hot` and `Cool`, defaults to `Hot`.
     * 
     */
    @Export(name="accessTier", refs={String.class}, tree="[0]")
    private Output<String> accessTier;

    /**
     * @return Defines the access tier for `BlobStorage`, `FileStorage` and `StorageV2` accounts. Valid options are `Hot` and `Cool`, defaults to `Hot`.
     * 
     */
    public Output<String> accessTier() {
        return this.accessTier;
    }
    /**
     * Defines the Kind of account. Valid options are `BlobStorage`, `BlockBlobStorage`, `FileStorage`, `Storage` and `StorageV2`. Defaults to `StorageV2`.
     * 
     * &gt; **NOTE:** Changing the `account_kind` value from `Storage` to `StorageV2` will not trigger a force new on the storage account, it will only upgrade the existing storage account from `Storage` to `StorageV2` keeping the existing storage account in place.
     * 
     */
    @Export(name="accountKind", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> accountKind;

    /**
     * @return Defines the Kind of account. Valid options are `BlobStorage`, `BlockBlobStorage`, `FileStorage`, `Storage` and `StorageV2`. Defaults to `StorageV2`.
     * 
     * &gt; **NOTE:** Changing the `account_kind` value from `Storage` to `StorageV2` will not trigger a force new on the storage account, it will only upgrade the existing storage account from `Storage` to `StorageV2` keeping the existing storage account in place.
     * 
     */
    public Output<Optional<String>> accountKind() {
        return Codegen.optional(this.accountKind);
    }
    /**
     * Defines the type of replication to use for this storage account. Valid options are `LRS`, `GRS`, `RAGRS`, `ZRS`, `GZRS` and `RAGZRS`.
     * 
     */
    @Export(name="accountReplicationType", refs={String.class}, tree="[0]")
    private Output<String> accountReplicationType;

    /**
     * @return Defines the type of replication to use for this storage account. Valid options are `LRS`, `GRS`, `RAGRS`, `ZRS`, `GZRS` and `RAGZRS`.
     * 
     */
    public Output<String> accountReplicationType() {
        return this.accountReplicationType;
    }
    /**
     * Defines the Tier to use for this storage account. Valid options are `Standard` and `Premium`. For `BlockBlobStorage` and `FileStorage` accounts only `Premium` is valid. Changing this forces a new resource to be created.
     * 
     * &gt; **NOTE:** Blobs with a tier of `Premium` are of account kind `StorageV2`.
     * 
     */
    @Export(name="accountTier", refs={String.class}, tree="[0]")
    private Output<String> accountTier;

    /**
     * @return Defines the Tier to use for this storage account. Valid options are `Standard` and `Premium`. For `BlockBlobStorage` and `FileStorage` accounts only `Premium` is valid. Changing this forces a new resource to be created.
     * 
     * &gt; **NOTE:** Blobs with a tier of `Premium` are of account kind `StorageV2`.
     * 
     */
    public Output<String> accountTier() {
        return this.accountTier;
    }
    /**
     * Allow or disallow nested items within this Account to opt into being public. Defaults to `true`.
     * 
     * &gt; **NOTE:** At this time `allow_nested_items_to_be_public` is only supported in the Public Cloud, China Cloud, and US Government Cloud.
     * 
     */
    @Export(name="allowNestedItemsToBePublic", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> allowNestedItemsToBePublic;

    /**
     * @return Allow or disallow nested items within this Account to opt into being public. Defaults to `true`.
     * 
     * &gt; **NOTE:** At this time `allow_nested_items_to_be_public` is only supported in the Public Cloud, China Cloud, and US Government Cloud.
     * 
     */
    public Output<Optional<Boolean>> allowNestedItemsToBePublic() {
        return Codegen.optional(this.allowNestedItemsToBePublic);
    }
    /**
     * Restrict copy to and from Storage Accounts within an AAD tenant or with Private Links to the same VNet. Possible values are `AAD` and `PrivateLink`.
     * 
     */
    @Export(name="allowedCopyScope", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> allowedCopyScope;

    /**
     * @return Restrict copy to and from Storage Accounts within an AAD tenant or with Private Links to the same VNet. Possible values are `AAD` and `PrivateLink`.
     * 
     */
    public Output<Optional<String>> allowedCopyScope() {
        return Codegen.optional(this.allowedCopyScope);
    }
    /**
     * A `azure_files_authentication` block as defined below.
     * 
     */
    @Export(name="azureFilesAuthentication", refs={AccountAzureFilesAuthentication.class}, tree="[0]")
    private Output</* @Nullable */ AccountAzureFilesAuthentication> azureFilesAuthentication;

    /**
     * @return A `azure_files_authentication` block as defined below.
     * 
     */
    public Output<Optional<AccountAzureFilesAuthentication>> azureFilesAuthentication() {
        return Codegen.optional(this.azureFilesAuthentication);
    }
    /**
     * A `blob_properties` block as defined below.
     * 
     */
    @Export(name="blobProperties", refs={AccountBlobProperties.class}, tree="[0]")
    private Output<AccountBlobProperties> blobProperties;

    /**
     * @return A `blob_properties` block as defined below.
     * 
     */
    public Output<AccountBlobProperties> blobProperties() {
        return this.blobProperties;
    }
    /**
     * Should cross Tenant replication be enabled? Defaults to `true`.
     * 
     */
    @Export(name="crossTenantReplicationEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> crossTenantReplicationEnabled;

    /**
     * @return Should cross Tenant replication be enabled? Defaults to `true`.
     * 
     */
    public Output<Optional<Boolean>> crossTenantReplicationEnabled() {
        return Codegen.optional(this.crossTenantReplicationEnabled);
    }
    /**
     * A `custom_domain` block as documented below.
     * 
     */
    @Export(name="customDomain", refs={AccountCustomDomain.class}, tree="[0]")
    private Output</* @Nullable */ AccountCustomDomain> customDomain;

    /**
     * @return A `custom_domain` block as documented below.
     * 
     */
    public Output<Optional<AccountCustomDomain>> customDomain() {
        return Codegen.optional(this.customDomain);
    }
    /**
     * A `customer_managed_key` block as documented below.
     * 
     */
    @Export(name="customerManagedKey", refs={AccountCustomerManagedKey.class}, tree="[0]")
    private Output</* @Nullable */ AccountCustomerManagedKey> customerManagedKey;

    /**
     * @return A `customer_managed_key` block as documented below.
     * 
     */
    public Output<Optional<AccountCustomerManagedKey>> customerManagedKey() {
        return Codegen.optional(this.customerManagedKey);
    }
    /**
     * Default to Azure Active Directory authorization in the Azure portal when accessing the Storage Account. The default value is `false`
     * 
     */
    @Export(name="defaultToOauthAuthentication", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> defaultToOauthAuthentication;

    /**
     * @return Default to Azure Active Directory authorization in the Azure portal when accessing the Storage Account. The default value is `false`
     * 
     */
    public Output<Optional<Boolean>> defaultToOauthAuthentication() {
        return Codegen.optional(this.defaultToOauthAuthentication);
    }
    /**
     * Specifies the Edge Zone within the Azure Region where this Storage Account should exist. Changing this forces a new Storage Account to be created.
     * 
     */
    @Export(name="edgeZone", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> edgeZone;

    /**
     * @return Specifies the Edge Zone within the Azure Region where this Storage Account should exist. Changing this forces a new Storage Account to be created.
     * 
     */
    public Output<Optional<String>> edgeZone() {
        return Codegen.optional(this.edgeZone);
    }
    /**
     * Boolean flag which forces HTTPS if enabled, see [here](https://docs.microsoft.com/azure/storage/storage-require-secure-transfer/) for more information. Defaults to `true`.
     * 
     */
    @Export(name="enableHttpsTrafficOnly", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> enableHttpsTrafficOnly;

    /**
     * @return Boolean flag which forces HTTPS if enabled, see [here](https://docs.microsoft.com/azure/storage/storage-require-secure-transfer/) for more information. Defaults to `true`.
     * 
     */
    public Output<Optional<Boolean>> enableHttpsTrafficOnly() {
        return Codegen.optional(this.enableHttpsTrafficOnly);
    }
    /**
     * An `identity` block as defined below.
     * 
     */
    @Export(name="identity", refs={AccountIdentity.class}, tree="[0]")
    private Output</* @Nullable */ AccountIdentity> identity;

    /**
     * @return An `identity` block as defined below.
     * 
     */
    public Output<Optional<AccountIdentity>> identity() {
        return Codegen.optional(this.identity);
    }
    /**
     * An `immutability_policy` block as defined below. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="immutabilityPolicy", refs={AccountImmutabilityPolicy.class}, tree="[0]")
    private Output</* @Nullable */ AccountImmutabilityPolicy> immutabilityPolicy;

    /**
     * @return An `immutability_policy` block as defined below. Changing this forces a new resource to be created.
     * 
     */
    public Output<Optional<AccountImmutabilityPolicy>> immutabilityPolicy() {
        return Codegen.optional(this.immutabilityPolicy);
    }
    /**
     * Is infrastructure encryption enabled? Changing this forces a new resource to be created. Defaults to `false`.
     * 
     * &gt; **NOTE:** This can only be `true` when `account_kind` is `StorageV2` or when `account_tier` is `Premium` *and* `account_kind` is one of `BlockBlobStorage` or `FileStorage`.
     * 
     */
    @Export(name="infrastructureEncryptionEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> infrastructureEncryptionEnabled;

    /**
     * @return Is infrastructure encryption enabled? Changing this forces a new resource to be created. Defaults to `false`.
     * 
     * &gt; **NOTE:** This can only be `true` when `account_kind` is `StorageV2` or when `account_tier` is `Premium` *and* `account_kind` is one of `BlockBlobStorage` or `FileStorage`.
     * 
     */
    public Output<Optional<Boolean>> infrastructureEncryptionEnabled() {
        return Codegen.optional(this.infrastructureEncryptionEnabled);
    }
    /**
     * Is Hierarchical Namespace enabled? This can be used with Azure Data Lake Storage Gen 2 ([see here for more information](https://docs.microsoft.com/azure/storage/blobs/data-lake-storage-quickstart-create-account/)). Changing this forces a new resource to be created.
     * 
     * &gt; **NOTE:** This can only be `true` when `account_tier` is `Standard` or when `account_tier` is `Premium` *and* `account_kind` is `BlockBlobStorage`
     * 
     */
    @Export(name="isHnsEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> isHnsEnabled;

    /**
     * @return Is Hierarchical Namespace enabled? This can be used with Azure Data Lake Storage Gen 2 ([see here for more information](https://docs.microsoft.com/azure/storage/blobs/data-lake-storage-quickstart-create-account/)). Changing this forces a new resource to be created.
     * 
     * &gt; **NOTE:** This can only be `true` when `account_tier` is `Standard` or when `account_tier` is `Premium` *and* `account_kind` is `BlockBlobStorage`
     * 
     */
    public Output<Optional<Boolean>> isHnsEnabled() {
        return Codegen.optional(this.isHnsEnabled);
    }
    /**
     * Is Large File Share Enabled?
     * 
     */
    @Export(name="largeFileShareEnabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> largeFileShareEnabled;

    /**
     * @return Is Large File Share Enabled?
     * 
     */
    public Output<Boolean> largeFileShareEnabled() {
        return this.largeFileShareEnabled;
    }
    /**
     * Specifies the supported Azure location where the resource exists. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="location", refs={String.class}, tree="[0]")
    private Output<String> location;

    /**
     * @return Specifies the supported Azure location where the resource exists. Changing this forces a new resource to be created.
     * 
     */
    public Output<String> location() {
        return this.location;
    }
    /**
     * The minimum supported TLS version for the storage account. Possible values are `TLS1_0`, `TLS1_1`, and `TLS1_2`. Defaults to `TLS1_2` for new storage accounts.
     * 
     * &gt; **NOTE:** At this time `min_tls_version` is only supported in the Public Cloud, China Cloud, and US Government Cloud.
     * 
     */
    @Export(name="minTlsVersion", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> minTlsVersion;

    /**
     * @return The minimum supported TLS version for the storage account. Possible values are `TLS1_0`, `TLS1_1`, and `TLS1_2`. Defaults to `TLS1_2` for new storage accounts.
     * 
     * &gt; **NOTE:** At this time `min_tls_version` is only supported in the Public Cloud, China Cloud, and US Government Cloud.
     * 
     */
    public Output<Optional<String>> minTlsVersion() {
        return Codegen.optional(this.minTlsVersion);
    }
    /**
     * Specifies the name of the storage account. Only lowercase Alphanumeric characters allowed. Changing this forces a new resource to be created. This must be unique across the entire Azure service, not just within the resource group.
     * 
     */
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    /**
     * @return Specifies the name of the storage account. Only lowercase Alphanumeric characters allowed. Changing this forces a new resource to be created. This must be unique across the entire Azure service, not just within the resource group.
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * A `network_rules` block as documented below.
     * 
     */
    @Export(name="networkRules", refs={AccountNetworkRules.class}, tree="[0]")
    private Output<AccountNetworkRules> networkRules;

    /**
     * @return A `network_rules` block as documented below.
     * 
     */
    public Output<AccountNetworkRules> networkRules() {
        return this.networkRules;
    }
    /**
     * Is NFSv3 protocol enabled? Changing this forces a new resource to be created. Defaults to `false`.
     * 
     * &gt; **NOTE:** This can only be `true` when `account_tier` is `Standard` and `account_kind` is `StorageV2`, or `account_tier` is `Premium` and `account_kind` is `BlockBlobStorage`. Additionally, the `is_hns_enabled` is `true` and `account_replication_type` must be `LRS` or `RAGRS`.
     * 
     */
    @Export(name="nfsv3Enabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> nfsv3Enabled;

    /**
     * @return Is NFSv3 protocol enabled? Changing this forces a new resource to be created. Defaults to `false`.
     * 
     * &gt; **NOTE:** This can only be `true` when `account_tier` is `Standard` and `account_kind` is `StorageV2`, or `account_tier` is `Premium` and `account_kind` is `BlockBlobStorage`. Additionally, the `is_hns_enabled` is `true` and `account_replication_type` must be `LRS` or `RAGRS`.
     * 
     */
    public Output<Optional<Boolean>> nfsv3Enabled() {
        return Codegen.optional(this.nfsv3Enabled);
    }
    /**
     * The primary access key for the storage account.
     * 
     */
    @Export(name="primaryAccessKey", refs={String.class}, tree="[0]")
    private Output<String> primaryAccessKey;

    /**
     * @return The primary access key for the storage account.
     * 
     */
    public Output<String> primaryAccessKey() {
        return this.primaryAccessKey;
    }
    /**
     * The connection string associated with the primary blob location.
     * 
     */
    @Export(name="primaryBlobConnectionString", refs={String.class}, tree="[0]")
    private Output<String> primaryBlobConnectionString;

    /**
     * @return The connection string associated with the primary blob location.
     * 
     */
    public Output<String> primaryBlobConnectionString() {
        return this.primaryBlobConnectionString;
    }
    /**
     * The endpoint URL for blob storage in the primary location.
     * 
     */
    @Export(name="primaryBlobEndpoint", refs={String.class}, tree="[0]")
    private Output<String> primaryBlobEndpoint;

    /**
     * @return The endpoint URL for blob storage in the primary location.
     * 
     */
    public Output<String> primaryBlobEndpoint() {
        return this.primaryBlobEndpoint;
    }
    /**
     * The hostname with port if applicable for blob storage in the primary location.
     * 
     */
    @Export(name="primaryBlobHost", refs={String.class}, tree="[0]")
    private Output<String> primaryBlobHost;

    /**
     * @return The hostname with port if applicable for blob storage in the primary location.
     * 
     */
    public Output<String> primaryBlobHost() {
        return this.primaryBlobHost;
    }
    /**
     * The connection string associated with the primary location.
     * 
     */
    @Export(name="primaryConnectionString", refs={String.class}, tree="[0]")
    private Output<String> primaryConnectionString;

    /**
     * @return The connection string associated with the primary location.
     * 
     */
    public Output<String> primaryConnectionString() {
        return this.primaryConnectionString;
    }
    /**
     * The endpoint URL for DFS storage in the primary location.
     * 
     */
    @Export(name="primaryDfsEndpoint", refs={String.class}, tree="[0]")
    private Output<String> primaryDfsEndpoint;

    /**
     * @return The endpoint URL for DFS storage in the primary location.
     * 
     */
    public Output<String> primaryDfsEndpoint() {
        return this.primaryDfsEndpoint;
    }
    /**
     * The hostname with port if applicable for DFS storage in the primary location.
     * 
     */
    @Export(name="primaryDfsHost", refs={String.class}, tree="[0]")
    private Output<String> primaryDfsHost;

    /**
     * @return The hostname with port if applicable for DFS storage in the primary location.
     * 
     */
    public Output<String> primaryDfsHost() {
        return this.primaryDfsHost;
    }
    /**
     * The endpoint URL for file storage in the primary location.
     * 
     */
    @Export(name="primaryFileEndpoint", refs={String.class}, tree="[0]")
    private Output<String> primaryFileEndpoint;

    /**
     * @return The endpoint URL for file storage in the primary location.
     * 
     */
    public Output<String> primaryFileEndpoint() {
        return this.primaryFileEndpoint;
    }
    /**
     * The hostname with port if applicable for file storage in the primary location.
     * 
     */
    @Export(name="primaryFileHost", refs={String.class}, tree="[0]")
    private Output<String> primaryFileHost;

    /**
     * @return The hostname with port if applicable for file storage in the primary location.
     * 
     */
    public Output<String> primaryFileHost() {
        return this.primaryFileHost;
    }
    /**
     * The primary location of the storage account.
     * 
     */
    @Export(name="primaryLocation", refs={String.class}, tree="[0]")
    private Output<String> primaryLocation;

    /**
     * @return The primary location of the storage account.
     * 
     */
    public Output<String> primaryLocation() {
        return this.primaryLocation;
    }
    /**
     * The endpoint URL for queue storage in the primary location.
     * 
     */
    @Export(name="primaryQueueEndpoint", refs={String.class}, tree="[0]")
    private Output<String> primaryQueueEndpoint;

    /**
     * @return The endpoint URL for queue storage in the primary location.
     * 
     */
    public Output<String> primaryQueueEndpoint() {
        return this.primaryQueueEndpoint;
    }
    /**
     * The hostname with port if applicable for queue storage in the primary location.
     * 
     */
    @Export(name="primaryQueueHost", refs={String.class}, tree="[0]")
    private Output<String> primaryQueueHost;

    /**
     * @return The hostname with port if applicable for queue storage in the primary location.
     * 
     */
    public Output<String> primaryQueueHost() {
        return this.primaryQueueHost;
    }
    /**
     * The endpoint URL for table storage in the primary location.
     * 
     */
    @Export(name="primaryTableEndpoint", refs={String.class}, tree="[0]")
    private Output<String> primaryTableEndpoint;

    /**
     * @return The endpoint URL for table storage in the primary location.
     * 
     */
    public Output<String> primaryTableEndpoint() {
        return this.primaryTableEndpoint;
    }
    /**
     * The hostname with port if applicable for table storage in the primary location.
     * 
     */
    @Export(name="primaryTableHost", refs={String.class}, tree="[0]")
    private Output<String> primaryTableHost;

    /**
     * @return The hostname with port if applicable for table storage in the primary location.
     * 
     */
    public Output<String> primaryTableHost() {
        return this.primaryTableHost;
    }
    /**
     * The endpoint URL for web storage in the primary location.
     * 
     */
    @Export(name="primaryWebEndpoint", refs={String.class}, tree="[0]")
    private Output<String> primaryWebEndpoint;

    /**
     * @return The endpoint URL for web storage in the primary location.
     * 
     */
    public Output<String> primaryWebEndpoint() {
        return this.primaryWebEndpoint;
    }
    /**
     * The hostname with port if applicable for web storage in the primary location.
     * 
     */
    @Export(name="primaryWebHost", refs={String.class}, tree="[0]")
    private Output<String> primaryWebHost;

    /**
     * @return The hostname with port if applicable for web storage in the primary location.
     * 
     */
    public Output<String> primaryWebHost() {
        return this.primaryWebHost;
    }
    /**
     * Whether the public network access is enabled? Defaults to `true`.
     * 
     */
    @Export(name="publicNetworkAccessEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> publicNetworkAccessEnabled;

    /**
     * @return Whether the public network access is enabled? Defaults to `true`.
     * 
     */
    public Output<Optional<Boolean>> publicNetworkAccessEnabled() {
        return Codegen.optional(this.publicNetworkAccessEnabled);
    }
    /**
     * The encryption type of the queue service. Possible values are `Service` and `Account`. Changing this forces a new resource to be created. Default value is `Service`.
     * 
     */
    @Export(name="queueEncryptionKeyType", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> queueEncryptionKeyType;

    /**
     * @return The encryption type of the queue service. Possible values are `Service` and `Account`. Changing this forces a new resource to be created. Default value is `Service`.
     * 
     */
    public Output<Optional<String>> queueEncryptionKeyType() {
        return Codegen.optional(this.queueEncryptionKeyType);
    }
    /**
     * A `queue_properties` block as defined below.
     * 
     * &gt; **NOTE:** `queue_properties` cannot be set when the `account_kind` is set to `BlobStorage`
     * 
     */
    @Export(name="queueProperties", refs={AccountQueueProperties.class}, tree="[0]")
    private Output<AccountQueueProperties> queueProperties;

    /**
     * @return A `queue_properties` block as defined below.
     * 
     * &gt; **NOTE:** `queue_properties` cannot be set when the `account_kind` is set to `BlobStorage`
     * 
     */
    public Output<AccountQueueProperties> queueProperties() {
        return this.queueProperties;
    }
    /**
     * The name of the resource group in which to create the storage account. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="resourceGroupName", refs={String.class}, tree="[0]")
    private Output<String> resourceGroupName;

    /**
     * @return The name of the resource group in which to create the storage account. Changing this forces a new resource to be created.
     * 
     */
    public Output<String> resourceGroupName() {
        return this.resourceGroupName;
    }
    /**
     * A `routing` block as defined below.
     * 
     */
    @Export(name="routing", refs={AccountRouting.class}, tree="[0]")
    private Output<AccountRouting> routing;

    /**
     * @return A `routing` block as defined below.
     * 
     */
    public Output<AccountRouting> routing() {
        return this.routing;
    }
    /**
     * A `sas_policy` block as defined below.
     * 
     */
    @Export(name="sasPolicy", refs={AccountSasPolicy.class}, tree="[0]")
    private Output</* @Nullable */ AccountSasPolicy> sasPolicy;

    /**
     * @return A `sas_policy` block as defined below.
     * 
     */
    public Output<Optional<AccountSasPolicy>> sasPolicy() {
        return Codegen.optional(this.sasPolicy);
    }
    /**
     * The secondary access key for the storage account.
     * 
     */
    @Export(name="secondaryAccessKey", refs={String.class}, tree="[0]")
    private Output<String> secondaryAccessKey;

    /**
     * @return The secondary access key for the storage account.
     * 
     */
    public Output<String> secondaryAccessKey() {
        return this.secondaryAccessKey;
    }
    /**
     * The connection string associated with the secondary blob location.
     * 
     */
    @Export(name="secondaryBlobConnectionString", refs={String.class}, tree="[0]")
    private Output<String> secondaryBlobConnectionString;

    /**
     * @return The connection string associated with the secondary blob location.
     * 
     */
    public Output<String> secondaryBlobConnectionString() {
        return this.secondaryBlobConnectionString;
    }
    /**
     * The endpoint URL for blob storage in the secondary location.
     * 
     */
    @Export(name="secondaryBlobEndpoint", refs={String.class}, tree="[0]")
    private Output<String> secondaryBlobEndpoint;

    /**
     * @return The endpoint URL for blob storage in the secondary location.
     * 
     */
    public Output<String> secondaryBlobEndpoint() {
        return this.secondaryBlobEndpoint;
    }
    /**
     * The hostname with port if applicable for blob storage in the secondary location.
     * 
     */
    @Export(name="secondaryBlobHost", refs={String.class}, tree="[0]")
    private Output<String> secondaryBlobHost;

    /**
     * @return The hostname with port if applicable for blob storage in the secondary location.
     * 
     */
    public Output<String> secondaryBlobHost() {
        return this.secondaryBlobHost;
    }
    /**
     * The connection string associated with the secondary location.
     * 
     */
    @Export(name="secondaryConnectionString", refs={String.class}, tree="[0]")
    private Output<String> secondaryConnectionString;

    /**
     * @return The connection string associated with the secondary location.
     * 
     */
    public Output<String> secondaryConnectionString() {
        return this.secondaryConnectionString;
    }
    /**
     * The endpoint URL for DFS storage in the secondary location.
     * 
     */
    @Export(name="secondaryDfsEndpoint", refs={String.class}, tree="[0]")
    private Output<String> secondaryDfsEndpoint;

    /**
     * @return The endpoint URL for DFS storage in the secondary location.
     * 
     */
    public Output<String> secondaryDfsEndpoint() {
        return this.secondaryDfsEndpoint;
    }
    /**
     * The hostname with port if applicable for DFS storage in the secondary location.
     * 
     */
    @Export(name="secondaryDfsHost", refs={String.class}, tree="[0]")
    private Output<String> secondaryDfsHost;

    /**
     * @return The hostname with port if applicable for DFS storage in the secondary location.
     * 
     */
    public Output<String> secondaryDfsHost() {
        return this.secondaryDfsHost;
    }
    /**
     * The endpoint URL for file storage in the secondary location.
     * 
     */
    @Export(name="secondaryFileEndpoint", refs={String.class}, tree="[0]")
    private Output<String> secondaryFileEndpoint;

    /**
     * @return The endpoint URL for file storage in the secondary location.
     * 
     */
    public Output<String> secondaryFileEndpoint() {
        return this.secondaryFileEndpoint;
    }
    /**
     * The hostname with port if applicable for file storage in the secondary location.
     * 
     */
    @Export(name="secondaryFileHost", refs={String.class}, tree="[0]")
    private Output<String> secondaryFileHost;

    /**
     * @return The hostname with port if applicable for file storage in the secondary location.
     * 
     */
    public Output<String> secondaryFileHost() {
        return this.secondaryFileHost;
    }
    /**
     * The secondary location of the storage account.
     * 
     */
    @Export(name="secondaryLocation", refs={String.class}, tree="[0]")
    private Output<String> secondaryLocation;

    /**
     * @return The secondary location of the storage account.
     * 
     */
    public Output<String> secondaryLocation() {
        return this.secondaryLocation;
    }
    /**
     * The endpoint URL for queue storage in the secondary location.
     * 
     */
    @Export(name="secondaryQueueEndpoint", refs={String.class}, tree="[0]")
    private Output<String> secondaryQueueEndpoint;

    /**
     * @return The endpoint URL for queue storage in the secondary location.
     * 
     */
    public Output<String> secondaryQueueEndpoint() {
        return this.secondaryQueueEndpoint;
    }
    /**
     * The hostname with port if applicable for queue storage in the secondary location.
     * 
     */
    @Export(name="secondaryQueueHost", refs={String.class}, tree="[0]")
    private Output<String> secondaryQueueHost;

    /**
     * @return The hostname with port if applicable for queue storage in the secondary location.
     * 
     */
    public Output<String> secondaryQueueHost() {
        return this.secondaryQueueHost;
    }
    /**
     * The endpoint URL for table storage in the secondary location.
     * 
     */
    @Export(name="secondaryTableEndpoint", refs={String.class}, tree="[0]")
    private Output<String> secondaryTableEndpoint;

    /**
     * @return The endpoint URL for table storage in the secondary location.
     * 
     */
    public Output<String> secondaryTableEndpoint() {
        return this.secondaryTableEndpoint;
    }
    /**
     * The hostname with port if applicable for table storage in the secondary location.
     * 
     */
    @Export(name="secondaryTableHost", refs={String.class}, tree="[0]")
    private Output<String> secondaryTableHost;

    /**
     * @return The hostname with port if applicable for table storage in the secondary location.
     * 
     */
    public Output<String> secondaryTableHost() {
        return this.secondaryTableHost;
    }
    /**
     * The endpoint URL for web storage in the secondary location.
     * 
     */
    @Export(name="secondaryWebEndpoint", refs={String.class}, tree="[0]")
    private Output<String> secondaryWebEndpoint;

    /**
     * @return The endpoint URL for web storage in the secondary location.
     * 
     */
    public Output<String> secondaryWebEndpoint() {
        return this.secondaryWebEndpoint;
    }
    /**
     * The hostname with port if applicable for web storage in the secondary location.
     * 
     */
    @Export(name="secondaryWebHost", refs={String.class}, tree="[0]")
    private Output<String> secondaryWebHost;

    /**
     * @return The hostname with port if applicable for web storage in the secondary location.
     * 
     */
    public Output<String> secondaryWebHost() {
        return this.secondaryWebHost;
    }
    /**
     * Boolean, enable SFTP for the storage account
     * 
     * &gt; **NOTE:** SFTP support requires `is_hns_enabled` set to `true`. [More information on SFTP support can be found here](https://learn.microsoft.com/azure/storage/blobs/secure-file-transfer-protocol-support). Defaults to `false`
     * 
     */
    @Export(name="sftpEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> sftpEnabled;

    /**
     * @return Boolean, enable SFTP for the storage account
     * 
     * &gt; **NOTE:** SFTP support requires `is_hns_enabled` set to `true`. [More information on SFTP support can be found here](https://learn.microsoft.com/azure/storage/blobs/secure-file-transfer-protocol-support). Defaults to `false`
     * 
     */
    public Output<Optional<Boolean>> sftpEnabled() {
        return Codegen.optional(this.sftpEnabled);
    }
    /**
     * A `share_properties` block as defined below.
     * 
     */
    @Export(name="shareProperties", refs={AccountShareProperties.class}, tree="[0]")
    private Output<AccountShareProperties> shareProperties;

    /**
     * @return A `share_properties` block as defined below.
     * 
     */
    public Output<AccountShareProperties> shareProperties() {
        return this.shareProperties;
    }
    @Export(name="sharedAccessKeyEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> sharedAccessKeyEnabled;

    public Output<Optional<Boolean>> sharedAccessKeyEnabled() {
        return Codegen.optional(this.sharedAccessKeyEnabled);
    }
    /**
     * A `static_website` block as defined below.
     * 
     * &gt; **NOTE:** `static_website` can only be set when the `account_kind` is set to `StorageV2` or `BlockBlobStorage`.
     * 
     */
    @Export(name="staticWebsite", refs={AccountStaticWebsite.class}, tree="[0]")
    private Output</* @Nullable */ AccountStaticWebsite> staticWebsite;

    /**
     * @return A `static_website` block as defined below.
     * 
     * &gt; **NOTE:** `static_website` can only be set when the `account_kind` is set to `StorageV2` or `BlockBlobStorage`.
     * 
     */
    public Output<Optional<AccountStaticWebsite>> staticWebsite() {
        return Codegen.optional(this.staticWebsite);
    }
    /**
     * The encryption type of the table service. Possible values are `Service` and `Account`. Changing this forces a new resource to be created. Default value is `Service`.
     * 
     * &gt; **NOTE:** For the `queue_encryption_key_type` and `table_encryption_key_type`, the `Account` key type is only allowed when the `account_kind` is set to `StorageV2`
     * 
     */
    @Export(name="tableEncryptionKeyType", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tableEncryptionKeyType;

    /**
     * @return The encryption type of the table service. Possible values are `Service` and `Account`. Changing this forces a new resource to be created. Default value is `Service`.
     * 
     * &gt; **NOTE:** For the `queue_encryption_key_type` and `table_encryption_key_type`, the `Account` key type is only allowed when the `account_kind` is set to `StorageV2`
     * 
     */
    public Output<Optional<String>> tableEncryptionKeyType() {
        return Codegen.optional(this.tableEncryptionKeyType);
    }
    /**
     * A mapping of tags to assign to the resource.
     * 
     */
    @Export(name="tags", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output</* @Nullable */ Map<String,String>> tags;

    /**
     * @return A mapping of tags to assign to the resource.
     * 
     */
    public Output<Optional<Map<String,String>>> tags() {
        return Codegen.optional(this.tags);
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public Account(String name) {
        this(name, AccountArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public Account(String name, AccountArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public Account(String name, AccountArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("azure:storage/account:Account", name, args == null ? AccountArgs.Empty : args, makeResourceOptions(options, Codegen.empty()));
    }

    private Account(String name, Output<String> id, @Nullable AccountState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("azure:storage/account:Account", name, state, makeResourceOptions(options, id));
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .additionalSecretOutputs(List.of(
                "primaryAccessKey",
                "primaryBlobConnectionString",
                "primaryConnectionString",
                "secondaryAccessKey",
                "secondaryBlobConnectionString",
                "secondaryConnectionString"
            ))
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static Account get(String name, Output<String> id, @Nullable AccountState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new Account(name, id, state, options);
    }
}
