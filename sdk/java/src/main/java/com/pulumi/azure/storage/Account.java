// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.azure.storage;

import com.pulumi.azure.Utilities;
import com.pulumi.azure.storage.AccountArgs;
import com.pulumi.azure.storage.inputs.AccountState;
import com.pulumi.azure.storage.outputs.AccountAzureFilesAuthentication;
import com.pulumi.azure.storage.outputs.AccountBlobProperties;
import com.pulumi.azure.storage.outputs.AccountCustomDomain;
import com.pulumi.azure.storage.outputs.AccountCustomerManagedKey;
import com.pulumi.azure.storage.outputs.AccountIdentity;
import com.pulumi.azure.storage.outputs.AccountImmutabilityPolicy;
import com.pulumi.azure.storage.outputs.AccountNetworkRules;
import com.pulumi.azure.storage.outputs.AccountQueueProperties;
import com.pulumi.azure.storage.outputs.AccountRouting;
import com.pulumi.azure.storage.outputs.AccountSasPolicy;
import com.pulumi.azure.storage.outputs.AccountShareProperties;
import com.pulumi.azure.storage.outputs.AccountStaticWebsite;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * Manages an Azure Storage Account.
 * 
 * ## Example Usage
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.azure.core.ResourceGroup;
 * import com.pulumi.azure.core.ResourceGroupArgs;
 * import com.pulumi.azure.storage.Account;
 * import com.pulumi.azure.storage.AccountArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var example = new ResourceGroup("example", ResourceGroupArgs.builder()
 *             .name("example-resources")
 *             .location("West Europe")
 *             .build());
 * 
 *         var exampleAccount = new Account("exampleAccount", AccountArgs.builder()
 *             .name("storageaccountname")
 *             .resourceGroupName(example.name())
 *             .location(example.location())
 *             .accountTier("Standard")
 *             .accountReplicationType("GRS")
 *             .tags(Map.of("environment", "staging"))
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * 
 * ### With Network Rules
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.azure.core.ResourceGroup;
 * import com.pulumi.azure.core.ResourceGroupArgs;
 * import com.pulumi.azure.network.VirtualNetwork;
 * import com.pulumi.azure.network.VirtualNetworkArgs;
 * import com.pulumi.azure.network.Subnet;
 * import com.pulumi.azure.network.SubnetArgs;
 * import com.pulumi.azure.storage.Account;
 * import com.pulumi.azure.storage.AccountArgs;
 * import com.pulumi.azure.storage.inputs.AccountNetworkRulesArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var example = new ResourceGroup("example", ResourceGroupArgs.builder()
 *             .name("example-resources")
 *             .location("West Europe")
 *             .build());
 * 
 *         var exampleVirtualNetwork = new VirtualNetwork("exampleVirtualNetwork", VirtualNetworkArgs.builder()
 *             .name("virtnetname")
 *             .addressSpaces("10.0.0.0/16")
 *             .location(example.location())
 *             .resourceGroupName(example.name())
 *             .build());
 * 
 *         var exampleSubnet = new Subnet("exampleSubnet", SubnetArgs.builder()
 *             .name("subnetname")
 *             .resourceGroupName(example.name())
 *             .virtualNetworkName(exampleVirtualNetwork.name())
 *             .addressPrefixes("10.0.2.0/24")
 *             .serviceEndpoints(            
 *                 "Microsoft.Sql",
 *                 "Microsoft.Storage")
 *             .build());
 * 
 *         var exampleAccount = new Account("exampleAccount", AccountArgs.builder()
 *             .name("storageaccountname")
 *             .resourceGroupName(example.name())
 *             .location(example.location())
 *             .accountTier("Standard")
 *             .accountReplicationType("LRS")
 *             .networkRules(AccountNetworkRulesArgs.builder()
 *                 .defaultAction("Deny")
 *                 .ipRules("100.0.0.1")
 *                 .virtualNetworkSubnetIds(exampleSubnet.id())
 *                 .build())
 *             .tags(Map.of("environment", "staging"))
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * 
 * ## API Providers
 * 
 * &lt;!-- This section is generated, changes will be overwritten --&gt;
 * This resource uses the following Azure API Providers:
 * 
 * * `Microsoft.Storage`: 2023-05-01
 * 
 * ## Import
 * 
 * Storage Accounts can be imported using the `resource id`, e.g.
 * 
 * ```sh
 * $ pulumi import azure:storage/account:Account storageAcc1 /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/myresourcegroup/providers/Microsoft.Storage/storageAccounts/myaccount
 * ```
 * 
 */
@ResourceType(type="azure:storage/account:Account")
public class Account extends com.pulumi.resources.CustomResource {
    /**
     * Defines the access tier for `BlobStorage`, `FileStorage` and `StorageV2` accounts. Valid options are `Hot`, `Cool`, `Cold` and `Premium`. Defaults to `Hot`.
     * 
     */
    @Export(name="accessTier", refs={String.class}, tree="[0]")
    private Output<String> accessTier;

    /**
     * @return Defines the access tier for `BlobStorage`, `FileStorage` and `StorageV2` accounts. Valid options are `Hot`, `Cool`, `Cold` and `Premium`. Defaults to `Hot`.
     * 
     */
    public Output<String> accessTier() {
        return this.accessTier;
    }
    /**
     * Defines the Kind of account. Valid options are `BlobStorage`, `BlockBlobStorage`, `FileStorage`, `Storage` and `StorageV2`. Defaults to `StorageV2`.
     * 
     * &gt; **Note:** Changing the `account_kind` value from `Storage` to `StorageV2` will not trigger a force new on the storage account, it will only upgrade the existing storage account from `Storage` to `StorageV2` keeping the existing storage account in place.
     * 
     */
    @Export(name="accountKind", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> accountKind;

    /**
     * @return Defines the Kind of account. Valid options are `BlobStorage`, `BlockBlobStorage`, `FileStorage`, `Storage` and `StorageV2`. Defaults to `StorageV2`.
     * 
     * &gt; **Note:** Changing the `account_kind` value from `Storage` to `StorageV2` will not trigger a force new on the storage account, it will only upgrade the existing storage account from `Storage` to `StorageV2` keeping the existing storage account in place.
     * 
     */
    public Output<Optional<String>> accountKind() {
        return Codegen.optional(this.accountKind);
    }
    /**
     * Defines the type of replication to use for this storage account. Valid options are `LRS`, `GRS`, `RAGRS`, `ZRS`, `GZRS` and `RAGZRS`. Changing this forces a new resource to be created when types `LRS`, `GRS` and `RAGRS` are changed to `ZRS`, `GZRS` or `RAGZRS` and vice versa.
     * 
     */
    @Export(name="accountReplicationType", refs={String.class}, tree="[0]")
    private Output<String> accountReplicationType;

    /**
     * @return Defines the type of replication to use for this storage account. Valid options are `LRS`, `GRS`, `RAGRS`, `ZRS`, `GZRS` and `RAGZRS`. Changing this forces a new resource to be created when types `LRS`, `GRS` and `RAGRS` are changed to `ZRS`, `GZRS` or `RAGZRS` and vice versa.
     * 
     */
    public Output<String> accountReplicationType() {
        return this.accountReplicationType;
    }
    /**
     * Defines the Tier to use for this storage account. Valid options are `Standard` and `Premium`. For `BlockBlobStorage` and `FileStorage` accounts only `Premium` is valid. Changing this forces a new resource to be created.
     * 
     * &gt; **Note:** Blobs with a tier of `Premium` are of account kind `StorageV2`.
     * 
     */
    @Export(name="accountTier", refs={String.class}, tree="[0]")
    private Output<String> accountTier;

    /**
     * @return Defines the Tier to use for this storage account. Valid options are `Standard` and `Premium`. For `BlockBlobStorage` and `FileStorage` accounts only `Premium` is valid. Changing this forces a new resource to be created.
     * 
     * &gt; **Note:** Blobs with a tier of `Premium` are of account kind `StorageV2`.
     * 
     */
    public Output<String> accountTier() {
        return this.accountTier;
    }
    /**
     * Allow or disallow nested items within this Account to opt into being public. Defaults to `true`.
     * 
     * &gt; **Note:** At this time `allow_nested_items_to_be_public` is only supported in the Public Cloud, China Cloud, and US Government Cloud.
     * 
     */
    @Export(name="allowNestedItemsToBePublic", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> allowNestedItemsToBePublic;

    /**
     * @return Allow or disallow nested items within this Account to opt into being public. Defaults to `true`.
     * 
     * &gt; **Note:** At this time `allow_nested_items_to_be_public` is only supported in the Public Cloud, China Cloud, and US Government Cloud.
     * 
     */
    public Output<Optional<Boolean>> allowNestedItemsToBePublic() {
        return Codegen.optional(this.allowNestedItemsToBePublic);
    }
    /**
     * Restrict copy to and from Storage Accounts within an AAD tenant or with Private Links to the same VNet. Possible values are `AAD` and `PrivateLink`.
     * 
     */
    @Export(name="allowedCopyScope", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> allowedCopyScope;

    /**
     * @return Restrict copy to and from Storage Accounts within an AAD tenant or with Private Links to the same VNet. Possible values are `AAD` and `PrivateLink`.
     * 
     */
    public Output<Optional<String>> allowedCopyScope() {
        return Codegen.optional(this.allowedCopyScope);
    }
    /**
     * A `azure_files_authentication` block as defined below.
     * 
     */
    @Export(name="azureFilesAuthentication", refs={AccountAzureFilesAuthentication.class}, tree="[0]")
    private Output</* @Nullable */ AccountAzureFilesAuthentication> azureFilesAuthentication;

    /**
     * @return A `azure_files_authentication` block as defined below.
     * 
     */
    public Output<Optional<AccountAzureFilesAuthentication>> azureFilesAuthentication() {
        return Codegen.optional(this.azureFilesAuthentication);
    }
    /**
     * A `blob_properties` block as defined below.
     * 
     */
    @Export(name="blobProperties", refs={AccountBlobProperties.class}, tree="[0]")
    private Output<AccountBlobProperties> blobProperties;

    /**
     * @return A `blob_properties` block as defined below.
     * 
     */
    public Output<AccountBlobProperties> blobProperties() {
        return this.blobProperties;
    }
    /**
     * Should cross Tenant replication be enabled? Defaults to `false`.
     * 
     */
    @Export(name="crossTenantReplicationEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> crossTenantReplicationEnabled;

    /**
     * @return Should cross Tenant replication be enabled? Defaults to `false`.
     * 
     */
    public Output<Optional<Boolean>> crossTenantReplicationEnabled() {
        return Codegen.optional(this.crossTenantReplicationEnabled);
    }
    /**
     * A `custom_domain` block as documented below.
     * 
     */
    @Export(name="customDomain", refs={AccountCustomDomain.class}, tree="[0]")
    private Output</* @Nullable */ AccountCustomDomain> customDomain;

    /**
     * @return A `custom_domain` block as documented below.
     * 
     */
    public Output<Optional<AccountCustomDomain>> customDomain() {
        return Codegen.optional(this.customDomain);
    }
    /**
     * A `customer_managed_key` block as documented below.
     * 
     * &gt; **Note:** It&#39;s possible to define a Customer Managed Key both within either the `customer_managed_key` block or by using the `azure.storage.CustomerManagedKey` resource. However, it&#39;s not possible to use both methods to manage a Customer Managed Key for a Storage Account, since these will conflict. When using the `azure.storage.CustomerManagedKey` resource, you will need to use `ignore_changes` on the `customer_managed_key` block.
     * 
     */
    @Export(name="customerManagedKey", refs={AccountCustomerManagedKey.class}, tree="[0]")
    private Output</* @Nullable */ AccountCustomerManagedKey> customerManagedKey;

    /**
     * @return A `customer_managed_key` block as documented below.
     * 
     * &gt; **Note:** It&#39;s possible to define a Customer Managed Key both within either the `customer_managed_key` block or by using the `azure.storage.CustomerManagedKey` resource. However, it&#39;s not possible to use both methods to manage a Customer Managed Key for a Storage Account, since these will conflict. When using the `azure.storage.CustomerManagedKey` resource, you will need to use `ignore_changes` on the `customer_managed_key` block.
     * 
     */
    public Output<Optional<AccountCustomerManagedKey>> customerManagedKey() {
        return Codegen.optional(this.customerManagedKey);
    }
    /**
     * Default to Azure Active Directory authorization in the Azure portal when accessing the Storage Account. The default value is `false`
     * 
     */
    @Export(name="defaultToOauthAuthentication", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> defaultToOauthAuthentication;

    /**
     * @return Default to Azure Active Directory authorization in the Azure portal when accessing the Storage Account. The default value is `false`
     * 
     */
    public Output<Optional<Boolean>> defaultToOauthAuthentication() {
        return Codegen.optional(this.defaultToOauthAuthentication);
    }
    /**
     * Specifies which DNS endpoint type to use. Possible values are `Standard` and `AzureDnsZone`. Defaults to `Standard`. Changing this forces a new resource to be created.
     * 
     * &gt; **Note:** Azure DNS zone support requires `PartitionedDns` feature to be enabled. To enable this feature for your subscription, use the following command: `az feature register --namespace &#34;Microsoft.Storage&#34; --name &#34;PartitionedDns&#34;`.
     * 
     */
    @Export(name="dnsEndpointType", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> dnsEndpointType;

    /**
     * @return Specifies which DNS endpoint type to use. Possible values are `Standard` and `AzureDnsZone`. Defaults to `Standard`. Changing this forces a new resource to be created.
     * 
     * &gt; **Note:** Azure DNS zone support requires `PartitionedDns` feature to be enabled. To enable this feature for your subscription, use the following command: `az feature register --namespace &#34;Microsoft.Storage&#34; --name &#34;PartitionedDns&#34;`.
     * 
     */
    public Output<Optional<String>> dnsEndpointType() {
        return Codegen.optional(this.dnsEndpointType);
    }
    /**
     * Specifies the Edge Zone within the Azure Region where this Storage Account should exist. Changing this forces a new Storage Account to be created.
     * 
     */
    @Export(name="edgeZone", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> edgeZone;

    /**
     * @return Specifies the Edge Zone within the Azure Region where this Storage Account should exist. Changing this forces a new Storage Account to be created.
     * 
     */
    public Output<Optional<String>> edgeZone() {
        return Codegen.optional(this.edgeZone);
    }
    /**
     * Boolean flag which forces HTTPS if enabled, see [here](https://docs.microsoft.com/azure/storage/storage-require-secure-transfer/) for more information. Defaults to `true`.
     * 
     */
    @Export(name="httpsTrafficOnlyEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> httpsTrafficOnlyEnabled;

    /**
     * @return Boolean flag which forces HTTPS if enabled, see [here](https://docs.microsoft.com/azure/storage/storage-require-secure-transfer/) for more information. Defaults to `true`.
     * 
     */
    public Output<Optional<Boolean>> httpsTrafficOnlyEnabled() {
        return Codegen.optional(this.httpsTrafficOnlyEnabled);
    }
    /**
     * An `identity` block as defined below.
     * 
     */
    @Export(name="identity", refs={AccountIdentity.class}, tree="[0]")
    private Output</* @Nullable */ AccountIdentity> identity;

    /**
     * @return An `identity` block as defined below.
     * 
     */
    public Output<Optional<AccountIdentity>> identity() {
        return Codegen.optional(this.identity);
    }
    /**
     * An `immutability_policy` block as defined below. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="immutabilityPolicy", refs={AccountImmutabilityPolicy.class}, tree="[0]")
    private Output</* @Nullable */ AccountImmutabilityPolicy> immutabilityPolicy;

    /**
     * @return An `immutability_policy` block as defined below. Changing this forces a new resource to be created.
     * 
     */
    public Output<Optional<AccountImmutabilityPolicy>> immutabilityPolicy() {
        return Codegen.optional(this.immutabilityPolicy);
    }
    /**
     * Is infrastructure encryption enabled? Changing this forces a new resource to be created. Defaults to `false`.
     * 
     * &gt; **Note:** This can only be `true` when `account_kind` is `StorageV2` or when `account_tier` is `Premium` *and* `account_kind` is one of `BlockBlobStorage` or `FileStorage`.
     * 
     */
    @Export(name="infrastructureEncryptionEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> infrastructureEncryptionEnabled;

    /**
     * @return Is infrastructure encryption enabled? Changing this forces a new resource to be created. Defaults to `false`.
     * 
     * &gt; **Note:** This can only be `true` when `account_kind` is `StorageV2` or when `account_tier` is `Premium` *and* `account_kind` is one of `BlockBlobStorage` or `FileStorage`.
     * 
     */
    public Output<Optional<Boolean>> infrastructureEncryptionEnabled() {
        return Codegen.optional(this.infrastructureEncryptionEnabled);
    }
    /**
     * Is Hierarchical Namespace enabled? This can be used with Azure Data Lake Storage Gen 2 ([see here for more information](https://docs.microsoft.com/azure/storage/blobs/data-lake-storage-quickstart-create-account/)). Changing this forces a new resource to be created.
     * 
     * &gt; **Note:** This can only be `true` when `account_tier` is `Standard` or when `account_tier` is `Premium` *and* `account_kind` is `BlockBlobStorage`
     * 
     */
    @Export(name="isHnsEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> isHnsEnabled;

    /**
     * @return Is Hierarchical Namespace enabled? This can be used with Azure Data Lake Storage Gen 2 ([see here for more information](https://docs.microsoft.com/azure/storage/blobs/data-lake-storage-quickstart-create-account/)). Changing this forces a new resource to be created.
     * 
     * &gt; **Note:** This can only be `true` when `account_tier` is `Standard` or when `account_tier` is `Premium` *and* `account_kind` is `BlockBlobStorage`
     * 
     */
    public Output<Optional<Boolean>> isHnsEnabled() {
        return Codegen.optional(this.isHnsEnabled);
    }
    /**
     * Are Large File Shares Enabled? Defaults to `false`.
     * 
     * &gt; **Note:** Large File Shares are enabled by default when using an `account_kind` of `FileStorage`.
     * 
     */
    @Export(name="largeFileShareEnabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> largeFileShareEnabled;

    /**
     * @return Are Large File Shares Enabled? Defaults to `false`.
     * 
     * &gt; **Note:** Large File Shares are enabled by default when using an `account_kind` of `FileStorage`.
     * 
     */
    public Output<Boolean> largeFileShareEnabled() {
        return this.largeFileShareEnabled;
    }
    /**
     * Is Local User Enabled? Defaults to `true`.
     * 
     */
    @Export(name="localUserEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> localUserEnabled;

    /**
     * @return Is Local User Enabled? Defaults to `true`.
     * 
     */
    public Output<Optional<Boolean>> localUserEnabled() {
        return Codegen.optional(this.localUserEnabled);
    }
    /**
     * Specifies the supported Azure location where the resource exists. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="location", refs={String.class}, tree="[0]")
    private Output<String> location;

    /**
     * @return Specifies the supported Azure location where the resource exists. Changing this forces a new resource to be created.
     * 
     */
    public Output<String> location() {
        return this.location;
    }
    /**
     * The minimum supported TLS version for the storage account. Possible values are `TLS1_0`, `TLS1_1`, and `TLS1_2`. Defaults to `TLS1_2` for new storage accounts.
     * 
     * &gt; **Note:** Azure Services will require TLS 1.2+ by August 2025, please see this [announcement](https://azure.microsoft.com/en-us/updates/v2/update-retirement-tls1-0-tls1-1-versions-azure-services/) for more.
     * 
     * &gt; **Note:** At this time `min_tls_version` is only supported in the Public Cloud, China Cloud, and US Government Cloud.
     * 
     */
    @Export(name="minTlsVersion", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> minTlsVersion;

    /**
     * @return The minimum supported TLS version for the storage account. Possible values are `TLS1_0`, `TLS1_1`, and `TLS1_2`. Defaults to `TLS1_2` for new storage accounts.
     * 
     * &gt; **Note:** Azure Services will require TLS 1.2+ by August 2025, please see this [announcement](https://azure.microsoft.com/en-us/updates/v2/update-retirement-tls1-0-tls1-1-versions-azure-services/) for more.
     * 
     * &gt; **Note:** At this time `min_tls_version` is only supported in the Public Cloud, China Cloud, and US Government Cloud.
     * 
     */
    public Output<Optional<String>> minTlsVersion() {
        return Codegen.optional(this.minTlsVersion);
    }
    /**
     * Specifies the name of the storage account. Only lowercase Alphanumeric characters allowed. Changing this forces a new resource to be created. This must be unique across the entire Azure service, not just within the resource group.
     * 
     */
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    /**
     * @return Specifies the name of the storage account. Only lowercase Alphanumeric characters allowed. Changing this forces a new resource to be created. This must be unique across the entire Azure service, not just within the resource group.
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * A `network_rules` block as documented below.
     * 
     */
    @Export(name="networkRules", refs={AccountNetworkRules.class}, tree="[0]")
    private Output<AccountNetworkRules> networkRules;

    /**
     * @return A `network_rules` block as documented below.
     * 
     */
    public Output<AccountNetworkRules> networkRules() {
        return this.networkRules;
    }
    /**
     * Is NFSv3 protocol enabled? Changing this forces a new resource to be created. Defaults to `false`.
     * 
     * &gt; **Note:** This can only be `true` when `account_tier` is `Standard` and `account_kind` is `StorageV2`, or `account_tier` is `Premium` and `account_kind` is `BlockBlobStorage`. Additionally, the `is_hns_enabled` is `true` and `account_replication_type` must be `LRS` or `RAGRS`.
     * 
     */
    @Export(name="nfsv3Enabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> nfsv3Enabled;

    /**
     * @return Is NFSv3 protocol enabled? Changing this forces a new resource to be created. Defaults to `false`.
     * 
     * &gt; **Note:** This can only be `true` when `account_tier` is `Standard` and `account_kind` is `StorageV2`, or `account_tier` is `Premium` and `account_kind` is `BlockBlobStorage`. Additionally, the `is_hns_enabled` is `true` and `account_replication_type` must be `LRS` or `RAGRS`.
     * 
     */
    public Output<Optional<Boolean>> nfsv3Enabled() {
        return Codegen.optional(this.nfsv3Enabled);
    }
    /**
     * The primary access key for the storage account.
     * 
     */
    @Export(name="primaryAccessKey", refs={String.class}, tree="[0]")
    private Output<String> primaryAccessKey;

    /**
     * @return The primary access key for the storage account.
     * 
     */
    public Output<String> primaryAccessKey() {
        return this.primaryAccessKey;
    }
    /**
     * The connection string associated with the primary blob location.
     * 
     */
    @Export(name="primaryBlobConnectionString", refs={String.class}, tree="[0]")
    private Output<String> primaryBlobConnectionString;

    /**
     * @return The connection string associated with the primary blob location.
     * 
     */
    public Output<String> primaryBlobConnectionString() {
        return this.primaryBlobConnectionString;
    }
    /**
     * The endpoint URL for blob storage in the primary location.
     * 
     */
    @Export(name="primaryBlobEndpoint", refs={String.class}, tree="[0]")
    private Output<String> primaryBlobEndpoint;

    /**
     * @return The endpoint URL for blob storage in the primary location.
     * 
     */
    public Output<String> primaryBlobEndpoint() {
        return this.primaryBlobEndpoint;
    }
    /**
     * The hostname with port if applicable for blob storage in the primary location.
     * 
     */
    @Export(name="primaryBlobHost", refs={String.class}, tree="[0]")
    private Output<String> primaryBlobHost;

    /**
     * @return The hostname with port if applicable for blob storage in the primary location.
     * 
     */
    public Output<String> primaryBlobHost() {
        return this.primaryBlobHost;
    }
    /**
     * The internet routing endpoint URL for blob storage in the primary location.
     * 
     */
    @Export(name="primaryBlobInternetEndpoint", refs={String.class}, tree="[0]")
    private Output<String> primaryBlobInternetEndpoint;

    /**
     * @return The internet routing endpoint URL for blob storage in the primary location.
     * 
     */
    public Output<String> primaryBlobInternetEndpoint() {
        return this.primaryBlobInternetEndpoint;
    }
    /**
     * The internet routing hostname with port if applicable for blob storage in the primary location.
     * 
     */
    @Export(name="primaryBlobInternetHost", refs={String.class}, tree="[0]")
    private Output<String> primaryBlobInternetHost;

    /**
     * @return The internet routing hostname with port if applicable for blob storage in the primary location.
     * 
     */
    public Output<String> primaryBlobInternetHost() {
        return this.primaryBlobInternetHost;
    }
    /**
     * The microsoft routing endpoint URL for blob storage in the primary location.
     * 
     */
    @Export(name="primaryBlobMicrosoftEndpoint", refs={String.class}, tree="[0]")
    private Output<String> primaryBlobMicrosoftEndpoint;

    /**
     * @return The microsoft routing endpoint URL for blob storage in the primary location.
     * 
     */
    public Output<String> primaryBlobMicrosoftEndpoint() {
        return this.primaryBlobMicrosoftEndpoint;
    }
    /**
     * The microsoft routing hostname with port if applicable for blob storage in the primary location.
     * 
     */
    @Export(name="primaryBlobMicrosoftHost", refs={String.class}, tree="[0]")
    private Output<String> primaryBlobMicrosoftHost;

    /**
     * @return The microsoft routing hostname with port if applicable for blob storage in the primary location.
     * 
     */
    public Output<String> primaryBlobMicrosoftHost() {
        return this.primaryBlobMicrosoftHost;
    }
    /**
     * The connection string associated with the primary location.
     * 
     */
    @Export(name="primaryConnectionString", refs={String.class}, tree="[0]")
    private Output<String> primaryConnectionString;

    /**
     * @return The connection string associated with the primary location.
     * 
     */
    public Output<String> primaryConnectionString() {
        return this.primaryConnectionString;
    }
    /**
     * The endpoint URL for DFS storage in the primary location.
     * 
     */
    @Export(name="primaryDfsEndpoint", refs={String.class}, tree="[0]")
    private Output<String> primaryDfsEndpoint;

    /**
     * @return The endpoint URL for DFS storage in the primary location.
     * 
     */
    public Output<String> primaryDfsEndpoint() {
        return this.primaryDfsEndpoint;
    }
    /**
     * The hostname with port if applicable for DFS storage in the primary location.
     * 
     */
    @Export(name="primaryDfsHost", refs={String.class}, tree="[0]")
    private Output<String> primaryDfsHost;

    /**
     * @return The hostname with port if applicable for DFS storage in the primary location.
     * 
     */
    public Output<String> primaryDfsHost() {
        return this.primaryDfsHost;
    }
    /**
     * The internet routing endpoint URL for DFS storage in the primary location.
     * 
     */
    @Export(name="primaryDfsInternetEndpoint", refs={String.class}, tree="[0]")
    private Output<String> primaryDfsInternetEndpoint;

    /**
     * @return The internet routing endpoint URL for DFS storage in the primary location.
     * 
     */
    public Output<String> primaryDfsInternetEndpoint() {
        return this.primaryDfsInternetEndpoint;
    }
    /**
     * The internet routing hostname with port if applicable for DFS storage in the primary location.
     * 
     */
    @Export(name="primaryDfsInternetHost", refs={String.class}, tree="[0]")
    private Output<String> primaryDfsInternetHost;

    /**
     * @return The internet routing hostname with port if applicable for DFS storage in the primary location.
     * 
     */
    public Output<String> primaryDfsInternetHost() {
        return this.primaryDfsInternetHost;
    }
    /**
     * The microsoft routing endpoint URL for DFS storage in the primary location.
     * 
     */
    @Export(name="primaryDfsMicrosoftEndpoint", refs={String.class}, tree="[0]")
    private Output<String> primaryDfsMicrosoftEndpoint;

    /**
     * @return The microsoft routing endpoint URL for DFS storage in the primary location.
     * 
     */
    public Output<String> primaryDfsMicrosoftEndpoint() {
        return this.primaryDfsMicrosoftEndpoint;
    }
    /**
     * The microsoft routing hostname with port if applicable for DFS storage in the primary location.
     * 
     */
    @Export(name="primaryDfsMicrosoftHost", refs={String.class}, tree="[0]")
    private Output<String> primaryDfsMicrosoftHost;

    /**
     * @return The microsoft routing hostname with port if applicable for DFS storage in the primary location.
     * 
     */
    public Output<String> primaryDfsMicrosoftHost() {
        return this.primaryDfsMicrosoftHost;
    }
    /**
     * The endpoint URL for file storage in the primary location.
     * 
     */
    @Export(name="primaryFileEndpoint", refs={String.class}, tree="[0]")
    private Output<String> primaryFileEndpoint;

    /**
     * @return The endpoint URL for file storage in the primary location.
     * 
     */
    public Output<String> primaryFileEndpoint() {
        return this.primaryFileEndpoint;
    }
    /**
     * The hostname with port if applicable for file storage in the primary location.
     * 
     */
    @Export(name="primaryFileHost", refs={String.class}, tree="[0]")
    private Output<String> primaryFileHost;

    /**
     * @return The hostname with port if applicable for file storage in the primary location.
     * 
     */
    public Output<String> primaryFileHost() {
        return this.primaryFileHost;
    }
    /**
     * The internet routing endpoint URL for file storage in the primary location.
     * 
     */
    @Export(name="primaryFileInternetEndpoint", refs={String.class}, tree="[0]")
    private Output<String> primaryFileInternetEndpoint;

    /**
     * @return The internet routing endpoint URL for file storage in the primary location.
     * 
     */
    public Output<String> primaryFileInternetEndpoint() {
        return this.primaryFileInternetEndpoint;
    }
    /**
     * The internet routing hostname with port if applicable for file storage in the primary location.
     * 
     */
    @Export(name="primaryFileInternetHost", refs={String.class}, tree="[0]")
    private Output<String> primaryFileInternetHost;

    /**
     * @return The internet routing hostname with port if applicable for file storage in the primary location.
     * 
     */
    public Output<String> primaryFileInternetHost() {
        return this.primaryFileInternetHost;
    }
    /**
     * The microsoft routing endpoint URL for file storage in the primary location.
     * 
     */
    @Export(name="primaryFileMicrosoftEndpoint", refs={String.class}, tree="[0]")
    private Output<String> primaryFileMicrosoftEndpoint;

    /**
     * @return The microsoft routing endpoint URL for file storage in the primary location.
     * 
     */
    public Output<String> primaryFileMicrosoftEndpoint() {
        return this.primaryFileMicrosoftEndpoint;
    }
    /**
     * The microsoft routing hostname with port if applicable for file storage in the primary location.
     * 
     */
    @Export(name="primaryFileMicrosoftHost", refs={String.class}, tree="[0]")
    private Output<String> primaryFileMicrosoftHost;

    /**
     * @return The microsoft routing hostname with port if applicable for file storage in the primary location.
     * 
     */
    public Output<String> primaryFileMicrosoftHost() {
        return this.primaryFileMicrosoftHost;
    }
    /**
     * The primary location of the storage account.
     * 
     */
    @Export(name="primaryLocation", refs={String.class}, tree="[0]")
    private Output<String> primaryLocation;

    /**
     * @return The primary location of the storage account.
     * 
     */
    public Output<String> primaryLocation() {
        return this.primaryLocation;
    }
    /**
     * The endpoint URL for queue storage in the primary location.
     * 
     */
    @Export(name="primaryQueueEndpoint", refs={String.class}, tree="[0]")
    private Output<String> primaryQueueEndpoint;

    /**
     * @return The endpoint URL for queue storage in the primary location.
     * 
     */
    public Output<String> primaryQueueEndpoint() {
        return this.primaryQueueEndpoint;
    }
    /**
     * The hostname with port if applicable for queue storage in the primary location.
     * 
     */
    @Export(name="primaryQueueHost", refs={String.class}, tree="[0]")
    private Output<String> primaryQueueHost;

    /**
     * @return The hostname with port if applicable for queue storage in the primary location.
     * 
     */
    public Output<String> primaryQueueHost() {
        return this.primaryQueueHost;
    }
    /**
     * The microsoft routing endpoint URL for queue storage in the primary location.
     * 
     */
    @Export(name="primaryQueueMicrosoftEndpoint", refs={String.class}, tree="[0]")
    private Output<String> primaryQueueMicrosoftEndpoint;

    /**
     * @return The microsoft routing endpoint URL for queue storage in the primary location.
     * 
     */
    public Output<String> primaryQueueMicrosoftEndpoint() {
        return this.primaryQueueMicrosoftEndpoint;
    }
    /**
     * The microsoft routing hostname with port if applicable for queue storage in the primary location.
     * 
     */
    @Export(name="primaryQueueMicrosoftHost", refs={String.class}, tree="[0]")
    private Output<String> primaryQueueMicrosoftHost;

    /**
     * @return The microsoft routing hostname with port if applicable for queue storage in the primary location.
     * 
     */
    public Output<String> primaryQueueMicrosoftHost() {
        return this.primaryQueueMicrosoftHost;
    }
    /**
     * The endpoint URL for table storage in the primary location.
     * 
     */
    @Export(name="primaryTableEndpoint", refs={String.class}, tree="[0]")
    private Output<String> primaryTableEndpoint;

    /**
     * @return The endpoint URL for table storage in the primary location.
     * 
     */
    public Output<String> primaryTableEndpoint() {
        return this.primaryTableEndpoint;
    }
    /**
     * The hostname with port if applicable for table storage in the primary location.
     * 
     */
    @Export(name="primaryTableHost", refs={String.class}, tree="[0]")
    private Output<String> primaryTableHost;

    /**
     * @return The hostname with port if applicable for table storage in the primary location.
     * 
     */
    public Output<String> primaryTableHost() {
        return this.primaryTableHost;
    }
    /**
     * The microsoft routing endpoint URL for table storage in the primary location.
     * 
     */
    @Export(name="primaryTableMicrosoftEndpoint", refs={String.class}, tree="[0]")
    private Output<String> primaryTableMicrosoftEndpoint;

    /**
     * @return The microsoft routing endpoint URL for table storage in the primary location.
     * 
     */
    public Output<String> primaryTableMicrosoftEndpoint() {
        return this.primaryTableMicrosoftEndpoint;
    }
    /**
     * The microsoft routing hostname with port if applicable for table storage in the primary location.
     * 
     */
    @Export(name="primaryTableMicrosoftHost", refs={String.class}, tree="[0]")
    private Output<String> primaryTableMicrosoftHost;

    /**
     * @return The microsoft routing hostname with port if applicable for table storage in the primary location.
     * 
     */
    public Output<String> primaryTableMicrosoftHost() {
        return this.primaryTableMicrosoftHost;
    }
    /**
     * The endpoint URL for web storage in the primary location.
     * 
     */
    @Export(name="primaryWebEndpoint", refs={String.class}, tree="[0]")
    private Output<String> primaryWebEndpoint;

    /**
     * @return The endpoint URL for web storage in the primary location.
     * 
     */
    public Output<String> primaryWebEndpoint() {
        return this.primaryWebEndpoint;
    }
    /**
     * The hostname with port if applicable for web storage in the primary location.
     * 
     */
    @Export(name="primaryWebHost", refs={String.class}, tree="[0]")
    private Output<String> primaryWebHost;

    /**
     * @return The hostname with port if applicable for web storage in the primary location.
     * 
     */
    public Output<String> primaryWebHost() {
        return this.primaryWebHost;
    }
    /**
     * The internet routing endpoint URL for web storage in the primary location.
     * 
     */
    @Export(name="primaryWebInternetEndpoint", refs={String.class}, tree="[0]")
    private Output<String> primaryWebInternetEndpoint;

    /**
     * @return The internet routing endpoint URL for web storage in the primary location.
     * 
     */
    public Output<String> primaryWebInternetEndpoint() {
        return this.primaryWebInternetEndpoint;
    }
    /**
     * The internet routing hostname with port if applicable for web storage in the primary location.
     * 
     */
    @Export(name="primaryWebInternetHost", refs={String.class}, tree="[0]")
    private Output<String> primaryWebInternetHost;

    /**
     * @return The internet routing hostname with port if applicable for web storage in the primary location.
     * 
     */
    public Output<String> primaryWebInternetHost() {
        return this.primaryWebInternetHost;
    }
    /**
     * The microsoft routing endpoint URL for web storage in the primary location.
     * 
     */
    @Export(name="primaryWebMicrosoftEndpoint", refs={String.class}, tree="[0]")
    private Output<String> primaryWebMicrosoftEndpoint;

    /**
     * @return The microsoft routing endpoint URL for web storage in the primary location.
     * 
     */
    public Output<String> primaryWebMicrosoftEndpoint() {
        return this.primaryWebMicrosoftEndpoint;
    }
    /**
     * The microsoft routing hostname with port if applicable for web storage in the primary location.
     * 
     */
    @Export(name="primaryWebMicrosoftHost", refs={String.class}, tree="[0]")
    private Output<String> primaryWebMicrosoftHost;

    /**
     * @return The microsoft routing hostname with port if applicable for web storage in the primary location.
     * 
     */
    public Output<String> primaryWebMicrosoftHost() {
        return this.primaryWebMicrosoftHost;
    }
    /**
     * Whether the public network access is enabled? Defaults to `true`.
     * 
     */
    @Export(name="publicNetworkAccessEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> publicNetworkAccessEnabled;

    /**
     * @return Whether the public network access is enabled? Defaults to `true`.
     * 
     */
    public Output<Optional<Boolean>> publicNetworkAccessEnabled() {
        return Codegen.optional(this.publicNetworkAccessEnabled);
    }
    /**
     * The encryption type of the queue service. Possible values are `Service` and `Account`. Changing this forces a new resource to be created. Default value is `Service`.
     * 
     */
    @Export(name="queueEncryptionKeyType", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> queueEncryptionKeyType;

    /**
     * @return The encryption type of the queue service. Possible values are `Service` and `Account`. Changing this forces a new resource to be created. Default value is `Service`.
     * 
     */
    public Output<Optional<String>> queueEncryptionKeyType() {
        return Codegen.optional(this.queueEncryptionKeyType);
    }
    /**
     * A `queue_properties` block as defined below.
     * 
     * &gt; **Note:** `queue_properties` can only be configured when `account_tier` is set to `Standard` and `account_kind` is set to either `Storage` or `StorageV2`.
     * 
     * @deprecated
     * this block has been deprecated and superseded by the `azure.storage.AccountQueueProperties` resource and will be removed in v5.0 of the AzureRM provider
     * 
     */
    @Deprecated /* this block has been deprecated and superseded by the `azure.storage.AccountQueueProperties` resource and will be removed in v5.0 of the AzureRM provider */
    @Export(name="queueProperties", refs={AccountQueueProperties.class}, tree="[0]")
    private Output<AccountQueueProperties> queueProperties;

    /**
     * @return A `queue_properties` block as defined below.
     * 
     * &gt; **Note:** `queue_properties` can only be configured when `account_tier` is set to `Standard` and `account_kind` is set to either `Storage` or `StorageV2`.
     * 
     */
    public Output<AccountQueueProperties> queueProperties() {
        return this.queueProperties;
    }
    /**
     * The name of the resource group in which to create the storage account. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="resourceGroupName", refs={String.class}, tree="[0]")
    private Output<String> resourceGroupName;

    /**
     * @return The name of the resource group in which to create the storage account. Changing this forces a new resource to be created.
     * 
     */
    public Output<String> resourceGroupName() {
        return this.resourceGroupName;
    }
    /**
     * A `routing` block as defined below.
     * 
     */
    @Export(name="routing", refs={AccountRouting.class}, tree="[0]")
    private Output<AccountRouting> routing;

    /**
     * @return A `routing` block as defined below.
     * 
     */
    public Output<AccountRouting> routing() {
        return this.routing;
    }
    /**
     * A `sas_policy` block as defined below.
     * 
     */
    @Export(name="sasPolicy", refs={AccountSasPolicy.class}, tree="[0]")
    private Output</* @Nullable */ AccountSasPolicy> sasPolicy;

    /**
     * @return A `sas_policy` block as defined below.
     * 
     */
    public Output<Optional<AccountSasPolicy>> sasPolicy() {
        return Codegen.optional(this.sasPolicy);
    }
    /**
     * The secondary access key for the storage account.
     * 
     */
    @Export(name="secondaryAccessKey", refs={String.class}, tree="[0]")
    private Output<String> secondaryAccessKey;

    /**
     * @return The secondary access key for the storage account.
     * 
     */
    public Output<String> secondaryAccessKey() {
        return this.secondaryAccessKey;
    }
    /**
     * The connection string associated with the secondary blob location.
     * 
     */
    @Export(name="secondaryBlobConnectionString", refs={String.class}, tree="[0]")
    private Output<String> secondaryBlobConnectionString;

    /**
     * @return The connection string associated with the secondary blob location.
     * 
     */
    public Output<String> secondaryBlobConnectionString() {
        return this.secondaryBlobConnectionString;
    }
    /**
     * The endpoint URL for blob storage in the secondary location.
     * 
     */
    @Export(name="secondaryBlobEndpoint", refs={String.class}, tree="[0]")
    private Output<String> secondaryBlobEndpoint;

    /**
     * @return The endpoint URL for blob storage in the secondary location.
     * 
     */
    public Output<String> secondaryBlobEndpoint() {
        return this.secondaryBlobEndpoint;
    }
    /**
     * The hostname with port if applicable for blob storage in the secondary location.
     * 
     */
    @Export(name="secondaryBlobHost", refs={String.class}, tree="[0]")
    private Output<String> secondaryBlobHost;

    /**
     * @return The hostname with port if applicable for blob storage in the secondary location.
     * 
     */
    public Output<String> secondaryBlobHost() {
        return this.secondaryBlobHost;
    }
    /**
     * The internet routing endpoint URL for blob storage in the secondary location.
     * 
     */
    @Export(name="secondaryBlobInternetEndpoint", refs={String.class}, tree="[0]")
    private Output<String> secondaryBlobInternetEndpoint;

    /**
     * @return The internet routing endpoint URL for blob storage in the secondary location.
     * 
     */
    public Output<String> secondaryBlobInternetEndpoint() {
        return this.secondaryBlobInternetEndpoint;
    }
    /**
     * The internet routing hostname with port if applicable for blob storage in the secondary location.
     * 
     */
    @Export(name="secondaryBlobInternetHost", refs={String.class}, tree="[0]")
    private Output<String> secondaryBlobInternetHost;

    /**
     * @return The internet routing hostname with port if applicable for blob storage in the secondary location.
     * 
     */
    public Output<String> secondaryBlobInternetHost() {
        return this.secondaryBlobInternetHost;
    }
    /**
     * The microsoft routing endpoint URL for blob storage in the secondary location.
     * 
     */
    @Export(name="secondaryBlobMicrosoftEndpoint", refs={String.class}, tree="[0]")
    private Output<String> secondaryBlobMicrosoftEndpoint;

    /**
     * @return The microsoft routing endpoint URL for blob storage in the secondary location.
     * 
     */
    public Output<String> secondaryBlobMicrosoftEndpoint() {
        return this.secondaryBlobMicrosoftEndpoint;
    }
    /**
     * The microsoft routing hostname with port if applicable for blob storage in the secondary location.
     * 
     */
    @Export(name="secondaryBlobMicrosoftHost", refs={String.class}, tree="[0]")
    private Output<String> secondaryBlobMicrosoftHost;

    /**
     * @return The microsoft routing hostname with port if applicable for blob storage in the secondary location.
     * 
     */
    public Output<String> secondaryBlobMicrosoftHost() {
        return this.secondaryBlobMicrosoftHost;
    }
    /**
     * The connection string associated with the secondary location.
     * 
     */
    @Export(name="secondaryConnectionString", refs={String.class}, tree="[0]")
    private Output<String> secondaryConnectionString;

    /**
     * @return The connection string associated with the secondary location.
     * 
     */
    public Output<String> secondaryConnectionString() {
        return this.secondaryConnectionString;
    }
    /**
     * The endpoint URL for DFS storage in the secondary location.
     * 
     */
    @Export(name="secondaryDfsEndpoint", refs={String.class}, tree="[0]")
    private Output<String> secondaryDfsEndpoint;

    /**
     * @return The endpoint URL for DFS storage in the secondary location.
     * 
     */
    public Output<String> secondaryDfsEndpoint() {
        return this.secondaryDfsEndpoint;
    }
    /**
     * The hostname with port if applicable for DFS storage in the secondary location.
     * 
     */
    @Export(name="secondaryDfsHost", refs={String.class}, tree="[0]")
    private Output<String> secondaryDfsHost;

    /**
     * @return The hostname with port if applicable for DFS storage in the secondary location.
     * 
     */
    public Output<String> secondaryDfsHost() {
        return this.secondaryDfsHost;
    }
    /**
     * The internet routing endpoint URL for DFS storage in the secondary location.
     * 
     */
    @Export(name="secondaryDfsInternetEndpoint", refs={String.class}, tree="[0]")
    private Output<String> secondaryDfsInternetEndpoint;

    /**
     * @return The internet routing endpoint URL for DFS storage in the secondary location.
     * 
     */
    public Output<String> secondaryDfsInternetEndpoint() {
        return this.secondaryDfsInternetEndpoint;
    }
    /**
     * The internet routing hostname with port if applicable for DFS storage in the secondary location.
     * 
     */
    @Export(name="secondaryDfsInternetHost", refs={String.class}, tree="[0]")
    private Output<String> secondaryDfsInternetHost;

    /**
     * @return The internet routing hostname with port if applicable for DFS storage in the secondary location.
     * 
     */
    public Output<String> secondaryDfsInternetHost() {
        return this.secondaryDfsInternetHost;
    }
    /**
     * The microsoft routing endpoint URL for DFS storage in the secondary location.
     * 
     */
    @Export(name="secondaryDfsMicrosoftEndpoint", refs={String.class}, tree="[0]")
    private Output<String> secondaryDfsMicrosoftEndpoint;

    /**
     * @return The microsoft routing endpoint URL for DFS storage in the secondary location.
     * 
     */
    public Output<String> secondaryDfsMicrosoftEndpoint() {
        return this.secondaryDfsMicrosoftEndpoint;
    }
    /**
     * The microsoft routing hostname with port if applicable for DFS storage in the secondary location.
     * 
     */
    @Export(name="secondaryDfsMicrosoftHost", refs={String.class}, tree="[0]")
    private Output<String> secondaryDfsMicrosoftHost;

    /**
     * @return The microsoft routing hostname with port if applicable for DFS storage in the secondary location.
     * 
     */
    public Output<String> secondaryDfsMicrosoftHost() {
        return this.secondaryDfsMicrosoftHost;
    }
    /**
     * The endpoint URL for file storage in the secondary location.
     * 
     */
    @Export(name="secondaryFileEndpoint", refs={String.class}, tree="[0]")
    private Output<String> secondaryFileEndpoint;

    /**
     * @return The endpoint URL for file storage in the secondary location.
     * 
     */
    public Output<String> secondaryFileEndpoint() {
        return this.secondaryFileEndpoint;
    }
    /**
     * The hostname with port if applicable for file storage in the secondary location.
     * 
     */
    @Export(name="secondaryFileHost", refs={String.class}, tree="[0]")
    private Output<String> secondaryFileHost;

    /**
     * @return The hostname with port if applicable for file storage in the secondary location.
     * 
     */
    public Output<String> secondaryFileHost() {
        return this.secondaryFileHost;
    }
    /**
     * The internet routing endpoint URL for file storage in the secondary location.
     * 
     */
    @Export(name="secondaryFileInternetEndpoint", refs={String.class}, tree="[0]")
    private Output<String> secondaryFileInternetEndpoint;

    /**
     * @return The internet routing endpoint URL for file storage in the secondary location.
     * 
     */
    public Output<String> secondaryFileInternetEndpoint() {
        return this.secondaryFileInternetEndpoint;
    }
    /**
     * The internet routing hostname with port if applicable for file storage in the secondary location.
     * 
     */
    @Export(name="secondaryFileInternetHost", refs={String.class}, tree="[0]")
    private Output<String> secondaryFileInternetHost;

    /**
     * @return The internet routing hostname with port if applicable for file storage in the secondary location.
     * 
     */
    public Output<String> secondaryFileInternetHost() {
        return this.secondaryFileInternetHost;
    }
    /**
     * The microsoft routing endpoint URL for file storage in the secondary location.
     * 
     */
    @Export(name="secondaryFileMicrosoftEndpoint", refs={String.class}, tree="[0]")
    private Output<String> secondaryFileMicrosoftEndpoint;

    /**
     * @return The microsoft routing endpoint URL for file storage in the secondary location.
     * 
     */
    public Output<String> secondaryFileMicrosoftEndpoint() {
        return this.secondaryFileMicrosoftEndpoint;
    }
    /**
     * The microsoft routing hostname with port if applicable for file storage in the secondary location.
     * 
     */
    @Export(name="secondaryFileMicrosoftHost", refs={String.class}, tree="[0]")
    private Output<String> secondaryFileMicrosoftHost;

    /**
     * @return The microsoft routing hostname with port if applicable for file storage in the secondary location.
     * 
     */
    public Output<String> secondaryFileMicrosoftHost() {
        return this.secondaryFileMicrosoftHost;
    }
    /**
     * The secondary location of the storage account.
     * 
     */
    @Export(name="secondaryLocation", refs={String.class}, tree="[0]")
    private Output<String> secondaryLocation;

    /**
     * @return The secondary location of the storage account.
     * 
     */
    public Output<String> secondaryLocation() {
        return this.secondaryLocation;
    }
    /**
     * The endpoint URL for queue storage in the secondary location.
     * 
     */
    @Export(name="secondaryQueueEndpoint", refs={String.class}, tree="[0]")
    private Output<String> secondaryQueueEndpoint;

    /**
     * @return The endpoint URL for queue storage in the secondary location.
     * 
     */
    public Output<String> secondaryQueueEndpoint() {
        return this.secondaryQueueEndpoint;
    }
    /**
     * The hostname with port if applicable for queue storage in the secondary location.
     * 
     */
    @Export(name="secondaryQueueHost", refs={String.class}, tree="[0]")
    private Output<String> secondaryQueueHost;

    /**
     * @return The hostname with port if applicable for queue storage in the secondary location.
     * 
     */
    public Output<String> secondaryQueueHost() {
        return this.secondaryQueueHost;
    }
    /**
     * The microsoft routing endpoint URL for queue storage in the secondary location.
     * 
     */
    @Export(name="secondaryQueueMicrosoftEndpoint", refs={String.class}, tree="[0]")
    private Output<String> secondaryQueueMicrosoftEndpoint;

    /**
     * @return The microsoft routing endpoint URL for queue storage in the secondary location.
     * 
     */
    public Output<String> secondaryQueueMicrosoftEndpoint() {
        return this.secondaryQueueMicrosoftEndpoint;
    }
    /**
     * The microsoft routing hostname with port if applicable for queue storage in the secondary location.
     * 
     */
    @Export(name="secondaryQueueMicrosoftHost", refs={String.class}, tree="[0]")
    private Output<String> secondaryQueueMicrosoftHost;

    /**
     * @return The microsoft routing hostname with port if applicable for queue storage in the secondary location.
     * 
     */
    public Output<String> secondaryQueueMicrosoftHost() {
        return this.secondaryQueueMicrosoftHost;
    }
    /**
     * The endpoint URL for table storage in the secondary location.
     * 
     */
    @Export(name="secondaryTableEndpoint", refs={String.class}, tree="[0]")
    private Output<String> secondaryTableEndpoint;

    /**
     * @return The endpoint URL for table storage in the secondary location.
     * 
     */
    public Output<String> secondaryTableEndpoint() {
        return this.secondaryTableEndpoint;
    }
    /**
     * The hostname with port if applicable for table storage in the secondary location.
     * 
     */
    @Export(name="secondaryTableHost", refs={String.class}, tree="[0]")
    private Output<String> secondaryTableHost;

    /**
     * @return The hostname with port if applicable for table storage in the secondary location.
     * 
     */
    public Output<String> secondaryTableHost() {
        return this.secondaryTableHost;
    }
    /**
     * The microsoft routing endpoint URL for table storage in the secondary location.
     * 
     */
    @Export(name="secondaryTableMicrosoftEndpoint", refs={String.class}, tree="[0]")
    private Output<String> secondaryTableMicrosoftEndpoint;

    /**
     * @return The microsoft routing endpoint URL for table storage in the secondary location.
     * 
     */
    public Output<String> secondaryTableMicrosoftEndpoint() {
        return this.secondaryTableMicrosoftEndpoint;
    }
    /**
     * The microsoft routing hostname with port if applicable for table storage in the secondary location.
     * 
     */
    @Export(name="secondaryTableMicrosoftHost", refs={String.class}, tree="[0]")
    private Output<String> secondaryTableMicrosoftHost;

    /**
     * @return The microsoft routing hostname with port if applicable for table storage in the secondary location.
     * 
     */
    public Output<String> secondaryTableMicrosoftHost() {
        return this.secondaryTableMicrosoftHost;
    }
    /**
     * The endpoint URL for web storage in the secondary location.
     * 
     */
    @Export(name="secondaryWebEndpoint", refs={String.class}, tree="[0]")
    private Output<String> secondaryWebEndpoint;

    /**
     * @return The endpoint URL for web storage in the secondary location.
     * 
     */
    public Output<String> secondaryWebEndpoint() {
        return this.secondaryWebEndpoint;
    }
    /**
     * The hostname with port if applicable for web storage in the secondary location.
     * 
     */
    @Export(name="secondaryWebHost", refs={String.class}, tree="[0]")
    private Output<String> secondaryWebHost;

    /**
     * @return The hostname with port if applicable for web storage in the secondary location.
     * 
     */
    public Output<String> secondaryWebHost() {
        return this.secondaryWebHost;
    }
    /**
     * The internet routing endpoint URL for web storage in the secondary location.
     * 
     */
    @Export(name="secondaryWebInternetEndpoint", refs={String.class}, tree="[0]")
    private Output<String> secondaryWebInternetEndpoint;

    /**
     * @return The internet routing endpoint URL for web storage in the secondary location.
     * 
     */
    public Output<String> secondaryWebInternetEndpoint() {
        return this.secondaryWebInternetEndpoint;
    }
    /**
     * The internet routing hostname with port if applicable for web storage in the secondary location.
     * 
     */
    @Export(name="secondaryWebInternetHost", refs={String.class}, tree="[0]")
    private Output<String> secondaryWebInternetHost;

    /**
     * @return The internet routing hostname with port if applicable for web storage in the secondary location.
     * 
     */
    public Output<String> secondaryWebInternetHost() {
        return this.secondaryWebInternetHost;
    }
    /**
     * The microsoft routing endpoint URL for web storage in the secondary location.
     * 
     */
    @Export(name="secondaryWebMicrosoftEndpoint", refs={String.class}, tree="[0]")
    private Output<String> secondaryWebMicrosoftEndpoint;

    /**
     * @return The microsoft routing endpoint URL for web storage in the secondary location.
     * 
     */
    public Output<String> secondaryWebMicrosoftEndpoint() {
        return this.secondaryWebMicrosoftEndpoint;
    }
    /**
     * The microsoft routing hostname with port if applicable for web storage in the secondary location.
     * 
     */
    @Export(name="secondaryWebMicrosoftHost", refs={String.class}, tree="[0]")
    private Output<String> secondaryWebMicrosoftHost;

    /**
     * @return The microsoft routing hostname with port if applicable for web storage in the secondary location.
     * 
     */
    public Output<String> secondaryWebMicrosoftHost() {
        return this.secondaryWebMicrosoftHost;
    }
    /**
     * Boolean, enable SFTP for the storage account
     * 
     * &gt; **Note:** SFTP support requires `is_hns_enabled` set to `true`. [More information on SFTP support can be found here](https://learn.microsoft.com/azure/storage/blobs/secure-file-transfer-protocol-support). Defaults to `false`
     * 
     */
    @Export(name="sftpEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> sftpEnabled;

    /**
     * @return Boolean, enable SFTP for the storage account
     * 
     * &gt; **Note:** SFTP support requires `is_hns_enabled` set to `true`. [More information on SFTP support can be found here](https://learn.microsoft.com/azure/storage/blobs/secure-file-transfer-protocol-support). Defaults to `false`
     * 
     */
    public Output<Optional<Boolean>> sftpEnabled() {
        return Codegen.optional(this.sftpEnabled);
    }
    /**
     * A `share_properties` block as defined below.
     * 
     * &gt; **Note:** `share_properties` can only be configured when either `account_tier` is `Standard` and `account_kind` is either `Storage` or `StorageV2` - or when `account_tier` is `Premium` and `account_kind` is `FileStorage`.
     * 
     */
    @Export(name="shareProperties", refs={AccountShareProperties.class}, tree="[0]")
    private Output<AccountShareProperties> shareProperties;

    /**
     * @return A `share_properties` block as defined below.
     * 
     * &gt; **Note:** `share_properties` can only be configured when either `account_tier` is `Standard` and `account_kind` is either `Storage` or `StorageV2` - or when `account_tier` is `Premium` and `account_kind` is `FileStorage`.
     * 
     */
    public Output<AccountShareProperties> shareProperties() {
        return this.shareProperties;
    }
    @Export(name="sharedAccessKeyEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> sharedAccessKeyEnabled;

    public Output<Optional<Boolean>> sharedAccessKeyEnabled() {
        return Codegen.optional(this.sharedAccessKeyEnabled);
    }
    /**
     * A `static_website` block as defined below.
     * 
     * &gt; **Note:** `static_website` can only be set when the `account_kind` is set to `StorageV2` or `BlockBlobStorage`.
     * 
     * &gt; **Note:** If `static_website` is specified, the service will automatically create a `azure.storage.Container` named `$web`.
     * 
     * @deprecated
     * this block has been deprecated and superseded by the `azure.storage.AccountStaticWebsite` resource and will be removed in v5.0 of the AzureRM provider
     * 
     */
    @Deprecated /* this block has been deprecated and superseded by the `azure.storage.AccountStaticWebsite` resource and will be removed in v5.0 of the AzureRM provider */
    @Export(name="staticWebsite", refs={AccountStaticWebsite.class}, tree="[0]")
    private Output<AccountStaticWebsite> staticWebsite;

    /**
     * @return A `static_website` block as defined below.
     * 
     * &gt; **Note:** `static_website` can only be set when the `account_kind` is set to `StorageV2` or `BlockBlobStorage`.
     * 
     * &gt; **Note:** If `static_website` is specified, the service will automatically create a `azure.storage.Container` named `$web`.
     * 
     */
    public Output<AccountStaticWebsite> staticWebsite() {
        return this.staticWebsite;
    }
    /**
     * The encryption type of the table service. Possible values are `Service` and `Account`. Changing this forces a new resource to be created. Default value is `Service`.
     * 
     * &gt; **Note:** `queue_encryption_key_type` and `table_encryption_key_type` cannot be set to `Account` when `account_kind` is set `Storage`
     * 
     */
    @Export(name="tableEncryptionKeyType", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tableEncryptionKeyType;

    /**
     * @return The encryption type of the table service. Possible values are `Service` and `Account`. Changing this forces a new resource to be created. Default value is `Service`.
     * 
     * &gt; **Note:** `queue_encryption_key_type` and `table_encryption_key_type` cannot be set to `Account` when `account_kind` is set `Storage`
     * 
     */
    public Output<Optional<String>> tableEncryptionKeyType() {
        return Codegen.optional(this.tableEncryptionKeyType);
    }
    /**
     * A mapping of tags to assign to the resource.
     * 
     */
    @Export(name="tags", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output</* @Nullable */ Map<String,String>> tags;

    /**
     * @return A mapping of tags to assign to the resource.
     * 
     */
    public Output<Optional<Map<String,String>>> tags() {
        return Codegen.optional(this.tags);
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public Account(java.lang.String name) {
        this(name, AccountArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public Account(java.lang.String name, AccountArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public Account(java.lang.String name, AccountArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("azure:storage/account:Account", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private Account(java.lang.String name, Output<java.lang.String> id, @Nullable AccountState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("azure:storage/account:Account", name, state, makeResourceOptions(options, id), false);
    }

    private static AccountArgs makeArgs(AccountArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? AccountArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .additionalSecretOutputs(List.of(
                "primaryAccessKey",
                "primaryBlobConnectionString",
                "primaryConnectionString",
                "secondaryAccessKey",
                "secondaryBlobConnectionString",
                "secondaryConnectionString"
            ))
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static Account get(java.lang.String name, Output<java.lang.String> id, @Nullable AccountState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new Account(name, id, state, options);
    }
}
