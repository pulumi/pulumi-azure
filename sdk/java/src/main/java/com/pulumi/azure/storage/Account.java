// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.azure.storage;

import com.pulumi.azure.Utilities;
import com.pulumi.azure.storage.AccountArgs;
import com.pulumi.azure.storage.inputs.AccountState;
import com.pulumi.azure.storage.outputs.AccountAzureFilesAuthentication;
import com.pulumi.azure.storage.outputs.AccountBlobProperties;
import com.pulumi.azure.storage.outputs.AccountCustomDomain;
import com.pulumi.azure.storage.outputs.AccountCustomerManagedKey;
import com.pulumi.azure.storage.outputs.AccountIdentity;
import com.pulumi.azure.storage.outputs.AccountNetworkRules;
import com.pulumi.azure.storage.outputs.AccountQueueProperties;
import com.pulumi.azure.storage.outputs.AccountRouting;
import com.pulumi.azure.storage.outputs.AccountShareProperties;
import com.pulumi.azure.storage.outputs.AccountStaticWebsite;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import java.lang.Boolean;
import java.lang.String;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * Manages an Azure Storage Account.
 * 
 * ## Example Usage
 * ```java
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.azure.core.ResourceGroup;
 * import com.pulumi.azure.core.ResourceGroupArgs;
 * import com.pulumi.azure.storage.Account;
 * import com.pulumi.azure.storage.AccountArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var exampleResourceGroup = new ResourceGroup(&#34;exampleResourceGroup&#34;, ResourceGroupArgs.builder()        
 *             .location(&#34;West Europe&#34;)
 *             .build());
 * 
 *         var exampleAccount = new Account(&#34;exampleAccount&#34;, AccountArgs.builder()        
 *             .resourceGroupName(exampleResourceGroup.name())
 *             .location(exampleResourceGroup.location())
 *             .accountTier(&#34;Standard&#34;)
 *             .accountReplicationType(&#34;GRS&#34;)
 *             .tags(Map.of(&#34;environment&#34;, &#34;staging&#34;))
 *             .build());
 * 
 *     }
 * }
 * ```
 * ### With Network Rules
 * ```java
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.azure.core.ResourceGroup;
 * import com.pulumi.azure.core.ResourceGroupArgs;
 * import com.pulumi.azure.network.VirtualNetwork;
 * import com.pulumi.azure.network.VirtualNetworkArgs;
 * import com.pulumi.azure.network.Subnet;
 * import com.pulumi.azure.network.SubnetArgs;
 * import com.pulumi.azure.storage.Account;
 * import com.pulumi.azure.storage.AccountArgs;
 * import com.pulumi.azure.storage.inputs.AccountNetworkRulesArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var exampleResourceGroup = new ResourceGroup(&#34;exampleResourceGroup&#34;, ResourceGroupArgs.builder()        
 *             .location(&#34;West Europe&#34;)
 *             .build());
 * 
 *         var exampleVirtualNetwork = new VirtualNetwork(&#34;exampleVirtualNetwork&#34;, VirtualNetworkArgs.builder()        
 *             .addressSpaces(&#34;10.0.0.0/16&#34;)
 *             .location(exampleResourceGroup.location())
 *             .resourceGroupName(exampleResourceGroup.name())
 *             .build());
 * 
 *         var exampleSubnet = new Subnet(&#34;exampleSubnet&#34;, SubnetArgs.builder()        
 *             .resourceGroupName(exampleResourceGroup.name())
 *             .virtualNetworkName(exampleVirtualNetwork.name())
 *             .addressPrefixes(&#34;10.0.2.0/24&#34;)
 *             .serviceEndpoints(            
 *                 &#34;Microsoft.Sql&#34;,
 *                 &#34;Microsoft.Storage&#34;)
 *             .build());
 * 
 *         var exampleAccount = new Account(&#34;exampleAccount&#34;, AccountArgs.builder()        
 *             .resourceGroupName(exampleResourceGroup.name())
 *             .location(exampleResourceGroup.location())
 *             .accountTier(&#34;Standard&#34;)
 *             .accountReplicationType(&#34;LRS&#34;)
 *             .networkRules(AccountNetworkRulesArgs.builder()
 *                 .defaultAction(&#34;Deny&#34;)
 *                 .ipRules(&#34;100.0.0.1&#34;)
 *                 .virtualNetworkSubnetIds(exampleSubnet.id())
 *                 .build())
 *             .tags(Map.of(&#34;environment&#34;, &#34;staging&#34;))
 *             .build());
 * 
 *     }
 * }
 * ```
 * 
 * ## Import
 * 
 * Storage Accounts can be imported using the `resource id`, e.g.
 * 
 * ```sh
 *  $ pulumi import azure:storage/account:Account storageAcc1 /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/myresourcegroup/providers/Microsoft.Storage/storageAccounts/myaccount
 * ```
 * 
 */
@ResourceType(type="azure:storage/account:Account")
public class Account extends com.pulumi.resources.CustomResource {
    /**
     * Defines the access tier for `BlobStorage`, `FileStorage` and `StorageV2` accounts. Valid options are `Hot` and `Cool`, defaults to `Hot`.
     * 
     */
    @Export(name="accessTier", type=String.class, parameters={})
    private Output<String> accessTier;

    /**
     * @return Defines the access tier for `BlobStorage`, `FileStorage` and `StorageV2` accounts. Valid options are `Hot` and `Cool`, defaults to `Hot`.
     * 
     */
    public Output<String> accessTier() {
        return this.accessTier;
    }
    /**
     * Defines the Kind of account. Valid options are `BlobStorage`, `BlockBlobStorage`, `FileStorage`, `Storage` and `StorageV2`. Changing this forces a new resource to be created. Defaults to `StorageV2`.
     * 
     */
    @Export(name="accountKind", type=String.class, parameters={})
    private Output</* @Nullable */ String> accountKind;

    /**
     * @return Defines the Kind of account. Valid options are `BlobStorage`, `BlockBlobStorage`, `FileStorage`, `Storage` and `StorageV2`. Changing this forces a new resource to be created. Defaults to `StorageV2`.
     * 
     */
    public Output<Optional<String>> accountKind() {
        return Codegen.optional(this.accountKind);
    }
    /**
     * Defines the type of replication to use for this storage account. Valid options are `LRS`, `GRS`, `RAGRS`, `ZRS`, `GZRS` and `RAGZRS`. Changing this forces a new resource to be created when types `LRS`, `GRS` and `RAGRS` are changed to `ZRS`, `GZRS` or `RAGZRS` and vice versa.
     * 
     */
    @Export(name="accountReplicationType", type=String.class, parameters={})
    private Output<String> accountReplicationType;

    /**
     * @return Defines the type of replication to use for this storage account. Valid options are `LRS`, `GRS`, `RAGRS`, `ZRS`, `GZRS` and `RAGZRS`. Changing this forces a new resource to be created when types `LRS`, `GRS` and `RAGRS` are changed to `ZRS`, `GZRS` or `RAGZRS` and vice versa.
     * 
     */
    public Output<String> accountReplicationType() {
        return this.accountReplicationType;
    }
    /**
     * Defines the Tier to use for this storage account. Valid options are `Standard` and `Premium`. For `BlockBlobStorage` and `FileStorage` accounts only `Premium` is valid. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="accountTier", type=String.class, parameters={})
    private Output<String> accountTier;

    /**
     * @return Defines the Tier to use for this storage account. Valid options are `Standard` and `Premium`. For `BlockBlobStorage` and `FileStorage` accounts only `Premium` is valid. Changing this forces a new resource to be created.
     * 
     */
    public Output<String> accountTier() {
        return this.accountTier;
    }
    /**
     * Allow or disallow nested items within this Account to opt into being public. Defaults to `true`.
     * 
     */
    @Export(name="allowNestedItemsToBePublic", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> allowNestedItemsToBePublic;

    /**
     * @return Allow or disallow nested items within this Account to opt into being public. Defaults to `true`.
     * 
     */
    public Output<Optional<Boolean>> allowNestedItemsToBePublic() {
        return Codegen.optional(this.allowNestedItemsToBePublic);
    }
    /**
     * A `azure_files_authentication` block as defined below.
     * 
     */
    @Export(name="azureFilesAuthentication", type=AccountAzureFilesAuthentication.class, parameters={})
    private Output</* @Nullable */ AccountAzureFilesAuthentication> azureFilesAuthentication;

    /**
     * @return A `azure_files_authentication` block as defined below.
     * 
     */
    public Output<Optional<AccountAzureFilesAuthentication>> azureFilesAuthentication() {
        return Codegen.optional(this.azureFilesAuthentication);
    }
    /**
     * A `blob_properties` block as defined below.
     * 
     */
    @Export(name="blobProperties", type=AccountBlobProperties.class, parameters={})
    private Output<AccountBlobProperties> blobProperties;

    /**
     * @return A `blob_properties` block as defined below.
     * 
     */
    public Output<AccountBlobProperties> blobProperties() {
        return this.blobProperties;
    }
    /**
     * Should cross Tenant replication be enabled? Defaults to `true`.
     * 
     */
    @Export(name="crossTenantReplicationEnabled", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> crossTenantReplicationEnabled;

    /**
     * @return Should cross Tenant replication be enabled? Defaults to `true`.
     * 
     */
    public Output<Optional<Boolean>> crossTenantReplicationEnabled() {
        return Codegen.optional(this.crossTenantReplicationEnabled);
    }
    /**
     * A `custom_domain` block as documented below.
     * 
     */
    @Export(name="customDomain", type=AccountCustomDomain.class, parameters={})
    private Output</* @Nullable */ AccountCustomDomain> customDomain;

    /**
     * @return A `custom_domain` block as documented below.
     * 
     */
    public Output<Optional<AccountCustomDomain>> customDomain() {
        return Codegen.optional(this.customDomain);
    }
    /**
     * A `customer_managed_key` block as documented below.
     * 
     */
    @Export(name="customerManagedKey", type=AccountCustomerManagedKey.class, parameters={})
    private Output</* @Nullable */ AccountCustomerManagedKey> customerManagedKey;

    /**
     * @return A `customer_managed_key` block as documented below.
     * 
     */
    public Output<Optional<AccountCustomerManagedKey>> customerManagedKey() {
        return Codegen.optional(this.customerManagedKey);
    }
    /**
     * Default to Azure Active Directory authorization in the Azure portal when accessing the Storage Account. The default value is `false`
     * 
     */
    @Export(name="defaultToOauthAuthentication", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> defaultToOauthAuthentication;

    /**
     * @return Default to Azure Active Directory authorization in the Azure portal when accessing the Storage Account. The default value is `false`
     * 
     */
    public Output<Optional<Boolean>> defaultToOauthAuthentication() {
        return Codegen.optional(this.defaultToOauthAuthentication);
    }
    /**
     * Specifies the Edge Zone within the Azure Region where this Storage Account should exist. Changing this forces a new Storage Account to be created.
     * 
     */
    @Export(name="edgeZone", type=String.class, parameters={})
    private Output</* @Nullable */ String> edgeZone;

    /**
     * @return Specifies the Edge Zone within the Azure Region where this Storage Account should exist. Changing this forces a new Storage Account to be created.
     * 
     */
    public Output<Optional<String>> edgeZone() {
        return Codegen.optional(this.edgeZone);
    }
    /**
     * Boolean flag which forces HTTPS if enabled, see [here](https://docs.microsoft.com/azure/storage/storage-require-secure-transfer/)
     * for more information. Defaults to `true`.
     * 
     */
    @Export(name="enableHttpsTrafficOnly", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> enableHttpsTrafficOnly;

    /**
     * @return Boolean flag which forces HTTPS if enabled, see [here](https://docs.microsoft.com/azure/storage/storage-require-secure-transfer/)
     * for more information. Defaults to `true`.
     * 
     */
    public Output<Optional<Boolean>> enableHttpsTrafficOnly() {
        return Codegen.optional(this.enableHttpsTrafficOnly);
    }
    /**
     * An `identity` block as defined below.
     * 
     */
    @Export(name="identity", type=AccountIdentity.class, parameters={})
    private Output</* @Nullable */ AccountIdentity> identity;

    /**
     * @return An `identity` block as defined below.
     * 
     */
    public Output<Optional<AccountIdentity>> identity() {
        return Codegen.optional(this.identity);
    }
    /**
     * Is infrastructure encryption enabled? Changing this forces a new resource to be created. Defaults to `false`.
     * 
     */
    @Export(name="infrastructureEncryptionEnabled", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> infrastructureEncryptionEnabled;

    /**
     * @return Is infrastructure encryption enabled? Changing this forces a new resource to be created. Defaults to `false`.
     * 
     */
    public Output<Optional<Boolean>> infrastructureEncryptionEnabled() {
        return Codegen.optional(this.infrastructureEncryptionEnabled);
    }
    /**
     * Is Hierarchical Namespace enabled? This can be used with Azure Data Lake Storage Gen 2 ([see here for more information](https://docs.microsoft.com/azure/storage/blobs/data-lake-storage-quickstart-create-account/)). Changing this forces a new resource to be created.
     * 
     */
    @Export(name="isHnsEnabled", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> isHnsEnabled;

    /**
     * @return Is Hierarchical Namespace enabled? This can be used with Azure Data Lake Storage Gen 2 ([see here for more information](https://docs.microsoft.com/azure/storage/blobs/data-lake-storage-quickstart-create-account/)). Changing this forces a new resource to be created.
     * 
     */
    public Output<Optional<Boolean>> isHnsEnabled() {
        return Codegen.optional(this.isHnsEnabled);
    }
    /**
     * Is Large File Share Enabled?
     * 
     */
    @Export(name="largeFileShareEnabled", type=Boolean.class, parameters={})
    private Output<Boolean> largeFileShareEnabled;

    /**
     * @return Is Large File Share Enabled?
     * 
     */
    public Output<Boolean> largeFileShareEnabled() {
        return this.largeFileShareEnabled;
    }
    /**
     * Specifies the supported Azure location where the resource exists. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="location", type=String.class, parameters={})
    private Output<String> location;

    /**
     * @return Specifies the supported Azure location where the resource exists. Changing this forces a new resource to be created.
     * 
     */
    public Output<String> location() {
        return this.location;
    }
    /**
     * The minimum supported TLS version for the storage account. Possible values are `TLS1_0`, `TLS1_1`, and `TLS1_2`. Defaults to `TLS1_2` for new storage accounts.
     * 
     */
    @Export(name="minTlsVersion", type=String.class, parameters={})
    private Output</* @Nullable */ String> minTlsVersion;

    /**
     * @return The minimum supported TLS version for the storage account. Possible values are `TLS1_0`, `TLS1_1`, and `TLS1_2`. Defaults to `TLS1_2` for new storage accounts.
     * 
     */
    public Output<Optional<String>> minTlsVersion() {
        return Codegen.optional(this.minTlsVersion);
    }
    /**
     * Specifies the name of the storage account. Changing this forces a new resource to be created. This must be unique across the entire Azure service, not just within the resource group.
     * 
     */
    @Export(name="name", type=String.class, parameters={})
    private Output<String> name;

    /**
     * @return Specifies the name of the storage account. Changing this forces a new resource to be created. This must be unique across the entire Azure service, not just within the resource group.
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * A `network_rules` block as documented below.
     * 
     */
    @Export(name="networkRules", type=AccountNetworkRules.class, parameters={})
    private Output<AccountNetworkRules> networkRules;

    /**
     * @return A `network_rules` block as documented below.
     * 
     */
    public Output<AccountNetworkRules> networkRules() {
        return this.networkRules;
    }
    /**
     * Is NFSv3 protocol enabled? Changing this forces a new resource to be created. Defaults to `false`.
     * 
     */
    @Export(name="nfsv3Enabled", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> nfsv3Enabled;

    /**
     * @return Is NFSv3 protocol enabled? Changing this forces a new resource to be created. Defaults to `false`.
     * 
     */
    public Output<Optional<Boolean>> nfsv3Enabled() {
        return Codegen.optional(this.nfsv3Enabled);
    }
    /**
     * The primary access key for the storage account.
     * 
     */
    @Export(name="primaryAccessKey", type=String.class, parameters={})
    private Output<String> primaryAccessKey;

    /**
     * @return The primary access key for the storage account.
     * 
     */
    public Output<String> primaryAccessKey() {
        return this.primaryAccessKey;
    }
    /**
     * The connection string associated with the primary blob location.
     * 
     */
    @Export(name="primaryBlobConnectionString", type=String.class, parameters={})
    private Output<String> primaryBlobConnectionString;

    /**
     * @return The connection string associated with the primary blob location.
     * 
     */
    public Output<String> primaryBlobConnectionString() {
        return this.primaryBlobConnectionString;
    }
    /**
     * The endpoint URL for blob storage in the primary location.
     * 
     */
    @Export(name="primaryBlobEndpoint", type=String.class, parameters={})
    private Output<String> primaryBlobEndpoint;

    /**
     * @return The endpoint URL for blob storage in the primary location.
     * 
     */
    public Output<String> primaryBlobEndpoint() {
        return this.primaryBlobEndpoint;
    }
    /**
     * The hostname with port if applicable for blob storage in the primary location.
     * 
     */
    @Export(name="primaryBlobHost", type=String.class, parameters={})
    private Output<String> primaryBlobHost;

    /**
     * @return The hostname with port if applicable for blob storage in the primary location.
     * 
     */
    public Output<String> primaryBlobHost() {
        return this.primaryBlobHost;
    }
    /**
     * The connection string associated with the primary location.
     * 
     */
    @Export(name="primaryConnectionString", type=String.class, parameters={})
    private Output<String> primaryConnectionString;

    /**
     * @return The connection string associated with the primary location.
     * 
     */
    public Output<String> primaryConnectionString() {
        return this.primaryConnectionString;
    }
    /**
     * The endpoint URL for DFS storage in the primary location.
     * 
     */
    @Export(name="primaryDfsEndpoint", type=String.class, parameters={})
    private Output<String> primaryDfsEndpoint;

    /**
     * @return The endpoint URL for DFS storage in the primary location.
     * 
     */
    public Output<String> primaryDfsEndpoint() {
        return this.primaryDfsEndpoint;
    }
    /**
     * The hostname with port if applicable for DFS storage in the primary location.
     * 
     */
    @Export(name="primaryDfsHost", type=String.class, parameters={})
    private Output<String> primaryDfsHost;

    /**
     * @return The hostname with port if applicable for DFS storage in the primary location.
     * 
     */
    public Output<String> primaryDfsHost() {
        return this.primaryDfsHost;
    }
    /**
     * The endpoint URL for file storage in the primary location.
     * 
     */
    @Export(name="primaryFileEndpoint", type=String.class, parameters={})
    private Output<String> primaryFileEndpoint;

    /**
     * @return The endpoint URL for file storage in the primary location.
     * 
     */
    public Output<String> primaryFileEndpoint() {
        return this.primaryFileEndpoint;
    }
    /**
     * The hostname with port if applicable for file storage in the primary location.
     * 
     */
    @Export(name="primaryFileHost", type=String.class, parameters={})
    private Output<String> primaryFileHost;

    /**
     * @return The hostname with port if applicable for file storage in the primary location.
     * 
     */
    public Output<String> primaryFileHost() {
        return this.primaryFileHost;
    }
    /**
     * The primary location of the storage account.
     * 
     */
    @Export(name="primaryLocation", type=String.class, parameters={})
    private Output<String> primaryLocation;

    /**
     * @return The primary location of the storage account.
     * 
     */
    public Output<String> primaryLocation() {
        return this.primaryLocation;
    }
    /**
     * The endpoint URL for queue storage in the primary location.
     * 
     */
    @Export(name="primaryQueueEndpoint", type=String.class, parameters={})
    private Output<String> primaryQueueEndpoint;

    /**
     * @return The endpoint URL for queue storage in the primary location.
     * 
     */
    public Output<String> primaryQueueEndpoint() {
        return this.primaryQueueEndpoint;
    }
    /**
     * The hostname with port if applicable for queue storage in the primary location.
     * 
     */
    @Export(name="primaryQueueHost", type=String.class, parameters={})
    private Output<String> primaryQueueHost;

    /**
     * @return The hostname with port if applicable for queue storage in the primary location.
     * 
     */
    public Output<String> primaryQueueHost() {
        return this.primaryQueueHost;
    }
    /**
     * The endpoint URL for table storage in the primary location.
     * 
     */
    @Export(name="primaryTableEndpoint", type=String.class, parameters={})
    private Output<String> primaryTableEndpoint;

    /**
     * @return The endpoint URL for table storage in the primary location.
     * 
     */
    public Output<String> primaryTableEndpoint() {
        return this.primaryTableEndpoint;
    }
    /**
     * The hostname with port if applicable for table storage in the primary location.
     * 
     */
    @Export(name="primaryTableHost", type=String.class, parameters={})
    private Output<String> primaryTableHost;

    /**
     * @return The hostname with port if applicable for table storage in the primary location.
     * 
     */
    public Output<String> primaryTableHost() {
        return this.primaryTableHost;
    }
    /**
     * The endpoint URL for web storage in the primary location.
     * 
     */
    @Export(name="primaryWebEndpoint", type=String.class, parameters={})
    private Output<String> primaryWebEndpoint;

    /**
     * @return The endpoint URL for web storage in the primary location.
     * 
     */
    public Output<String> primaryWebEndpoint() {
        return this.primaryWebEndpoint;
    }
    /**
     * The hostname with port if applicable for web storage in the primary location.
     * 
     */
    @Export(name="primaryWebHost", type=String.class, parameters={})
    private Output<String> primaryWebHost;

    /**
     * @return The hostname with port if applicable for web storage in the primary location.
     * 
     */
    public Output<String> primaryWebHost() {
        return this.primaryWebHost;
    }
    /**
     * Whether the public network access is enabled? Defaults to `true`.
     * 
     */
    @Export(name="publicNetworkAccessEnabled", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> publicNetworkAccessEnabled;

    /**
     * @return Whether the public network access is enabled? Defaults to `true`.
     * 
     */
    public Output<Optional<Boolean>> publicNetworkAccessEnabled() {
        return Codegen.optional(this.publicNetworkAccessEnabled);
    }
    /**
     * The encryption type of the queue service. Possible values are `Service` and `Account`. Changing this forces a new resource to be created. Default value is `Service`.
     * 
     */
    @Export(name="queueEncryptionKeyType", type=String.class, parameters={})
    private Output</* @Nullable */ String> queueEncryptionKeyType;

    /**
     * @return The encryption type of the queue service. Possible values are `Service` and `Account`. Changing this forces a new resource to be created. Default value is `Service`.
     * 
     */
    public Output<Optional<String>> queueEncryptionKeyType() {
        return Codegen.optional(this.queueEncryptionKeyType);
    }
    /**
     * A `queue_properties` block as defined below.
     * 
     */
    @Export(name="queueProperties", type=AccountQueueProperties.class, parameters={})
    private Output<AccountQueueProperties> queueProperties;

    /**
     * @return A `queue_properties` block as defined below.
     * 
     */
    public Output<AccountQueueProperties> queueProperties() {
        return this.queueProperties;
    }
    /**
     * The name of the resource group in which to create the storage account. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="resourceGroupName", type=String.class, parameters={})
    private Output<String> resourceGroupName;

    /**
     * @return The name of the resource group in which to create the storage account. Changing this forces a new resource to be created.
     * 
     */
    public Output<String> resourceGroupName() {
        return this.resourceGroupName;
    }
    /**
     * A `routing` block as defined below.
     * 
     */
    @Export(name="routing", type=AccountRouting.class, parameters={})
    private Output<AccountRouting> routing;

    /**
     * @return A `routing` block as defined below.
     * 
     */
    public Output<AccountRouting> routing() {
        return this.routing;
    }
    /**
     * The secondary access key for the storage account.
     * 
     */
    @Export(name="secondaryAccessKey", type=String.class, parameters={})
    private Output<String> secondaryAccessKey;

    /**
     * @return The secondary access key for the storage account.
     * 
     */
    public Output<String> secondaryAccessKey() {
        return this.secondaryAccessKey;
    }
    /**
     * The connection string associated with the secondary blob location.
     * 
     */
    @Export(name="secondaryBlobConnectionString", type=String.class, parameters={})
    private Output<String> secondaryBlobConnectionString;

    /**
     * @return The connection string associated with the secondary blob location.
     * 
     */
    public Output<String> secondaryBlobConnectionString() {
        return this.secondaryBlobConnectionString;
    }
    /**
     * The endpoint URL for blob storage in the secondary location.
     * 
     */
    @Export(name="secondaryBlobEndpoint", type=String.class, parameters={})
    private Output<String> secondaryBlobEndpoint;

    /**
     * @return The endpoint URL for blob storage in the secondary location.
     * 
     */
    public Output<String> secondaryBlobEndpoint() {
        return this.secondaryBlobEndpoint;
    }
    /**
     * The hostname with port if applicable for blob storage in the secondary location.
     * 
     */
    @Export(name="secondaryBlobHost", type=String.class, parameters={})
    private Output<String> secondaryBlobHost;

    /**
     * @return The hostname with port if applicable for blob storage in the secondary location.
     * 
     */
    public Output<String> secondaryBlobHost() {
        return this.secondaryBlobHost;
    }
    /**
     * The connection string associated with the secondary location.
     * 
     */
    @Export(name="secondaryConnectionString", type=String.class, parameters={})
    private Output<String> secondaryConnectionString;

    /**
     * @return The connection string associated with the secondary location.
     * 
     */
    public Output<String> secondaryConnectionString() {
        return this.secondaryConnectionString;
    }
    /**
     * The endpoint URL for DFS storage in the secondary location.
     * 
     */
    @Export(name="secondaryDfsEndpoint", type=String.class, parameters={})
    private Output<String> secondaryDfsEndpoint;

    /**
     * @return The endpoint URL for DFS storage in the secondary location.
     * 
     */
    public Output<String> secondaryDfsEndpoint() {
        return this.secondaryDfsEndpoint;
    }
    /**
     * The hostname with port if applicable for DFS storage in the secondary location.
     * 
     */
    @Export(name="secondaryDfsHost", type=String.class, parameters={})
    private Output<String> secondaryDfsHost;

    /**
     * @return The hostname with port if applicable for DFS storage in the secondary location.
     * 
     */
    public Output<String> secondaryDfsHost() {
        return this.secondaryDfsHost;
    }
    /**
     * The endpoint URL for file storage in the secondary location.
     * 
     */
    @Export(name="secondaryFileEndpoint", type=String.class, parameters={})
    private Output<String> secondaryFileEndpoint;

    /**
     * @return The endpoint URL for file storage in the secondary location.
     * 
     */
    public Output<String> secondaryFileEndpoint() {
        return this.secondaryFileEndpoint;
    }
    /**
     * The hostname with port if applicable for file storage in the secondary location.
     * 
     */
    @Export(name="secondaryFileHost", type=String.class, parameters={})
    private Output<String> secondaryFileHost;

    /**
     * @return The hostname with port if applicable for file storage in the secondary location.
     * 
     */
    public Output<String> secondaryFileHost() {
        return this.secondaryFileHost;
    }
    /**
     * The secondary location of the storage account.
     * 
     */
    @Export(name="secondaryLocation", type=String.class, parameters={})
    private Output<String> secondaryLocation;

    /**
     * @return The secondary location of the storage account.
     * 
     */
    public Output<String> secondaryLocation() {
        return this.secondaryLocation;
    }
    /**
     * The endpoint URL for queue storage in the secondary location.
     * 
     */
    @Export(name="secondaryQueueEndpoint", type=String.class, parameters={})
    private Output<String> secondaryQueueEndpoint;

    /**
     * @return The endpoint URL for queue storage in the secondary location.
     * 
     */
    public Output<String> secondaryQueueEndpoint() {
        return this.secondaryQueueEndpoint;
    }
    /**
     * The hostname with port if applicable for queue storage in the secondary location.
     * 
     */
    @Export(name="secondaryQueueHost", type=String.class, parameters={})
    private Output<String> secondaryQueueHost;

    /**
     * @return The hostname with port if applicable for queue storage in the secondary location.
     * 
     */
    public Output<String> secondaryQueueHost() {
        return this.secondaryQueueHost;
    }
    /**
     * The endpoint URL for table storage in the secondary location.
     * 
     */
    @Export(name="secondaryTableEndpoint", type=String.class, parameters={})
    private Output<String> secondaryTableEndpoint;

    /**
     * @return The endpoint URL for table storage in the secondary location.
     * 
     */
    public Output<String> secondaryTableEndpoint() {
        return this.secondaryTableEndpoint;
    }
    /**
     * The hostname with port if applicable for table storage in the secondary location.
     * 
     */
    @Export(name="secondaryTableHost", type=String.class, parameters={})
    private Output<String> secondaryTableHost;

    /**
     * @return The hostname with port if applicable for table storage in the secondary location.
     * 
     */
    public Output<String> secondaryTableHost() {
        return this.secondaryTableHost;
    }
    /**
     * The endpoint URL for web storage in the secondary location.
     * 
     */
    @Export(name="secondaryWebEndpoint", type=String.class, parameters={})
    private Output<String> secondaryWebEndpoint;

    /**
     * @return The endpoint URL for web storage in the secondary location.
     * 
     */
    public Output<String> secondaryWebEndpoint() {
        return this.secondaryWebEndpoint;
    }
    /**
     * The hostname with port if applicable for web storage in the secondary location.
     * 
     */
    @Export(name="secondaryWebHost", type=String.class, parameters={})
    private Output<String> secondaryWebHost;

    /**
     * @return The hostname with port if applicable for web storage in the secondary location.
     * 
     */
    public Output<String> secondaryWebHost() {
        return this.secondaryWebHost;
    }
    /**
     * A `share_properties` block as defined below.
     * 
     */
    @Export(name="shareProperties", type=AccountShareProperties.class, parameters={})
    private Output<AccountShareProperties> shareProperties;

    /**
     * @return A `share_properties` block as defined below.
     * 
     */
    public Output<AccountShareProperties> shareProperties() {
        return this.shareProperties;
    }
    /**
     * Indicates whether the storage account permits requests to be authorized with the account access key via Shared Key. If false, then all requests, including shared access signatures, must be authorized with Azure Active Directory (Azure AD). The default value is `true`.
     * 
     */
    @Export(name="sharedAccessKeyEnabled", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> sharedAccessKeyEnabled;

    /**
     * @return Indicates whether the storage account permits requests to be authorized with the account access key via Shared Key. If false, then all requests, including shared access signatures, must be authorized with Azure Active Directory (Azure AD). The default value is `true`.
     * 
     */
    public Output<Optional<Boolean>> sharedAccessKeyEnabled() {
        return Codegen.optional(this.sharedAccessKeyEnabled);
    }
    /**
     * A `static_website` block as defined below.
     * 
     */
    @Export(name="staticWebsite", type=AccountStaticWebsite.class, parameters={})
    private Output</* @Nullable */ AccountStaticWebsite> staticWebsite;

    /**
     * @return A `static_website` block as defined below.
     * 
     */
    public Output<Optional<AccountStaticWebsite>> staticWebsite() {
        return Codegen.optional(this.staticWebsite);
    }
    /**
     * The encryption type of the table service. Possible values are `Service` and `Account`. Changing this forces a new resource to be created. Default value is `Service`.
     * 
     */
    @Export(name="tableEncryptionKeyType", type=String.class, parameters={})
    private Output</* @Nullable */ String> tableEncryptionKeyType;

    /**
     * @return The encryption type of the table service. Possible values are `Service` and `Account`. Changing this forces a new resource to be created. Default value is `Service`.
     * 
     */
    public Output<Optional<String>> tableEncryptionKeyType() {
        return Codegen.optional(this.tableEncryptionKeyType);
    }
    /**
     * A mapping of tags to assign to the resource.
     * 
     */
    @Export(name="tags", type=Map.class, parameters={String.class, String.class})
    private Output</* @Nullable */ Map<String,String>> tags;

    /**
     * @return A mapping of tags to assign to the resource.
     * 
     */
    public Output<Optional<Map<String,String>>> tags() {
        return Codegen.optional(this.tags);
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public Account(String name) {
        this(name, AccountArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public Account(String name, AccountArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public Account(String name, AccountArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("azure:storage/account:Account", name, args == null ? AccountArgs.Empty : args, makeResourceOptions(options, Codegen.empty()));
    }

    private Account(String name, Output<String> id, @Nullable AccountState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("azure:storage/account:Account", name, state, makeResourceOptions(options, id));
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static Account get(String name, Output<String> id, @Nullable AccountState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new Account(name, id, state, options);
    }
}
