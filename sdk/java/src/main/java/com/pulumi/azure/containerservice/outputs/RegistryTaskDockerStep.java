// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.azure.containerservice.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class RegistryTaskDockerStep {
    /**
     * @return Specifies a map of arguments to be used when executing this step.
     * 
     */
    private @Nullable Map<String,String> arguments;
    /**
     * @return Should the image cache be enabled? Defaults to `true`.
     * 
     */
    private @Nullable Boolean cacheEnabled;
    /**
     * @return The token (Git PAT or SAS token of storage account blob) associated with the context for this step.
     * 
     */
    private String contextAccessToken;
    /**
     * @return The URL (absolute or relative) of the source context for this step. If the context is an url you can reference a specific branch or folder via `#branch:folder`.
     * 
     */
    private String contextPath;
    /**
     * @return The Dockerfile path relative to the source context.
     * 
     */
    private String dockerfilePath;
    /**
     * @return Specifies a list of fully qualified image names including the repository and tag.
     * 
     */
    private @Nullable List<String> imageNames;
    /**
     * @return Should the image built be pushed to the registry or not? Defaults to `true`.
     * 
     */
    private @Nullable Boolean pushEnabled;
    /**
     * @return Specifies a map of *secret* arguments to be used when executing this step.
     * 
     */
    private @Nullable Map<String,String> secretArguments;
    /**
     * @return The name of the target build stage for the docker build.
     * 
     */
    private @Nullable String target;

    private RegistryTaskDockerStep() {}
    /**
     * @return Specifies a map of arguments to be used when executing this step.
     * 
     */
    public Map<String,String> arguments() {
        return this.arguments == null ? Map.of() : this.arguments;
    }
    /**
     * @return Should the image cache be enabled? Defaults to `true`.
     * 
     */
    public Optional<Boolean> cacheEnabled() {
        return Optional.ofNullable(this.cacheEnabled);
    }
    /**
     * @return The token (Git PAT or SAS token of storage account blob) associated with the context for this step.
     * 
     */
    public String contextAccessToken() {
        return this.contextAccessToken;
    }
    /**
     * @return The URL (absolute or relative) of the source context for this step. If the context is an url you can reference a specific branch or folder via `#branch:folder`.
     * 
     */
    public String contextPath() {
        return this.contextPath;
    }
    /**
     * @return The Dockerfile path relative to the source context.
     * 
     */
    public String dockerfilePath() {
        return this.dockerfilePath;
    }
    /**
     * @return Specifies a list of fully qualified image names including the repository and tag.
     * 
     */
    public List<String> imageNames() {
        return this.imageNames == null ? List.of() : this.imageNames;
    }
    /**
     * @return Should the image built be pushed to the registry or not? Defaults to `true`.
     * 
     */
    public Optional<Boolean> pushEnabled() {
        return Optional.ofNullable(this.pushEnabled);
    }
    /**
     * @return Specifies a map of *secret* arguments to be used when executing this step.
     * 
     */
    public Map<String,String> secretArguments() {
        return this.secretArguments == null ? Map.of() : this.secretArguments;
    }
    /**
     * @return The name of the target build stage for the docker build.
     * 
     */
    public Optional<String> target() {
        return Optional.ofNullable(this.target);
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(RegistryTaskDockerStep defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private @Nullable Map<String,String> arguments;
        private @Nullable Boolean cacheEnabled;
        private String contextAccessToken;
        private String contextPath;
        private String dockerfilePath;
        private @Nullable List<String> imageNames;
        private @Nullable Boolean pushEnabled;
        private @Nullable Map<String,String> secretArguments;
        private @Nullable String target;
        public Builder() {}
        public Builder(RegistryTaskDockerStep defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.arguments = defaults.arguments;
    	      this.cacheEnabled = defaults.cacheEnabled;
    	      this.contextAccessToken = defaults.contextAccessToken;
    	      this.contextPath = defaults.contextPath;
    	      this.dockerfilePath = defaults.dockerfilePath;
    	      this.imageNames = defaults.imageNames;
    	      this.pushEnabled = defaults.pushEnabled;
    	      this.secretArguments = defaults.secretArguments;
    	      this.target = defaults.target;
        }

        @CustomType.Setter
        public Builder arguments(@Nullable Map<String,String> arguments) {

            this.arguments = arguments;
            return this;
        }
        @CustomType.Setter
        public Builder cacheEnabled(@Nullable Boolean cacheEnabled) {

            this.cacheEnabled = cacheEnabled;
            return this;
        }
        @CustomType.Setter
        public Builder contextAccessToken(String contextAccessToken) {
            if (contextAccessToken == null) {
              throw new MissingRequiredPropertyException("RegistryTaskDockerStep", "contextAccessToken");
            }
            this.contextAccessToken = contextAccessToken;
            return this;
        }
        @CustomType.Setter
        public Builder contextPath(String contextPath) {
            if (contextPath == null) {
              throw new MissingRequiredPropertyException("RegistryTaskDockerStep", "contextPath");
            }
            this.contextPath = contextPath;
            return this;
        }
        @CustomType.Setter
        public Builder dockerfilePath(String dockerfilePath) {
            if (dockerfilePath == null) {
              throw new MissingRequiredPropertyException("RegistryTaskDockerStep", "dockerfilePath");
            }
            this.dockerfilePath = dockerfilePath;
            return this;
        }
        @CustomType.Setter
        public Builder imageNames(@Nullable List<String> imageNames) {

            this.imageNames = imageNames;
            return this;
        }
        public Builder imageNames(String... imageNames) {
            return imageNames(List.of(imageNames));
        }
        @CustomType.Setter
        public Builder pushEnabled(@Nullable Boolean pushEnabled) {

            this.pushEnabled = pushEnabled;
            return this;
        }
        @CustomType.Setter
        public Builder secretArguments(@Nullable Map<String,String> secretArguments) {

            this.secretArguments = secretArguments;
            return this;
        }
        @CustomType.Setter
        public Builder target(@Nullable String target) {

            this.target = target;
            return this;
        }
        public RegistryTaskDockerStep build() {
            final var _resultValue = new RegistryTaskDockerStep();
            _resultValue.arguments = arguments;
            _resultValue.cacheEnabled = cacheEnabled;
            _resultValue.contextAccessToken = contextAccessToken;
            _resultValue.contextPath = contextPath;
            _resultValue.dockerfilePath = dockerfilePath;
            _resultValue.imageNames = imageNames;
            _resultValue.pushEnabled = pushEnabled;
            _resultValue.secretArguments = secretArguments;
            _resultValue.target = target;
            return _resultValue;
        }
    }
}
