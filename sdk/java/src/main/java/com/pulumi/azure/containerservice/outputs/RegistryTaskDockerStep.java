// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.azure.containerservice.outputs;

import com.pulumi.core.annotations.CustomType;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class RegistryTaskDockerStep {
    /**
     * @return Specifies a map of arguments to be used when executing this step.
     * 
     */
    private final @Nullable Map<String,String> arguments;
    /**
     * @return Should the image cache be enabled? Defaults to `true`.
     * 
     */
    private final @Nullable Boolean cacheEnabled;
    /**
     * @return The token (Git PAT or SAS token of storage account blob) associated with the context for this step.
     * 
     */
    private final String contextAccessToken;
    /**
     * @return The URL (absolute or relative) of the source context for this step.
     * 
     */
    private final String contextPath;
    /**
     * @return The  Dockerfile path relative to the source context.
     * 
     */
    private final String dockerfilePath;
    /**
     * @return Specifies a list of fully qualified image names including the repository and tag.
     * 
     */
    private final @Nullable List<String> imageNames;
    /**
     * @return Should the image built be pushed to the registry or not? Defaults to `true`.
     * 
     */
    private final @Nullable Boolean pushEnabled;
    /**
     * @return Specifies a map of *secret* arguments to be used when executing this step.
     * 
     */
    private final @Nullable Map<String,String> secretArguments;
    /**
     * @return The name of the target build stage for the docker build.
     * 
     */
    private final @Nullable String target;

    @CustomType.Constructor
    private RegistryTaskDockerStep(
        @CustomType.Parameter("arguments") @Nullable Map<String,String> arguments,
        @CustomType.Parameter("cacheEnabled") @Nullable Boolean cacheEnabled,
        @CustomType.Parameter("contextAccessToken") String contextAccessToken,
        @CustomType.Parameter("contextPath") String contextPath,
        @CustomType.Parameter("dockerfilePath") String dockerfilePath,
        @CustomType.Parameter("imageNames") @Nullable List<String> imageNames,
        @CustomType.Parameter("pushEnabled") @Nullable Boolean pushEnabled,
        @CustomType.Parameter("secretArguments") @Nullable Map<String,String> secretArguments,
        @CustomType.Parameter("target") @Nullable String target) {
        this.arguments = arguments;
        this.cacheEnabled = cacheEnabled;
        this.contextAccessToken = contextAccessToken;
        this.contextPath = contextPath;
        this.dockerfilePath = dockerfilePath;
        this.imageNames = imageNames;
        this.pushEnabled = pushEnabled;
        this.secretArguments = secretArguments;
        this.target = target;
    }

    /**
     * @return Specifies a map of arguments to be used when executing this step.
     * 
     */
    public Map<String,String> arguments() {
        return this.arguments == null ? Map.of() : this.arguments;
    }
    /**
     * @return Should the image cache be enabled? Defaults to `true`.
     * 
     */
    public Optional<Boolean> cacheEnabled() {
        return Optional.ofNullable(this.cacheEnabled);
    }
    /**
     * @return The token (Git PAT or SAS token of storage account blob) associated with the context for this step.
     * 
     */
    public String contextAccessToken() {
        return this.contextAccessToken;
    }
    /**
     * @return The URL (absolute or relative) of the source context for this step.
     * 
     */
    public String contextPath() {
        return this.contextPath;
    }
    /**
     * @return The  Dockerfile path relative to the source context.
     * 
     */
    public String dockerfilePath() {
        return this.dockerfilePath;
    }
    /**
     * @return Specifies a list of fully qualified image names including the repository and tag.
     * 
     */
    public List<String> imageNames() {
        return this.imageNames == null ? List.of() : this.imageNames;
    }
    /**
     * @return Should the image built be pushed to the registry or not? Defaults to `true`.
     * 
     */
    public Optional<Boolean> pushEnabled() {
        return Optional.ofNullable(this.pushEnabled);
    }
    /**
     * @return Specifies a map of *secret* arguments to be used when executing this step.
     * 
     */
    public Map<String,String> secretArguments() {
        return this.secretArguments == null ? Map.of() : this.secretArguments;
    }
    /**
     * @return The name of the target build stage for the docker build.
     * 
     */
    public Optional<String> target() {
        return Optional.ofNullable(this.target);
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(RegistryTaskDockerStep defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private @Nullable Map<String,String> arguments;
        private @Nullable Boolean cacheEnabled;
        private String contextAccessToken;
        private String contextPath;
        private String dockerfilePath;
        private @Nullable List<String> imageNames;
        private @Nullable Boolean pushEnabled;
        private @Nullable Map<String,String> secretArguments;
        private @Nullable String target;

        public Builder() {
    	      // Empty
        }

        public Builder(RegistryTaskDockerStep defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.arguments = defaults.arguments;
    	      this.cacheEnabled = defaults.cacheEnabled;
    	      this.contextAccessToken = defaults.contextAccessToken;
    	      this.contextPath = defaults.contextPath;
    	      this.dockerfilePath = defaults.dockerfilePath;
    	      this.imageNames = defaults.imageNames;
    	      this.pushEnabled = defaults.pushEnabled;
    	      this.secretArguments = defaults.secretArguments;
    	      this.target = defaults.target;
        }

        public Builder arguments(@Nullable Map<String,String> arguments) {
            this.arguments = arguments;
            return this;
        }
        public Builder cacheEnabled(@Nullable Boolean cacheEnabled) {
            this.cacheEnabled = cacheEnabled;
            return this;
        }
        public Builder contextAccessToken(String contextAccessToken) {
            this.contextAccessToken = Objects.requireNonNull(contextAccessToken);
            return this;
        }
        public Builder contextPath(String contextPath) {
            this.contextPath = Objects.requireNonNull(contextPath);
            return this;
        }
        public Builder dockerfilePath(String dockerfilePath) {
            this.dockerfilePath = Objects.requireNonNull(dockerfilePath);
            return this;
        }
        public Builder imageNames(@Nullable List<String> imageNames) {
            this.imageNames = imageNames;
            return this;
        }
        public Builder imageNames(String... imageNames) {
            return imageNames(List.of(imageNames));
        }
        public Builder pushEnabled(@Nullable Boolean pushEnabled) {
            this.pushEnabled = pushEnabled;
            return this;
        }
        public Builder secretArguments(@Nullable Map<String,String> secretArguments) {
            this.secretArguments = secretArguments;
            return this;
        }
        public Builder target(@Nullable String target) {
            this.target = target;
            return this;
        }        public RegistryTaskDockerStep build() {
            return new RegistryTaskDockerStep(arguments, cacheEnabled, contextAccessToken, contextPath, dockerfilePath, imageNames, pushEnabled, secretArguments, target);
        }
    }
}
