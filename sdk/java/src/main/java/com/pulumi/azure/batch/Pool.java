// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.azure.batch;

import com.pulumi.azure.Utilities;
import com.pulumi.azure.batch.PoolArgs;
import com.pulumi.azure.batch.inputs.PoolState;
import com.pulumi.azure.batch.outputs.PoolAutoScale;
import com.pulumi.azure.batch.outputs.PoolCertificate;
import com.pulumi.azure.batch.outputs.PoolContainerConfiguration;
import com.pulumi.azure.batch.outputs.PoolDataDisk;
import com.pulumi.azure.batch.outputs.PoolDiskEncryption;
import com.pulumi.azure.batch.outputs.PoolExtension;
import com.pulumi.azure.batch.outputs.PoolFixedScale;
import com.pulumi.azure.batch.outputs.PoolIdentity;
import com.pulumi.azure.batch.outputs.PoolMount;
import com.pulumi.azure.batch.outputs.PoolNetworkConfiguration;
import com.pulumi.azure.batch.outputs.PoolNodePlacement;
import com.pulumi.azure.batch.outputs.PoolSecurityProfile;
import com.pulumi.azure.batch.outputs.PoolStartTask;
import com.pulumi.azure.batch.outputs.PoolStorageImageReference;
import com.pulumi.azure.batch.outputs.PoolTaskSchedulingPolicy;
import com.pulumi.azure.batch.outputs.PoolUserAccount;
import com.pulumi.azure.batch.outputs.PoolWindow;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * Manages an Azure Batch pool.
 * 
 * ## Example Usage
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.azure.core.ResourceGroup;
 * import com.pulumi.azure.core.ResourceGroupArgs;
 * import com.pulumi.azure.batch.Certificate;
 * import com.pulumi.azure.batch.CertificateArgs;
 * import com.pulumi.std.StdFunctions;
 * import com.pulumi.std.inputs.Filebase64Args;
 * import com.pulumi.azure.batch.Pool;
 * import com.pulumi.azure.batch.PoolArgs;
 * import com.pulumi.azure.batch.inputs.PoolAutoScaleArgs;
 * import com.pulumi.azure.batch.inputs.PoolStorageImageReferenceArgs;
 * import com.pulumi.azure.batch.inputs.PoolContainerConfigurationArgs;
 * import com.pulumi.azure.batch.inputs.PoolStartTaskArgs;
 * import com.pulumi.azure.batch.inputs.PoolStartTaskUserIdentityArgs;
 * import com.pulumi.azure.batch.inputs.PoolStartTaskUserIdentityAutoUserArgs;
 * import com.pulumi.azure.batch.inputs.PoolCertificateArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var example = new ResourceGroup("example", ResourceGroupArgs.builder()
 *             .name("testaccbatch")
 *             .location("West Europe")
 *             .build());
 * 
 *         var exampleAccount = new com.pulumi.azure.storage.Account("exampleAccount", com.pulumi.azure.storage.AccountArgs.builder()
 *             .name("testaccsa")
 *             .resourceGroupName(example.name())
 *             .location(example.location())
 *             .accountTier("Standard")
 *             .accountReplicationType("LRS")
 *             .build());
 * 
 *         var exampleAccount2 = new com.pulumi.azure.batch.Account("exampleAccount2", com.pulumi.azure.batch.AccountArgs.builder()
 *             .name("testaccbatch")
 *             .resourceGroupName(example.name())
 *             .location(example.location())
 *             .poolAllocationMode("BatchService")
 *             .storageAccountId(exampleAccount.id())
 *             .storageAccountAuthenticationMode("StorageKeys")
 *             .tags(Map.of("env", "test"))
 *             .build());
 * 
 *         var exampleCertificate = new Certificate("exampleCertificate", CertificateArgs.builder()
 *             .resourceGroupName(example.name())
 *             .accountName(exampleAccount2.name())
 *             .certificate(StdFunctions.filebase64(Filebase64Args.builder()
 *                 .input("certificate.cer")
 *                 .build()).result())
 *             .format("Cer")
 *             .thumbprint("312d31a79fa0cef49c00f769afc2b73e9f4edf34")
 *             .thumbprintAlgorithm("SHA1")
 *             .build());
 * 
 *         var examplePool = new Pool("examplePool", PoolArgs.builder()
 *             .name("testaccpool")
 *             .resourceGroupName(example.name())
 *             .accountName(exampleAccount2.name())
 *             .displayName("Test Acc Pool Auto")
 *             .vmSize("STANDARD_A1_V2")
 *             .nodeAgentSkuId("batch.node.ubuntu 20.04")
 *             .autoScale(PoolAutoScaleArgs.builder()
 *                 .evaluationInterval("PT15M")
 *                 .formula("""
 *       startingNumberOfVMs = 1;
 *       maxNumberofVMs = 25;
 *       pendingTaskSamplePercent = $PendingTasks.GetSamplePercent(180 * TimeInterval_Second);
 *       pendingTaskSamples = pendingTaskSamplePercent < 70 ? startingNumberOfVMs : avg($PendingTasks.GetSample(180 *   TimeInterval_Second));
 *       $TargetDedicatedNodes=min(maxNumberofVMs, pendingTaskSamples);
 *                 """)
 *                 .build())
 *             .storageImageReference(PoolStorageImageReferenceArgs.builder()
 *                 .publisher("microsoft-azure-batch")
 *                 .offer("ubuntu-server-container")
 *                 .sku("20-04-lts")
 *                 .version("latest")
 *                 .build())
 *             .containerConfiguration(PoolContainerConfigurationArgs.builder()
 *                 .type("DockerCompatible")
 *                 .containerRegistries(PoolContainerConfigurationContainerRegistryArgs.builder()
 *                     .registryServer("docker.io")
 *                     .userName("login")
 *                     .password("apassword")
 *                     .build())
 *                 .build())
 *             .startTask(PoolStartTaskArgs.builder()
 *                 .commandLine("echo 'Hello World from $env'")
 *                 .taskRetryMaximum(1)
 *                 .waitForSuccess(true)
 *                 .commonEnvironmentProperties(Map.of("env", "TEST"))
 *                 .userIdentity(PoolStartTaskUserIdentityArgs.builder()
 *                     .autoUser(PoolStartTaskUserIdentityAutoUserArgs.builder()
 *                         .elevationLevel("NonAdmin")
 *                         .scope("Task")
 *                         .build())
 *                     .build())
 *                 .build())
 *             .certificates(PoolCertificateArgs.builder()
 *                 .id(exampleCertificate.id())
 *                 .storeLocation("CurrentUser")
 *                 .visibilities("StartTask")
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ## API Providers
 * 
 * &lt;!-- This section is generated, changes will be overwritten --&gt;
 * This resource uses the following Azure API Providers:
 * 
 * * `Microsoft.Batch` - 2024-07-01
 * 
 * ## Import
 * 
 * Batch Pools can be imported using the `resource id`, e.g.
 * 
 * ```sh
 * $ pulumi import azure:batch/pool:Pool example /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/myGroup1/providers/Microsoft.Batch/batchAccounts/myBatchAccount1/pools/myBatchPool1
 * ```
 * 
 */
@ResourceType(type="azure:batch/pool:Pool")
public class Pool extends com.pulumi.resources.CustomResource {
    /**
     * Specifies the name of the Batch account in which the pool will be created. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="accountName", refs={String.class}, tree="[0]")
    private Output<String> accountName;

    /**
     * @return Specifies the name of the Batch account in which the pool will be created. Changing this forces a new resource to be created.
     * 
     */
    public Output<String> accountName() {
        return this.accountName;
    }
    /**
     * A `auto_scale` block that describes the scale settings when using auto scale as defined below.
     * 
     */
    @Export(name="autoScale", refs={PoolAutoScale.class}, tree="[0]")
    private Output</* @Nullable */ PoolAutoScale> autoScale;

    /**
     * @return A `auto_scale` block that describes the scale settings when using auto scale as defined below.
     * 
     */
    public Output<Optional<PoolAutoScale>> autoScale() {
        return Codegen.optional(this.autoScale);
    }
    /**
     * One or more `certificate` blocks that describe the certificates to be installed on each compute node in the pool as defined below.
     * 
     */
    @Export(name="certificates", refs={List.class,PoolCertificate.class}, tree="[0,1]")
    private Output</* @Nullable */ List<PoolCertificate>> certificates;

    /**
     * @return One or more `certificate` blocks that describe the certificates to be installed on each compute node in the pool as defined below.
     * 
     */
    public Output<Optional<List<PoolCertificate>>> certificates() {
        return Codegen.optional(this.certificates);
    }
    /**
     * The container configuration used in the pool&#39;s VMs. One `container_configuration` block as defined below.
     * 
     */
    @Export(name="containerConfiguration", refs={PoolContainerConfiguration.class}, tree="[0]")
    private Output</* @Nullable */ PoolContainerConfiguration> containerConfiguration;

    /**
     * @return The container configuration used in the pool&#39;s VMs. One `container_configuration` block as defined below.
     * 
     */
    public Output<Optional<PoolContainerConfiguration>> containerConfiguration() {
        return Codegen.optional(this.containerConfiguration);
    }
    /**
     * A `data_disks` block describes the data disk settings as defined below.
     * 
     */
    @Export(name="dataDisks", refs={List.class,PoolDataDisk.class}, tree="[0,1]")
    private Output</* @Nullable */ List<PoolDataDisk>> dataDisks;

    /**
     * @return A `data_disks` block describes the data disk settings as defined below.
     * 
     */
    public Output<Optional<List<PoolDataDisk>>> dataDisks() {
        return Codegen.optional(this.dataDisks);
    }
    /**
     * A `disk_encryption` block, as defined below, describes the disk encryption configuration applied on compute nodes in the pool. Disk encryption configuration is not supported on Linux pool created with Virtual Machine Image or Shared Image Gallery Image.
     * 
     */
    @Export(name="diskEncryptions", refs={List.class,PoolDiskEncryption.class}, tree="[0,1]")
    private Output</* @Nullable */ List<PoolDiskEncryption>> diskEncryptions;

    /**
     * @return A `disk_encryption` block, as defined below, describes the disk encryption configuration applied on compute nodes in the pool. Disk encryption configuration is not supported on Linux pool created with Virtual Machine Image or Shared Image Gallery Image.
     * 
     */
    public Output<Optional<List<PoolDiskEncryption>>> diskEncryptions() {
        return Codegen.optional(this.diskEncryptions);
    }
    /**
     * Specifies the display name of the Batch pool. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="displayName", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> displayName;

    /**
     * @return Specifies the display name of the Batch pool. Changing this forces a new resource to be created.
     * 
     */
    public Output<Optional<String>> displayName() {
        return Codegen.optional(this.displayName);
    }
    /**
     * An `extensions` block as defined below.
     * 
     */
    @Export(name="extensions", refs={List.class,PoolExtension.class}, tree="[0,1]")
    private Output</* @Nullable */ List<PoolExtension>> extensions;

    /**
     * @return An `extensions` block as defined below.
     * 
     */
    public Output<Optional<List<PoolExtension>>> extensions() {
        return Codegen.optional(this.extensions);
    }
    /**
     * A `fixed_scale` block that describes the scale settings when using fixed scale as defined below.
     * 
     */
    @Export(name="fixedScale", refs={PoolFixedScale.class}, tree="[0]")
    private Output</* @Nullable */ PoolFixedScale> fixedScale;

    /**
     * @return A `fixed_scale` block that describes the scale settings when using fixed scale as defined below.
     * 
     */
    public Output<Optional<PoolFixedScale>> fixedScale() {
        return Codegen.optional(this.fixedScale);
    }
    /**
     * An `identity` block as defined below.
     * 
     */
    @Export(name="identity", refs={PoolIdentity.class}, tree="[0]")
    private Output</* @Nullable */ PoolIdentity> identity;

    /**
     * @return An `identity` block as defined below.
     * 
     */
    public Output<Optional<PoolIdentity>> identity() {
        return Codegen.optional(this.identity);
    }
    /**
     * Whether the pool permits direct communication between nodes. This imposes restrictions on which nodes can be assigned to the pool. Enabling this value can reduce the chance of the requested number of nodes to be allocated in the pool. Values allowed are `Disabled` and `Enabled`. Defaults to `Enabled`.
     * 
     */
    @Export(name="interNodeCommunication", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> interNodeCommunication;

    /**
     * @return Whether the pool permits direct communication between nodes. This imposes restrictions on which nodes can be assigned to the pool. Enabling this value can reduce the chance of the requested number of nodes to be allocated in the pool. Values allowed are `Disabled` and `Enabled`. Defaults to `Enabled`.
     * 
     */
    public Output<Optional<String>> interNodeCommunication() {
        return Codegen.optional(this.interNodeCommunication);
    }
    /**
     * The type of on-premises license to be used when deploying the operating system. This only applies to images that contain the Windows operating system, and should only be used when you hold valid on-premises licenses for the nodes which will be deployed. If omitted, no on-premises licensing discount is applied. Values are: &#34;Windows_Server&#34; - The on-premises license is for Windows Server. &#34;Windows_Client&#34; - The on-premises license is for Windows Client.
     * 
     */
    @Export(name="licenseType", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> licenseType;

    /**
     * @return The type of on-premises license to be used when deploying the operating system. This only applies to images that contain the Windows operating system, and should only be used when you hold valid on-premises licenses for the nodes which will be deployed. If omitted, no on-premises licensing discount is applied. Values are: &#34;Windows_Server&#34; - The on-premises license is for Windows Server. &#34;Windows_Client&#34; - The on-premises license is for Windows Client.
     * 
     */
    public Output<Optional<String>> licenseType() {
        return Codegen.optional(this.licenseType);
    }
    /**
     * Specifies the maximum number of tasks that can run concurrently on a single compute node in the pool. Defaults to `1`. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="maxTasksPerNode", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> maxTasksPerNode;

    /**
     * @return Specifies the maximum number of tasks that can run concurrently on a single compute node in the pool. Defaults to `1`. Changing this forces a new resource to be created.
     * 
     */
    public Output<Optional<Integer>> maxTasksPerNode() {
        return Codegen.optional(this.maxTasksPerNode);
    }
    /**
     * A map of custom batch pool metadata.
     * 
     */
    @Export(name="metadata", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output</* @Nullable */ Map<String,String>> metadata;

    /**
     * @return A map of custom batch pool metadata.
     * 
     */
    public Output<Optional<Map<String,String>>> metadata() {
        return Codegen.optional(this.metadata);
    }
    /**
     * A `mount` block defined as below.
     * 
     */
    @Export(name="mounts", refs={List.class,PoolMount.class}, tree="[0,1]")
    private Output</* @Nullable */ List<PoolMount>> mounts;

    /**
     * @return A `mount` block defined as below.
     * 
     */
    public Output<Optional<List<PoolMount>>> mounts() {
        return Codegen.optional(this.mounts);
    }
    /**
     * Specifies the name of the Batch pool. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    /**
     * @return Specifies the name of the Batch pool. Changing this forces a new resource to be created.
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * A `network_configuration` block that describes the network configurations for the Batch pool as defined below. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="networkConfiguration", refs={PoolNetworkConfiguration.class}, tree="[0]")
    private Output</* @Nullable */ PoolNetworkConfiguration> networkConfiguration;

    /**
     * @return A `network_configuration` block that describes the network configurations for the Batch pool as defined below. Changing this forces a new resource to be created.
     * 
     */
    public Output<Optional<PoolNetworkConfiguration>> networkConfiguration() {
        return Codegen.optional(this.networkConfiguration);
    }
    /**
     * Specifies the SKU of the node agents that will be created in the Batch pool. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="nodeAgentSkuId", refs={String.class}, tree="[0]")
    private Output<String> nodeAgentSkuId;

    /**
     * @return Specifies the SKU of the node agents that will be created in the Batch pool. Changing this forces a new resource to be created.
     * 
     */
    public Output<String> nodeAgentSkuId() {
        return this.nodeAgentSkuId;
    }
    /**
     * A `node_placement` block that describes the placement policy for allocating nodes in the pool as defined below.
     * 
     */
    @Export(name="nodePlacements", refs={List.class,PoolNodePlacement.class}, tree="[0,1]")
    private Output</* @Nullable */ List<PoolNodePlacement>> nodePlacements;

    /**
     * @return A `node_placement` block that describes the placement policy for allocating nodes in the pool as defined below.
     * 
     */
    public Output<Optional<List<PoolNodePlacement>>> nodePlacements() {
        return Codegen.optional(this.nodePlacements);
    }
    /**
     * Specifies the ephemeral disk placement for operating system disk for all VMs in the pool. This property can be used by user in the request to choose which location the operating system should be in. e.g., cache disk space for Ephemeral OS disk provisioning. For more information on Ephemeral OS disk size requirements, please refer to Ephemeral OS disk size requirements for Windows VMs at &lt;https://docs.microsoft.com/en-us/azure/virtual-machines/windows/ephemeral-os-disks#size-requirements&gt; and Linux VMs at &lt;https://docs.microsoft.com/en-us/azure/virtual-machines/linux/ephemeral-os-disks#size-requirements&gt;. The only possible value is `CacheDisk`.
     * 
     */
    @Export(name="osDiskPlacement", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> osDiskPlacement;

    /**
     * @return Specifies the ephemeral disk placement for operating system disk for all VMs in the pool. This property can be used by user in the request to choose which location the operating system should be in. e.g., cache disk space for Ephemeral OS disk provisioning. For more information on Ephemeral OS disk size requirements, please refer to Ephemeral OS disk size requirements for Windows VMs at &lt;https://docs.microsoft.com/en-us/azure/virtual-machines/windows/ephemeral-os-disks#size-requirements&gt; and Linux VMs at &lt;https://docs.microsoft.com/en-us/azure/virtual-machines/linux/ephemeral-os-disks#size-requirements&gt;. The only possible value is `CacheDisk`.
     * 
     */
    public Output<Optional<String>> osDiskPlacement() {
        return Codegen.optional(this.osDiskPlacement);
    }
    /**
     * The name of the resource group in which to create the Batch pool. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="resourceGroupName", refs={String.class}, tree="[0]")
    private Output<String> resourceGroupName;

    /**
     * @return The name of the resource group in which to create the Batch pool. Changing this forces a new resource to be created.
     * 
     */
    public Output<String> resourceGroupName() {
        return this.resourceGroupName;
    }
    /**
     * A `security_profile` block that describes the security settings for the Batch pool as defined below. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="securityProfile", refs={PoolSecurityProfile.class}, tree="[0]")
    private Output</* @Nullable */ PoolSecurityProfile> securityProfile;

    /**
     * @return A `security_profile` block that describes the security settings for the Batch pool as defined below. Changing this forces a new resource to be created.
     * 
     */
    public Output<Optional<PoolSecurityProfile>> securityProfile() {
        return Codegen.optional(this.securityProfile);
    }
    /**
     * A `start_task` block that describes the start task settings for the Batch pool as defined below.
     * 
     */
    @Export(name="startTask", refs={PoolStartTask.class}, tree="[0]")
    private Output</* @Nullable */ PoolStartTask> startTask;

    /**
     * @return A `start_task` block that describes the start task settings for the Batch pool as defined below.
     * 
     */
    public Output<Optional<PoolStartTask>> startTask() {
        return Codegen.optional(this.startTask);
    }
    /**
     * Whether to stop if there is a pending resize operation on this pool.
     * 
     */
    @Export(name="stopPendingResizeOperation", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> stopPendingResizeOperation;

    /**
     * @return Whether to stop if there is a pending resize operation on this pool.
     * 
     */
    public Output<Optional<Boolean>> stopPendingResizeOperation() {
        return Codegen.optional(this.stopPendingResizeOperation);
    }
    /**
     * A `storage_image_reference` block for the virtual machines that will compose the Batch pool as defined below. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="storageImageReference", refs={PoolStorageImageReference.class}, tree="[0]")
    private Output<PoolStorageImageReference> storageImageReference;

    /**
     * @return A `storage_image_reference` block for the virtual machines that will compose the Batch pool as defined below. Changing this forces a new resource to be created.
     * 
     */
    public Output<PoolStorageImageReference> storageImageReference() {
        return this.storageImageReference;
    }
    /**
     * The desired node communication mode for the pool. Possible values are `Classic`, `Default` and `Simplified`.
     * 
     */
    @Export(name="targetNodeCommunicationMode", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> targetNodeCommunicationMode;

    /**
     * @return The desired node communication mode for the pool. Possible values are `Classic`, `Default` and `Simplified`.
     * 
     */
    public Output<Optional<String>> targetNodeCommunicationMode() {
        return Codegen.optional(this.targetNodeCommunicationMode);
    }
    /**
     * A `task_scheduling_policy` block that describes how tasks are distributed across compute nodes in a pool as defined below. If not specified, the default is spread as defined below.
     * 
     */
    @Export(name="taskSchedulingPolicies", refs={List.class,PoolTaskSchedulingPolicy.class}, tree="[0,1]")
    private Output<List<PoolTaskSchedulingPolicy>> taskSchedulingPolicies;

    /**
     * @return A `task_scheduling_policy` block that describes how tasks are distributed across compute nodes in a pool as defined below. If not specified, the default is spread as defined below.
     * 
     */
    public Output<List<PoolTaskSchedulingPolicy>> taskSchedulingPolicies() {
        return this.taskSchedulingPolicies;
    }
    /**
     * A `user_accounts` block that describes the list of user accounts to be created on each node in the pool as defined below.
     * 
     */
    @Export(name="userAccounts", refs={List.class,PoolUserAccount.class}, tree="[0,1]")
    private Output</* @Nullable */ List<PoolUserAccount>> userAccounts;

    /**
     * @return A `user_accounts` block that describes the list of user accounts to be created on each node in the pool as defined below.
     * 
     */
    public Output<Optional<List<PoolUserAccount>>> userAccounts() {
        return Codegen.optional(this.userAccounts);
    }
    /**
     * Specifies the size of the VM created in the Batch pool. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="vmSize", refs={String.class}, tree="[0]")
    private Output<String> vmSize;

    /**
     * @return Specifies the size of the VM created in the Batch pool. Changing this forces a new resource to be created.
     * 
     */
    public Output<String> vmSize() {
        return this.vmSize;
    }
    /**
     * A `windows` block that describes the Windows configuration in the pool as defined below.
     * 
     * &gt; **Note:** For Windows compute nodes, the Batch service installs the certificates to the specified certificate store and location. For Linux compute nodes, the certificates are stored in a directory inside the task working directory and an environment variable `AZ_BATCH_CERTIFICATES_DIR` is supplied to the task to query for this location. For certificates with visibility of `remoteUser`, a `certs` directory is created in the user&#39;s home directory (e.g., `/home/{user-name}/certs`) and certificates are placed in that directory.
     * 
     * &gt; **Note:** `fixed_scale` and `auto_scale` blocks cannot be used both at the same time.
     * 
     */
    @Export(name="windows", refs={List.class,PoolWindow.class}, tree="[0,1]")
    private Output</* @Nullable */ List<PoolWindow>> windows;

    /**
     * @return A `windows` block that describes the Windows configuration in the pool as defined below.
     * 
     * &gt; **Note:** For Windows compute nodes, the Batch service installs the certificates to the specified certificate store and location. For Linux compute nodes, the certificates are stored in a directory inside the task working directory and an environment variable `AZ_BATCH_CERTIFICATES_DIR` is supplied to the task to query for this location. For certificates with visibility of `remoteUser`, a `certs` directory is created in the user&#39;s home directory (e.g., `/home/{user-name}/certs`) and certificates are placed in that directory.
     * 
     * &gt; **Note:** `fixed_scale` and `auto_scale` blocks cannot be used both at the same time.
     * 
     */
    public Output<Optional<List<PoolWindow>>> windows() {
        return Codegen.optional(this.windows);
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public Pool(java.lang.String name) {
        this(name, PoolArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public Pool(java.lang.String name, PoolArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public Pool(java.lang.String name, PoolArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("azure:batch/pool:Pool", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private Pool(java.lang.String name, Output<java.lang.String> id, @Nullable PoolState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("azure:batch/pool:Pool", name, state, makeResourceOptions(options, id), false);
    }

    private static PoolArgs makeArgs(PoolArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? PoolArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static Pool get(java.lang.String name, Output<java.lang.String> id, @Nullable PoolState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new Pool(name, id, state, options);
    }
}
