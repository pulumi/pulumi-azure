// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.azure.compute;

import com.pulumi.azure.Utilities;
import com.pulumi.azure.compute.ManagedDiskArgs;
import com.pulumi.azure.compute.inputs.ManagedDiskState;
import com.pulumi.azure.compute.outputs.ManagedDiskEncryptionSettings;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * Manages a managed disk.
 * 
 * ## Example Usage
 * 
 * ### With Create Empty
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.azure.core.ResourceGroup;
 * import com.pulumi.azure.core.ResourceGroupArgs;
 * import com.pulumi.azure.compute.ManagedDisk;
 * import com.pulumi.azure.compute.ManagedDiskArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var example = new ResourceGroup("example", ResourceGroupArgs.builder()
 *             .name("example-resources")
 *             .location("West Europe")
 *             .build());
 * 
 *         var exampleManagedDisk = new ManagedDisk("exampleManagedDisk", ManagedDiskArgs.builder()
 *             .name("acctestmd")
 *             .location(example.location())
 *             .resourceGroupName(example.name())
 *             .storageAccountType("Standard_LRS")
 *             .createOption("Empty")
 *             .diskSizeGb(1)
 *             .tags(Map.of("environment", "staging"))
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ### With Create Copy
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.azure.core.ResourceGroup;
 * import com.pulumi.azure.core.ResourceGroupArgs;
 * import com.pulumi.azure.compute.ManagedDisk;
 * import com.pulumi.azure.compute.ManagedDiskArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var example = new ResourceGroup("example", ResourceGroupArgs.builder()
 *             .name("example-resources")
 *             .location("West Europe")
 *             .build());
 * 
 *         var source = new ManagedDisk("source", ManagedDiskArgs.builder()
 *             .name("acctestmd1")
 *             .location(example.location())
 *             .resourceGroupName(example.name())
 *             .storageAccountType("Standard_LRS")
 *             .createOption("Empty")
 *             .diskSizeGb(1)
 *             .tags(Map.of("environment", "staging"))
 *             .build());
 * 
 *         var copy = new ManagedDisk("copy", ManagedDiskArgs.builder()
 *             .name("acctestmd2")
 *             .location(example.location())
 *             .resourceGroupName(example.name())
 *             .storageAccountType("Standard_LRS")
 *             .createOption("Copy")
 *             .sourceResourceId(source.id())
 *             .diskSizeGb(1)
 *             .tags(Map.of("environment", "staging"))
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ## API Providers
 * 
 * &lt;!-- This section is generated, changes will be overwritten --&gt;
 * This resource uses the following Azure API Providers:
 * 
 * * `Microsoft.Compute` - 2023-04-02
 * 
 * ## Import
 * 
 * Managed Disks can be imported using the `resource id`, e.g.
 * 
 * ```sh
 * $ pulumi import azure:compute/managedDisk:ManagedDisk example /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/mygroup1/providers/Microsoft.Compute/disks/manageddisk1
 * ```
 * 
 */
@ResourceType(type="azure:compute/managedDisk:ManagedDisk")
public class ManagedDisk extends com.pulumi.resources.CustomResource {
    /**
     * The method to use when creating the managed disk. Changing this forces a new resource to be created. Possible values include:
     * * `Import` - Import a VHD file in to the managed disk (VHD specified with `source_uri`).
     * * `ImportSecure` - Securely import a VHD file in to the managed disk (VHD specified with `source_uri`).
     * * `Empty` - Create an empty managed disk.
     * * `Copy` - Copy an existing managed disk or snapshot (specified with `source_resource_id`).
     * * `FromImage` - Copy a Platform Image (specified with `image_reference_id`)
     * * `Restore` - Set by Azure Backup or Site Recovery on a restored disk (specified with `source_resource_id`).
     * * `Upload` - Upload a VHD disk with the help of SAS URL (to be used with `upload_size_bytes`).
     * 
     */
    @Export(name="createOption", refs={String.class}, tree="[0]")
    private Output<String> createOption;

    /**
     * @return The method to use when creating the managed disk. Changing this forces a new resource to be created. Possible values include:
     * * `Import` - Import a VHD file in to the managed disk (VHD specified with `source_uri`).
     * * `ImportSecure` - Securely import a VHD file in to the managed disk (VHD specified with `source_uri`).
     * * `Empty` - Create an empty managed disk.
     * * `Copy` - Copy an existing managed disk or snapshot (specified with `source_resource_id`).
     * * `FromImage` - Copy a Platform Image (specified with `image_reference_id`)
     * * `Restore` - Set by Azure Backup or Site Recovery on a restored disk (specified with `source_resource_id`).
     * * `Upload` - Upload a VHD disk with the help of SAS URL (to be used with `upload_size_bytes`).
     * 
     */
    public Output<String> createOption() {
        return this.createOption;
    }
    /**
     * The ID of the disk access resource for using private endpoints on disks.
     * 
     * &gt; **Note:** `disk_access_id` is only supported when `network_access_policy` is set to `AllowPrivate`.
     * 
     */
    @Export(name="diskAccessId", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> diskAccessId;

    /**
     * @return The ID of the disk access resource for using private endpoints on disks.
     * 
     * &gt; **Note:** `disk_access_id` is only supported when `network_access_policy` is set to `AllowPrivate`.
     * 
     */
    public Output<Optional<String>> diskAccessId() {
        return Codegen.optional(this.diskAccessId);
    }
    /**
     * The ID of a Disk Encryption Set which should be used to encrypt this Managed Disk. Conflicts with `secure_vm_disk_encryption_set_id`.
     * 
     * &gt; **NOTE:** The Disk Encryption Set must have the `Reader` Role Assignment scoped on the Key Vault - in addition to an Access Policy to the Key Vault
     * 
     * &gt; **NOTE:** Disk Encryption Sets are in Public Preview in a limited set of regions
     * 
     */
    @Export(name="diskEncryptionSetId", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> diskEncryptionSetId;

    /**
     * @return The ID of a Disk Encryption Set which should be used to encrypt this Managed Disk. Conflicts with `secure_vm_disk_encryption_set_id`.
     * 
     * &gt; **NOTE:** The Disk Encryption Set must have the `Reader` Role Assignment scoped on the Key Vault - in addition to an Access Policy to the Key Vault
     * 
     * &gt; **NOTE:** Disk Encryption Sets are in Public Preview in a limited set of regions
     * 
     */
    public Output<Optional<String>> diskEncryptionSetId() {
        return Codegen.optional(this.diskEncryptionSetId);
    }
    /**
     * The number of IOPS allowed across all VMs mounting the shared disk as read-only; only settable for UltraSSD disks and PremiumV2 disks with shared disk enabled. One operation can transfer between 4k and 256k bytes.
     * 
     */
    @Export(name="diskIopsReadOnly", refs={Integer.class}, tree="[0]")
    private Output<Integer> diskIopsReadOnly;

    /**
     * @return The number of IOPS allowed across all VMs mounting the shared disk as read-only; only settable for UltraSSD disks and PremiumV2 disks with shared disk enabled. One operation can transfer between 4k and 256k bytes.
     * 
     */
    public Output<Integer> diskIopsReadOnly() {
        return this.diskIopsReadOnly;
    }
    /**
     * The number of IOPS allowed for this disk; only settable for UltraSSD disks and PremiumV2 disks. One operation can transfer between 4k and 256k bytes.
     * 
     */
    @Export(name="diskIopsReadWrite", refs={Integer.class}, tree="[0]")
    private Output<Integer> diskIopsReadWrite;

    /**
     * @return The number of IOPS allowed for this disk; only settable for UltraSSD disks and PremiumV2 disks. One operation can transfer between 4k and 256k bytes.
     * 
     */
    public Output<Integer> diskIopsReadWrite() {
        return this.diskIopsReadWrite;
    }
    /**
     * The bandwidth allowed across all VMs mounting the shared disk as read-only; only settable for UltraSSD disks and PremiumV2 disks with shared disk enabled. MBps means millions of bytes per second.
     * 
     */
    @Export(name="diskMbpsReadOnly", refs={Integer.class}, tree="[0]")
    private Output<Integer> diskMbpsReadOnly;

    /**
     * @return The bandwidth allowed across all VMs mounting the shared disk as read-only; only settable for UltraSSD disks and PremiumV2 disks with shared disk enabled. MBps means millions of bytes per second.
     * 
     */
    public Output<Integer> diskMbpsReadOnly() {
        return this.diskMbpsReadOnly;
    }
    /**
     * The bandwidth allowed for this disk; only settable for UltraSSD disks and PremiumV2 disks. MBps means millions of bytes per second.
     * 
     */
    @Export(name="diskMbpsReadWrite", refs={Integer.class}, tree="[0]")
    private Output<Integer> diskMbpsReadWrite;

    /**
     * @return The bandwidth allowed for this disk; only settable for UltraSSD disks and PremiumV2 disks. MBps means millions of bytes per second.
     * 
     */
    public Output<Integer> diskMbpsReadWrite() {
        return this.diskMbpsReadWrite;
    }
    @Export(name="diskSizeGb", refs={Integer.class}, tree="[0]")
    private Output<Integer> diskSizeGb;

    public Output<Integer> diskSizeGb() {
        return this.diskSizeGb;
    }
    /**
     * Specifies the Edge Zone within the Azure Region where this Managed Disk should exist. Changing this forces a new Managed Disk to be created.
     * 
     */
    @Export(name="edgeZone", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> edgeZone;

    /**
     * @return Specifies the Edge Zone within the Azure Region where this Managed Disk should exist. Changing this forces a new Managed Disk to be created.
     * 
     */
    public Output<Optional<String>> edgeZone() {
        return Codegen.optional(this.edgeZone);
    }
    /**
     * A `encryption_settings` block as defined below.
     * 
     * &gt; **NOTE:** Removing `encryption_settings` forces a new resource to be created.
     * 
     */
    @Export(name="encryptionSettings", refs={ManagedDiskEncryptionSettings.class}, tree="[0]")
    private Output</* @Nullable */ ManagedDiskEncryptionSettings> encryptionSettings;

    /**
     * @return A `encryption_settings` block as defined below.
     * 
     * &gt; **NOTE:** Removing `encryption_settings` forces a new resource to be created.
     * 
     */
    public Output<Optional<ManagedDiskEncryptionSettings>> encryptionSettings() {
        return Codegen.optional(this.encryptionSettings);
    }
    /**
     * ID of a Gallery Image Version to copy when `create_option` is `FromImage`. This field cannot be specified if image_reference_id is specified. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="galleryImageReferenceId", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> galleryImageReferenceId;

    /**
     * @return ID of a Gallery Image Version to copy when `create_option` is `FromImage`. This field cannot be specified if image_reference_id is specified. Changing this forces a new resource to be created.
     * 
     */
    public Output<Optional<String>> galleryImageReferenceId() {
        return Codegen.optional(this.galleryImageReferenceId);
    }
    /**
     * The HyperV Generation of the Disk when the source of an `Import` or `Copy` operation targets a source that contains an operating system. Possible values are `V1` and `V2`. For `ImportSecure` it must be set to `V2`. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="hyperVGeneration", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> hyperVGeneration;

    /**
     * @return The HyperV Generation of the Disk when the source of an `Import` or `Copy` operation targets a source that contains an operating system. Possible values are `V1` and `V2`. For `ImportSecure` it must be set to `V2`. Changing this forces a new resource to be created.
     * 
     */
    public Output<Optional<String>> hyperVGeneration() {
        return Codegen.optional(this.hyperVGeneration);
    }
    /**
     * ID of an existing platform/marketplace disk image to copy when `create_option` is `FromImage`. This field cannot be specified if gallery_image_reference_id is specified. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="imageReferenceId", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> imageReferenceId;

    /**
     * @return ID of an existing platform/marketplace disk image to copy when `create_option` is `FromImage`. This field cannot be specified if gallery_image_reference_id is specified. Changing this forces a new resource to be created.
     * 
     */
    public Output<Optional<String>> imageReferenceId() {
        return Codegen.optional(this.imageReferenceId);
    }
    /**
     * Specified the supported Azure location where the resource exists. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="location", refs={String.class}, tree="[0]")
    private Output<String> location;

    /**
     * @return Specified the supported Azure location where the resource exists. Changing this forces a new resource to be created.
     * 
     */
    public Output<String> location() {
        return this.location;
    }
    /**
     * Logical Sector Size. Possible values are: `512` and `4096`. Defaults to `4096`. Changing this forces a new resource to be created.
     * 
     * &gt; **NOTE:** Setting logical sector size is supported only with `UltraSSD_LRS` disks and `PremiumV2_LRS` disks.
     * 
     */
    @Export(name="logicalSectorSize", refs={Integer.class}, tree="[0]")
    private Output<Integer> logicalSectorSize;

    /**
     * @return Logical Sector Size. Possible values are: `512` and `4096`. Defaults to `4096`. Changing this forces a new resource to be created.
     * 
     * &gt; **NOTE:** Setting logical sector size is supported only with `UltraSSD_LRS` disks and `PremiumV2_LRS` disks.
     * 
     */
    public Output<Integer> logicalSectorSize() {
        return this.logicalSectorSize;
    }
    /**
     * The maximum number of VMs that can attach to the disk at the same time. Value greater than one indicates a disk that can be mounted on multiple VMs at the same time.
     * 
     * &gt; **Note:** Premium SSD maxShares limit: `P15` and `P20` disks: 2. `P30`,`P40`,`P50` disks: 5. `P60`,`P70`,`P80` disks: 10. For ultra disks the `max_shares` minimum value is 1 and the maximum is 5.
     * 
     */
    @Export(name="maxShares", refs={Integer.class}, tree="[0]")
    private Output<Integer> maxShares;

    /**
     * @return The maximum number of VMs that can attach to the disk at the same time. Value greater than one indicates a disk that can be mounted on multiple VMs at the same time.
     * 
     * &gt; **Note:** Premium SSD maxShares limit: `P15` and `P20` disks: 2. `P30`,`P40`,`P50` disks: 5. `P60`,`P70`,`P80` disks: 10. For ultra disks the `max_shares` minimum value is 1 and the maximum is 5.
     * 
     */
    public Output<Integer> maxShares() {
        return this.maxShares;
    }
    /**
     * Specifies the name of the Managed Disk. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    /**
     * @return Specifies the name of the Managed Disk. Changing this forces a new resource to be created.
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * Policy for accessing the disk via network. Allowed values are `AllowAll`, `AllowPrivate`, and `DenyAll`.
     * 
     */
    @Export(name="networkAccessPolicy", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> networkAccessPolicy;

    /**
     * @return Policy for accessing the disk via network. Allowed values are `AllowAll`, `AllowPrivate`, and `DenyAll`.
     * 
     */
    public Output<Optional<String>> networkAccessPolicy() {
        return Codegen.optional(this.networkAccessPolicy);
    }
    /**
     * Specifies if On-Demand Bursting is enabled for the Managed Disk.
     * 
     * &gt; **Note:** Credit-Based Bursting is enabled by default on all eligible disks. More information on [Credit-Based and On-Demand Bursting can be found in the documentation](https://docs.microsoft.com/azure/virtual-machines/disk-bursting#disk-level-bursting).
     * 
     */
    @Export(name="onDemandBurstingEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> onDemandBurstingEnabled;

    /**
     * @return Specifies if On-Demand Bursting is enabled for the Managed Disk.
     * 
     * &gt; **Note:** Credit-Based Bursting is enabled by default on all eligible disks. More information on [Credit-Based and On-Demand Bursting can be found in the documentation](https://docs.microsoft.com/azure/virtual-machines/disk-bursting#disk-level-bursting).
     * 
     */
    public Output<Optional<Boolean>> onDemandBurstingEnabled() {
        return Codegen.optional(this.onDemandBurstingEnabled);
    }
    /**
     * Specifies whether this Managed Disk should be optimized for frequent disk attachments (where a disk is attached/detached more than 5 times in a day). Defaults to `false`.
     * 
     * &gt; **Note:** Setting `optimized_frequent_attach_enabled` to `true` causes the disks to not align with the fault domain of the Virtual Machine, which can have operational implications.
     * 
     */
    @Export(name="optimizedFrequentAttachEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> optimizedFrequentAttachEnabled;

    /**
     * @return Specifies whether this Managed Disk should be optimized for frequent disk attachments (where a disk is attached/detached more than 5 times in a day). Defaults to `false`.
     * 
     * &gt; **Note:** Setting `optimized_frequent_attach_enabled` to `true` causes the disks to not align with the fault domain of the Virtual Machine, which can have operational implications.
     * 
     */
    public Output<Optional<Boolean>> optimizedFrequentAttachEnabled() {
        return Codegen.optional(this.optimizedFrequentAttachEnabled);
    }
    /**
     * Specify a value when the source of an `Import`, `ImportSecure` or `Copy` operation targets a source that contains an operating system. Valid values are `Linux` or `Windows`.
     * 
     */
    @Export(name="osType", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> osType;

    /**
     * @return Specify a value when the source of an `Import`, `ImportSecure` or `Copy` operation targets a source that contains an operating system. Valid values are `Linux` or `Windows`.
     * 
     */
    public Output<Optional<String>> osType() {
        return Codegen.optional(this.osType);
    }
    /**
     * Specifies whether Performance Plus is enabled for this Managed Disk. Defaults to `false`. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="performancePlusEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> performancePlusEnabled;

    /**
     * @return Specifies whether Performance Plus is enabled for this Managed Disk. Defaults to `false`. Changing this forces a new resource to be created.
     * 
     */
    public Output<Optional<Boolean>> performancePlusEnabled() {
        return Codegen.optional(this.performancePlusEnabled);
    }
    /**
     * Whether it is allowed to access the disk via public network. Defaults to `true`.
     * 
     * For more information on managed disks, such as sizing options and pricing, please check out the [Azure Documentation](https://docs.microsoft.com/azure/storage/storage-managed-disks-overview).
     * 
     */
    @Export(name="publicNetworkAccessEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> publicNetworkAccessEnabled;

    /**
     * @return Whether it is allowed to access the disk via public network. Defaults to `true`.
     * 
     * For more information on managed disks, such as sizing options and pricing, please check out the [Azure Documentation](https://docs.microsoft.com/azure/storage/storage-managed-disks-overview).
     * 
     */
    public Output<Optional<Boolean>> publicNetworkAccessEnabled() {
        return Codegen.optional(this.publicNetworkAccessEnabled);
    }
    /**
     * The name of the Resource Group where the Managed Disk should exist. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="resourceGroupName", refs={String.class}, tree="[0]")
    private Output<String> resourceGroupName;

    /**
     * @return The name of the Resource Group where the Managed Disk should exist. Changing this forces a new resource to be created.
     * 
     */
    public Output<String> resourceGroupName() {
        return this.resourceGroupName;
    }
    /**
     * The ID of the Disk Encryption Set which should be used to Encrypt this OS Disk when the Virtual Machine is a Confidential VM. Conflicts with `disk_encryption_set_id`. Changing this forces a new resource to be created.
     * 
     * &gt; **NOTE:** `secure_vm_disk_encryption_set_id` can only be specified when `security_type` is set to `ConfidentialVM_DiskEncryptedWithCustomerKey`.
     * 
     */
    @Export(name="secureVmDiskEncryptionSetId", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> secureVmDiskEncryptionSetId;

    /**
     * @return The ID of the Disk Encryption Set which should be used to Encrypt this OS Disk when the Virtual Machine is a Confidential VM. Conflicts with `disk_encryption_set_id`. Changing this forces a new resource to be created.
     * 
     * &gt; **NOTE:** `secure_vm_disk_encryption_set_id` can only be specified when `security_type` is set to `ConfidentialVM_DiskEncryptedWithCustomerKey`.
     * 
     */
    public Output<Optional<String>> secureVmDiskEncryptionSetId() {
        return Codegen.optional(this.secureVmDiskEncryptionSetId);
    }
    /**
     * Security Type of the Managed Disk when it is used for a Confidential VM. Possible values are `ConfidentialVM_VMGuestStateOnlyEncryptedWithPlatformKey`, `ConfidentialVM_DiskEncryptedWithPlatformKey` and `ConfidentialVM_DiskEncryptedWithCustomerKey`. Changing this forces a new resource to be created.
     * 
     * &gt; **NOTE:** When `security_type` is set to `ConfidentialVM_DiskEncryptedWithCustomerKey` the value of `create_option` must be one of `FromImage` or `ImportSecure`.
     * 
     * &gt; **NOTE:** `security_type` cannot be specified when `trusted_launch_enabled` is set to true.
     * 
     * &gt; **NOTE:** `secure_vm_disk_encryption_set_id` must be specified when `security_type` is set to `ConfidentialVM_DiskEncryptedWithCustomerKey`.
     * 
     */
    @Export(name="securityType", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> securityType;

    /**
     * @return Security Type of the Managed Disk when it is used for a Confidential VM. Possible values are `ConfidentialVM_VMGuestStateOnlyEncryptedWithPlatformKey`, `ConfidentialVM_DiskEncryptedWithPlatformKey` and `ConfidentialVM_DiskEncryptedWithCustomerKey`. Changing this forces a new resource to be created.
     * 
     * &gt; **NOTE:** When `security_type` is set to `ConfidentialVM_DiskEncryptedWithCustomerKey` the value of `create_option` must be one of `FromImage` or `ImportSecure`.
     * 
     * &gt; **NOTE:** `security_type` cannot be specified when `trusted_launch_enabled` is set to true.
     * 
     * &gt; **NOTE:** `secure_vm_disk_encryption_set_id` must be specified when `security_type` is set to `ConfidentialVM_DiskEncryptedWithCustomerKey`.
     * 
     */
    public Output<Optional<String>> securityType() {
        return Codegen.optional(this.securityType);
    }
    /**
     * The ID of an existing Managed Disk or Snapshot to copy when `create_option` is `Copy` or the recovery point to restore when `create_option` is `Restore`. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="sourceResourceId", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> sourceResourceId;

    /**
     * @return The ID of an existing Managed Disk or Snapshot to copy when `create_option` is `Copy` or the recovery point to restore when `create_option` is `Restore`. Changing this forces a new resource to be created.
     * 
     */
    public Output<Optional<String>> sourceResourceId() {
        return Codegen.optional(this.sourceResourceId);
    }
    /**
     * URI to a valid VHD file to be used when `create_option` is `Import` or `ImportSecure`. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="sourceUri", refs={String.class}, tree="[0]")
    private Output<String> sourceUri;

    /**
     * @return URI to a valid VHD file to be used when `create_option` is `Import` or `ImportSecure`. Changing this forces a new resource to be created.
     * 
     */
    public Output<String> sourceUri() {
        return this.sourceUri;
    }
    /**
     * The ID of the Storage Account where the `source_uri` is located. Required when `create_option` is set to `Import` or `ImportSecure`. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="storageAccountId", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> storageAccountId;

    /**
     * @return The ID of the Storage Account where the `source_uri` is located. Required when `create_option` is set to `Import` or `ImportSecure`. Changing this forces a new resource to be created.
     * 
     */
    public Output<Optional<String>> storageAccountId() {
        return Codegen.optional(this.storageAccountId);
    }
    /**
     * The type of storage to use for the managed disk. Possible values are `Standard_LRS`, `StandardSSD_ZRS`, `Premium_LRS`, `PremiumV2_LRS`, `Premium_ZRS`, `StandardSSD_LRS` or `UltraSSD_LRS`.
     * 
     * &gt; **Note:** Azure Ultra Disk Storage is only available in a region that support availability zones and can only enabled on the following VM series: `ESv3`, `DSv3`, `FSv3`, `LSv2`, `M` and `Mv2`. For more information see the `Azure Ultra Disk Storage` [product documentation](https://docs.microsoft.com/azure/virtual-machines/windows/disks-enable-ultra-ssd).
     * 
     */
    @Export(name="storageAccountType", refs={String.class}, tree="[0]")
    private Output<String> storageAccountType;

    /**
     * @return The type of storage to use for the managed disk. Possible values are `Standard_LRS`, `StandardSSD_ZRS`, `Premium_LRS`, `PremiumV2_LRS`, `Premium_ZRS`, `StandardSSD_LRS` or `UltraSSD_LRS`.
     * 
     * &gt; **Note:** Azure Ultra Disk Storage is only available in a region that support availability zones and can only enabled on the following VM series: `ESv3`, `DSv3`, `FSv3`, `LSv2`, `M` and `Mv2`. For more information see the `Azure Ultra Disk Storage` [product documentation](https://docs.microsoft.com/azure/virtual-machines/windows/disks-enable-ultra-ssd).
     * 
     */
    public Output<String> storageAccountType() {
        return this.storageAccountType;
    }
    /**
     * A mapping of tags to assign to the resource.
     * 
     */
    @Export(name="tags", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output</* @Nullable */ Map<String,String>> tags;

    /**
     * @return A mapping of tags to assign to the resource.
     * 
     */
    public Output<Optional<Map<String,String>>> tags() {
        return Codegen.optional(this.tags);
    }
    @Export(name="tier", refs={String.class}, tree="[0]")
    private Output<String> tier;

    public Output<String> tier() {
        return this.tier;
    }
    /**
     * Specifies if Trusted Launch is enabled for the Managed Disk. Changing this forces a new resource to be created.
     * 
     * &gt; **Note:** Trusted Launch can only be enabled when `create_option` is `FromImage` or `Import`.
     * 
     */
    @Export(name="trustedLaunchEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> trustedLaunchEnabled;

    /**
     * @return Specifies if Trusted Launch is enabled for the Managed Disk. Changing this forces a new resource to be created.
     * 
     * &gt; **Note:** Trusted Launch can only be enabled when `create_option` is `FromImage` or `Import`.
     * 
     */
    public Output<Optional<Boolean>> trustedLaunchEnabled() {
        return Codegen.optional(this.trustedLaunchEnabled);
    }
    /**
     * Specifies the size of the managed disk to create in bytes. Required when `create_option` is `Upload`. The value must be equal to the source disk to be copied in bytes. Source disk size could be calculated with `ls -l` or `wc -c`. More information can be found at [Copy a managed disk](https://learn.microsoft.com/en-us/azure/virtual-machines/linux/disks-upload-vhd-to-managed-disk-cli#copy-a-managed-disk). Changing this forces a new resource to be created.
     * 
     */
    @Export(name="uploadSizeBytes", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> uploadSizeBytes;

    /**
     * @return Specifies the size of the managed disk to create in bytes. Required when `create_option` is `Upload`. The value must be equal to the source disk to be copied in bytes. Source disk size could be calculated with `ls -l` or `wc -c`. More information can be found at [Copy a managed disk](https://learn.microsoft.com/en-us/azure/virtual-machines/linux/disks-upload-vhd-to-managed-disk-cli#copy-a-managed-disk). Changing this forces a new resource to be created.
     * 
     */
    public Output<Optional<Integer>> uploadSizeBytes() {
        return Codegen.optional(this.uploadSizeBytes);
    }
    /**
     * Specifies the Availability Zone in which this Managed Disk should be located. Changing this property forces a new resource to be created.
     * 
     * &gt; **Note:** Availability Zones are [only supported in select regions at this time](https://docs.microsoft.com/azure/availability-zones/az-overview).
     * 
     */
    @Export(name="zone", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> zone;

    /**
     * @return Specifies the Availability Zone in which this Managed Disk should be located. Changing this property forces a new resource to be created.
     * 
     * &gt; **Note:** Availability Zones are [only supported in select regions at this time](https://docs.microsoft.com/azure/availability-zones/az-overview).
     * 
     */
    public Output<Optional<String>> zone() {
        return Codegen.optional(this.zone);
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public ManagedDisk(java.lang.String name) {
        this(name, ManagedDiskArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public ManagedDisk(java.lang.String name, ManagedDiskArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public ManagedDisk(java.lang.String name, ManagedDiskArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("azure:compute/managedDisk:ManagedDisk", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private ManagedDisk(java.lang.String name, Output<java.lang.String> id, @Nullable ManagedDiskState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("azure:compute/managedDisk:ManagedDisk", name, state, makeResourceOptions(options, id), false);
    }

    private static ManagedDiskArgs makeArgs(ManagedDiskArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? ManagedDiskArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static ManagedDisk get(java.lang.String name, Output<java.lang.String> id, @Nullable ManagedDiskState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new ManagedDisk(name, id, state, options);
    }
}
