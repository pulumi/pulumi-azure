// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.azure.streamanalytics.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class OutputBlobSerializationArgs extends com.pulumi.resources.ResourceArgs {

    public static final OutputBlobSerializationArgs Empty = new OutputBlobSerializationArgs();

    /**
     * The encoding of the incoming data in the case of input and the encoding of outgoing data in the case of output. It currently can only be set to `UTF8`.
     * 
     * &gt; **Note:** This is required when `type` is set to `Csv` or `Json`.
     * 
     */
    @Import(name="encoding")
    private @Nullable Output<String> encoding;

    /**
     * @return The encoding of the incoming data in the case of input and the encoding of outgoing data in the case of output. It currently can only be set to `UTF8`.
     * 
     * &gt; **Note:** This is required when `type` is set to `Csv` or `Json`.
     * 
     */
    public Optional<Output<String>> encoding() {
        return Optional.ofNullable(this.encoding);
    }

    /**
     * The delimiter that will be used to separate comma-separated value (CSV) records. Possible values are ` ` (space), `,` (comma), `	` (tab), `|` (pipe) and `;`.
     * 
     * &gt; **Note:** This is required when `type` is set to `Csv`.
     * 
     */
    @Import(name="fieldDelimiter")
    private @Nullable Output<String> fieldDelimiter;

    /**
     * @return The delimiter that will be used to separate comma-separated value (CSV) records. Possible values are ` ` (space), `,` (comma), `	` (tab), `|` (pipe) and `;`.
     * 
     * &gt; **Note:** This is required when `type` is set to `Csv`.
     * 
     */
    public Optional<Output<String>> fieldDelimiter() {
        return Optional.ofNullable(this.fieldDelimiter);
    }

    /**
     * Specifies the format of the JSON the output will be written in. Possible values are `Array` and `LineSeparated`.
     * 
     * &gt; **Note:** This is Required and can only be specified when `type` is set to `Json`.
     * 
     */
    @Import(name="format")
    private @Nullable Output<String> format;

    /**
     * @return Specifies the format of the JSON the output will be written in. Possible values are `Array` and `LineSeparated`.
     * 
     * &gt; **Note:** This is Required and can only be specified when `type` is set to `Json`.
     * 
     */
    public Optional<Output<String>> format() {
        return Optional.ofNullable(this.format);
    }

    /**
     * The serialization format used for outgoing data streams. Possible values are `Avro`, `Csv`, `Json` and `Parquet`.
     * 
     * &gt; **Note:** `batch_max_wait_time` and `batch_min_rows` are required when `type` is set to `Parquet`
     * 
     */
    @Import(name="type", required=true)
    private Output<String> type;

    /**
     * @return The serialization format used for outgoing data streams. Possible values are `Avro`, `Csv`, `Json` and `Parquet`.
     * 
     * &gt; **Note:** `batch_max_wait_time` and `batch_min_rows` are required when `type` is set to `Parquet`
     * 
     */
    public Output<String> type() {
        return this.type;
    }

    private OutputBlobSerializationArgs() {}

    private OutputBlobSerializationArgs(OutputBlobSerializationArgs $) {
        this.encoding = $.encoding;
        this.fieldDelimiter = $.fieldDelimiter;
        this.format = $.format;
        this.type = $.type;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(OutputBlobSerializationArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private OutputBlobSerializationArgs $;

        public Builder() {
            $ = new OutputBlobSerializationArgs();
        }

        public Builder(OutputBlobSerializationArgs defaults) {
            $ = new OutputBlobSerializationArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param encoding The encoding of the incoming data in the case of input and the encoding of outgoing data in the case of output. It currently can only be set to `UTF8`.
         * 
         * &gt; **Note:** This is required when `type` is set to `Csv` or `Json`.
         * 
         * @return builder
         * 
         */
        public Builder encoding(@Nullable Output<String> encoding) {
            $.encoding = encoding;
            return this;
        }

        /**
         * @param encoding The encoding of the incoming data in the case of input and the encoding of outgoing data in the case of output. It currently can only be set to `UTF8`.
         * 
         * &gt; **Note:** This is required when `type` is set to `Csv` or `Json`.
         * 
         * @return builder
         * 
         */
        public Builder encoding(String encoding) {
            return encoding(Output.of(encoding));
        }

        /**
         * @param fieldDelimiter The delimiter that will be used to separate comma-separated value (CSV) records. Possible values are ` ` (space), `,` (comma), `	` (tab), `|` (pipe) and `;`.
         * 
         * &gt; **Note:** This is required when `type` is set to `Csv`.
         * 
         * @return builder
         * 
         */
        public Builder fieldDelimiter(@Nullable Output<String> fieldDelimiter) {
            $.fieldDelimiter = fieldDelimiter;
            return this;
        }

        /**
         * @param fieldDelimiter The delimiter that will be used to separate comma-separated value (CSV) records. Possible values are ` ` (space), `,` (comma), `	` (tab), `|` (pipe) and `;`.
         * 
         * &gt; **Note:** This is required when `type` is set to `Csv`.
         * 
         * @return builder
         * 
         */
        public Builder fieldDelimiter(String fieldDelimiter) {
            return fieldDelimiter(Output.of(fieldDelimiter));
        }

        /**
         * @param format Specifies the format of the JSON the output will be written in. Possible values are `Array` and `LineSeparated`.
         * 
         * &gt; **Note:** This is Required and can only be specified when `type` is set to `Json`.
         * 
         * @return builder
         * 
         */
        public Builder format(@Nullable Output<String> format) {
            $.format = format;
            return this;
        }

        /**
         * @param format Specifies the format of the JSON the output will be written in. Possible values are `Array` and `LineSeparated`.
         * 
         * &gt; **Note:** This is Required and can only be specified when `type` is set to `Json`.
         * 
         * @return builder
         * 
         */
        public Builder format(String format) {
            return format(Output.of(format));
        }

        /**
         * @param type The serialization format used for outgoing data streams. Possible values are `Avro`, `Csv`, `Json` and `Parquet`.
         * 
         * &gt; **Note:** `batch_max_wait_time` and `batch_min_rows` are required when `type` is set to `Parquet`
         * 
         * @return builder
         * 
         */
        public Builder type(Output<String> type) {
            $.type = type;
            return this;
        }

        /**
         * @param type The serialization format used for outgoing data streams. Possible values are `Avro`, `Csv`, `Json` and `Parquet`.
         * 
         * &gt; **Note:** `batch_max_wait_time` and `batch_min_rows` are required when `type` is set to `Parquet`
         * 
         * @return builder
         * 
         */
        public Builder type(String type) {
            return type(Output.of(type));
        }

        public OutputBlobSerializationArgs build() {
            if ($.type == null) {
                throw new MissingRequiredPropertyException("OutputBlobSerializationArgs", "type");
            }
            return $;
        }
    }

}
