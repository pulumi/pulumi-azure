// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.azure.siterecovery;

import com.pulumi.azure.siterecovery.inputs.VmwareReplicatedVmManagedDiskArgs;
import com.pulumi.azure.siterecovery.inputs.VmwareReplicatedVmNetworkInterfaceArgs;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class VmwareReplicatedVmArgs extends com.pulumi.resources.ResourceArgs {

    public static final VmwareReplicatedVmArgs Empty = new VmwareReplicatedVmArgs();

    /**
     * The name of VMWare appliance which handles the replication. Changing this forces a new resource to be created.
     * 
     */
    @Import(name="applianceName", required=true)
    private Output<String> applianceName;

    /**
     * @return The name of VMWare appliance which handles the replication. Changing this forces a new resource to be created.
     * 
     */
    public Output<String> applianceName() {
        return this.applianceName;
    }

    /**
     * The ID of the stroage account that should be used for logging during replication.
     * 
     * &gt; **Note:** Only standard types of storage accounts are allowed.
     * 
     * &gt; **Note:** Only one of `defaultLogStorageAccountId` or `managedDisk` must be specified.
     * 
     * &gt; **Note:** Changing `defaultLogStorageAccountId` forces a new resource to be created. But removing it does not.
     * 
     * &gt; **Note:** When `defaultLogStorageAccountId` co-exist with `managedDisk`, the value of `defaultLogStorageAccountId` must be as same as `logStorageAccountId` of every `managedDisk` or it forces a new resource to be created.
     * 
     */
    @Import(name="defaultLogStorageAccountId")
    private @Nullable Output<String> defaultLogStorageAccountId;

    /**
     * @return The ID of the stroage account that should be used for logging during replication.
     * 
     * &gt; **Note:** Only standard types of storage accounts are allowed.
     * 
     * &gt; **Note:** Only one of `defaultLogStorageAccountId` or `managedDisk` must be specified.
     * 
     * &gt; **Note:** Changing `defaultLogStorageAccountId` forces a new resource to be created. But removing it does not.
     * 
     * &gt; **Note:** When `defaultLogStorageAccountId` co-exist with `managedDisk`, the value of `defaultLogStorageAccountId` must be as same as `logStorageAccountId` of every `managedDisk` or it forces a new resource to be created.
     * 
     */
    public Optional<Output<String>> defaultLogStorageAccountId() {
        return Optional.ofNullable(this.defaultLogStorageAccountId);
    }

    /**
     * The type of storage account that should be used for recovery disks when a failover is done. Possible values are `Premium_LRS`, `Standard_LRS` and `StandardSSD_LRS`.
     * 
     * &gt; **Note:** Only one of `defaultRecoveryDiskType` or `managedDisk` must be specified.
     * 
     * &gt; **Note:** Changing `defaultRecoveryDiskType` forces a new resource to be created. But removing it does not.
     * 
     * &gt; **Note:** When `defaultRecoveryDiskType` co-exist with `managedDisk`, the value of `defaultRecoveryDiskType` must be as same as `targetDiskType` of every `managedDisk` or it forces a new resource to be created.
     * 
     */
    @Import(name="defaultRecoveryDiskType")
    private @Nullable Output<String> defaultRecoveryDiskType;

    /**
     * @return The type of storage account that should be used for recovery disks when a failover is done. Possible values are `Premium_LRS`, `Standard_LRS` and `StandardSSD_LRS`.
     * 
     * &gt; **Note:** Only one of `defaultRecoveryDiskType` or `managedDisk` must be specified.
     * 
     * &gt; **Note:** Changing `defaultRecoveryDiskType` forces a new resource to be created. But removing it does not.
     * 
     * &gt; **Note:** When `defaultRecoveryDiskType` co-exist with `managedDisk`, the value of `defaultRecoveryDiskType` must be as same as `targetDiskType` of every `managedDisk` or it forces a new resource to be created.
     * 
     */
    public Optional<Output<String>> defaultRecoveryDiskType() {
        return Optional.ofNullable(this.defaultRecoveryDiskType);
    }

    /**
     * The ID of the default Disk Encryption Set that should be used for the disks when a failover is done.
     * 
     * &gt; **Note:** Changing `defaultTargetDiskEncryptionSetId` forces a new resource to be created. But removing it does not.
     * 
     * &gt; **Note:** When `defaultTargetDiskEncryptionSetId` co-exist with `managedDisk`, the value of `defaultTargetDiskEncryptionSetId` must be as same as `targetDiskEncryptionSetId` of every `managedDisk` or it forces a new resource to be created.
     * 
     */
    @Import(name="defaultTargetDiskEncryptionSetId")
    private @Nullable Output<String> defaultTargetDiskEncryptionSetId;

    /**
     * @return The ID of the default Disk Encryption Set that should be used for the disks when a failover is done.
     * 
     * &gt; **Note:** Changing `defaultTargetDiskEncryptionSetId` forces a new resource to be created. But removing it does not.
     * 
     * &gt; **Note:** When `defaultTargetDiskEncryptionSetId` co-exist with `managedDisk`, the value of `defaultTargetDiskEncryptionSetId` must be as same as `targetDiskEncryptionSetId` of every `managedDisk` or it forces a new resource to be created.
     * 
     */
    public Optional<Output<String>> defaultTargetDiskEncryptionSetId() {
        return Optional.ofNullable(this.defaultTargetDiskEncryptionSetId);
    }

    /**
     * The license type of the VM. Possible values are `NoLicenseType`, `NotSpecified` and `WindowsServer`. Defaults to `NotSpecified`.
     * 
     */
    @Import(name="licenseType")
    private @Nullable Output<String> licenseType;

    /**
     * @return The license type of the VM. Possible values are `NoLicenseType`, `NotSpecified` and `WindowsServer`. Defaults to `NotSpecified`.
     * 
     */
    public Optional<Output<String>> licenseType() {
        return Optional.ofNullable(this.licenseType);
    }

    /**
     * One or more `managedDisk` block as defined below. It&#39;s available only if mobility service is already installed on the source VM.
     * 
     * &gt; **Note:** A replicated VM could be created without `managedDisk` block, once the block has been specified, changing it expect removing it forces a new resource to be created.
     * 
     */
    @Import(name="managedDisks")
    private @Nullable Output<List<VmwareReplicatedVmManagedDiskArgs>> managedDisks;

    /**
     * @return One or more `managedDisk` block as defined below. It&#39;s available only if mobility service is already installed on the source VM.
     * 
     * &gt; **Note:** A replicated VM could be created without `managedDisk` block, once the block has been specified, changing it expect removing it forces a new resource to be created.
     * 
     */
    public Optional<Output<List<VmwareReplicatedVmManagedDiskArgs>>> managedDisks() {
        return Optional.ofNullable(this.managedDisks);
    }

    /**
     * Name of group in which all machines will replicate together and have shared crash consistent and app-consistent recovery points when failed over.
     * 
     */
    @Import(name="multiVmGroupName")
    private @Nullable Output<String> multiVmGroupName;

    /**
     * @return Name of group in which all machines will replicate together and have shared crash consistent and app-consistent recovery points when failed over.
     * 
     */
    public Optional<Output<String>> multiVmGroupName() {
        return Optional.ofNullable(this.multiVmGroupName);
    }

    /**
     * The name of the replicated VM. Changing this forces a new resource to be created.
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return The name of the replicated VM. Changing this forces a new resource to be created.
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * One or more `networkInterface` block as defined below.
     * 
     */
    @Import(name="networkInterfaces")
    private @Nullable Output<List<VmwareReplicatedVmNetworkInterfaceArgs>> networkInterfaces;

    /**
     * @return One or more `networkInterface` block as defined below.
     * 
     */
    public Optional<Output<List<VmwareReplicatedVmNetworkInterfaceArgs>>> networkInterfaces() {
        return Optional.ofNullable(this.networkInterfaces);
    }

    /**
     * The name of the credential to access the source VM. Changing this forces a new resource to be created. More information about the credentials could be found [here](https://learn.microsoft.com/en-us/azure/site-recovery/deploy-vmware-azure-replication-appliance-modernized).
     * 
     */
    @Import(name="physicalServerCredentialName", required=true)
    private Output<String> physicalServerCredentialName;

    /**
     * @return The name of the credential to access the source VM. Changing this forces a new resource to be created. More information about the credentials could be found [here](https://learn.microsoft.com/en-us/azure/site-recovery/deploy-vmware-azure-replication-appliance-modernized).
     * 
     */
    public Output<String> physicalServerCredentialName() {
        return this.physicalServerCredentialName;
    }

    /**
     * The ID of the policy to use for this replicated VM.
     * 
     */
    @Import(name="recoveryReplicationPolicyId", required=true)
    private Output<String> recoveryReplicationPolicyId;

    /**
     * @return The ID of the policy to use for this replicated VM.
     * 
     */
    public Output<String> recoveryReplicationPolicyId() {
        return this.recoveryReplicationPolicyId;
    }

    /**
     * The ID of the Recovery Services Vault where the replicated VM is created.
     * 
     */
    @Import(name="recoveryVaultId", required=true)
    private Output<String> recoveryVaultId;

    /**
     * @return The ID of the Recovery Services Vault where the replicated VM is created.
     * 
     */
    public Output<String> recoveryVaultId() {
        return this.recoveryVaultId;
    }

    /**
     * The name of the source VM in VMWare. Changing this forces a new resource to be created.
     * 
     */
    @Import(name="sourceVmName", required=true)
    private Output<String> sourceVmName;

    /**
     * @return The name of the source VM in VMWare. Changing this forces a new resource to be created.
     * 
     */
    public Output<String> sourceVmName() {
        return this.sourceVmName;
    }

    /**
     * The ID of availability set that the new VM should belong to when a failover is done.
     * 
     */
    @Import(name="targetAvailabilitySetId")
    private @Nullable Output<String> targetAvailabilitySetId;

    /**
     * @return The ID of availability set that the new VM should belong to when a failover is done.
     * 
     */
    public Optional<Output<String>> targetAvailabilitySetId() {
        return Optional.ofNullable(this.targetAvailabilitySetId);
    }

    /**
     * The ID of the storage account that should be used for boot diagnostics when a failover is done.
     * 
     */
    @Import(name="targetBootDiagnosticsStorageAccountId")
    private @Nullable Output<String> targetBootDiagnosticsStorageAccountId;

    /**
     * @return The ID of the storage account that should be used for boot diagnostics when a failover is done.
     * 
     */
    public Optional<Output<String>> targetBootDiagnosticsStorageAccountId() {
        return Optional.ofNullable(this.targetBootDiagnosticsStorageAccountId);
    }

    /**
     * The ID of network to use when a failover is done.
     * 
     * &gt; **Note:** `targetNetworkId` is required when `networkInterface` is specified.
     * 
     */
    @Import(name="targetNetworkId")
    private @Nullable Output<String> targetNetworkId;

    /**
     * @return The ID of network to use when a failover is done.
     * 
     * &gt; **Note:** `targetNetworkId` is required when `networkInterface` is specified.
     * 
     */
    public Optional<Output<String>> targetNetworkId() {
        return Optional.ofNullable(this.targetNetworkId);
    }

    /**
     * The ID of Proximity Placement Group the new VM should belong to when a failover is done.
     * 
     * &gt; **Note:** Only one of `targetAvailabilitySetId` or `targetZone` can be specified.
     * 
     */
    @Import(name="targetProximityPlacementGroupId")
    private @Nullable Output<String> targetProximityPlacementGroupId;

    /**
     * @return The ID of Proximity Placement Group the new VM should belong to when a failover is done.
     * 
     * &gt; **Note:** Only one of `targetAvailabilitySetId` or `targetZone` can be specified.
     * 
     */
    public Optional<Output<String>> targetProximityPlacementGroupId() {
        return Optional.ofNullable(this.targetProximityPlacementGroupId);
    }

    /**
     * The ID of resource group where the VM should be created when a failover is done.
     * 
     */
    @Import(name="targetResourceGroupId", required=true)
    private Output<String> targetResourceGroupId;

    /**
     * @return The ID of resource group where the VM should be created when a failover is done.
     * 
     */
    public Output<String> targetResourceGroupId() {
        return this.targetResourceGroupId;
    }

    /**
     * Name of the VM that should be created when a failover is done. Changing this forces a new resource to be created.
     * 
     */
    @Import(name="targetVmName", required=true)
    private Output<String> targetVmName;

    /**
     * @return Name of the VM that should be created when a failover is done. Changing this forces a new resource to be created.
     * 
     */
    public Output<String> targetVmName() {
        return this.targetVmName;
    }

    /**
     * Size of the VM that should be created when a failover is done, such as `Standard_F2`. If it&#39;s not specified, it will automatically be set by detecting the source VM size.
     * 
     */
    @Import(name="targetVmSize")
    private @Nullable Output<String> targetVmSize;

    /**
     * @return Size of the VM that should be created when a failover is done, such as `Standard_F2`. If it&#39;s not specified, it will automatically be set by detecting the source VM size.
     * 
     */
    public Optional<Output<String>> targetVmSize() {
        return Optional.ofNullable(this.targetVmSize);
    }

    /**
     * Specifies the Availability Zone where the Failover VM should exist.
     * 
     */
    @Import(name="targetZone")
    private @Nullable Output<String> targetZone;

    /**
     * @return Specifies the Availability Zone where the Failover VM should exist.
     * 
     */
    public Optional<Output<String>> targetZone() {
        return Optional.ofNullable(this.targetZone);
    }

    /**
     * The ID of network to use when a test failover is done.
     * 
     */
    @Import(name="testNetworkId")
    private @Nullable Output<String> testNetworkId;

    /**
     * @return The ID of network to use when a test failover is done.
     * 
     */
    public Optional<Output<String>> testNetworkId() {
        return Optional.ofNullable(this.testNetworkId);
    }

    private VmwareReplicatedVmArgs() {}

    private VmwareReplicatedVmArgs(VmwareReplicatedVmArgs $) {
        this.applianceName = $.applianceName;
        this.defaultLogStorageAccountId = $.defaultLogStorageAccountId;
        this.defaultRecoveryDiskType = $.defaultRecoveryDiskType;
        this.defaultTargetDiskEncryptionSetId = $.defaultTargetDiskEncryptionSetId;
        this.licenseType = $.licenseType;
        this.managedDisks = $.managedDisks;
        this.multiVmGroupName = $.multiVmGroupName;
        this.name = $.name;
        this.networkInterfaces = $.networkInterfaces;
        this.physicalServerCredentialName = $.physicalServerCredentialName;
        this.recoveryReplicationPolicyId = $.recoveryReplicationPolicyId;
        this.recoveryVaultId = $.recoveryVaultId;
        this.sourceVmName = $.sourceVmName;
        this.targetAvailabilitySetId = $.targetAvailabilitySetId;
        this.targetBootDiagnosticsStorageAccountId = $.targetBootDiagnosticsStorageAccountId;
        this.targetNetworkId = $.targetNetworkId;
        this.targetProximityPlacementGroupId = $.targetProximityPlacementGroupId;
        this.targetResourceGroupId = $.targetResourceGroupId;
        this.targetVmName = $.targetVmName;
        this.targetVmSize = $.targetVmSize;
        this.targetZone = $.targetZone;
        this.testNetworkId = $.testNetworkId;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(VmwareReplicatedVmArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private VmwareReplicatedVmArgs $;

        public Builder() {
            $ = new VmwareReplicatedVmArgs();
        }

        public Builder(VmwareReplicatedVmArgs defaults) {
            $ = new VmwareReplicatedVmArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param applianceName The name of VMWare appliance which handles the replication. Changing this forces a new resource to be created.
         * 
         * @return builder
         * 
         */
        public Builder applianceName(Output<String> applianceName) {
            $.applianceName = applianceName;
            return this;
        }

        /**
         * @param applianceName The name of VMWare appliance which handles the replication. Changing this forces a new resource to be created.
         * 
         * @return builder
         * 
         */
        public Builder applianceName(String applianceName) {
            return applianceName(Output.of(applianceName));
        }

        /**
         * @param defaultLogStorageAccountId The ID of the stroage account that should be used for logging during replication.
         * 
         * &gt; **Note:** Only standard types of storage accounts are allowed.
         * 
         * &gt; **Note:** Only one of `defaultLogStorageAccountId` or `managedDisk` must be specified.
         * 
         * &gt; **Note:** Changing `defaultLogStorageAccountId` forces a new resource to be created. But removing it does not.
         * 
         * &gt; **Note:** When `defaultLogStorageAccountId` co-exist with `managedDisk`, the value of `defaultLogStorageAccountId` must be as same as `logStorageAccountId` of every `managedDisk` or it forces a new resource to be created.
         * 
         * @return builder
         * 
         */
        public Builder defaultLogStorageAccountId(@Nullable Output<String> defaultLogStorageAccountId) {
            $.defaultLogStorageAccountId = defaultLogStorageAccountId;
            return this;
        }

        /**
         * @param defaultLogStorageAccountId The ID of the stroage account that should be used for logging during replication.
         * 
         * &gt; **Note:** Only standard types of storage accounts are allowed.
         * 
         * &gt; **Note:** Only one of `defaultLogStorageAccountId` or `managedDisk` must be specified.
         * 
         * &gt; **Note:** Changing `defaultLogStorageAccountId` forces a new resource to be created. But removing it does not.
         * 
         * &gt; **Note:** When `defaultLogStorageAccountId` co-exist with `managedDisk`, the value of `defaultLogStorageAccountId` must be as same as `logStorageAccountId` of every `managedDisk` or it forces a new resource to be created.
         * 
         * @return builder
         * 
         */
        public Builder defaultLogStorageAccountId(String defaultLogStorageAccountId) {
            return defaultLogStorageAccountId(Output.of(defaultLogStorageAccountId));
        }

        /**
         * @param defaultRecoveryDiskType The type of storage account that should be used for recovery disks when a failover is done. Possible values are `Premium_LRS`, `Standard_LRS` and `StandardSSD_LRS`.
         * 
         * &gt; **Note:** Only one of `defaultRecoveryDiskType` or `managedDisk` must be specified.
         * 
         * &gt; **Note:** Changing `defaultRecoveryDiskType` forces a new resource to be created. But removing it does not.
         * 
         * &gt; **Note:** When `defaultRecoveryDiskType` co-exist with `managedDisk`, the value of `defaultRecoveryDiskType` must be as same as `targetDiskType` of every `managedDisk` or it forces a new resource to be created.
         * 
         * @return builder
         * 
         */
        public Builder defaultRecoveryDiskType(@Nullable Output<String> defaultRecoveryDiskType) {
            $.defaultRecoveryDiskType = defaultRecoveryDiskType;
            return this;
        }

        /**
         * @param defaultRecoveryDiskType The type of storage account that should be used for recovery disks when a failover is done. Possible values are `Premium_LRS`, `Standard_LRS` and `StandardSSD_LRS`.
         * 
         * &gt; **Note:** Only one of `defaultRecoveryDiskType` or `managedDisk` must be specified.
         * 
         * &gt; **Note:** Changing `defaultRecoveryDiskType` forces a new resource to be created. But removing it does not.
         * 
         * &gt; **Note:** When `defaultRecoveryDiskType` co-exist with `managedDisk`, the value of `defaultRecoveryDiskType` must be as same as `targetDiskType` of every `managedDisk` or it forces a new resource to be created.
         * 
         * @return builder
         * 
         */
        public Builder defaultRecoveryDiskType(String defaultRecoveryDiskType) {
            return defaultRecoveryDiskType(Output.of(defaultRecoveryDiskType));
        }

        /**
         * @param defaultTargetDiskEncryptionSetId The ID of the default Disk Encryption Set that should be used for the disks when a failover is done.
         * 
         * &gt; **Note:** Changing `defaultTargetDiskEncryptionSetId` forces a new resource to be created. But removing it does not.
         * 
         * &gt; **Note:** When `defaultTargetDiskEncryptionSetId` co-exist with `managedDisk`, the value of `defaultTargetDiskEncryptionSetId` must be as same as `targetDiskEncryptionSetId` of every `managedDisk` or it forces a new resource to be created.
         * 
         * @return builder
         * 
         */
        public Builder defaultTargetDiskEncryptionSetId(@Nullable Output<String> defaultTargetDiskEncryptionSetId) {
            $.defaultTargetDiskEncryptionSetId = defaultTargetDiskEncryptionSetId;
            return this;
        }

        /**
         * @param defaultTargetDiskEncryptionSetId The ID of the default Disk Encryption Set that should be used for the disks when a failover is done.
         * 
         * &gt; **Note:** Changing `defaultTargetDiskEncryptionSetId` forces a new resource to be created. But removing it does not.
         * 
         * &gt; **Note:** When `defaultTargetDiskEncryptionSetId` co-exist with `managedDisk`, the value of `defaultTargetDiskEncryptionSetId` must be as same as `targetDiskEncryptionSetId` of every `managedDisk` or it forces a new resource to be created.
         * 
         * @return builder
         * 
         */
        public Builder defaultTargetDiskEncryptionSetId(String defaultTargetDiskEncryptionSetId) {
            return defaultTargetDiskEncryptionSetId(Output.of(defaultTargetDiskEncryptionSetId));
        }

        /**
         * @param licenseType The license type of the VM. Possible values are `NoLicenseType`, `NotSpecified` and `WindowsServer`. Defaults to `NotSpecified`.
         * 
         * @return builder
         * 
         */
        public Builder licenseType(@Nullable Output<String> licenseType) {
            $.licenseType = licenseType;
            return this;
        }

        /**
         * @param licenseType The license type of the VM. Possible values are `NoLicenseType`, `NotSpecified` and `WindowsServer`. Defaults to `NotSpecified`.
         * 
         * @return builder
         * 
         */
        public Builder licenseType(String licenseType) {
            return licenseType(Output.of(licenseType));
        }

        /**
         * @param managedDisks One or more `managedDisk` block as defined below. It&#39;s available only if mobility service is already installed on the source VM.
         * 
         * &gt; **Note:** A replicated VM could be created without `managedDisk` block, once the block has been specified, changing it expect removing it forces a new resource to be created.
         * 
         * @return builder
         * 
         */
        public Builder managedDisks(@Nullable Output<List<VmwareReplicatedVmManagedDiskArgs>> managedDisks) {
            $.managedDisks = managedDisks;
            return this;
        }

        /**
         * @param managedDisks One or more `managedDisk` block as defined below. It&#39;s available only if mobility service is already installed on the source VM.
         * 
         * &gt; **Note:** A replicated VM could be created without `managedDisk` block, once the block has been specified, changing it expect removing it forces a new resource to be created.
         * 
         * @return builder
         * 
         */
        public Builder managedDisks(List<VmwareReplicatedVmManagedDiskArgs> managedDisks) {
            return managedDisks(Output.of(managedDisks));
        }

        /**
         * @param managedDisks One or more `managedDisk` block as defined below. It&#39;s available only if mobility service is already installed on the source VM.
         * 
         * &gt; **Note:** A replicated VM could be created without `managedDisk` block, once the block has been specified, changing it expect removing it forces a new resource to be created.
         * 
         * @return builder
         * 
         */
        public Builder managedDisks(VmwareReplicatedVmManagedDiskArgs... managedDisks) {
            return managedDisks(List.of(managedDisks));
        }

        /**
         * @param multiVmGroupName Name of group in which all machines will replicate together and have shared crash consistent and app-consistent recovery points when failed over.
         * 
         * @return builder
         * 
         */
        public Builder multiVmGroupName(@Nullable Output<String> multiVmGroupName) {
            $.multiVmGroupName = multiVmGroupName;
            return this;
        }

        /**
         * @param multiVmGroupName Name of group in which all machines will replicate together and have shared crash consistent and app-consistent recovery points when failed over.
         * 
         * @return builder
         * 
         */
        public Builder multiVmGroupName(String multiVmGroupName) {
            return multiVmGroupName(Output.of(multiVmGroupName));
        }

        /**
         * @param name The name of the replicated VM. Changing this forces a new resource to be created.
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name The name of the replicated VM. Changing this forces a new resource to be created.
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param networkInterfaces One or more `networkInterface` block as defined below.
         * 
         * @return builder
         * 
         */
        public Builder networkInterfaces(@Nullable Output<List<VmwareReplicatedVmNetworkInterfaceArgs>> networkInterfaces) {
            $.networkInterfaces = networkInterfaces;
            return this;
        }

        /**
         * @param networkInterfaces One or more `networkInterface` block as defined below.
         * 
         * @return builder
         * 
         */
        public Builder networkInterfaces(List<VmwareReplicatedVmNetworkInterfaceArgs> networkInterfaces) {
            return networkInterfaces(Output.of(networkInterfaces));
        }

        /**
         * @param networkInterfaces One or more `networkInterface` block as defined below.
         * 
         * @return builder
         * 
         */
        public Builder networkInterfaces(VmwareReplicatedVmNetworkInterfaceArgs... networkInterfaces) {
            return networkInterfaces(List.of(networkInterfaces));
        }

        /**
         * @param physicalServerCredentialName The name of the credential to access the source VM. Changing this forces a new resource to be created. More information about the credentials could be found [here](https://learn.microsoft.com/en-us/azure/site-recovery/deploy-vmware-azure-replication-appliance-modernized).
         * 
         * @return builder
         * 
         */
        public Builder physicalServerCredentialName(Output<String> physicalServerCredentialName) {
            $.physicalServerCredentialName = physicalServerCredentialName;
            return this;
        }

        /**
         * @param physicalServerCredentialName The name of the credential to access the source VM. Changing this forces a new resource to be created. More information about the credentials could be found [here](https://learn.microsoft.com/en-us/azure/site-recovery/deploy-vmware-azure-replication-appliance-modernized).
         * 
         * @return builder
         * 
         */
        public Builder physicalServerCredentialName(String physicalServerCredentialName) {
            return physicalServerCredentialName(Output.of(physicalServerCredentialName));
        }

        /**
         * @param recoveryReplicationPolicyId The ID of the policy to use for this replicated VM.
         * 
         * @return builder
         * 
         */
        public Builder recoveryReplicationPolicyId(Output<String> recoveryReplicationPolicyId) {
            $.recoveryReplicationPolicyId = recoveryReplicationPolicyId;
            return this;
        }

        /**
         * @param recoveryReplicationPolicyId The ID of the policy to use for this replicated VM.
         * 
         * @return builder
         * 
         */
        public Builder recoveryReplicationPolicyId(String recoveryReplicationPolicyId) {
            return recoveryReplicationPolicyId(Output.of(recoveryReplicationPolicyId));
        }

        /**
         * @param recoveryVaultId The ID of the Recovery Services Vault where the replicated VM is created.
         * 
         * @return builder
         * 
         */
        public Builder recoveryVaultId(Output<String> recoveryVaultId) {
            $.recoveryVaultId = recoveryVaultId;
            return this;
        }

        /**
         * @param recoveryVaultId The ID of the Recovery Services Vault where the replicated VM is created.
         * 
         * @return builder
         * 
         */
        public Builder recoveryVaultId(String recoveryVaultId) {
            return recoveryVaultId(Output.of(recoveryVaultId));
        }

        /**
         * @param sourceVmName The name of the source VM in VMWare. Changing this forces a new resource to be created.
         * 
         * @return builder
         * 
         */
        public Builder sourceVmName(Output<String> sourceVmName) {
            $.sourceVmName = sourceVmName;
            return this;
        }

        /**
         * @param sourceVmName The name of the source VM in VMWare. Changing this forces a new resource to be created.
         * 
         * @return builder
         * 
         */
        public Builder sourceVmName(String sourceVmName) {
            return sourceVmName(Output.of(sourceVmName));
        }

        /**
         * @param targetAvailabilitySetId The ID of availability set that the new VM should belong to when a failover is done.
         * 
         * @return builder
         * 
         */
        public Builder targetAvailabilitySetId(@Nullable Output<String> targetAvailabilitySetId) {
            $.targetAvailabilitySetId = targetAvailabilitySetId;
            return this;
        }

        /**
         * @param targetAvailabilitySetId The ID of availability set that the new VM should belong to when a failover is done.
         * 
         * @return builder
         * 
         */
        public Builder targetAvailabilitySetId(String targetAvailabilitySetId) {
            return targetAvailabilitySetId(Output.of(targetAvailabilitySetId));
        }

        /**
         * @param targetBootDiagnosticsStorageAccountId The ID of the storage account that should be used for boot diagnostics when a failover is done.
         * 
         * @return builder
         * 
         */
        public Builder targetBootDiagnosticsStorageAccountId(@Nullable Output<String> targetBootDiagnosticsStorageAccountId) {
            $.targetBootDiagnosticsStorageAccountId = targetBootDiagnosticsStorageAccountId;
            return this;
        }

        /**
         * @param targetBootDiagnosticsStorageAccountId The ID of the storage account that should be used for boot diagnostics when a failover is done.
         * 
         * @return builder
         * 
         */
        public Builder targetBootDiagnosticsStorageAccountId(String targetBootDiagnosticsStorageAccountId) {
            return targetBootDiagnosticsStorageAccountId(Output.of(targetBootDiagnosticsStorageAccountId));
        }

        /**
         * @param targetNetworkId The ID of network to use when a failover is done.
         * 
         * &gt; **Note:** `targetNetworkId` is required when `networkInterface` is specified.
         * 
         * @return builder
         * 
         */
        public Builder targetNetworkId(@Nullable Output<String> targetNetworkId) {
            $.targetNetworkId = targetNetworkId;
            return this;
        }

        /**
         * @param targetNetworkId The ID of network to use when a failover is done.
         * 
         * &gt; **Note:** `targetNetworkId` is required when `networkInterface` is specified.
         * 
         * @return builder
         * 
         */
        public Builder targetNetworkId(String targetNetworkId) {
            return targetNetworkId(Output.of(targetNetworkId));
        }

        /**
         * @param targetProximityPlacementGroupId The ID of Proximity Placement Group the new VM should belong to when a failover is done.
         * 
         * &gt; **Note:** Only one of `targetAvailabilitySetId` or `targetZone` can be specified.
         * 
         * @return builder
         * 
         */
        public Builder targetProximityPlacementGroupId(@Nullable Output<String> targetProximityPlacementGroupId) {
            $.targetProximityPlacementGroupId = targetProximityPlacementGroupId;
            return this;
        }

        /**
         * @param targetProximityPlacementGroupId The ID of Proximity Placement Group the new VM should belong to when a failover is done.
         * 
         * &gt; **Note:** Only one of `targetAvailabilitySetId` or `targetZone` can be specified.
         * 
         * @return builder
         * 
         */
        public Builder targetProximityPlacementGroupId(String targetProximityPlacementGroupId) {
            return targetProximityPlacementGroupId(Output.of(targetProximityPlacementGroupId));
        }

        /**
         * @param targetResourceGroupId The ID of resource group where the VM should be created when a failover is done.
         * 
         * @return builder
         * 
         */
        public Builder targetResourceGroupId(Output<String> targetResourceGroupId) {
            $.targetResourceGroupId = targetResourceGroupId;
            return this;
        }

        /**
         * @param targetResourceGroupId The ID of resource group where the VM should be created when a failover is done.
         * 
         * @return builder
         * 
         */
        public Builder targetResourceGroupId(String targetResourceGroupId) {
            return targetResourceGroupId(Output.of(targetResourceGroupId));
        }

        /**
         * @param targetVmName Name of the VM that should be created when a failover is done. Changing this forces a new resource to be created.
         * 
         * @return builder
         * 
         */
        public Builder targetVmName(Output<String> targetVmName) {
            $.targetVmName = targetVmName;
            return this;
        }

        /**
         * @param targetVmName Name of the VM that should be created when a failover is done. Changing this forces a new resource to be created.
         * 
         * @return builder
         * 
         */
        public Builder targetVmName(String targetVmName) {
            return targetVmName(Output.of(targetVmName));
        }

        /**
         * @param targetVmSize Size of the VM that should be created when a failover is done, such as `Standard_F2`. If it&#39;s not specified, it will automatically be set by detecting the source VM size.
         * 
         * @return builder
         * 
         */
        public Builder targetVmSize(@Nullable Output<String> targetVmSize) {
            $.targetVmSize = targetVmSize;
            return this;
        }

        /**
         * @param targetVmSize Size of the VM that should be created when a failover is done, such as `Standard_F2`. If it&#39;s not specified, it will automatically be set by detecting the source VM size.
         * 
         * @return builder
         * 
         */
        public Builder targetVmSize(String targetVmSize) {
            return targetVmSize(Output.of(targetVmSize));
        }

        /**
         * @param targetZone Specifies the Availability Zone where the Failover VM should exist.
         * 
         * @return builder
         * 
         */
        public Builder targetZone(@Nullable Output<String> targetZone) {
            $.targetZone = targetZone;
            return this;
        }

        /**
         * @param targetZone Specifies the Availability Zone where the Failover VM should exist.
         * 
         * @return builder
         * 
         */
        public Builder targetZone(String targetZone) {
            return targetZone(Output.of(targetZone));
        }

        /**
         * @param testNetworkId The ID of network to use when a test failover is done.
         * 
         * @return builder
         * 
         */
        public Builder testNetworkId(@Nullable Output<String> testNetworkId) {
            $.testNetworkId = testNetworkId;
            return this;
        }

        /**
         * @param testNetworkId The ID of network to use when a test failover is done.
         * 
         * @return builder
         * 
         */
        public Builder testNetworkId(String testNetworkId) {
            return testNetworkId(Output.of(testNetworkId));
        }

        public VmwareReplicatedVmArgs build() {
            if ($.applianceName == null) {
                throw new MissingRequiredPropertyException("VmwareReplicatedVmArgs", "applianceName");
            }
            if ($.physicalServerCredentialName == null) {
                throw new MissingRequiredPropertyException("VmwareReplicatedVmArgs", "physicalServerCredentialName");
            }
            if ($.recoveryReplicationPolicyId == null) {
                throw new MissingRequiredPropertyException("VmwareReplicatedVmArgs", "recoveryReplicationPolicyId");
            }
            if ($.recoveryVaultId == null) {
                throw new MissingRequiredPropertyException("VmwareReplicatedVmArgs", "recoveryVaultId");
            }
            if ($.sourceVmName == null) {
                throw new MissingRequiredPropertyException("VmwareReplicatedVmArgs", "sourceVmName");
            }
            if ($.targetResourceGroupId == null) {
                throw new MissingRequiredPropertyException("VmwareReplicatedVmArgs", "targetResourceGroupId");
            }
            if ($.targetVmName == null) {
                throw new MissingRequiredPropertyException("VmwareReplicatedVmArgs", "targetVmName");
            }
            return $;
        }
    }

}
