// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.azure.monitoring.outputs;

import com.pulumi.azure.monitoring.outputs.AutoscaleSettingProfileRuleMetricTriggerDimension;
import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.Double;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class AutoscaleSettingProfileRuleMetricTrigger {
    /**
     * @return One or more `dimensions` block as defined below.
     * 
     */
    private @Nullable List<AutoscaleSettingProfileRuleMetricTriggerDimension> dimensions;
    /**
     * @return Whether to enable metric divide by instance count.
     * 
     */
    private @Nullable Boolean divideByInstanceCount;
    /**
     * @return The name of the metric that defines what the rule monitors, such as `Percentage CPU` for `Virtual Machine Scale Sets` and `CpuPercentage` for `App Service Plan`.
     * 
     * &gt; **NOTE:** The allowed value of `metric_name` highly depends on the targeting resource type, please visit [Supported metrics with Azure Monitor](https://docs.microsoft.com/azure/azure-monitor/platform/metrics-supported) for more details.
     * 
     */
    private String metricName;
    /**
     * @return The namespace of the metric that defines what the rule monitors, such as `microsoft.compute/virtualmachinescalesets` for `Virtual Machine Scale Sets`.
     * 
     */
    private @Nullable String metricNamespace;
    /**
     * @return The ID of the Resource which the Rule monitors.
     * 
     */
    private String metricResourceId;
    /**
     * @return Specifies the operator used to compare the metric data and threshold. Possible values are: `Equals`, `NotEquals`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan`, `LessThanOrEqual`.
     * 
     */
    private String operator;
    /**
     * @return Specifies how the metrics from multiple instances are combined. Possible values are `Average`, `Max`, `Min` and `Sum`.
     * 
     */
    private String statistic;
    /**
     * @return Specifies the threshold of the metric that triggers the scale action.
     * 
     */
    private Double threshold;
    /**
     * @return Specifies how the data that&#39;s collected should be combined over time. Possible values include `Average`, `Count`, `Maximum`, `Minimum`, `Last` and `Total`.
     * 
     */
    private String timeAggregation;
    /**
     * @return Specifies the granularity of metrics that the rule monitors, which must be one of the pre-defined values returned from the metric definitions for the metric. This value must be between 1 minute and 12 hours an be formatted as an ISO 8601 string.
     * 
     */
    private String timeGrain;
    /**
     * @return Specifies the time range for which data is collected, which must be greater than the delay in metric collection (which varies from resource to resource). This value must be between 5 minutes and 12 hours and be formatted as an ISO 8601 string.
     * 
     */
    private String timeWindow;

    private AutoscaleSettingProfileRuleMetricTrigger() {}
    /**
     * @return One or more `dimensions` block as defined below.
     * 
     */
    public List<AutoscaleSettingProfileRuleMetricTriggerDimension> dimensions() {
        return this.dimensions == null ? List.of() : this.dimensions;
    }
    /**
     * @return Whether to enable metric divide by instance count.
     * 
     */
    public Optional<Boolean> divideByInstanceCount() {
        return Optional.ofNullable(this.divideByInstanceCount);
    }
    /**
     * @return The name of the metric that defines what the rule monitors, such as `Percentage CPU` for `Virtual Machine Scale Sets` and `CpuPercentage` for `App Service Plan`.
     * 
     * &gt; **NOTE:** The allowed value of `metric_name` highly depends on the targeting resource type, please visit [Supported metrics with Azure Monitor](https://docs.microsoft.com/azure/azure-monitor/platform/metrics-supported) for more details.
     * 
     */
    public String metricName() {
        return this.metricName;
    }
    /**
     * @return The namespace of the metric that defines what the rule monitors, such as `microsoft.compute/virtualmachinescalesets` for `Virtual Machine Scale Sets`.
     * 
     */
    public Optional<String> metricNamespace() {
        return Optional.ofNullable(this.metricNamespace);
    }
    /**
     * @return The ID of the Resource which the Rule monitors.
     * 
     */
    public String metricResourceId() {
        return this.metricResourceId;
    }
    /**
     * @return Specifies the operator used to compare the metric data and threshold. Possible values are: `Equals`, `NotEquals`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan`, `LessThanOrEqual`.
     * 
     */
    public String operator() {
        return this.operator;
    }
    /**
     * @return Specifies how the metrics from multiple instances are combined. Possible values are `Average`, `Max`, `Min` and `Sum`.
     * 
     */
    public String statistic() {
        return this.statistic;
    }
    /**
     * @return Specifies the threshold of the metric that triggers the scale action.
     * 
     */
    public Double threshold() {
        return this.threshold;
    }
    /**
     * @return Specifies how the data that&#39;s collected should be combined over time. Possible values include `Average`, `Count`, `Maximum`, `Minimum`, `Last` and `Total`.
     * 
     */
    public String timeAggregation() {
        return this.timeAggregation;
    }
    /**
     * @return Specifies the granularity of metrics that the rule monitors, which must be one of the pre-defined values returned from the metric definitions for the metric. This value must be between 1 minute and 12 hours an be formatted as an ISO 8601 string.
     * 
     */
    public String timeGrain() {
        return this.timeGrain;
    }
    /**
     * @return Specifies the time range for which data is collected, which must be greater than the delay in metric collection (which varies from resource to resource). This value must be between 5 minutes and 12 hours and be formatted as an ISO 8601 string.
     * 
     */
    public String timeWindow() {
        return this.timeWindow;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(AutoscaleSettingProfileRuleMetricTrigger defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private @Nullable List<AutoscaleSettingProfileRuleMetricTriggerDimension> dimensions;
        private @Nullable Boolean divideByInstanceCount;
        private String metricName;
        private @Nullable String metricNamespace;
        private String metricResourceId;
        private String operator;
        private String statistic;
        private Double threshold;
        private String timeAggregation;
        private String timeGrain;
        private String timeWindow;
        public Builder() {}
        public Builder(AutoscaleSettingProfileRuleMetricTrigger defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.dimensions = defaults.dimensions;
    	      this.divideByInstanceCount = defaults.divideByInstanceCount;
    	      this.metricName = defaults.metricName;
    	      this.metricNamespace = defaults.metricNamespace;
    	      this.metricResourceId = defaults.metricResourceId;
    	      this.operator = defaults.operator;
    	      this.statistic = defaults.statistic;
    	      this.threshold = defaults.threshold;
    	      this.timeAggregation = defaults.timeAggregation;
    	      this.timeGrain = defaults.timeGrain;
    	      this.timeWindow = defaults.timeWindow;
        }

        @CustomType.Setter
        public Builder dimensions(@Nullable List<AutoscaleSettingProfileRuleMetricTriggerDimension> dimensions) {

            this.dimensions = dimensions;
            return this;
        }
        public Builder dimensions(AutoscaleSettingProfileRuleMetricTriggerDimension... dimensions) {
            return dimensions(List.of(dimensions));
        }
        @CustomType.Setter
        public Builder divideByInstanceCount(@Nullable Boolean divideByInstanceCount) {

            this.divideByInstanceCount = divideByInstanceCount;
            return this;
        }
        @CustomType.Setter
        public Builder metricName(String metricName) {
            if (metricName == null) {
              throw new MissingRequiredPropertyException("AutoscaleSettingProfileRuleMetricTrigger", "metricName");
            }
            this.metricName = metricName;
            return this;
        }
        @CustomType.Setter
        public Builder metricNamespace(@Nullable String metricNamespace) {

            this.metricNamespace = metricNamespace;
            return this;
        }
        @CustomType.Setter
        public Builder metricResourceId(String metricResourceId) {
            if (metricResourceId == null) {
              throw new MissingRequiredPropertyException("AutoscaleSettingProfileRuleMetricTrigger", "metricResourceId");
            }
            this.metricResourceId = metricResourceId;
            return this;
        }
        @CustomType.Setter
        public Builder operator(String operator) {
            if (operator == null) {
              throw new MissingRequiredPropertyException("AutoscaleSettingProfileRuleMetricTrigger", "operator");
            }
            this.operator = operator;
            return this;
        }
        @CustomType.Setter
        public Builder statistic(String statistic) {
            if (statistic == null) {
              throw new MissingRequiredPropertyException("AutoscaleSettingProfileRuleMetricTrigger", "statistic");
            }
            this.statistic = statistic;
            return this;
        }
        @CustomType.Setter
        public Builder threshold(Double threshold) {
            if (threshold == null) {
              throw new MissingRequiredPropertyException("AutoscaleSettingProfileRuleMetricTrigger", "threshold");
            }
            this.threshold = threshold;
            return this;
        }
        @CustomType.Setter
        public Builder timeAggregation(String timeAggregation) {
            if (timeAggregation == null) {
              throw new MissingRequiredPropertyException("AutoscaleSettingProfileRuleMetricTrigger", "timeAggregation");
            }
            this.timeAggregation = timeAggregation;
            return this;
        }
        @CustomType.Setter
        public Builder timeGrain(String timeGrain) {
            if (timeGrain == null) {
              throw new MissingRequiredPropertyException("AutoscaleSettingProfileRuleMetricTrigger", "timeGrain");
            }
            this.timeGrain = timeGrain;
            return this;
        }
        @CustomType.Setter
        public Builder timeWindow(String timeWindow) {
            if (timeWindow == null) {
              throw new MissingRequiredPropertyException("AutoscaleSettingProfileRuleMetricTrigger", "timeWindow");
            }
            this.timeWindow = timeWindow;
            return this;
        }
        public AutoscaleSettingProfileRuleMetricTrigger build() {
            final var _resultValue = new AutoscaleSettingProfileRuleMetricTrigger();
            _resultValue.dimensions = dimensions;
            _resultValue.divideByInstanceCount = divideByInstanceCount;
            _resultValue.metricName = metricName;
            _resultValue.metricNamespace = metricNamespace;
            _resultValue.metricResourceId = metricResourceId;
            _resultValue.operator = operator;
            _resultValue.statistic = statistic;
            _resultValue.threshold = threshold;
            _resultValue.timeAggregation = timeAggregation;
            _resultValue.timeGrain = timeGrain;
            _resultValue.timeWindow = timeWindow;
            return _resultValue;
        }
    }
}
