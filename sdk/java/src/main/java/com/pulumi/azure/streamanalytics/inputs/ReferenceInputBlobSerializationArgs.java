// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.azure.streamanalytics.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class ReferenceInputBlobSerializationArgs extends com.pulumi.resources.ResourceArgs {

    public static final ReferenceInputBlobSerializationArgs Empty = new ReferenceInputBlobSerializationArgs();

    /**
     * The encoding of the incoming data in the case of input and the encoding of outgoing data in the case of output. It currently can only be set to `UTF8`.
     * 
     * &gt; **NOTE:** This is required when `type` is set to `Csv` or `Json`.
     * 
     */
    @Import(name="encoding")
    private @Nullable Output<String> encoding;

    /**
     * @return The encoding of the incoming data in the case of input and the encoding of outgoing data in the case of output. It currently can only be set to `UTF8`.
     * 
     * &gt; **NOTE:** This is required when `type` is set to `Csv` or `Json`.
     * 
     */
    public Optional<Output<String>> encoding() {
        return Optional.ofNullable(this.encoding);
    }

    /**
     * The delimiter that will be used to separate comma-separated value (CSV) records. Possible values are ` ` (space), `,` (comma), `	` (tab), `|` (pipe) and `;`.
     * 
     * &gt; **NOTE:** This is required when `type` is set to `Csv`.
     * 
     */
    @Import(name="fieldDelimiter")
    private @Nullable Output<String> fieldDelimiter;

    /**
     * @return The delimiter that will be used to separate comma-separated value (CSV) records. Possible values are ` ` (space), `,` (comma), `	` (tab), `|` (pipe) and `;`.
     * 
     * &gt; **NOTE:** This is required when `type` is set to `Csv`.
     * 
     */
    public Optional<Output<String>> fieldDelimiter() {
        return Optional.ofNullable(this.fieldDelimiter);
    }

    /**
     * The serialization format used for the reference data. Possible values are `Avro`, `Csv` and `Json`.
     * 
     */
    @Import(name="type", required=true)
    private Output<String> type;

    /**
     * @return The serialization format used for the reference data. Possible values are `Avro`, `Csv` and `Json`.
     * 
     */
    public Output<String> type() {
        return this.type;
    }

    private ReferenceInputBlobSerializationArgs() {}

    private ReferenceInputBlobSerializationArgs(ReferenceInputBlobSerializationArgs $) {
        this.encoding = $.encoding;
        this.fieldDelimiter = $.fieldDelimiter;
        this.type = $.type;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(ReferenceInputBlobSerializationArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private ReferenceInputBlobSerializationArgs $;

        public Builder() {
            $ = new ReferenceInputBlobSerializationArgs();
        }

        public Builder(ReferenceInputBlobSerializationArgs defaults) {
            $ = new ReferenceInputBlobSerializationArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param encoding The encoding of the incoming data in the case of input and the encoding of outgoing data in the case of output. It currently can only be set to `UTF8`.
         * 
         * &gt; **NOTE:** This is required when `type` is set to `Csv` or `Json`.
         * 
         * @return builder
         * 
         */
        public Builder encoding(@Nullable Output<String> encoding) {
            $.encoding = encoding;
            return this;
        }

        /**
         * @param encoding The encoding of the incoming data in the case of input and the encoding of outgoing data in the case of output. It currently can only be set to `UTF8`.
         * 
         * &gt; **NOTE:** This is required when `type` is set to `Csv` or `Json`.
         * 
         * @return builder
         * 
         */
        public Builder encoding(String encoding) {
            return encoding(Output.of(encoding));
        }

        /**
         * @param fieldDelimiter The delimiter that will be used to separate comma-separated value (CSV) records. Possible values are ` ` (space), `,` (comma), `	` (tab), `|` (pipe) and `;`.
         * 
         * &gt; **NOTE:** This is required when `type` is set to `Csv`.
         * 
         * @return builder
         * 
         */
        public Builder fieldDelimiter(@Nullable Output<String> fieldDelimiter) {
            $.fieldDelimiter = fieldDelimiter;
            return this;
        }

        /**
         * @param fieldDelimiter The delimiter that will be used to separate comma-separated value (CSV) records. Possible values are ` ` (space), `,` (comma), `	` (tab), `|` (pipe) and `;`.
         * 
         * &gt; **NOTE:** This is required when `type` is set to `Csv`.
         * 
         * @return builder
         * 
         */
        public Builder fieldDelimiter(String fieldDelimiter) {
            return fieldDelimiter(Output.of(fieldDelimiter));
        }

        /**
         * @param type The serialization format used for the reference data. Possible values are `Avro`, `Csv` and `Json`.
         * 
         * @return builder
         * 
         */
        public Builder type(Output<String> type) {
            $.type = type;
            return this;
        }

        /**
         * @param type The serialization format used for the reference data. Possible values are `Avro`, `Csv` and `Json`.
         * 
         * @return builder
         * 
         */
        public Builder type(String type) {
            return type(Output.of(type));
        }

        public ReferenceInputBlobSerializationArgs build() {
            if ($.type == null) {
                throw new MissingRequiredPropertyException("ReferenceInputBlobSerializationArgs", "type");
            }
            return $;
        }
    }

}
