// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import { input as inputs, output as outputs } from "../types";

export namespace advisor {
    export interface GetRecommendationsRecommendation {
        /**
         * The category of the recommendation.
         */
        category: string;
        /**
         * The description of the issue or the opportunity identified by the recommendation.
         */
        description: string;
        /**
         * The business impact of the recommendation.
         */
        impact: string;
        /**
         * The name of the Advisor Recommendation.
         */
        recommendationName: string;
        /**
         * The recommendation type id of the Advisor Recommendation.
         */
        recommendationTypeId: string;
        /**
         * The name of the identified resource of the Advisor Recommendation.
         */
        resourceName: string;
        /**
         * The type of the identified resource of the Advisor Recommendation.
         */
        resourceType: string;
        /**
         * A list of Advisor Suppression names of the Advisor Recommendation.
         */
        suppressionNames: string[];
        /**
         * The most recent time that Advisor checked the validity of the recommendation..
         */
        updatedTime: string;
    }

}

export namespace analysisservices {
    export interface ServerIpv4FirewallRule {
        /**
         * Specifies the name of the firewall rule.
         */
        name: string;
        /**
         * End of the firewall rule range as IPv4 address.
         */
        rangeEnd: string;
        /**
         * Start of the firewall rule range as IPv4 address.
         */
        rangeStart: string;
    }

}

export namespace apimanagement {
    export interface ApiDiagnosticBackendRequest {
        /**
         * Number of payload bytes to log (up to 8192).
         */
        bodyBytes?: number;
        /**
         * Specifies a list of headers to log.
         */
        headersToLogs?: string[];
    }

    export interface ApiDiagnosticBackendResponse {
        /**
         * Number of payload bytes to log (up to 8192).
         */
        bodyBytes?: number;
        /**
         * Specifies a list of headers to log.
         */
        headersToLogs?: string[];
    }

    export interface ApiDiagnosticFrontendRequest {
        /**
         * Number of payload bytes to log (up to 8192).
         */
        bodyBytes?: number;
        /**
         * Specifies a list of headers to log.
         */
        headersToLogs?: string[];
    }

    export interface ApiDiagnosticFrontendResponse {
        /**
         * Number of payload bytes to log (up to 8192).
         */
        bodyBytes?: number;
        /**
         * Specifies a list of headers to log.
         */
        headersToLogs?: string[];
    }

    export interface ApiImport {
        /**
         * The format of the content from which the API Definition should be imported. Possible values are: `openapi`, `openapi+json`, `openapi+json-link`, `openapi-link`, `swagger-json`, `swagger-link-json`, `wadl-link-json`, `wadl-xml`, `wsdl` and `wsdl-link`.
         */
        contentFormat: string;
        /**
         * The Content from which the API Definition should be imported. When a `contentFormat` of `*-link-*` is specified this must be a URL, otherwise this must be defined inline.
         */
        contentValue: string;
        /**
         * A `wsdlSelector` block as defined below, which allows you to limit the import of a WSDL to only a subset of the document. This can only be specified when `contentFormat` is `wsdl` or `wsdl-link`.
         */
        wsdlSelector?: outputs.apimanagement.ApiImportWsdlSelector;
    }

    export interface ApiImportWsdlSelector {
        /**
         * The name of endpoint (port) to import from WSDL.
         */
        endpointName: string;
        /**
         * The name of service to import from WSDL.
         */
        serviceName: string;
    }

    export interface ApiOauth2Authorization {
        /**
         * OAuth authorization server identifier. The name of an OAuth2 Authorization Server.
         */
        authorizationServerName: string;
        /**
         * Operations scope.
         */
        scope?: string;
    }

    export interface ApiOpenidAuthentication {
        /**
         * How to send token to the server. A list of zero or more methods. Valid values are `authorizationHeader` and `query`.
         */
        bearerTokenSendingMethods?: string[];
        /**
         * OpenID Connect provider identifier. The name of an OpenID Connect Provider.
         */
        openidProviderName: string;
    }

    export interface ApiOperationRequest {
        /**
         * A description of the HTTP Request, which may include HTML tags.
         */
        description?: string;
        /**
         * One or more `header` blocks as defined above.
         */
        headers?: outputs.apimanagement.ApiOperationRequestHeader[];
        /**
         * One or more `queryParameter` blocks as defined above.
         */
        queryParameters?: outputs.apimanagement.ApiOperationRequestQueryParameter[];
        /**
         * One or more `representation` blocks as defined below.
         */
        representations?: outputs.apimanagement.ApiOperationRequestRepresentation[];
    }

    export interface ApiOperationRequestHeader {
        /**
         * The default value for this Header.
         */
        defaultValue?: string;
        /**
         * A description of this Header.
         */
        description?: string;
        /**
         * The Name of this Header.
         */
        name: string;
        /**
         * Is this Header Required?
         */
        required: boolean;
        /**
         * The Type of this Header, such as a `string`.
         */
        type: string;
        /**
         * One or more acceptable values for this Header.
         */
        values?: string[];
    }

    export interface ApiOperationRequestQueryParameter {
        /**
         * The default value for this Query Parameter.
         */
        defaultValue?: string;
        /**
         * A description of this Query Parameter.
         */
        description?: string;
        /**
         * The Name of this Query Parameter.
         */
        name: string;
        /**
         * Is this Query Parameter Required?
         */
        required: boolean;
        /**
         * The Type of this Query Parameter, such as a `string`.
         */
        type: string;
        /**
         * One or more acceptable values for this Query Parameter.
         */
        values?: string[];
    }

    export interface ApiOperationRequestRepresentation {
        /**
         * The Content Type of this representation, such as `application/json`.
         */
        contentType: string;
        /**
         * One or more `formParameter` block as defined above.
         */
        formParameters?: outputs.apimanagement.ApiOperationRequestRepresentationFormParameter[];
        /**
         * An example of this representation.
         */
        sample?: string;
        /**
         * The ID of an API Management Schema which represents this Response.
         */
        schemaId?: string;
        /**
         * The Type Name defined by the Schema.
         */
        typeName?: string;
    }

    export interface ApiOperationRequestRepresentationFormParameter {
        /**
         * The default value for this Form Parameter.
         */
        defaultValue?: string;
        /**
         * A description of this Form Parameter.
         */
        description?: string;
        /**
         * The Name of this Form Parameter.
         */
        name: string;
        /**
         * Is this Form Parameter Required?
         */
        required: boolean;
        /**
         * The Type of this Form Parameter, such as a `string`.
         */
        type: string;
        /**
         * One or more acceptable values for this Form Parameter.
         */
        values?: string[];
    }

    export interface ApiOperationResponse {
        /**
         * A description of the HTTP Response, which may include HTML tags.
         */
        description?: string;
        /**
         * One or more `header` blocks as defined above.
         */
        headers?: outputs.apimanagement.ApiOperationResponseHeader[];
        /**
         * One or more `representation` blocks as defined below.
         */
        representations?: outputs.apimanagement.ApiOperationResponseRepresentation[];
        /**
         * The HTTP Status Code.
         */
        statusCode: number;
    }

    export interface ApiOperationResponseHeader {
        /**
         * The default value for this Header.
         */
        defaultValue?: string;
        /**
         * A description of this Header.
         */
        description?: string;
        /**
         * The Name of this Header.
         */
        name: string;
        /**
         * Is this Header Required?
         */
        required: boolean;
        /**
         * The Type of this Header, such as a `string`.
         */
        type: string;
        /**
         * One or more acceptable values for this Header.
         */
        values?: string[];
    }

    export interface ApiOperationResponseRepresentation {
        /**
         * The Content Type of this representation, such as `application/json`.
         */
        contentType: string;
        /**
         * One or more `formParameter` block as defined above.
         */
        formParameters?: outputs.apimanagement.ApiOperationResponseRepresentationFormParameter[];
        /**
         * An example of this representation.
         */
        sample?: string;
        /**
         * The ID of an API Management Schema which represents this Response.
         */
        schemaId?: string;
        /**
         * The Type Name defined by the Schema.
         */
        typeName?: string;
    }

    export interface ApiOperationResponseRepresentationFormParameter {
        /**
         * The default value for this Form Parameter.
         */
        defaultValue?: string;
        /**
         * A description of this Form Parameter.
         */
        description?: string;
        /**
         * The Name of this Form Parameter.
         */
        name: string;
        /**
         * Is this Form Parameter Required?
         */
        required: boolean;
        /**
         * The Type of this Form Parameter, such as a `string`.
         */
        type: string;
        /**
         * One or more acceptable values for this Form Parameter.
         */
        values?: string[];
    }

    export interface ApiOperationTemplateParameter {
        /**
         * The default value for this Template Parameter.
         */
        defaultValue?: string;
        /**
         * A description of this Template Parameter.
         */
        description?: string;
        /**
         * The Name of this Template Parameter.
         */
        name: string;
        /**
         * Is this Template Parameter Required?
         */
        required: boolean;
        /**
         * The Type of this Template Parameter, such as a `string`.
         */
        type: string;
        /**
         * One or more acceptable values for this Template Parameter.
         */
        values?: string[];
    }

    export interface ApiSubscriptionKeyParameterNames {
        /**
         * The name of the HTTP Header which should be used for the Subscription Key.
         */
        header: string;
        /**
         * The name of the QueryString parameter which should be used for the Subscription Key.
         */
        query: string;
    }

    export interface AuthorizationServerTokenBodyParameter {
        /**
         * The Name of the Parameter.
         */
        name: string;
        /**
         * The Value of the Parameter.
         */
        value: string;
    }

    export interface BackendCredentials {
        /**
         * An `authorization` block as defined below.
         */
        authorization?: outputs.apimanagement.BackendCredentialsAuthorization;
        /**
         * A list of client certificate thumbprints to present to the backend host. The certificates must exist within the API Management Service.
         */
        certificates?: string[];
        /**
         * A mapping of header parameters to pass to the backend host. The keys are the header names and the values are a comma separated string of header values. This is converted to a list before being passed to the API.
         */
        header?: {[key: string]: string};
        /**
         * A mapping of query parameters to pass to the backend host. The keys are the query names and the values are a comma separated string of query values. This is converted to a list before being passed to the API.
         */
        query?: {[key: string]: string};
    }

    export interface BackendCredentialsAuthorization {
        /**
         * The authentication Parameter value.
         */
        parameter?: string;
        /**
         * The authentication Scheme name.
         */
        scheme?: string;
    }

    export interface BackendProxy {
        /**
         * The password to connect to the proxy server.
         */
        password?: string;
        /**
         * The URL of the proxy server.
         */
        url: string;
        /**
         * The username to connect to the proxy server.
         */
        username: string;
    }

    export interface BackendServiceFabricCluster {
        /**
         * The client certificate resource id for the management endpoint.
         */
        clientCertificateId: string;
        /**
         * The client certificate thumbprint for the management endpoint.
         */
        clientCertificateThumbprint: string;
        /**
         * A list of cluster management endpoints.
         */
        managementEndpoints: string[];
        /**
         * The maximum number of retries when attempting resolve the partition.
         */
        maxPartitionResolutionRetries: number;
        /**
         * A list of thumbprints of the server certificates of the Service Fabric cluster.
         */
        serverCertificateThumbprints?: string[];
        /**
         * One or more `serverX509Name` blocks as documented below.
         */
        serverX509Names?: outputs.apimanagement.BackendServiceFabricClusterServerX509Name[];
    }

    export interface BackendServiceFabricClusterServerX509Name {
        /**
         * The thumbprint for the issuer of the certificate.
         */
        issuerCertificateThumbprint: string;
        /**
         * The name of the API Management backend. Changing this forces a new resource to be created.
         */
        name: string;
    }

    export interface BackendTls {
        /**
         * Flag indicating whether SSL certificate chain validation should be done when using self-signed certificates for the backend host.
         */
        validateCertificateChain?: boolean;
        /**
         * Flag indicating whether SSL certificate name validation should be done when using self-signed certificates for the backend host.
         */
        validateCertificateName?: boolean;
    }

    export interface CustomDomainDeveloperPortal {
        /**
         * The Base64 Encoded Certificate. (Mutually exlusive with `keyVaultId`.)
         */
        certificate?: string;
        /**
         * The password associated with the certificate provided above.
         */
        certificatePassword?: string;
        /**
         * The Hostname to use for the corresponding endpoint.
         */
        hostName: string;
        /**
         * The ID of the Key Vault Secret containing the SSL Certificate, which must be should be of the type application/x-pkcs12.
         */
        keyVaultId?: string;
        /**
         * Should Client Certificate Negotiation be enabled for this Hostname? Defaults to false.
         */
        negotiateClientCertificate?: boolean;
    }

    export interface CustomDomainManagement {
        /**
         * The Base64 Encoded Certificate. (Mutually exlusive with `keyVaultId`.)
         */
        certificate?: string;
        /**
         * The password associated with the certificate provided above.
         */
        certificatePassword?: string;
        /**
         * The Hostname to use for the corresponding endpoint.
         */
        hostName: string;
        /**
         * The ID of the Key Vault Secret containing the SSL Certificate, which must be should be of the type application/x-pkcs12.
         */
        keyVaultId?: string;
        /**
         * Should Client Certificate Negotiation be enabled for this Hostname? Defaults to false.
         */
        negotiateClientCertificate?: boolean;
    }

    export interface CustomDomainPortal {
        /**
         * The Base64 Encoded Certificate. (Mutually exlusive with `keyVaultId`.)
         */
        certificate?: string;
        /**
         * The password associated with the certificate provided above.
         */
        certificatePassword?: string;
        /**
         * The Hostname to use for the corresponding endpoint.
         */
        hostName: string;
        /**
         * The ID of the Key Vault Secret containing the SSL Certificate, which must be should be of the type application/x-pkcs12.
         */
        keyVaultId?: string;
        /**
         * Should Client Certificate Negotiation be enabled for this Hostname? Defaults to false.
         */
        negotiateClientCertificate?: boolean;
    }

    export interface CustomDomainProxy {
        /**
         * The Base64 Encoded Certificate. (Mutually exlusive with `keyVaultId`.)
         */
        certificate?: string;
        /**
         * The password associated with the certificate provided above.
         */
        certificatePassword?: string;
        /**
         * Is the certificate associated with this Hostname the Default SSL Certificate? This is used when an SNI header isn't specified by a client. Defaults to false.
         */
        defaultSslBinding: boolean;
        /**
         * The Hostname to use for the API Proxy Endpoint.
         */
        hostName: string;
        /**
         * The ID of the Key Vault Secret containing the SSL Certificate, which must be should be of the type application/x-pkcs12.
         */
        keyVaultId?: string;
        /**
         * Should Client Certificate Negotiation be enabled for this Hostname? Defaults to false.
         */
        negotiateClientCertificate?: boolean;
    }

    export interface CustomDomainScm {
        /**
         * The Base64 Encoded Certificate. (Mutually exlusive with `keyVaultId`.)
         */
        certificate?: string;
        /**
         * The password associated with the certificate provided above.
         */
        certificatePassword?: string;
        /**
         * The Hostname to use for the corresponding endpoint.
         */
        hostName: string;
        /**
         * The ID of the Key Vault Secret containing the SSL Certificate, which must be should be of the type application/x-pkcs12.
         */
        keyVaultId?: string;
        /**
         * Should Client Certificate Negotiation be enabled for this Hostname? Defaults to false.
         */
        negotiateClientCertificate?: boolean;
    }

    export interface DiagnosticBackendRequest {
        /**
         * Number of payload bytes to log (up to 8192).
         */
        bodyBytes?: number;
        /**
         * Specifies a list of headers to log.
         */
        headersToLogs?: string[];
    }

    export interface DiagnosticBackendResponse {
        /**
         * Number of payload bytes to log (up to 8192).
         */
        bodyBytes?: number;
        /**
         * Specifies a list of headers to log.
         */
        headersToLogs?: string[];
    }

    export interface DiagnosticFrontendRequest {
        /**
         * Number of payload bytes to log (up to 8192).
         */
        bodyBytes?: number;
        /**
         * Specifies a list of headers to log.
         */
        headersToLogs?: string[];
    }

    export interface DiagnosticFrontendResponse {
        /**
         * Number of payload bytes to log (up to 8192).
         */
        bodyBytes?: number;
        /**
         * Specifies a list of headers to log.
         */
        headersToLogs?: string[];
    }

    export interface GatewayLocationData {
        /**
         * The city or locality where the resource is located.
         */
        city?: string;
        /**
         * The district, state, or province where the resource is located.
         */
        district?: string;
        /**
         * A canonical name for the geographic or physical location.
         */
        name: string;
        /**
         * The country or region where the resource is located.
         */
        region?: string;
    }

    export interface GetApiSubscriptionKeyParameterName {
        /**
         * The name of the HTTP Header which should be used for the Subscription Key.
         */
        header: string;
        /**
         * The name of the QueryString parameter which should be used for the Subscription Key.
         */
        query: string;
    }

    export interface GetGatewayLocationData {
        /**
         * The city or locality where the resource is located.
         */
        city: string;
        /**
         * The district, state, or province where the resource is located.
         */
        district: string;
        /**
         * The name of the API Management Gateway.
         */
        name: string;
        region: string;
    }

    export interface GetServiceAdditionalLocation {
        /**
         * Gateway URL of the API Management service in the Region.
         */
        gatewayRegionalUrl: string;
        /**
         * The location name of the additional region among Azure Data center regions.
         */
        location: string;
        /**
         * Private IP addresses of the API Management service in the additional location, for instances using virtual network mode.
         */
        privateIpAddresses: string[];
        /**
         * Public Static Load Balanced IP addresses of the API Management service in the additional location. Available only for Basic, Standard and Premium SKU.
         */
        publicIpAddresses: string[];
    }

    export interface GetServiceHostnameConfiguration {
        /**
         * One or more `developerPortal` blocks as documented below.
         */
        developerPortals: outputs.apimanagement.GetServiceHostnameConfigurationDeveloperPortal[];
        /**
         * One or more `management` blocks as documented below.
         */
        managements: outputs.apimanagement.GetServiceHostnameConfigurationManagement[];
        /**
         * One or more `portal` blocks as documented below.
         */
        portals: outputs.apimanagement.GetServiceHostnameConfigurationPortal[];
        /**
         * One or more `proxy` blocks as documented below.
         */
        proxies: outputs.apimanagement.GetServiceHostnameConfigurationProxy[];
        /**
         * One or more `scm` blocks as documented below.
         */
        scms: outputs.apimanagement.GetServiceHostnameConfigurationScm[];
    }

    export interface GetServiceHostnameConfigurationDeveloperPortal {
        /**
         * The Hostname used for the SCM URL.
         */
        hostName: string;
        /**
         * The ID of the Key Vault Secret which contains the SSL Certificate.
         */
        keyVaultId: string;
        /**
         * Is Client Certificate Negotiation enabled?
         */
        negotiateClientCertificate: boolean;
    }

    export interface GetServiceHostnameConfigurationManagement {
        /**
         * The Hostname used for the SCM URL.
         */
        hostName: string;
        /**
         * The ID of the Key Vault Secret which contains the SSL Certificate.
         */
        keyVaultId: string;
        /**
         * Is Client Certificate Negotiation enabled?
         */
        negotiateClientCertificate: boolean;
    }

    export interface GetServiceHostnameConfigurationPortal {
        /**
         * The Hostname used for the SCM URL.
         */
        hostName: string;
        /**
         * The ID of the Key Vault Secret which contains the SSL Certificate.
         */
        keyVaultId: string;
        /**
         * Is Client Certificate Negotiation enabled?
         */
        negotiateClientCertificate: boolean;
    }

    export interface GetServiceHostnameConfigurationProxy {
        /**
         * Is this the default SSL Binding?
         */
        defaultSslBinding: boolean;
        /**
         * The Hostname used for the SCM URL.
         */
        hostName: string;
        /**
         * The ID of the Key Vault Secret which contains the SSL Certificate.
         */
        keyVaultId: string;
        /**
         * Is Client Certificate Negotiation enabled?
         */
        negotiateClientCertificate: boolean;
    }

    export interface GetServiceHostnameConfigurationScm {
        /**
         * The Hostname used for the SCM URL.
         */
        hostName: string;
        /**
         * The ID of the Key Vault Secret which contains the SSL Certificate.
         */
        keyVaultId: string;
        /**
         * Is Client Certificate Negotiation enabled?
         */
        negotiateClientCertificate: boolean;
    }

    export interface GetServiceIdentity {
        /**
         * A list of IDs for User Assigned Managed Identity resources to be assigned.
         */
        identityIds: string[];
        /**
         * Specifies the Principal ID of the System Assigned Managed Service Identity that is configured on this API Management Service.
         */
        principalId: string;
        /**
         * Specifies the Tenant ID of the System Assigned Managed Service Identity that is configured on this API Management Service.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that is configured on this API Management Service.
         */
        type: string;
    }

    export interface LoggerApplicationInsights {
        /**
         * The instrumentation key used to push data to Application Insights.
         */
        instrumentationKey: string;
    }

    export interface LoggerEventhub {
        /**
         * The connection string of an EventHub Namespace.
         */
        connectionString: string;
        /**
         * The name of an EventHub.
         */
        name: string;
    }

    export interface ServiceAdditionalLocation {
        /**
         * The URL of the Regional Gateway for the API Management Service in the specified region.
         */
        gatewayRegionalUrl: string;
        /**
         * The name of the Azure Region in which the API Management Service should be expanded to.
         */
        location: string;
        /**
         * The Private IP addresses of the API Management Service.  Available only when the API Manager instance is using Virtual Network mode.
         */
        privateIpAddresses: string[];
        /**
         * Public Static Load Balanced IP addresses of the API Management service in the additional location. Available only for Basic, Standard and Premium SKU.
         */
        publicIpAddresses: string[];
        /**
         * A `virtualNetworkConfiguration` block as defined below.  Required when `virtualNetworkType` is `External` or `Internal`.
         */
        virtualNetworkConfiguration?: outputs.apimanagement.ServiceAdditionalLocationVirtualNetworkConfiguration;
    }

    export interface ServiceAdditionalLocationVirtualNetworkConfiguration {
        /**
         * The id of the subnet that will be used for the API Management.
         */
        subnetId: string;
    }

    export interface ServiceCertificate {
        /**
         * The password for the certificate.
         */
        certificatePassword?: string;
        /**
         * The Base64 Encoded PFX or Base64 Encoded X.509 Certificate.
         */
        encodedCertificate: string;
        /**
         * The name of the Certificate Store where this certificate should be stored. Possible values are `CertificateAuthority` and `Root`.
         */
        storeName: string;
    }

    export interface ServiceHostnameConfiguration {
        /**
         * One or more `developerPortal` blocks as documented below.
         */
        developerPortals?: outputs.apimanagement.ServiceHostnameConfigurationDeveloperPortal[];
        /**
         * One or more `management` blocks as documented below.
         */
        managements?: outputs.apimanagement.ServiceHostnameConfigurationManagement[];
        /**
         * One or more `portal` blocks as documented below.
         */
        portals?: outputs.apimanagement.ServiceHostnameConfigurationPortal[];
        /**
         * One or more `proxy` blocks as documented below.
         */
        proxies?: outputs.apimanagement.ServiceHostnameConfigurationProxy[];
        /**
         * One or more `scm` blocks as documented below.
         */
        scms?: outputs.apimanagement.ServiceHostnameConfigurationScm[];
    }

    export interface ServiceHostnameConfigurationDeveloperPortal {
        /**
         * One or more (up to 10) `certificate` blocks as defined below.
         */
        certificate?: string;
        /**
         * The password for the certificate.
         */
        certificatePassword?: string;
        /**
         * The Hostname to use for the Management API.
         */
        hostName: string;
        /**
         * The ID of the Key Vault Secret containing the SSL Certificate, which must be should be of the type `application/x-pkcs12`.
         */
        keyVaultId?: string;
        /**
         * Should Client Certificate Negotiation be enabled for this Hostname? Defaults to `false`.
         */
        negotiateClientCertificate?: boolean;
    }

    export interface ServiceHostnameConfigurationManagement {
        /**
         * The Base64 Encoded Certificate.
         */
        certificate?: string;
        /**
         * The password associated with the certificate provided above.
         */
        certificatePassword?: string;
        /**
         * The Hostname to use for the Management API.
         */
        hostName: string;
        /**
         * The ID of the Key Vault Secret containing the SSL Certificate, which must be should be of the type `application/x-pkcs12`.
         */
        keyVaultId?: string;
        /**
         * Should Client Certificate Negotiation be enabled for this Hostname? Defaults to `false`.
         */
        negotiateClientCertificate?: boolean;
    }

    export interface ServiceHostnameConfigurationPortal {
        /**
         * One or more (up to 10) `certificate` blocks as defined below.
         */
        certificate?: string;
        /**
         * The password for the certificate.
         */
        certificatePassword?: string;
        /**
         * The Hostname to use for the Management API.
         */
        hostName: string;
        /**
         * The ID of the Key Vault Secret containing the SSL Certificate, which must be should be of the type `application/x-pkcs12`.
         */
        keyVaultId?: string;
        /**
         * Should Client Certificate Negotiation be enabled for this Hostname? Defaults to `false`.
         */
        negotiateClientCertificate?: boolean;
    }

    export interface ServiceHostnameConfigurationProxy {
        /**
         * The Base64 Encoded Certificate.
         */
        certificate?: string;
        /**
         * The password associated with the certificate provided above.
         */
        certificatePassword?: string;
        /**
         * Is the certificate associated with this Hostname the Default SSL Certificate? This is used when an SNI header isn't specified by a client. Defaults to `false`.
         */
        defaultSslBinding: boolean;
        /**
         * The Hostname to use for the Management API.
         */
        hostName: string;
        /**
         * The ID of the Key Vault Secret containing the SSL Certificate, which must be should be of the type `application/x-pkcs12`.
         */
        keyVaultId?: string;
        /**
         * Should Client Certificate Negotiation be enabled for this Hostname? Defaults to `false`.
         */
        negotiateClientCertificate?: boolean;
    }

    export interface ServiceHostnameConfigurationScm {
        /**
         * One or more (up to 10) `certificate` blocks as defined below.
         */
        certificate?: string;
        /**
         * The password for the certificate.
         */
        certificatePassword?: string;
        /**
         * The Hostname to use for the Management API.
         */
        hostName: string;
        /**
         * The ID of the Key Vault Secret containing the SSL Certificate, which must be should be of the type `application/x-pkcs12`.
         */
        keyVaultId?: string;
        /**
         * Should Client Certificate Negotiation be enabled for this Hostname? Defaults to `false`.
         */
        negotiateClientCertificate?: boolean;
    }

    export interface ServiceIdentity {
        /**
         * A list of IDs for User Assigned Managed Identity resources to be assigned.
         */
        identityIds?: string[];
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The identifier for the tenant access information contract.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this API Management Service. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
         */
        type?: string;
    }

    export interface ServicePolicy {
        /**
         * The XML Content for this Policy.
         */
        xmlContent: string;
        /**
         * A link to an API Management Policy XML Document, which must be publicly available.
         */
        xmlLink?: string;
    }

    export interface ServiceProtocols {
        /**
         * Should HTTP/2 be supported by the API Management Service? Defaults to `false`.
         */
        enableHttp2?: boolean;
    }

    export interface ServiceSecurity {
        /**
         * Should SSL 3.0 be enabled on the backend of the gateway? Defaults to `false`.
         */
        enableBackendSsl30?: boolean;
        /**
         * Should TLS 1.0 be enabled on the backend of the gateway? Defaults to `false`.
         */
        enableBackendTls10?: boolean;
        /**
         * Should TLS 1.1 be enabled on the backend of the gateway? Defaults to `false`.
         */
        enableBackendTls11?: boolean;
        /**
         * Should SSL 3.0 be enabled on the frontend of the gateway? Defaults to `false`.
         */
        enableFrontendSsl30?: boolean;
        /**
         * Should TLS 1.0 be enabled on the frontend of the gateway? Defaults to `false`.
         */
        enableFrontendTls10?: boolean;
        /**
         * Should TLS 1.1 be enabled on the frontend of the gateway? Defaults to `false`.
         */
        enableFrontendTls11?: boolean;
        /**
         * Should the `TLS_RSA_WITH_3DES_EDE_CBC_SHA` cipher be enabled for alL TLS versions (1.0, 1.1 and 1.2)? Defaults to `false`.
         *
         * @deprecated this has been renamed to the boolean attribute `triple_des_ciphers_enabled`.
         */
        enableTripleDesCiphers: boolean;
        /**
         * Should the `TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA` cipher be enabled? Defaults to `false`.
         */
        tlsEcdheEcdsaWithAes128CbcShaCiphersEnabled?: boolean;
        /**
         * Should the `TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA` cipher be enabled? Defaults to `false`.
         */
        tlsEcdheEcdsaWithAes256CbcShaCiphersEnabled?: boolean;
        tlsEcdheRsaWithAes128CbcShaCiphersEnabled?: boolean;
        tlsEcdheRsaWithAes256CbcShaCiphersEnabled?: boolean;
        /**
         * Should the `TLS_RSA_WITH_AES_128_CBC_SHA256` cipher be enabled? Defaults to `false`.
         */
        tlsRsaWithAes128CbcSha256CiphersEnabled?: boolean;
        /**
         * Should the `TLS_RSA_WITH_AES_128_CBC_SHA` cipher be enabled? Defaults to `false`.
         */
        tlsRsaWithAes128CbcShaCiphersEnabled?: boolean;
        /**
         * Should the `TLS_RSA_WITH_AES_128_GCM_SHA256` cipher be enabled? Defaults to `false`.
         */
        tlsRsaWithAes128GcmSha256CiphersEnabled?: boolean;
        /**
         * Should the `TLS_RSA_WITH_AES_256_CBC_SHA256` cipher be enabled? Defaults to `false`.
         */
        tlsRsaWithAes256CbcSha256CiphersEnabled?: boolean;
        /**
         * Should the `TLS_RSA_WITH_AES_256_CBC_SHA` cipher be enabled? Defaults to `false`.
         */
        tlsRsaWithAes256CbcShaCiphersEnabled?: boolean;
        /**
         * Should the `TLS_RSA_WITH_3DES_EDE_CBC_SHA` cipher be enabled for alL TLS versions (1.0, 1.1 and 1.2)? Defaults to `false`.
         */
        tripleDesCiphersEnabled: boolean;
    }

    export interface ServiceSignIn {
        /**
         * Should anonymous users be redirected to the sign in page?
         */
        enabled: boolean;
    }

    export interface ServiceSignUp {
        /**
         * Can users sign up on the development portal?
         */
        enabled: boolean;
        /**
         * A `termsOfService` block as defined below.
         */
        termsOfService: outputs.apimanagement.ServiceSignUpTermsOfService;
    }

    export interface ServiceSignUpTermsOfService {
        /**
         * Should the user be asked for consent during sign up?
         */
        consentRequired: boolean;
        /**
         * Should Terms of Service be displayed during sign up?.
         */
        enabled: boolean;
        /**
         * The Terms of Service which users are required to agree to in order to sign up.
         */
        text?: string;
    }

    export interface ServiceTenantAccess {
        /**
         * Should the access to the management api be enabled?
         */
        enabled: boolean;
        /**
         * Primary access key for the tenant access information contract.
         */
        primaryKey: string;
        /**
         * Secondary access key for the tenant access information contract.
         */
        secondaryKey: string;
        /**
         * The identifier for the tenant access information contract.
         */
        tenantId: string;
    }

    export interface ServiceVirtualNetworkConfiguration {
        /**
         * The id of the subnet that will be used for the API Management.
         */
        subnetId: string;
    }
}

export namespace appconfiguration {
    export interface ConfigurationStoreIdentity {
        /**
         * The ID of the Principal (Client) in Azure Active Directory.
         */
        principalId: string;
        /**
         * The ID of the Azure Active Directory Tenant.
         */
        tenantId: string;
        /**
         * Specifies the identity type of the App Configuration. At this time the only allowed value is `SystemAssigned`.
         */
        type: string;
    }

    export interface ConfigurationStorePrimaryReadKey {
        /**
         * The Connection String for this Access Key - comprising of the Endpoint, ID and Secret.
         */
        connectionString: string;
        /**
         * The ID of the Access Key.
         */
        id: string;
        /**
         * The Secret of the Access Key.
         */
        secret: string;
    }

    export interface ConfigurationStorePrimaryWriteKey {
        /**
         * The Connection String for this Access Key - comprising of the Endpoint, ID and Secret.
         */
        connectionString: string;
        /**
         * The ID of the Access Key.
         */
        id: string;
        /**
         * The Secret of the Access Key.
         */
        secret: string;
    }

    export interface ConfigurationStoreSecondaryReadKey {
        /**
         * The Connection String for this Access Key - comprising of the Endpoint, ID and Secret.
         */
        connectionString: string;
        /**
         * The ID of the Access Key.
         */
        id: string;
        /**
         * The Secret of the Access Key.
         */
        secret: string;
    }

    export interface ConfigurationStoreSecondaryWriteKey {
        /**
         * The Connection String for this Access Key - comprising of the Endpoint, ID and Secret.
         */
        connectionString: string;
        /**
         * The ID of the Access Key.
         */
        id: string;
        /**
         * The Secret of the Access Key.
         */
        secret: string;
    }

    export interface GetConfigurationStorePrimaryReadKey {
        /**
         * The Connection String for this Access Key - comprising of the Endpoint, ID and Secret.
         */
        connectionString: string;
        /**
         * The ID of the Access Key.
         */
        id: string;
        /**
         * The Secret of the Access Key.
         */
        secret: string;
    }

    export interface GetConfigurationStorePrimaryWriteKey {
        /**
         * The Connection String for this Access Key - comprising of the Endpoint, ID and Secret.
         */
        connectionString: string;
        /**
         * The ID of the Access Key.
         */
        id: string;
        /**
         * The Secret of the Access Key.
         */
        secret: string;
    }

    export interface GetConfigurationStoreSecondaryReadKey {
        /**
         * The Connection String for this Access Key - comprising of the Endpoint, ID and Secret.
         */
        connectionString: string;
        /**
         * The ID of the Access Key.
         */
        id: string;
        /**
         * The Secret of the Access Key.
         */
        secret: string;
    }

    export interface GetConfigurationStoreSecondaryWriteKey {
        /**
         * The Connection String for this Access Key - comprising of the Endpoint, ID and Secret.
         */
        connectionString: string;
        /**
         * The ID of the Access Key.
         */
        id: string;
        /**
         * The Secret of the Access Key.
         */
        secret: string;
    }

}

export namespace appplatform {
    export interface GetSpringCloudAppIdentity {
        /**
         * The Principal ID for the Service Principal associated with the Managed Service Identity of this Spring Cloud Application.
         */
        principalId: string;
        /**
         * The Tenant ID for the Service Principal associated with the Managed Service Identity of this Spring Cloud Application.
         */
        tenantId: string;
        /**
         * The Type of Managed Identity assigned to the Spring Cloud Application.
         */
        type: string;
    }

    export interface GetSpringCloudAppPersistentDisk {
        /**
         * The mount path of the persistent disk.
         */
        mountPath: string;
        /**
         * The size of the persistent disk in GB.
         */
        sizeInGb: number;
    }

    export interface GetSpringCloudServiceConfigServerGitSetting {
        /**
         * A `httpBasicAuth` block as defined below.
         */
        httpBasicAuths: outputs.appplatform.GetSpringCloudServiceConfigServerGitSettingHttpBasicAuth[];
        /**
         * The default label of the Git repository, which is a branch name, tag name, or commit-id of the repository
         */
        label: string;
        /**
         * One or more `repository` blocks as defined below.
         */
        repositories: outputs.appplatform.GetSpringCloudServiceConfigServerGitSettingRepository[];
        /**
         * An array of strings used to search subdirectories of the Git repository.
         */
        searchPaths: string[];
        /**
         * A `sshAuth` block as defined below.
         */
        sshAuths: outputs.appplatform.GetSpringCloudServiceConfigServerGitSettingSshAuth[];
        /**
         * The URI of the Git repository
         */
        uri: string;
    }

    export interface GetSpringCloudServiceConfigServerGitSettingHttpBasicAuth {
        /**
         * The password used to access the Http Basic Authentication Git repository server.
         */
        password: string;
        /**
         * The username used to access the Http Basic Authentication Git repository server.
         */
        username: string;
    }

    export interface GetSpringCloudServiceConfigServerGitSettingRepository {
        /**
         * A `httpBasicAuth` block as defined below.
         */
        httpBasicAuths: outputs.appplatform.GetSpringCloudServiceConfigServerGitSettingRepositoryHttpBasicAuth[];
        /**
         * The default label of the Git repository, which is a branch name, tag name, or commit-id of the repository
         */
        label: string;
        /**
         * Specifies The name of the Spring Cloud Service resource.
         */
        name: string;
        /**
         * An array of strings used to match an application name. For each pattern, use the `{application}/{profile}` format with wildcards.
         */
        patterns: string[];
        /**
         * An array of strings used to search subdirectories of the Git repository.
         */
        searchPaths: string[];
        /**
         * A `sshAuth` block as defined below.
         */
        sshAuths: outputs.appplatform.GetSpringCloudServiceConfigServerGitSettingRepositorySshAuth[];
        /**
         * The URI of the Git repository
         */
        uri: string;
    }

    export interface GetSpringCloudServiceConfigServerGitSettingRepositoryHttpBasicAuth {
        /**
         * The password used to access the Http Basic Authentication Git repository server.
         */
        password: string;
        /**
         * The username used to access the Http Basic Authentication Git repository server.
         */
        username: string;
    }

    export interface GetSpringCloudServiceConfigServerGitSettingRepositorySshAuth {
        /**
         * The host key of the Git repository server.
         */
        hostKey: string;
        /**
         * The host key algorithm.
         */
        hostKeyAlgorithm: string;
        /**
         * The SSH private key to access the Git repository, needed when the URI starts with `git@` or `ssh://`.
         */
        privateKey: string;
        /**
         * Indicates whether the Config Server instance will fail to start if the hostKey does not match.
         */
        strictHostKeyCheckingEnabled: boolean;
    }

    export interface GetSpringCloudServiceConfigServerGitSettingSshAuth {
        /**
         * The host key of the Git repository server.
         */
        hostKey: string;
        /**
         * The host key algorithm.
         */
        hostKeyAlgorithm: string;
        /**
         * The SSH private key to access the Git repository, needed when the URI starts with `git@` or `ssh://`.
         */
        privateKey: string;
        /**
         * Indicates whether the Config Server instance will fail to start if the hostKey does not match.
         */
        strictHostKeyCheckingEnabled: boolean;
    }

    export interface GetSpringCloudServiceRequiredNetworkTrafficRule {
        /**
         * The direction of required traffic. Possible values are `Inbound`, `Outbound`.
         */
        direction: string;
        /**
         * The FQDN list of required traffic.
         */
        fqdns: string[];
        ipAddresses: string[];
        /**
         * The port of required traffic.
         */
        port: number;
        /**
         * The protocol of required traffic.
         */
        protocol: string;
    }

    export interface SpringCloudAppIdentity {
        /**
         * The Principal ID for the Service Principal associated with the Managed Service Identity of this Spring Cloud Application.
         */
        principalId: string;
        /**
         * The Tenant ID for the Service Principal associated with the Managed Service Identity of this Spring Cloud Application.
         */
        tenantId: string;
        /**
         * Specifies the identity type of the Spring Cloud Application. Possible value is `SystemAssigned`.
         */
        type?: string;
    }

    export interface SpringCloudAppPersistentDisk {
        /**
         * Specifies the mount path of the persistent disk. Defaults to `/persistent`.
         */
        mountPath?: string;
        /**
         * Specifies the size of the persistent disk in GB. Possible values are between `0` and `50`.
         */
        sizeInGb: number;
    }

    export interface SpringCloudServiceConfigServerGitSetting {
        /**
         * A `httpBasicAuth` block as defined below.
         */
        httpBasicAuth?: outputs.appplatform.SpringCloudServiceConfigServerGitSettingHttpBasicAuth;
        /**
         * The default label of the Git repository, should be the branch name, tag name, or commit-id of the repository.
         */
        label?: string;
        /**
         * One or more `repository` blocks as defined below.
         */
        repositories?: outputs.appplatform.SpringCloudServiceConfigServerGitSettingRepository[];
        /**
         * An array of strings used to search subdirectories of the Git repository.
         */
        searchPaths?: string[];
        /**
         * A `sshAuth` block as defined below.
         */
        sshAuth?: outputs.appplatform.SpringCloudServiceConfigServerGitSettingSshAuth;
        /**
         * The URI of the default Git repository used as the Config Server back end, should be started with `http://`, `https://`, `git@`, or `ssh://`.
         */
        uri: string;
    }

    export interface SpringCloudServiceConfigServerGitSettingHttpBasicAuth {
        /**
         * The password used to access the Git repository server, required when the Git repository server supports Http Basic Authentication.
         */
        password: string;
        /**
         * The username that's used to access the Git repository server, required when the Git repository server supports Http Basic Authentication.
         */
        username: string;
    }

    export interface SpringCloudServiceConfigServerGitSettingRepository {
        /**
         * A `httpBasicAuth` block as defined below.
         */
        httpBasicAuth?: outputs.appplatform.SpringCloudServiceConfigServerGitSettingRepositoryHttpBasicAuth;
        /**
         * The default label of the Git repository, should be the branch name, tag name, or commit-id of the repository.
         */
        label?: string;
        /**
         * A name to identify on the Git repository, required only if repos exists.
         */
        name: string;
        /**
         * An array of strings used to match an application name. For each pattern, use the `{application}/{profile}` format with wildcards.
         */
        patterns?: string[];
        /**
         * An array of strings used to search subdirectories of the Git repository.
         */
        searchPaths?: string[];
        /**
         * A `sshAuth` block as defined below.
         */
        sshAuth?: outputs.appplatform.SpringCloudServiceConfigServerGitSettingRepositorySshAuth;
        /**
         * The URI of the Git repository that's used as the Config Server back end should be started with `http://`, `https://`, `git@`, or `ssh://`.
         */
        uri: string;
    }

    export interface SpringCloudServiceConfigServerGitSettingRepositoryHttpBasicAuth {
        /**
         * The password used to access the Git repository server, required when the Git repository server supports Http Basic Authentication.
         */
        password: string;
        /**
         * The username that's used to access the Git repository server, required when the Git repository server supports Http Basic Authentication.
         */
        username: string;
    }

    export interface SpringCloudServiceConfigServerGitSettingRepositorySshAuth {
        /**
         * The host key of the Git repository server, should not include the algorithm prefix as covered by `host-key-algorithm`.
         */
        hostKey?: string;
        /**
         * The host key algorithm, should be `ssh-dss`, `ssh-rsa`, `ecdsa-sha2-nistp256`, `ecdsa-sha2-nistp384`, or `ecdsa-sha2-nistp521`. Required only if `host-key` exists.
         */
        hostKeyAlgorithm?: string;
        /**
         * The SSH private key to access the Git repository, required when the URI starts with `git@` or `ssh://`.
         */
        privateKey: string;
        /**
         * Indicates whether the Config Server instance will fail to start if the hostKey does not match.
         */
        strictHostKeyCheckingEnabled?: boolean;
    }

    export interface SpringCloudServiceConfigServerGitSettingSshAuth {
        /**
         * The host key of the Git repository server, should not include the algorithm prefix as covered by `host-key-algorithm`.
         */
        hostKey?: string;
        /**
         * The host key algorithm, should be `ssh-dss`, `ssh-rsa`, `ecdsa-sha2-nistp256`, `ecdsa-sha2-nistp384`, or `ecdsa-sha2-nistp521`. Required only if `host-key` exists.
         */
        hostKeyAlgorithm?: string;
        /**
         * The SSH private key to access the Git repository, required when the URI starts with `git@` or `ssh://`.
         */
        privateKey: string;
        /**
         * Indicates whether the Config Server instance will fail to start if the hostKey does not match.
         */
        strictHostKeyCheckingEnabled?: boolean;
    }

    export interface SpringCloudServiceNetwork {
        /**
         * Specifies the Name of the resource group containing network resources of Azure Spring Cloud Apps. Changing this forces a new resource to be created.
         */
        appNetworkResourceGroup: string;
        /**
         * Specifies the ID of the Subnet which should host the Spring Boot Applications deployed in this Spring Cloud Service. Changing this forces a new resource to be created.
         */
        appSubnetId: string;
        /**
         * A list of (at least 3) CIDR ranges (at least /16) which are used to host the Spring Cloud infrastructure, which must not overlap with any existing CIDR ranges in the Subnet. Changing this forces a new resource to be created.
         */
        cidrRanges: string[];
        /**
         * Specifies the Name of the resource group containing network resources of Azure Spring Cloud Service Runtime. Changing this forces a new resource to be created.
         */
        serviceRuntimeNetworkResourceGroup: string;
        /**
         * Specifies the ID of the Subnet where the Service Runtime components of the Spring Cloud Service will exist. Changing this forces a new resource to be created.
         */
        serviceRuntimeSubnetId: string;
    }

    export interface SpringCloudServiceRequiredNetworkTrafficRule {
        /**
         * The direction of required traffic. Possible values are `Inbound`, `Outbound`.
         */
        direction: string;
        /**
         * The FQDN list of required traffic.
         */
        fqdns: string[];
        ipAddresses: string[];
        /**
         * The port of required traffic.
         */
        port: number;
        /**
         * The protocol of required traffic.
         */
        protocol: string;
    }

    export interface SpringCloudServiceTrace {
        /**
         * The Instrumentation Key used for Application Insights.
         */
        instrumentationKey: string;
        /**
         * The sampling rate of Application Insights Agent. Must be between `0.0` and `100.0`. Defaults to `10.0`.
         */
        sampleRate?: number;
    }
}

export namespace appservice {
    export interface AppServiceAuthSettings {
        /**
         * A `activeDirectory` block as defined below.
         */
        activeDirectory?: outputs.appservice.AppServiceAuthSettingsActiveDirectory;
        /**
         * Login parameters to send to the OpenID Connect authorization endpoint when a user logs in. Each parameter must be in the form "key=value".
         */
        additionalLoginParams?: {[key: string]: string};
        /**
         * External URLs that can be redirected to as part of logging in or logging out of the app.
         */
        allowedExternalRedirectUrls?: string[];
        /**
         * The default provider to use when multiple providers have been set up. Possible values are `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount` and `Twitter`.
         */
        defaultProvider?: string;
        /**
         * Is Authentication enabled?
         */
        enabled: boolean;
        /**
         * A `facebook` block as defined below.
         */
        facebook?: outputs.appservice.AppServiceAuthSettingsFacebook;
        /**
         * A `google` block as defined below.
         */
        google?: outputs.appservice.AppServiceAuthSettingsGoogle;
        /**
         * Issuer URI. When using Azure Active Directory, this value is the URI of the directory tenant, e.g. https://sts.windows.net/{tenant-guid}/.
         */
        issuer?: string;
        /**
         * A `microsoft` block as defined below.
         */
        microsoft?: outputs.appservice.AppServiceAuthSettingsMicrosoft;
        /**
         * The runtime version of the Authentication/Authorization module.
         */
        runtimeVersion?: string;
        /**
         * The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to 72.
         */
        tokenRefreshExtensionHours?: number;
        /**
         * If enabled the module will durably store platform-specific security tokens that are obtained during login flows. Defaults to false.
         */
        tokenStoreEnabled?: boolean;
        /**
         * A `twitter` block as defined below.
         */
        twitter?: outputs.appservice.AppServiceAuthSettingsTwitter;
        /**
         * The action to take when an unauthenticated client attempts to access the app. Possible values are `AllowAnonymous` and `RedirectToLoginPage`.
         */
        unauthenticatedClientAction?: string;
    }

    export interface AppServiceAuthSettingsActiveDirectory {
        /**
         * Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
         */
        allowedAudiences?: string[];
        /**
         * The Client ID of this relying party application. Enables OpenIDConnection authentication with Azure Active Directory.
         */
        clientId: string;
        /**
         * The Client Secret of this relying party application. If no secret is provided, implicit flow will be used.
         */
        clientSecret?: string;
    }

    export interface AppServiceAuthSettingsFacebook {
        /**
         * The App ID of the Facebook app used for login
         */
        appId: string;
        /**
         * The App Secret of the Facebook app used for Facebook Login.
         */
        appSecret: string;
        /**
         * The OAuth 2.0 scopes that will be requested as part of Facebook Login authentication. https://developers.facebook.com/docs/facebook-login
         */
        oauthScopes?: string[];
    }

    export interface AppServiceAuthSettingsGoogle {
        /**
         * The OpenID Connect Client ID for the Google web application.
         */
        clientId: string;
        /**
         * The client secret associated with the Google web application.
         */
        clientSecret: string;
        /**
         * The OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. https://developers.google.com/identity/sign-in/web/
         */
        oauthScopes?: string[];
    }

    export interface AppServiceAuthSettingsMicrosoft {
        /**
         * The OAuth 2.0 client ID that was created for the app used for authentication.
         */
        clientId: string;
        /**
         * The OAuth 2.0 client secret that was created for the app used for authentication.
         */
        clientSecret: string;
        /**
         * The OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. https://msdn.microsoft.com/en-us/library/dn631845.aspx
         */
        oauthScopes?: string[];
    }

    export interface AppServiceAuthSettingsTwitter {
        consumerKey: string;
        consumerSecret: string;
    }

    export interface AppServiceBackup {
        /**
         * Is this Backup enabled?
         */
        enabled?: boolean;
        /**
         * Specifies the name for this Backup.
         */
        name: string;
        /**
         * A `schedule` block as defined below.
         */
        schedule: outputs.appservice.AppServiceBackupSchedule;
        /**
         * The SAS URL to a Storage Container where Backups should be saved.
         */
        storageAccountUrl: string;
    }

    export interface AppServiceBackupSchedule {
        /**
         * Sets how often the backup should be executed.
         */
        frequencyInterval: number;
        /**
         * Sets the unit of time for how often the backup should be executed. Possible values are `Day` or `Hour`.
         */
        frequencyUnit: string;
        /**
         * Should at least one backup always be kept in the Storage Account by the Retention Policy, regardless of how old it is?
         */
        keepAtLeastOneBackup?: boolean;
        /**
         * Specifies the number of days after which Backups should be deleted.
         */
        retentionPeriodInDays?: number;
        /**
         * Sets when the schedule should start working.
         */
        startTime?: string;
    }

    export interface AppServiceConnectionString {
        /**
         * The name of the Connection String.
         */
        name: string;
        /**
         * The type of the Connection String. Possible values are `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure` and  `SQLServer`.
         */
        type: string;
        /**
         * The value for the Connection String.
         */
        value: string;
    }

    export interface AppServiceIdentity {
        /**
         * Specifies a list of user managed identity ids to be assigned. Required if `type` is `UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID for the Service Principal associated with the Managed Service Identity of this App Service.
         */
        principalId: string;
        /**
         * The Tenant ID for the Service Principal associated with the Managed Service Identity of this App Service.
         */
        tenantId: string;
        /**
         * Specifies the identity type of the App Service. Possible values are `SystemAssigned` (where Azure will generate a Service Principal for you), `UserAssigned` where you can specify the Service Principal IDs in the `identityIds` field, and `SystemAssigned, UserAssigned` which assigns both a system managed identity as well as the specified user assigned identities.
         */
        type: string;
    }

    export interface AppServiceLogs {
        /**
         * An `applicationLogs` block as defined below.
         */
        applicationLogs: outputs.appservice.AppServiceLogsApplicationLogs;
        /**
         * Should `Detailed error messages` be enabled on this App Service? Defaults to `false`.
         */
        detailedErrorMessagesEnabled?: boolean;
        /**
         * Should `Failed request tracing` be enabled on this App Service? Defaults to `false`.
         */
        failedRequestTracingEnabled?: boolean;
        /**
         * An `httpLogs` block as defined below.
         */
        httpLogs: outputs.appservice.AppServiceLogsHttpLogs;
    }

    export interface AppServiceLogsApplicationLogs {
        /**
         * An `azureBlobStorage` block as defined below.
         */
        azureBlobStorage?: outputs.appservice.AppServiceLogsApplicationLogsAzureBlobStorage;
        fileSystemLevel?: string;
    }

    export interface AppServiceLogsApplicationLogsAzureBlobStorage {
        /**
         * The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `httpLogs`
         */
        level: string;
        /**
         * The number of days to retain logs for.
         */
        retentionInDays: number;
        /**
         * The URL to the storage container with a shared access signature token appended.
         */
        sasUrl: string;
    }

    export interface AppServiceLogsHttpLogs {
        /**
         * An `azureBlobStorage` block as defined below.
         */
        azureBlobStorage?: outputs.appservice.AppServiceLogsHttpLogsAzureBlobStorage;
        /**
         * A `fileSystem` block as defined below.
         */
        fileSystem?: outputs.appservice.AppServiceLogsHttpLogsFileSystem;
    }

    export interface AppServiceLogsHttpLogsAzureBlobStorage {
        /**
         * The number of days to retain logs for.
         */
        retentionInDays: number;
        /**
         * The URL to the storage container with a shared access signature token appended.
         */
        sasUrl: string;
    }

    export interface AppServiceLogsHttpLogsFileSystem {
        /**
         * The number of days to retain logs for.
         */
        retentionInDays: number;
        /**
         * The maximum size in megabytes that http log files can use before being removed.
         */
        retentionInMb: number;
    }

    export interface AppServiceSiteConfig {
        /**
         * Should the app be loaded at all times? Defaults to `false`.
         */
        alwaysOn?: boolean;
        /**
         * App command line to launch, e.g. `/sbin/myserver -b 0.0.0.0`.
         */
        appCommandLine?: string;
        autoSwapSlotName?: string;
        /**
         * A `cors` block as defined below.
         */
        cors: outputs.appservice.AppServiceSiteConfigCors;
        /**
         * The ordering of default documents to load, if an address isn't specified.
         */
        defaultDocuments?: string[];
        /**
         * The version of the .net framework's CLR used in this App Service. Possible values are `v2.0` (which will use the latest version of the .net framework for the .net CLR v2 - currently `.net 3.5`), `v4.0` (which corresponds to the latest version of the .net CLR v4 - which at the time of writing is `.net 4.7.1`) and `v5.0`. [For more information on which .net CLR version to use based on the .net framework you're targeting - please see this table](https://en.wikipedia.org/wiki/.NET_Framework_version_history#Overview). Defaults to `v4.0`.
         */
        dotnetFrameworkVersion?: string;
        /**
         * State of FTP / FTPS service for this App Service. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`.
         */
        ftpsState: string;
        /**
         * The health check path to be pinged by App Service. [For more information - please see App Service health check announcement](https://azure.github.io/AppService/2020/08/24/healthcheck-on-app-service.html).
         */
        healthCheckPath?: string;
        /**
         * Is HTTP2 Enabled on this App Service? Defaults to `false`.
         */
        http2Enabled?: boolean;
        /**
         * A list of objects representing ip restrictions as defined below.
         */
        ipRestrictions: outputs.appservice.AppServiceSiteConfigIpRestriction[];
        /**
         * The Java Container to use. If specified `javaVersion` and `javaContainerVersion` must also be specified. Possible values are `JAVA`, `JETTY`, and `TOMCAT`.
         */
        javaContainer?: string;
        /**
         * The version of the Java Container to use. If specified `javaVersion` and `javaContainer` must also be specified.
         */
        javaContainerVersion?: string;
        /**
         * The version of Java to use. If specified `javaContainer` and `javaContainerVersion` must also be specified. Possible values are `1.7`, `1.8` and `11` and their specific versions - except for Java 11 (e.g. `1.7.0_80`, `1.8.0_181`, `11`)
         */
        javaVersion?: string;
        /**
         * Linux App Framework and version for the App Service. Possible options are a Docker container (`DOCKER|<user/image:tag>`), a base-64 encoded Docker Compose file (`COMPOSE|${filebase64("compose.yml")}`) or a base-64 encoded Kubernetes Manifest (`KUBE|${filebase64("kubernetes.yml")}`).
         */
        linuxFxVersion: string;
        /**
         * Is "MySQL In App" Enabled? This runs a local MySQL instance with your app and shares resources from the App Service plan.
         */
        localMysqlEnabled: boolean;
        /**
         * The Managed Pipeline Mode. Possible values are `Integrated` and `Classic`. Defaults to `Integrated`.
         */
        managedPipelineMode: string;
        /**
         * The minimum supported TLS version for the app service. Possible values are `1.0`, `1.1`, and `1.2`. Defaults to `1.2` for new app services.
         */
        minTlsVersion: string;
        /**
         * The scaled number of workers (for per site scaling) of this App Service. Requires that `perSiteScaling` is enabled on the `azure.appservice.Plan`. [For more information - please see Microsoft documentation on high-density hosting](https://docs.microsoft.com/en-us/azure/app-service/manage-scale-per-app).
         */
        numberOfWorkers: number;
        /**
         * The version of PHP to use in this App Service. Possible values are `5.5`, `5.6`, `7.0`, `7.1`, `7.2`, `7.3` and `7.4`.
         */
        phpVersion?: string;
        /**
         * The version of Python to use in this App Service. Possible values are `2.7` and `3.4`.
         */
        pythonVersion?: string;
        /**
         * Is Remote Debugging Enabled? Defaults to `false`.
         */
        remoteDebuggingEnabled?: boolean;
        /**
         * Which version of Visual Studio should the Remote Debugger be compatible with? Possible values are `VS2012`, `VS2013`, `VS2015` and `VS2017`.
         */
        remoteDebuggingVersion: string;
        /**
         * A [List of objects](https://www.terraform.io/docs/configuration/attr-as-blocks.html) representing ip restrictions as defined below.
         */
        scmIpRestrictions: outputs.appservice.AppServiceSiteConfigScmIpRestriction[];
        /**
         * The type of Source Control enabled for this App Service. Defaults to `None`. Possible values are: `BitbucketGit`, `BitbucketHg`, `CodePlexGit`, `CodePlexHg`, `Dropbox`, `ExternalGit`, `ExternalHg`, `GitHub`, `LocalGit`, `None`, `OneDrive`, `Tfs`, `VSO`, and `VSTSRM`
         */
        scmType: string;
        /**
         * IP security restrictions for scm to use main. Defaults to false.
         */
        scmUseMainIpRestriction?: boolean;
        /**
         * Should the App Service run in 32 bit mode, rather than 64 bit mode?
         */
        use32BitWorkerProcess?: boolean;
        /**
         * Should WebSockets be enabled?
         */
        websocketsEnabled: boolean;
        /**
         * The Windows Docker container image (`DOCKER|<user/image:tag>`)
         */
        windowsFxVersion: string;
    }

    export interface AppServiceSiteConfigCors {
        /**
         * A list of origins which should be able to make cross-origin calls. `*` can be used to allow all calls.
         */
        allowedOrigins: string[];
        /**
         * Are credentials supported?
         */
        supportCredentials?: boolean;
    }

    export interface AppServiceSiteConfigIpRestriction {
        /**
         * Does this restriction `Allow` or `Deny` access for this IP range. Defaults to `Allow`.
         */
        action?: string;
        /**
         * The headers for this specific `ipRestriction` as defined below.
         */
        headers: outputs.appservice.AppServiceSiteConfigIpRestrictionHeaders;
        /**
         * The IP Address used for this IP Restriction in CIDR notation.
         */
        ipAddress?: string;
        /**
         * The name for this IP Restriction.
         */
        name: string;
        /**
         * The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
         */
        priority?: number;
        /**
         * The Service Tag used for this IP Restriction.
         */
        serviceTag?: string;
        /**
         * The Virtual Network Subnet ID used for this IP Restriction.
         */
        virtualNetworkSubnetId?: string;
    }

    export interface AppServiceSiteConfigIpRestrictionHeaders {
        /**
         * A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
         */
        xAzureFdids?: string[];
        /**
         * A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
         */
        xFdHealthProbe?: string;
        /**
         * A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
         */
        xForwardedFors?: string[];
        /**
         * A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
         */
        xForwardedHosts?: string[];
    }

    export interface AppServiceSiteConfigScmIpRestriction {
        /**
         * Allow or Deny access for this IP range. Defaults to Allow.
         */
        action?: string;
        /**
         * The headers for this specific `scmIpRestriction` as defined below.
         */
        headers: outputs.appservice.AppServiceSiteConfigScmIpRestrictionHeaders;
        /**
         * The IP Address used for this IP Restriction in CIDR notation.
         */
        ipAddress?: string;
        /**
         * The name for this IP Restriction.
         */
        name: string;
        /**
         * The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
         */
        priority?: number;
        /**
         * The Service Tag used for this IP Restriction.
         */
        serviceTag?: string;
        /**
         * The Virtual Network Subnet ID used for this IP Restriction.
         */
        virtualNetworkSubnetId?: string;
    }

    export interface AppServiceSiteConfigScmIpRestrictionHeaders {
        /**
         * A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
         */
        xAzureFdids?: string[];
        /**
         * A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
         */
        xFdHealthProbe?: string;
        /**
         * A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
         */
        xForwardedFors?: string[];
        /**
         * A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
         */
        xForwardedHosts?: string[];
    }

    export interface AppServiceSiteCredential {
        /**
         * The password associated with the username, which can be used to publish to this App Service.
         */
        password: string;
        /**
         * The username which can be used to publish to this App Service
         */
        username: string;
    }

    export interface AppServiceSourceControl {
        /**
         * The branch of the remote repository to use. Defaults to 'master'.
         */
        branch: string;
        /**
         * Limits to manual integration. Defaults to `false` if not specified.
         */
        manualIntegration: boolean;
        /**
         * The URL of the source code repository.
         */
        repoUrl: string;
        /**
         * Enable roll-back for the repository. Defaults to `false` if not specified.
         */
        rollbackEnabled: boolean;
        /**
         * Use Mercurial if `true`, otherwise uses Git.
         */
        useMercurial: boolean;
    }

    export interface AppServiceStorageAccount {
        /**
         * The access key for the storage account.
         */
        accessKey: string;
        /**
         * The name of the storage account.
         */
        accountName: string;
        /**
         * The path to mount the storage within the site's runtime environment.
         */
        mountPath?: string;
        /**
         * The name of the storage account identifier.
         */
        name: string;
        /**
         * The name of the file share (container name, for Blob storage).
         */
        shareName: string;
        /**
         * The type of storage. Possible values are `AzureBlob` and `AzureFiles`.
         */
        type: string;
    }

    export interface CertificateOrderCertificate {
        /**
         * The name of the App Service Certificate.
         */
        certificateName: string;
        /**
         * Key Vault resource Id.
         */
        keyVaultId: string;
        /**
         * Key Vault secret name.
         */
        keyVaultSecretName: string;
        /**
         * Status of the Key Vault secret.
         */
        provisioningState: string;
    }

    export interface EnvironmentClusterSetting {
        /**
         * The name of the Cluster Setting.
         */
        name: string;
        /**
         * The value for the Cluster Setting.
         */
        value: string;
    }

    export interface EnvironmentV3ClusterSetting {
        /**
         * The name of the Cluster Setting.
         */
        name: string;
        /**
         * The value for the Cluster Setting.
         */
        value: string;
    }

    export interface FunctionAppAuthSettings {
        /**
         * A `activeDirectory` block as defined below.
         */
        activeDirectory?: outputs.appservice.FunctionAppAuthSettingsActiveDirectory;
        /**
         * Login parameters to send to the OpenID Connect authorization endpoint when a user logs in. Each parameter must be in the form "key=value".
         */
        additionalLoginParams?: {[key: string]: string};
        /**
         * External URLs that can be redirected to as part of logging in or logging out of the app.
         */
        allowedExternalRedirectUrls?: string[];
        /**
         * The default provider to use when multiple providers have been set up. Possible values are `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount` and `Twitter`.
         */
        defaultProvider?: string;
        /**
         * Is Authentication enabled?
         */
        enabled: boolean;
        /**
         * A `facebook` block as defined below.
         */
        facebook?: outputs.appservice.FunctionAppAuthSettingsFacebook;
        /**
         * A `google` block as defined below.
         */
        google?: outputs.appservice.FunctionAppAuthSettingsGoogle;
        /**
         * Issuer URI. When using Azure Active Directory, this value is the URI of the directory tenant, e.g. https://sts.windows.net/{tenant-guid}/.
         */
        issuer?: string;
        /**
         * A `microsoft` block as defined below.
         */
        microsoft?: outputs.appservice.FunctionAppAuthSettingsMicrosoft;
        /**
         * The runtime version of the Authentication/Authorization module.
         */
        runtimeVersion?: string;
        /**
         * The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to 72.
         */
        tokenRefreshExtensionHours?: number;
        /**
         * If enabled the module will durably store platform-specific security tokens that are obtained during login flows. Defaults to false.
         */
        tokenStoreEnabled?: boolean;
        /**
         * A `twitter` block as defined below.
         */
        twitter?: outputs.appservice.FunctionAppAuthSettingsTwitter;
        /**
         * The action to take when an unauthenticated client attempts to access the app. Possible values are `AllowAnonymous` and `RedirectToLoginPage`.
         */
        unauthenticatedClientAction?: string;
    }

    export interface FunctionAppAuthSettingsActiveDirectory {
        /**
         * Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
         */
        allowedAudiences?: string[];
        /**
         * The Client ID of this relying party application. Enables OpenIDConnection authentication with Azure Active Directory.
         */
        clientId: string;
        /**
         * The Client Secret of this relying party application. If no secret is provided, implicit flow will be used.
         */
        clientSecret?: string;
    }

    export interface FunctionAppAuthSettingsFacebook {
        /**
         * The App ID of the Facebook app used for login
         */
        appId: string;
        /**
         * The App Secret of the Facebook app used for Facebook Login.
         */
        appSecret: string;
        /**
         * The OAuth 2.0 scopes that will be requested as part of Facebook Login authentication. https://developers.facebook.com/docs/facebook-login
         */
        oauthScopes?: string[];
    }

    export interface FunctionAppAuthSettingsGoogle {
        /**
         * The OpenID Connect Client ID for the Google web application.
         */
        clientId: string;
        /**
         * The client secret associated with the Google web application.
         */
        clientSecret: string;
        /**
         * The OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. https://developers.google.com/identity/sign-in/web/
         */
        oauthScopes?: string[];
    }

    export interface FunctionAppAuthSettingsMicrosoft {
        /**
         * The OAuth 2.0 client ID that was created for the app used for authentication.
         */
        clientId: string;
        /**
         * The OAuth 2.0 client secret that was created for the app used for authentication.
         */
        clientSecret: string;
        /**
         * The OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. https://msdn.microsoft.com/en-us/library/dn631845.aspx
         */
        oauthScopes?: string[];
    }

    export interface FunctionAppAuthSettingsTwitter {
        consumerKey: string;
        consumerSecret: string;
    }

    export interface FunctionAppConnectionString {
        /**
         * The name of the Connection String.
         */
        name: string;
        /**
         * The type of the Connection String. Possible values are `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure` and  `SQLServer`.
         */
        type: string;
        /**
         * The value for the Connection String.
         */
        value: string;
    }

    export interface FunctionAppIdentity {
        /**
         * Specifies a list of user managed identity ids to be assigned. Required if `type` is `UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID for the Service Principal associated with the Managed Service Identity of this App Service.
         */
        principalId: string;
        /**
         * The Tenant ID for the Service Principal associated with the Managed Service Identity of this App Service.
         */
        tenantId: string;
        /**
         * Specifies the identity type of the Function App. Possible values are `SystemAssigned` (where Azure will generate a Service Principal for you), `UserAssigned` where you can specify the Service Principal IDs in the `identityIds` field, and `SystemAssigned, UserAssigned` which assigns both a system managed identity as well as the specified user assigned identities.
         */
        type: string;
    }

    export interface FunctionAppSiteConfig {
        /**
         * Should the Function App be loaded at all times? Defaults to `false`.
         */
        alwaysOn?: boolean;
        autoSwapSlotName?: string;
        /**
         * A `cors` block as defined below.
         */
        cors: outputs.appservice.FunctionAppSiteConfigCors;
        /**
         * State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`. Defaults to `AllAllowed`.
         */
        ftpsState: string;
        /**
         * Path which will be checked for this function app health.
         */
        healthCheckPath?: string;
        /**
         * Specifies whether or not the http2 protocol should be enabled. Defaults to `false`.
         */
        http2Enabled?: boolean;
        /**
         * A [List of objects](https://www.terraform.io/docs/configuration/attr-as-blocks.html) representing ip restrictions as defined below.
         */
        ipRestrictions: outputs.appservice.FunctionAppSiteConfigIpRestriction[];
        /**
         * Java version hosted by the function app in Azure. Possible values are `1.8`, `11`.
         */
        javaVersion?: string;
        /**
         * Linux App Framework and version for the AppService, e.g. `DOCKER|(golang:latest)`.
         */
        linuxFxVersion: string;
        /**
         * The minimum supported TLS version for the function app. Possible values are `1.0`, `1.1`, and `1.2`. Defaults to `1.2` for new function apps.
         */
        minTlsVersion: string;
        /**
         * The number of pre-warmed instances for this function app. Only affects apps on the Premium plan.
         */
        preWarmedInstanceCount: number;
        /**
         * A [List of objects](https://www.terraform.io/docs/configuration/attr-as-blocks.html) representing ip restrictions as defined below.
         */
        scmIpRestrictions: outputs.appservice.FunctionAppSiteConfigScmIpRestriction[];
        /**
         * The type of Source Control used by the Function App. Valid values include: `BitBucketGit`, `BitBucketHg`, `CodePlexGit`, `CodePlexHg`, `Dropbox`, `ExternalGit`, `ExternalHg`, `GitHub`, `LocalGit`, `None` (default), `OneDrive`, `Tfs`, `VSO`, and `VSTSRM`
         */
        scmType: string;
        /**
         * IP security restrictions for scm to use main. Defaults to false.
         */
        scmUseMainIpRestriction?: boolean;
        /**
         * Should the Function App run in 32 bit mode, rather than 64 bit mode? Defaults to `true`.
         */
        use32BitWorkerProcess?: boolean;
        /**
         * Should WebSockets be enabled?
         */
        websocketsEnabled?: boolean;
    }

    export interface FunctionAppSiteConfigCors {
        /**
         * A list of origins which should be able to make cross-origin calls. `*` can be used to allow all calls.
         */
        allowedOrigins: string[];
        /**
         * Are credentials supported?
         */
        supportCredentials?: boolean;
    }

    export interface FunctionAppSiteConfigIpRestriction {
        /**
         * Does this restriction `Allow` or `Deny` access for this IP range. Defaults to `Allow`.
         */
        action?: string;
        /**
         * The headers for this specific `ipRestriction` as defined below.
         */
        headers: outputs.appservice.FunctionAppSiteConfigIpRestrictionHeaders;
        /**
         * The IP Address used for this IP Restriction in CIDR notation.
         */
        ipAddress?: string;
        /**
         * The name for this IP Restriction.
         */
        name: string;
        /**
         * The priority for this IP Restriction. Restrictions are enforced in priority order. By default, the priority is set to 65000 if not specified.
         */
        priority?: number;
        /**
         * The Service Tag used for this IP Restriction.
         */
        serviceTag?: string;
        /**
         * The Virtual Network Subnet ID used for this IP Restriction.
         */
        virtualNetworkSubnetId?: string;
    }

    export interface FunctionAppSiteConfigIpRestrictionHeaders {
        /**
         * A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
         */
        xAzureFdids?: string[];
        /**
         * A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
         */
        xFdHealthProbe?: string;
        /**
         * A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
         */
        xForwardedFors?: string[];
        /**
         * A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
         */
        xForwardedHosts?: string[];
    }

    export interface FunctionAppSiteConfigScmIpRestriction {
        /**
         * Allow or Deny access for this IP range. Defaults to Allow.
         */
        action?: string;
        /**
         * The headers for this specific `scmIpRestriction` as defined below.
         */
        headers: outputs.appservice.FunctionAppSiteConfigScmIpRestrictionHeaders;
        /**
         * The IP Address used for this IP Restriction in CIDR notation.
         */
        ipAddress?: string;
        /**
         * The name for this IP Restriction.
         */
        name: string;
        /**
         * The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
         */
        priority?: number;
        /**
         * The Service Tag used for this IP Restriction.
         */
        serviceTag?: string;
        /**
         * The Virtual Network Subnet ID used for this IP Restriction.
         */
        virtualNetworkSubnetId?: string;
    }

    export interface FunctionAppSiteConfigScmIpRestrictionHeaders {
        /**
         * A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
         */
        xAzureFdids?: string[];
        /**
         * A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
         */
        xFdHealthProbe?: string;
        /**
         * A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
         */
        xForwardedFors?: string[];
        /**
         * A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
         */
        xForwardedHosts?: string[];
    }

    export interface FunctionAppSiteCredential {
        /**
         * The password associated with the username, which can be used to publish to this App Service.
         */
        password: string;
        /**
         * The username which can be used to publish to this App Service
         */
        username: string;
    }

    export interface FunctionAppSlotAuthSettings {
        /**
         * An `activeDirectory` block as defined below.
         */
        activeDirectory?: outputs.appservice.FunctionAppSlotAuthSettingsActiveDirectory;
        /**
         * Login parameters to send to the OpenID Connect authorization endpoint when a user logs in. Each parameter must be in the form "key=value".
         */
        additionalLoginParams?: {[key: string]: string};
        /**
         * External URLs that can be redirected to as part of logging in or logging out of the app.
         */
        allowedExternalRedirectUrls?: string[];
        /**
         * The default provider to use when multiple providers have been set up. Possible values are `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount` and `Twitter`.
         */
        defaultProvider?: string;
        /**
         * Is Authentication enabled?
         */
        enabled: boolean;
        /**
         * A `facebook` block as defined below.
         */
        facebook?: outputs.appservice.FunctionAppSlotAuthSettingsFacebook;
        /**
         * A `google` block as defined below.
         */
        google?: outputs.appservice.FunctionAppSlotAuthSettingsGoogle;
        /**
         * Issuer URI. When using Azure Active Directory, this value is the URI of the directory tenant, e.g. https://sts.windows.net/{tenant-guid}/.
         */
        issuer?: string;
        /**
         * A `microsoft` block as defined below.
         */
        microsoft?: outputs.appservice.FunctionAppSlotAuthSettingsMicrosoft;
        /**
         * The runtime version of the Authentication/Authorization module.
         */
        runtimeVersion?: string;
        /**
         * The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to 72.
         */
        tokenRefreshExtensionHours?: number;
        /**
         * If enabled the module will durably store platform-specific security tokens that are obtained during login flows. Defaults to false.
         */
        tokenStoreEnabled?: boolean;
        /**
         * A `twitter` block as defined below.
         */
        twitter?: outputs.appservice.FunctionAppSlotAuthSettingsTwitter;
        /**
         * The action to take when an unauthenticated client attempts to access the app. Possible values are `AllowAnonymous` and `RedirectToLoginPage`.
         */
        unauthenticatedClientAction?: string;
    }

    export interface FunctionAppSlotAuthSettingsActiveDirectory {
        /**
         * Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
         */
        allowedAudiences?: string[];
        /**
         * The Client ID of this relying party application. Enables OpenIDConnection authentication with Azure Active Directory.
         */
        clientId: string;
        /**
         * The Client Secret of this relying party application. If no secret is provided, implicit flow will be used.
         */
        clientSecret?: string;
    }

    export interface FunctionAppSlotAuthSettingsFacebook {
        /**
         * The App ID of the Facebook app used for login
         */
        appId: string;
        /**
         * The App Secret of the Facebook app used for Facebook Login.
         */
        appSecret: string;
        /**
         * The OAuth 2.0 scopes that will be requested as part of Facebook Login authentication. https://developers.facebook.com/docs/facebook-login
         */
        oauthScopes?: string[];
    }

    export interface FunctionAppSlotAuthSettingsGoogle {
        /**
         * The OpenID Connect Client ID for the Google web application.
         */
        clientId: string;
        /**
         * The client secret associated with the Google web application.
         */
        clientSecret: string;
        /**
         * The OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. https://developers.google.com/identity/sign-in/web/
         */
        oauthScopes?: string[];
    }

    export interface FunctionAppSlotAuthSettingsMicrosoft {
        /**
         * The OAuth 2.0 client ID that was created for the app used for authentication.
         */
        clientId: string;
        /**
         * The OAuth 2.0 client secret that was created for the app used for authentication.
         */
        clientSecret: string;
        /**
         * The OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. https://msdn.microsoft.com/en-us/library/dn631845.aspx
         */
        oauthScopes?: string[];
    }

    export interface FunctionAppSlotAuthSettingsTwitter {
        consumerKey: string;
        consumerSecret: string;
    }

    export interface FunctionAppSlotConnectionString {
        /**
         * The name of the Connection String.
         */
        name: string;
        /**
         * The type of the Connection String. Possible values are `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure` and  `SQLServer`.
         */
        type: string;
        /**
         * The value for the Connection String.
         */
        value: string;
    }

    export interface FunctionAppSlotIdentity {
        /**
         * Specifies a list of user managed identity ids to be assigned. Required if `type` is `UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID for the Service Principal associated with the Managed Service Identity of this App Service.
         */
        principalId: string;
        /**
         * The Tenant ID for the Service Principal associated with the Managed Service Identity of this App Service.
         */
        tenantId: string;
        /**
         * Specifies the identity type of the Function App. Possible values are `SystemAssigned` (where Azure will generate a Service Principal for you), `UserAssigned` where you can specify the Service Principal IDs in the `identityIds` field, and `SystemAssigned, UserAssigned` which assigns both a system managed identity as well as the specified user assigned identities.
         */
        type: string;
    }

    export interface FunctionAppSlotSiteConfig {
        /**
         * Should the Function App be loaded at all times? Defaults to `false`.
         */
        alwaysOn?: boolean;
        /**
         * The name of the slot to automatically swap to during deployment
         */
        autoSwapSlotName?: string;
        /**
         * A `cors` block as defined below.
         */
        cors: outputs.appservice.FunctionAppSlotSiteConfigCors;
        /**
         * State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`.
         */
        ftpsState: string;
        healthCheckPath?: string;
        /**
         * Specifies whether or not the http2 protocol should be enabled. Defaults to `false`.
         */
        http2Enabled?: boolean;
        /**
         * A [List of objects](https://www.terraform.io/docs/configuration/attr-as-blocks.html) representing ip restrictions as defined below.
         */
        ipRestrictions: outputs.appservice.FunctionAppSlotSiteConfigIpRestriction[];
        javaVersion?: string;
        /**
         * Linux App Framework and version for the AppService, e.g. `DOCKER|(golang:latest)`.
         */
        linuxFxVersion: string;
        /**
         * The minimum supported TLS version for the function app. Possible values are `1.0`, `1.1`, and `1.2`. Defaults to `1.2` for new function apps.
         */
        minTlsVersion: string;
        /**
         * The number of pre-warmed instances for this function app. Only affects apps on the Premium plan.
         */
        preWarmedInstanceCount: number;
        scmIpRestrictions: outputs.appservice.FunctionAppSlotSiteConfigScmIpRestriction[];
        scmType: string;
        scmUseMainIpRestriction?: boolean;
        /**
         * Should the Function App run in 32 bit mode, rather than 64 bit mode? Defaults to `true`.
         */
        use32BitWorkerProcess?: boolean;
        /**
         * Should WebSockets be enabled?
         */
        websocketsEnabled?: boolean;
    }

    export interface FunctionAppSlotSiteConfigCors {
        /**
         * A list of origins which should be able to make cross-origin calls. `*` can be used to allow all calls.
         */
        allowedOrigins: string[];
        /**
         * Are credentials supported?
         */
        supportCredentials?: boolean;
    }

    export interface FunctionAppSlotSiteConfigIpRestriction {
        /**
         * Does this restriction `Allow` or `Deny` access for this IP range. Defaults to `Allow`.
         */
        action?: string;
        /**
         * The headers for this specific `ipRestriction` as defined below.
         */
        headers: outputs.appservice.FunctionAppSlotSiteConfigIpRestrictionHeaders;
        /**
         * The IP Address used for this IP Restriction in CIDR notation.
         */
        ipAddress?: string;
        /**
         * The name for this IP Restriction.
         */
        name: string;
        /**
         * The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
         */
        priority?: number;
        /**
         * The Service Tag used for this IP Restriction.
         */
        serviceTag?: string;
        /**
         * The Virtual Network Subnet ID used for this IP Restriction.
         */
        virtualNetworkSubnetId?: string;
    }

    export interface FunctionAppSlotSiteConfigIpRestrictionHeaders {
        /**
         * A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
         */
        xAzureFdids?: string[];
        /**
         * A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
         */
        xFdHealthProbe?: string;
        /**
         * A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
         */
        xForwardedFors?: string[];
        /**
         * A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
         */
        xForwardedHosts?: string[];
    }

    export interface FunctionAppSlotSiteConfigScmIpRestriction {
        /**
         * Does this restriction `Allow` or `Deny` access for this IP range. Defaults to `Allow`.
         */
        action?: string;
        /**
         * The headers for this specific `ipRestriction` as defined below.
         */
        headers: outputs.appservice.FunctionAppSlotSiteConfigScmIpRestrictionHeaders;
        /**
         * The IP Address used for this IP Restriction in CIDR notation.
         */
        ipAddress?: string;
        /**
         * Specifies the name of the Function App. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
         */
        priority?: number;
        /**
         * The Service Tag used for this IP Restriction.
         */
        serviceTag?: string;
        /**
         * The Virtual Network Subnet ID used for this IP Restriction.
         */
        virtualNetworkSubnetId?: string;
    }

    export interface FunctionAppSlotSiteConfigScmIpRestrictionHeaders {
        /**
         * A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
         */
        xAzureFdids?: string[];
        /**
         * A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
         */
        xFdHealthProbe?: string;
        /**
         * A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
         */
        xForwardedFors?: string[];
        /**
         * A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
         */
        xForwardedHosts?: string[];
    }

    export interface FunctionAppSlotSiteCredential {
        /**
         * The password associated with the username, which can be used to publish to this App Service.
         */
        password: string;
        /**
         * The username which can be used to publish to this App Service
         */
        username: string;
    }

    export interface FunctionAppSourceControl {
        /**
         * The branch of the remote repository to use. Defaults to 'master'.
         */
        branch: string;
        /**
         * Limits to manual integration. Defaults to `false` if not specified.
         */
        manualIntegration: boolean;
        /**
         * The URL of the source code repository.
         */
        repoUrl: string;
        /**
         * Enable roll-back for the repository. Defaults to `false` if not specified.
         */
        rollbackEnabled: boolean;
        /**
         * Use Mercurial if `true`, otherwise uses Git.
         */
        useMercurial: boolean;
    }

    export interface GetAppServiceConnectionString {
        /**
         * The name of the App Service.
         */
        name: string;
        /**
         * The type of the Connection String.
         */
        type: string;
        /**
         * The value for the Connection String.
         */
        value: string;
    }

    export interface GetAppServiceEnvironmentClusterSetting {
        /**
         * The name of this App Service Environment.
         */
        name: string;
        /**
         * The value for the Cluster Setting.
         */
        value: string;
    }

    export interface GetAppServicePlanSku {
        /**
         * Specifies the number of workers associated with this App Service Plan.
         */
        capacity: number;
        /**
         * Specifies the plan's instance size.
         */
        size: string;
        /**
         * Specifies the plan's pricing tier.
         */
        tier: string;
    }

    export interface GetAppServiceSiteConfig {
        /**
         * Is the app loaded at all times?
         */
        alwaysOn: boolean;
        /**
         * App command line to launch.
         */
        appCommandLine: string;
        /**
         * A `cors` block as defined above.
         */
        cors: outputs.appservice.GetAppServiceSiteConfigCor[];
        /**
         * The ordering of default documents to load, if an address isn't specified.
         */
        defaultDocuments: string[];
        /**
         * The version of the .net framework's CLR used in this App Service.
         */
        dotnetFrameworkVersion: string;
        /**
         * State of FTP / FTPS service for this AppService.
         */
        ftpsState: string;
        /**
         * The health check path to be pinged by App Service.
         */
        healthCheckPath: string;
        /**
         * Is HTTP2 Enabled on this App Service?
         */
        http2Enabled: boolean;
        /**
         * One or more `ipRestriction` blocks as defined above.
         */
        ipRestrictions: outputs.appservice.GetAppServiceSiteConfigIpRestriction[];
        /**
         * The Java Container in use.
         */
        javaContainer: string;
        /**
         * The version of the Java Container in use.
         */
        javaContainerVersion: string;
        /**
         * The version of Java in use.
         */
        javaVersion: string;
        /**
         * Linux App Framework and version for the AppService.
         */
        linuxFxVersion: string;
        /**
         * Is "MySQL In App" Enabled? This runs a local MySQL instance with your app and shares resources from the App Service plan.
         */
        localMysqlEnabled: boolean;
        /**
         * The Managed Pipeline Mode used in this App Service.
         */
        managedPipelineMode: string;
        /**
         * The minimum supported TLS version for this App Service.
         */
        minTlsVersion: string;
        /**
         * The scaled number of workers (for per site scaling) of this App Service.
         */
        numberOfWorkers: number;
        /**
         * The version of PHP used in this App Service.
         */
        phpVersion: string;
        /**
         * The version of Python used in this App Service.
         */
        pythonVersion: string;
        /**
         * Is Remote Debugging Enabled in this App Service?
         */
        remoteDebuggingEnabled: boolean;
        /**
         * Which version of Visual Studio is the Remote Debugger compatible with?
         */
        remoteDebuggingVersion: string;
        /**
         * One or more `scmIpRestriction` blocks as defined above.
         */
        scmIpRestrictions: outputs.appservice.GetAppServiceSiteConfigScmIpRestriction[];
        /**
         * The type of Source Control enabled for this App Service.
         */
        scmType: string;
        /**
         * IP security restrictions for scm to use main.
         */
        scmUseMainIpRestriction: boolean;
        /**
         * Does the App Service run in 32 bit mode, rather than 64 bit mode?
         */
        use32BitWorkerProcess: boolean;
        /**
         * Are WebSockets enabled for this App Service?
         */
        websocketsEnabled: boolean;
        /**
         * Windows Container Docker Image for the AppService.
         */
        windowsFxVersion: string;
    }

    export interface GetAppServiceSiteConfigCor {
        /**
         * A list of origins which are able to make cross-origin calls.
         */
        allowedOrigins: string[];
        /**
         * Are credentials supported?
         */
        supportCredentials: boolean;
    }

    export interface GetAppServiceSiteConfigIpRestriction {
        /**
         * Allow or Deny access for this IP range. Defaults to Allow.
         */
        action: string;
        headers: outputs.appservice.GetAppServiceSiteConfigIpRestrictionHeaders;
        /**
         * The IP Address used for this IP Restriction in CIDR notation.
         */
        ipAddress: string;
        /**
         * The name of the App Service.
         */
        name: string;
        /**
         * The priority for this IP Restriction.
         */
        priority: number;
        /**
         * The Service Tag used for this IP Restriction.
         */
        serviceTag: string;
        /**
         * The Virtual Network Subnet ID used for this IP Restriction.
         */
        virtualNetworkSubnetId: string;
    }

    export interface GetAppServiceSiteConfigIpRestrictionHeaders {
        xAzureFdids: string[];
        xFdHealthProbes: string[];
        xForwardedFors: string[];
        xForwardedHosts: string[];
    }

    export interface GetAppServiceSiteConfigScmIpRestriction {
        /**
         * Allow or Deny access for this IP range. Defaults to Allow.
         */
        action: string;
        headers: outputs.appservice.GetAppServiceSiteConfigScmIpRestrictionHeaders;
        /**
         * The IP Address used for this IP Restriction in CIDR notation.
         */
        ipAddress: string;
        /**
         * The name of the App Service.
         */
        name: string;
        /**
         * The priority for this IP Restriction.
         */
        priority: number;
        /**
         * The Service Tag used for this IP Restriction.
         */
        serviceTag: string;
        /**
         * The Virtual Network Subnet ID used for this IP Restriction.
         */
        virtualNetworkSubnetId: string;
    }

    export interface GetAppServiceSiteConfigScmIpRestrictionHeaders {
        xAzureFdids: string[];
        xFdHealthProbes: string[];
        xForwardedFors: string[];
        xForwardedHosts: string[];
    }

    export interface GetAppServiceSiteCredential {
        password: string;
        username: string;
    }

    export interface GetAppServiceSourceControl {
        /**
         * The branch of the remote repository in use.
         */
        branch: string;
        /**
         * Limits to manual integration.
         */
        manualIntegration: boolean;
        /**
         * The URL of the source code repository.
         */
        repoUrl: string;
        /**
         * Is roll-back enabled for the repository.
         */
        rollbackEnabled: boolean;
        /**
         * Uses Mercurial if `true`, otherwise uses Git.
         */
        useMercurial: boolean;
    }

    export interface GetCertificateOrderCertificate {
        /**
         * The name of the App Service Certificate.
         */
        certificateName: string;
        /**
         * Key Vault resource Id.
         */
        keyVaultId: string;
        /**
         * Key Vault secret name.
         */
        keyVaultSecretName: string;
        /**
         * Status of the Key Vault secret.
         */
        provisioningState: string;
    }

    export interface GetEnvironmentV3ClusterSetting {
        /**
         * The name of this v3 App Service Environment.
         */
        name: string;
        /**
         * The value for the Cluster Setting.
         */
        value: string;
    }

    export interface GetFunctionAppConnectionString {
        /**
         * The name of the Function App resource.
         */
        name: string;
        /**
         * The identity type of the Managed Identity assigned to the function app.
         */
        type: string;
        /**
         * The value for the Connection String.
         */
        value: string;
    }

    export interface GetFunctionAppIdentity {
        /**
         * The ID of the System Managed Service Principal assigned to the function app.
         */
        principalId: string;
        /**
         * The ID of the Tenant of the System Managed Service Principal assigned to the function app.
         */
        tenantId: string;
        /**
         * The identity type of the Managed Identity assigned to the function app.
         */
        type: string;
    }

    export interface GetFunctionAppSiteConfig {
        /**
         * Is the app loaded at all times?
         */
        alwaysOn: boolean;
        autoSwapSlotName: string;
        /**
         * A `cors` block as defined above.
         */
        cors: outputs.appservice.GetFunctionAppSiteConfigCors;
        /**
         * State of FTP / FTPS service for this AppService.
         */
        ftpsState: string;
        healthCheckPath: string;
        /**
         * Is HTTP2 Enabled on this App Service?
         */
        http2Enabled: boolean;
        /**
         * One or more `ipRestriction` blocks as defined above.
         */
        ipRestrictions: outputs.appservice.GetFunctionAppSiteConfigIpRestriction[];
        /**
         * Java version hosted by the function app in Azure.
         */
        javaVersion: string;
        /**
         * Linux App Framework and version for the AppService.
         */
        linuxFxVersion: string;
        /**
         * The minimum supported TLS version for this App Service.
         */
        minTlsVersion: string;
        /**
         * The number of pre-warmed instances for this function app. Only applicable to apps on the Premium plan.
         */
        preWarmedInstanceCount: number;
        /**
         * One or more `scmIpRestriction` blocks as defined above.
         */
        scmIpRestrictions: outputs.appservice.GetFunctionAppSiteConfigScmIpRestriction[];
        /**
         * The type of Source Control enabled for this App Service.
         */
        scmType: string;
        /**
         * IP security restrictions for scm to use main.
         */
        scmUseMainIpRestriction: boolean;
        /**
         * Does the App Service run in 32 bit mode, rather than 64 bit mode?
         */
        use32BitWorkerProcess: boolean;
        /**
         * Are WebSockets enabled for this App Service?
         */
        websocketsEnabled: boolean;
    }

    export interface GetFunctionAppSiteConfigCors {
        allowedOrigins: string[];
        supportCredentials?: boolean;
    }

    export interface GetFunctionAppSiteConfigIpRestriction {
        /**
         * Allow or Deny access for this IP range. Defaults to Allow.
         */
        action: string;
        headers: outputs.appservice.GetFunctionAppSiteConfigIpRestrictionHeaders;
        /**
         * The IP Address used for this IP Restriction in CIDR notation.
         */
        ipAddress: string;
        /**
         * The name of the Function App resource.
         */
        name: string;
        /**
         * The priority for this IP Restriction.
         */
        priority: number;
        /**
         * The Service Tag used for this IP Restriction.
         */
        serviceTag: string;
        /**
         * The Virtual Network Subnet ID used for this IP Restriction.
         */
        virtualNetworkSubnetId: string;
    }

    export interface GetFunctionAppSiteConfigIpRestrictionHeaders {
        xAzureFdids: string[];
        xFdHealthProbes: string[];
        xForwardedFors: string[];
        xForwardedHosts: string[];
    }

    export interface GetFunctionAppSiteConfigScmIpRestriction {
        /**
         * Allow or Deny access for this IP range. Defaults to Allow.
         */
        action: string;
        headers: outputs.appservice.GetFunctionAppSiteConfigScmIpRestrictionHeaders;
        /**
         * The IP Address used for this IP Restriction in CIDR notation.
         */
        ipAddress: string;
        /**
         * The name of the Function App resource.
         */
        name: string;
        /**
         * The priority for this IP Restriction.
         */
        priority: number;
        /**
         * The Service Tag used for this IP Restriction.
         */
        serviceTag: string;
        /**
         * The Virtual Network Subnet ID used for this IP Restriction.
         */
        virtualNetworkSubnetId: string;
    }

    export interface GetFunctionAppSiteConfigScmIpRestrictionHeaders {
        xAzureFdids: string[];
        xFdHealthProbes: string[];
        xForwardedFors: string[];
        xForwardedHosts: string[];
    }

    export interface GetFunctionAppSiteCredential {
        /**
         * The password associated with the username, which can be used to publish to this App Service.
         */
        password: string;
        /**
         * The username which can be used to publish to this App Service
         */
        username: string;
    }

    export interface GetFunctionAppSourceControl {
        /**
         * The branch of the remote repository in use.
         */
        branch: string;
        /**
         * Limits to manual integration.
         */
        manualIntegration: boolean;
        /**
         * The URL of the source code repository.
         */
        repoUrl: string;
        /**
         * Is roll-back enabled for the repository.
         */
        rollbackEnabled: boolean;
        /**
         * Uses Mercurial if `true`, otherwise uses Git.
         */
        useMercurial: boolean;
    }

    export interface PlanSku {
        /**
         * Specifies the number of workers associated with this App Service Plan.
         */
        capacity: number;
        /**
         * Specifies the plan's instance size.
         */
        size: string;
        /**
         * Specifies the plan's pricing tier.
         */
        tier: string;
    }

    export interface SlotAuthSettings {
        /**
         * A `activeDirectory` block as defined below.
         */
        activeDirectory?: outputs.appservice.SlotAuthSettingsActiveDirectory;
        /**
         * Login parameters to send to the OpenID Connect authorization endpoint when a user logs in. Each parameter must be in the form "key=value".
         */
        additionalLoginParams?: {[key: string]: string};
        /**
         * External URLs that can be redirected to as part of logging in or logging out of the app.
         */
        allowedExternalRedirectUrls?: string[];
        /**
         * The default provider to use when multiple providers have been set up. Possible values are `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount` and `Twitter`.
         */
        defaultProvider?: string;
        /**
         * Is Authentication enabled?
         */
        enabled: boolean;
        /**
         * A `facebook` block as defined below.
         */
        facebook?: outputs.appservice.SlotAuthSettingsFacebook;
        /**
         * A `google` block as defined below.
         */
        google?: outputs.appservice.SlotAuthSettingsGoogle;
        /**
         * Issuer URI. When using Azure Active Directory, this value is the URI of the directory tenant, e.g. https://sts.windows.net/{tenant-guid}/.
         */
        issuer?: string;
        /**
         * A `microsoft` block as defined below.
         */
        microsoft?: outputs.appservice.SlotAuthSettingsMicrosoft;
        /**
         * The runtime version of the Authentication/Authorization module.
         */
        runtimeVersion?: string;
        /**
         * The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to 72.
         */
        tokenRefreshExtensionHours?: number;
        /**
         * If enabled the module will durably store platform-specific security tokens that are obtained during login flows. Defaults to false.
         */
        tokenStoreEnabled?: boolean;
        /**
         * A `twitter` block as defined below.
         */
        twitter?: outputs.appservice.SlotAuthSettingsTwitter;
        /**
         * The action to take when an unauthenticated client attempts to access the app. Possible values are `AllowAnonymous` and `RedirectToLoginPage`.
         */
        unauthenticatedClientAction?: string;
    }

    export interface SlotAuthSettingsActiveDirectory {
        /**
         * Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
         */
        allowedAudiences?: string[];
        /**
         * The Client ID of this relying party application. Enables OpenIDConnection authentication with Azure Active Directory.
         */
        clientId: string;
        /**
         * The Client Secret of this relying party application. If no secret is provided, implicit flow will be used.
         */
        clientSecret?: string;
    }

    export interface SlotAuthSettingsFacebook {
        /**
         * The App ID of the Facebook app used for login
         */
        appId: string;
        /**
         * The App Secret of the Facebook app used for Facebook Login.
         */
        appSecret: string;
        /**
         * The OAuth 2.0 scopes that will be requested as part of Facebook Login authentication. https://developers.facebook.com/docs/facebook-login
         */
        oauthScopes?: string[];
    }

    export interface SlotAuthSettingsGoogle {
        /**
         * The OpenID Connect Client ID for the Google web application.
         */
        clientId: string;
        /**
         * The client secret associated with the Google web application.
         */
        clientSecret: string;
        /**
         * The OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. https://developers.google.com/identity/sign-in/web/
         */
        oauthScopes?: string[];
    }

    export interface SlotAuthSettingsMicrosoft {
        /**
         * The OAuth 2.0 client ID that was created for the app used for authentication.
         */
        clientId: string;
        /**
         * The OAuth 2.0 client secret that was created for the app used for authentication.
         */
        clientSecret: string;
        /**
         * The OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. https://msdn.microsoft.com/en-us/library/dn631845.aspx
         */
        oauthScopes?: string[];
    }

    export interface SlotAuthSettingsTwitter {
        consumerKey: string;
        consumerSecret: string;
    }

    export interface SlotConnectionString {
        /**
         * The name of the Connection String.
         */
        name: string;
        /**
         * The type of the Connection String. Possible values are `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and  `SQLServer`.
         */
        type: string;
        /**
         * The value for the Connection String.
         */
        value: string;
    }

    export interface SlotIdentity {
        /**
         * Specifies a list of user managed identity ids to be assigned. Required if `type` is `UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID for the Service Principal associated with the Managed Service Identity of this App Service slot.
         */
        principalId: string;
        /**
         * The Tenant ID for the Service Principal associated with the Managed Service Identity of this App Service slot.
         */
        tenantId: string;
        /**
         * Specifies the identity type of the App Service. Possible values are `SystemAssigned` (where Azure will generate a Service Principal for you), `UserAssigned` where you can specify the Service Principal IDs in the `identityIds` field, and `SystemAssigned, UserAssigned` which assigns both a system managed identity as well as the specified user assigned identities.
         */
        type: string;
    }

    export interface SlotLogs {
        /**
         * An `applicationLogs` block as defined below.
         */
        applicationLogs: outputs.appservice.SlotLogsApplicationLogs;
        /**
         * Should `Detailed error messages` be enabled on this App Service slot? Defaults to `false`.
         */
        detailedErrorMessagesEnabled?: boolean;
        /**
         * Should `Failed request tracing` be enabled on this App Service slot? Defaults to `false`.
         */
        failedRequestTracingEnabled?: boolean;
        /**
         * An `httpLogs` block as defined below.
         */
        httpLogs: outputs.appservice.SlotLogsHttpLogs;
    }

    export interface SlotLogsApplicationLogs {
        /**
         * An `azureBlobStorage` block as defined below.
         */
        azureBlobStorage?: outputs.appservice.SlotLogsApplicationLogsAzureBlobStorage;
        /**
         * The file system log level. Possible values are `Off`, `Error`, `Warning`, `Information`, and `Verbose`.
         */
        fileSystemLevel?: string;
    }

    export interface SlotLogsApplicationLogsAzureBlobStorage {
        /**
         * The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `httpLogs`
         */
        level: string;
        /**
         * The number of days to retain logs for.
         */
        retentionInDays: number;
        /**
         * The URL to the storage container, with a Service SAS token appended. **NOTE:** there is currently no means of generating Service SAS tokens with the `azurerm` provider.
         */
        sasUrl: string;
    }

    export interface SlotLogsHttpLogs {
        /**
         * An `azureBlobStorage` block as defined below.
         */
        azureBlobStorage?: outputs.appservice.SlotLogsHttpLogsAzureBlobStorage;
        /**
         * A `fileSystem` block as defined below.
         */
        fileSystem?: outputs.appservice.SlotLogsHttpLogsFileSystem;
    }

    export interface SlotLogsHttpLogsAzureBlobStorage {
        /**
         * The number of days to retain logs for.
         */
        retentionInDays: number;
        /**
         * The URL to the storage container, with a Service SAS token appended. **NOTE:** there is currently no means of generating Service SAS tokens with the `azurerm` provider.
         */
        sasUrl: string;
    }

    export interface SlotLogsHttpLogsFileSystem {
        /**
         * The number of days to retain logs for.
         */
        retentionInDays: number;
        /**
         * The maximum size in megabytes that http log files can use before being removed.
         */
        retentionInMb: number;
    }

    export interface SlotSiteConfig {
        /**
         * Should the app be loaded at all times? Defaults to `false`.
         */
        alwaysOn?: boolean;
        /**
         * App command line to launch, e.g. `/sbin/myserver -b 0.0.0.0`.
         */
        appCommandLine?: string;
        /**
         * The name of the slot to automatically swap to during deployment
         */
        autoSwapSlotName?: string;
        /**
         * A `cors` block as defined below.
         */
        cors: outputs.appservice.SlotSiteConfigCors;
        /**
         * The ordering of default documents to load, if an address isn't specified.
         */
        defaultDocuments?: string[];
        /**
         * The version of the .net framework's CLR used in this App Service Slot. Possible values are `v2.0` (which will use the latest version of the .net framework for the .net CLR v2 - currently `.net 3.5`) and `v4.0` (which corresponds to the latest version of the .net CLR v4 - which at the time of writing is `.net 4.7.1`). [For more information on which .net CLR version to use based on the .net framework you're targeting - please see this table](https://en.wikipedia.org/wiki/.NET_Framework_version_history#Overview). Defaults to `v4.0`.
         */
        dotnetFrameworkVersion?: string;
        ftpsState: string;
        healthCheckPath?: string;
        /**
         * Is HTTP2 Enabled on this App Service? Defaults to `false`.
         */
        http2Enabled?: boolean;
        /**
         * A list of objects representing ip restrictions as defined below.
         */
        ipRestrictions: outputs.appservice.SlotSiteConfigIpRestriction[];
        /**
         * The Java Container to use. If specified `javaVersion` and `javaContainerVersion` must also be specified. Possible values are `JETTY` and `TOMCAT`.
         */
        javaContainer?: string;
        /**
         * The version of the Java Container to use. If specified `javaVersion` and `javaContainer` must also be specified.
         */
        javaContainerVersion?: string;
        /**
         * The version of Java to use. If specified `javaContainer` and `javaContainerVersion` must also be specified. Possible values are `1.7`, `1.8`, and `11` and their specific versions - except for Java 11 (e.g. `1.7.0_80`, `1.8.0_181`, `11`)
         */
        javaVersion?: string;
        linuxFxVersion: string;
        /**
         * Is "MySQL In App" Enabled? This runs a local MySQL instance with your app and shares resources from the App Service plan.
         */
        localMysqlEnabled: boolean;
        /**
         * The Managed Pipeline Mode. Possible values are `Integrated` and `Classic`. Defaults to `Integrated`.
         */
        managedPipelineMode: string;
        /**
         * The minimum supported TLS version for the app service. Possible values are `1.0`, `1.1`, and `1.2`. Defaults to `1.2` for new app services.
         */
        minTlsVersion: string;
        numberOfWorkers: number;
        /**
         * The version of PHP to use in this App Service Slot. Possible values are `5.5`, `5.6`, `7.0`, `7.1`, `7.2`, and `7.3`.
         */
        phpVersion?: string;
        /**
         * The version of Python to use in this App Service Slot. Possible values are `2.7` and `3.4`.
         */
        pythonVersion?: string;
        /**
         * Is Remote Debugging Enabled? Defaults to `false`.
         */
        remoteDebuggingEnabled?: boolean;
        /**
         * Which version of Visual Studio should the Remote Debugger be compatible with? Possible values are `VS2012`, `VS2013`, `VS2015`, and `VS2017`.
         */
        remoteDebuggingVersion: string;
        scmIpRestrictions: outputs.appservice.SlotSiteConfigScmIpRestriction[];
        /**
         * The type of Source Control enabled for this App Service Slot. Defaults to `None`. Possible values are: `BitbucketGit`, `BitbucketHg`, `CodePlexGit`, `CodePlexHg`, `Dropbox`, `ExternalGit`, `ExternalHg`, `GitHub`, `LocalGit`, `None`, `OneDrive`, `Tfs`, `VSO`, and `VSTSRM`
         */
        scmType: string;
        scmUseMainIpRestriction?: boolean;
        /**
         * Should the App Service Slot run in 32 bit mode, rather than 64 bit mode?
         */
        use32BitWorkerProcess?: boolean;
        /**
         * Should WebSockets be enabled?
         */
        websocketsEnabled: boolean;
        windowsFxVersion: string;
    }

    export interface SlotSiteConfigCors {
        /**
         * A list of origins which should be able to make cross-origin calls. `*` can be used to allow all calls.
         */
        allowedOrigins: string[];
        /**
         * Are credentials supported?
         */
        supportCredentials?: boolean;
    }

    export interface SlotSiteConfigIpRestriction {
        /**
         * Does this restriction `Allow` or `Deny` access for this IP range. Defaults to `Allow`.
         */
        action?: string;
        /**
         * The headers for this specific `ipRestriction` as defined below. The http header filters are evaluated after the rule itself and both conditions must be true for the rule to apply.
         */
        headers: outputs.appservice.SlotSiteConfigIpRestrictionHeaders;
        /**
         * The IP Address used for this IP Restriction in CIDR notation.
         */
        ipAddress?: string;
        /**
         * The name for this IP Restriction.
         */
        name: string;
        /**
         * The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
         */
        priority?: number;
        /**
         * The Service Tag used for this IP Restriction.
         */
        serviceTag?: string;
        /**
         * The Virtual Network Subnet ID used for this IP Restriction.
         */
        virtualNetworkSubnetId?: string;
    }

    export interface SlotSiteConfigIpRestrictionHeaders {
        /**
         * A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
         */
        xAzureFdids?: string[];
        /**
         * A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
         */
        xFdHealthProbe?: string;
        /**
         * A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
         */
        xForwardedFors?: string[];
        /**
         * A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
         */
        xForwardedHosts?: string[];
    }

    export interface SlotSiteConfigScmIpRestriction {
        /**
         * Does this restriction `Allow` or `Deny` access for this IP range. Defaults to `Allow`.
         */
        action?: string;
        /**
         * The headers for this specific `ipRestriction` as defined below. The http header filters are evaluated after the rule itself and both conditions must be true for the rule to apply.
         */
        headers: outputs.appservice.SlotSiteConfigScmIpRestrictionHeaders;
        /**
         * The IP Address used for this IP Restriction in CIDR notation.
         */
        ipAddress?: string;
        /**
         * Specifies the name of the App Service Slot component. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
         */
        priority?: number;
        /**
         * The Service Tag used for this IP Restriction.
         */
        serviceTag?: string;
        /**
         * The Virtual Network Subnet ID used for this IP Restriction.
         */
        virtualNetworkSubnetId?: string;
    }

    export interface SlotSiteConfigScmIpRestrictionHeaders {
        /**
         * A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
         */
        xAzureFdids?: string[];
        /**
         * A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
         */
        xFdHealthProbe?: string;
        /**
         * A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
         */
        xForwardedFors?: string[];
        /**
         * A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
         */
        xForwardedHosts?: string[];
    }

    export interface SlotSiteCredential {
        /**
         * The password associated with the username, which can be used to publish to this App Service.
         */
        password: string;
        /**
         * The username which can be used to publish to this App Service
         */
        username: string;
    }
}

export namespace authorization {
    export interface GetRoleDefinitionPermission {
        /**
         * a list of actions supported by this role
         */
        actions: string[];
        dataActions?: string[];
        /**
         * a list of actions which are denied by this role
         */
        notActions: string[];
        notDataActions?: string[];
    }

    export interface RoleDefinitionPermission {
        /**
         * One or more Allowed Actions, such as `*`, `Microsoft.Resources/subscriptions/resourceGroups/read`. See ['Azure Resource Manager resource provider operations'](https://docs.microsoft.com/en-us/azure/role-based-access-control/resource-provider-operations) for details.
         */
        actions?: string[];
        /**
         * One or more Allowed Data Actions, such as `*`, `Microsoft.Storage/storageAccounts/blobServices/containers/blobs/read`. See ['Azure Resource Manager resource provider operations'](https://docs.microsoft.com/en-us/azure/role-based-access-control/resource-provider-operations) for details.
         */
        dataActions?: string[];
        /**
         * One or more Disallowed Actions, such as `*`, `Microsoft.Resources/subscriptions/resourceGroups/read`. See ['Azure Resource Manager resource provider operations'](https://docs.microsoft.com/en-us/azure/role-based-access-control/resource-provider-operations) for details.
         */
        notActions?: string[];
        /**
         * One or more Disallowed Data Actions, such as `*`, `Microsoft.Resources/subscriptions/resourceGroups/read`. See ['Azure Resource Manager resource provider operations'](https://docs.microsoft.com/en-us/azure/role-based-access-control/resource-provider-operations) for details.
         */
        notDataActions?: string[];
    }

}

export namespace automation {
    export interface ModuleModuleLink {
        hash?: outputs.automation.ModuleModuleLinkHash;
        /**
         * The uri of the module content (zip or nupkg).
         */
        uri: string;
    }

    export interface ModuleModuleLinkHash {
        algorithm: string;
        value: string;
    }

    export interface RunBookJobSchedule {
        jobScheduleId: string;
        parameters?: {[key: string]: string};
        runOn?: string;
        scheduleName: string;
    }

    export interface RunBookPublishContentLink {
        hash?: outputs.automation.RunBookPublishContentLinkHash;
        /**
         * The uri of the runbook content.
         */
        uri: string;
        version?: string;
    }

    export interface RunBookPublishContentLinkHash {
        algorithm: string;
        value: string;
    }

    export interface ScheduleMonthlyOccurrence {
        /**
         * Day of the occurrence. Must be one of `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday`, `Sunday`.
         */
        day: string;
        /**
         * Occurrence of the week within the month. Must be between `1` and `5`. `-1` for last week within the month.
         */
        occurrence: number;
    }

}

export namespace avs {
    export interface GetPrivateCloudCircuit {
        /**
         * The ID of the ExpressRoute Circuit.
         */
        expressRouteId: string;
        /**
         * The ID of the ExpressRoute Circuit private peering.
         */
        expressRoutePrivatePeeringId: string;
        /**
         * The CIDR of the primary subnet.
         */
        primarySubnetCidr: string;
        /**
         * The CIDR of the secondary subnet.
         */
        secondarySubnetCidr: string;
    }

    export interface GetPrivateCloudManagementCluster {
        /**
         * The list of the hosts in the management cluster.
         */
        hosts: string[];
        /**
         * The ID of the management cluster.
         */
        id: number;
        /**
         * The size of the management cluster.
         */
        size: number;
    }

    export interface PrivateCloudCircuit {
        /**
         * The ID of the ExpressRoute Circuit.
         */
        expressRouteId: string;
        /**
         * The ID of the ExpressRoute Circuit private peering.
         */
        expressRoutePrivatePeeringId: string;
        /**
         * The CIDR of the primary subnet.
         */
        primarySubnetCidr: string;
        /**
         * The CIDR of the secondary subnet.
         */
        secondarySubnetCidr: string;
    }

    export interface PrivateCloudManagementCluster {
        /**
         * A list of hosts in the management cluster.
         */
        hosts: string[];
        /**
         * The ID of the  management cluster.
         */
        id: number;
        /**
         * The size of the management cluster. This field can not updated with `internetConnectionEnabled` together.
         */
        size: number;
    }

}

export namespace backup {
    export interface PolicyFileShareBackup {
        /**
         * Sets the backup frequency. Currently, only `Daily` is supported
         */
        frequency: string;
        /**
         * The time of day to perform the backup in 24-hour format. Times must be either on the hour or half hour (e.g. 12:00, 12:30, 13:00, etc.)
         */
        time: string;
    }

    export interface PolicyFileShareRetentionDaily {
        /**
         * The number of yearly backups to keep. Must be between `1` and `10`
         */
        count: number;
    }

    export interface PolicyFileShareRetentionMonthly {
        /**
         * The number of yearly backups to keep. Must be between `1` and `10`
         */
        count: number;
        /**
         * The weekday backups to retain . Must be one of `Sunday`, `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday` or `Saturday`.
         */
        weekdays: string[];
        /**
         * The weeks of the month to retain backups of. Must be one of `First`, `Second`, `Third`, `Fourth`, `Last`.
         */
        weeks: string[];
    }

    export interface PolicyFileShareRetentionWeekly {
        /**
         * The number of yearly backups to keep. Must be between `1` and `10`
         */
        count: number;
        /**
         * The weekday backups to retain . Must be one of `Sunday`, `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday` or `Saturday`.
         */
        weekdays: string[];
    }

    export interface PolicyFileShareRetentionYearly {
        /**
         * The number of yearly backups to keep. Must be between `1` and `10`
         */
        count: number;
        /**
         * The months of the year to retain backups of. Must be one of `January`, `February`, `March`, `April`, `May`, `June`, `July`, `Augest`, `September`, `October`, `November` and `December`.
         */
        months: string[];
        /**
         * The weekday backups to retain . Must be one of `Sunday`, `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday` or `Saturday`.
         */
        weekdays: string[];
        /**
         * The weeks of the month to retain backups of. Must be one of `First`, `Second`, `Third`, `Fourth`, `Last`.
         */
        weeks: string[];
    }

    export interface PolicyVMBackup {
        /**
         * Sets the backup frequency. Must be either `Daily` or`Weekly`.
         */
        frequency: string;
        /**
         * The time of day to perform the backup in 24hour format.
         */
        time: string;
        /**
         * The weekday backups to retain . Must be one of `Sunday`, `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday` or `Saturday`.
         */
        weekdays?: string[];
    }

    export interface PolicyVMRetentionDaily {
        /**
         * The number of yearly backups to keep. Must be between `1` and `9999`
         */
        count: number;
    }

    export interface PolicyVMRetentionMonthly {
        /**
         * The number of yearly backups to keep. Must be between `1` and `9999`
         */
        count: number;
        /**
         * The weekday backups to retain . Must be one of `Sunday`, `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday` or `Saturday`.
         */
        weekdays: string[];
        /**
         * The weeks of the month to retain backups of. Must be one of `First`, `Second`, `Third`, `Fourth`, `Last`.
         */
        weeks: string[];
    }

    export interface PolicyVMRetentionWeekly {
        /**
         * The number of yearly backups to keep. Must be between `1` and `9999`
         */
        count: number;
        /**
         * The weekday backups to retain . Must be one of `Sunday`, `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday` or `Saturday`.
         */
        weekdays: string[];
    }

    export interface PolicyVMRetentionYearly {
        /**
         * The number of yearly backups to keep. Must be between `1` and `9999`
         */
        count: number;
        /**
         * The months of the year to retain backups of. Must be one of `January`, `February`, `March`, `April`, `May`, `June`, `July`, `August`, `September`, `October`, `November` and `December`.
         */
        months: string[];
        /**
         * The weekday backups to retain . Must be one of `Sunday`, `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday` or `Saturday`.
         */
        weekdays: string[];
        /**
         * The weeks of the month to retain backups of. Must be one of `First`, `Second`, `Third`, `Fourth`, `Last`.
         */
        weeks: string[];
    }

}

export namespace batch {
    export interface AccountKeyVaultReference {
        /**
         * The Azure identifier of the Azure KeyVault to use.
         */
        id: string;
        /**
         * The HTTPS URL of the Azure KeyVault to use.
         */
        url: string;
    }

    export interface GetAccountKeyVaultReference {
        /**
         * The Azure identifier of the Azure KeyVault reference.
         */
        id: string;
        /**
         * The HTTPS URL of the Azure KeyVault reference.
         */
        url: string;
    }

    export interface GetPoolAutoScale {
        /**
         * The interval to wait before evaluating if the pool needs to be scaled.
         */
        evaluationInterval: string;
        /**
         * The autoscale formula that needs to be used for scaling the Batch pool.
         */
        formula: string;
    }

    export interface GetPoolCertificate {
        /**
         * The fully qualified ID of the certificate installed on the pool.
         */
        id: string;
        /**
         * The location of the certificate store on the compute node into which the certificate is installed, either `CurrentUser` or `LocalMachine`.
         */
        storeLocation: string;
        /**
         * The name of the certificate store on the compute node into which the certificate is installed.
         */
        storeName?: string;
        /**
         * Which user accounts on the compute node have access to the private data of the certificate.
         */
        visibilities?: string[];
    }

    export interface GetPoolContainerConfiguration {
        /**
         * A list of container image names to use, as would be specified by `docker pull`.
         */
        containerImageNames: string[];
        /**
         * Additional container registries from which container images can be pulled by the pool's VMs.
         */
        containerRegistries: outputs.batch.GetPoolContainerConfigurationContainerRegistry[];
        /**
         * The type of container configuration.
         */
        type: string;
    }

    export interface GetPoolContainerConfigurationContainerRegistry {
        /**
         * The password to log into the registry server.
         */
        password: string;
        /**
         * The container registry URL. The default is "docker.io".
         */
        registryServer: string;
        /**
         * The user name to log into the registry server.
         */
        userName: string;
    }

    export interface GetPoolFixedScale {
        /**
         * The timeout for resize operations.
         */
        resizeTimeout: string;
        /**
         * The number of nodes in the Batch pool.
         */
        targetDedicatedNodes: number;
        /**
         * The number of low priority nodes in the Batch pool.
         */
        targetLowPriorityNodes: number;
    }

    export interface GetPoolNetworkConfiguration {
        /**
         * The inbound NAT pools that are used to address specific ports on the individual compute node externally.
         */
        endpointConfiguration: outputs.batch.GetPoolNetworkConfigurationEndpointConfiguration;
        /**
         * The ARM resource identifier of the virtual network subnet which the compute nodes of the pool are joined too.
         */
        subnetId: string;
    }

    export interface GetPoolNetworkConfigurationEndpointConfiguration {
        /**
         * The port number on the compute node.
         */
        backendPort: number;
        /**
         * The range of external ports that are used to provide inbound access to the backendPort on the individual compute nodes in the format of `1000-1100`.
         */
        frontendPortRange: string;
        /**
         * The name of the endpoint.
         */
        name: string;
        /**
         * The list of network security group rules that are applied to the endpoint.
         */
        networkSecurityGroupRules: outputs.batch.GetPoolNetworkConfigurationEndpointConfigurationNetworkSecurityGroupRule[];
        /**
         * The protocol of the endpoint.
         */
        protocol: string;
    }

    export interface GetPoolNetworkConfigurationEndpointConfigurationNetworkSecurityGroupRule {
        /**
         * The action that should be taken for a specified IP address, subnet range or tag.
         */
        access: string;
        /**
         * The priority for this rule.
         */
        priority: number;
        /**
         * The source address prefix or tag to match for the rule.
         */
        sourceAddressPrefix: string;
    }

    export interface GetPoolStartTask {
        /**
         * The command line executed by the start task.
         */
        commandLine: string;
        /**
         * A map of strings (key,value) that represents the environment variables to set in the start task.
         */
        environment?: {[key: string]: string};
        /**
         * The number of retry count.
         */
        maxTaskRetryCount?: number;
        /**
         * One or more `resourceFile` blocks that describe the files to be downloaded to a compute node.
         */
        resourceFiles: outputs.batch.GetPoolStartTaskResourceFile[];
        /**
         * A `userIdentity` block that describes the user identity under which the start task runs.
         */
        userIdentities: outputs.batch.GetPoolStartTaskUserIdentity[];
        /**
         * A flag that indicates if the Batch pool should wait for the start task to be completed.
         */
        waitForSuccess?: boolean;
    }

    export interface GetPoolStartTaskResourceFile {
        /**
         * The storage container name in the auto storage account.
         */
        autoStorageContainerName: string;
        /**
         * The blob prefix used when downloading blobs from an Azure Storage container.
         */
        blobPrefix: string;
        /**
         * The file permission mode attribute represented as a string in octal format (e.g. `"0644"`).
         */
        fileMode: string;
        /**
         * The location on the compute node to which to download the file, relative to the task's working directory. If the `httpUrl` property is specified, the `filePath` is required and describes the path which the file will be downloaded to, including the filename. Otherwise, if the `autoStorageContainerName` or `storageContainerUrl` property is specified.
         */
        filePath: string;
        /**
         * The URL of the file to download. If the URL is Azure Blob Storage, it must be readable using anonymous access.
         */
        httpUrl: string;
        /**
         * The URL of the blob container within Azure Blob Storage.
         */
        storageContainerUrl: string;
    }

    export interface GetPoolStartTaskUserIdentity {
        /**
         * A `autoUser` block that describes the user identity under which the start task runs.
         */
        autoUsers: outputs.batch.GetPoolStartTaskUserIdentityAutoUser[];
        /**
         * The user name to log into the registry server.
         */
        userName: string;
    }

    export interface GetPoolStartTaskUserIdentityAutoUser {
        /**
         * The elevation level of the user identity under which the start task runs.
         */
        elevationLevel: string;
        /**
         * The scope of the user identity under which the start task runs.
         */
        scope: string;
    }

    export interface GetPoolStorageImageReference {
        /**
         * The fully qualified ID of the certificate installed on the pool.
         */
        id: string;
        offer: string;
        publisher: string;
        sku: string;
        version: string;
    }

    export interface PoolAutoScale {
        /**
         * The interval to wait before evaluating if the pool needs to be scaled. Defaults to `PT15M`.
         */
        evaluationInterval?: string;
        /**
         * The autoscale formula that needs to be used for scaling the Batch pool.
         */
        formula: string;
    }

    export interface PoolCertificate {
        /**
         * The ID of the Batch Certificate to install on the Batch Pool, which must be inside the same Batch Account.
         */
        id: string;
        /**
         * The location of the certificate store on the compute node into which to install the certificate. Possible values are `CurrentUser` or `LocalMachine`.
         */
        storeLocation: string;
        /**
         * The name of the certificate store on the compute node into which to install the certificate. This property is applicable only for pools configured with Windows nodes (that is, created with cloudServiceConfiguration, or with virtualMachineConfiguration using a Windows image reference). Common store names include: `My`, `Root`, `CA`, `Trust`, `Disallowed`, `TrustedPeople`, `TrustedPublisher`, `AuthRoot`, `AddressBook`, but any custom store name can also be used. The default value is `My`.
         */
        storeName?: string;
        /**
         * Which user accounts on the compute node should have access to the private data of the certificate.
         */
        visibilities?: string[];
    }

    export interface PoolContainerConfiguration {
        /**
         * A list of container image names to use, as would be specified by `docker pull`.
         */
        containerImageNames?: string[];
        /**
         * Additional container registries from which container images can be pulled by the pool's VMs.
         */
        containerRegistries?: outputs.batch.PoolContainerConfigurationContainerRegistry[];
        /**
         * The type of container configuration. Possible value is `DockerCompatible`.
         */
        type?: string;
    }

    export interface PoolContainerConfigurationContainerRegistry {
        /**
         * The password to log into the registry server. Changing this forces a new resource to be created.
         */
        password: string;
        /**
         * The container registry URL. The default is "docker.io". Changing this forces a new resource to be created.
         */
        registryServer: string;
        /**
         * The user name to log into the registry server. Changing this forces a new resource to be created.
         */
        userName: string;
    }

    export interface PoolFixedScale {
        /**
         * The timeout for resize operations. Defaults to `PT15M`.
         */
        resizeTimeout?: string;
        /**
         * The number of nodes in the Batch pool. Defaults to `1`.
         */
        targetDedicatedNodes?: number;
        /**
         * The number of low priority nodes in the Batch pool. Defaults to `0`.
         */
        targetLowPriorityNodes?: number;
    }

    export interface PoolNetworkConfiguration {
        /**
         * A list of inbound NAT pools that can be used to address specific ports on an individual compute node externally. Set as documented in the inboundNatPools block below. Changing this forces a new resource to be created.
         */
        endpointConfigurations?: outputs.batch.PoolNetworkConfigurationEndpointConfiguration[];
        /**
         * Type of public IP address provisioning. Supported values are `BatchManaged`, `UserManaged` and `NoPublicIPAddresses`.
         */
        publicAddressProvisioningType?: string;
        /**
         * A list of public ip ids that will be allocated to nodes. Changing this forces a new resource to be created.
         */
        publicIps?: string[];
        /**
         * The ARM resource identifier of the virtual network subnet which the compute nodes of the pool will join. Changing this forces a new resource to be created.
         */
        subnetId: string;
    }

    export interface PoolNetworkConfigurationEndpointConfiguration {
        /**
         * The port number on the compute node. Acceptable values are between `1` and `65535` except for `29876`, `29877` as these are reserved. Changing this forces a new resource to be created.
         */
        backendPort: number;
        /**
         * The range of external ports that will be used to provide inbound access to the backendPort on individual compute nodes in the format of `1000-1100`. Acceptable values range between `1` and `65534` except ports from `50000` to `55000` which are reserved by the Batch service. All ranges within a pool must be distinct and cannot overlap. Values must be a range of at least `100` nodes. Changing this forces a new resource to be created.
         */
        frontendPortRange: string;
        /**
         * The name of the endpoint. The name must be unique within a Batch pool, can contain letters, numbers, underscores, periods, and hyphens. Names must start with a letter or number, must end with a letter, number, or underscore, and cannot exceed 77 characters. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * A list of network security group rules that will be applied to the endpoint. The maximum number of rules that can be specified across all the endpoints on a Batch pool is `25`. If no network security group rules are specified, a default rule will be created to allow inbound access to the specified backendPort. Set as documented in the networkSecurityGroupRules block below. Changing this forces a new resource to be created.
         */
        networkSecurityGroupRules?: outputs.batch.PoolNetworkConfigurationEndpointConfigurationNetworkSecurityGroupRule[];
        /**
         * The protocol of the endpoint. Acceptable values are `TCP` and `UDP`. Changing this forces a new resource to be created.
         */
        protocol: string;
    }

    export interface PoolNetworkConfigurationEndpointConfigurationNetworkSecurityGroupRule {
        /**
         * The action that should be taken for a specified IP address, subnet range or tag. Acceptable values are `Allow` and `Deny`. Changing this forces a new resource to be created.
         */
        access: string;
        /**
         * The priority for this rule. The value must be at least `150`. Changing this forces a new resource to be created.
         */
        priority: number;
        /**
         * The source address prefix or tag to match for the rule. Changing this forces a new resource to be created.
         */
        sourceAddressPrefix: string;
    }

    export interface PoolStartTask {
        /**
         * The command line executed by the start task.
         */
        commandLine: string;
        /**
         * A map of strings (key,value) that represents the environment variables to set in the start task.
         */
        environment?: {[key: string]: string};
        /**
         * The number of retry count. Defaults to `1`.
         */
        maxTaskRetryCount?: number;
        /**
         * One or more `resourceFile` blocks that describe the files to be downloaded to a compute node.
         */
        resourceFiles?: outputs.batch.PoolStartTaskResourceFile[];
        /**
         * A `userIdentity` block that describes the user identity under which the start task runs.
         */
        userIdentity: outputs.batch.PoolStartTaskUserIdentity;
        /**
         * A flag that indicates if the Batch pool should wait for the start task to be completed. Default to `false`.
         */
        waitForSuccess?: boolean;
    }

    export interface PoolStartTaskResourceFile {
        /**
         * The storage container name in the auto storage account.
         */
        autoStorageContainerName?: string;
        /**
         * The blob prefix to use when downloading blobs from an Azure Storage container. Only the blobs whose names begin with the specified prefix will be downloaded. The property is valid only when `autoStorageContainerName` or `storageContainerUrl` is used. This prefix can be a partial filename or a subdirectory. If a prefix is not specified, all the files in the container will be downloaded.
         */
        blobPrefix?: string;
        /**
         * The file permission mode represented as a string in octal format (e.g. `"0644"`). This property applies only to files being downloaded to Linux compute nodes. It will be ignored if it is specified for a `resourceFile` which will be downloaded to a Windows node. If this property is not specified for a Linux node, then a default value of 0770 is applied to the file.
         */
        fileMode?: string;
        /**
         * The location on the compute node to which to download the file, relative to the task's working directory. If the `httpUrl` property is specified, the `filePath` is required and describes the path which the file will be downloaded to, including the filename. Otherwise, if the `autoStorageContainerName` or `storageContainerUrl` property is specified, `filePath` is optional and is the directory to download the files to. In the case where `filePath` is used as a directory, any directory structure already associated with the input data will be retained in full and appended to the specified filePath directory. The specified relative path cannot break out of the task's working directory (for example by using '..').
         */
        filePath?: string;
        /**
         * The URL of the file to download. If the URL is Azure Blob Storage, it must be readable using anonymous access; that is, the Batch service does not present any credentials when downloading the blob. There are two ways to get such a URL for a blob in Azure storage: include a Shared Access Signature (SAS) granting read permissions on the blob, or set the ACL for the blob or its container to allow public access.
         */
        httpUrl?: string;
        /**
         * The URL of the blob container within Azure Blob Storage. This URL must be readable and listable using anonymous access; that is, the Batch service does not present any credentials when downloading the blob. There are two ways to get such a URL for a blob in Azure storage: include a Shared Access Signature (SAS) granting read and list permissions on the blob, or set the ACL for the blob or its container to allow public access.
         */
        storageContainerUrl?: string;
    }

    export interface PoolStartTaskUserIdentity {
        /**
         * A `autoUser` block that describes the user identity under which the start task runs.
         */
        autoUser?: outputs.batch.PoolStartTaskUserIdentityAutoUser;
        /**
         * The username to be used by the Batch pool start task.
         */
        userName?: string;
    }

    export interface PoolStartTaskUserIdentityAutoUser {
        /**
         * The elevation level of the user identity under which the start task runs. Possible values are `Admin` or `NonAdmin`. Defaults to `NonAdmin`.
         */
        elevationLevel?: string;
        /**
         * The scope of the user identity under which the start task runs. Possible values are `Task` or `Pool`. Defaults to `Task`.
         */
        scope?: string;
    }

    export interface PoolStorageImageReference {
        /**
         * Specifies the ID of the Custom Image which the virtual machines should be created from. Changing this forces a new resource to be created. See [official documentation](https://docs.microsoft.com/en-us/azure/batch/batch-custom-images) for more details.
         * ---
         */
        id?: string;
        /**
         * Specifies the offer of the image used to create the virtual machines. Changing this forces a new resource to be created.
         */
        offer?: string;
        /**
         * Specifies the publisher of the image used to create the virtual machines. Changing this forces a new resource to be created.
         */
        publisher?: string;
        /**
         * Specifies the SKU of the image used to create the virtual machines. Changing this forces a new resource to be created.
         */
        sku?: string;
        /**
         * Specifies the version of the image used to create the virtual machines. Changing this forces a new resource to be created.
         */
        version?: string;
    }

}

export namespace blueprint {
    export interface AssignmentIdentity {
        identityIds: string[];
        principalId: string;
        tenantId: string;
        /**
         * The Identity type for the Managed Service Identity. Currently only `UserAssigned` is supported.
         */
        type: string;
    }

}

export namespace bot {
    export interface ChannelDirectLineSite {
        /**
         * Enables/Disables this site. Enabled by default
         */
        enabled?: boolean;
        /**
         * Enables additional security measures for this site, see [Enhanced Directline Authentication Features](https://blog.botframework.com/2018/09/25/enhanced-direct-line-authentication-features). Disabled by default.
         */
        enhancedAuthenticationEnabled?: boolean;
        /**
         * Id for the site
         */
        id: string;
        /**
         * Primary key for accessing this site
         */
        key: string;
        /**
         * Secondary key for accessing this site
         */
        key2: string;
        /**
         * The name of the site
         */
        name: string;
        /**
         * This field is required when `isSecureSiteEnabled` is enabled. Determines which origins can establish a Directline conversation for this site.
         */
        trustedOrigins?: string[];
        /**
         * Enables v1 of the Directline protocol for this site. Enabled by default
         */
        v1Allowed?: boolean;
        /**
         * Enables v3 of the Directline protocol for this site. Enabled by default
         */
        v3Allowed?: boolean;
    }

}

export namespace cdn {
    export interface EndpointDeliveryRule {
        /**
         * A `cacheExpirationAction` block as defined above.
         */
        cacheExpirationAction?: outputs.cdn.EndpointDeliveryRuleCacheExpirationAction;
        /**
         * A `cacheKeyQueryStringAction` block as defined above.
         */
        cacheKeyQueryStringAction?: outputs.cdn.EndpointDeliveryRuleCacheKeyQueryStringAction;
        /**
         * A `cookiesCondition` block as defined above.
         */
        cookiesConditions?: outputs.cdn.EndpointDeliveryRuleCookiesCondition[];
        /**
         * A `deviceCondition` block as defined below.
         */
        deviceCondition?: outputs.cdn.EndpointDeliveryRuleDeviceCondition;
        /**
         * A `httpVersionCondition` block as defined below.
         */
        httpVersionConditions?: outputs.cdn.EndpointDeliveryRuleHttpVersionCondition[];
        /**
         * A `modifyRequestHeaderAction` block as defined below.
         */
        modifyRequestHeaderActions?: outputs.cdn.EndpointDeliveryRuleModifyRequestHeaderAction[];
        /**
         * A `modifyResponseHeaderAction` block as defined below.
         */
        modifyResponseHeaderActions?: outputs.cdn.EndpointDeliveryRuleModifyResponseHeaderAction[];
        /**
         * The Name which should be used for this Delivery Rule.
         */
        name: string;
        /**
         * The order used for this rule, which must be larger than 1.
         */
        order: number;
        /**
         * A `postArgCondition` block as defined below.
         */
        postArgConditions?: outputs.cdn.EndpointDeliveryRulePostArgCondition[];
        /**
         * A `queryStringCondition` block as defined below.
         */
        queryStringConditions?: outputs.cdn.EndpointDeliveryRuleQueryStringCondition[];
        /**
         * A `remoteAddressCondition` block as defined below.
         */
        remoteAddressConditions?: outputs.cdn.EndpointDeliveryRuleRemoteAddressCondition[];
        /**
         * A `requestBodyCondition` block as defined below.
         */
        requestBodyConditions?: outputs.cdn.EndpointDeliveryRuleRequestBodyCondition[];
        /**
         * A `requestHeaderCondition` block as defined below.
         */
        requestHeaderConditions?: outputs.cdn.EndpointDeliveryRuleRequestHeaderCondition[];
        /**
         * A `requestMethodCondition` block as defined below.
         */
        requestMethodCondition?: outputs.cdn.EndpointDeliveryRuleRequestMethodCondition;
        /**
         * A `requestSchemeCondition` block as defined below.
         */
        requestSchemeCondition?: outputs.cdn.EndpointDeliveryRuleRequestSchemeCondition;
        /**
         * A `requestUriCondition` block as defined below.
         */
        requestUriConditions?: outputs.cdn.EndpointDeliveryRuleRequestUriCondition[];
        /**
         * A `urlFileExtensionCondition` block as defined below.
         */
        urlFileExtensionConditions?: outputs.cdn.EndpointDeliveryRuleUrlFileExtensionCondition[];
        /**
         * A `urlFileNameCondition` block as defined below.
         */
        urlFileNameConditions?: outputs.cdn.EndpointDeliveryRuleUrlFileNameCondition[];
        /**
         * A `urlPathCondition` block as defined below.
         */
        urlPathConditions?: outputs.cdn.EndpointDeliveryRuleUrlPathCondition[];
        /**
         * A `urlRedirectAction` block as defined below.
         */
        urlRedirectAction?: outputs.cdn.EndpointDeliveryRuleUrlRedirectAction;
        /**
         * A `urlRewriteAction` block as defined below.
         */
        urlRewriteAction?: outputs.cdn.EndpointDeliveryRuleUrlRewriteAction;
    }

    export interface EndpointDeliveryRuleCacheExpirationAction {
        /**
         * The behavior of the cache. Valid values are `BypassCache`, `Override` and `SetIfMissing`.
         */
        behavior: string;
        /**
         * Duration of the cache. Only allowed when `behavior` is set to `Override` or `SetIfMissing`. Format: `[d.]hh:mm:ss`
         */
        duration?: string;
    }

    export interface EndpointDeliveryRuleCacheKeyQueryStringAction {
        /**
         * The behavior of the cache key for query strings. Valid values are `Exclude`, `ExcludeAll`, `Include` and `IncludeAll`.
         */
        behavior: string;
        /**
         * Comma separated list of parameter values.
         */
        parameters?: string;
    }

    export interface EndpointDeliveryRuleCookiesCondition {
        /**
         * List of values for the cookie. This is required if `operator` is not `Any`.
         */
        matchValues?: string[];
        /**
         * Defaults to `false`.
         */
        negateCondition?: boolean;
        /**
         * Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
         */
        operator: string;
        /**
         * Name of the cookie.
         */
        selector: string;
        /**
         * Valid values are `Lowercase` and `Uppercase`.
         */
        transforms?: string[];
    }

    export interface EndpointDeliveryRuleDeviceCondition {
        /**
         * Valid values are `Desktop` and `Mobile`.
         */
        matchValues: string[];
        /**
         * Defaults to `false`.
         */
        negateCondition?: boolean;
        /**
         * Valid values are `Equal`.
         */
        operator?: string;
    }

    export interface EndpointDeliveryRuleHttpVersionCondition {
        /**
         * Valid values are `0.9`, `1.0`, `1.1` and `2.0`.
         */
        matchValues: string[];
        /**
         * Defaults to `false`.
         */
        negateCondition?: boolean;
        /**
         * Valid values are `Equal`.
         */
        operator?: string;
    }

    export interface EndpointDeliveryRuleModifyRequestHeaderAction {
        /**
         * Action to be executed on a header value. Valid values are `Append`, `Delete` and `Overwrite`.
         */
        action: string;
        /**
         * The header name.
         */
        name: string;
        /**
         * The value of the header. Only needed when `action` is set to `Append` or `overwrite`.
         */
        value?: string;
    }

    export interface EndpointDeliveryRuleModifyResponseHeaderAction {
        /**
         * Action to be executed on a header value. Valid values are `Append`, `Delete` and `Overwrite`.
         */
        action: string;
        /**
         * The header name.
         */
        name: string;
        /**
         * The value of the header. Only needed when `action` is set to `Append` or `overwrite`.
         */
        value?: string;
    }

    export interface EndpointDeliveryRulePostArgCondition {
        /**
         * List of string values. This is required if `operator` is not `Any`.
         */
        matchValues?: string[];
        /**
         * Defaults to `false`.
         */
        negateCondition?: boolean;
        /**
         * Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
         */
        operator: string;
        /**
         * Name of the post arg.
         */
        selector: string;
        /**
         * Valid values are `Lowercase` and `Uppercase`.
         */
        transforms?: string[];
    }

    export interface EndpointDeliveryRuleQueryStringCondition {
        /**
         * List of string values. This is required if `operator` is not `Any`.
         */
        matchValues?: string[];
        /**
         * Defaults to `false`.
         */
        negateCondition?: boolean;
        /**
         * Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
         */
        operator: string;
        /**
         * Valid values are `Lowercase` and `Uppercase`.
         */
        transforms?: string[];
    }

    export interface EndpointDeliveryRuleRemoteAddressCondition {
        /**
         * List of string values. For `GeoMatch` `operator` this should be a list of country codes (e.g. `US` or `DE`). List of IP address if `operator` equals to `IPMatch`. This is required if `operator` is not `Any`.
         */
        matchValues?: string[];
        /**
         * Defaults to `false`.
         */
        negateCondition?: boolean;
        /**
         * Valid values are `Any`, `GeoMatch` and `IPMatch`.
         */
        operator: string;
    }

    export interface EndpointDeliveryRuleRequestBodyCondition {
        /**
         * List of string values. This is required if `operator` is not `Any`.
         */
        matchValues?: string[];
        /**
         * Defaults to `false`.
         */
        negateCondition?: boolean;
        /**
         * Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
         */
        operator: string;
        /**
         * Valid values are `Lowercase` and `Uppercase`.
         */
        transforms?: string[];
    }

    export interface EndpointDeliveryRuleRequestHeaderCondition {
        /**
         * List of header values. This is required if `operator` is not `Any`.
         */
        matchValues?: string[];
        /**
         * Defaults to `false`.
         */
        negateCondition?: boolean;
        /**
         * Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
         */
        operator: string;
        /**
         * Header name.
         */
        selector: string;
        /**
         * Valid values are `Lowercase` and `Uppercase`.
         */
        transforms?: string[];
    }

    export interface EndpointDeliveryRuleRequestMethodCondition {
        /**
         * Valid values are `DELETE`, `GET`, `HEAD`, `OPTIONS`, `POST` and `PUT`.
         */
        matchValues: string[];
        /**
         * Defaults to `false`.
         */
        negateCondition?: boolean;
        /**
         * Valid values are `Equal`.
         */
        operator?: string;
    }

    export interface EndpointDeliveryRuleRequestSchemeCondition {
        /**
         * Valid values are `HTTP` and `HTTPS`.
         */
        matchValues: string[];
        /**
         * Defaults to `false`.
         */
        negateCondition?: boolean;
        /**
         * Valid values are `Equal`.
         */
        operator?: string;
    }

    export interface EndpointDeliveryRuleRequestUriCondition {
        /**
         * List of string values. This is required if `operator` is not `Any`.
         */
        matchValues?: string[];
        /**
         * Defaults to `false`.
         */
        negateCondition?: boolean;
        /**
         * Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
         */
        operator: string;
        /**
         * Valid values are `Lowercase` and `Uppercase`.
         */
        transforms?: string[];
    }

    export interface EndpointDeliveryRuleUrlFileExtensionCondition {
        /**
         * List of string values. This is required if `operator` is not `Any`.
         */
        matchValues?: string[];
        /**
         * Defaults to `false`.
         */
        negateCondition?: boolean;
        /**
         * Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
         */
        operator: string;
        /**
         * Valid values are `Lowercase` and `Uppercase`.
         */
        transforms?: string[];
    }

    export interface EndpointDeliveryRuleUrlFileNameCondition {
        /**
         * List of string values. This is required if `operator` is not `Any`.
         */
        matchValues?: string[];
        /**
         * Defaults to `false`.
         */
        negateCondition?: boolean;
        /**
         * Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
         */
        operator: string;
        /**
         * Valid values are `Lowercase` and `Uppercase`.
         */
        transforms?: string[];
    }

    export interface EndpointDeliveryRuleUrlPathCondition {
        /**
         * List of string values. This is required if `operator` is not `Any`.
         */
        matchValues?: string[];
        /**
         * Defaults to `false`.
         */
        negateCondition?: boolean;
        /**
         * Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
         */
        operator: string;
        /**
         * Valid values are `Lowercase` and `Uppercase`.
         */
        transforms?: string[];
    }

    export interface EndpointDeliveryRuleUrlRedirectAction {
        /**
         * Specifies the fragment part of the URL. This value must not start with a `#`.
         */
        fragment?: string;
        /**
         * Specifies the hostname part of the URL.
         */
        hostname?: string;
        /**
         * Specifies the path part of the URL. This value must begin with a `/`.
         */
        path?: string;
        /**
         * Specifies the protocol part of the URL. Valid values are `Http` and `Https`.
         */
        protocol?: string;
        /**
         * Specifies the query string part of the URL. This value must not start with a `?` or `&` and must be in `<key>=<value>` format separated by `&`.
         */
        queryString?: string;
        /**
         * Type of the redirect. Valid values are `Found`, `Moved`, `PermanentRedirect` and `TemporaryRedirect`.
         */
        redirectType: string;
    }

    export interface EndpointDeliveryRuleUrlRewriteAction {
        /**
         * This value must start with a `/` and can't be longer than 260 characters.
         */
        destination: string;
        /**
         * Defaults to `true`.
         */
        preserveUnmatchedPath?: boolean;
        /**
         * This value must start with a `/` and can't be longer than 260 characters.
         */
        sourcePattern: string;
    }

    export interface EndpointGeoFilter {
        /**
         * The Action of the Geo Filter. Possible values include `Allow` and `Block`.
         */
        action: string;
        /**
         * A List of two letter country codes (e.g. `US`, `GB`) to be associated with this Geo Filter.
         */
        countryCodes: string[];
        /**
         * The relative path applicable to geo filter.
         */
        relativePath: string;
    }

    export interface EndpointGlobalDeliveryRule {
        /**
         * A `cacheExpirationAction` block as defined above.
         */
        cacheExpirationAction?: outputs.cdn.EndpointGlobalDeliveryRuleCacheExpirationAction;
        /**
         * A `cacheKeyQueryStringAction` block as defined above.
         */
        cacheKeyQueryStringAction?: outputs.cdn.EndpointGlobalDeliveryRuleCacheKeyQueryStringAction;
        /**
         * A `modifyRequestHeaderAction` block as defined below.
         */
        modifyRequestHeaderActions?: outputs.cdn.EndpointGlobalDeliveryRuleModifyRequestHeaderAction[];
        /**
         * A `modifyResponseHeaderAction` block as defined below.
         */
        modifyResponseHeaderActions?: outputs.cdn.EndpointGlobalDeliveryRuleModifyResponseHeaderAction[];
        /**
         * A `urlRedirectAction` block as defined below.
         */
        urlRedirectAction?: outputs.cdn.EndpointGlobalDeliveryRuleUrlRedirectAction;
        /**
         * A `urlRewriteAction` block as defined below.
         */
        urlRewriteAction?: outputs.cdn.EndpointGlobalDeliveryRuleUrlRewriteAction;
    }

    export interface EndpointGlobalDeliveryRuleCacheExpirationAction {
        /**
         * The behavior of the cache. Valid values are `BypassCache`, `Override` and `SetIfMissing`.
         */
        behavior: string;
        /**
         * Duration of the cache. Only allowed when `behavior` is set to `Override` or `SetIfMissing`. Format: `[d.]hh:mm:ss`
         */
        duration?: string;
    }

    export interface EndpointGlobalDeliveryRuleCacheKeyQueryStringAction {
        /**
         * The behavior of the cache key for query strings. Valid values are `Exclude`, `ExcludeAll`, `Include` and `IncludeAll`.
         */
        behavior: string;
        /**
         * Comma separated list of parameter values.
         */
        parameters?: string;
    }

    export interface EndpointGlobalDeliveryRuleModifyRequestHeaderAction {
        /**
         * Action to be executed on a header value. Valid values are `Append`, `Delete` and `Overwrite`.
         */
        action: string;
        /**
         * The header name.
         */
        name: string;
        /**
         * The value of the header. Only needed when `action` is set to `Append` or `overwrite`.
         */
        value?: string;
    }

    export interface EndpointGlobalDeliveryRuleModifyResponseHeaderAction {
        /**
         * Action to be executed on a header value. Valid values are `Append`, `Delete` and `Overwrite`.
         */
        action: string;
        /**
         * The header name.
         */
        name: string;
        /**
         * The value of the header. Only needed when `action` is set to `Append` or `overwrite`.
         */
        value?: string;
    }

    export interface EndpointGlobalDeliveryRuleUrlRedirectAction {
        /**
         * Specifies the fragment part of the URL. This value must not start with a `#`.
         */
        fragment?: string;
        /**
         * Specifies the hostname part of the URL.
         */
        hostname?: string;
        /**
         * Specifies the path part of the URL. This value must begin with a `/`.
         */
        path?: string;
        /**
         * Specifies the protocol part of the URL. Valid values are `Http` and `Https`.
         */
        protocol?: string;
        /**
         * Specifies the query string part of the URL. This value must not start with a `?` or `&` and must be in `<key>=<value>` format separated by `&`.
         */
        queryString?: string;
        /**
         * Type of the redirect. Valid values are `Found`, `Moved`, `PermanentRedirect` and `TemporaryRedirect`.
         */
        redirectType: string;
    }

    export interface EndpointGlobalDeliveryRuleUrlRewriteAction {
        /**
         * This value must start with a `/` and can't be longer than 260 characters.
         */
        destination: string;
        /**
         * Defaults to `true`.
         */
        preserveUnmatchedPath?: boolean;
        /**
         * This value must start with a `/` and can't be longer than 260 characters.
         */
        sourcePattern: string;
    }

    export interface EndpointOrigin {
        /**
         * A string that determines the hostname/IP address of the origin server. This string can be a domain name, Storage Account endpoint, Web App endpoint, IPv4 address or IPv6 address. Changing this forces a new resource to be created.
         */
        hostName: string;
        /**
         * The HTTP port of the origin. Defaults to `80`. Changing this forces a new resource to be created.
         */
        httpPort?: number;
        /**
         * The HTTPS port of the origin. Defaults to `443`. Changing this forces a new resource to be created.
         */
        httpsPort?: number;
        /**
         * The name of the origin. This is an arbitrary value. However, this value needs to be unique under the endpoint. Changing this forces a new resource to be created.
         */
        name: string;
    }

}

export namespace cognitive {
    export interface AccountNetworkAcls {
        /**
         * The Default Action to use when no rules match from `ipRules` / `virtualNetworkSubnetIds`. Possible values are `Allow` and `Deny`.
         */
        defaultAction: string;
        /**
         * One or more IP Addresses, or CIDR Blocks which should be able to access the Cognitive Account.
         */
        ipRules?: string[];
        /**
         * One or more Subnet ID's which should be able to access this Cognitive Account.
         */
        virtualNetworkSubnetIds?: string[];
    }

}

export namespace compute {
    export interface BastionHostIpConfiguration {
        /**
         * The name of the IP configuration.
         */
        name: string;
        /**
         * Reference to a Public IP Address to associate with this Bastion Host.
         */
        publicIpAddressId: string;
        /**
         * Reference to a subnet in which this Bastion Host has been created.
         */
        subnetId: string;
    }

    export interface ConfigurationPolicyAssignmentConfiguration {
        /**
         * The name of the Guest Configuration that will be assigned in this Guest Configuration Assignment.
         */
        name: string;
        /**
         * One or more `parameter` blocks which define what configuration parameters and values against.
         */
        parameters?: outputs.compute.ConfigurationPolicyAssignmentConfigurationParameter[];
        /**
         * The version of the Guest Configuration that will be assigned in this Guest Configuration Assignment.
         */
        version?: string;
    }

    export interface ConfigurationPolicyAssignmentConfigurationParameter {
        /**
         * The name of the configuration parameter to check.
         */
        name: string;
        /**
         * The value to check the configuration parameter with.
         */
        value: string;
    }

    export interface DiskEncryptionSetIdentity {
        /**
         * The (Client) ID of the Service Principal.
         */
        principalId: string;
        /**
         * The ID of the Tenant the Service Principal is assigned in.
         */
        tenantId: string;
        /**
         * The Type of Identity which should be used for this Disk Encryption Set. At this time the only possible value is `SystemAssigned`.
         */
        type: string;
    }

    export interface GetImageDataDisk {
        /**
         * the URI in Azure storage of the blob used to create the image.
         */
        blobUri: string;
        /**
         * the caching mode for the Data Disk, such as `ReadWrite`, `ReadOnly`, or `None`.
         */
        caching: string;
        /**
         * the logical unit number of the data disk.
         */
        lun: number;
        /**
         * the ID of the Managed Disk used as the Data Disk Image.
         */
        managedDiskId: string;
        /**
         * the size of this Data Disk in GB.
         */
        sizeGb: number;
    }

    export interface GetImageOsDisk {
        /**
         * the URI in Azure storage of the blob used to create the image.
         */
        blobUri: string;
        /**
         * the caching mode for the Data Disk, such as `ReadWrite`, `ReadOnly`, or `None`.
         */
        caching: string;
        /**
         * the ID of the Managed Disk used as the Data Disk Image.
         */
        managedDiskId: string;
        /**
         * the State of the OS used in the Image, such as `Generalized`.
         */
        osState: string;
        /**
         * the type of Operating System used on the OS Disk. such as `Linux` or `Windows`.
         */
        osType: string;
        /**
         * the size of this Data Disk in GB.
         */
        sizeGb: number;
    }

    export interface GetImagesImage {
        /**
         * One or more `dataDisk` blocks as defined below.
         */
        dataDisks: outputs.compute.GetImagesImageDataDisk[];
        /**
         * The supported Azure location where the Image exists.
         */
        location: string;
        /**
         * The name of the Image.
         */
        name: string;
        /**
         * An `osDisk` block as defined below.
         */
        osDisks: outputs.compute.GetImagesImageOsDisk[];
        /**
         * A mapping of tags assigned to the Image.
         */
        tags: {[key: string]: string};
        /**
         * Is zone resiliency enabled?
         */
        zoneResilient: boolean;
    }

    export interface GetImagesImageDataDisk {
        /**
         * the URI in Azure storage of the blob used to create the image.
         */
        blobUri: string;
        /**
         * the caching mode for the Data Disk.
         */
        caching: string;
        /**
         * the logical unit number of the data disk.
         */
        lun: number;
        /**
         * the ID of the Managed Disk used as the Data Disk Image.
         */
        managedDiskId: string;
        /**
         * the size of this Data Disk in GB.
         */
        sizeGb: number;
    }

    export interface GetImagesImageOsDisk {
        /**
         * the URI in Azure storage of the blob used to create the image.
         */
        blobUri: string;
        /**
         * the caching mode for the Data Disk.
         */
        caching: string;
        /**
         * the ID of the Managed Disk used as the Data Disk Image.
         */
        managedDiskId: string;
        /**
         * the State of the OS used in the Image.
         */
        osState: string;
        /**
         * the type of Operating System used on the OS Disk.
         */
        osType: string;
        /**
         * the size of this Data Disk in GB.
         */
        sizeGb: number;
    }

    export interface GetSharedImageIdentifier {
        /**
         * The Offer Name for this Shared Image.
         */
        offer: string;
        /**
         * The Publisher Name for this Gallery Image.
         */
        publisher: string;
        /**
         * The Name of the SKU for this Gallery Image.
         */
        sku: string;
    }

    export interface GetSharedImageVersionTargetRegion {
        /**
         * The name of the Image Version.
         */
        name: string;
        /**
         * The number of replicas of the Image Version to be created per region.
         */
        regionalReplicaCount: number;
        /**
         * The storage account type for the image version.
         */
        storageAccountType: string;
    }

    export interface GetSharedImageVersionsImage {
        /**
         * Is this Image Version excluded from the `latest` filter?
         */
        excludeFromLatest: boolean;
        /**
         * The supported Azure location where the Shared Image Gallery exists.
         */
        location: string;
        /**
         * The ID of the Managed Image which was the source of this Shared Image Version.
         */
        managedImageId: string;
        /**
         * The Azure Region in which this Image Version exists.
         */
        name: string;
        /**
         * A mapping of tags assigned to the Shared Image.
         */
        tags: {[key: string]: string};
        /**
         * One or more `targetRegion` blocks as documented below.
         */
        targetRegions: outputs.compute.GetSharedImageVersionsImageTargetRegion[];
    }

    export interface GetSharedImageVersionsImageTargetRegion {
        /**
         * The Azure Region in which this Image Version exists.
         */
        name: string;
        /**
         * The number of replicas of the Image Version to be created per region.
         */
        regionalReplicaCount: number;
        /**
         * The storage account type for the image version.
         */
        storageAccountType: string;
    }

    export interface GetSnapshotEncryptionSetting {
        diskEncryptionKeys: outputs.compute.GetSnapshotEncryptionSettingDiskEncryptionKey[];
        enabled: boolean;
        keyEncryptionKeys: outputs.compute.GetSnapshotEncryptionSettingKeyEncryptionKey[];
    }

    export interface GetSnapshotEncryptionSettingDiskEncryptionKey {
        secretUrl: string;
        sourceVaultId: string;
    }

    export interface GetSnapshotEncryptionSettingKeyEncryptionKey {
        keyUrl: string;
        sourceVaultId: string;
    }

    export interface GetVirtualMachineIdentity {
        /**
         * The list of User Managed Identity ID's which are assigned to the Virtual Machine.
         */
        identityIds: string[];
        /**
         * The ID of the System Managed Service Principal assigned to the Virtual Machine.
         */
        principalId: string;
        /**
         * The ID of the Tenant of the System Managed Service Principal assigned to the Virtual Machine.
         */
        tenantId: string;
        /**
         * The identity type of the Managed Identity assigned to the Virtual Machine.
         */
        type: string;
    }

    export interface GetVirtualMachineScaleSetIdentity {
        /**
         * The list of User Managed Identity ID's which are assigned to the Virtual Machine Scale Set.
         */
        identityIds: string[];
        /**
         * The ID of the System Managed Service Principal assigned to the Virtual Machine Scale Set.
         */
        principalId: string;
        /**
         * The identity type of the Managed Identity assigned to the Virtual Machine Scale Set.
         */
        type: string;
    }

    export interface GetVirtualMachineScaleSetNetworkInterface {
        /**
         * The dns servers in use.
         */
        dnsServers: string[];
        enableAcceleratedNetworking: boolean;
        enableIpForwarding: boolean;
        /**
         * An ipConfiguration block as documented below.
         */
        ipConfigurations: outputs.compute.GetVirtualMachineScaleSetNetworkInterfaceIpConfiguration[];
        /**
         * The name of this Virtual Machine Scale Set.
         */
        name: string;
        /**
         * The identifier for the network security group.
         */
        networkSecurityGroupId: string;
        /**
         * If this ipConfiguration is the primary one.
         */
        primary: boolean;
    }

    export interface GetVirtualMachineScaleSetNetworkInterfaceIpConfiguration {
        /**
         * An array of references to backend address pools of application gateways.
         */
        applicationGatewayBackendAddressPoolIds: string[];
        /**
         * The application security group IDs to use.
         */
        applicationSecurityGroupIds: string[];
        /**
         * An array of references to backend address pools of load balancers.
         */
        loadBalancerBackendAddressPoolIds: string[];
        /**
         * An array of references to inbound NAT pools for load balancers.
         */
        loadBalancerInboundNatRulesIds: string[];
        /**
         * The name of this Virtual Machine Scale Set.
         */
        name: string;
        /**
         * If this ipConfiguration is the primary one.
         */
        primary: boolean;
        publicIpAddresses: outputs.compute.GetVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress[];
        /**
         * The the identifier of the subnet.
         */
        subnetId: string;
        version: string;
    }

    export interface GetVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress {
        /**
         * The domain name label for the dns settings.
         */
        domainNameLabel: string;
        idleTimeoutInMinutes: number;
        ipTags: outputs.compute.GetVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTag[];
        /**
         * The name of this Virtual Machine Scale Set.
         */
        name: string;
        publicIpPrefixId: string;
    }

    export interface GetVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTag {
        tag: string;
        /**
         * The identity type of the Managed Identity assigned to the Virtual Machine Scale Set.
         */
        type: string;
    }

    export interface ImageDataDisk {
        /**
         * Specifies the URI in Azure storage of the blob that you want to use to create the image.
         */
        blobUri: string;
        /**
         * Specifies the caching mode as `ReadWrite`, `ReadOnly`, or `None`. The default is `None`.
         */
        caching?: string;
        /**
         * Specifies the logical unit number of the data disk.
         */
        lun?: number;
        /**
         * Specifies the ID of the managed disk resource that you want to use to create the image.
         */
        managedDiskId?: string;
        /**
         * Specifies the size of the image to be created. The target size can't be smaller than the source size.
         */
        sizeGb: number;
    }

    export interface ImageOsDisk {
        /**
         * Specifies the URI in Azure storage of the blob that you want to use to create the image.
         */
        blobUri: string;
        /**
         * Specifies the caching mode as `ReadWrite`, `ReadOnly`, or `None`. The default is `None`.
         */
        caching?: string;
        /**
         * Specifies the ID of the managed disk resource that you want to use to create the image.
         */
        managedDiskId: string;
        /**
         * Specifies the state of the operating system contained in the blob. Currently, the only value is Generalized.
         */
        osState?: string;
        /**
         * Specifies the type of operating system contained in the virtual machine image. Possible values are: Windows or Linux.
         */
        osType?: string;
        /**
         * Specifies the size of the image to be created. The target size can't be smaller than the source size.
         */
        sizeGb: number;
    }

    export interface LinuxVirtualMachineAdditionalCapabilities {
        /**
         * Should the capacity to enable Data Disks of the `UltraSSD_LRS` storage account type be supported on this Virtual Machine? Defaults to `false`.
         */
        ultraSsdEnabled?: boolean;
    }

    export interface LinuxVirtualMachineAdminSshKey {
        /**
         * The Public Key which should be used for authentication, which needs to be at least 2048-bit and in `ssh-rsa` format. Changing this forces a new resource to be created.
         */
        publicKey: string;
        /**
         * The Username for which this Public SSH Key should be configured. Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface LinuxVirtualMachineBootDiagnostics {
        /**
         * The Primary/Secondary Endpoint for the Azure Storage Account which should be used to store Boot Diagnostics, including Console Output and Screenshots from the Hypervisor.
         */
        storageAccountUri?: string;
    }

    export interface LinuxVirtualMachineIdentity {
        /**
         * A list of User Managed Identity ID's which should be assigned to the Linux Virtual Machine.
         */
        identityIds?: string[];
        /**
         * The ID of the System Managed Service Principal.
         */
        principalId: string;
        /**
         * The ID of the Tenant the System Managed Service Principal is assigned in.
         */
        tenantId: string;
        /**
         * The type of Managed Identity which should be assigned to the Linux Virtual Machine. Possible values are `SystemAssigned`, `UserAssigned` and `SystemAssigned, UserAssigned`.
         */
        type: string;
    }

    export interface LinuxVirtualMachineOsDisk {
        /**
         * The Type of Caching which should be used for the Internal OS Disk. Possible values are `None`, `ReadOnly` and `ReadWrite`.
         */
        caching: string;
        /**
         * A `diffDiskSettings` block as defined above.
         */
        diffDiskSettings?: outputs.compute.LinuxVirtualMachineOsDiskDiffDiskSettings;
        /**
         * The ID of the Disk Encryption Set which should be used to Encrypt this OS Disk.
         */
        diskEncryptionSetId?: string;
        /**
         * The Size of the Internal OS Disk in GB, if you wish to vary from the size used in the image this Virtual Machine is sourced from.
         */
        diskSizeGb: number;
        /**
         * The name which should be used for the Internal OS Disk. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * The Type of Storage Account which should back this the Internal OS Disk. Possible values are `Standard_LRS`, `StandardSSD_LRS` and `Premium_LRS`. Changing this forces a new resource to be created.
         */
        storageAccountType: string;
        /**
         * Should Write Accelerator be Enabled for this OS Disk? Defaults to `false`.
         */
        writeAcceleratorEnabled?: boolean;
    }

    export interface LinuxVirtualMachineOsDiskDiffDiskSettings {
        /**
         * Specifies the Ephemeral Disk Settings for the OS Disk. At this time the only possible value is `Local`. Changing this forces a new resource to be created.
         */
        option: string;
    }

    export interface LinuxVirtualMachinePlan {
        /**
         * Specifies the Name of the Marketplace Image this Virtual Machine should be created from. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * Specifies the Product of the Marketplace Image this Virtual Machine should be created from. Changing this forces a new resource to be created.
         */
        product: string;
        /**
         * Specifies the Publisher of the Marketplace Image this Virtual Machine should be created from. Changing this forces a new resource to be created.
         */
        publisher: string;
    }

    export interface LinuxVirtualMachineScaleSetAdditionalCapabilities {
        /**
         * Should the capacity to enable Data Disks of the `UltraSSD_LRS` storage account type be supported on this Virtual Machine Scale Set? Defaults to `false`. Changing this forces a new resource to be created.
         */
        ultraSsdEnabled?: boolean;
    }

    export interface LinuxVirtualMachineScaleSetAdminSshKey {
        /**
         * The Public Key which should be used for authentication, which needs to be at least 2048-bit and in `ssh-rsa` format.
         */
        publicKey: string;
        /**
         * The Username for which this Public SSH Key should be configured.
         */
        username: string;
    }

    export interface LinuxVirtualMachineScaleSetAutomaticInstanceRepair {
        /**
         * Should the automatic instance repair be enabled on this Virtual Machine Scale Set?
         */
        enabled: boolean;
        /**
         * Amount of time (in minutes, between 30 and 90, defaults to 30 minutes) for which automatic repairs will be delayed. The grace period starts right after the VM is found unhealthy. The time duration should be specified in ISO 8601 format.
         */
        gracePeriod?: string;
    }

    export interface LinuxVirtualMachineScaleSetAutomaticOsUpgradePolicy {
        /**
         * Should automatic rollbacks be disabled?
         */
        disableAutomaticRollback: boolean;
        /**
         * Should OS Upgrades automatically be applied to Scale Set instances in a rolling fashion when a newer version of the OS Image becomes available?
         */
        enableAutomaticOsUpgrade: boolean;
    }

    export interface LinuxVirtualMachineScaleSetBootDiagnostics {
        /**
         * The Primary/Secondary Endpoint for the Azure Storage Account which should be used to store Boot Diagnostics, including Console Output and Screenshots from the Hypervisor.
         */
        storageAccountUri?: string;
    }

    export interface LinuxVirtualMachineScaleSetDataDisk {
        /**
         * The type of Caching which should be used for this Data Disk. Possible values are `None`, `ReadOnly` and `ReadWrite`.
         */
        caching: string;
        /**
         * The create option which should be used for this Data Disk. Possible values are `Empty` and `FromImage`. Defaults to `Empty`. (`FromImage` should only be used if the source image includes data disks).
         */
        createOption?: string;
        /**
         * The ID of the Disk Encryption Set which should be used to encrypt this Data Disk.
         */
        diskEncryptionSetId?: string;
        /**
         * Specifies the Read-Write IOPS for this Data Disk. Only settable for UltraSSD disks.
         */
        diskIopsReadWrite: number;
        /**
         * Specifies the bandwidth in MB per second for this Data Disk. Only settable for UltraSSD disks.
         */
        diskMbpsReadWrite: number;
        /**
         * The size of the Data Disk which should be created.
         */
        diskSizeGb: number;
        /**
         * The Logical Unit Number of the Data Disk, which must be unique within the Virtual Machine.
         */
        lun: number;
        /**
         * The Type of Storage Account which should back this Data Disk. Possible values include `Standard_LRS`, `StandardSSD_LRS`, `Premium_LRS` and `UltraSSD_LRS`.
         */
        storageAccountType: string;
        /**
         * Should Write Accelerator be enabled for this Data Disk? Defaults to `false`.
         */
        writeAcceleratorEnabled?: boolean;
    }

    export interface LinuxVirtualMachineScaleSetExtension {
        /**
         * Should the latest version of the Extension be used at Deployment Time, if one is available? This won't auto-update the extension on existing installation. Defaults to `true`.
         */
        autoUpgradeMinorVersion?: boolean;
        /**
         * A value which, when different to the previous value can be used to force-run the Extension even if the Extension Configuration hasn't changed.
         */
        forceUpdateTag?: string;
        /**
         * The name for the Virtual Machine Scale Set Extension.
         */
        name: string;
        /**
         * A JSON String which specifies Sensitive Settings (such as Passwords) for the Extension.
         */
        protectedSettings?: string;
        /**
         * An ordered list of Extension names which this should be provisioned after.
         */
        provisionAfterExtensions?: string[];
        /**
         * Specifies the Publisher of the Extension.
         */
        publisher: string;
        /**
         * A JSON String which specifies Settings for the Extension.
         */
        settings?: string;
        /**
         * Specifies the Type of the Extension.
         */
        type: string;
        /**
         * Specifies the version of the extension to use, available versions can be found using the Azure CLI.
         */
        typeHandlerVersion: string;
    }

    export interface LinuxVirtualMachineScaleSetIdentity {
        /**
         * A list of User Managed Identity ID's which should be assigned to the Linux Virtual Machine Scale Set.
         */
        identityIds?: string[];
        /**
         * The ID of the System Managed Service Principal.
         */
        principalId: string;
        /**
         * The type of Managed Identity which should be assigned to the Linux Virtual Machine Scale Set. Possible values are `SystemAssigned`, `UserAssigned` and `SystemAssigned, UserAssigned`.
         */
        type: string;
    }

    export interface LinuxVirtualMachineScaleSetNetworkInterface {
        /**
         * A list of IP Addresses of DNS Servers which should be assigned to the Network Interface.
         */
        dnsServers?: string[];
        /**
         * Does this Network Interface support Accelerated Networking? Defaults to `false`.
         */
        enableAcceleratedNetworking?: boolean;
        /**
         * Does this Network Interface support IP Forwarding? Defaults to `false`.
         */
        enableIpForwarding?: boolean;
        /**
         * One or more `ipConfiguration` blocks as defined above.
         */
        ipConfigurations: outputs.compute.LinuxVirtualMachineScaleSetNetworkInterfaceIpConfiguration[];
        /**
         * The Name which should be used for this Network Interface. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * The ID of a Network Security Group which should be assigned to this Network Interface.
         */
        networkSecurityGroupId?: string;
        /**
         * Is this the Primary IP Configuration?
         */
        primary?: boolean;
    }

    export interface LinuxVirtualMachineScaleSetNetworkInterfaceIpConfiguration {
        /**
         * A list of Backend Address Pools ID's from a Application Gateway which this Virtual Machine Scale Set should be connected to.
         */
        applicationGatewayBackendAddressPoolIds?: string[];
        /**
         * A list of Application Security Group ID's which this Virtual Machine Scale Set should be connected to.
         */
        applicationSecurityGroupIds?: string[];
        /**
         * A list of Backend Address Pools ID's from a Load Balancer which this Virtual Machine Scale Set should be connected to.
         */
        loadBalancerBackendAddressPoolIds?: string[];
        /**
         * A list of NAT Rule ID's from a Load Balancer which this Virtual Machine Scale Set should be connected to.
         */
        loadBalancerInboundNatRulesIds?: string[];
        /**
         * The Name which should be used for this IP Configuration.
         */
        name: string;
        /**
         * Is this the Primary IP Configuration for this Network Interface? Defaults to `false`.
         */
        primary?: boolean;
        /**
         * A `publicIpAddress` block as defined below.
         */
        publicIpAddresses?: outputs.compute.LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress[];
        /**
         * The ID of the Subnet which this IP Configuration should be connected to.
         */
        subnetId?: string;
        /**
         * The Internet Protocol Version which should be used for this IP Configuration. Possible values are `IPv4` and `IPv6`. Defaults to `IPv4`.
         */
        version?: string;
    }

    export interface LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress {
        /**
         * The Prefix which should be used for the Domain Name Label for each Virtual Machine Instance. Azure concatenates the Domain Name Label and Virtual Machine Index to create a unique Domain Name Label for each Virtual Machine.
         */
        domainNameLabel?: string;
        /**
         * The Idle Timeout in Minutes for the Public IP Address. Possible values are in the range `4` to `32`.
         */
        idleTimeoutInMinutes: number;
        /**
         * One or more `ipTag` blocks as defined above.
         */
        ipTags?: outputs.compute.LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTag[];
        /**
         * The Name of the Public IP Address Configuration.
         */
        name: string;
        /**
         * The ID of the Public IP Address Prefix from where Public IP Addresses should be allocated. Changing this forces a new resource to be created.
         */
        publicIpPrefixId?: string;
    }

    export interface LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTag {
        /**
         * The IP Tag associated with the Public IP, such as `SQL` or `Storage`.
         */
        tag: string;
        /**
         * The Type of IP Tag, such as `FirstPartyUsage`.
         */
        type: string;
    }

    export interface LinuxVirtualMachineScaleSetOsDisk {
        /**
         * The Type of Caching which should be used for the Internal OS Disk. Possible values are `None`, `ReadOnly` and `ReadWrite`.
         */
        caching: string;
        /**
         * A `diffDiskSettings` block as defined above. Changing this forces a new resource to be created.
         */
        diffDiskSettings?: outputs.compute.LinuxVirtualMachineScaleSetOsDiskDiffDiskSettings;
        /**
         * The ID of the Disk Encryption Set which should be used to encrypt this OS Disk.
         */
        diskEncryptionSetId?: string;
        /**
         * The Size of the Internal OS Disk in GB, if you wish to vary from the size used in the image this Virtual Machine Scale Set is sourced from.
         */
        diskSizeGb: number;
        /**
         * The Type of Storage Account which should back this the Internal OS Disk. Possible values include `Standard_LRS`, `StandardSSD_LRS` and `Premium_LRS`.
         */
        storageAccountType: string;
        /**
         * Should Write Accelerator be Enabled for this OS Disk? Defaults to `false`.
         */
        writeAcceleratorEnabled?: boolean;
    }

    export interface LinuxVirtualMachineScaleSetOsDiskDiffDiskSettings {
        option: string;
    }

    export interface LinuxVirtualMachineScaleSetPlan {
        /**
         * Specifies the name of the image from the marketplace. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * Specifies the product of the image from the marketplace. Changing this forces a new resource to be created.
         */
        product: string;
        /**
         * Specifies the publisher of the image. Changing this forces a new resource to be created.
         */
        publisher: string;
    }

    export interface LinuxVirtualMachineScaleSetRollingUpgradePolicy {
        /**
         * The maximum percent of total virtual machine instances that will be upgraded simultaneously by the rolling upgrade in one batch. As this is a maximum, unhealthy instances in previous or future batches can cause the percentage of instances in a batch to decrease to ensure higher reliability.
         */
        maxBatchInstancePercent: number;
        /**
         * The maximum percentage of the total virtual machine instances in the scale set that can be simultaneously unhealthy, either as a result of being upgraded, or by being found in an unhealthy state by the virtual machine health checks before the rolling upgrade aborts. This constraint will be checked prior to starting any batch.
         */
        maxUnhealthyInstancePercent: number;
        /**
         * The maximum percentage of upgraded virtual machine instances that can be found to be in an unhealthy state. This check will happen after each batch is upgraded. If this percentage is ever exceeded, the rolling update aborts.
         */
        maxUnhealthyUpgradedInstancePercent: number;
        /**
         * The wait time between completing the update for all virtual machines in one batch and starting the next batch. The time duration should be specified in ISO 8601 format.
         */
        pauseTimeBetweenBatches: string;
    }

    export interface LinuxVirtualMachineScaleSetSecret {
        /**
         * One or more `certificate` blocks as defined above.
         */
        certificates: outputs.compute.LinuxVirtualMachineScaleSetSecretCertificate[];
        /**
         * The ID of the Key Vault from which all Secrets should be sourced.
         */
        keyVaultId: string;
    }

    export interface LinuxVirtualMachineScaleSetSecretCertificate {
        /**
         * The Secret URL of a Key Vault Certificate.
         */
        url: string;
    }

    export interface LinuxVirtualMachineScaleSetSourceImageReference {
        /**
         * Specifies the offer of the image used to create the virtual machines.
         */
        offer: string;
        /**
         * Specifies the publisher of the image used to create the virtual machines.
         */
        publisher: string;
        /**
         * Specifies the SKU of the image used to create the virtual machines.
         */
        sku: string;
        /**
         * Specifies the version of the image used to create the virtual machines.
         */
        version: string;
    }

    export interface LinuxVirtualMachineScaleSetTerminateNotification {
        /**
         * Should the terminate notification be enabled on this Virtual Machine Scale Set? Defaults to `false`.
         */
        enabled: boolean;
        /**
         * Length of time (in minutes, between 5 and 15) a notification to be sent to the VM on the instance metadata server till the VM gets deleted. The time duration should be specified in ISO 8601 format.
         */
        timeout?: string;
    }

    export interface LinuxVirtualMachineSecret {
        /**
         * One or more `certificate` blocks as defined above.
         */
        certificates: outputs.compute.LinuxVirtualMachineSecretCertificate[];
        /**
         * The ID of the Key Vault from which all Secrets should be sourced.
         */
        keyVaultId: string;
    }

    export interface LinuxVirtualMachineSecretCertificate {
        /**
         * The Secret URL of a Key Vault Certificate.
         */
        url: string;
    }

    export interface LinuxVirtualMachineSourceImageReference {
        /**
         * Specifies the offer of the image used to create the virtual machines.
         */
        offer: string;
        /**
         * Specifies the publisher of the image used to create the virtual machines.
         */
        publisher: string;
        /**
         * Specifies the SKU of the image used to create the virtual machines.
         */
        sku: string;
        /**
         * Specifies the version of the image used to create the virtual machines.
         */
        version: string;
    }

    export interface ManagedDiskEncryptionSettings {
        /**
         * A `diskEncryptionKey` block as defined above.
         */
        diskEncryptionKey?: outputs.compute.ManagedDiskEncryptionSettingsDiskEncryptionKey;
        /**
         * Is Encryption enabled on this Managed Disk? Changing this forces a new resource to be created.
         */
        enabled: boolean;
        /**
         * A `keyEncryptionKey` block as defined below.
         */
        keyEncryptionKey?: outputs.compute.ManagedDiskEncryptionSettingsKeyEncryptionKey;
    }

    export interface ManagedDiskEncryptionSettingsDiskEncryptionKey {
        /**
         * The URL to the Key Vault Secret used as the Disk Encryption Key. This can be found as `id` on the `azure.keyvault.Secret` resource.
         */
        secretUrl: string;
        /**
         * The ID of the source Key Vault.
         */
        sourceVaultId: string;
    }

    export interface ManagedDiskEncryptionSettingsKeyEncryptionKey {
        /**
         * The URL to the Key Vault Key used as the Key Encryption Key. This can be found as `id` on the `azure.keyvault.Key` resource.
         */
        keyUrl: string;
        /**
         * The ID of the source Key Vault.
         */
        sourceVaultId: string;
    }

    export interface ScaleSetBootDiagnostics {
        enabled?: boolean;
        storageUri: string;
    }

    export interface ScaleSetExtension {
        /**
         * Specifies whether or not to use the latest minor version available.
         */
        autoUpgradeMinorVersion?: boolean;
        /**
         * Specifies the name of the extension.
         */
        name: string;
        /**
         * The protectedSettings passed to the extension, like settings, these are specified as a JSON object in a string.
         */
        protectedSettings?: string;
        /**
         * Specifies a dependency array of extensions required to be executed before, the array stores the name of each extension.
         */
        provisionAfterExtensions?: string[];
        /**
         * The publisher of the extension, available publishers can be found by using the Azure CLI.
         */
        publisher: string;
        /**
         * The settings passed to the extension, these are specified as a JSON object in a string.
         */
        settings?: string;
        /**
         * The type of extension, available types for a publisher can be found using the Azure CLI.
         */
        type: string;
        /**
         * Specifies the version of the extension to use, available versions can be found using the Azure CLI.
         */
        typeHandlerVersion: string;
    }

    export interface ScaleSetIdentity {
        /**
         * Specifies a list of user managed identity ids to be assigned to the VMSS. Required if `type` is `UserAssigned`.
         */
        identityIds?: string[];
        principalId: string;
        /**
         * Specifies the identity type to be assigned to the scale set. Allowable values are `SystemAssigned` and `UserAssigned`. For the `SystemAssigned` identity the scale set's Service Principal ID (SPN) can be retrieved after the scale set has been created. See [documentation](https://docs.microsoft.com/en-us/azure/active-directory/managed-service-identity/overview) for more information.
         */
        type: string;
    }

    export interface ScaleSetNetworkProfile {
        /**
         * Specifies whether to enable accelerated networking or not. Defaults to `false`.
         */
        acceleratedNetworking?: boolean;
        /**
         * A dnsSettings block as documented below.
         */
        dnsSettings?: outputs.compute.ScaleSetNetworkProfileDnsSettings;
        /**
         * An ipConfiguration block as documented below.
         */
        ipConfigurations: outputs.compute.ScaleSetNetworkProfileIpConfiguration[];
        /**
         * Whether IP forwarding is enabled on this NIC. Defaults to `false`.
         */
        ipForwarding?: boolean;
        /**
         * Specifies the name of the network interface configuration.
         */
        name: string;
        /**
         * Specifies the identifier for the network security group.
         */
        networkSecurityGroupId?: string;
        /**
         * Indicates whether network interfaces created from the network interface configuration will be the primary NIC of the VM.
         */
        primary: boolean;
    }

    export interface ScaleSetNetworkProfileDnsSettings {
        /**
         * Specifies an array of dns servers.
         */
        dnsServers: string[];
    }

    export interface ScaleSetNetworkProfileIpConfiguration {
        /**
         * Specifies an array of references to backend address pools of application gateways. A scale set can reference backend address pools of multiple application gateways. Multiple scale sets can use the same application gateway.
         */
        applicationGatewayBackendAddressPoolIds?: string[];
        /**
         * Specifies up to `20` application security group IDs.
         */
        applicationSecurityGroupIds?: string[];
        /**
         * Specifies an array of references to backend address pools of load balancers. A scale set can reference backend address pools of one public and one internal load balancer. Multiple scale sets cannot use the same load balancer.
         */
        loadBalancerBackendAddressPoolIds?: string[];
        /**
         * Specifies an array of references to inbound NAT pools for load balancers. A scale set can reference inbound nat pools of one public and one internal load balancer. Multiple scale sets cannot use the same load balancer.
         */
        loadBalancerInboundNatRulesIds: string[];
        /**
         * Specifies name of the IP configuration.
         */
        name: string;
        /**
         * Specifies if this ipConfiguration is the primary one.
         */
        primary: boolean;
        /**
         * Describes a virtual machines scale set IP Configuration's PublicIPAddress configuration. The publicIpAddressConfiguration is documented below.
         */
        publicIpAddressConfiguration?: outputs.compute.ScaleSetNetworkProfileIpConfigurationPublicIpAddressConfiguration;
        /**
         * Specifies the identifier of the subnet.
         */
        subnetId: string;
    }

    export interface ScaleSetNetworkProfileIpConfigurationPublicIpAddressConfiguration {
        /**
         * The domain name label for the dns settings.
         */
        domainNameLabel: string;
        /**
         * The idle timeout in minutes. This value must be between 4 and 30.
         */
        idleTimeout: number;
        /**
         * The name of the public ip address configuration
         */
        name: string;
    }

    export interface ScaleSetOsProfile {
        /**
         * Specifies the administrator password to use for all the instances of virtual machines in a scale set.
         */
        adminPassword?: string;
        /**
         * Specifies the administrator account name to use for all the instances of virtual machines in the scale set.
         */
        adminUsername: string;
        /**
         * Specifies the computer name prefix for all of the virtual machines in the scale set. Computer name prefixes must be 1 to 9 characters long for windows images and 1 - 58 for linux. Changing this forces a new resource to be created.
         */
        computerNamePrefix: string;
        /**
         * Specifies custom data to supply to the machine. On linux-based systems, this can be used as a cloud-init script. On other systems, this will be copied as a file on disk. Internally, this provider will base64 encode this value before sending it to the API. The maximum length of the binary array is 65535 bytes.
         */
        customData?: string;
    }

    export interface ScaleSetOsProfileLinuxConfig {
        /**
         * Specifies whether password authentication should be disabled. Defaults to `false`. Changing this forces a new resource to be created.
         */
        disablePasswordAuthentication?: boolean;
        /**
         * Specifies a collection of `path` and `keyData` to be placed on the virtual machine.
         */
        sshKeys?: outputs.compute.ScaleSetOsProfileLinuxConfigSshKey[];
    }

    export interface ScaleSetOsProfileLinuxConfigSshKey {
        keyData?: string;
        path: string;
    }

    export interface ScaleSetOsProfileSecret {
        /**
         * Specifies the key vault to use.
         */
        sourceVaultId: string;
        /**
         * A collection of Vault Certificates as documented below
         */
        vaultCertificates?: outputs.compute.ScaleSetOsProfileSecretVaultCertificate[];
    }

    export interface ScaleSetOsProfileSecretVaultCertificate {
        /**
         * Specifies the certificate store on the Virtual Machine where the certificate should be added to.
         */
        certificateStore?: string;
        /**
         * It is the Base64 encoding of a JSON Object that which is encoded in UTF-8 of which the contents need to be `data`, `dataType` and `password`.
         */
        certificateUrl: string;
    }

    export interface ScaleSetOsProfileWindowsConfig {
        /**
         * An Additional Unattended Config block as documented below.
         */
        additionalUnattendConfigs?: outputs.compute.ScaleSetOsProfileWindowsConfigAdditionalUnattendConfig[];
        /**
         * Indicates whether virtual machines in the scale set are enabled for automatic updates.
         */
        enableAutomaticUpgrades?: boolean;
        /**
         * Indicates whether virtual machine agent should be provisioned on the virtual machines in the scale set.
         */
        provisionVmAgent?: boolean;
        /**
         * A collection of WinRM configuration blocks as documented below.
         */
        winrms?: outputs.compute.ScaleSetOsProfileWindowsConfigWinrm[];
    }

    export interface ScaleSetOsProfileWindowsConfigAdditionalUnattendConfig {
        /**
         * Specifies the name of the component to configure with the added content. The only allowable value is `Microsoft-Windows-Shell-Setup`.
         */
        component: string;
        /**
         * Specifies the base-64 encoded XML formatted content that is added to the unattend.xml file for the specified path and component.
         */
        content: string;
        /**
         * Specifies the name of the pass that the content applies to. The only allowable value is `oobeSystem`.
         */
        pass: string;
        /**
         * Specifies the name of the setting to which the content applies. Possible values are: `FirstLogonCommands` and `AutoLogon`.
         */
        settingName: string;
    }

    export interface ScaleSetOsProfileWindowsConfigWinrm {
        /**
         * Specifies URL of the certificate with which new Virtual Machines is provisioned.
         */
        certificateUrl?: string;
        /**
         * Specifies the protocol of listener
         */
        protocol: string;
    }

    export interface ScaleSetPlan {
        /**
         * Specifies the name of the image from the marketplace.
         */
        name: string;
        /**
         * Specifies the product of the image from the marketplace.
         */
        product: string;
        /**
         * Specifies the publisher of the image.
         */
        publisher: string;
    }

    export interface ScaleSetRollingUpgradePolicy {
        /**
         * The maximum percent of total virtual machine instances that will be upgraded simultaneously by the rolling upgrade in one batch. As this is a maximum, unhealthy instances in previous or future batches can cause the percentage of instances in a batch to decrease to ensure higher reliability. Defaults to `20`.
         */
        maxBatchInstancePercent?: number;
        /**
         * The maximum percentage of the total virtual machine instances in the scale set that can be simultaneously unhealthy, either as a result of being upgraded, or by being found in an unhealthy state by the virtual machine health checks before the rolling upgrade aborts. This constraint will be checked prior to starting any batch. Defaults to `20`.
         */
        maxUnhealthyInstancePercent?: number;
        /**
         * The maximum percentage of upgraded virtual machine instances that can be found to be in an unhealthy state. This check will happen after each batch is upgraded. If this percentage is ever exceeded, the rolling update aborts. Defaults to `20`.
         */
        maxUnhealthyUpgradedInstancePercent?: number;
        /**
         * The wait time between completing the update for all virtual machines in one batch and starting the next batch. The time duration should be specified in ISO 8601 format for duration (https://en.wikipedia.org/wiki/ISO_8601#Durations). Defaults to `0` seconds represented as `PT0S`.
         */
        pauseTimeBetweenBatches?: string;
    }

    export interface ScaleSetSku {
        /**
         * Specifies the number of virtual machines in the scale set.
         */
        capacity: number;
        /**
         * Specifies the size of virtual machines in a scale set.
         */
        name: string;
        /**
         * Specifies the tier of virtual machines in a scale set. Possible values, `standard` or `basic`.
         */
        tier: string;
    }

    export interface ScaleSetStorageProfileDataDisk {
        /**
         * Specifies the caching requirements. Possible values include: `None` (default), `ReadOnly`, `ReadWrite`.
         */
        caching: string;
        /**
         * Specifies how the data disk should be created. The only possible options are `FromImage` and `Empty`.
         */
        createOption: string;
        /**
         * Specifies the size of the disk in GB. This element is required when creating an empty disk.
         */
        diskSizeGb: number;
        /**
         * Specifies the Logical Unit Number of the disk in each virtual machine in the scale set.
         */
        lun: number;
        /**
         * Specifies the type of managed disk to create. Value must be either `Standard_LRS`, `StandardSSD_LRS` or `Premium_LRS`.
         */
        managedDiskType: string;
    }

    export interface ScaleSetStorageProfileImageReference {
        /**
         * Specifies the ID of the (custom) image to use to create the virtual
         * machine scale set, as in the example below.
         */
        id?: string;
        /**
         * Specifies the offer of the image used to create the virtual machines.
         */
        offer?: string;
        /**
         * Specifies the publisher of the image used to create the virtual machines.
         */
        publisher?: string;
        /**
         * Specifies the SKU of the image used to create the virtual machines.
         */
        sku?: string;
        /**
         * Specifies the version of the image used to create the virtual machines.
         */
        version?: string;
    }

    export interface ScaleSetStorageProfileOsDisk {
        /**
         * Specifies the caching requirements. Possible values include: `None` (default), `ReadOnly`, `ReadWrite`.
         */
        caching: string;
        /**
         * Specifies how the virtual machine should be created. The only possible option is `FromImage`.
         */
        createOption: string;
        /**
         * Specifies the blob uri for user image. A virtual machine scale set creates an os disk in the same container as the user image.
         * Updating the osDisk image causes the existing disk to be deleted and a new one created with the new image. If the VM scale set is in Manual upgrade mode then the virtual machines are not updated until they have manualUpgrade applied to them.
         * When setting this field `osType` needs to be specified. Cannot be used when `vhdContainers`, `managedDiskType` or `storageProfileImageReference` are specified.
         */
        image?: string;
        /**
         * Specifies the type of managed disk to create. Value you must be either `Standard_LRS`, `StandardSSD_LRS` or `Premium_LRS`. Cannot be used when `vhdContainers` or `image` is specified.
         */
        managedDiskType: string;
        /**
         * Specifies the disk name. Must be specified when using unmanaged disk ('managed_disk_type' property not set).
         */
        name?: string;
        /**
         * Specifies the operating system Type, valid values are windows, linux.
         */
        osType?: string;
        /**
         * Specifies the vhd uri. Cannot be used when `image` or `managedDiskType` is specified.
         */
        vhdContainers?: string[];
    }

    export interface SharedImageIdentifier {
        /**
         * The Offer Name for this Shared Image.
         */
        offer: string;
        /**
         * The Publisher Name for this Gallery Image.
         */
        publisher: string;
        /**
         * The Name of the SKU for this Gallery Image.
         */
        sku: string;
    }

    export interface SharedImagePurchasePlan {
        /**
         * The Purchase Plan Name for this Shared Image. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * The Purchase Plan Product for this Gallery Image. Changing this forces a new resource to be created.
         */
        product?: string;
        /**
         * The Purchase Plan Publisher for this Gallery Image. Changing this forces a new resource to be created.
         */
        publisher?: string;
    }

    export interface SharedImageVersionTargetRegion {
        /**
         * The Azure Region in which this Image Version should exist.
         */
        name: string;
        /**
         * The number of replicas of the Image Version to be created per region.
         */
        regionalReplicaCount: number;
        /**
         * The storage account type for the image version. Possible values are `Standard_LRS` and `Standard_ZRS`. Defaults to `Standard_LRS`. You can store all of your image version replicas in Zone Redundant Storage by specifying `Standard_ZRS`.
         */
        storageAccountType?: string;
    }

    export interface SnapshotEncryptionSettings {
        diskEncryptionKey?: outputs.compute.SnapshotEncryptionSettingsDiskEncryptionKey;
        enabled: boolean;
        keyEncryptionKey?: outputs.compute.SnapshotEncryptionSettingsKeyEncryptionKey;
    }

    export interface SnapshotEncryptionSettingsDiskEncryptionKey {
        secretUrl: string;
        sourceVaultId: string;
    }

    export interface SnapshotEncryptionSettingsKeyEncryptionKey {
        keyUrl: string;
        sourceVaultId: string;
    }

    export interface VirtualMachineAdditionalCapabilities {
        /**
         * Should Ultra SSD disk be enabled for this Virtual Machine?
         */
        ultraSsdEnabled: boolean;
    }

    export interface VirtualMachineBootDiagnostics {
        /**
         * Should Boot Diagnostics be enabled for this Virtual Machine?
         */
        enabled: boolean;
        /**
         * The Storage Account's Blob Endpoint which should hold the virtual machine's diagnostic files.
         */
        storageUri: string;
    }

    export interface VirtualMachineIdentity {
        /**
         * Specifies a list of user managed identity ids to be assigned to the VM. Required if `type` is `UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID for the Service Principal associated with the Managed Service Identity of this Virtual Machine.
         */
        principalId: string;
        /**
         * The Managed Service Identity Type of this Virtual Machine. Possible values are `SystemAssigned` (where Azure will generate a Service Principal for you), `UserAssigned` (where you can specify the Service Principal ID's) to be used by this Virtual Machine using the `identityIds` field, and `SystemAssigned, UserAssigned` which assigns both a system managed identity as well as the specified user assigned identities.
         */
        type: string;
    }

    export interface VirtualMachineOsProfile {
        /**
         * The password associated with the local administrator account.
         */
        adminPassword?: string;
        /**
         * Specifies the name of the local administrator account.
         */
        adminUsername: string;
        /**
         * Specifies the name of the Virtual Machine.
         */
        computerName: string;
        /**
         * Specifies custom data to supply to the machine. On Linux-based systems, this can be used as a cloud-init script. On other systems, this will be copied as a file on disk. Internally, this provider will base64 encode this value before sending it to the API. The maximum length of the binary array is 65535 bytes.
         */
        customData: string;
    }

    export interface VirtualMachineOsProfileLinuxConfig {
        /**
         * Specifies whether password authentication should be disabled. If set to `false`, an `adminPassword` must be specified.
         */
        disablePasswordAuthentication: boolean;
        /**
         * One or more `sshKeys` blocks. This field is required if `disablePasswordAuthentication` is set to `true`.
         */
        sshKeys?: outputs.compute.VirtualMachineOsProfileLinuxConfigSshKey[];
    }

    export interface VirtualMachineOsProfileLinuxConfigSshKey {
        /**
         * The Public SSH Key which should be written to the `path` defined above.
         */
        keyData: string;
        /**
         * The path of the destination file on the virtual machine
         */
        path: string;
    }

    export interface VirtualMachineOsProfileSecret {
        /**
         * Specifies the ID of the Key Vault to use.
         */
        sourceVaultId: string;
        /**
         * One or more `vaultCertificates` blocks.
         */
        vaultCertificates?: outputs.compute.VirtualMachineOsProfileSecretVaultCertificate[];
    }

    export interface VirtualMachineOsProfileSecretVaultCertificate {
        /**
         * Specifies the certificate store on the Virtual Machine where the certificate should be added to, such as `My`.
         */
        certificateStore?: string;
        /**
         * The ID of the Key Vault Secret. Stored secret is the Base64 encoding of a JSON Object that which is encoded in UTF-8 of which the contents need to be:
         */
        certificateUrl: string;
    }

    export interface VirtualMachineOsProfileWindowsConfig {
        /**
         * A `additionalUnattendConfig` block.
         */
        additionalUnattendConfigs?: outputs.compute.VirtualMachineOsProfileWindowsConfigAdditionalUnattendConfig[];
        /**
         * Are automatic updates enabled on this Virtual Machine? Defaults to `false.`
         */
        enableAutomaticUpgrades?: boolean;
        /**
         * Should the Azure Virtual Machine Guest Agent be installed on this Virtual Machine? Defaults to `false`.
         */
        provisionVmAgent?: boolean;
        /**
         * Specifies the time zone of the virtual machine, [the possible values are defined here](http://jackstromberg.com/2017/01/list-of-time-zones-consumed-by-azure/).
         */
        timezone?: string;
        /**
         * One or more `winrm` block.
         */
        winrms?: outputs.compute.VirtualMachineOsProfileWindowsConfigWinrm[];
    }

    export interface VirtualMachineOsProfileWindowsConfigAdditionalUnattendConfig {
        /**
         * Specifies the name of the component to configure with the added content. The only allowable value is `Microsoft-Windows-Shell-Setup`.
         */
        component: string;
        /**
         * Specifies the base-64 encoded XML formatted content that is added to the unattend.xml file for the specified path and component.
         */
        content: string;
        /**
         * Specifies the name of the pass that the content applies to. The only allowable value is `oobeSystem`.
         */
        pass: string;
        /**
         * Specifies the name of the setting to which the content applies. Possible values are: `FirstLogonCommands` and `AutoLogon`.
         */
        settingName: string;
    }

    export interface VirtualMachineOsProfileWindowsConfigWinrm {
        /**
         * The ID of the Key Vault Secret which contains the encrypted Certificate which should be installed on the Virtual Machine. This certificate must also be specified in the `vaultCertificates` block within the `osProfileSecrets` block.
         */
        certificateUrl?: string;
        /**
         * Specifies the protocol of listener. Possible values are `HTTP` or `HTTPS`.
         */
        protocol: string;
    }

    export interface VirtualMachinePlan {
        /**
         * Specifies the name of the image from the marketplace.
         */
        name: string;
        /**
         * Specifies the product of the image from the marketplace.
         */
        product: string;
        /**
         * Specifies the publisher of the image.
         */
        publisher: string;
    }

    export interface VirtualMachineStorageDataDisk {
        /**
         * Specifies the caching requirements for the Data Disk. Possible values include `None`, `ReadOnly` and `ReadWrite`.
         */
        caching: string;
        /**
         * Specifies how the data disk should be created. Possible values are `Attach`, `FromImage` and `Empty`.
         */
        createOption: string;
        /**
         * Specifies the size of the data disk in gigabytes.
         */
        diskSizeGb: number;
        /**
         * Specifies the logical unit number of the data disk. This needs to be unique within all the Data Disks on the Virtual Machine.
         */
        lun: number;
        /**
         * Specifies the ID of an Existing Managed Disk which should be attached to this Virtual Machine. When this field is set `createOption` must be set to `Attach`.
         */
        managedDiskId: string;
        /**
         * Specifies the type of managed disk to create. Possible values are either `Standard_LRS`, `StandardSSD_LRS`, `Premium_LRS` or `UltraSSD_LRS`.
         */
        managedDiskType: string;
        /**
         * The name of the Data Disk.
         */
        name: string;
        /**
         * Specifies the URI of the VHD file backing this Unmanaged Data Disk. Changing this forces a new resource to be created.
         */
        vhdUri?: string;
        /**
         * Specifies if Write Accelerator is enabled on the disk. This can only be enabled on `Premium_LRS` managed disks with no caching and [M-Series VMs](https://docs.microsoft.com/en-us/azure/virtual-machines/workloads/sap/how-to-enable-write-accelerator). Defaults to `false`.
         */
        writeAcceleratorEnabled?: boolean;
    }

    export interface VirtualMachineStorageImageReference {
        /**
         * Specifies the ID of the Custom Image which the Virtual Machine should be created from. Changing this forces a new resource to be created.
         */
        id?: string;
        /**
         * Specifies the offer of the image used to create the virtual machine. Changing this forces a new resource to be created.
         */
        offer?: string;
        /**
         * Specifies the publisher of the image used to create the virtual machine. Changing this forces a new resource to be created.
         */
        publisher?: string;
        /**
         * Specifies the SKU of the image used to create the virtual machine. Changing this forces a new resource to be created.
         */
        sku?: string;
        /**
         * Specifies the version of the image used to create the virtual machine. Changing this forces a new resource to be created.
         */
        version: string;
    }

    export interface VirtualMachineStorageOsDisk {
        /**
         * Specifies the caching requirements for the OS Disk. Possible values include `None`, `ReadOnly` and `ReadWrite`.
         */
        caching: string;
        /**
         * Specifies how the OS Disk should be created. Possible values are `Attach` (managed disks only) and `FromImage`.
         */
        createOption: string;
        /**
         * Specifies the size of the OS Disk in gigabytes.
         */
        diskSizeGb: number;
        /**
         * Specifies the Image URI in the format `publisherName:offer:skus:version`. This field can also specify the [VHD uri](https://azure.microsoft.com/en-us/documentation/articles/virtual-machines-linux-cli-deploy-templates/#create-a-custom-vm-image) of a custom VM image to clone. When cloning a Custom (Unmanaged) Disk Image the `osType` field must be set.
         */
        imageUri?: string;
        /**
         * Specifies the ID of an existing Managed Disk which should be attached as the OS Disk of this Virtual Machine. If this is set then the `createOption` must be set to `Attach`.
         */
        managedDiskId: string;
        /**
         * Specifies the type of Managed Disk which should be created. Possible values are `Standard_LRS`, `StandardSSD_LRS` or `Premium_LRS`.
         */
        managedDiskType: string;
        /**
         * Specifies the name of the OS Disk.
         */
        name: string;
        /**
         * Specifies the Operating System on the OS Disk. Possible values are `Linux` and `Windows`.
         */
        osType: string;
        /**
         * Specifies the URI of the VHD file backing this Unmanaged OS Disk. Changing this forces a new resource to be created.
         */
        vhdUri?: string;
        /**
         * Specifies if Write Accelerator is enabled on the disk. This can only be enabled on `Premium_LRS` managed disks with no caching and [M-Series VMs](https://docs.microsoft.com/en-us/azure/virtual-machines/workloads/sap/how-to-enable-write-accelerator). Defaults to `false`.
         */
        writeAcceleratorEnabled?: boolean;
    }

    export interface WindowsVirtualMachineAdditionalCapabilities {
        /**
         * Should the capacity to enable Data Disks of the `UltraSSD_LRS` storage account type be supported on this Virtual Machine? Defaults to `false`.
         */
        ultraSsdEnabled?: boolean;
    }

    export interface WindowsVirtualMachineAdditionalUnattendContent {
        /**
         * The XML formatted content that is added to the unattend.xml file for the specified path and component. Changing this forces a new resource to be created.
         */
        content: string;
        /**
         * The name of the setting to which the content applies. Possible values are `AutoLogon` and `FirstLogonCommands`. Changing this forces a new resource to be created.
         */
        setting: string;
    }

    export interface WindowsVirtualMachineBootDiagnostics {
        /**
         * The Primary/Secondary Endpoint for the Azure Storage Account which should be used to store Boot Diagnostics, including Console Output and Screenshots from the Hypervisor.
         */
        storageAccountUri?: string;
    }

    export interface WindowsVirtualMachineIdentity {
        /**
         * A list of User Managed Identity ID's which should be assigned to the Windows Virtual Machine.
         */
        identityIds?: string[];
        /**
         * The ID of the System Managed Service Principal.
         */
        principalId: string;
        /**
         * The ID of the Tenant the System Managed Service Principal is assigned in.
         */
        tenantId: string;
        /**
         * The type of Managed Identity which should be assigned to the Windows Virtual Machine. Possible values are `SystemAssigned`, `UserAssigned` and `SystemAssigned, UserAssigned`.
         */
        type: string;
    }

    export interface WindowsVirtualMachineOsDisk {
        /**
         * The Type of Caching which should be used for the Internal OS Disk. Possible values are `None`, `ReadOnly` and `ReadWrite`.
         */
        caching: string;
        /**
         * A `diffDiskSettings` block as defined above.
         */
        diffDiskSettings?: outputs.compute.WindowsVirtualMachineOsDiskDiffDiskSettings;
        /**
         * The ID of the Disk Encryption Set which should be used to Encrypt this OS Disk.
         */
        diskEncryptionSetId?: string;
        /**
         * The Size of the Internal OS Disk in GB, if you wish to vary from the size used in the image this Virtual Machine is sourced from.
         */
        diskSizeGb: number;
        /**
         * The name which should be used for the Internal OS Disk. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * The Type of Storage Account which should back this the Internal OS Disk. Possible values are `Standard_LRS`, `StandardSSD_LRS` and `Premium_LRS`. Changing this forces a new resource to be created.
         */
        storageAccountType: string;
        /**
         * Should Write Accelerator be Enabled for this OS Disk? Defaults to `false`.
         */
        writeAcceleratorEnabled?: boolean;
    }

    export interface WindowsVirtualMachineOsDiskDiffDiskSettings {
        /**
         * Specifies the Ephemeral Disk Settings for the OS Disk. At this time the only possible value is `Local`. Changing this forces a new resource to be created.
         */
        option: string;
    }

    export interface WindowsVirtualMachinePlan {
        /**
         * Specifies the Name of the Marketplace Image this Virtual Machine should be created from. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * Specifies the Product of the Marketplace Image this Virtual Machine should be created from. Changing this forces a new resource to be created.
         */
        product: string;
        /**
         * Specifies the Publisher of the Marketplace Image this Virtual Machine should be created from. Changing this forces a new resource to be created.
         */
        publisher: string;
    }

    export interface WindowsVirtualMachineScaleSetAdditionalCapabilities {
        /**
         * Should the capacity to enable Data Disks of the `UltraSSD_LRS` storage account type be supported on this Virtual Machine Scale Set? Defaults to `false`. Changing this forces a new resource to be created.
         */
        ultraSsdEnabled?: boolean;
    }

    export interface WindowsVirtualMachineScaleSetAdditionalUnattendContent {
        /**
         * The XML formatted content that is added to the unattend.xml file for the specified path and component. Changing this forces a new resource to be created.
         */
        content: string;
        /**
         * The name of the setting to which the content applies. Possible values are `AutoLogon` and `FirstLogonCommands`. Changing this forces a new resource to be created.
         */
        setting: string;
    }

    export interface WindowsVirtualMachineScaleSetAutomaticInstanceRepair {
        /**
         * Should the automatic instance repair be enabled on this Virtual Machine Scale Set?
         */
        enabled: boolean;
        /**
         * Amount of time (in minutes, between 30 and 90, defaults to 30 minutes) for which automatic repairs will be delayed. The grace period starts right after the VM is found unhealthy. The time duration should be specified in ISO 8601 format.
         */
        gracePeriod?: string;
    }

    export interface WindowsVirtualMachineScaleSetAutomaticOsUpgradePolicy {
        /**
         * Should automatic rollbacks be disabled?
         */
        disableAutomaticRollback: boolean;
        /**
         * Should OS Upgrades automatically be applied to Scale Set instances in a rolling fashion when a newer version of the OS Image becomes available?
         */
        enableAutomaticOsUpgrade: boolean;
    }

    export interface WindowsVirtualMachineScaleSetBootDiagnostics {
        /**
         * The Primary/Secondary Endpoint for the Azure Storage Account which should be used to store Boot Diagnostics, including Console Output and Screenshots from the Hypervisor.
         */
        storageAccountUri?: string;
    }

    export interface WindowsVirtualMachineScaleSetDataDisk {
        /**
         * The type of Caching which should be used for this Data Disk. Possible values are `None`, `ReadOnly` and `ReadWrite`.
         */
        caching: string;
        /**
         * The create option which should be used for this Data Disk. Possible values are `Empty` and `FromImage`. Defaults to `Empty`. (`FromImage` should only be used if the source image includes data disks).
         */
        createOption?: string;
        /**
         * The ID of the Disk Encryption Set which should be used to encrypt this Data Disk.
         */
        diskEncryptionSetId?: string;
        /**
         * Specifies the Read-Write IOPS for this Data Disk. Only settable for UltraSSD disks.
         */
        diskIopsReadWrite: number;
        /**
         * Specifies the bandwidth in MB per second for this Data Disk. Only settable for UltraSSD disks.
         */
        diskMbpsReadWrite: number;
        /**
         * The size of the Data Disk which should be created.
         */
        diskSizeGb: number;
        /**
         * The Logical Unit Number of the Data Disk, which must be unique within the Virtual Machine.
         */
        lun: number;
        /**
         * The Type of Storage Account which should back this Data Disk. Possible values include `Standard_LRS`, `StandardSSD_LRS`, `Premium_LRS` and `UltraSSD_LRS`.
         */
        storageAccountType: string;
        /**
         * Should Write Accelerator be enabled for this Data Disk? Defaults to `false`.
         */
        writeAcceleratorEnabled?: boolean;
    }

    export interface WindowsVirtualMachineScaleSetExtension {
        /**
         * Should the latest version of the Extension be used at Deployment Time, if one is available? This won't auto-update the extension on existing installation. Defaults to `true`.
         */
        autoUpgradeMinorVersion?: boolean;
        /**
         * A value which, when different to the previous value can be used to force-run the Extension even if the Extension Configuration hasn't changed.
         */
        forceUpdateTag?: string;
        /**
         * The name for the Virtual Machine Scale Set Extension.
         */
        name: string;
        /**
         * A JSON String which specifies Sensitive Settings (such as Passwords) for the Extension.
         */
        protectedSettings?: string;
        /**
         * An ordered list of Extension names which this should be provisioned after.
         */
        provisionAfterExtensions?: string[];
        /**
         * Specifies the Publisher of the Extension.
         */
        publisher: string;
        /**
         * A JSON String which specifies Settings for the Extension.
         */
        settings?: string;
        /**
         * Specifies the Type of the Extension.
         */
        type: string;
        /**
         * Specifies the version of the extension to use, available versions can be found using the Azure CLI.
         */
        typeHandlerVersion: string;
    }

    export interface WindowsVirtualMachineScaleSetIdentity {
        /**
         * A list of User Managed Identity ID's which should be assigned to the Windows Virtual Machine Scale Set.
         */
        identityIds?: string[];
        /**
         * The ID of the System Managed Service Principal.
         */
        principalId: string;
        /**
         * The type of Managed Identity which should be assigned to the Windows Virtual Machine Scale Set. Possible values are `SystemAssigned`, `UserAssigned` and `SystemAssigned, UserAssigned`.
         */
        type: string;
    }

    export interface WindowsVirtualMachineScaleSetNetworkInterface {
        /**
         * A list of IP Addresses of DNS Servers which should be assigned to the Network Interface.
         */
        dnsServers?: string[];
        /**
         * Does this Network Interface support Accelerated Networking? Defaults to `false`.
         */
        enableAcceleratedNetworking?: boolean;
        /**
         * Does this Network Interface support IP Forwarding? Defaults to `false`.
         */
        enableIpForwarding?: boolean;
        /**
         * One or more `ipConfiguration` blocks as defined above.
         */
        ipConfigurations: outputs.compute.WindowsVirtualMachineScaleSetNetworkInterfaceIpConfiguration[];
        /**
         * The Name which should be used for this Network Interface. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * The ID of a Network Security Group which should be assigned to this Network Interface.
         */
        networkSecurityGroupId?: string;
        /**
         * Is this the Primary IP Configuration?
         */
        primary?: boolean;
    }

    export interface WindowsVirtualMachineScaleSetNetworkInterfaceIpConfiguration {
        /**
         * A list of Backend Address Pools ID's from a Application Gateway which this Virtual Machine Scale Set should be connected to.
         */
        applicationGatewayBackendAddressPoolIds?: string[];
        /**
         * A list of Application Security Group ID's which this Virtual Machine Scale Set should be connected to.
         */
        applicationSecurityGroupIds?: string[];
        /**
         * A list of Backend Address Pools ID's from a Load Balancer which this Virtual Machine Scale Set should be connected to.
         */
        loadBalancerBackendAddressPoolIds?: string[];
        /**
         * A list of NAT Rule ID's from a Load Balancer which this Virtual Machine Scale Set should be connected to.
         */
        loadBalancerInboundNatRulesIds?: string[];
        /**
         * The Name which should be used for this IP Configuration.
         */
        name: string;
        /**
         * Is this the Primary IP Configuration for this Network Interface? Defaults to `false`.
         */
        primary?: boolean;
        /**
         * A `publicIpAddress` block as defined below.
         */
        publicIpAddresses?: outputs.compute.WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress[];
        /**
         * The ID of the Subnet which this IP Configuration should be connected to.
         */
        subnetId?: string;
        /**
         * The Internet Protocol Version which should be used for this IP Configuration. Possible values are `IPv4` and `IPv6`. Defaults to `IPv4`.
         */
        version?: string;
    }

    export interface WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress {
        /**
         * The Prefix which should be used for the Domain Name Label for each Virtual Machine Instance. Azure concatenates the Domain Name Label and Virtual Machine Index to create a unique Domain Name Label for each Virtual Machine.
         */
        domainNameLabel?: string;
        /**
         * The Idle Timeout in Minutes for the Public IP Address. Possible values are in the range `4` to `32`.
         */
        idleTimeoutInMinutes: number;
        /**
         * One or more `ipTag` blocks as defined above.
         */
        ipTags?: outputs.compute.WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTag[];
        /**
         * The Name of the Public IP Address Configuration.
         */
        name: string;
        /**
         * The ID of the Public IP Address Prefix from where Public IP Addresses should be allocated. Changing this forces a new resource to be created.
         */
        publicIpPrefixId?: string;
    }

    export interface WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTag {
        /**
         * The IP Tag associated with the Public IP, such as `SQL` or `Storage`.
         */
        tag: string;
        /**
         * The Type of IP Tag, such as `FirstPartyUsage`.
         */
        type: string;
    }

    export interface WindowsVirtualMachineScaleSetOsDisk {
        /**
         * The Type of Caching which should be used for the Internal OS Disk. Possible values are `None`, `ReadOnly` and `ReadWrite`.
         */
        caching: string;
        /**
         * A `diffDiskSettings` block as defined above. Changing this forces a new resource to be created.
         */
        diffDiskSettings?: outputs.compute.WindowsVirtualMachineScaleSetOsDiskDiffDiskSettings;
        /**
         * The ID of the Disk Encryption Set which should be used to encrypt this OS Disk.
         */
        diskEncryptionSetId?: string;
        /**
         * The Size of the Internal OS Disk in GB, if you wish to vary from the size used in the image this Virtual Machine Scale Set is sourced from.
         */
        diskSizeGb: number;
        /**
         * The Type of Storage Account which should back this the Internal OS Disk. Possible values include `Standard_LRS`, `StandardSSD_LRS` and `Premium_LRS`.
         */
        storageAccountType: string;
        /**
         * Should Write Accelerator be Enabled for this OS Disk? Defaults to `false`.
         */
        writeAcceleratorEnabled?: boolean;
    }

    export interface WindowsVirtualMachineScaleSetOsDiskDiffDiskSettings {
        option: string;
    }

    export interface WindowsVirtualMachineScaleSetPlan {
        /**
         * Specifies the name of the image from the marketplace. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * Specifies the product of the image from the marketplace. Changing this forces a new resource to be created.
         */
        product: string;
        /**
         * Specifies the publisher of the image. Changing this forces a new resource to be created.
         */
        publisher: string;
    }

    export interface WindowsVirtualMachineScaleSetRollingUpgradePolicy {
        /**
         * The maximum percent of total virtual machine instances that will be upgraded simultaneously by the rolling upgrade in one batch. As this is a maximum, unhealthy instances in previous or future batches can cause the percentage of instances in a batch to decrease to ensure higher reliability.
         */
        maxBatchInstancePercent: number;
        /**
         * The maximum percentage of the total virtual machine instances in the scale set that can be simultaneously unhealthy, either as a result of being upgraded, or by being found in an unhealthy state by the virtual machine health checks before the rolling upgrade aborts. This constraint will be checked prior to starting any batch.
         */
        maxUnhealthyInstancePercent: number;
        /**
         * The maximum percentage of upgraded virtual machine instances that can be found to be in an unhealthy state. This check will happen after each batch is upgraded. If this percentage is ever exceeded, the rolling update aborts.
         */
        maxUnhealthyUpgradedInstancePercent: number;
        /**
         * The wait time between completing the update for all virtual machines in one batch and starting the next batch. The time duration should be specified in ISO 8601 format.
         */
        pauseTimeBetweenBatches: string;
    }

    export interface WindowsVirtualMachineScaleSetSecret {
        /**
         * One or more `certificate` blocks as defined above.
         */
        certificates: outputs.compute.WindowsVirtualMachineScaleSetSecretCertificate[];
        /**
         * The ID of the Key Vault from which all Secrets should be sourced.
         */
        keyVaultId: string;
    }

    export interface WindowsVirtualMachineScaleSetSecretCertificate {
        /**
         * The certificate store on the Virtual Machine where the certificate should be added.
         */
        store: string;
        /**
         * The Secret URL of a Key Vault Certificate.
         */
        url: string;
    }

    export interface WindowsVirtualMachineScaleSetSourceImageReference {
        /**
         * Specifies the offer of the image used to create the virtual machines.
         */
        offer: string;
        /**
         * Specifies the publisher of the image used to create the virtual machines.
         */
        publisher: string;
        /**
         * Specifies the SKU of the image used to create the virtual machines.
         */
        sku: string;
        /**
         * Specifies the version of the image used to create the virtual machines.
         */
        version: string;
    }

    export interface WindowsVirtualMachineScaleSetTerminateNotification {
        /**
         * Should the terminate notification be enabled on this Virtual Machine Scale Set? Defaults to `false`.
         */
        enabled: boolean;
        /**
         * Length of time (in minutes, between 5 and 15) a notification to be sent to the VM on the instance metadata server till the VM gets deleted. The time duration should be specified in ISO 8601 format.
         */
        timeout?: string;
    }

    export interface WindowsVirtualMachineScaleSetWinrmListener {
        /**
         * The Secret URL of a Key Vault Certificate, which must be specified when `protocol` is set to `Https`.
         */
        certificateUrl?: string;
        /**
         * The Protocol of the WinRM Listener. Possible values are `Http` and `Https`.
         */
        protocol: string;
    }

    export interface WindowsVirtualMachineSecret {
        /**
         * One or more `certificate` blocks as defined above.
         */
        certificates: outputs.compute.WindowsVirtualMachineSecretCertificate[];
        /**
         * The ID of the Key Vault from which all Secrets should be sourced.
         */
        keyVaultId: string;
    }

    export interface WindowsVirtualMachineSecretCertificate {
        /**
         * The certificate store on the Virtual Machine where the certificate should be added.
         */
        store: string;
        /**
         * The Secret URL of a Key Vault Certificate.
         */
        url: string;
    }

    export interface WindowsVirtualMachineSourceImageReference {
        /**
         * Specifies the offer of the image used to create the virtual machines.
         */
        offer: string;
        /**
         * Specifies the publisher of the image used to create the virtual machines.
         */
        publisher: string;
        /**
         * Specifies the SKU of the image used to create the virtual machines.
         */
        sku: string;
        /**
         * Specifies the version of the image used to create the virtual machines.
         */
        version: string;
    }

    export interface WindowsVirtualMachineWinrmListener {
        /**
         * The Secret URL of a Key Vault Certificate, which must be specified when `protocol` is set to `Https`.
         */
        certificateUrl?: string;
        protocol: string;
    }

}

export namespace config {
    export interface Features {
        cognitiveAccount?: outputs.config.FeaturesCognitiveAccount;
        keyVault?: outputs.config.FeaturesKeyVault;
        logAnalyticsWorkspace?: outputs.config.FeaturesLogAnalyticsWorkspace;
        network?: outputs.config.FeaturesNetwork;
        templateDeployment?: outputs.config.FeaturesTemplateDeployment;
        virtualMachine?: outputs.config.FeaturesVirtualMachine;
        virtualMachineScaleSet?: outputs.config.FeaturesVirtualMachineScaleSet;
    }

    export interface FeaturesCognitiveAccount {
        purgeSoftDeleteOnDestroy?: boolean;
    }

    export interface FeaturesKeyVault {
        purgeSoftDeleteOnDestroy?: boolean;
        recoverSoftDeletedKeyVaults?: boolean;
    }

    export interface FeaturesLogAnalyticsWorkspace {
        permanentlyDeleteOnDestroy: boolean;
    }

    export interface FeaturesNetwork {
        relaxedLocking: boolean;
    }

    export interface FeaturesTemplateDeployment {
        deleteNestedItemsDuringDeletion: boolean;
    }

    export interface FeaturesVirtualMachine {
        deleteOsDiskOnDeletion?: boolean;
        gracefulShutdown?: boolean;
        skipShutdownAndForceDelete?: boolean;
    }

    export interface FeaturesVirtualMachineScaleSet {
        forceDelete?: boolean;
        rollInstancesWhenRequired: boolean;
    }

}

export namespace consumption {
    export interface BudgetResourceGroupFilter {
        /**
         * One or more `dimension` blocks as defined below to filter the budget on.
         */
        dimensions?: outputs.consumption.BudgetResourceGroupFilterDimension[];
        /**
         * A `not` block as defined below to filter the budget on.
         */
        not?: outputs.consumption.BudgetResourceGroupFilterNot;
        /**
         * One or more `tag` blocks as defined below to filter the budget on.
         */
        tags?: outputs.consumption.BudgetResourceGroupFilterTag[];
    }

    export interface BudgetResourceGroupFilterDimension {
        /**
         * The name of the column to use for the filter. The allowed values are `ChargeType`, `Frequency`, `InvoiceId`, `Meter`, `MeterCategory`, `MeterSubCategory`, `PartNumber`, `PricingModel`, `Product`, `ProductOrderId`, `ProductOrderName`, `PublisherType`, `ReservationId`, `ReservationName`, `ResourceGroupName`, `ResourceGuid`, `ResourceId`, `ResourceLocation`, `ResourceType`, `ServiceFamily`, `ServiceName`, `UnitOfMeasure`.
         */
        name: string;
        /**
         * The operator to use for comparison. The allowed values are `In`.
         */
        operator?: string;
        /**
         * Specifies a list of values for the column.
         */
        values: string[];
    }

    export interface BudgetResourceGroupFilterNot {
        /**
         * One `dimension` block as defined below to filter the budget on. Conflicts with `tag`.
         */
        dimension?: outputs.consumption.BudgetResourceGroupFilterNotDimension;
        /**
         * One `tag` block as defined below to filter the budget on. Conflicts with `dimension`.
         */
        tag?: outputs.consumption.BudgetResourceGroupFilterNotTag;
    }

    export interface BudgetResourceGroupFilterNotDimension {
        /**
         * The name of the column to use for the filter. The allowed values are `ChargeType`, `Frequency`, `InvoiceId`, `Meter`, `MeterCategory`, `MeterSubCategory`, `PartNumber`, `PricingModel`, `Product`, `ProductOrderId`, `ProductOrderName`, `PublisherType`, `ReservationId`, `ReservationName`, `ResourceGroupName`, `ResourceGuid`, `ResourceId`, `ResourceLocation`, `ResourceType`, `ServiceFamily`, `ServiceName`, `UnitOfMeasure`.
         */
        name: string;
        /**
         * The operator to use for comparison. The allowed values are `In`.
         */
        operator?: string;
        /**
         * Specifies a list of values for the column.
         */
        values: string[];
    }

    export interface BudgetResourceGroupFilterNotTag {
        /**
         * The name of the tag to use for the filter.
         */
        name: string;
        /**
         * The operator to use for comparison. The allowed values are `In`.
         */
        operator?: string;
        /**
         * Specifies a list of values for the tag.
         */
        values: string[];
    }

    export interface BudgetResourceGroupFilterTag {
        /**
         * The name of the tag to use for the filter.
         */
        name: string;
        /**
         * The operator to use for comparison. The allowed values are `In`.
         */
        operator?: string;
        /**
         * Specifies a list of values for the tag.
         */
        values: string[];
    }

    export interface BudgetResourceGroupNotification {
        /**
         * Specifies a list of email addresses to send the budget notification to when the threshold is exceeded.
         */
        contactEmails?: string[];
        /**
         * Specifies a list of Action Group IDs to send the budget notification to when the threshold is exceeded.
         */
        contactGroups?: string[];
        /**
         * Specifies a list of contact roles to send the budget notification to when the threshold is exceeded.
         */
        contactRoles?: string[];
        /**
         * Should the notification be enabled?
         */
        enabled?: boolean;
        /**
         * The comparison operator for the notification. Must be one of `EqualTo`, `GreaterThan`, or `GreaterThanOrEqualTo`.
         */
        operator: string;
        /**
         * Threshold value associated with a notification. Notification is sent when the cost exceeded the threshold. It is always percent and has to be between 0 and 1000.
         */
        threshold: number;
    }

    export interface BudgetResourceGroupTimePeriod {
        /**
         * The end date for the budget. If not set this will be 10 years after the start date.
         */
        endDate: string;
        /**
         * The start date for the budget. The start date must be first of the month and should be less than the end date. Budget start date must be on or after June 1, 2017. Future start date should not be more than twelve months. Past start date should be selected within the timegrain period. Changing this forces a new Resource Group Consumption Budget to be created.
         */
        startDate: string;
    }

    export interface BudgetSubscriptionFilter {
        /**
         * One or more `dimension` blocks as defined below to filter the budget on.
         */
        dimensions?: outputs.consumption.BudgetSubscriptionFilterDimension[];
        /**
         * A `not` block as defined below to filter the budget on.
         */
        not?: outputs.consumption.BudgetSubscriptionFilterNot;
        /**
         * One or more `tag` blocks as defined below to filter the budget on.
         */
        tags?: outputs.consumption.BudgetSubscriptionFilterTag[];
    }

    export interface BudgetSubscriptionFilterDimension {
        /**
         * The name of the column to use for the filter. The allowed values are `ChargeType`, `Frequency`, `InvoiceId`, `Meter`, `MeterCategory`, `MeterSubCategory`, `PartNumber`, `PricingModel`, `Product`, `ProductOrderId`, `ProductOrderName`, `PublisherType`, `ReservationId`, `ReservationName`, `ResourceGroupName`, `ResourceGuid`, `ResourceId`, `ResourceLocation`, `ResourceType`, `ServiceFamily`, `ServiceName`, `UnitOfMeasure`.
         */
        name: string;
        /**
         * The operator to use for comparison. The allowed values are `In`.
         */
        operator?: string;
        /**
         * Specifies a list of values for the column.
         */
        values: string[];
    }

    export interface BudgetSubscriptionFilterNot {
        /**
         * One `dimension` block as defined below to filter the budget on. Conflicts with `tag`.
         */
        dimension?: outputs.consumption.BudgetSubscriptionFilterNotDimension;
        /**
         * One `tag` block as defined below to filter the budget on. Conflicts with `dimension`.
         */
        tag?: outputs.consumption.BudgetSubscriptionFilterNotTag;
    }

    export interface BudgetSubscriptionFilterNotDimension {
        /**
         * The name of the column to use for the filter. The allowed values are `ChargeType`, `Frequency`, `InvoiceId`, `Meter`, `MeterCategory`, `MeterSubCategory`, `PartNumber`, `PricingModel`, `Product`, `ProductOrderId`, `ProductOrderName`, `PublisherType`, `ReservationId`, `ReservationName`, `ResourceGroupName`, `ResourceGuid`, `ResourceId`, `ResourceLocation`, `ResourceType`, `ServiceFamily`, `ServiceName`, `UnitOfMeasure`.
         */
        name: string;
        /**
         * The operator to use for comparison. The allowed values are `In`.
         */
        operator?: string;
        /**
         * Specifies a list of values for the column.
         */
        values: string[];
    }

    export interface BudgetSubscriptionFilterNotTag {
        /**
         * The name of the tag to use for the filter.
         */
        name: string;
        /**
         * The operator to use for comparison. The allowed values are `In`.
         */
        operator?: string;
        /**
         * Specifies a list of values for the tag.
         */
        values: string[];
    }

    export interface BudgetSubscriptionFilterTag {
        /**
         * The name of the tag to use for the filter.
         */
        name: string;
        /**
         * The operator to use for comparison. The allowed values are `In`.
         */
        operator?: string;
        /**
         * Specifies a list of values for the tag.
         */
        values: string[];
    }

    export interface BudgetSubscriptionNotification {
        /**
         * Specifies a list of email addresses to send the budget notification to when the threshold is exceeded.
         */
        contactEmails?: string[];
        /**
         * Specifies a list of Action Group IDs to send the budget notification to when the threshold is exceeded.
         */
        contactGroups?: string[];
        /**
         * Specifies a list of contact roles to send the budget notification to when the threshold is exceeded.
         */
        contactRoles?: string[];
        /**
         * Should the notification be enabled?
         */
        enabled?: boolean;
        /**
         * The comparison operator for the notification. Must be one of `EqualTo`, `GreaterThan`, or `GreaterThanOrEqualTo`.
         */
        operator: string;
        /**
         * Threshold value associated with a notification. Notification is sent when the cost exceeded the threshold. It is always percent and has to be between 0 and 1000.
         */
        threshold: number;
    }

    export interface BudgetSubscriptionTimePeriod {
        /**
         * The end date for the budget. If not set this will be 10 years after the start date.
         */
        endDate: string;
        /**
         * The start date for the budget. The start date must be first of the month and should be less than the end date. Budget start date must be on or after June 1, 2017. Future start date should not be more than twelve months. Past start date should be selected within the timegrain period. Changing this forces a new Subscription Consumption Budget to be created.
         */
        startDate: string;
    }

}

export namespace containerservice {
    export interface GetClusterNodePoolUpgradeSetting {
        /**
         * The maximum number or percentage of nodes which will be added to the Node Pool size during an upgrade.
         */
        maxSurge: string;
    }

    export interface GetKubernetesClusterAddonProfile {
        /**
         * A `azurePolicy` block.
         */
        azurePolicies: outputs.containerservice.GetKubernetesClusterAddonProfileAzurePolicy[];
        /**
         * A `httpApplicationRouting` block.
         */
        httpApplicationRoutings: outputs.containerservice.GetKubernetesClusterAddonProfileHttpApplicationRouting[];
        /**
         * An `ingressApplicationGateway` block.
         */
        ingressApplicationGateways: outputs.containerservice.GetKubernetesClusterAddonProfileIngressApplicationGateway[];
        /**
         * A `kubeDashboard` block.
         */
        kubeDashboards: outputs.containerservice.GetKubernetesClusterAddonProfileKubeDashboard[];
        /**
         * A `omsAgent` block.
         */
        omsAgents: outputs.containerservice.GetKubernetesClusterAddonProfileOmsAgent[];
    }

    export interface GetKubernetesClusterAddonProfileAzurePolicy {
        /**
         * Is Role Based Access Control enabled?
         */
        enabled: boolean;
    }

    export interface GetKubernetesClusterAddonProfileHttpApplicationRouting {
        /**
         * Is Role Based Access Control enabled?
         */
        enabled: boolean;
        /**
         * The Zone Name of the HTTP Application Routing.
         */
        httpApplicationRoutingZoneName: string;
    }

    export interface GetKubernetesClusterAddonProfileIngressApplicationGateway {
        /**
         * The ID of the Application Gateway associated with the ingress controller deployed to this Kubernetes Cluster.
         */
        effectiveGatewayId: string;
        /**
         * Is Role Based Access Control enabled?
         */
        enabled: boolean;
        /**
         * The ID of the Application Gateway integrated with the ingress controller of this Kubernetes Cluster. This attribute is only set when gatewayId is specified when configuring the `ingressApplicationGateway` addon.
         */
        gatewayId: string;
        /**
         * An `ingressApplicationGatewayIdentity` block as defined below.
         */
        ingressApplicationGatewayIdentities: outputs.containerservice.GetKubernetesClusterAddonProfileIngressApplicationGatewayIngressApplicationGatewayIdentity[];
        /**
         * The subnet CIDR used to create an Application Gateway, which in turn will be integrated with the ingress controller of this Kubernetes Cluster. This attribute is only set when `subnetCidr` is specified when configuring the `ingressApplicationGateway` addon.
         */
        subnetCidr: string;
        /**
         * The ID of the subnet on which to create an Application Gateway, which in turn will be integrated with the ingress controller of this Kubernetes Cluster. This attribute is only set when `subnetId` is specified when configuring the `ingressApplicationGateway` addon.
         */
        subnetId: string;
    }

    export interface GetKubernetesClusterAddonProfileIngressApplicationGatewayIngressApplicationGatewayIdentity {
        /**
         * The Client ID of the user-defined Managed Identity assigned to the Kubelets.
         */
        clientId: string;
        /**
         * The Object ID of the user-defined Managed Identity assigned to the Kubelets.
         */
        objectId: string;
        /**
         * The ID of the User Assigned Identity assigned to the Kubelets.
         */
        userAssignedIdentityId: string;
    }

    export interface GetKubernetesClusterAddonProfileKubeDashboard {
        /**
         * Is Role Based Access Control enabled?
         */
        enabled: boolean;
    }

    export interface GetKubernetesClusterAddonProfileOmsAgent {
        /**
         * Is Role Based Access Control enabled?
         */
        enabled: boolean;
        /**
         * The ID of the Log Analytics Workspace which the OMS Agent should send data to.
         */
        logAnalyticsWorkspaceId: string;
        /**
         * An `omsAgentIdentity` block as defined below.
         */
        omsAgentIdentities: outputs.containerservice.GetKubernetesClusterAddonProfileOmsAgentOmsAgentIdentity[];
    }

    export interface GetKubernetesClusterAddonProfileOmsAgentOmsAgentIdentity {
        /**
         * The Client ID of the user-defined Managed Identity assigned to the Kubelets.
         */
        clientId: string;
        /**
         * The Object ID of the user-defined Managed Identity assigned to the Kubelets.
         */
        objectId: string;
        /**
         * The ID of the User Assigned Identity assigned to the Kubelets.
         */
        userAssignedIdentityId: string;
    }

    export interface GetKubernetesClusterAgentPoolProfile {
        /**
         * The availability zones used for the nodes.
         */
        availabilityZones: string[];
        /**
         * The number of Agents (VM's) in the Pool.
         */
        count: number;
        /**
         * If the auto-scaler is enabled.
         */
        enableAutoScaling: boolean;
        /**
         * If the Public IPs for the nodes in this Agent Pool are enabled.
         */
        enableNodePublicIp: boolean;
        /**
         * Maximum number of nodes for auto-scaling
         */
        maxCount: number;
        /**
         * The maximum number of pods that can run on each agent.
         */
        maxPods: number;
        /**
         * Minimum number of nodes for auto-scaling
         */
        minCount: number;
        /**
         * The name of the managed Kubernetes Cluster.
         */
        name: string;
        nodeLabels: {[key: string]: string};
        /**
         * Resource ID for the Public IP Addresses Prefix for the nodes in this Agent Pool.
         */
        nodePublicIpPrefixId: string;
        nodeTaints: string[];
        /**
         * Kubernetes version used for the Agents.
         */
        orchestratorVersion: string;
        /**
         * The size of the Agent VM's Operating System Disk in GB.
         */
        osDiskSizeGb: number;
        /**
         * The Operating System used for the Agents.
         */
        osType: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: string};
        /**
         * The type of identity used for the managed cluster.
         */
        type: string;
        /**
         * A `upgradeSettings` block as documented below.
         */
        upgradeSettings: outputs.containerservice.GetKubernetesClusterAgentPoolProfileUpgradeSetting[];
        /**
         * The size of each VM in the Agent Pool (e.g. `Standard_F1`).
         */
        vmSize: string;
        /**
         * The ID of the Subnet where the Agents in the Pool are provisioned.
         */
        vnetSubnetId: string;
    }

    export interface GetKubernetesClusterAgentPoolProfileUpgradeSetting {
        /**
         * The maximum number or percentage of nodes which will be added to the Node Pool size during an upgrade.
         */
        maxSurge: string;
    }

    export interface GetKubernetesClusterIdentity {
        /**
         * The principal id of the system assigned identity which is used by primary components.
         */
        principalId: string;
        /**
         * The tenant id of the system assigned identity which is used by primary components.
         */
        tenantId: string;
        /**
         * The type of identity used for the managed cluster.
         */
        type: string;
        /**
         * The ID of the User Assigned Identity assigned to the Kubelets.
         */
        userAssignedIdentityId: string;
    }

    export interface GetKubernetesClusterKubeAdminConfig {
        /**
         * Base64 encoded public certificate used by clients to authenticate to the Kubernetes cluster.
         */
        clientCertificate: string;
        /**
         * Base64 encoded private key used by clients to authenticate to the Kubernetes cluster.
         */
        clientKey: string;
        /**
         * Base64 encoded public CA certificate used as the root of trust for the Kubernetes cluster.
         */
        clusterCaCertificate: string;
        /**
         * The Kubernetes cluster server host.
         */
        host: string;
        /**
         * A password or token used to authenticate to the Kubernetes cluster.
         */
        password: string;
        /**
         * A username used to authenticate to the Kubernetes cluster.
         */
        username: string;
    }

    export interface GetKubernetesClusterKubeConfig {
        /**
         * Base64 encoded public certificate used by clients to authenticate to the Kubernetes cluster.
         */
        clientCertificate: string;
        /**
         * Base64 encoded private key used by clients to authenticate to the Kubernetes cluster.
         */
        clientKey: string;
        /**
         * Base64 encoded public CA certificate used as the root of trust for the Kubernetes cluster.
         */
        clusterCaCertificate: string;
        /**
         * The Kubernetes cluster server host.
         */
        host: string;
        /**
         * A password or token used to authenticate to the Kubernetes cluster.
         */
        password: string;
        /**
         * A username used to authenticate to the Kubernetes cluster.
         */
        username: string;
    }

    export interface GetKubernetesClusterKubeletIdentity {
        /**
         * The Client ID of the user-defined Managed Identity assigned to the Kubelets.
         */
        clientId: string;
        /**
         * The Object ID of the user-defined Managed Identity assigned to the Kubelets.
         */
        objectId: string;
        /**
         * The ID of the User Assigned Identity assigned to the Kubelets.
         */
        userAssignedIdentityId: string;
    }

    export interface GetKubernetesClusterLinuxProfile {
        /**
         * The username associated with the administrator account of the Windows VMs.
         */
        adminUsername: string;
        /**
         * An `sshKey` block as defined below.
         */
        sshKeys: outputs.containerservice.GetKubernetesClusterLinuxProfileSshKey[];
    }

    export interface GetKubernetesClusterLinuxProfileSshKey {
        /**
         * The Public SSH Key used to access the cluster.
         */
        keyData: string;
    }

    export interface GetKubernetesClusterNetworkProfile {
        /**
         * IP address within the Kubernetes service address range used by cluster service discovery (kube-dns).
         */
        dnsServiceIp: string;
        /**
         * IP address (in CIDR notation) used as the Docker bridge IP address on nodes.
         */
        dockerBridgeCidr: string;
        loadBalancerSku: string;
        /**
         * Network plugin used such as `azure` or `kubenet`.
         */
        networkPlugin: string;
        /**
         * Network policy to be used with Azure CNI. Eg: `calico` or `azure`
         */
        networkPolicy: string;
        /**
         * The CIDR used for pod IP addresses.
         */
        podCidr: string;
        /**
         * Network range used by the Kubernetes service.
         */
        serviceCidr: string;
    }

    export interface GetKubernetesClusterRoleBasedAccessControl {
        /**
         * A `azureActiveDirectory` block as documented above.
         */
        azureActiveDirectories: outputs.containerservice.GetKubernetesClusterRoleBasedAccessControlAzureActiveDirectory[];
        /**
         * Is Role Based Access Control enabled?
         */
        enabled: boolean;
    }

    export interface GetKubernetesClusterRoleBasedAccessControlAzureActiveDirectory {
        /**
         * The list of Object IDs of Azure Active Directory Groups which have Admin Role on the Cluster (when using a Managed integration).
         */
        adminGroupObjectIds: string[];
        /**
         * The Client ID of an Azure Active Directory Application.
         */
        clientAppId: string;
        /**
         * Is the Azure Active Directory Integration managed (also known as AAD Integration V2)?
         */
        managed: boolean;
        /**
         * The Server ID of an Azure Active Directory Application.
         */
        serverAppId: string;
        /**
         * The tenant id of the system assigned identity which is used by primary components.
         */
        tenantId: string;
    }

    export interface GetKubernetesClusterServicePrincipal {
        /**
         * The Client ID of the user-defined Managed Identity assigned to the Kubelets.
         */
        clientId: string;
    }

    export interface GetKubernetesClusterWindowsProfile {
        /**
         * The username associated with the administrator account of the Windows VMs.
         */
        adminUsername: string;
    }

    export interface GroupContainer {
        /**
         * A list of commands which should be run on the container. Changing this forces a new resource to be created.
         */
        commands: string[];
        /**
         * The required number of CPU cores of the containers. Changing this forces a new resource to be created.
         */
        cpu: number;
        /**
         * A list of environment variables to be set on the container. Specified as a map of name/value pairs. Changing this forces a new resource to be created.
         */
        environmentVariables?: {[key: string]: string};
        /**
         * A `gpu` block as defined below. Changing this forces a new resource to be created.
         */
        gpu?: outputs.containerservice.GroupContainerGpu;
        /**
         * The container image name. Changing this forces a new resource to be created.
         */
        image: string;
        /**
         * The definition of a readiness probe for this container as documented in the `livenessProbe` block below. Changing this forces a new resource to be created.
         */
        livenessProbe?: outputs.containerservice.GroupContainerLivenessProbe;
        /**
         * The required memory of the containers in GB. Changing this forces a new resource to be created.
         */
        memory: number;
        /**
         * Specifies the name of the Container Group. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * A set of public ports for the container. Changing this forces a new resource to be created. Set as documented in the `ports` block below.
         */
        ports?: outputs.containerservice.GroupContainerPort[];
        /**
         * The definition of a readiness probe for this container as documented in the `readinessProbe` block below. Changing this forces a new resource to be created.
         */
        readinessProbe?: outputs.containerservice.GroupContainerReadinessProbe;
        /**
         * A list of sensitive environment variables to be set on the container. Specified as a map of name/value pairs. Changing this forces a new resource to be created.
         */
        secureEnvironmentVariables?: {[key: string]: string};
        /**
         * The definition of a volume mount for this container as documented in the `volume` block below. Changing this forces a new resource to be created.
         */
        volumes?: outputs.containerservice.GroupContainerVolume[];
    }

    export interface GroupContainerGpu {
        /**
         * The number of GPUs which should be assigned to this container. Allowed values are `1`, `2`, or `4`. Changing this forces a new resource to be created.
         */
        count?: number;
        /**
         * The Sku which should be used for the GPU. Possible values are `K80`, `P100`, or `V100`. Changing this forces a new resource to be created.
         */
        sku?: string;
    }

    export interface GroupContainerLivenessProbe {
        /**
         * Commands to be run to validate container readiness. Changing this forces a new resource to be created.
         */
        execs?: string[];
        /**
         * How many times to try the probe before restarting the container (liveness probe) or marking the container as unhealthy (readiness probe). The default value is `3` and the minimum value is `1`. Changing this forces a new resource to be created.
         */
        failureThreshold?: number;
        /**
         * The definition of the httpGet for this container as documented in the `httpGet` block below. Changing this forces a new resource to be created.
         */
        httpGets?: outputs.containerservice.GroupContainerLivenessProbeHttpGet[];
        /**
         * Number of seconds after the container has started before liveness or readiness probes are initiated. Changing this forces a new resource to be created.
         */
        initialDelaySeconds?: number;
        /**
         * How often (in seconds) to perform the probe. The default value is `10` and the minimum value is `1`. Changing this forces a new resource to be created.
         */
        periodSeconds?: number;
        /**
         * Minimum consecutive successes for the probe to be considered successful after having failed. The default value is `1` and the minimum value is `1`. Changing this forces a new resource to be created.
         */
        successThreshold?: number;
        /**
         * Number of seconds after which the probe times out. The default value is `1` and the minimum value is `1`. Changing this forces a new resource to be created.
         */
        timeoutSeconds?: number;
    }

    export interface GroupContainerLivenessProbeHttpGet {
        /**
         * Path to access on the HTTP server. Changing this forces a new resource to be created.
         */
        path?: string;
        /**
         * The port number the container will expose. Changing this forces a new resource to be created.
         */
        port?: number;
        /**
         * Scheme to use for connecting to the host. Possible values are `Http` and `Https`. Changing this forces a new resource to be created.
         */
        scheme?: string;
    }

    export interface GroupContainerPort {
        /**
         * The port number the container will expose. Changing this forces a new resource to be created.
         */
        port?: number;
        /**
         * The network protocol associated with port. Possible values are `TCP` & `UDP`. Changing this forces a new resource to be created.
         */
        protocol?: string;
    }

    export interface GroupContainerReadinessProbe {
        /**
         * Commands to be run to validate container readiness. Changing this forces a new resource to be created.
         */
        execs?: string[];
        /**
         * How many times to try the probe before restarting the container (liveness probe) or marking the container as unhealthy (readiness probe). The default value is `3` and the minimum value is `1`. Changing this forces a new resource to be created.
         */
        failureThreshold?: number;
        /**
         * The definition of the httpGet for this container as documented in the `httpGet` block below. Changing this forces a new resource to be created.
         */
        httpGets?: outputs.containerservice.GroupContainerReadinessProbeHttpGet[];
        /**
         * Number of seconds after the container has started before liveness or readiness probes are initiated. Changing this forces a new resource to be created.
         */
        initialDelaySeconds?: number;
        /**
         * How often (in seconds) to perform the probe. The default value is `10` and the minimum value is `1`. Changing this forces a new resource to be created.
         */
        periodSeconds?: number;
        /**
         * Minimum consecutive successes for the probe to be considered successful after having failed. The default value is `1` and the minimum value is `1`. Changing this forces a new resource to be created.
         */
        successThreshold?: number;
        /**
         * Number of seconds after which the probe times out. The default value is `1` and the minimum value is `1`. Changing this forces a new resource to be created.
         */
        timeoutSeconds?: number;
    }

    export interface GroupContainerReadinessProbeHttpGet {
        /**
         * Path to access on the HTTP server. Changing this forces a new resource to be created.
         */
        path?: string;
        /**
         * The port number the container will expose. Changing this forces a new resource to be created.
         */
        port?: number;
        /**
         * Scheme to use for connecting to the host. Possible values are `Http` and `Https`. Changing this forces a new resource to be created.
         */
        scheme?: string;
    }

    export interface GroupContainerVolume {
        /**
         * Boolean as to whether the mounted volume should be an empty directory. Defaults to `false`. Changing this forces a new resource to be created.
         */
        emptyDir?: boolean;
        /**
         * A `gitRepo` block as defined below.
         */
        gitRepo?: outputs.containerservice.GroupContainerVolumeGitRepo;
        /**
         * The path on which this volume is to be mounted. Changing this forces a new resource to be created.
         */
        mountPath: string;
        /**
         * Specifies the name of the Container Group. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * Specify if the volume is to be mounted as read only or not. The default value is `false`. Changing this forces a new resource to be created.
         */
        readOnly?: boolean;
        /**
         * A map of secrets that will be mounted as files in the volume. Changing this forces a new resource to be created.
         */
        secret?: {[key: string]: string};
        /**
         * The Azure storage share that is to be mounted as a volume. This must be created on the storage account specified as above. Changing this forces a new resource to be created.
         */
        shareName?: string;
        /**
         * The access key for the Azure Storage account specified as above. Changing this forces a new resource to be created.
         */
        storageAccountKey?: string;
        /**
         * The Azure storage account from which the volume is to be mounted. Changing this forces a new resource to be created.
         */
        storageAccountName?: string;
    }

    export interface GroupContainerVolumeGitRepo {
        /**
         * Specifies the directory into which the repository should be cloned. Changing this forces a new resource to be created.
         */
        directory?: string;
        /**
         * Specifies the commit hash of the revision to be cloned. If unspecified, the HEAD revision is cloned. Changing this forces a new resource to be created.
         */
        revision?: string;
        /**
         * Specifies the Git repository to be cloned. Changing this forces a new resource to be created.
         */
        url: string;
    }

    export interface GroupDiagnostics {
        /**
         * A `logAnalytics` block as defined below. Changing this forces a new resource to be created.
         */
        logAnalytics: outputs.containerservice.GroupDiagnosticsLogAnalytics;
    }

    export interface GroupDiagnosticsLogAnalytics {
        /**
         * The log type which should be used. Possible values are `ContainerInsights` and `ContainerInstanceLogs`. Changing this forces a new resource to be created.
         */
        logType?: string;
        /**
         * Any metadata required for Log Analytics. Changing this forces a new resource to be created.
         */
        metadata?: {[key: string]: string};
        /**
         * The Workspace ID of the Log Analytics Workspace. Changing this forces a new resource to be created.
         */
        workspaceId: string;
        /**
         * The Workspace Key of the Log Analytics Workspace. Changing this forces a new resource to be created.
         */
        workspaceKey: string;
    }

    export interface GroupDnsConfig {
        /**
         * A list of nameservers the containers will search out to resolve requests.
         */
        nameservers: string[];
        /**
         * A list of [resolver configuration options](https://man7.org/linux/man-pages/man5/resolv.conf.5.html).
         */
        options: string[];
        /**
         * A list of search domains that DNS requests will search along.
         */
        searchDomains: string[];
    }

    export interface GroupExposedPort {
        /**
         * The port number the container will expose. Changing this forces a new resource to be created.
         */
        port?: number;
        /**
         * The network protocol associated with port. Possible values are `TCP` & `UDP`. Changing this forces a new resource to be created.
         */
        protocol?: string;
    }

    export interface GroupIdentity {
        /**
         * Specifies a list of user managed identity ids to be assigned. Required if `type` is `UserAssigned`. Changing this forces a new resource to be created.
         */
        identityIds?: string[];
        principalId: string;
        /**
         * The Managed Service Identity Type of this container group. Possible values are `SystemAssigned` (where Azure will generate a Service Principal for you), `UserAssigned` where you can specify the Service Principal IDs in the `identityIds` field, and `SystemAssigned, UserAssigned` which assigns both a system managed identity as well as the specified user assigned identities. Changing this forces a new resource to be created.
         */
        type: string;
    }

    export interface GroupImageRegistryCredential {
        /**
         * The password with which to connect to the registry. Changing this forces a new resource to be created.
         */
        password: string;
        /**
         * The address to use to connect to the registry without protocol ("https"/"http"). For example: "myacr.acr.io". Changing this forces a new resource to be created.
         */
        server: string;
        /**
         * The username with which to connect to the registry. Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface KubernetesClusterAddonProfile {
        /**
         * A `aciConnectorLinux` block. For more details, please visit [Create and configure an AKS cluster to use virtual nodes](https://docs.microsoft.com/en-us/azure/aks/virtual-nodes-portal).
         */
        aciConnectorLinux?: outputs.containerservice.KubernetesClusterAddonProfileAciConnectorLinux;
        /**
         * A `azurePolicy` block as defined below. For more details please visit [Understand Azure Policy for Azure Kubernetes Service](https://docs.microsoft.com/en-ie/azure/governance/policy/concepts/rego-for-aks)
         */
        azurePolicy?: outputs.containerservice.KubernetesClusterAddonProfileAzurePolicy;
        /**
         * A `httpApplicationRouting` block as defined below.
         */
        httpApplicationRouting?: outputs.containerservice.KubernetesClusterAddonProfileHttpApplicationRouting;
        /**
         * An `ingressApplicationGateway` block as defined below.
         */
        ingressApplicationGateway?: outputs.containerservice.KubernetesClusterAddonProfileIngressApplicationGateway;
        /**
         * A `kubeDashboard` block as defined below.
         */
        kubeDashboard?: outputs.containerservice.KubernetesClusterAddonProfileKubeDashboard;
        /**
         * A `omsAgent` block as defined below. For more details, please visit [How to onboard Azure Monitor for containers](https://docs.microsoft.com/en-us/azure/monitoring/monitoring-container-insights-onboard).
         */
        omsAgent?: outputs.containerservice.KubernetesClusterAddonProfileOmsAgent;
    }

    export interface KubernetesClusterAddonProfileAciConnectorLinux {
        /**
         * Is the virtual node addon enabled?
         */
        enabled: boolean;
        /**
         * The subnet name for the virtual nodes to run. This is required when `aciConnectorLinux` `enabled` argument is set to `true`.
         */
        subnetName?: string;
    }

    export interface KubernetesClusterAddonProfileAzurePolicy {
        /**
         * Is the Azure Policy for Kubernetes Add On enabled?
         */
        enabled: boolean;
    }

    export interface KubernetesClusterAddonProfileHttpApplicationRouting {
        /**
         * Is HTTP Application Routing Enabled?
         */
        enabled: boolean;
        /**
         * The Zone Name of the HTTP Application Routing.
         */
        httpApplicationRoutingZoneName: string;
    }

    export interface KubernetesClusterAddonProfileIngressApplicationGateway {
        /**
         * The ID of the Application Gateway associated with the ingress controller deployed to this Kubernetes Cluster.
         */
        effectiveGatewayId: string;
        /**
         * Whether to deploy the Application Gateway ingress controller to this Kubernetes Cluster?
         */
        enabled: boolean;
        /**
         * The ID of the Application Gateway to integrate with the ingress controller of this Kubernetes Cluster. See [this](https://docs.microsoft.com/en-us/azure/application-gateway/tutorial-ingress-controller-add-on-existing) page for further details.
         */
        gatewayId?: string;
        /**
         * The name of the Application Gateway to be used or created in the Nodepool Resource Group, which in turn will be integrated with the ingress controller of this Kubernetes Cluster. See [this](https://docs.microsoft.com/en-us/azure/application-gateway/tutorial-ingress-controller-add-on-new) page for further details.
         */
        gatewayName?: string;
        /**
         * An `ingressApplicationGatewayIdentity` block is exported. The exported attributes are defined below.
         */
        ingressApplicationGatewayIdentities: outputs.containerservice.KubernetesClusterAddonProfileIngressApplicationGatewayIngressApplicationGatewayIdentity[];
        /**
         * The subnet CIDR to be used to create an Application Gateway, which in turn will be integrated with the ingress controller of this Kubernetes Cluster. See [this](https://docs.microsoft.com/en-us/azure/application-gateway/tutorial-ingress-controller-add-on-new) page for further details.
         */
        subnetCidr?: string;
        /**
         * The ID of the subnet on which to create an Application Gateway, which in turn will be integrated with the ingress controller of this Kubernetes Cluster. See [this](https://docs.microsoft.com/en-us/azure/application-gateway/tutorial-ingress-controller-add-on-new) page for further details.
         */
        subnetId?: string;
    }

    export interface KubernetesClusterAddonProfileIngressApplicationGatewayIngressApplicationGatewayIdentity {
        /**
         * The Client ID of the user-defined Managed Identity to be assigned to the Kubelets. If not specified a Managed Identity is created automatically.
         */
        clientId: string;
        /**
         * The Object ID of the user-defined Managed Identity assigned to the Kubelets.If not specified a Managed Identity is created automatically.
         */
        objectId: string;
        /**
         * The ID of a user assigned identity.
         */
        userAssignedIdentityId: string;
    }

    export interface KubernetesClusterAddonProfileKubeDashboard {
        /**
         * Is the Kubernetes Dashboard enabled?
         */
        enabled: boolean;
    }

    export interface KubernetesClusterAddonProfileOmsAgent {
        /**
         * Is the OMS Agent Enabled?
         */
        enabled: boolean;
        /**
         * The ID of the Log Analytics Workspace which the OMS Agent should send data to. Must be present if `enabled` is `true`.
         */
        logAnalyticsWorkspaceId?: string;
        /**
         * An `omsAgentIdentity` block is exported. The exported attributes are defined below.
         */
        omsAgentIdentities: outputs.containerservice.KubernetesClusterAddonProfileOmsAgentOmsAgentIdentity[];
    }

    export interface KubernetesClusterAddonProfileOmsAgentOmsAgentIdentity {
        /**
         * The Client ID of the user-defined Managed Identity to be assigned to the Kubelets. If not specified a Managed Identity is created automatically.
         */
        clientId: string;
        /**
         * The Object ID of the user-defined Managed Identity assigned to the Kubelets.If not specified a Managed Identity is created automatically.
         */
        objectId: string;
        /**
         * The ID of a user assigned identity.
         */
        userAssignedIdentityId: string;
    }

    export interface KubernetesClusterAutoScalerProfile {
        /**
         * Detect similar node groups and balance the number of nodes between them. Defaults to `false`.
         */
        balanceSimilarNodeGroups?: boolean;
        /**
         * Maximum number of empty nodes that can be deleted at the same time. Defaults to `10`.
         */
        emptyBulkDeleteMax: string;
        /**
         * Expander to use. Possible values are `least-waste`, `priority`, `most-pods` and `random`. Defaults to `random`.
         */
        expander: string;
        /**
         * Maximum number of seconds the cluster autoscaler waits for pod termination when trying to scale down a node. Defaults to `600`.
         */
        maxGracefulTerminationSec: string;
        /**
         * Maximum time the autoscaler waits for a node to be provisioned. Defaults to `15m`.
         */
        maxNodeProvisioningTime?: string;
        /**
         * Maximum Number of allowed unready nodes. Defaults to `3`.
         */
        maxUnreadyNodes?: number;
        /**
         * Maximum percentage of unready nodes the cluster autoscaler will stop if the percentage is exceeded. Defaults to `45`.
         */
        maxUnreadyPercentage?: number;
        /**
         * For scenarios like burst/batch scale where you don't want CA to act before the kubernetes scheduler could schedule all the pods, you can tell CA to ignore unscheduled pods before they're a certain age. Defaults to `10s`.
         */
        newPodScaleUpDelay: string;
        /**
         * How long after the scale up of AKS nodes the scale down evaluation resumes. Defaults to `10m`.
         */
        scaleDownDelayAfterAdd: string;
        /**
         * How long after node deletion that scale down evaluation resumes. Defaults to the value used for `scanInterval`.
         */
        scaleDownDelayAfterDelete: string;
        /**
         * How long after scale down failure that scale down evaluation resumes. Defaults to `3m`.
         */
        scaleDownDelayAfterFailure: string;
        /**
         * How long a node should be unneeded before it is eligible for scale down. Defaults to `10m`.
         */
        scaleDownUnneeded: string;
        /**
         * How long an unready node should be unneeded before it is eligible for scale down. Defaults to `20m`.
         */
        scaleDownUnready: string;
        /**
         * Node utilization level, defined as sum of requested resources divided by capacity, below which a node can be considered for scale down. Defaults to `0.5`.
         */
        scaleDownUtilizationThreshold: string;
        /**
         * How often the AKS Cluster should be re-evaluated for scale up/down. Defaults to `10s`.
         */
        scanInterval: string;
        /**
         * If `true` cluster autoscaler will never delete nodes with pods with local storage, for example, EmptyDir or HostPath. Defaults to `true`.
         */
        skipNodesWithLocalStorage?: boolean;
        /**
         * If `true` cluster autoscaler will never delete nodes with pods from kube-system (except for DaemonSet or mirror pods). Defaults to `true`.
         */
        skipNodesWithSystemPods?: boolean;
    }

    export interface KubernetesClusterDefaultNodePool {
        /**
         * A list of Availability Zones across which the Node Pool should be spread. Changing this forces a new resource to be created.
         */
        availabilityZones?: string[];
        /**
         * Should [the Kubernetes Auto Scaler](https://docs.microsoft.com/en-us/azure/aks/cluster-autoscaler) be enabled for this Node Pool? Defaults to `false`.
         */
        enableAutoScaling?: boolean;
        /**
         * Should the nodes in the Default Node Pool have host encryption enabled? Defaults to `false`.
         */
        enableHostEncryption?: boolean;
        /**
         * Should nodes in this Node Pool have a Public IP Address? Defaults to `false`. Changing this forces a new resource to be created.
         */
        enableNodePublicIp?: boolean;
        /**
         * Should the nodes in this Node Pool have Federal Information Processing Standard enabled? Changing this forces a new resource to be created.
         */
        fipsEnabled?: boolean;
        /**
         * A `kubeletConfig` block as defined below.
         */
        kubeletConfig?: outputs.containerservice.KubernetesClusterDefaultNodePoolKubeletConfig;
        /**
         * The type of disk used by kubelet. At this time the only possible value is `OS`.
         */
        kubeletDiskType: string;
        /**
         * A `linuxOsConfig` block as defined below.
         */
        linuxOsConfig?: outputs.containerservice.KubernetesClusterDefaultNodePoolLinuxOsConfig;
        /**
         * The maximum number of nodes which should exist in this Node Pool. If specified this must be between `1` and `1000`.
         */
        maxCount?: number;
        /**
         * The maximum number of pods that can run on each agent. Changing this forces a new resource to be created.
         */
        maxPods: number;
        /**
         * The minimum number of nodes which should exist in this Node Pool. If specified this must be between `1` and `1000`.
         */
        minCount?: number;
        /**
         * The name which should be used for the default Kubernetes Node Pool. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * The initial number of nodes which should exist in this Node Pool. If specified this must be between `1` and `1000` and between `minCount` and `maxCount`.
         */
        nodeCount: number;
        /**
         * A map of Kubernetes labels which should be applied to nodes in the Default Node Pool. Changing this forces a new resource to be created.
         */
        nodeLabels?: {[key: string]: string};
        /**
         * Resource ID for the Public IP Addresses Prefix for the nodes in this Node Pool. `enableNodePublicIp` should be `true`. Changing this forces a new resource to be created.
         */
        nodePublicIpPrefixId?: string;
        nodeTaints?: string[];
        /**
         * Enabling this option will taint default node pool with `CriticalAddonsOnly=true:NoSchedule` taint. Changing this forces a new resource to be created.
         */
        onlyCriticalAddonsEnabled?: boolean;
        /**
         * Version of Kubernetes used for the Agents. If not specified, the latest recommended version will be used at provisioning time (but won't auto-upgrade)
         */
        orchestratorVersion: string;
        /**
         * The size of the OS Disk which should be used for each agent in the Node Pool. Changing this forces a new resource to be created.
         */
        osDiskSizeGb: number;
        /**
         * The type of disk which should be used for the Operating System. Possible values are `Ephemeral` and `Managed`. Defaults to `Managed`. Changing this forces a new resource to be created.
         */
        osDiskType?: string;
        proximityPlacementGroupId?: string;
        /**
         * A mapping of tags to assign to the Node Pool.
         */
        tags?: {[key: string]: string};
        /**
         * The type of Node Pool which should be created. Possible values are `AvailabilitySet` and `VirtualMachineScaleSets`. Defaults to `VirtualMachineScaleSets`.
         */
        type?: string;
        /**
         * A `upgradeSettings` block as documented below.
         */
        upgradeSettings?: outputs.containerservice.KubernetesClusterDefaultNodePoolUpgradeSettings;
        /**
         * The size of the Virtual Machine, such as `Standard_DS2_v2`.
         */
        vmSize: string;
        /**
         * The ID of a Subnet where the Kubernetes Node Pool should exist. Changing this forces a new resource to be created.
         */
        vnetSubnetId?: string;
    }

    export interface KubernetesClusterDefaultNodePoolKubeletConfig {
        /**
         * Specifies the allow list of unsafe sysctls command or patterns (ending in `*`). Changing this forces a new resource to be created.
         */
        allowedUnsafeSysctls?: string[];
        /**
         * Specifies the maximum number of container log files that can be present for a container. must be at least 2. Changing this forces a new resource to be created.
         */
        containerLogMaxLine?: number;
        /**
         * Specifies the maximum size (e.g. 10MB) of container log file before it is rotated. Changing this forces a new resource to be created.
         */
        containerLogMaxSizeMb?: number;
        /**
         * Is CPU CFS quota enforcement for containers enabled? Changing this forces a new resource to be created.
         */
        cpuCfsQuotaEnabled?: boolean;
        /**
         * Specifies the CPU CFS quota period value. Changing this forces a new resource to be created.
         */
        cpuCfsQuotaPeriod?: string;
        /**
         * Specifies the CPU Manager policy to use. Possible values are `none` and `static`, Changing this forces a new resource to be created.
         */
        cpuManagerPolicy?: string;
        /**
         * Specifies the percent of disk usage above which image garbage collection is always run. Must be between `0` and `100`. Changing this forces a new resource to be created.
         */
        imageGcHighThreshold?: number;
        /**
         * Specifies the percent of disk usage lower than which image garbage collection is never run. Must be between `0` and `100`. Changing this forces a new resource to be created.
         */
        imageGcLowThreshold?: number;
        /**
         * Specifies the maximum number of processes per pod. Changing this forces a new resource to be created.
         */
        podMaxPid?: number;
        /**
         * Specifies the Topology Manager policy to use. Possible values are `none`, `best-effort`, `restricted` or `single-numa-node`. Changing this forces a new resource to be created.
         */
        topologyManagerPolicy?: string;
    }

    export interface KubernetesClusterDefaultNodePoolLinuxOsConfig {
        /**
         * Specifies the size of swap file on each node in MB. Changing this forces a new resource to be created.
         */
        swapFileSizeMb?: number;
        /**
         * A `sysctlConfig` block as defined below. Changing this forces a new resource to be created.
         */
        sysctlConfig?: outputs.containerservice.KubernetesClusterDefaultNodePoolLinuxOsConfigSysctlConfig;
        /**
         * specifies the defrag configuration for Transparent Huge Page. Possible values are `always`, `defer`, `defer+madvise`, `madvise` and `never`. Changing this forces a new resource to be created.
         */
        transparentHugePageDefrag?: string;
        /**
         * Specifies the Transparent Huge Page enabled configuration. Possible values are `always`, `madvise` and `never`. Changing this forces a new resource to be created.
         */
        transparentHugePageEnabled?: string;
    }

    export interface KubernetesClusterDefaultNodePoolLinuxOsConfigSysctlConfig {
        /**
         * The sysctl setting fs.aio-max-nr. Must be between `65536` and `6553500`. Changing this forces a new resource to be created.
         */
        fsAioMaxNr?: number;
        /**
         * The sysctl setting fs.file-max. Must be between `8192` and `12000500`. Changing this forces a new resource to be created.
         */
        fsFileMax?: number;
        /**
         * The sysctl setting fs.inotify.max_user_watches. Must be between `781250` and `2097152`. Changing this forces a new resource to be created.
         */
        fsInotifyMaxUserWatches?: number;
        /**
         * The sysctl setting fs.nr_open. Must be between `8192` and `20000500`. Changing this forces a new resource to be created.
         */
        fsNrOpen?: number;
        /**
         * The sysctl setting kernel.threads-max. Must be between `20` and `513785`. Changing this forces a new resource to be created.
         */
        kernelThreadsMax?: number;
        /**
         * The sysctl setting net.core.netdev_max_backlog. Must be between `1000` and `3240000`. Changing this forces a new resource to be created.
         */
        netCoreNetdevMaxBacklog?: number;
        /**
         * The sysctl setting net.core.optmem_max. Must be between `20480` and `4194304`. Changing this forces a new resource to be created.
         */
        netCoreOptmemMax?: number;
        /**
         * The sysctl setting net.core.rmem_default. Must be between `212992` and `134217728`. Changing this forces a new resource to be created.
         */
        netCoreRmemDefault?: number;
        /**
         * The sysctl setting net.core.rmem_max. Must be between `212992` and `134217728`. Changing this forces a new resource to be created.
         */
        netCoreRmemMax?: number;
        /**
         * The sysctl setting net.core.somaxconn. Must be between `4096` and `3240000`. Changing this forces a new resource to be created.
         */
        netCoreSomaxconn?: number;
        /**
         * The sysctl setting net.core.wmem_default. Must be between `212992` and `134217728`. Changing this forces a new resource to be created.
         */
        netCoreWmemDefault?: number;
        /**
         * The sysctl setting net.core.wmem_max. Must be between `212992` and `134217728`. Changing this forces a new resource to be created.
         */
        netCoreWmemMax?: number;
        /**
         * The sysctl setting net.ipv4.ip_local_port_range max value. Must be between `1024` and `60999`. Changing this forces a new resource to be created.
         */
        netIpv4IpLocalPortRangeMax?: number;
        /**
         * The sysctl setting net.ipv4.ip_local_port_range min value. Must be between `1024` and `60999`. Changing this forces a new resource to be created.
         */
        netIpv4IpLocalPortRangeMin?: number;
        /**
         * The sysctl setting net.ipv4.neigh.default.gc_thresh1. Must be between `128` and `80000`. Changing this forces a new resource to be created.
         */
        netIpv4NeighDefaultGcThresh1?: number;
        /**
         * The sysctl setting net.ipv4.neigh.default.gc_thresh2. Must be between `512` and `90000`. Changing this forces a new resource to be created.
         */
        netIpv4NeighDefaultGcThresh2?: number;
        /**
         * The sysctl setting net.ipv4.neigh.default.gc_thresh3. Must be between `1024` and `100000`. Changing this forces a new resource to be created.
         */
        netIpv4NeighDefaultGcThresh3?: number;
        /**
         * The sysctl setting net.ipv4.tcp_fin_timeout. Must be between `5` and `120`. Changing this forces a new resource to be created.
         */
        netIpv4TcpFinTimeout?: number;
        /**
         * The sysctl setting net.ipv4.tcp_keepalive_intvl. Must be between `10` and `75`. Changing this forces a new resource to be created.
         */
        netIpv4TcpKeepaliveIntvl?: number;
        /**
         * The sysctl setting net.ipv4.tcp_keepalive_probes. Must be between `1` and `15`. Changing this forces a new resource to be created.
         */
        netIpv4TcpKeepaliveProbes?: number;
        /**
         * The sysctl setting net.ipv4.tcp_keepalive_time. Must be between `30` and `432000`. Changing this forces a new resource to be created.
         */
        netIpv4TcpKeepaliveTime?: number;
        /**
         * The sysctl setting net.ipv4.tcp_max_syn_backlog. Must be between `128` and `3240000`. Changing this forces a new resource to be created.
         */
        netIpv4TcpMaxSynBacklog?: number;
        /**
         * The sysctl setting net.ipv4.tcp_max_tw_buckets. Must be between `8000` and `1440000`. Changing this forces a new resource to be created.
         */
        netIpv4TcpMaxTwBuckets?: number;
        /**
         * The sysctl setting net.ipv4.tcp_tw_reuse. Changing this forces a new resource to be created.
         */
        netIpv4TcpTwReuse?: boolean;
        /**
         * The sysctl setting net.netfilter.nf_conntrack_buckets. Must be between `65536` and `147456`. Changing this forces a new resource to be created.
         */
        netNetfilterNfConntrackBuckets?: number;
        /**
         * The sysctl setting net.netfilter.nf_conntrack_max. Must be between `131072` and `589824`. Changing this forces a new resource to be created.
         */
        netNetfilterNfConntrackMax?: number;
        /**
         * The sysctl setting vm.max_map_count. Must be between `65530` and `262144`. Changing this forces a new resource to be created.
         */
        vmMaxMapCount?: number;
        /**
         * The sysctl setting vm.swappiness. Must be between `0` and `100`. Changing this forces a new resource to be created.
         */
        vmSwappiness?: number;
        /**
         * The sysctl setting vm.vfs_cache_pressure. Must be between `0` and `100`. Changing this forces a new resource to be created.
         */
        vmVfsCachePressure?: number;
    }

    export interface KubernetesClusterDefaultNodePoolUpgradeSettings {
        /**
         * The maximum number or percentage of nodes which will be added to the Node Pool size during an upgrade.
         */
        maxSurge: string;
    }

    export interface KubernetesClusterIdentity {
        /**
         * The principal id of the system assigned identity which is used by master components.
         */
        principalId: string;
        /**
         * The Tenant ID used for Azure Active Directory Application. If this isn't specified the Tenant ID of the current Subscription is used.
         */
        tenantId: string;
        /**
         * The type of identity used for the managed cluster. Possible values are `SystemAssigned` and `UserAssigned`. If `UserAssigned` is set, a `userAssignedIdentityId` must be set as well.
         */
        type: string;
        /**
         * The ID of a user assigned identity.
         */
        userAssignedIdentityId?: string;
    }

    export interface KubernetesClusterKubeAdminConfig {
        /**
         * Base64 encoded public certificate used by clients to authenticate to the Kubernetes cluster.
         */
        clientCertificate: string;
        /**
         * Base64 encoded private key used by clients to authenticate to the Kubernetes cluster.
         */
        clientKey: string;
        /**
         * Base64 encoded public CA certificate used as the root of trust for the Kubernetes cluster.
         */
        clusterCaCertificate: string;
        /**
         * The Kubernetes cluster server host.
         */
        host: string;
        /**
         * A password or token used to authenticate to the Kubernetes cluster.
         */
        password: string;
        /**
         * A username used to authenticate to the Kubernetes cluster.
         */
        username: string;
    }

    export interface KubernetesClusterKubeConfig {
        /**
         * Base64 encoded public certificate used by clients to authenticate to the Kubernetes cluster.
         */
        clientCertificate: string;
        /**
         * Base64 encoded private key used by clients to authenticate to the Kubernetes cluster.
         */
        clientKey: string;
        /**
         * Base64 encoded public CA certificate used as the root of trust for the Kubernetes cluster.
         */
        clusterCaCertificate: string;
        /**
         * The Kubernetes cluster server host.
         */
        host: string;
        /**
         * A password or token used to authenticate to the Kubernetes cluster.
         */
        password: string;
        /**
         * A username used to authenticate to the Kubernetes cluster.
         */
        username: string;
    }

    export interface KubernetesClusterKubeletIdentity {
        /**
         * The Client ID of the user-defined Managed Identity to be assigned to the Kubelets. If not specified a Managed Identity is created automatically.
         */
        clientId: string;
        /**
         * The Object ID of the user-defined Managed Identity assigned to the Kubelets.If not specified a Managed Identity is created automatically.
         */
        objectId: string;
        /**
         * The ID of the User Assigned Identity assigned to the Kubelets. If not specified a Managed Identity is created automatically.
         */
        userAssignedIdentityId: string;
    }

    export interface KubernetesClusterLinuxProfile {
        /**
         * The Admin Username for the Cluster. Changing this forces a new resource to be created.
         */
        adminUsername: string;
        /**
         * An `sshKey` block. Only one is currently allowed. Changing this forces a new resource to be created.
         */
        sshKey: outputs.containerservice.KubernetesClusterLinuxProfileSshKey;
    }

    export interface KubernetesClusterLinuxProfileSshKey {
        /**
         * The Public SSH Key used to access the cluster. Changing this forces a new resource to be created.
         */
        keyData: string;
    }

    export interface KubernetesClusterNetworkProfile {
        /**
         * IP address within the Kubernetes service address range that will be used by cluster service discovery (kube-dns). Changing this forces a new resource to be created.
         */
        dnsServiceIp: string;
        /**
         * IP address (in CIDR notation) used as the Docker bridge IP address on nodes. Changing this forces a new resource to be created.
         */
        dockerBridgeCidr: string;
        /**
         * A `loadBalancerProfile` block. This can only be specified when `loadBalancerSku` is set to `Standard`.
         */
        loadBalancerProfile: outputs.containerservice.KubernetesClusterNetworkProfileLoadBalancerProfile;
        /**
         * Specifies the SKU of the Load Balancer used for this Kubernetes Cluster. Possible values are `Basic` and `Standard`. Defaults to `Standard`.
         */
        loadBalancerSku?: string;
        /**
         * Network mode to be used with Azure CNI. Possible values are `bridge` and `transparent`. Changing this forces a new resource to be created.
         */
        networkMode: string;
        /**
         * Network plugin to use for networking. Currently supported values are `azure` and `kubenet`. Changing this forces a new resource to be created.
         */
        networkPlugin: string;
        /**
         * Sets up network policy to be used with Azure CNI. [Network policy allows us to control the traffic flow between pods](https://docs.microsoft.com/en-us/azure/aks/use-network-policies). Currently supported values are `calico` and `azure`. Changing this forces a new resource to be created.
         */
        networkPolicy: string;
        /**
         * The outbound (egress) routing method which should be used for this Kubernetes Cluster. Possible values are `loadBalancer` and `userDefinedRouting`. Defaults to `loadBalancer`.
         */
        outboundType?: string;
        /**
         * The CIDR to use for pod IP addresses. This field can only be set when `networkPlugin` is set to `kubenet`. Changing this forces a new resource to be created.
         */
        podCidr: string;
        /**
         * The Network Range used by the Kubernetes service. Changing this forces a new resource to be created.
         */
        serviceCidr: string;
    }

    export interface KubernetesClusterNetworkProfileLoadBalancerProfile {
        /**
         * The outcome (resource IDs) of the specified arguments.
         */
        effectiveOutboundIps: string[];
        /**
         * Desired outbound flow idle timeout in minutes for the cluster load balancer. Must be between `4` and `120` inclusive. Defaults to `30`.
         */
        idleTimeoutInMinutes?: number;
        /**
         * Count of desired managed outbound IPs for the cluster load balancer. Must be between `1` and `100` inclusive.
         */
        managedOutboundIpCount: number;
        /**
         * The ID of the Public IP Addresses which should be used for outbound communication for the cluster load balancer.
         */
        outboundIpAddressIds: string[];
        /**
         * The ID of the outbound Public IP Address Prefixes which should be used for the cluster load balancer.
         */
        outboundIpPrefixIds: string[];
        /**
         * Number of desired SNAT port for each VM in the clusters load balancer. Must be between `0` and `64000` inclusive. Defaults to `0`.
         */
        outboundPortsAllocated?: number;
    }

    export interface KubernetesClusterNodePoolKubeletConfig {
        /**
         * Specifies the allow list of unsafe sysctls command or patterns (ending in `*`). Changing this forces a new resource to be created.
         */
        allowedUnsafeSysctls?: string[];
        /**
         * Specifies the maximum number of container log files that can be present for a container. must be at least 2. Changing this forces a new resource to be created.
         */
        containerLogMaxLine?: number;
        /**
         * Specifies the maximum size (e.g. 10MB) of container log file before it is rotated. Changing this forces a new resource to be created.
         */
        containerLogMaxSizeMb?: number;
        /**
         * Is CPU CFS quota enforcement for containers enabled? Changing this forces a new resource to be created.
         */
        cpuCfsQuotaEnabled?: boolean;
        /**
         * Specifies the CPU CFS quota period value. Changing this forces a new resource to be created.
         */
        cpuCfsQuotaPeriod?: string;
        /**
         * Specifies the CPU Manager policy to use. Possible values are `none` and `static`, Changing this forces a new resource to be created.
         */
        cpuManagerPolicy?: string;
        /**
         * Specifies the percent of disk usage above which image garbage collection is always run. Must be between `0` and `100`. Changing this forces a new resource to be created.
         */
        imageGcHighThreshold?: number;
        /**
         * Specifies the percent of disk usage lower than which image garbage collection is never run. Must be between `0` and `100`. Changing this forces a new resource to be created.
         */
        imageGcLowThreshold?: number;
        podMaxPid?: number;
        /**
         * Specifies the Topology Manager policy to use. Possible values are `none`, `best-effort`, `restricted` or `single-numa-node`. Changing this forces a new resource to be created.
         */
        topologyManagerPolicy?: string;
    }

    export interface KubernetesClusterNodePoolLinuxOsConfig {
        /**
         * Specifies the size of swap file on each node in MB. Changing this forces a new resource to be created.
         */
        swapFileSizeMb?: number;
        /**
         * A `sysctlConfig` block as defined below. Changing this forces a new resource to be created.
         */
        sysctlConfig?: outputs.containerservice.KubernetesClusterNodePoolLinuxOsConfigSysctlConfig;
        /**
         * specifies the defrag configuration for Transparent Huge Page. Possible values are `always`, `defer`, `defer+madvise`, `madvise` and `never`. Changing this forces a new resource to be created.
         */
        transparentHugePageDefrag?: string;
        /**
         * Specifies the Transparent Huge Page enabled configuration. Possible values are `always`, `madvise` and `never`. Changing this forces a new resource to be created.
         */
        transparentHugePageEnabled?: string;
    }

    export interface KubernetesClusterNodePoolLinuxOsConfigSysctlConfig {
        /**
         * The sysctl setting fs.aio-max-nr. Must be between `65536` and `6553500`. Changing this forces a new resource to be created.
         */
        fsAioMaxNr?: number;
        /**
         * The sysctl setting fs.file-max. Must be between `8192` and `12000500`. Changing this forces a new resource to be created.
         */
        fsFileMax?: number;
        /**
         * The sysctl setting fs.inotify.max_user_watches. Must be between `781250` and `2097152`. Changing this forces a new resource to be created.
         */
        fsInotifyMaxUserWatches?: number;
        /**
         * The sysctl setting fs.nr_open. Must be between `8192` and `20000500`. Changing this forces a new resource to be created.
         */
        fsNrOpen?: number;
        /**
         * The sysctl setting kernel.threads-max. Must be between `20` and `513785`. Changing this forces a new resource to be created.
         */
        kernelThreadsMax?: number;
        /**
         * The sysctl setting net.core.netdev_max_backlog. Must be between `1000` and `3240000`. Changing this forces a new resource to be created.
         */
        netCoreNetdevMaxBacklog?: number;
        /**
         * The sysctl setting net.core.optmem_max. Must be between `20480` and `4194304`. Changing this forces a new resource to be created.
         */
        netCoreOptmemMax?: number;
        /**
         * The sysctl setting net.core.rmem_default. Must be between `212992` and `134217728`. Changing this forces a new resource to be created.
         */
        netCoreRmemDefault?: number;
        /**
         * The sysctl setting net.core.rmem_max. Must be between `212992` and `134217728`. Changing this forces a new resource to be created.
         */
        netCoreRmemMax?: number;
        /**
         * The sysctl setting net.core.somaxconn. Must be between `4096` and `3240000`. Changing this forces a new resource to be created.
         */
        netCoreSomaxconn?: number;
        /**
         * The sysctl setting net.core.wmem_default. Must be between `212992` and `134217728`. Changing this forces a new resource to be created.
         */
        netCoreWmemDefault?: number;
        /**
         * The sysctl setting net.core.wmem_max. Must be between `212992` and `134217728`. Changing this forces a new resource to be created.
         */
        netCoreWmemMax?: number;
        /**
         * The sysctl setting net.ipv4.ip_local_port_range max value. Must be between `1024` and `60999`. Changing this forces a new resource to be created.
         */
        netIpv4IpLocalPortRangeMax?: number;
        /**
         * The sysctl setting net.ipv4.ip_local_port_range min value. Must be between `1024` and `60999`. Changing this forces a new resource to be created.
         */
        netIpv4IpLocalPortRangeMin?: number;
        /**
         * The sysctl setting net.ipv4.neigh.default.gc_thresh1. Must be between `128` and `80000`. Changing this forces a new resource to be created.
         */
        netIpv4NeighDefaultGcThresh1?: number;
        /**
         * The sysctl setting net.ipv4.neigh.default.gc_thresh2. Must be between `512` and `90000`. Changing this forces a new resource to be created.
         */
        netIpv4NeighDefaultGcThresh2?: number;
        /**
         * The sysctl setting net.ipv4.neigh.default.gc_thresh3. Must be between `1024` and `100000`. Changing this forces a new resource to be created.
         */
        netIpv4NeighDefaultGcThresh3?: number;
        /**
         * The sysctl setting net.ipv4.tcp_fin_timeout. Must be between `5` and `120`. Changing this forces a new resource to be created.
         */
        netIpv4TcpFinTimeout?: number;
        /**
         * The sysctl setting net.ipv4.tcp_keepalive_intvl. Must be between `10` and `75`. Changing this forces a new resource to be created.
         */
        netIpv4TcpKeepaliveIntvl?: number;
        /**
         * The sysctl setting net.ipv4.tcp_keepalive_probes. Must be between `1` and `15`. Changing this forces a new resource to be created.
         */
        netIpv4TcpKeepaliveProbes?: number;
        /**
         * The sysctl setting net.ipv4.tcp_keepalive_time. Must be between `30` and `432000`. Changing this forces a new resource to be created.
         */
        netIpv4TcpKeepaliveTime?: number;
        /**
         * The sysctl setting net.ipv4.tcp_max_syn_backlog. Must be between `128` and `3240000`. Changing this forces a new resource to be created.
         */
        netIpv4TcpMaxSynBacklog?: number;
        /**
         * The sysctl setting net.ipv4.tcp_max_tw_buckets. Must be between `8000` and `1440000`. Changing this forces a new resource to be created.
         */
        netIpv4TcpMaxTwBuckets?: number;
        /**
         * Is sysctl setting net.ipv4.tcp_tw_reuse enabled? Changing this forces a new resource to be created.
         */
        netIpv4TcpTwReuse?: boolean;
        /**
         * The sysctl setting net.netfilter.nf_conntrack_buckets. Must be between `65536` and `147456`. Changing this forces a new resource to be created.
         */
        netNetfilterNfConntrackBuckets?: number;
        /**
         * The sysctl setting net.netfilter.nf_conntrack_max. Must be between `131072` and `589824`. Changing this forces a new resource to be created.
         */
        netNetfilterNfConntrackMax?: number;
        /**
         * The sysctl setting vm.max_map_count. Must be between `65530` and `262144`. Changing this forces a new resource to be created.
         */
        vmMaxMapCount?: number;
        /**
         * The sysctl setting vm.swappiness. Must be between `0` and `100`. Changing this forces a new resource to be created.
         */
        vmSwappiness?: number;
        /**
         * The sysctl setting vm.vfs_cache_pressure. Must be between `0` and `100`. Changing this forces a new resource to be created.
         */
        vmVfsCachePressure?: number;
    }

    export interface KubernetesClusterNodePoolUpgradeSettings {
        /**
         * The maximum number or percentage of nodes which will be added to the Node Pool size during an upgrade.
         */
        maxSurge: string;
    }

    export interface KubernetesClusterRoleBasedAccessControl {
        /**
         * An `azureActiveDirectory` block.
         */
        azureActiveDirectory?: outputs.containerservice.KubernetesClusterRoleBasedAccessControlAzureActiveDirectory;
        /**
         * Is Role Based Access Control Enabled? Changing this forces a new resource to be created.
         */
        enabled: boolean;
    }

    export interface KubernetesClusterRoleBasedAccessControlAzureActiveDirectory {
        /**
         * A list of Object IDs of Azure Active Directory Groups which should have Admin Role on the Cluster.
         */
        adminGroupObjectIds?: string[];
        /**
         * Is Role Based Access Control based on Azure AD enabled?
         */
        azureRbacEnabled?: boolean;
        /**
         * The Client ID of an Azure Active Directory Application.
         */
        clientAppId?: string;
        /**
         * Is the Azure Active Directory integration Managed, meaning that Azure will create/manage the Service Principal used for integration.
         */
        managed?: boolean;
        /**
         * The Server ID of an Azure Active Directory Application.
         */
        serverAppId?: string;
        /**
         * The Server Secret of an Azure Active Directory Application.
         */
        serverAppSecret?: string;
        /**
         * The Tenant ID used for Azure Active Directory Application. If this isn't specified the Tenant ID of the current Subscription is used.
         */
        tenantId: string;
    }

    export interface KubernetesClusterServicePrincipal {
        /**
         * The Client ID for the Service Principal.
         */
        clientId: string;
        /**
         * The Client Secret for the Service Principal.
         */
        clientSecret: string;
    }

    export interface KubernetesClusterWindowsProfile {
        /**
         * The Admin Password for Windows VMs. Length must be between 14 and 123 characters.
         */
        adminPassword?: string;
        /**
         * The Admin Username for Windows VMs.
         */
        adminUsername: string;
        /**
         * Specifies the type of on-premise license which should be used for Node Pool Windows Virtual Machine. At this time the only possible value is `Windows_Server`.
         */
        license?: string;
    }

    export interface RegistryEncryption {
        /**
         * Boolean value that indicates whether encryption is enabled.
         */
        enabled?: boolean;
        /**
         * The client ID of the managed identity associated with the encryption key.
         */
        identityClientId: string;
        /**
         * The ID of the Key Vault Key.
         */
        keyVaultKeyId: string;
    }

    export interface RegistryGeoreplication {
        /**
         * A location where the container registry should be geo-replicated.
         */
        location: string;
        /**
         * A mapping of tags to assign to this replication location.
         */
        tags?: {[key: string]: string};
        /**
         * Whether zone redundancy is enabled for this replication location? Defaults to `false`.
         */
        zoneRedundancyEnabled?: boolean;
    }

    export interface RegistryIdentity {
        /**
         * A list of User Managed Identity ID's which should be assigned to the Container Registry.
         */
        identityIds?: string[];
        principalId: string;
        /**
         * The type of Managed Identity which should be assigned to the Container Registry. Possible values are `SystemAssigned`, `UserAssigned` and `SystemAssigned, UserAssigned`.
         */
        type: string;
    }

    export interface RegistryNetworkRuleSet {
        /**
         * The behaviour for requests matching no rules. Either `Allow` or `Deny`. Defaults to `Allow`
         */
        defaultAction?: string;
        /**
         * One or more `ipRule` blocks as defined below.
         */
        ipRules?: outputs.containerservice.RegistryNetworkRuleSetIpRule[];
        /**
         * One or more `virtualNetwork` blocks as defined below.
         */
        virtualNetworks?: outputs.containerservice.RegistryNetworkRuleSetVirtualNetwork[];
    }

    export interface RegistryNetworkRuleSetIpRule {
        /**
         * The behaviour for requests matching this rule. At this time the only supported value is `Allow`
         */
        action: string;
        /**
         * The CIDR block from which requests will match the rule.
         */
        ipRange: string;
    }

    export interface RegistryNetworkRuleSetVirtualNetwork {
        /**
         * The behaviour for requests matching this rule. At this time the only supported value is `Allow`
         */
        action: string;
        /**
         * The subnet id from which requests will match the rule.
         */
        subnetId: string;
    }

    export interface RegistryRetentionPolicy {
        /**
         * The number of days to retain an untagged manifest after which it gets purged. Default is `7`.
         */
        days?: number;
        /**
         * Boolean value that indicates whether the policy is enabled.
         */
        enabled?: boolean;
    }

    export interface RegistryTrustPolicy {
        /**
         * Boolean value that indicates whether the policy is enabled.
         */
        enabled?: boolean;
    }

}

export namespace core {
    export interface CustomProviderAction {
        /**
         * Specifies the endpoint of the action.
         */
        endpoint: string;
        /**
         * Specifies the name of the action.
         */
        name: string;
    }

    export interface CustomProviderResourceType {
        /**
         * Specifies the endpoint of the route definition.
         */
        endpoint: string;
        /**
         * Specifies the name of the route definition.
         */
        name: string;
        /**
         * The routing type that is supported for the resource request. Valid values are `ResourceTypeRoutingProxy` or `ResourceTypeRoutingProxyCache`. This value defaults to `ResourceTypeRoutingProxy`.
         */
        routingType?: string;
    }

    export interface CustomProviderValidation {
        /**
         * The endpoint where the validation specification is located.
         */
        specification: string;
    }

    export interface GetResourcesResource {
        /**
         * The ID of this Resource.
         */
        id: string;
        /**
         * The Azure Region in which this Resource exists.
         */
        location: string;
        /**
         * The name of the Resource.
         */
        name: string;
        /**
         * A map of tags assigned to this Resource.
         */
        tags: {[key: string]: string};
        /**
         * The Resource Type of the Resources you want to list (e.g. `Microsoft.Network/virtualNetworks`). A full list of available Resource Types can be found [here](https://docs.microsoft.com/en-us/azure/azure-resource-manager/azure-services-resource-providers).
         */
        type: string;
    }

    export interface GetSubscriptionsSubscription {
        /**
         * The subscription display name.
         */
        displayName: string;
        /**
         * The ID of this subscription.
         */
        id: string;
        /**
         * The subscription location placement ID.
         */
        locationPlacementId: string;
        /**
         * The subscription quota ID.
         */
        quotaId: string;
        /**
         * The subscription spending limit.
         */
        spendingLimit: string;
        /**
         * The subscription state. Possible values are Enabled, Warned, PastDue, Disabled, and Deleted.
         */
        state: string;
        /**
         * The subscription GUID.
         */
        subscriptionId: string;
        /**
         * A mapping of tags assigned to the resource.
         */
        tags: {[key: string]: string};
        /**
         * The subscription tenant ID.
         */
        tenantId: string;
    }

    export interface ResourceGroupPolicyAssignmentIdentity {
        /**
         * The Principal ID of the Policy Assignment for this Resource Group.
         */
        principalId: string;
        /**
         * The Tenant ID of the Policy Assignment for this Resource Group.
         */
        tenantId: string;
        /**
         * The Type of Managed Identity which should be added to this Policy Definition. The only possible value is `SystemAssigned`.
         */
        type?: string;
    }

    export interface ResourcePolicyAssignmentIdentity {
        /**
         * The Principal ID of the Policy Assignment for this Resource.
         */
        principalId: string;
        /**
         * The Tenant ID of the Policy Assignment for this Resource.
         */
        tenantId: string;
        /**
         * The Type of Managed Identity which should be added to this Policy Definition. The only possible value is `SystemAssigned`.
         */
        type?: string;
    }

    export interface SubscriptionPolicyAssignmentIdentity {
        /**
         * The Principal ID of the Policy Assignment for this Subscription.
         */
        principalId: string;
        /**
         * The Tenant ID of the Policy Assignment for this Subscription.
         */
        tenantId: string;
        /**
         * The Type of Managed Identity which should be added to this Policy Definition. The only possible value is `SystemAssigned`.
         */
        type?: string;
    }

}

export namespace cosmosdb {
    export interface AccountBackup {
        /**
         * The interval in minutes between two backups. This is configurable only when `type` is `Periodic`. Possible values are between 60 and 1440.
         */
        intervalInMinutes: number;
        /**
         * The time in hours that each backup is retained. This is configurable only when `type` is `Periodic`. Possible values are between 8 and 720.
         */
        retentionInHours: number;
        /**
         * The type of the `backup`. Possible values are `Continuous` and `Periodic`. Defaults to `Periodic`.
         */
        type: string;
    }

    export interface AccountCapability {
        /**
         * Specifies the name of the CosmosDB Account. Changing this forces a new resource to be created.
         */
        name: string;
    }

    export interface AccountConsistencyPolicy {
        /**
         * The Consistency Level to use for this CosmosDB Account - can be either `BoundedStaleness`, `Eventual`, `Session`, `Strong` or `ConsistentPrefix`.
         */
        consistencyLevel: string;
        /**
         * When used with the Bounded Staleness consistency level, this value represents the time amount of staleness (in seconds) tolerated. Accepted range for this value is `5` - `86400` (1 day). Defaults to `5`. Required when `consistencyLevel` is set to `BoundedStaleness`.
         */
        maxIntervalInSeconds: number;
        /**
         * When used with the Bounded Staleness consistency level, this value represents the number of stale requests tolerated. Accepted range for this value is `10` – `2147483647`. Defaults to `100`. Required when `consistencyLevel` is set to `BoundedStaleness`.
         */
        maxStalenessPrefix: number;
    }

    export interface AccountCorsRule {
        /**
         * A list of headers that are allowed to be a part of the cross-origin request.
         */
        allowedHeaders: string[];
        /**
         * A list of http headers that are allowed to be executed by the origin. Valid options are  `DELETE`, `GET`, `HEAD`, `MERGE`, `POST`, `OPTIONS`, `PUT` or `PATCH`.
         */
        allowedMethods: string[];
        /**
         * A list of origin domains that will be allowed by CORS.
         */
        allowedOrigins: string[];
        /**
         * A list of response headers that are exposed to CORS clients.
         */
        exposedHeaders: string[];
        /**
         * The number of seconds the client should cache a preflight response.
         */
        maxAgeInSeconds: number;
    }

    export interface AccountGeoLocation {
        /**
         * The failover priority of the region. A failover priority of `0` indicates a write region. The maximum value for a failover priority = (total number of regions - 1). Failover priority values must be unique for each of the regions in which the database account exists. Changing this causes the location to be re-provisioned and cannot be changed for the location with failover priority `0`.
         */
        failoverPriority: number;
        /**
         * The ID of the virtual network subnet.
         */
        id: string;
        /**
         * The name of the Azure region to host replicated data.
         */
        location: string;
        /**
         * The string used to generate the document endpoints for this region. If not specified it defaults to `${cosmosdb_account.name}-${location}`. Changing this causes the location to be deleted and re-provisioned and cannot be changed for the location with failover priority `0`.
         *
         * @deprecated This is deprecated because the service no longer accepts this as an input since Apr 25, 2019
         */
        prefix?: string;
        /**
         * Should zone redundancy be enabled for this region? Defaults to `false`.
         */
        zoneRedundant?: boolean;
    }

    export interface AccountIdentity {
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Cosmos Account. Possible value is only `SystemAssigned`.
         */
        type: string;
    }

    export interface AccountVirtualNetworkRule {
        /**
         * The ID of the virtual network subnet.
         */
        id: string;
        /**
         * If set to true, the specified subnet will be added as a virtual network rule even if its CosmosDB service endpoint is not active. Defaults to `false`.
         */
        ignoreMissingVnetServiceEndpoint?: boolean;
    }

    export interface CassandraKeyspaceAutoscaleSettings {
        /**
         * The maximum throughput of the Cassandra KeySpace (RU/s). Must be between `4,000` and `1,000,000`. Must be set in increments of `1,000`. Conflicts with `throughput`.
         */
        maxThroughput: number;
    }

    export interface CassandraTableAutoscaleSettings {
        /**
         * The maximum throughput of the Cassandra Table (RU/s). Must be between `4,000` and `1,000,000`. Must be set in increments of `1,000`. Conflicts with `throughput`.
         */
        maxThroughput: number;
    }

    export interface CassandraTableSchema {
        /**
         * One or more `clusterKey` blocks as defined below.
         */
        clusterKeys?: outputs.cosmosdb.CassandraTableSchemaClusterKey[];
        /**
         * One or more `column` blocks as defined below.
         */
        columns: outputs.cosmosdb.CassandraTableSchemaColumn[];
        /**
         * One or more `partitionKey` blocks as defined below.
         */
        partitionKeys: outputs.cosmosdb.CassandraTableSchemaPartitionKey[];
    }

    export interface CassandraTableSchemaClusterKey {
        /**
         * Name of the cluster key to be created.
         */
        name: string;
        /**
         * Order of the key. Currently supported values are `Asc` and `Desc`.
         */
        orderBy: string;
    }

    export interface CassandraTableSchemaColumn {
        /**
         * Name of the column to be created.
         */
        name: string;
        /**
         * Type of the column to be created.
         */
        type: string;
    }

    export interface CassandraTableSchemaPartitionKey {
        /**
         * Name of the column to partition by.
         */
        name: string;
    }

    export interface GetAccountCapability {
        /**
         * Specifies the name of the CosmosDB Account.
         */
        name: string;
    }

    export interface GetAccountConsistencyPolicy {
        /**
         * The Consistency Level used by this CosmosDB Account.
         */
        consistencyLevel: string;
        /**
         * The amount of staleness (in seconds) tolerated when the consistency level is Bounded Staleness.
         */
        maxIntervalInSeconds: number;
        /**
         * The number of stale requests tolerated when the consistency level is Bounded Staleness.
         */
        maxStalenessPrefix: number;
    }

    export interface GetAccountGeoLocation {
        failoverPriority: number;
        /**
         * The ID of the virtual network subnet.
         */
        id: string;
        /**
         * The name of the Azure region hosting replicated data.
         */
        location: string;
    }

    export interface GetAccountVirtualNetworkRule {
        /**
         * The ID of the virtual network subnet.
         */
        id: string;
    }

    export interface GremlinDatabaseAutoscaleSettings {
        /**
         * The maximum throughput of the Gremlin database (RU/s). Must be between `4,000` and `1,000,000`. Must be set in increments of `1,000`. Conflicts with `throughput`.
         */
        maxThroughput: number;
    }

    export interface GremlinGraphAutoscaleSettings {
        /**
         * The maximum throughput of the Gremlin graph (RU/s). Must be between `4,000` and `1,000,000`. Must be set in increments of `1,000`. Conflicts with `throughput`.
         */
        maxThroughput: number;
    }

    export interface GremlinGraphConflictResolutionPolicy {
        /**
         * The conflict resolution path in the case of LastWriterWins mode.
         */
        conflictResolutionPath?: string;
        /**
         * The procedure to resolve conflicts in the case of custom mode.
         */
        conflictResolutionProcedure?: string;
        /**
         * Indicates the conflict resolution mode. Possible values include: `LastWriterWins`, `Custom`.
         */
        mode: string;
    }

    export interface GremlinGraphIndexPolicy {
        /**
         * Indicates if the indexing policy is automatic. Defaults to `true`.
         */
        automatic?: boolean;
        /**
         * One or more `compositeIndex` blocks as defined below.
         */
        compositeIndices?: outputs.cosmosdb.GremlinGraphIndexPolicyCompositeIndex[];
        /**
         * List of paths to exclude from indexing. Required if `indexingMode` is `Consistent` or `Lazy`.
         */
        excludedPaths: string[];
        /**
         * List of paths to include in the indexing. Required if `indexingMode` is `Consistent` or `Lazy`.
         */
        includedPaths: string[];
        /**
         * Indicates the indexing mode. Possible values include: `Consistent`, `Lazy`, `None`.
         */
        indexingMode: string;
        /**
         * One or more `spatialIndex` blocks as defined below.
         */
        spatialIndices?: outputs.cosmosdb.GremlinGraphIndexPolicySpatialIndex[];
    }

    export interface GremlinGraphIndexPolicyCompositeIndex {
        /**
         * One or more `index` blocks as defined below.
         */
        indices: outputs.cosmosdb.GremlinGraphIndexPolicyCompositeIndexIndex[];
    }

    export interface GremlinGraphIndexPolicyCompositeIndexIndex {
        /**
         * Order of the index. Possible values are `Ascending` or `Descending`.
         */
        order: string;
        /**
         * Path for which the indexing behaviour applies to.
         */
        path: string;
    }

    export interface GremlinGraphIndexPolicySpatialIndex {
        /**
         * Path for which the indexing behaviour applies to. According to the service design, all spatial types including `LineString`, `MultiPolygon`, `Point`, and `Polygon` will be applied to the path.
         */
        path: string;
        types: string[];
    }

    export interface GremlinGraphUniqueKey {
        /**
         * A list of paths to use for this unique key.
         */
        paths: string[];
    }

    export interface MongoCollectionAutoscaleSettings {
        /**
         * The maximum throughput of the MongoDB collection (RU/s). Must be between `4,000` and `1,000,000`. Must be set in increments of `1,000`. Conflicts with `throughput`.
         */
        maxThroughput: number;
    }

    export interface MongoCollectionIndex {
        /**
         * Specifies the list of user settable keys for each Cosmos DB Mongo Collection.
         */
        keys: string[];
        /**
         * Is the index unique or not? Defaults to `false`.
         */
        unique?: boolean;
    }

    export interface MongoCollectionSystemIndex {
        /**
         * Specifies the list of user settable keys for each Cosmos DB Mongo Collection.
         */
        keys: string[];
        /**
         * Is the index unique or not? Defaults to `false`.
         */
        unique: boolean;
    }

    export interface MongoDatabaseAutoscaleSettings {
        /**
         * The maximum throughput of the MongoDB database (RU/s). Must be between `4,000` and `1,000,000`. Must be set in increments of `1,000`. Conflicts with `throughput`.
         */
        maxThroughput: number;
    }

    export interface SqlContainerAutoscaleSettings {
        /**
         * The maximum throughput of the SQL container (RU/s). Must be between `4,000` and `1,000,000`. Must be set in increments of `1,000`. Conflicts with `throughput`.
         */
        maxThroughput: number;
    }

    export interface SqlContainerConflictResolutionPolicy {
        /**
         * The conflict resolution path in the case of `LastWriterWins` mode.
         */
        conflictResolutionPath?: string;
        /**
         * The procedure to resolve conflicts in the case of `Custom` mode.
         */
        conflictResolutionProcedure?: string;
        /**
         * Indicates the conflict resolution mode. Possible values include: `LastWriterWins`, `Custom`.
         */
        mode: string;
    }

    export interface SqlContainerIndexingPolicy {
        /**
         * One or more `compositeIndex` blocks as defined below.
         */
        compositeIndices?: outputs.cosmosdb.SqlContainerIndexingPolicyCompositeIndex[];
        /**
         * One or more `excludedPath` blocks as defined below. Either `includedPath` or `excludedPath` must contain the `path` `/*`
         */
        excludedPaths: outputs.cosmosdb.SqlContainerIndexingPolicyExcludedPath[];
        /**
         * One or more `includedPath` blocks as defined below. Either `includedPath` or `excludedPath` must contain the `path` `/*`
         */
        includedPaths: outputs.cosmosdb.SqlContainerIndexingPolicyIncludedPath[];
        /**
         * Indicates the indexing mode. Possible values include: `Consistent` and `None`. Defaults to `Consistent`.
         */
        indexingMode?: string;
        /**
         * One or more `spatialIndex` blocks as defined below.
         */
        spatialIndices?: outputs.cosmosdb.SqlContainerIndexingPolicySpatialIndex[];
    }

    export interface SqlContainerIndexingPolicyCompositeIndex {
        /**
         * One or more `index` blocks as defined below.
         */
        indices: outputs.cosmosdb.SqlContainerIndexingPolicyCompositeIndexIndex[];
    }

    export interface SqlContainerIndexingPolicyCompositeIndexIndex {
        /**
         * Order of the index. Possible values are `Ascending` or `Descending`.
         */
        order: string;
        /**
         * Path for which the indexing behaviour applies to.
         */
        path: string;
    }

    export interface SqlContainerIndexingPolicyExcludedPath {
        /**
         * Path that is excluded from indexing.
         */
        path: string;
    }

    export interface SqlContainerIndexingPolicyIncludedPath {
        /**
         * Path for which the indexing behaviour applies to.
         */
        path: string;
    }

    export interface SqlContainerIndexingPolicySpatialIndex {
        /**
         * Path for which the indexing behaviour applies to. According to the service design, all spatial types including `LineString`, `MultiPolygon`, `Point`, and `Polygon` will be applied to the path.
         */
        path: string;
        /**
         * A set of spatial types of the path.
         */
        types: string[];
    }

    export interface SqlContainerUniqueKey {
        /**
         * A list of paths to use for this unique key.
         */
        paths: string[];
    }

    export interface SqlDatabaseAutoscaleSettings {
        /**
         * The maximum throughput of the SQL database (RU/s). Must be between `4,000` and `1,000,000`. Must be set in increments of `1,000`. Conflicts with `throughput`.
         */
        maxThroughput: number;
    }

    export interface TableAutoscaleSettings {
        /**
         * The maximum throughput of the Table (RU/s). Must be between `4,000` and `1,000,000`. Must be set in increments of `1,000`. Conflicts with `throughput`.
         */
        maxThroughput: number;
    }
}

export namespace costmanagement {
    export interface ResourceGroupExportDeliveryInfo {
        /**
         * The name of the container where exports will be uploaded.
         */
        containerName: string;
        /**
         * The path of the directory where exports will be uploaded.
         */
        rootFolderPath: string;
        /**
         * The storage account id where exports will be delivered.
         */
        storageAccountId: string;
    }

    export interface ResourceGroupExportQuery {
        /**
         * The time frame for pulling data for the query. If custom, then a specific time period must be provided. Possible values include: `WeekToDate`, `MonthToDate`, `YearToDate`, `TheLastWeek`, `TheLastMonth`, `TheLastYear`, `Custom`.
         */
        timeFrame: string;
        /**
         * The type of the query.
         */
        type: string;
    }

}

export namespace databoxedge {
    export interface DeviceDeviceProperty {
        /**
         * The Data Box Edge/Gateway device local capacity in MB.
         */
        capacity: number;
        /**
         * Type of compute roles configured.
         */
        configuredRoleTypes: string[];
        /**
         * The Data Box Edge/Gateway device culture.
         */
        culture: string;
        /**
         * The device software version number of the device (eg: 1.2.18105.6).
         */
        hcsVersion: string;
        /**
         * The Data Box Edge/Gateway device model.
         */
        model: string;
        /**
         * The number of nodes in the cluster.
         */
        nodeCount: number;
        /**
         * The Serial Number of Data Box Edge/Gateway device.
         */
        serialNumber: string;
        /**
         * The Data Box Edge/Gateway device software version.
         */
        softwareVersion: string;
        /**
         * The status of the Data Box Edge/Gateway device.
         */
        status: string;
        /**
         * The Data Box Edge/Gateway device timezone.
         */
        timeZone: string;
        /**
         * The type of the Data Box Edge/Gateway device.
         */
        type: string;
    }

    export interface OrderContact {
        /**
         * The name of the company. Changing this forces a new Databox Edge Order to be created.
         */
        companyName: string;
        /**
         * A list of email address to send order notification to. Changing this forces a new Databox Edge Order to be created.
         */
        emails: string[];
        /**
         * The contact person name. Changing this forces a new Databox Edge Order to be created.
         */
        name: string;
        /**
         * The phone number. Changing this forces a new Databox Edge Order to be created.
         */
        phoneNumber: string;
    }

    export interface OrderReturnTracking {
        /**
         * Name of the carrier used in the delivery.
         */
        carrierName: string;
        /**
         * Serial number of the device being tracked.
         */
        serialNumber: string;
        /**
         * The ID of the tracking.
         */
        trackingId: string;
        /**
         * Tracking URL of the shipment.
         */
        trackingUrl: string;
    }

    export interface OrderShipmentAddress {
        /**
         * The list of upto 3 lines for address information. Changing this forces a new Databox Edge Order to be created.
         */
        addresses: string[];
        /**
         * The city name. Changing this forces a new Databox Edge Order to be created.
         */
        city: string;
        /**
         * The name of the country to ship the Databox Edge Device to. Valid values are "Algeria", "Argentina", "Australia", "Austria", "Bahamas", "Bahrain", "Bangladesh", "Barbados", "Belgium", "Bermuda", "Bolivia", "Bosnia and Herzegovina", "Brazil", "Bulgaria", "Canada", "Cayman Islands", "Chile", "Colombia", "Costa Rica", "Croatia", "Cyprus", "Czechia", "CÃ´te D'ivoire", "Denmark", "Dominican Republic", "Ecuador", "Egypt", "El Salvador", "Estonia", "Ethiopia", "Finland", "France", "Georgia", "Germany", "Ghana", "Greece", "Guatemala", "Honduras", "Hong Kong SAR", "Hungary", "Iceland", "India", "Indonesia", "Ireland", "Israel", "Italy", "Jamaica", "Japan", "Jordan", "Kazakhstan", "Kenya", "Kuwait", "Kyrgyzstan", "Latvia", "Libya", "Liechtenstein", "Lithuania", "Luxembourg", "Macao SAR", "Malaysia", "Malta", "Mauritius", "Mexico", "Moldova", "Monaco", "Mongolia", "Montenegro", "Morocco", "Namibia", "Nepal", "Netherlands", "New Zealand", "Nicaragua", "Nigeria", "Norway", "Oman", "Pakistan", "Palestinian Authority", "Panama", "Paraguay", "Peru", "Philippines", "Poland", "Portugal", "Puerto Rico", "Qatar", "Republic of Korea", "Romania", "Russia", "Rwanda", "Saint Kitts And Nevis", "Saudi Arabia", "Senegal", "Serbia", "Singapore", "Slovakia", "Slovenia", "South Africa", "Spain", "Sri Lanka", "Sweden", "Switzerland", "Taiwan", "Tajikistan", "Tanzania", "Thailand", "Trinidad And Tobago", "Tunisia", "Turkey", "Turkmenistan", "U.S. Virgin Islands", "Uganda", "Ukraine", "United Arab Emirates", "United Kingdom", "United States", "Uruguay", "Uzbekistan", "Venezuela", "Vietnam", "Yemen", "Zambia" or "Zimbabwe". Changing this forces a new Databox Edge Order to be created.
         */
        country: string;
        /**
         * The postal code. Changing this forces a new Databox Edge Order to be created.
         */
        postalCode: string;
        /**
         * The name of the state to ship the Databox Edge Device to. Changing this forces a new Databox Edge Order to be created.
         */
        state: string;
    }

    export interface OrderShipmentHistory {
        /**
         * Dictionary to hold generic information which is not stored by the already existing properties.
         */
        additionalDetails: {[key: string]: string};
        /**
         * Comments related to this status change.
         */
        comments: string;
        /**
         * Time of status update.
         */
        lastUpdate: string;
    }

    export interface OrderShipmentTracking {
        /**
         * Name of the carrier used in the delivery.
         */
        carrierName: string;
        /**
         * Serial number of the device being tracked.
         */
        serialNumber: string;
        /**
         * The ID of the tracking.
         */
        trackingId: string;
        /**
         * Tracking URL of the shipment.
         */
        trackingUrl: string;
    }

    export interface OrderStatus {
        /**
         * Dictionary to hold generic information which is not stored by the already existing properties.
         */
        additionalDetails: {[key: string]: string};
        /**
         * Comments related to this status change.
         */
        comments: string;
        /**
         * The current status of the order. Possible values include `Untracked`, `AwaitingFulfilment`, `AwaitingPreparation`, `AwaitingShipment`, `Shipped`, `Arriving`, `Delivered`, `ReplacementRequested`, `LostDevice`, `Declined`, `ReturnInitiated`, `AwaitingReturnShipment`, `ShippedBack` or `CollectedAtMicrosoft`.
         */
        info: string;
        /**
         * Time of status update.
         */
        lastUpdate: string;
    }

}

export namespace databricks {
    export interface WorkspaceCustomParameters {
        machineLearningWorkspaceId?: string;
        /**
         * Are public IP Addresses not allowed? Possible values are `true` or `false`. Defaults to `false`. Changing this forces a new resource to be created.
         */
        noPublicIp?: boolean;
        /**
         * The name of the Private Subnet within the Virtual Network. Required if `virtualNetworkId` is set. Changing this forces a new resource to be created.
         */
        privateSubnetName?: string;
        /**
         * The name of the Public Subnet within the Virtual Network. Required if `virtualNetworkId` is set. Changing this forces a new resource to be created.
         */
        publicSubnetName?: string;
        /**
         * The ID of a Virtual Network where this Databricks Cluster should be created. Changing this forces a new resource to be created.
         */
        virtualNetworkId?: string;
    }

    export interface WorkspaceStorageAccountIdentity {
        /**
         * The principal UUID for the internal databricks storage account needed to provide access to the workspace for enabling Customer Managed Keys.
         */
        principalId: string;
        /**
         * The UUID of the tenant where the internal databricks storage account was created.
         */
        tenantId: string;
        /**
         * The type of the internal databricks storage account.
         */
        type: string;
    }

}

export namespace datafactory {
    export interface DatasetAzureBlobSchemaColumn {
        /**
         * The description of the column.
         */
        description?: string;
        /**
         * The name of the column.
         */
        name: string;
        /**
         * Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
         */
        type?: string;
    }

    export interface DatasetCosmosDBApiSchemaColumn {
        /**
         * The description of the column.
         */
        description?: string;
        /**
         * The name of the column.
         */
        name: string;
        /**
         * Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
         */
        type?: string;
    }

    export interface DatasetDelimitedTextAzureBlobFsLocation {
        /**
         * The storage data lake gen2 file system on the Azure Blob Storage Account hosting the file.
         */
        fileSystem: string;
        /**
         * The filename of the file.
         */
        filename?: string;
        /**
         * The folder path to the file.
         */
        path?: string;
    }

    export interface DatasetDelimitedTextAzureBlobStorageLocation {
        /**
         * The container on the Azure Blob Storage Account hosting the file.
         */
        container: string;
        /**
         * The filename of the file.
         */
        filename: string;
        /**
         * The folder path to the file.
         */
        path: string;
    }

    export interface DatasetDelimitedTextHttpServerLocation {
        /**
         * The filename of the file on the web server.
         */
        filename: string;
        /**
         * The folder path to the file on the web server.
         */
        path: string;
        /**
         * The base URL to the web server hosting the file.
         */
        relativeUrl: string;
    }

    export interface DatasetDelimitedTextSchemaColumn {
        /**
         * The description of the column.
         */
        description?: string;
        /**
         * The name of the column.
         */
        name: string;
        /**
         * Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
         */
        type?: string;
    }

    export interface DatasetHttpSchemaColumn {
        /**
         * The description of the column.
         */
        description?: string;
        /**
         * The name of the column.
         */
        name: string;
        /**
         * Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
         */
        type?: string;
    }

    export interface DatasetJsonAzureBlobStorageLocation {
        /**
         * The container on the Azure Blob Storage Account hosting the file.
         */
        container: string;
        /**
         * The filename of the file on the web server.
         */
        filename: string;
        /**
         * The folder path to the file on the web server.
         */
        path: string;
    }

    export interface DatasetJsonHttpServerLocation {
        /**
         * The filename of the file on the web server.
         */
        filename: string;
        /**
         * The folder path to the file on the web server.
         */
        path: string;
        /**
         * The base URL to the web server hosting the file.
         */
        relativeUrl: string;
    }

    export interface DatasetJsonSchemaColumn {
        /**
         * The description of the column.
         */
        description?: string;
        /**
         * The name of the column.
         */
        name: string;
        /**
         * Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
         */
        type?: string;
    }

    export interface DatasetMysqlSchemaColumn {
        /**
         * The description of the column.
         */
        description?: string;
        /**
         * The name of the column.
         */
        name: string;
        /**
         * Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
         */
        type?: string;
    }

    export interface DatasetParquetAzureBlobStorageLocation {
        /**
         * The container on the Azure Blob Storage Account hosting the file.
         */
        container: string;
        /**
         * The filename of the file on the web server.
         */
        filename?: string;
        /**
         * The folder path to the file on the web server.
         */
        path: string;
    }

    export interface DatasetParquetHttpServerLocation {
        /**
         * The filename of the file on the web server.
         */
        filename: string;
        /**
         * The folder path to the file on the web server.
         */
        path: string;
        /**
         * The base URL to the web server hosting the file.
         */
        relativeUrl: string;
    }

    export interface DatasetParquetSchemaColumn {
        /**
         * The description of the column.
         */
        description?: string;
        /**
         * The name of the column.
         */
        name: string;
        /**
         * Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
         */
        type?: string;
    }

    export interface DatasetPostgresqlSchemaColumn {
        /**
         * The description of the column.
         */
        description?: string;
        /**
         * The name of the column.
         */
        name: string;
        /**
         * Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
         */
        type?: string;
    }

    export interface DatasetSnowflakeSchemaColumn {
        /**
         * The description of the column.
         */
        description?: string;
        /**
         * The name of the column.
         */
        name: string;
        /**
         * Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
         */
        type?: string;
    }

    export interface DatasetSqlServerTableSchemaColumn {
        /**
         * The description of the column.
         */
        description?: string;
        /**
         * The name of the column.
         */
        name: string;
        /**
         * Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
         */
        type?: string;
    }

    export interface FactoryGithubConfiguration {
        /**
         * Specifies the GitHub account name.
         */
        accountName: string;
        /**
         * Specifies the branch of the repository to get code from.
         */
        branchName: string;
        /**
         * Specifies the GitHub Enterprise host name. For example: https://github.mydomain.com. Use https://github.com for open source repositories.
         */
        gitUrl: string;
        /**
         * Specifies the name of the git repository.
         */
        repositoryName: string;
        /**
         * Specifies the root folder within the repository. Set to `/` for the top level.
         */
        rootFolder: string;
    }

    export interface FactoryGlobalParameter {
        /**
         * Specifies the global parameter name.
         */
        name: string;
        /**
         * Specifies the global parameter type. Possible Values are `Array`, `Bool`, `Float`, `Int`, `Object` or `String`.
         */
        type: string;
        /**
         * Specifies the global parameter value.
         */
        value: string;
    }

    export interface FactoryIdentity {
        /**
         * Specifies the IDs of user assigned identities. Requiered if `UserAssigned` type is used.
         */
        identityIds?: string[];
        /**
         * The ID of the Principal (Client) in Azure Active Directory
         */
        principalId: string;
        /**
         * Specifies the Tenant ID associated with the VSTS account.
         */
        tenantId: string;
        /**
         * Specifies the identity type of the Data Factory. Possible values are `SystemAssigned` and `UserAssigned`.
         */
        type: string;
    }

    export interface FactoryVstsConfiguration {
        /**
         * Specifies the VSTS account name.
         */
        accountName: string;
        /**
         * Specifies the branch of the repository to get code from.
         */
        branchName: string;
        /**
         * Specifies the name of the VSTS project.
         */
        projectName: string;
        /**
         * Specifies the name of the git repository.
         */
        repositoryName: string;
        /**
         * Specifies the root folder within the repository. Set to `/` for the top level.
         */
        rootFolder: string;
        /**
         * Specifies the Tenant ID associated with the VSTS account.
         */
        tenantId: string;
    }

    export interface GetFactoryGithubConfiguration {
        /**
         * The VSTS account name.
         */
        accountName: string;
        /**
         * The branch of the repository to get code from.
         */
        branchName: string;
        /**
         * The GitHub Enterprise host name.
         */
        gitUrl: string;
        /**
         * The name of the git repository.
         */
        repositoryName: string;
        /**
         * The root folder within the repository.
         */
        rootFolder: string;
    }

    export interface GetFactoryIdentity {
        identityIds: string[];
        /**
         * The ID of the Principal (Client) in Azure Active Directory.
         */
        principalId: string;
        /**
         * The Tenant ID associated with the VSTS account.
         */
        tenantId: string;
        /**
         * The identity type of the Data Factory.
         */
        type: string;
    }

    export interface GetFactoryVstsConfiguration {
        /**
         * The VSTS account name.
         */
        accountName: string;
        /**
         * The branch of the repository to get code from.
         */
        branchName: string;
        /**
         * The name of the VSTS project.
         */
        projectName: string;
        /**
         * The name of the git repository.
         */
        repositoryName: string;
        /**
         * The root folder within the repository.
         */
        rootFolder: string;
        /**
         * The Tenant ID associated with the VSTS account.
         */
        tenantId: string;
    }

    export interface IntegrationRuntimeManagedCatalogInfo {
        /**
         * Administrator login name for the SQL Server.
         */
        administratorLogin?: string;
        /**
         * Administrator login password for the SQL Server.
         */
        administratorPassword?: string;
        /**
         * Pricing tier for the database that will be created for the SSIS catalog. Valid values are: `Basic`, `Standard`, `Premium` and `PremiumRS`.
         */
        pricingTier?: string;
        /**
         * The endpoint of an Azure SQL Server that will be used to host the SSIS catalog.
         */
        serverEndpoint: string;
    }

    export interface IntegrationRuntimeManagedCustomSetupScript {
        /**
         * The blob endpoint for the container which contains a custom setup script that will be run on every node on startup. See [https://docs.microsoft.com/en-us/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup](https://docs.microsoft.com/en-us/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup) for more information.
         */
        blobContainerUri: string;
        /**
         * A container SAS token that gives access to the files. See [https://docs.microsoft.com/en-us/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup](https://docs.microsoft.com/en-us/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup) for more information.
         */
        sasToken: string;
    }

    export interface IntegrationRuntimeManagedVnetIntegration {
        /**
         * Name of the subnet to which the nodes of the Managed Integration Runtime will be added.
         */
        subnetName: string;
        /**
         * ID of the virtual network to which the nodes of the Managed Integration Runtime will be added.
         */
        vnetId: string;
    }

    export interface IntegrationRuntimeSelfHostedRbacAuthorization {
        /**
         * The resource identifier of the integration runtime to be shared. Changing this forces a new Data Factory to be created.
         */
        resourceId: string;
    }

    export interface IntegrationRuntimeSsisCatalogInfo {
        /**
         * Administrator login name for the SQL Server.
         */
        administratorLogin?: string;
        /**
         * Administrator login password for the SQL Server.
         */
        administratorPassword?: string;
        /**
         * Pricing tier for the database that will be created for the SSIS catalog. Valid values are: `Basic`, `Standard`, `Premium` and `PremiumRS`.
         */
        pricingTier?: string;
        /**
         * The endpoint of an Azure SQL Server that will be used to host the SSIS catalog.
         */
        serverEndpoint: string;
    }

    export interface IntegrationRuntimeSsisCustomSetupScript {
        /**
         * The blob endpoint for the container which contains a custom setup script that will be run on every node on startup. See [https://docs.microsoft.com/en-us/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup](https://docs.microsoft.com/en-us/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup) for more information.
         */
        blobContainerUri: string;
        /**
         * A container SAS token that gives access to the files. See [https://docs.microsoft.com/en-us/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup](https://docs.microsoft.com/en-us/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup) for more information.
         */
        sasToken: string;
    }

    export interface IntegrationRuntimeSsisVnetIntegration {
        /**
         * Name of the subnet to which the nodes of the Azure-SSIS Integration Runtime will be added.
         */
        subnetName: string;
        /**
         * ID of the virtual network to which the nodes of the Azure-SSIS Integration Runtime will be added.
         */
        vnetId: string;
    }

    export interface LinkedCustomServiceIntegrationRuntime {
        /**
         * The integration runtime reference to associate with the Data Factory Linked Service.
         */
        name: string;
        /**
         * A map of parameters to associate with the integration runtime.
         */
        parameters?: {[key: string]: string};
    }

    export interface LinkedServiceAzureDatabricksInstancePool {
        /**
         * Spark version of a the cluster.
         */
        clusterVersion: string;
        /**
         * Identifier of the instance pool within the linked ADB instance.
         */
        instancePoolId: string;
        /**
         * The max number of worker nodes. Set this value if you want to enable autoscaling between the `minNumberOfWorkers` and this value. Omit this value to use a fixed number of workers defined in the `minNumberOfWorkers` property.
         */
        maxNumberOfWorkers?: number;
        /**
         * The minimum number of worker nodes. Defaults to 1.
         */
        minNumberOfWorkers?: number;
    }

    export interface LinkedServiceAzureDatabricksKeyVaultPassword {
        /**
         * Specifies the name of an existing Key Vault Data Factory Linked Service.
         */
        linkedServiceName: string;
        /**
         * Specifies the secret name in Azure Key Vault that stores ADB access token.
         */
        secretName: string;
    }

    export interface LinkedServiceAzureDatabricksNewClusterConfig {
        /**
         * Spark version of a the cluster.
         */
        clusterVersion: string;
        /**
         * Tags for the cluster resource.
         */
        customTags?: {[key: string]: string};
        /**
         * Driver node type for the cluster.
         */
        driverNodeType?: string;
        /**
         * User defined initialization scripts for the cluster.
         */
        initScripts?: string[];
        /**
         * Location to deliver Spark driver, worker, and event logs.
         */
        logDestination?: string;
        /**
         * The max number of worker nodes. Set this value if you want to enable autoscaling between the `minNumberOfWorkers` and this value. Omit this value to use a fixed number of workers defined in the `minNumberOfWorkers` property.
         */
        maxNumberOfWorkers?: number;
        /**
         * The minimum number of worker nodes. Defaults to 1.
         */
        minNumberOfWorkers?: number;
        /**
         * Node type for the new cluster.
         */
        nodeType: string;
        /**
         * User-specified Spark configuration variables key-value pairs.
         */
        sparkConfig?: {[key: string]: string};
        /**
         * User-specified Spark environment variables key-value pairs.
         */
        sparkEnvironmentVariables?: {[key: string]: string};
    }

    export interface LinkedServiceAzureFileStorageKeyVaultPassword {
        /**
         * Specifies the name of an existing Key Vault Data Factory Linked Service.
         */
        linkedServiceName: string;
        /**
         * Specifies the secret name in Azure Key Vault that stores Azure File Storage password.
         */
        secretName: string;
    }

    export interface LinkedServiceAzureSqlDatabaseKeyVaultConnectionString {
        /**
         * Specifies the name of an existing Key Vault Data Factory Linked Service.
         */
        linkedServiceName: string;
        /**
         * Specifies the secret name in Azure Key Vault that stores SQL Server connection string.
         */
        secretName: string;
    }

    export interface LinkedServiceAzureSqlDatabaseKeyVaultPassword {
        /**
         * Specifies the name of an existing Key Vault Data Factory Linked Service.
         */
        linkedServiceName: string;
        /**
         * Specifies the secret name in Azure Key Vault that stores SQL Server password.
         */
        secretName: string;
    }

    export interface LinkedServiceOdataBasicAuthentication {
        /**
         * The password associated with the username, which can be used to authenticate to the OData endpoint.
         */
        password: string;
        /**
         * The username which can be used to authenticate to the OData endpoint.
         */
        username: string;
    }

    export interface LinkedServiceSnowflakeKeyVaultPassword {
        /**
         * Specifies the name of an existing Key Vault Data Factory Linked Service.
         */
        linkedServiceName: string;
        /**
         * Specifies the secret name in Azure Key Vault that stores Snowflake password.
         */
        secretName: string;
    }

    export interface LinkedServiceSqlServerKeyVaultConnectionString {
        /**
         * Specifies the name of an existing Key Vault Data Factory Linked Service.
         */
        linkedServiceName: string;
        /**
         * Specifies the secret name in Azure Key Vault that stores SQL Server connection string.
         */
        secretName: string;
    }

    export interface LinkedServiceSqlServerKeyVaultPassword {
        /**
         * Specifies the name of an existing Key Vault Data Factory Linked Service.
         */
        linkedServiceName: string;
        /**
         * Specifies the secret name in Azure Key Vault that stores SQL Server password.
         */
        secretName: string;
    }

    export interface LinkedServiceSynapseKeyVaultPassword {
        /**
         * Specifies the name of an existing Key Vault Data Factory Linked Service.
         */
        linkedServiceName: string;
        /**
         * Specifies the secret name in Azure Key Vault that stores Synapse password.
         */
        secretName: string;
    }

    export interface TriggerBlobEventPipeline {
        /**
         * The Data Factory Pipeline name that the trigger will act on.
         */
        name: string;
        /**
         * The Data Factory Pipeline parameters that the trigger will act on.
         */
        parameters?: {[key: string]: string};
    }

}

export namespace dataprotection {
    export interface BackupPolicyPostgresqlRetentionRule {
        /**
         * A `criteria` block as defined below. Changing this forces a new Backup Policy PostgreSQL to be created.
         */
        criteria: outputs.dataprotection.BackupPolicyPostgresqlRetentionRuleCriteria;
        /**
         * Duration after which the backup is deleted. It should follow `ISO 8601` duration format. Changing this forces a new Backup Policy PostgreSQL to be created.
         */
        duration: string;
        /**
         * The name which should be used for this retention rule. Changing this forces a new Backup Policy PostgreSQL to be created.
         */
        name: string;
        /**
         * Specifies the priority of the rule. The priority number must be unique for each rule. The lower the priority number, the higher the priority of the rule. Changing this forces a new Backup Policy Postgre Sql to be created.
         */
        priority: number;
    }

    export interface BackupPolicyPostgresqlRetentionRuleCriteria {
        /**
         * Possible values are `AllBackup`, `FirstOfDay`, `FirstOfWeek`, `FirstOfMonth` and `FirstOfYear`. These values mean the first successful backup of the day/week/month/year. Changing this forces a new Backup Policy PostgreSQL to be created.
         */
        absoluteCriteria?: string;
        /**
         * Possible values are `Monday`, `Tuesday`, `Thursday`, `Friday`, `Saturday` and `Sunday`. Changing this forces a new Backup Policy PostgreSQL to be created.
         */
        daysOfWeeks?: string[];
        /**
         * Possible values are `January`, `February`, `March`, `April`, `May`, `June`, `July`, `August`, `September`, `October`, `November` and `December`. Changing this forces a new Backup Policy PostgreSQL to be created.
         */
        monthsOfYears?: string[];
        /**
         * Specifies a list of backup times for backup in the `RFC3339` format. Changing this forces a new Backup Policy Postgre Sql to be created.
         */
        scheduledBackupTimes?: string[];
        /**
         * Possible values are `First`, `Second`, `Third`, `Fourth` and `Last`. Changing this forces a new Backup Policy PostgreSQL to be created.
         */
        weeksOfMonths?: string[];
    }

    export interface BackupVaultIdentity {
        /**
         * The Principal ID for the Service Principal associated with the Identity of this Backup Vault.
         */
        principalId: string;
        /**
         * The Tenant ID for the Service Principal associated with the Identity of this Backup Vault.
         */
        tenantId: string;
        /**
         * Specifies the identity type of the Backup Vault. Possible value is `SystemAssigned`.
         */
        type?: string;
    }

}

export namespace datashare {
    export interface AccountIdentity {
        /**
         * The Principal ID for the Service Principal associated with the Identity of this Data Share Account.
         */
        principalId: string;
        /**
         * The Tenant ID for the Service Principal associated with the Identity of this Data Share Account.
         */
        tenantId: string;
        /**
         * Specifies the identity type of the Data Share Account. At this time the only allowed value is `SystemAssigned`.
         */
        type: string;
    }

    export interface DatasetBlobStorageStorageAccount {
        /**
         * The name of the storage account to be shared with the receiver. Changing this forces a new Data Share Blob Storage Dataset to be created.
         */
        name: string;
        /**
         * The resource group name of the storage account to be shared with the receiver. Changing this forces a new Data Share Blob Storage Dataset to be created.
         */
        resourceGroupName: string;
        /**
         * The subscription id of the storage account to be shared with the receiver. Changing this forces a new Data Share Blob Storage Dataset to be created.
         */
        subscriptionId: string;
    }

    export interface GetAccountIdentity {
        /**
         * The ID of the Principal (Client) in Azure Active Directory.
         */
        principalId: string;
        /**
         * The ID of the Azure Active Directory Tenant.
         */
        tenantId: string;
        /**
         * The identity type of the Data Share Account.
         */
        type: string;
    }

    export interface GetDatasetBlobStorageStorageAccount {
        /**
         * The name of this Data Share Blob Storage Dataset.
         */
        name: string;
        /**
         * The resource group name of the storage account to be shared with the receiver.
         */
        resourceGroupName: string;
        /**
         * The subscription id of the storage account to be shared with the receiver.
         */
        subscriptionId: string;
    }

    export interface GetShareSnapshotSchedule {
        /**
         * The name of this Data Share.
         */
        name: string;
        /**
         * The interval of the synchronization with the source data.
         */
        recurrence: string;
        /**
         * The synchronization with the source data's start time.
         */
        startTime: string;
    }

    export interface ShareSnapshotSchedule {
        /**
         * The name of the snapshot schedule.
         */
        name: string;
        /**
         * The interval of the synchronization with the source data. Possible values are `Hour` and `Day`.
         */
        recurrence: string;
        /**
         * The synchronization with the source data's start time.
         */
        startTime: string;
    }

}

export namespace desktopvirtualization {
    export interface HostPoolRegistrationInfo {
        /**
         * A valid `RFC3339Time` for the expiration of the token.
         */
        expirationDate: string;
        resetToken: boolean;
        /**
         * The registration token generated by the Virtual Desktop Host Pool.
         */
        token: string;
    }

}

export namespace devtest {
    export interface GetVirtualNetworkAllowedSubnet {
        /**
         * Indicates if this subnet allows public IP addresses. Possible values are `Allow`, `Default` and `Deny`.
         */
        allowPublicIp: string;
        /**
         * The name of the subnet.
         */
        labSubnetName: string;
        /**
         * The resource identifier for the subnet.
         */
        resourceId: string;
    }

    export interface GetVirtualNetworkSubnetOverride {
        /**
         * The name of the subnet.
         */
        labSubnetName: string;
        /**
         * The resource identifier for the subnet.
         */
        resourceId: string;
        /**
         * Indicates if the subnet can be used for VM creation.  Possible values are `Allow`, `Default` and `Deny`.
         */
        useInVmCreationPermission: string;
        usePublicIpAddressPermission: string;
        /**
         * The virtual network pool associated with this subnet.
         */
        virtualNetworkPoolName: string;
    }

    export interface GlobalVMShutdownScheduleNotificationSettings {
        /**
         * Whether to enable pre-shutdown notifications. Possible values are `true` and `false`. Defaults to `false`
         */
        enabled: boolean;
        /**
         * Time in minutes between 15 and 120 before a shutdown event at which a notification will be sent. Defaults to `30`.
         */
        timeInMinutes?: number;
        /**
         * The webhook URL to which the notification will be sent. Required if `enabled` is `true`. Optional otherwise.
         */
        webhookUrl?: string;
    }

    export interface LinuxVirtualMachineGalleryImageReference {
        /**
         * The Offer of the Gallery Image. Changing this forces a new resource to be created.
         */
        offer: string;
        /**
         * The Publisher of the Gallery Image. Changing this forces a new resource to be created.
         */
        publisher: string;
        /**
         * The SKU of the Gallery Image. Changing this forces a new resource to be created.
         */
        sku: string;
        /**
         * The Version of the Gallery Image. Changing this forces a new resource to be created.
         */
        version: string;
    }

    export interface LinuxVirtualMachineInboundNatRule {
        /**
         * The Backend Port associated with this NAT Rule. Changing this forces a new resource to be created.
         */
        backendPort: number;
        /**
         * The frontend port associated with this Inbound NAT Rule.
         */
        frontendPort: number;
        /**
         * The Protocol used for this NAT Rule. Possible values are `Tcp` and `Udp`. Changing this forces a new resource to be created.
         */
        protocol: string;
    }

    export interface ScheduleDailyRecurrence {
        /**
         * The time each day when the schedule takes effect.
         */
        time: string;
    }

    export interface ScheduleHourlyRecurrence {
        minute: number;
    }

    export interface ScheduleNotificationSettings {
        /**
         * The status of the notification. Possible values are `Enabled` and `Disabled`. Defaults to `Disabled`
         */
        status?: string;
        /**
         * Time in minutes before event at which notification will be sent.
         */
        timeInMinutes?: number;
        /**
         * The webhook URL to which the notification will be sent.
         */
        webhookUrl?: string;
    }

    export interface ScheduleWeeklyRecurrence {
        /**
         * The time when the schedule takes effect.
         */
        time: string;
        /**
         * A list of days that this schedule takes effect . Possible values include `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday` and `Sunday`.
         */
        weekDays?: string[];
    }

    export interface VirtualNetworkSubnet {
        /**
         * Specifies the name of the Dev Test Virtual Network. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * Can this subnet be used for creating Virtual Machines? Possible values are `Allow`, `Default` and `Deny`.
         */
        useInVirtualMachineCreation?: string;
        /**
         * Can Virtual Machines in this Subnet use Public IP Addresses? Possible values are `Allow`, `Default` and `Deny`.
         */
        usePublicIpAddress?: string;
    }

    export interface WindowsVirtualMachineGalleryImageReference {
        /**
         * The Offer of the Gallery Image. Changing this forces a new resource to be created.
         */
        offer: string;
        /**
         * The Publisher of the Gallery Image. Changing this forces a new resource to be created.
         */
        publisher: string;
        /**
         * The SKU of the Gallery Image. Changing this forces a new resource to be created.
         */
        sku: string;
        /**
         * The Version of the Gallery Image. Changing this forces a new resource to be created.
         */
        version: string;
    }

    export interface WindowsVirtualMachineInboundNatRule {
        /**
         * The Backend Port associated with this NAT Rule. Changing this forces a new resource to be created.
         */
        backendPort: number;
        /**
         * The frontend port associated with this Inbound NAT Rule.
         */
        frontendPort: number;
        /**
         * The Protocol used for this NAT Rule. Possible values are `Tcp` and `Udp`. Changing this forces a new resource to be created.
         */
        protocol: string;
    }

}

export namespace dns {
    export interface CaaRecordRecord {
        /**
         * Extensible CAA flags, currently only 1 is implemented to set the issuer critical flag.
         */
        flags: number;
        /**
         * A property tag, options are issue, issuewild and iodef.
         */
        tag: string;
        /**
         * A property value such as a registrar domain.
         */
        value: string;
    }

    export interface MxRecordRecord {
        /**
         * The mail server responsible for the domain covered by the MX record.
         */
        exchange: string;
        /**
         * String representing the "preference” value of the MX records. Records with lower preference value take priority.
         */
        preference: string;
    }

    export interface SrvRecordRecord {
        /**
         * Port the service is listening on.
         */
        port: number;
        /**
         * Priority of the SRV record.
         */
        priority: number;
        /**
         * FQDN of the service.
         */
        target: string;
        /**
         * Weight of the SRV record.
         */
        weight: number;
    }

    export interface TxtRecordRecord {
        /**
         * The value of the record. Max length: 1024 characters
         */
        value: string;
    }

    export interface ZoneSoaRecord {
        /**
         * The email contact for the SOA record.
         */
        email: string;
        /**
         * The expire time for the SOA record. Defaults to `2419200`.
         */
        expireTime?: number;
        fqdn: string;
        /**
         * The domain name of the authoritative name server for the SOA record. Defaults to `ns1-03.azure-dns.com.`.
         */
        hostName: string;
        /**
         * The minimum Time To Live for the SOA record. By convention, it is used to determine the negative caching duration. Defaults to `300`.
         */
        minimumTtl?: number;
        /**
         * The refresh time for the SOA record. Defaults to `3600`.
         */
        refreshTime?: number;
        /**
         * The retry time for the SOA record. Defaults to `300`.
         */
        retryTime?: number;
        /**
         * The serial number for the SOA record. Defaults to `1`.
         */
        serialNumber?: number;
        /**
         * A mapping of tags to assign to the Record Set.
         */
        tags?: {[key: string]: string};
        /**
         * The Time To Live of the SOA Record in seconds. Defaults to `3600`.
         */
        ttl?: number;
    }

}

export namespace eventgrid {
    export interface DomainInboundIpRule {
        /**
         * The action to take when the rule is matched. Possible values are `Allow`.
         */
        action?: string;
        /**
         * The ip mask (CIDR) to match on.
         */
        ipMask: string;
    }

    export interface DomainInputMappingDefaultValues {
        /**
         * Specifies the default data version of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        dataVersion?: string;
        /**
         * Specifies the default event type of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        eventType?: string;
        /**
         * Specifies the default subject of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        subject?: string;
    }

    export interface DomainInputMappingFields {
        /**
         * Specifies the data version of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        dataVersion?: string;
        /**
         * Specifies the event time of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        eventTime?: string;
        /**
         * Specifies the event type of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        eventType?: string;
        /**
         * Specifies the id of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        id?: string;
        /**
         * Specifies the subject of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        subject?: string;
        /**
         * Specifies the topic of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        topic?: string;
    }

    export interface EventSubscriptionAdvancedFilter {
        /**
         * Compares a value of an event using a single boolean value.
         */
        boolEquals?: outputs.eventgrid.EventSubscriptionAdvancedFilterBoolEqual[];
        /**
         * Evaluates if a value of an event isn't NULL or undefined.
         */
        isNotNulls?: outputs.eventgrid.EventSubscriptionAdvancedFilterIsNotNull[];
        /**
         * Evaluates if a value of an event is NULL or undefined.
         */
        isNullOrUndefineds?: outputs.eventgrid.EventSubscriptionAdvancedFilterIsNullOrUndefined[];
        /**
         * Compares a value of an event using a single floating point number.
         */
        numberGreaterThanOrEquals?: outputs.eventgrid.EventSubscriptionAdvancedFilterNumberGreaterThanOrEqual[];
        /**
         * Compares a value of an event using a single floating point number.
         */
        numberGreaterThans?: outputs.eventgrid.EventSubscriptionAdvancedFilterNumberGreaterThan[];
        /**
         * Compares a value of an event using multiple floating point number ranges.
         */
        numberInRanges?: outputs.eventgrid.EventSubscriptionAdvancedFilterNumberInRange[];
        /**
         * Compares a value of an event using multiple floating point numbers.
         */
        numberIns?: outputs.eventgrid.EventSubscriptionAdvancedFilterNumberIn[];
        /**
         * Compares a value of an event using a single floating point number.
         */
        numberLessThanOrEquals?: outputs.eventgrid.EventSubscriptionAdvancedFilterNumberLessThanOrEqual[];
        /**
         * Compares a value of an event using a single floating point number.
         */
        numberLessThans?: outputs.eventgrid.EventSubscriptionAdvancedFilterNumberLessThan[];
        /**
         * Compares a value of an event using multiple floating point number ranges.
         */
        numberNotInRanges?: outputs.eventgrid.EventSubscriptionAdvancedFilterNumberNotInRange[];
        /**
         * Compares a value of an event using multiple floating point numbers.
         */
        numberNotIns?: outputs.eventgrid.EventSubscriptionAdvancedFilterNumberNotIn[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringBeginsWiths?: outputs.eventgrid.EventSubscriptionAdvancedFilterStringBeginsWith[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringContains?: outputs.eventgrid.EventSubscriptionAdvancedFilterStringContain[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringEndsWiths?: outputs.eventgrid.EventSubscriptionAdvancedFilterStringEndsWith[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringIns?: outputs.eventgrid.EventSubscriptionAdvancedFilterStringIn[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringNotBeginsWiths?: outputs.eventgrid.EventSubscriptionAdvancedFilterStringNotBeginsWith[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringNotContains?: outputs.eventgrid.EventSubscriptionAdvancedFilterStringNotContain[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringNotEndsWiths?: outputs.eventgrid.EventSubscriptionAdvancedFilterStringNotEndsWith[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringNotIns?: outputs.eventgrid.EventSubscriptionAdvancedFilterStringNotIn[];
    }

    export interface EventSubscriptionAdvancedFilterBoolEqual {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies a single value to compare to when using a single value operator.
         */
        value: boolean;
    }

    export interface EventSubscriptionAdvancedFilterIsNotNull {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
    }

    export interface EventSubscriptionAdvancedFilterIsNullOrUndefined {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
    }

    export interface EventSubscriptionAdvancedFilterNumberGreaterThan {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies a single value to compare to when using a single value operator.
         */
        value: number;
    }

    export interface EventSubscriptionAdvancedFilterNumberGreaterThanOrEqual {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies a single value to compare to when using a single value operator.
         */
        value: number;
    }

    export interface EventSubscriptionAdvancedFilterNumberIn {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         */
        values: number[];
    }

    export interface EventSubscriptionAdvancedFilterNumberInRange {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         */
        values: number[][];
    }

    export interface EventSubscriptionAdvancedFilterNumberLessThan {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies a single value to compare to when using a single value operator.
         */
        value: number;
    }

    export interface EventSubscriptionAdvancedFilterNumberLessThanOrEqual {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies a single value to compare to when using a single value operator.
         */
        value: number;
    }

    export interface EventSubscriptionAdvancedFilterNumberNotIn {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         */
        values: number[];
    }

    export interface EventSubscriptionAdvancedFilterNumberNotInRange {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         */
        values: number[][];
    }

    export interface EventSubscriptionAdvancedFilterStringBeginsWith {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         */
        values: string[];
    }

    export interface EventSubscriptionAdvancedFilterStringContain {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         */
        values: string[];
    }

    export interface EventSubscriptionAdvancedFilterStringEndsWith {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         */
        values: string[];
    }

    export interface EventSubscriptionAdvancedFilterStringIn {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         */
        values: string[];
    }

    export interface EventSubscriptionAdvancedFilterStringNotBeginsWith {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         */
        values: string[];
    }

    export interface EventSubscriptionAdvancedFilterStringNotContain {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         */
        values: string[];
    }

    export interface EventSubscriptionAdvancedFilterStringNotEndsWith {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         */
        values: string[];
    }

    export interface EventSubscriptionAdvancedFilterStringNotIn {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         */
        values: string[];
    }

    export interface EventSubscriptionAzureFunctionEndpoint {
        /**
         * Specifies the ID of the Function where the Event Subscription will receive events. This must be the functions ID in format {function_app.id}/functions/{name}.
         */
        functionId: string;
        /**
         * Maximum number of events per batch.
         */
        maxEventsPerBatch?: number;
        /**
         * Preferred batch size in Kilobytes.
         */
        preferredBatchSizeInKilobytes?: number;
    }

    export interface EventSubscriptionEventhubEndpoint {
        /**
         * Specifies the id of the eventhub where the Event Subscription will receive events.
         */
        eventhubId: string;
    }

    export interface EventSubscriptionHybridConnectionEndpoint {
        /**
         * Specifies the id of the hybrid connection where the Event Subscription will receive events.
         */
        hybridConnectionId: string;
    }

    export interface EventSubscriptionRetryPolicy {
        /**
         * Specifies the time to live (in minutes) for events. Supported range is `1` to `1440`. Defaults to `1440`. See [official documentation](https://docs.microsoft.com/en-us/azure/event-grid/manage-event-delivery#set-retry-policy) for more details.
         */
        eventTimeToLive: number;
        /**
         * Specifies the maximum number of delivery retry attempts for events.
         */
        maxDeliveryAttempts: number;
    }

    export interface EventSubscriptionStorageBlobDeadLetterDestination {
        /**
         * Specifies the id of the storage account id where the storage blob is located.
         */
        storageAccountId: string;
        /**
         * Specifies the name of the Storage blob container that is the destination of the deadletter events.
         */
        storageBlobContainerName: string;
    }

    export interface EventSubscriptionStorageQueueEndpoint {
        /**
         * Specifies the name of the storage queue where the Event Subscription will receive events.
         */
        queueName: string;
        /**
         * Specifies the id of the storage account id where the storage queue is located.
         */
        storageAccountId: string;
    }

    export interface EventSubscriptionSubjectFilter {
        /**
         * Specifies if `subjectBeginsWith` and `subjectEndsWith` case sensitive. This value defaults to `false`.
         */
        caseSensitive?: boolean;
        /**
         * A string to filter events for an event subscription based on a resource path prefix.
         */
        subjectBeginsWith?: string;
        /**
         * A string to filter events for an event subscription based on a resource path suffix.
         */
        subjectEndsWith?: string;
    }

    export interface EventSubscriptionWebhookEndpoint {
        /**
         * The Azure Active Directory Application ID or URI to get the access token that will be included as the bearer token in delivery requests.
         */
        activeDirectoryAppIdOrUri?: string;
        /**
         * The Azure Active Directory Tenant ID to get the access token that will be included as the bearer token in delivery requests.
         */
        activeDirectoryTenantId?: string;
        /**
         * The base url of the webhook where the Event Subscription will receive events.
         */
        baseUrl: string;
        /**
         * Maximum number of events per batch.
         */
        maxEventsPerBatch?: number;
        /**
         * Preferred batch size in Kilobytes.
         */
        preferredBatchSizeInKilobytes?: number;
        /**
         * Specifies the url of the webhook where the Event Subscription will receive events.
         */
        url: string;
    }

    export interface SystemTopicEventSubscriptionAdvancedFilter {
        /**
         * Compares a value of an event using a single boolean value.
         */
        boolEquals?: outputs.eventgrid.SystemTopicEventSubscriptionAdvancedFilterBoolEqual[];
        /**
         * Evaluates if a value of an event isn't NULL or undefined.
         */
        isNotNulls?: outputs.eventgrid.SystemTopicEventSubscriptionAdvancedFilterIsNotNull[];
        /**
         * Evaluates if a value of an event is NULL or undefined.
         */
        isNullOrUndefineds?: outputs.eventgrid.SystemTopicEventSubscriptionAdvancedFilterIsNullOrUndefined[];
        /**
         * Compares a value of an event using a single floating point number.
         */
        numberGreaterThanOrEquals?: outputs.eventgrid.SystemTopicEventSubscriptionAdvancedFilterNumberGreaterThanOrEqual[];
        /**
         * Compares a value of an event using a single floating point number.
         */
        numberGreaterThans?: outputs.eventgrid.SystemTopicEventSubscriptionAdvancedFilterNumberGreaterThan[];
        /**
         * Compares a value of an event using multiple floating point number ranges.
         */
        numberInRanges?: outputs.eventgrid.SystemTopicEventSubscriptionAdvancedFilterNumberInRange[];
        /**
         * Compares a value of an event using multiple floating point numbers.
         */
        numberIns?: outputs.eventgrid.SystemTopicEventSubscriptionAdvancedFilterNumberIn[];
        /**
         * Compares a value of an event using a single floating point number.
         */
        numberLessThanOrEquals?: outputs.eventgrid.SystemTopicEventSubscriptionAdvancedFilterNumberLessThanOrEqual[];
        /**
         * Compares a value of an event using a single floating point number.
         */
        numberLessThans?: outputs.eventgrid.SystemTopicEventSubscriptionAdvancedFilterNumberLessThan[];
        /**
         * Compares a value of an event using multiple floating point number ranges.
         */
        numberNotInRanges?: outputs.eventgrid.SystemTopicEventSubscriptionAdvancedFilterNumberNotInRange[];
        /**
         * Compares a value of an event using multiple floating point numbers.
         */
        numberNotIns?: outputs.eventgrid.SystemTopicEventSubscriptionAdvancedFilterNumberNotIn[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringBeginsWiths?: outputs.eventgrid.SystemTopicEventSubscriptionAdvancedFilterStringBeginsWith[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringContains?: outputs.eventgrid.SystemTopicEventSubscriptionAdvancedFilterStringContain[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringEndsWiths?: outputs.eventgrid.SystemTopicEventSubscriptionAdvancedFilterStringEndsWith[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringIns?: outputs.eventgrid.SystemTopicEventSubscriptionAdvancedFilterStringIn[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringNotBeginsWiths?: outputs.eventgrid.SystemTopicEventSubscriptionAdvancedFilterStringNotBeginsWith[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringNotContains?: outputs.eventgrid.SystemTopicEventSubscriptionAdvancedFilterStringNotContain[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringNotEndsWiths?: outputs.eventgrid.SystemTopicEventSubscriptionAdvancedFilterStringNotEndsWith[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringNotIns?: outputs.eventgrid.SystemTopicEventSubscriptionAdvancedFilterStringNotIn[];
    }

    export interface SystemTopicEventSubscriptionAdvancedFilterBoolEqual {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies a single value to compare to when using a single value operator.
         */
        value: boolean;
    }

    export interface SystemTopicEventSubscriptionAdvancedFilterIsNotNull {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
    }

    export interface SystemTopicEventSubscriptionAdvancedFilterIsNullOrUndefined {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
    }

    export interface SystemTopicEventSubscriptionAdvancedFilterNumberGreaterThan {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies a single value to compare to when using a single value operator.
         */
        value: number;
    }

    export interface SystemTopicEventSubscriptionAdvancedFilterNumberGreaterThanOrEqual {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies a single value to compare to when using a single value operator.
         */
        value: number;
    }

    export interface SystemTopicEventSubscriptionAdvancedFilterNumberIn {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         */
        values: number[];
    }

    export interface SystemTopicEventSubscriptionAdvancedFilterNumberInRange {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         */
        values: number[][];
    }

    export interface SystemTopicEventSubscriptionAdvancedFilterNumberLessThan {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies a single value to compare to when using a single value operator.
         */
        value: number;
    }

    export interface SystemTopicEventSubscriptionAdvancedFilterNumberLessThanOrEqual {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies a single value to compare to when using a single value operator.
         */
        value: number;
    }

    export interface SystemTopicEventSubscriptionAdvancedFilterNumberNotIn {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         */
        values: number[];
    }

    export interface SystemTopicEventSubscriptionAdvancedFilterNumberNotInRange {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         */
        values: number[][];
    }

    export interface SystemTopicEventSubscriptionAdvancedFilterStringBeginsWith {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         */
        values: string[];
    }

    export interface SystemTopicEventSubscriptionAdvancedFilterStringContain {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         */
        values: string[];
    }

    export interface SystemTopicEventSubscriptionAdvancedFilterStringEndsWith {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         */
        values: string[];
    }

    export interface SystemTopicEventSubscriptionAdvancedFilterStringIn {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         */
        values: string[];
    }

    export interface SystemTopicEventSubscriptionAdvancedFilterStringNotBeginsWith {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         */
        values: string[];
    }

    export interface SystemTopicEventSubscriptionAdvancedFilterStringNotContain {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         */
        values: string[];
    }

    export interface SystemTopicEventSubscriptionAdvancedFilterStringNotEndsWith {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         */
        values: string[];
    }

    export interface SystemTopicEventSubscriptionAdvancedFilterStringNotIn {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         */
        values: string[];
    }

    export interface SystemTopicEventSubscriptionAzureFunctionEndpoint {
        /**
         * Specifies the ID of the Function where the Event Subscription will receive events. This must be the functions ID in format {function_app.id}/functions/{name}.
         */
        functionId: string;
        /**
         * Maximum number of events per batch.
         */
        maxEventsPerBatch?: number;
        /**
         * Preferred batch size in Kilobytes.
         */
        preferredBatchSizeInKilobytes?: number;
    }

    export interface SystemTopicEventSubscriptionRetryPolicy {
        /**
         * Specifies the time to live (in minutes) for events. Supported range is `1` to `1440`. Defaults to `1440`. See [official documentation](https://docs.microsoft.com/en-us/azure/event-grid/manage-event-delivery#set-retry-policy) for more details.
         */
        eventTimeToLive: number;
        /**
         * Specifies the maximum number of delivery retry attempts for events.
         */
        maxDeliveryAttempts: number;
    }

    export interface SystemTopicEventSubscriptionStorageBlobDeadLetterDestination {
        /**
         * Specifies the id of the storage account id where the storage blob is located.
         */
        storageAccountId: string;
        /**
         * Specifies the name of the Storage blob container that is the destination of the deadletter events.
         */
        storageBlobContainerName: string;
    }

    export interface SystemTopicEventSubscriptionStorageQueueEndpoint {
        /**
         * Specifies the name of the storage queue where the Event Subscription will receive events.
         */
        queueName: string;
        /**
         * Specifies the id of the storage account id where the storage queue is located.
         */
        storageAccountId: string;
    }

    export interface SystemTopicEventSubscriptionSubjectFilter {
        /**
         * Specifies if `subjectBeginsWith` and `subjectEndsWith` case sensitive. This value defaults to `false`.
         */
        caseSensitive?: boolean;
        /**
         * A string to filter events for an event subscription based on a resource path prefix.
         */
        subjectBeginsWith?: string;
        /**
         * A string to filter events for an event subscription based on a resource path suffix.
         */
        subjectEndsWith?: string;
    }

    export interface SystemTopicEventSubscriptionWebhookEndpoint {
        /**
         * The Azure Active Directory Application ID or URI to get the access token that will be included as the bearer token in delivery requests.
         */
        activeDirectoryAppIdOrUri?: string;
        /**
         * The Azure Active Directory Tenant ID to get the access token that will be included as the bearer token in delivery requests.
         */
        activeDirectoryTenantId?: string;
        /**
         * The base url of the webhook where the Event Subscription will receive events.
         */
        baseUrl: string;
        /**
         * Maximum number of events per batch.
         */
        maxEventsPerBatch?: number;
        /**
         * Preferred batch size in Kilobytes.
         */
        preferredBatchSizeInKilobytes?: number;
        /**
         * Specifies the url of the webhook where the Event Subscription will receive events.
         */
        url: string;
    }

    export interface TopicInboundIpRule {
        /**
         * The action to take when the rule is matched. Possible values are `Allow`.
         */
        action?: string;
        /**
         * The ip mask (CIDR) to match on.
         */
        ipMask: string;
    }

    export interface TopicInputMappingDefaultValues {
        /**
         * Specifies the default data version of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        dataVersion?: string;
        /**
         * Specifies the default event type of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        eventType?: string;
        /**
         * Specifies the default subject of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        subject?: string;
    }

    export interface TopicInputMappingFields {
        /**
         * Specifies the data version of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        dataVersion?: string;
        /**
         * Specifies the event time of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        eventTime?: string;
        /**
         * Specifies the event type of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        eventType?: string;
        /**
         * Specifies the id of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        id?: string;
        /**
         * Specifies the subject of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        subject?: string;
        /**
         * Specifies the topic of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        topic?: string;
    }

}

export namespace eventhub {
    export interface DomainInboundIpRule {
        /**
         * The action to take when the rule is matched. Possible values are `Allow`.
         */
        action?: string;
        /**
         * The ip mask (CIDR) to match on.
         */
        ipMask: string;
    }

    export interface DomainInputMappingDefaultValues {
        /**
         * Specifies the default data version of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        dataVersion?: string;
        /**
         * Specifies the default event type of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        eventType?: string;
        /**
         * Specifies the default subject of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        subject?: string;
    }

    export interface DomainInputMappingFields {
        /**
         * Specifies the data version of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        dataVersion?: string;
        /**
         * Specifies the event time of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        eventTime?: string;
        /**
         * Specifies the event type of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        eventType?: string;
        /**
         * Specifies the id of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        id?: string;
        /**
         * Specifies the subject of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        subject?: string;
        /**
         * Specifies the topic of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        topic?: string;
    }

    export interface EventGridTopicInboundIpRule {
        /**
         * The action to take when the rule is matched. Possible values are `Allow`.
         */
        action?: string;
        /**
         * The ip mask (CIDR) to match on.
         */
        ipMask: string;
    }

    export interface EventGridTopicInputMappingDefaultValues {
        /**
         * Specifies the default data version of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        dataVersion?: string;
        /**
         * Specifies the default event type of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        eventType?: string;
        /**
         * Specifies the default subject of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        subject?: string;
    }

    export interface EventGridTopicInputMappingFields {
        /**
         * Specifies the data version of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        dataVersion?: string;
        /**
         * Specifies the event time of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        eventTime?: string;
        /**
         * Specifies the event type of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        eventType?: string;
        /**
         * Specifies the id of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        id?: string;
        /**
         * Specifies the subject of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        subject?: string;
        /**
         * Specifies the topic of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        topic?: string;
    }

    export interface EventHubCaptureDescription {
        /**
         * A `destination` block as defined below.
         */
        destination: outputs.eventhub.EventHubCaptureDescriptionDestination;
        /**
         * Specifies if the Capture Description is Enabled.
         */
        enabled: boolean;
        /**
         * Specifies the Encoding used for the Capture Description. Possible values are `Avro` and `AvroDeflate`.
         */
        encoding: string;
        /**
         * Specifies the time interval in seconds at which the capture will happen. Values can be between `60` and `900` seconds. Defaults to `300` seconds.
         */
        intervalInSeconds?: number;
        /**
         * Specifies the amount of data built up in your EventHub before a Capture Operation occurs. Value should be between `10485760` and `524288000`  bytes. Defaults to `314572800` bytes.
         */
        sizeLimitInBytes?: number;
        /**
         * Specifies if empty files should not be emitted if no events occur during the Capture time window.  Defaults to `false`.
         */
        skipEmptyArchives?: boolean;
    }

    export interface EventHubCaptureDescriptionDestination {
        /**
         * The Blob naming convention for archiving. e.g. `{Namespace}/{EventHub}/{PartitionId}/{Year}/{Month}/{Day}/{Hour}/{Minute}/{Second}`. Here all the parameters (Namespace,EventHub .. etc) are mandatory irrespective of order
         */
        archiveNameFormat: string;
        /**
         * The name of the Container within the Blob Storage Account where messages should be archived.
         */
        blobContainerName: string;
        /**
         * The Name of the Destination where the capture should take place. At this time the only supported value is `EventHubArchive.AzureBlockBlob`.
         */
        name: string;
        /**
         * The ID of the Blob Storage Account where messages should be archived.
         */
        storageAccountId: string;
    }

    export interface EventHubNamespaceIdentity {
        /**
         * The Client ID of the Service Principal assigned to this EventHub Namespace.
         */
        principalId: string;
        /**
         * The ID of the Tenant the Service Principal is assigned in.
         */
        tenantId: string;
        /**
         * The Type of Identity which should be used for this EventHub Namespace. At this time the only possible value is `SystemAssigned`.
         */
        type: string;
    }

    export interface EventHubNamespaceNetworkRulesets {
        /**
         * The default action to take when a rule is not matched. Possible values are `Allow` and `Deny`. Defaults to `Deny`.
         */
        defaultAction: string;
        /**
         * One or more `ipRule` blocks as defined below.
         */
        ipRules?: outputs.eventhub.EventHubNamespaceNetworkRulesetsIpRule[];
        /**
         * Whether Trusted Microsoft Services are allowed to bypass firewall.
         */
        trustedServiceAccessEnabled?: boolean;
        /**
         * One or more `virtualNetworkRule` blocks as defined below.
         */
        virtualNetworkRules?: outputs.eventhub.EventHubNamespaceNetworkRulesetsVirtualNetworkRule[];
    }

    export interface EventHubNamespaceNetworkRulesetsIpRule {
        /**
         * The action to take when the rule is matched. Possible values are `Allow`.
         */
        action?: string;
        /**
         * The ip mask to match on.
         */
        ipMask: string;
    }

    export interface EventHubNamespaceNetworkRulesetsVirtualNetworkRule {
        /**
         * Are missing virtual network service endpoints ignored? Defaults to `false`.
         */
        ignoreMissingVirtualNetworkServiceEndpoint?: boolean;
        /**
         * The id of the subnet to match on.
         */
        subnetId: string;
    }

    export interface EventSubscriptionAdvancedFilter {
        /**
         * Compares a value of an event using a single boolean value.
         */
        boolEquals?: outputs.eventhub.EventSubscriptionAdvancedFilterBoolEqual[];
        /**
         * Evaluates if a value of an event isn't NULL or undefined.
         */
        isNotNulls?: outputs.eventhub.EventSubscriptionAdvancedFilterIsNotNull[];
        /**
         * Evaluates if a value of an event is NULL or undefined.
         */
        isNullOrUndefineds?: outputs.eventhub.EventSubscriptionAdvancedFilterIsNullOrUndefined[];
        /**
         * Compares a value of an event using a single floating point number.
         */
        numberGreaterThanOrEquals?: outputs.eventhub.EventSubscriptionAdvancedFilterNumberGreaterThanOrEqual[];
        /**
         * Compares a value of an event using a single floating point number.
         */
        numberGreaterThans?: outputs.eventhub.EventSubscriptionAdvancedFilterNumberGreaterThan[];
        /**
         * Compares a value of an event using multiple floating point number ranges.
         */
        numberInRanges?: outputs.eventhub.EventSubscriptionAdvancedFilterNumberInRange[];
        /**
         * Compares a value of an event using multiple floating point numbers.
         */
        numberIns?: outputs.eventhub.EventSubscriptionAdvancedFilterNumberIn[];
        /**
         * Compares a value of an event using a single floating point number.
         */
        numberLessThanOrEquals?: outputs.eventhub.EventSubscriptionAdvancedFilterNumberLessThanOrEqual[];
        /**
         * Compares a value of an event using a single floating point number.
         */
        numberLessThans?: outputs.eventhub.EventSubscriptionAdvancedFilterNumberLessThan[];
        /**
         * Compares a value of an event using multiple floating point number ranges.
         */
        numberNotInRanges?: outputs.eventhub.EventSubscriptionAdvancedFilterNumberNotInRange[];
        /**
         * Compares a value of an event using multiple floating point numbers.
         */
        numberNotIns?: outputs.eventhub.EventSubscriptionAdvancedFilterNumberNotIn[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringBeginsWiths?: outputs.eventhub.EventSubscriptionAdvancedFilterStringBeginsWith[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringContains?: outputs.eventhub.EventSubscriptionAdvancedFilterStringContain[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringEndsWiths?: outputs.eventhub.EventSubscriptionAdvancedFilterStringEndsWith[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringIns?: outputs.eventhub.EventSubscriptionAdvancedFilterStringIn[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringNotBeginsWiths?: outputs.eventhub.EventSubscriptionAdvancedFilterStringNotBeginsWith[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringNotContains?: outputs.eventhub.EventSubscriptionAdvancedFilterStringNotContain[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringNotEndsWiths?: outputs.eventhub.EventSubscriptionAdvancedFilterStringNotEndsWith[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringNotIns?: outputs.eventhub.EventSubscriptionAdvancedFilterStringNotIn[];
    }

    export interface EventSubscriptionAdvancedFilterBoolEqual {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies a single value to compare to when using a single value operator.
         */
        value: boolean;
    }

    export interface EventSubscriptionAdvancedFilterIsNotNull {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
    }

    export interface EventSubscriptionAdvancedFilterIsNullOrUndefined {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
    }

    export interface EventSubscriptionAdvancedFilterNumberGreaterThan {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies a single value to compare to when using a single value operator.
         */
        value: number;
    }

    export interface EventSubscriptionAdvancedFilterNumberGreaterThanOrEqual {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies a single value to compare to when using a single value operator.
         */
        value: number;
    }

    export interface EventSubscriptionAdvancedFilterNumberIn {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         */
        values: number[];
    }

    export interface EventSubscriptionAdvancedFilterNumberInRange {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         */
        values: number[][];
    }

    export interface EventSubscriptionAdvancedFilterNumberLessThan {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies a single value to compare to when using a single value operator.
         */
        value: number;
    }

    export interface EventSubscriptionAdvancedFilterNumberLessThanOrEqual {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies a single value to compare to when using a single value operator.
         */
        value: number;
    }

    export interface EventSubscriptionAdvancedFilterNumberNotIn {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         */
        values: number[];
    }

    export interface EventSubscriptionAdvancedFilterNumberNotInRange {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         */
        values: number[][];
    }

    export interface EventSubscriptionAdvancedFilterStringBeginsWith {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         */
        values: string[];
    }

    export interface EventSubscriptionAdvancedFilterStringContain {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         */
        values: string[];
    }

    export interface EventSubscriptionAdvancedFilterStringEndsWith {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         */
        values: string[];
    }

    export interface EventSubscriptionAdvancedFilterStringIn {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         */
        values: string[];
    }

    export interface EventSubscriptionAdvancedFilterStringNotBeginsWith {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         */
        values: string[];
    }

    export interface EventSubscriptionAdvancedFilterStringNotContain {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         */
        values: string[];
    }

    export interface EventSubscriptionAdvancedFilterStringNotEndsWith {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         */
        values: string[];
    }

    export interface EventSubscriptionAdvancedFilterStringNotIn {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         */
        values: string[];
    }

    export interface EventSubscriptionAzureFunctionEndpoint {
        /**
         * Specifies the ID of the Function where the Event Subscription will receive events. This must be the functions ID in format {function_app.id}/functions/{name}.
         */
        functionId: string;
        /**
         * Maximum number of events per batch.
         */
        maxEventsPerBatch?: number;
        /**
         * Preferred batch size in Kilobytes.
         */
        preferredBatchSizeInKilobytes?: number;
    }

    export interface EventSubscriptionEventhubEndpoint {
        /**
         * Specifies the id of the eventhub where the Event Subscription will receive events.
         */
        eventhubId: string;
    }

    export interface EventSubscriptionHybridConnectionEndpoint {
        /**
         * Specifies the id of the hybrid connection where the Event Subscription will receive events.
         */
        hybridConnectionId: string;
    }

    export interface EventSubscriptionRetryPolicy {
        /**
         * Specifies the time to live (in minutes) for events. Supported range is `1` to `1440`. Defaults to `1440`. See [official documentation](https://docs.microsoft.com/en-us/azure/event-grid/manage-event-delivery#set-retry-policy) for more details.
         */
        eventTimeToLive: number;
        /**
         * Specifies the maximum number of delivery retry attempts for events.
         */
        maxDeliveryAttempts: number;
    }

    export interface EventSubscriptionStorageBlobDeadLetterDestination {
        /**
         * Specifies the id of the storage account id where the storage blob is located.
         */
        storageAccountId: string;
        /**
         * Specifies the name of the Storage blob container that is the destination of the deadletter events.
         */
        storageBlobContainerName: string;
    }

    export interface EventSubscriptionStorageQueueEndpoint {
        /**
         * Specifies the name of the storage queue where the Event Subscription will receive events.
         */
        queueName: string;
        /**
         * Specifies the id of the storage account id where the storage queue is located.
         */
        storageAccountId: string;
    }

    export interface EventSubscriptionSubjectFilter {
        /**
         * Specifies if `subjectBeginsWith` and `subjectEndsWith` case sensitive. This value defaults to `false`.
         */
        caseSensitive?: boolean;
        /**
         * A string to filter events for an event subscription based on a resource path prefix.
         */
        subjectBeginsWith?: string;
        /**
         * A string to filter events for an event subscription based on a resource path suffix.
         */
        subjectEndsWith?: string;
    }

    export interface EventSubscriptionWebhookEndpoint {
        /**
         * The Azure Active Directory Application ID or URI to get the access token that will be included as the bearer token in delivery requests.
         */
        activeDirectoryAppIdOrUri?: string;
        /**
         * The Azure Active Directory Tenant ID to get the access token that will be included as the bearer token in delivery requests.
         */
        activeDirectoryTenantId?: string;
        /**
         * The base url of the webhook where the Event Subscription will receive events.
         */
        baseUrl: string;
        /**
         * Maximum number of events per batch.
         */
        maxEventsPerBatch?: number;
        /**
         * Preferred batch size in Kilobytes.
         */
        preferredBatchSizeInKilobytes?: number;
        /**
         * Specifies the url of the webhook where the Event Subscription will receive events.
         */
        url: string;
    }

    export interface SubscriptionRuleCorrelationFilter {
        /**
         * Content type of the message.
         */
        contentType?: string;
        /**
         * Identifier of the correlation.
         */
        correlationId?: string;
        /**
         * Application specific label.
         */
        label?: string;
        /**
         * Identifier of the message.
         */
        messageId?: string;
        /**
         * A list of user defined properties to be included in the filter. Specified as a map of name/value pairs.
         */
        properties?: {[key: string]: string};
        /**
         * Address of the queue to reply to.
         */
        replyTo?: string;
        /**
         * Session identifier to reply to.
         */
        replyToSessionId?: string;
        /**
         * Session identifier.
         */
        sessionId?: string;
        /**
         * Address to send to.
         */
        to?: string;
    }

}

export namespace frontdoor {
    export interface CustomHttpsConfigurationCustomHttpsConfiguration {
        /**
         * The name of the Key Vault secret representing the full certificate PFX.
         */
        azureKeyVaultCertificateSecretName?: string;
        /**
         * The version of the Key Vault secret representing the full certificate PFX. Defaults to `Latest`.
         */
        azureKeyVaultCertificateSecretVersion?: string;
        /**
         * The ID of the Key Vault containing the SSL certificate.
         */
        azureKeyVaultCertificateVaultId?: string;
        /**
         * Certificate source to encrypted `HTTPS` traffic with. Allowed values are `FrontDoor` or `AzureKeyVault`. Defaults to `FrontDoor`.
         */
        certificateSource?: string;
        /**
         * Minimum client TLS version supported.
         */
        minimumTlsVersion: string;
        provisioningState: string;
        provisioningSubstate: string;
    }

    export interface FirewallPolicyCustomRule {
        /**
         * The action to perform when the rule is matched. Possible values are `Allow`, `Block`, `Log`, or `Redirect`.
         */
        action: string;
        /**
         * Is the rule is enabled or disabled? Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * One or more `matchCondition` block defined below. Can support up to `10` `matchCondition` blocks.
         */
        matchConditions?: outputs.frontdoor.FirewallPolicyCustomRuleMatchCondition[];
        /**
         * Gets name of the resource that is unique within a policy. This name can be used to access the resource.
         */
        name: string;
        /**
         * The priority of the rule. Rules with a lower value will be evaluated before rules with a higher value. Defaults to `1`.
         */
        priority?: number;
        /**
         * The rate limit duration in minutes. Defaults to `1`.
         */
        rateLimitDurationInMinutes?: number;
        /**
         * The rate limit threshold. Defaults to `10`.
         */
        rateLimitThreshold?: number;
        /**
         * The type of rule. Possible values are `MatchRule` or `RateLimitRule`.
         */
        type: string;
    }

    export interface FirewallPolicyCustomRuleMatchCondition {
        /**
         * Up to `600` possible values to match. Limit is in total across all `matchCondition` blocks and `matchValues` arguments. String value itself can be up to `256` characters long.
         */
        matchValues: string[];
        /**
         * The request variable to compare with. Possible values are `Cookies`, `PostArgs`, `QueryString`, `RemoteAddr`, `RequestBody`, `RequestHeader`, `RequestMethod`, `RequestUri`, or `SocketAddr`.
         */
        matchVariable: string;
        /**
         * Should the result of the condition be negated.
         */
        negationCondition?: boolean;
        /**
         * Comparison type to use for matching with the variable value. Possible values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GeoMatch`, `GreaterThan`, `GreaterThanOrEqual`, `IPMatch`, `LessThan`, `LessThanOrEqual` or `RegEx`.
         */
        operator: string;
        /**
         * Match against a specific key if the `matchVariable` is `QueryString`, `PostArgs`, `RequestHeader` or `Cookies`.
         */
        selector?: string;
        /**
         * Up to `5` transforms to apply. Possible values are `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `URLDecode` or`URLEncode`.
         */
        transforms?: string[];
    }

    export interface FirewallPolicyManagedRule {
        /**
         * One or more `exclusion` blocks as defined below.
         */
        exclusions?: outputs.frontdoor.FirewallPolicyManagedRuleExclusion[];
        /**
         * One or more `override` blocks as defined below.
         */
        overrides?: outputs.frontdoor.FirewallPolicyManagedRuleOverride[];
        /**
         * The name of the managed rule to use with this resource.
         */
        type: string;
        /**
         * The version on the managed rule to use with this resource.
         */
        version: string;
    }

    export interface FirewallPolicyManagedRuleExclusion {
        /**
         * The variable type to be excluded. Possible values are `QueryStringArgNames`, `RequestBodyPostArgNames`, `RequestCookieNames`, `RequestHeaderNames`.
         */
        matchVariable: string;
        /**
         * Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to. Possible values are: `Equals`, `Contains`, `StartsWith`, `EndsWith`, `EqualsAny`.
         */
        operator: string;
        /**
         * Selector for the value in the `matchVariable` attribute this exclusion applies to.
         */
        selector: string;
    }

    export interface FirewallPolicyManagedRuleOverride {
        /**
         * One or more `exclusion` blocks as defined below.
         */
        exclusions?: outputs.frontdoor.FirewallPolicyManagedRuleOverrideExclusion[];
        /**
         * The managed rule group to override.
         */
        ruleGroupName: string;
        /**
         * One or more `rule` blocks as defined below. If none are specified, all of the rules in the group will be disabled.
         */
        rules?: outputs.frontdoor.FirewallPolicyManagedRuleOverrideRule[];
    }

    export interface FirewallPolicyManagedRuleOverrideExclusion {
        /**
         * The variable type to be excluded. Possible values are `QueryStringArgNames`, `RequestBodyPostArgNames`, `RequestCookieNames`, `RequestHeaderNames`.
         */
        matchVariable: string;
        /**
         * Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to. Possible values are: `Equals`, `Contains`, `StartsWith`, `EndsWith`, `EqualsAny`.
         */
        operator: string;
        /**
         * Selector for the value in the `matchVariable` attribute this exclusion applies to.
         */
        selector: string;
    }

    export interface FirewallPolicyManagedRuleOverrideRule {
        /**
         * The action to be applied when the rule matches. Possible values are `Allow`, `Block`, `Log`, or `Redirect`.
         */
        action: string;
        /**
         * Is the managed rule override enabled or disabled. Defaults to `false`
         */
        enabled?: boolean;
        /**
         * One or more `exclusion` blocks as defined below.
         */
        exclusions?: outputs.frontdoor.FirewallPolicyManagedRuleOverrideRuleExclusion[];
        /**
         * Identifier for the managed rule.
         */
        ruleId: string;
    }

    export interface FirewallPolicyManagedRuleOverrideRuleExclusion {
        /**
         * The variable type to be excluded. Possible values are `QueryStringArgNames`, `RequestBodyPostArgNames`, `RequestCookieNames`, `RequestHeaderNames`.
         */
        matchVariable: string;
        /**
         * Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to. Possible values are: `Equals`, `Contains`, `StartsWith`, `EndsWith`, `EqualsAny`.
         */
        operator: string;
        /**
         * Selector for the value in the `matchVariable` attribute this exclusion applies to.
         */
        selector: string;
    }

    export interface FrontdoorBackendPool {
        /**
         * A `backend` block as defined below.
         */
        backends: outputs.frontdoor.FrontdoorBackendPoolBackend[];
        /**
         * Specifies the name of the `backendPoolHealthProbe` block within this resource to use for this `Backend Pool`.
         */
        healthProbeName: string;
        /**
         * The ID of the FrontDoor.
         */
        id: string;
        /**
         * Specifies the name of the `backendPoolLoadBalancing` block within this resource to use for this `Backend Pool`.
         */
        loadBalancingName: string;
        /**
         * Specifies the name of the Backend Pool.
         */
        name: string;
    }

    export interface FrontdoorBackendPoolBackend {
        /**
         * Location of the backend (IP address or FQDN)
         */
        address: string;
        /**
         * Specifies if the backend is enabled or not. Valid options are `true` or `false`. Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * The value to use as the host header sent to the backend.
         */
        hostHeader: string;
        /**
         * The HTTP TCP port number. Possible values are between `1` - `65535`.
         */
        httpPort: number;
        /**
         * The HTTPS TCP port number. Possible values are between `1` - `65535`.
         */
        httpsPort: number;
        /**
         * Priority to use for load balancing. Higher priorities will not be used for load balancing if any lower priority backend is healthy. Defaults to `1`.
         */
        priority?: number;
        /**
         * Weight of this endpoint for load balancing purposes. Defaults to `50`.
         */
        weight?: number;
    }

    export interface FrontdoorBackendPoolHealthProbe {
        /**
         * Is this health probe enabled? Dafaults to `true`.
         */
        enabled?: boolean;
        /**
         * The ID of the FrontDoor.
         */
        id: string;
        /**
         * The number of seconds between each Health Probe. Defaults to `120`.
         */
        intervalInSeconds?: number;
        /**
         * Specifies the name of the Health Probe.
         */
        name: string;
        /**
         * The path to use for the Health Probe. Default is `/`.
         */
        path?: string;
        /**
         * Specifies HTTP method the health probe uses when querying the backend pool instances. Possible values include: `Get` and `Head`. Defaults to `Get`.
         */
        probeMethod?: string;
        /**
         * Protocol scheme to use for the Health Probe. Defaults to `Http`.
         */
        protocol?: string;
    }

    export interface FrontdoorBackendPoolLoadBalancing {
        /**
         * The additional latency in milliseconds for probes to fall into the lowest latency bucket. Defaults to `0`.
         */
        additionalLatencyMilliseconds?: number;
        /**
         * The ID of the FrontDoor.
         */
        id: string;
        /**
         * Specifies the name of the Load Balancer.
         */
        name: string;
        /**
         * The number of samples to consider for load balancing decisions. Defaults to `4`.
         */
        sampleSize?: number;
        /**
         * The number of samples within the sample period that must succeed. Defaults to `2`.
         */
        successfulSamplesRequired?: number;
    }

    export interface FrontdoorExplicitResourceOrder {
        backendPoolHealthProbeIds: string[];
        backendPoolIds: string[];
        backendPoolLoadBalancingIds: string[];
        frontendEndpointIds: string[];
        routingRuleIds: string[];
    }

    export interface FrontdoorFrontendEndpoint {
        /**
         * Specifies the host name of the `frontendEndpoint`. Must be a domain name. In order to use a name.azurefd.net domain, the name value must match the Front Door name.
         */
        hostName: string;
        /**
         * The ID of the FrontDoor.
         */
        id: string;
        /**
         * Specifies the name of the `frontendEndpoint`.
         */
        name: string;
        /**
         * Whether to allow session affinity on this host. Valid options are `true` or `false` Defaults to `false`.
         */
        sessionAffinityEnabled?: boolean;
        /**
         * The TTL to use in seconds for session affinity, if applicable. Defaults to `0`.
         */
        sessionAffinityTtlSeconds?: number;
        /**
         * Defines the Web Application Firewall policy `ID` for each host.
         */
        webApplicationFirewallPolicyLinkId?: string;
    }

    export interface FrontdoorRoutingRule {
        /**
         * Protocol schemes to match for the Backend Routing Rule. Defaults to `Http`.
         */
        acceptedProtocols: string[];
        /**
         * `Enable` or `Disable` use of this Backend Routing Rule. Permitted values are `true` or `false`. Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * A `forwardingConfiguration` block as defined below.
         */
        forwardingConfiguration?: outputs.frontdoor.FrontdoorRoutingRuleForwardingConfiguration;
        /**
         * The names of the `frontendEndpoint` blocks within this resource to associate with this `routingRule`.
         */
        frontendEndpoints: string[];
        /**
         * The ID of the FrontDoor.
         */
        id: string;
        /**
         * Specifies the name of the Routing Rule.
         */
        name: string;
        /**
         * The route patterns for the Backend Routing Rule. Defaults to `/*`.
         */
        patternsToMatches: string[];
        /**
         * A `redirectConfiguration` block as defined below.
         */
        redirectConfiguration?: outputs.frontdoor.FrontdoorRoutingRuleRedirectConfiguration;
    }

    export interface FrontdoorRoutingRuleForwardingConfiguration {
        /**
         * Specifies the name of the Backend Pool to forward the incoming traffic to.
         */
        backendPoolName: string;
        /**
         * Specifies whether to Enable caching or not. Valid options are `true` or `false`. Defaults to `false`.
         */
        cacheEnabled?: boolean;
        /**
         * Defines cache behaviour in relation to query string parameters. Valid options are `StripAll` or `StripNone`. Defaults to `StripAll`.
         */
        cacheQueryParameterStripDirective?: string;
        /**
         * Whether to use dynamic compression when caching. Valid options are `true` or `false`. Defaults to `false`.
         */
        cacheUseDynamicCompression?: boolean;
        /**
         * Path to use when constructing the request to forward to the backend. This functions as a URL Rewrite. Default behaviour preserves the URL path.
         */
        customForwardingPath?: string;
        /**
         * Protocol to use when redirecting. Valid options are `HttpOnly`, `HttpsOnly`, or `MatchRequest`. Defaults to `HttpsOnly`.
         */
        forwardingProtocol?: string;
    }

    export interface FrontdoorRoutingRuleRedirectConfiguration {
        /**
         * The destination fragment in the portion of URL after '#'. Set this to add a fragment to the redirect URL.
         */
        customFragment?: string;
        /**
         * Set this to change the URL for the redirection.
         */
        customHost?: string;
        /**
         * The path to retain as per the incoming request, or update in the URL for the redirection.
         */
        customPath?: string;
        /**
         * Replace any existing query string from the incoming request URL.
         */
        customQueryString?: string;
        /**
         * Protocol to use when redirecting. Valid options are `HttpOnly`, `HttpsOnly`, or `MatchRequest`. Defaults to `MatchRequest`
         */
        redirectProtocol: string;
        /**
         * Status code for the redirect. Valida options are `Moved`, `Found`, `TemporaryRedirect`, `PermanentRedirect`.
         */
        redirectType: string;
    }

}

export namespace hdinsight {
    export interface GetClusterGateway {
        /**
         * Is the Ambari Portal enabled?
         */
        enabled: boolean;
        /**
         * The password used for the Ambari Portal.
         */
        password: string;
        /**
         * The username used for the Ambari Portal.
         */
        username: string;
    }

    export interface HBaseClusterComponentVersion {
        /**
         * The version of HBase which should be used for this HDInsight HBase Cluster. Changing this forces a new resource to be created.
         */
        hbase: string;
    }

    export interface HBaseClusterGateway {
        /**
         * Is the Ambari portal enabled? The HDInsight API doesn't support disabling gateway anymore.
         *
         * @deprecated HDInsight doesn't support disabling gateway anymore
         */
        enabled?: boolean;
        /**
         * The password used for the Ambari Portal.
         */
        password: string;
        /**
         * The username used for the Ambari Portal. Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface HBaseClusterMetastores {
        /**
         * An `ambari` block as defined below.
         */
        ambari?: outputs.hdinsight.HBaseClusterMetastoresAmbari;
        /**
         * A `hive` block as defined below.
         */
        hive?: outputs.hdinsight.HBaseClusterMetastoresHive;
        /**
         * An `oozie` block as defined below.
         */
        oozie?: outputs.hdinsight.HBaseClusterMetastoresOozie;
    }

    export interface HBaseClusterMetastoresAmbari {
        /**
         * The external Hive metastore's existing SQL database.  Changing this forces a new resource to be created.
         */
        databaseName: string;
        /**
         * The external Ambari metastore's existing SQL server admin password.  Changing this forces a new resource to be created.
         */
        password: string;
        /**
         * The fully-qualified domain name (FQDN) of the SQL server to use for the external Ambari metastore.  Changing this forces a new resource to be created.
         */
        server: string;
        /**
         * The external Ambari metastore's existing SQL server admin username.  Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface HBaseClusterMetastoresHive {
        /**
         * The external Hive metastore's existing SQL database.  Changing this forces a new resource to be created.
         */
        databaseName: string;
        /**
         * The external Hive metastore's existing SQL server admin password.  Changing this forces a new resource to be created.
         */
        password: string;
        /**
         * The fully-qualified domain name (FQDN) of the SQL server to use for the external Hive metastore.  Changing this forces a new resource to be created.
         */
        server: string;
        /**
         * The external Hive metastore's existing SQL server admin username.  Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface HBaseClusterMetastoresOozie {
        /**
         * The external Oozie metastore's existing SQL database.  Changing this forces a new resource to be created.
         */
        databaseName: string;
        /**
         * The external Oozie metastore's existing SQL server admin password.  Changing this forces a new resource to be created.
         */
        password: string;
        /**
         * The fully-qualified domain name (FQDN) of the SQL server to use for the external Oozie metastore.  Changing this forces a new resource to be created.
         */
        server: string;
        /**
         * The external Oozie metastore's existing SQL server admin username.  Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface HBaseClusterMonitor {
        /**
         * The Operations Management Suite (OMS) workspace ID.
         */
        logAnalyticsWorkspaceId: string;
        /**
         * The Operations Management Suite (OMS) workspace key.
         */
        primaryKey: string;
    }

    export interface HBaseClusterRoles {
        /**
         * A `headNode` block as defined above.
         */
        headNode: outputs.hdinsight.HBaseClusterRolesHeadNode;
        /**
         * A `workerNode` block as defined below.
         */
        workerNode: outputs.hdinsight.HBaseClusterRolesWorkerNode;
        /**
         * A `zookeeperNode` block as defined below.
         */
        zookeeperNode: outputs.hdinsight.HBaseClusterRolesZookeeperNode;
    }

    export interface HBaseClusterRolesHeadNode {
        /**
         * The Password associated with the local administrator for the Head Nodes. Changing this forces a new resource to be created.
         */
        password?: string;
        /**
         * A list of SSH Keys which should be used for the local administrator on the Head Nodes. Changing this forces a new resource to be created.
         */
        sshKeys?: string[];
        /**
         * The ID of the Subnet within the Virtual Network where the Head Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        subnetId?: string;
        /**
         * The Username of the local administrator for the Head Nodes. Changing this forces a new resource to be created.
         */
        username: string;
        /**
         * The ID of the Virtual Network where the Head Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        virtualNetworkId?: string;
        /**
         * The Size of the Virtual Machine which should be used as the Head Nodes. Changing this forces a new resource to be created.
         */
        vmSize: string;
    }

    export interface HBaseClusterRolesWorkerNode {
        /**
         * A `autoscale` block as defined below.
         */
        autoscale?: outputs.hdinsight.HBaseClusterRolesWorkerNodeAutoscale;
        /**
         * The minimum number of instances which should be run for the Worker Nodes. Changing this forces a new resource to be created.
         *
         * @deprecated this has been deprecated from the API and will be removed in version 3.0 of the provider
         */
        minInstanceCount: number;
        /**
         * The Password associated with the local administrator for the Worker Nodes. Changing this forces a new resource to be created.
         */
        password?: string;
        /**
         * A list of SSH Keys which should be used for the local administrator on the Worker Nodes. Changing this forces a new resource to be created.
         */
        sshKeys?: string[];
        /**
         * The ID of the Subnet within the Virtual Network where the Worker Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        subnetId?: string;
        /**
         * The number of instances which should be run for the Worker Nodes.
         */
        targetInstanceCount: number;
        /**
         * The Username of the local administrator for the Worker Nodes. Changing this forces a new resource to be created.
         */
        username: string;
        /**
         * The ID of the Virtual Network where the Worker Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        virtualNetworkId?: string;
        /**
         * The Size of the Virtual Machine which should be used as the Worker Nodes. Changing this forces a new resource to be created.
         */
        vmSize: string;
    }

    export interface HBaseClusterRolesWorkerNodeAutoscale {
        /**
         * A `recurrence` block as defined below.
         */
        recurrence?: outputs.hdinsight.HBaseClusterRolesWorkerNodeAutoscaleRecurrence;
    }

    export interface HBaseClusterRolesWorkerNodeAutoscaleRecurrence {
        /**
         * A list of `schedule` blocks as defined below.
         */
        schedules: outputs.hdinsight.HBaseClusterRolesWorkerNodeAutoscaleRecurrenceSchedule[];
        /**
         * The time zone for the autoscale schedule times.
         */
        timezone: string;
    }

    export interface HBaseClusterRolesWorkerNodeAutoscaleRecurrenceSchedule {
        /**
         * The days of the week to perform autoscale.
         */
        days: string[];
        /**
         * The number of worker nodes to autoscale at the specified time.
         */
        targetInstanceCount: number;
        /**
         * The time of day to perform the autoscale in 24hour format.
         */
        time: string;
    }

    export interface HBaseClusterRolesZookeeperNode {
        /**
         * The Password associated with the local administrator for the Zookeeper Nodes. Changing this forces a new resource to be created.
         */
        password?: string;
        /**
         * A list of SSH Keys which should be used for the local administrator on the Zookeeper Nodes. Changing this forces a new resource to be created.
         */
        sshKeys?: string[];
        /**
         * The ID of the Subnet within the Virtual Network where the Zookeeper Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        subnetId?: string;
        /**
         * The Username of the local administrator for the Zookeeper Nodes. Changing this forces a new resource to be created.
         */
        username: string;
        /**
         * The ID of the Virtual Network where the Zookeeper Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        virtualNetworkId?: string;
        /**
         * The Size of the Virtual Machine which should be used as the Zookeeper Nodes. Changing this forces a new resource to be created.
         */
        vmSize: string;
    }

    export interface HBaseClusterStorageAccount {
        /**
         * Is this the Default Storage Account for the HDInsight Hadoop Cluster? Changing this forces a new resource to be created.
         */
        isDefault: boolean;
        /**
         * The Access Key which should be used to connect to the Storage Account. Changing this forces a new resource to be created.
         */
        storageAccountKey: string;
        /**
         * The ID of the Storage Container. Changing this forces a new resource to be created.
         */
        storageContainerId: string;
    }

    export interface HBaseClusterStorageAccountGen2 {
        /**
         * The ID of the Gen2 Filesystem. Changing this forces a new resource to be created.
         */
        filesystemId: string;
        /**
         * Is this the Default Storage Account for the HDInsight Hadoop Cluster? Changing this forces a new resource to be created.
         */
        isDefault: boolean;
        /**
         * The ID of Managed Identity to use for accessing the Gen2 filesystem. Changing this forces a new resource to be created.
         */
        managedIdentityResourceId: string;
        /**
         * The ID of the Storage Account. Changing this forces a new resource to be created.
         */
        storageResourceId: string;
    }

    export interface HadoopClusterComponentVersion {
        /**
         * The version of Hadoop which should be used for this HDInsight Hadoop Cluster. Changing this forces a new resource to be created.
         */
        hadoop: string;
    }

    export interface HadoopClusterGateway {
        /**
         * Is the Ambari portal enabled? The HDInsight API doesn't support disabling gateway anymore.
         *
         * @deprecated HDInsight doesn't support disabling gateway anymore
         */
        enabled?: boolean;
        /**
         * The password used for the Ambari Portal.
         */
        password: string;
        /**
         * The username used for the Ambari Portal. Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface HadoopClusterMetastores {
        /**
         * An `ambari` block as defined below.
         */
        ambari?: outputs.hdinsight.HadoopClusterMetastoresAmbari;
        /**
         * A `hive` block as defined below.
         */
        hive?: outputs.hdinsight.HadoopClusterMetastoresHive;
        /**
         * An `oozie` block as defined below.
         */
        oozie?: outputs.hdinsight.HadoopClusterMetastoresOozie;
    }

    export interface HadoopClusterMetastoresAmbari {
        /**
         * The external Hive metastore's existing SQL database.  Changing this forces a new resource to be created.
         */
        databaseName: string;
        /**
         * The external Ambari metastore's existing SQL server admin password.  Changing this forces a new resource to be created.
         */
        password: string;
        /**
         * The fully-qualified domain name (FQDN) of the SQL server to use for the external Ambari metastore.  Changing this forces a new resource to be created.
         */
        server: string;
        /**
         * The external Ambari metastore's existing SQL server admin username.  Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface HadoopClusterMetastoresHive {
        /**
         * The external Hive metastore's existing SQL database.  Changing this forces a new resource to be created.
         */
        databaseName: string;
        /**
         * The external Hive metastore's existing SQL server admin password.  Changing this forces a new resource to be created.
         */
        password: string;
        /**
         * The fully-qualified domain name (FQDN) of the SQL server to use for the external Hive metastore.  Changing this forces a new resource to be created.
         */
        server: string;
        /**
         * The external Hive metastore's existing SQL server admin username.  Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface HadoopClusterMetastoresOozie {
        /**
         * The external Oozie metastore's existing SQL database.  Changing this forces a new resource to be created.
         */
        databaseName: string;
        /**
         * The external Oozie metastore's existing SQL server admin password.  Changing this forces a new resource to be created.
         */
        password: string;
        /**
         * The fully-qualified domain name (FQDN) of the SQL server to use for the external Oozie metastore.  Changing this forces a new resource to be created.
         */
        server: string;
        /**
         * The external Oozie metastore's existing SQL server admin username.  Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface HadoopClusterMonitor {
        /**
         * The Operations Management Suite (OMS) workspace ID.
         */
        logAnalyticsWorkspaceId: string;
        /**
         * The Operations Management Suite (OMS) workspace key.
         */
        primaryKey: string;
    }

    export interface HadoopClusterNetwork {
        /**
         * The direction of the resource provider connection. Possible values include `Inbound` or `Outbound`. Defaults to `Inbound`. Changing this forces a new resource to be created.
         */
        connectionDirection?: string;
        /**
         * Is the private link enabled? Possible values include `True` or `False`. Defaults to `False`. Changing this forces a new resource to be created.
         */
        privateLinkEnabled?: boolean;
    }

    export interface HadoopClusterRoles {
        /**
         * A `edgeNode` block as defined below.
         */
        edgeNode?: outputs.hdinsight.HadoopClusterRolesEdgeNode;
        /**
         * A `headNode` block as defined above.
         */
        headNode: outputs.hdinsight.HadoopClusterRolesHeadNode;
        /**
         * A `workerNode` block as defined below.
         */
        workerNode: outputs.hdinsight.HadoopClusterRolesWorkerNode;
        /**
         * A `zookeeperNode` block as defined below.
         */
        zookeeperNode: outputs.hdinsight.HadoopClusterRolesZookeeperNode;
    }

    export interface HadoopClusterRolesEdgeNode {
        /**
         * A `installScriptAction` block as defined below.
         */
        installScriptActions: outputs.hdinsight.HadoopClusterRolesEdgeNodeInstallScriptAction[];
        /**
         * The number of instances which should be run for the Worker Nodes.
         */
        targetInstanceCount: number;
        /**
         * The Size of the Virtual Machine which should be used as the Edge Nodes. Changing this forces a new resource to be created.
         */
        vmSize: string;
    }

    export interface HadoopClusterRolesEdgeNodeInstallScriptAction {
        /**
         * The name of the install script action. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * The URI pointing to the script to run during the installation of the edge node. Changing this forces a new resource to be created.
         */
        uri: string;
    }

    export interface HadoopClusterRolesHeadNode {
        /**
         * The Password associated with the local administrator for the Head Nodes. Changing this forces a new resource to be created.
         */
        password?: string;
        /**
         * A list of SSH Keys which should be used for the local administrator on the Head Nodes. Changing this forces a new resource to be created.
         */
        sshKeys?: string[];
        /**
         * The ID of the Subnet within the Virtual Network where the Head Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        subnetId?: string;
        /**
         * The Username of the local administrator for the Head Nodes. Changing this forces a new resource to be created.
         */
        username: string;
        /**
         * The ID of the Virtual Network where the Head Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        virtualNetworkId?: string;
        /**
         * The Size of the Virtual Machine which should be used as the Head Nodes. Changing this forces a new resource to be created.
         */
        vmSize: string;
    }

    export interface HadoopClusterRolesWorkerNode {
        /**
         * A `autoscale` block as defined below.
         */
        autoscale?: outputs.hdinsight.HadoopClusterRolesWorkerNodeAutoscale;
        /**
         * The minimum number of instances which should be run for the Worker Nodes. Changing this forces a new resource to be created.
         *
         * @deprecated this has been deprecated from the API and will be removed in version 3.0 of the provider
         */
        minInstanceCount: number;
        /**
         * The Password associated with the local administrator for the Worker Nodes. Changing this forces a new resource to be created.
         */
        password?: string;
        /**
         * A list of SSH Keys which should be used for the local administrator on the Worker Nodes. Changing this forces a new resource to be created.
         */
        sshKeys?: string[];
        /**
         * The ID of the Subnet within the Virtual Network where the Worker Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        subnetId?: string;
        /**
         * The number of instances which should be run for the Worker Nodes.
         */
        targetInstanceCount: number;
        /**
         * The Username of the local administrator for the Worker Nodes. Changing this forces a new resource to be created.
         */
        username: string;
        /**
         * The ID of the Virtual Network where the Worker Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        virtualNetworkId?: string;
        /**
         * The Size of the Virtual Machine which should be used as the Worker Nodes. Changing this forces a new resource to be created.
         */
        vmSize: string;
    }

    export interface HadoopClusterRolesWorkerNodeAutoscale {
        /**
         * A `capacity` block as defined below.
         */
        capacity?: outputs.hdinsight.HadoopClusterRolesWorkerNodeAutoscaleCapacity;
        /**
         * A `recurrence` block as defined below.
         */
        recurrence?: outputs.hdinsight.HadoopClusterRolesWorkerNodeAutoscaleRecurrence;
    }

    export interface HadoopClusterRolesWorkerNodeAutoscaleCapacity {
        /**
         * The maximum number of worker nodes to autoscale to based on the cluster's activity.
         */
        maxInstanceCount: number;
        /**
         * The minimum number of worker nodes to autoscale to based on the cluster's activity.
         */
        minInstanceCount: number;
    }

    export interface HadoopClusterRolesWorkerNodeAutoscaleRecurrence {
        /**
         * A list of `schedule` blocks as defined below.
         */
        schedules: outputs.hdinsight.HadoopClusterRolesWorkerNodeAutoscaleRecurrenceSchedule[];
        /**
         * The time zone for the autoscale schedule times.
         */
        timezone: string;
    }

    export interface HadoopClusterRolesWorkerNodeAutoscaleRecurrenceSchedule {
        /**
         * The days of the week to perform autoscale.
         */
        days: string[];
        /**
         * The number of worker nodes to autoscale at the specified time.
         */
        targetInstanceCount: number;
        /**
         * The time of day to perform the autoscale in 24hour format.
         */
        time: string;
    }

    export interface HadoopClusterRolesZookeeperNode {
        /**
         * The Password associated with the local administrator for the Zookeeper Nodes. Changing this forces a new resource to be created.
         */
        password?: string;
        /**
         * A list of SSH Keys which should be used for the local administrator on the Zookeeper Nodes. Changing this forces a new resource to be created.
         */
        sshKeys?: string[];
        /**
         * The ID of the Subnet within the Virtual Network where the Zookeeper Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        subnetId?: string;
        /**
         * The Username of the local administrator for the Zookeeper Nodes. Changing this forces a new resource to be created.
         */
        username: string;
        /**
         * The ID of the Virtual Network where the Zookeeper Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        virtualNetworkId?: string;
        /**
         * The Size of the Virtual Machine which should be used as the Zookeeper Nodes. Changing this forces a new resource to be created.
         */
        vmSize: string;
    }

    export interface HadoopClusterStorageAccount {
        /**
         * Is this the Default Storage Account for the HDInsight Hadoop Cluster? Changing this forces a new resource to be created.
         */
        isDefault: boolean;
        /**
         * The Access Key which should be used to connect to the Storage Account. Changing this forces a new resource to be created.
         */
        storageAccountKey: string;
        /**
         * The ID of the Storage Container. Changing this forces a new resource to be created.
         */
        storageContainerId: string;
    }

    export interface HadoopClusterStorageAccountGen2 {
        /**
         * The ID of the Gen2 Filesystem. Changing this forces a new resource to be created.
         */
        filesystemId: string;
        /**
         * Is this the Default Storage Account for the HDInsight Hadoop Cluster? Changing this forces a new resource to be created.
         */
        isDefault: boolean;
        /**
         * The ID of Managed Identity to use for accessing the Gen2 filesystem. Changing this forces a new resource to be created.
         */
        managedIdentityResourceId: string;
        /**
         * The ID of the Storage Account. Changing this forces a new resource to be created.
         */
        storageResourceId: string;
    }

    export interface InteractiveQueryClusterComponentVersion {
        interactiveHive: string;
    }

    export interface InteractiveQueryClusterGateway {
        /**
         * Is the Ambari portal enabled? The HDInsight API doesn't support disabling gateway anymore.
         *
         * @deprecated HDInsight doesn't support disabling gateway anymore
         */
        enabled?: boolean;
        /**
         * The password used for the Ambari Portal.
         */
        password: string;
        /**
         * The username used for the Ambari Portal. Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface InteractiveQueryClusterMetastores {
        /**
         * An `ambari` block as defined below.
         */
        ambari?: outputs.hdinsight.InteractiveQueryClusterMetastoresAmbari;
        /**
         * A `hive` block as defined below.
         */
        hive?: outputs.hdinsight.InteractiveQueryClusterMetastoresHive;
        /**
         * An `oozie` block as defined below.
         */
        oozie?: outputs.hdinsight.InteractiveQueryClusterMetastoresOozie;
    }

    export interface InteractiveQueryClusterMetastoresAmbari {
        /**
         * The external Hive metastore's existing SQL database.  Changing this forces a new resource to be created.
         */
        databaseName: string;
        /**
         * The external Ambari metastore's existing SQL server admin password.  Changing this forces a new resource to be created.
         */
        password: string;
        /**
         * The fully-qualified domain name (FQDN) of the SQL server to use for the external Ambari metastore.  Changing this forces a new resource to be created.
         */
        server: string;
        /**
         * The external Ambari metastore's existing SQL server admin username.  Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface InteractiveQueryClusterMetastoresHive {
        /**
         * The external Hive metastore's existing SQL database.  Changing this forces a new resource to be created.
         */
        databaseName: string;
        /**
         * The external Hive metastore's existing SQL server admin password.  Changing this forces a new resource to be created.
         */
        password: string;
        /**
         * The fully-qualified domain name (FQDN) of the SQL server to use for the external Hive metastore.  Changing this forces a new resource to be created.
         */
        server: string;
        /**
         * The external Hive metastore's existing SQL server admin username.  Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface InteractiveQueryClusterMetastoresOozie {
        /**
         * The external Oozie metastore's existing SQL database.  Changing this forces a new resource to be created.
         */
        databaseName: string;
        /**
         * The external Oozie metastore's existing SQL server admin password.  Changing this forces a new resource to be created.
         */
        password: string;
        /**
         * The fully-qualified domain name (FQDN) of the SQL server to use for the external Oozie metastore.  Changing this forces a new resource to be created.
         */
        server: string;
        /**
         * The external Oozie metastore's existing SQL server admin username.  Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface InteractiveQueryClusterMonitor {
        /**
         * The Operations Management Suite (OMS) workspace ID.
         */
        logAnalyticsWorkspaceId: string;
        /**
         * The Operations Management Suite (OMS) workspace key.
         */
        primaryKey: string;
    }

    export interface InteractiveQueryClusterNetwork {
        /**
         * The direction of the resource provider connection. Possible values include `Inbound` or `Outbound`. Defaults to `Inbound`. Changing this forces a new resource to be created.
         */
        connectionDirection?: string;
        /**
         * Is the private link enabled? Possible values include `True` or `False`. Defaults to `False`. Changing this forces a new resource to be created.
         */
        privateLinkEnabled?: boolean;
    }

    export interface InteractiveQueryClusterRoles {
        /**
         * A `headNode` block as defined above.
         */
        headNode: outputs.hdinsight.InteractiveQueryClusterRolesHeadNode;
        /**
         * A `workerNode` block as defined below.
         */
        workerNode: outputs.hdinsight.InteractiveQueryClusterRolesWorkerNode;
        /**
         * A `zookeeperNode` block as defined below.
         */
        zookeeperNode: outputs.hdinsight.InteractiveQueryClusterRolesZookeeperNode;
    }

    export interface InteractiveQueryClusterRolesHeadNode {
        /**
         * The Password associated with the local administrator for the Head Nodes. Changing this forces a new resource to be created.
         */
        password?: string;
        /**
         * A list of SSH Keys which should be used for the local administrator on the Head Nodes. Changing this forces a new resource to be created.
         */
        sshKeys?: string[];
        /**
         * The ID of the Subnet within the Virtual Network where the Head Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        subnetId?: string;
        /**
         * The Username of the local administrator for the Head Nodes. Changing this forces a new resource to be created.
         */
        username: string;
        /**
         * The ID of the Virtual Network where the Head Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        virtualNetworkId?: string;
        /**
         * The Size of the Virtual Machine which should be used as the Head Nodes. Changing this forces a new resource to be created.
         */
        vmSize: string;
    }

    export interface InteractiveQueryClusterRolesWorkerNode {
        /**
         * A `autoscale` block as defined below.
         */
        autoscale?: outputs.hdinsight.InteractiveQueryClusterRolesWorkerNodeAutoscale;
        /**
         * The minimum number of instances which should be run for the Worker Nodes. Changing this forces a new resource to be created.
         *
         * @deprecated this has been deprecated from the API and will be removed in version 3.0 of the provider
         */
        minInstanceCount: number;
        /**
         * The Password associated with the local administrator for the Worker Nodes. Changing this forces a new resource to be created.
         */
        password?: string;
        /**
         * A list of SSH Keys which should be used for the local administrator on the Worker Nodes. Changing this forces a new resource to be created.
         */
        sshKeys?: string[];
        /**
         * The ID of the Subnet within the Virtual Network where the Worker Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        subnetId?: string;
        /**
         * The number of instances which should be run for the Worker Nodes.
         */
        targetInstanceCount: number;
        /**
         * The Username of the local administrator for the Worker Nodes. Changing this forces a new resource to be created.
         */
        username: string;
        /**
         * The ID of the Virtual Network where the Worker Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        virtualNetworkId?: string;
        /**
         * The Size of the Virtual Machine which should be used as the Worker Nodes. Changing this forces a new resource to be created.
         */
        vmSize: string;
    }

    export interface InteractiveQueryClusterRolesWorkerNodeAutoscale {
        /**
         * A `capacity` block as defined below.
         */
        capacity?: outputs.hdinsight.InteractiveQueryClusterRolesWorkerNodeAutoscaleCapacity;
        /**
         * A `recurrence` block as defined below.
         */
        recurrence?: outputs.hdinsight.InteractiveQueryClusterRolesWorkerNodeAutoscaleRecurrence;
    }

    export interface InteractiveQueryClusterRolesWorkerNodeAutoscaleCapacity {
        /**
         * The maximum number of worker nodes to autoscale to based on the cluster's activity.
         */
        maxInstanceCount: number;
        /**
         * The minimum number of worker nodes to autoscale to based on the cluster's activity.
         */
        minInstanceCount: number;
    }

    export interface InteractiveQueryClusterRolesWorkerNodeAutoscaleRecurrence {
        /**
         * A list of `schedule` blocks as defined below.
         */
        schedules: outputs.hdinsight.InteractiveQueryClusterRolesWorkerNodeAutoscaleRecurrenceSchedule[];
        /**
         * The time zone for the autoscale schedule times.
         */
        timezone: string;
    }

    export interface InteractiveQueryClusterRolesWorkerNodeAutoscaleRecurrenceSchedule {
        /**
         * The days of the week to perform autoscale.
         */
        days: string[];
        /**
         * The number of worker nodes to autoscale at the specified time.
         */
        targetInstanceCount: number;
        /**
         * The time of day to perform the autoscale in 24hour format.
         */
        time: string;
    }

    export interface InteractiveQueryClusterRolesZookeeperNode {
        /**
         * The Password associated with the local administrator for the Zookeeper Nodes. Changing this forces a new resource to be created.
         */
        password?: string;
        /**
         * A list of SSH Keys which should be used for the local administrator on the Zookeeper Nodes. Changing this forces a new resource to be created.
         */
        sshKeys?: string[];
        /**
         * The ID of the Subnet within the Virtual Network where the Zookeeper Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        subnetId?: string;
        /**
         * The Username of the local administrator for the Zookeeper Nodes. Changing this forces a new resource to be created.
         */
        username: string;
        /**
         * The ID of the Virtual Network where the Zookeeper Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        virtualNetworkId?: string;
        /**
         * The Size of the Virtual Machine which should be used as the Zookeeper Nodes. Changing this forces a new resource to be created.
         */
        vmSize: string;
    }

    export interface InteractiveQueryClusterStorageAccount {
        /**
         * Is this the Default Storage Account for the HDInsight Hadoop Cluster? Changing this forces a new resource to be created.
         */
        isDefault: boolean;
        /**
         * The Access Key which should be used to connect to the Storage Account. Changing this forces a new resource to be created.
         */
        storageAccountKey: string;
        /**
         * The ID of the Storage Container. Changing this forces a new resource to be created.
         */
        storageContainerId: string;
    }

    export interface InteractiveQueryClusterStorageAccountGen2 {
        /**
         * The ID of the Gen2 Filesystem. Changing this forces a new resource to be created.
         */
        filesystemId: string;
        /**
         * Is this the Default Storage Account for the HDInsight Hadoop Cluster? Changing this forces a new resource to be created.
         */
        isDefault: boolean;
        /**
         * The ID of Managed Identity to use for accessing the Gen2 filesystem. Changing this forces a new resource to be created.
         */
        managedIdentityResourceId: string;
        /**
         * The ID of the Storage Account. Changing this forces a new resource to be created.
         */
        storageResourceId: string;
    }

    export interface KafkaClusterComponentVersion {
        /**
         * The version of Kafka which should be used for this HDInsight Kafka Cluster. Changing this forces a new resource to be created.
         */
        kafka: string;
    }

    export interface KafkaClusterGateway {
        /**
         * Is the Ambari portal enabled? The HDInsight API doesn't support disabling gateway anymore.
         *
         * @deprecated HDInsight doesn't support disabling gateway anymore
         */
        enabled?: boolean;
        /**
         * The password used for the Ambari Portal.
         */
        password: string;
        /**
         * The username used for the Ambari Portal. Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface KafkaClusterMetastores {
        /**
         * An `ambari` block as defined below.
         */
        ambari?: outputs.hdinsight.KafkaClusterMetastoresAmbari;
        /**
         * A `hive` block as defined below.
         */
        hive?: outputs.hdinsight.KafkaClusterMetastoresHive;
        /**
         * An `oozie` block as defined below.
         */
        oozie?: outputs.hdinsight.KafkaClusterMetastoresOozie;
    }

    export interface KafkaClusterMetastoresAmbari {
        /**
         * The external Hive metastore's existing SQL database.  Changing this forces a new resource to be created.
         */
        databaseName: string;
        /**
         * The external Ambari metastore's existing SQL server admin password.  Changing this forces a new resource to be created.
         */
        password: string;
        /**
         * The fully-qualified domain name (FQDN) of the SQL server to use for the external Ambari metastore.  Changing this forces a new resource to be created.
         */
        server: string;
        /**
         * The external Ambari metastore's existing SQL server admin username.  Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface KafkaClusterMetastoresHive {
        /**
         * The external Hive metastore's existing SQL database.  Changing this forces a new resource to be created.
         */
        databaseName: string;
        /**
         * The external Hive metastore's existing SQL server admin password.  Changing this forces a new resource to be created.
         */
        password: string;
        /**
         * The fully-qualified domain name (FQDN) of the SQL server to use for the external Hive metastore.  Changing this forces a new resource to be created.
         */
        server: string;
        /**
         * The external Hive metastore's existing SQL server admin username.  Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface KafkaClusterMetastoresOozie {
        /**
         * The external Oozie metastore's existing SQL database.  Changing this forces a new resource to be created.
         */
        databaseName: string;
        /**
         * The external Oozie metastore's existing SQL server admin password.  Changing this forces a new resource to be created.
         */
        password: string;
        /**
         * The fully-qualified domain name (FQDN) of the SQL server to use for the external Oozie metastore.  Changing this forces a new resource to be created.
         */
        server: string;
        /**
         * The external Oozie metastore's existing SQL server admin username.  Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface KafkaClusterMonitor {
        /**
         * The Operations Management Suite (OMS) workspace ID.
         */
        logAnalyticsWorkspaceId: string;
        /**
         * The Operations Management Suite (OMS) workspace key.
         */
        primaryKey: string;
    }

    export interface KafkaClusterRestProxy {
        /**
         * The Azure Active Directory Security Group ID.
         */
        securityGroupId: string;
    }

    export interface KafkaClusterRoles {
        /**
         * A `headNode` block as defined above.
         */
        headNode: outputs.hdinsight.KafkaClusterRolesHeadNode;
        /**
         * A `kafkaManagementNode` block as defined below.
         */
        kafkaManagementNode?: outputs.hdinsight.KafkaClusterRolesKafkaManagementNode;
        /**
         * A `workerNode` block as defined below.
         */
        workerNode: outputs.hdinsight.KafkaClusterRolesWorkerNode;
        /**
         * A `zookeeperNode` block as defined below.
         */
        zookeeperNode: outputs.hdinsight.KafkaClusterRolesZookeeperNode;
    }

    export interface KafkaClusterRolesHeadNode {
        /**
         * The Password associated with the local administrator for the Head Nodes. Changing this forces a new resource to be created.
         */
        password?: string;
        /**
         * A list of SSH Keys which should be used for the local administrator on the Head Nodes. Changing this forces a new resource to be created.
         */
        sshKeys?: string[];
        /**
         * The ID of the Subnet within the Virtual Network where the Head Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        subnetId?: string;
        /**
         * The Username of the local administrator for the Head Nodes. Changing this forces a new resource to be created.
         */
        username: string;
        /**
         * The ID of the Virtual Network where the Head Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        virtualNetworkId?: string;
        /**
         * The Size of the Virtual Machine which should be used as the Head Nodes. Changing this forces a new resource to be created.
         */
        vmSize: string;
    }

    export interface KafkaClusterRolesKafkaManagementNode {
        /**
         * The Password associated with the local administrator for the Kafka Management Nodes. Changing this forces a new resource to be created.
         */
        password?: string;
        /**
         * A list of SSH Keys which should be used for the local administrator on the Kafka Management Nodes. Changing this forces a new resource to be created.
         */
        sshKeys?: string[];
        /**
         * The ID of the Subnet within the Virtual Network where the Kafka Management Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        subnetId?: string;
        /**
         * The Username of the local administrator for the Kafka Management Nodes. Changing this forces a new resource to be created.
         */
        username: string;
        /**
         * The ID of the Virtual Network where the Kafka Management Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        virtualNetworkId?: string;
        /**
         * The Size of the Virtual Machine which should be used as the Kafka Management Nodes. Changing this forces a new resource to be created.
         */
        vmSize: string;
    }

    export interface KafkaClusterRolesWorkerNode {
        /**
         * The minimum number of instances which should be run for the Worker Nodes. Changing this forces a new resource to be created.
         *
         * @deprecated this has been deprecated from the API and will be removed in version 3.0 of the provider
         */
        minInstanceCount: number;
        /**
         * The number of Data Disks which should be assigned to each Worker Node, which can be between 1 and 8. Changing this forces a new resource to be created.
         */
        numberOfDisksPerNode: number;
        /**
         * The Password associated with the local administrator for the Worker Nodes. Changing this forces a new resource to be created.
         */
        password?: string;
        /**
         * A list of SSH Keys which should be used for the local administrator on the Worker Nodes. Changing this forces a new resource to be created.
         */
        sshKeys?: string[];
        /**
         * The ID of the Subnet within the Virtual Network where the Worker Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        subnetId?: string;
        /**
         * The number of instances which should be run for the Worker Nodes.
         */
        targetInstanceCount: number;
        /**
         * The Username of the local administrator for the Worker Nodes. Changing this forces a new resource to be created.
         */
        username: string;
        /**
         * The ID of the Virtual Network where the Worker Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        virtualNetworkId?: string;
        /**
         * The Size of the Virtual Machine which should be used as the Worker Nodes. Changing this forces a new resource to be created.
         */
        vmSize: string;
    }

    export interface KafkaClusterRolesZookeeperNode {
        /**
         * The Password associated with the local administrator for the Zookeeper Nodes. Changing this forces a new resource to be created.
         */
        password?: string;
        /**
         * A list of SSH Keys which should be used for the local administrator on the Zookeeper Nodes. Changing this forces a new resource to be created.
         */
        sshKeys?: string[];
        /**
         * The ID of the Subnet within the Virtual Network where the Zookeeper Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        subnetId?: string;
        /**
         * The Username of the local administrator for the Zookeeper Nodes. Changing this forces a new resource to be created.
         */
        username: string;
        /**
         * The ID of the Virtual Network where the Zookeeper Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        virtualNetworkId?: string;
        /**
         * The Size of the Virtual Machine which should be used as the Zookeeper Nodes. Changing this forces a new resource to be created.
         */
        vmSize: string;
    }

    export interface KafkaClusterStorageAccount {
        /**
         * Is this the Default Storage Account for the HDInsight Hadoop Cluster? Changing this forces a new resource to be created.
         */
        isDefault: boolean;
        /**
         * The Access Key which should be used to connect to the Storage Account. Changing this forces a new resource to be created.
         */
        storageAccountKey: string;
        /**
         * The ID of the Storage Container. Changing this forces a new resource to be created.
         */
        storageContainerId: string;
    }

    export interface KafkaClusterStorageAccountGen2 {
        /**
         * The ID of the Gen2 Filesystem. Changing this forces a new resource to be created.
         */
        filesystemId: string;
        /**
         * Is this the Default Storage Account for the HDInsight Hadoop Cluster? Changing this forces a new resource to be created.
         */
        isDefault: boolean;
        /**
         * The ID of Managed Identity to use for accessing the Gen2 filesystem. Changing this forces a new resource to be created.
         */
        managedIdentityResourceId: string;
        /**
         * The ID of the Storage Account. Changing this forces a new resource to be created.
         */
        storageResourceId: string;
    }

    export interface MLServicesClusterGateway {
        /**
         * Is the Ambari portal enabled? The HDInsight API doesn't support disabling gateway anymore.
         *
         * @deprecated HDInsight doesn't support disabling gateway anymore
         */
        enabled?: boolean;
        /**
         * The password used for the Ambari Portal.
         */
        password: string;
        /**
         * The username used for the Ambari Portal. Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface MLServicesClusterRoles {
        /**
         * A `edgeNode` block as defined above.
         */
        edgeNode: outputs.hdinsight.MLServicesClusterRolesEdgeNode;
        /**
         * A `headNode` block as defined above.
         */
        headNode: outputs.hdinsight.MLServicesClusterRolesHeadNode;
        /**
         * A `workerNode` block as defined below.
         */
        workerNode: outputs.hdinsight.MLServicesClusterRolesWorkerNode;
        /**
         * A `zookeeperNode` block as defined below.
         */
        zookeeperNode: outputs.hdinsight.MLServicesClusterRolesZookeeperNode;
    }

    export interface MLServicesClusterRolesEdgeNode {
        /**
         * The Password associated with the local administrator for the Edge Node. Changing this forces a new resource to be created.
         */
        password?: string;
        /**
         * A list of SSH Keys which should be used for the local administrator on the Edge Node. Changing this forces a new resource to be created.
         */
        sshKeys?: string[];
        /**
         * The ID of the Subnet within the Virtual Network where the Edge Node should be provisioned within. Changing this forces a new resource to be created.
         */
        subnetId?: string;
        /**
         * The Username of the local administrator for the Edge Node. Changing this forces a new resource to be created.
         */
        username: string;
        /**
         * The ID of the Virtual Network where the Edge Node should be provisioned within. Changing this forces a new resource to be created.
         */
        virtualNetworkId?: string;
        /**
         * The Size of the Virtual Machine which should be used as the Edge Node. Changing this forces a new resource to be created.
         */
        vmSize: string;
    }

    export interface MLServicesClusterRolesHeadNode {
        /**
         * The Password associated with the local administrator for the Head Nodes. Changing this forces a new resource to be created.
         */
        password?: string;
        /**
         * A list of SSH Keys which should be used for the local administrator on the Head Nodes. Changing this forces a new resource to be created.
         */
        sshKeys?: string[];
        /**
         * The ID of the Subnet within the Virtual Network where the Head Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        subnetId?: string;
        /**
         * The Username of the local administrator for the Head Nodes. Changing this forces a new resource to be created.
         */
        username: string;
        /**
         * The ID of the Virtual Network where the Head Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        virtualNetworkId?: string;
        /**
         * The Size of the Virtual Machine which should be used as the Head Nodes. Changing this forces a new resource to be created.
         */
        vmSize: string;
    }

    export interface MLServicesClusterRolesWorkerNode {
        /**
         * The minimum number of instances which should be run for the Worker Nodes. Changing this forces a new resource to be created.
         *
         * @deprecated this has been deprecated from the API and will be removed in version 3.0 of the provider
         */
        minInstanceCount: number;
        /**
         * The Password associated with the local administrator for the Worker Nodes. Changing this forces a new resource to be created.
         */
        password?: string;
        /**
         * A list of SSH Keys which should be used for the local administrator on the Worker Nodes. Changing this forces a new resource to be created.
         */
        sshKeys?: string[];
        /**
         * The ID of the Subnet within the Virtual Network where the Worker Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        subnetId?: string;
        /**
         * The number of instances which should be run for the Worker Nodes.
         */
        targetInstanceCount: number;
        /**
         * The Username of the local administrator for the Worker Nodes. Changing this forces a new resource to be created.
         */
        username: string;
        /**
         * The ID of the Virtual Network where the Worker Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        virtualNetworkId?: string;
        /**
         * The Size of the Virtual Machine which should be used as the Worker Nodes. Changing this forces a new resource to be created.
         */
        vmSize: string;
    }

    export interface MLServicesClusterRolesZookeeperNode {
        /**
         * The Password associated with the local administrator for the Zookeeper Nodes. Changing this forces a new resource to be created.
         */
        password?: string;
        /**
         * A list of SSH Keys which should be used for the local administrator on the Zookeeper Nodes. Changing this forces a new resource to be created.
         */
        sshKeys?: string[];
        /**
         * The ID of the Subnet within the Virtual Network where the Zookeeper Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        subnetId?: string;
        /**
         * The Username of the local administrator for the Zookeeper Nodes. Changing this forces a new resource to be created.
         */
        username: string;
        /**
         * The ID of the Virtual Network where the Zookeeper Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        virtualNetworkId?: string;
        /**
         * The Size of the Virtual Machine which should be used as the Zookeeper Nodes. Changing this forces a new resource to be created.
         */
        vmSize: string;
    }

    export interface MLServicesClusterStorageAccount {
        /**
         * Is this the Default Storage Account for the HDInsight ML Services Cluster? Changing this forces a new resource to be created.
         */
        isDefault: boolean;
        /**
         * The Access Key which should be used to connect to the Storage Account. Changing this forces a new resource to be created.
         */
        storageAccountKey: string;
        /**
         * The ID of the Storage Container. Changing this forces a new resource to be created.
         */
        storageContainerId: string;
    }

    export interface RServerClusterGateway {
        /**
         * Is the Ambari portal enabled? The HDInsight API doesn't support disabling gateway anymore.
         *
         * @deprecated HDInsight doesn't support disabling gateway anymore
         */
        enabled?: boolean;
        /**
         * The password used for the Ambari Portal.
         */
        password: string;
        /**
         * The username used for the Ambari Portal. Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface RServerClusterRoles {
        /**
         * A `edgeNode` block as defined above.
         */
        edgeNode: outputs.hdinsight.RServerClusterRolesEdgeNode;
        /**
         * A `headNode` block as defined above.
         */
        headNode: outputs.hdinsight.RServerClusterRolesHeadNode;
        /**
         * A `workerNode` block as defined below.
         */
        workerNode: outputs.hdinsight.RServerClusterRolesWorkerNode;
        /**
         * A `zookeeperNode` block as defined below.
         */
        zookeeperNode: outputs.hdinsight.RServerClusterRolesZookeeperNode;
    }

    export interface RServerClusterRolesEdgeNode {
        /**
         * The Password associated with the local administrator for the Edge Node. Changing this forces a new resource to be created.
         */
        password?: string;
        /**
         * A list of SSH Keys which should be used for the local administrator on the Edge Node. Changing this forces a new resource to be created.
         */
        sshKeys?: string[];
        /**
         * The ID of the Subnet within the Virtual Network where the Edge Node should be provisioned within. Changing this forces a new resource to be created.
         */
        subnetId?: string;
        /**
         * The Username of the local administrator for the Edge Node. Changing this forces a new resource to be created.
         */
        username: string;
        /**
         * The ID of the Virtual Network where the Edge Node should be provisioned within. Changing this forces a new resource to be created.
         */
        virtualNetworkId?: string;
        /**
         * The Size of the Virtual Machine which should be used as the Edge Node. Changing this forces a new resource to be created.
         */
        vmSize: string;
    }

    export interface RServerClusterRolesHeadNode {
        /**
         * The Password associated with the local administrator for the Head Nodes. Changing this forces a new resource to be created.
         */
        password?: string;
        /**
         * A list of SSH Keys which should be used for the local administrator on the Head Nodes. Changing this forces a new resource to be created.
         */
        sshKeys?: string[];
        /**
         * The ID of the Subnet within the Virtual Network where the Head Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        subnetId?: string;
        /**
         * The Username of the local administrator for the Head Nodes. Changing this forces a new resource to be created.
         */
        username: string;
        /**
         * The ID of the Virtual Network where the Head Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        virtualNetworkId?: string;
        /**
         * The Size of the Virtual Machine which should be used as the Head Nodes. Changing this forces a new resource to be created.
         */
        vmSize: string;
    }

    export interface RServerClusterRolesWorkerNode {
        /**
         * The minimum number of instances which should be run for the Worker Nodes. Changing this forces a new resource to be created.
         *
         * @deprecated this has been deprecated from the API and will be removed in version 3.0 of the provider
         */
        minInstanceCount: number;
        /**
         * The Password associated with the local administrator for the Worker Nodes. Changing this forces a new resource to be created.
         */
        password?: string;
        /**
         * A list of SSH Keys which should be used for the local administrator on the Worker Nodes. Changing this forces a new resource to be created.
         */
        sshKeys?: string[];
        /**
         * The ID of the Subnet within the Virtual Network where the Worker Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        subnetId?: string;
        /**
         * The number of instances which should be run for the Worker Nodes.
         */
        targetInstanceCount: number;
        /**
         * The Username of the local administrator for the Worker Nodes. Changing this forces a new resource to be created.
         */
        username: string;
        /**
         * The ID of the Virtual Network where the Worker Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        virtualNetworkId?: string;
        /**
         * The Size of the Virtual Machine which should be used as the Worker Nodes. Changing this forces a new resource to be created.
         */
        vmSize: string;
    }

    export interface RServerClusterRolesZookeeperNode {
        /**
         * The Password associated with the local administrator for the Zookeeper Nodes. Changing this forces a new resource to be created.
         */
        password?: string;
        /**
         * A list of SSH Keys which should be used for the local administrator on the Zookeeper Nodes. Changing this forces a new resource to be created.
         */
        sshKeys?: string[];
        /**
         * The ID of the Subnet within the Virtual Network where the Zookeeper Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        subnetId?: string;
        /**
         * The Username of the local administrator for the Zookeeper Nodes. Changing this forces a new resource to be created.
         */
        username: string;
        /**
         * The ID of the Virtual Network where the Zookeeper Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        virtualNetworkId?: string;
        /**
         * The Size of the Virtual Machine which should be used as the Zookeeper Nodes. Changing this forces a new resource to be created.
         */
        vmSize: string;
    }

    export interface RServerClusterStorageAccount {
        /**
         * Is this the Default Storage Account for the HDInsight RServer Cluster? Changing this forces a new resource to be created.
         */
        isDefault: boolean;
        /**
         * The Access Key which should be used to connect to the Storage Account. Changing this forces a new resource to be created.
         */
        storageAccountKey: string;
        /**
         * The ID of the Storage Container. Changing this forces a new resource to be created.
         */
        storageContainerId: string;
    }

    export interface SparkClusterComponentVersion {
        /**
         * The version of Spark which should be used for this HDInsight Spark Cluster. Changing this forces a new resource to be created.
         */
        spark: string;
    }

    export interface SparkClusterGateway {
        /**
         * Is the Ambari portal enabled? The HDInsight API doesn't support disabling gateway anymore.
         *
         * @deprecated HDInsight doesn't support disabling gateway anymore
         */
        enabled?: boolean;
        /**
         * The password used for the Ambari Portal.
         */
        password: string;
        /**
         * The username used for the Ambari Portal. Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface SparkClusterMetastores {
        /**
         * An `ambari` block as defined below.
         */
        ambari?: outputs.hdinsight.SparkClusterMetastoresAmbari;
        /**
         * A `hive` block as defined below.
         */
        hive?: outputs.hdinsight.SparkClusterMetastoresHive;
        /**
         * An `oozie` block as defined below.
         */
        oozie?: outputs.hdinsight.SparkClusterMetastoresOozie;
    }

    export interface SparkClusterMetastoresAmbari {
        /**
         * The external Hive metastore's existing SQL database.  Changing this forces a new resource to be created.
         */
        databaseName: string;
        /**
         * The external Ambari metastore's existing SQL server admin password.  Changing this forces a new resource to be created.
         */
        password: string;
        /**
         * The fully-qualified domain name (FQDN) of the SQL server to use for the external Ambari metastore.  Changing this forces a new resource to be created.
         */
        server: string;
        /**
         * The external Ambari metastore's existing SQL server admin username.  Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface SparkClusterMetastoresHive {
        /**
         * The external Hive metastore's existing SQL database.  Changing this forces a new resource to be created.
         */
        databaseName: string;
        /**
         * The external Hive metastore's existing SQL server admin password.  Changing this forces a new resource to be created.
         */
        password: string;
        /**
         * The fully-qualified domain name (FQDN) of the SQL server to use for the external Hive metastore.  Changing this forces a new resource to be created.
         */
        server: string;
        /**
         * The external Hive metastore's existing SQL server admin username.  Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface SparkClusterMetastoresOozie {
        /**
         * The external Oozie metastore's existing SQL database.  Changing this forces a new resource to be created.
         */
        databaseName: string;
        /**
         * The external Oozie metastore's existing SQL server admin password.  Changing this forces a new resource to be created.
         */
        password: string;
        /**
         * The fully-qualified domain name (FQDN) of the SQL server to use for the external Oozie metastore.  Changing this forces a new resource to be created.
         */
        server: string;
        /**
         * The external Oozie metastore's existing SQL server admin username.  Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface SparkClusterMonitor {
        /**
         * The Operations Management Suite (OMS) workspace ID.
         */
        logAnalyticsWorkspaceId: string;
        /**
         * The Operations Management Suite (OMS) workspace key.
         */
        primaryKey: string;
    }

    export interface SparkClusterNetwork {
        /**
         * The direction of the resource provider connection. Possible values include `Inbound` or `Outbound`. Defaults to `Inbound`. Changing this forces a new resource to be created.
         */
        connectionDirection?: string;
        /**
         * Is the private link enabled? Possible values include `True` or `False`. Defaults to `False`. Changing this forces a new resource to be created.
         */
        privateLinkEnabled?: boolean;
    }

    export interface SparkClusterRoles {
        /**
         * A `headNode` block as defined above.
         */
        headNode: outputs.hdinsight.SparkClusterRolesHeadNode;
        /**
         * A `workerNode` block as defined below.
         */
        workerNode: outputs.hdinsight.SparkClusterRolesWorkerNode;
        /**
         * A `zookeeperNode` block as defined below.
         */
        zookeeperNode: outputs.hdinsight.SparkClusterRolesZookeeperNode;
    }

    export interface SparkClusterRolesHeadNode {
        /**
         * The Password associated with the local administrator for the Head Nodes. Changing this forces a new resource to be created.
         */
        password?: string;
        /**
         * A list of SSH Keys which should be used for the local administrator on the Head Nodes. Changing this forces a new resource to be created.
         */
        sshKeys?: string[];
        /**
         * The ID of the Subnet within the Virtual Network where the Head Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        subnetId?: string;
        /**
         * The Username of the local administrator for the Head Nodes. Changing this forces a new resource to be created.
         */
        username: string;
        /**
         * The ID of the Virtual Network where the Head Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        virtualNetworkId?: string;
        /**
         * The Size of the Virtual Machine which should be used as the Head Nodes. Changing this forces a new resource to be created.
         */
        vmSize: string;
    }

    export interface SparkClusterRolesWorkerNode {
        /**
         * A `autoscale` block as defined below.
         */
        autoscale?: outputs.hdinsight.SparkClusterRolesWorkerNodeAutoscale;
        /**
         * The minimum number of instances which should be run for the Worker Nodes. Changing this forces a new resource to be created.
         *
         * @deprecated this has been deprecated from the API and will be removed in version 3.0 of the provider
         */
        minInstanceCount: number;
        /**
         * The Password associated with the local administrator for the Worker Nodes. Changing this forces a new resource to be created.
         */
        password?: string;
        /**
         * A list of SSH Keys which should be used for the local administrator on the Worker Nodes. Changing this forces a new resource to be created.
         */
        sshKeys?: string[];
        /**
         * The ID of the Subnet within the Virtual Network where the Worker Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        subnetId?: string;
        /**
         * The number of instances which should be run for the Worker Nodes.
         */
        targetInstanceCount: number;
        /**
         * The Username of the local administrator for the Worker Nodes. Changing this forces a new resource to be created.
         */
        username: string;
        /**
         * The ID of the Virtual Network where the Worker Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        virtualNetworkId?: string;
        /**
         * The Size of the Virtual Machine which should be used as the Worker Nodes. Changing this forces a new resource to be created.
         */
        vmSize: string;
    }

    export interface SparkClusterRolesWorkerNodeAutoscale {
        /**
         * A `capacity` block as defined below.
         */
        capacity?: outputs.hdinsight.SparkClusterRolesWorkerNodeAutoscaleCapacity;
        /**
         * A `recurrence` block as defined below.
         */
        recurrence?: outputs.hdinsight.SparkClusterRolesWorkerNodeAutoscaleRecurrence;
    }

    export interface SparkClusterRolesWorkerNodeAutoscaleCapacity {
        /**
         * The maximum number of worker nodes to autoscale to based on the cluster's activity.
         */
        maxInstanceCount: number;
        /**
         * The minimum number of worker nodes to autoscale to based on the cluster's activity.
         */
        minInstanceCount: number;
    }

    export interface SparkClusterRolesWorkerNodeAutoscaleRecurrence {
        /**
         * A list of `schedule` blocks as defined below.
         */
        schedules: outputs.hdinsight.SparkClusterRolesWorkerNodeAutoscaleRecurrenceSchedule[];
        /**
         * The time zone for the autoscale schedule times.
         */
        timezone: string;
    }

    export interface SparkClusterRolesWorkerNodeAutoscaleRecurrenceSchedule {
        /**
         * The days of the week to perform autoscale.
         */
        days: string[];
        /**
         * The number of worker nodes to autoscale at the specified time.
         */
        targetInstanceCount: number;
        /**
         * The time of day to perform the autoscale in 24hour format.
         */
        time: string;
    }

    export interface SparkClusterRolesZookeeperNode {
        /**
         * The Password associated with the local administrator for the Zookeeper Nodes. Changing this forces a new resource to be created.
         */
        password?: string;
        /**
         * A list of SSH Keys which should be used for the local administrator on the Zookeeper Nodes. Changing this forces a new resource to be created.
         */
        sshKeys?: string[];
        /**
         * The ID of the Subnet within the Virtual Network where the Zookeeper Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        subnetId?: string;
        /**
         * The Username of the local administrator for the Zookeeper Nodes. Changing this forces a new resource to be created.
         */
        username: string;
        /**
         * The ID of the Virtual Network where the Zookeeper Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        virtualNetworkId?: string;
        /**
         * The Size of the Virtual Machine which should be used as the Zookeeper Nodes. Changing this forces a new resource to be created.
         */
        vmSize: string;
    }

    export interface SparkClusterStorageAccount {
        /**
         * Is this the Default Storage Account for the HDInsight Hadoop Cluster? Changing this forces a new resource to be created.
         */
        isDefault: boolean;
        /**
         * The Access Key which should be used to connect to the Storage Account. Changing this forces a new resource to be created.
         */
        storageAccountKey: string;
        /**
         * The ID of the Storage Container. Changing this forces a new resource to be created.
         */
        storageContainerId: string;
    }

    export interface SparkClusterStorageAccountGen2 {
        /**
         * The ID of the Gen2 Filesystem. Changing this forces a new resource to be created.
         */
        filesystemId: string;
        /**
         * Is this the Default Storage Account for the HDInsight Hadoop Cluster? Changing this forces a new resource to be created.
         */
        isDefault: boolean;
        /**
         * The ID of Managed Identity to use for accessing the Gen2 filesystem. Changing this forces a new resource to be created.
         */
        managedIdentityResourceId: string;
        /**
         * The ID of the Storage Account. Changing this forces a new resource to be created.
         */
        storageResourceId: string;
    }

    export interface StormClusterComponentVersion {
        /**
         * The version of Storm which should be used for this HDInsight Storm Cluster. Changing this forces a new resource to be created.
         */
        storm: string;
    }

    export interface StormClusterGateway {
        /**
         * Is the Ambari portal enabled? The HDInsight API doesn't support disabling gateway anymore.
         *
         * @deprecated HDInsight doesn't support disabling gateway anymore
         */
        enabled?: boolean;
        /**
         * The password used for the Ambari Portal.
         */
        password: string;
        /**
         * The username used for the Ambari Portal. Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface StormClusterMetastores {
        /**
         * An `ambari` block as defined below.
         */
        ambari?: outputs.hdinsight.StormClusterMetastoresAmbari;
        /**
         * A `hive` block as defined below.
         */
        hive?: outputs.hdinsight.StormClusterMetastoresHive;
        /**
         * An `oozie` block as defined below.
         */
        oozie?: outputs.hdinsight.StormClusterMetastoresOozie;
    }

    export interface StormClusterMetastoresAmbari {
        /**
         * The external Hive metastore's existing SQL database.  Changing this forces a new resource to be created.
         */
        databaseName: string;
        /**
         * The external Ambari metastore's existing SQL server admin password.  Changing this forces a new resource to be created.
         */
        password: string;
        /**
         * The fully-qualified domain name (FQDN) of the SQL server to use for the external Ambari metastore.  Changing this forces a new resource to be created.
         */
        server: string;
        /**
         * The external Ambari metastore's existing SQL server admin username.  Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface StormClusterMetastoresHive {
        /**
         * The external Hive metastore's existing SQL database.  Changing this forces a new resource to be created.
         */
        databaseName: string;
        /**
         * The external Hive metastore's existing SQL server admin password.  Changing this forces a new resource to be created.
         */
        password: string;
        /**
         * The fully-qualified domain name (FQDN) of the SQL server to use for the external Hive metastore.  Changing this forces a new resource to be created.
         */
        server: string;
        /**
         * The external Hive metastore's existing SQL server admin username.  Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface StormClusterMetastoresOozie {
        /**
         * The external Oozie metastore's existing SQL database.  Changing this forces a new resource to be created.
         */
        databaseName: string;
        /**
         * The external Oozie metastore's existing SQL server admin password.  Changing this forces a new resource to be created.
         */
        password: string;
        /**
         * The fully-qualified domain name (FQDN) of the SQL server to use for the external Oozie metastore.  Changing this forces a new resource to be created.
         */
        server: string;
        /**
         * The external Oozie metastore's existing SQL server admin username.  Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface StormClusterMonitor {
        /**
         * The Operations Management Suite (OMS) workspace ID.
         */
        logAnalyticsWorkspaceId: string;
        /**
         * The Operations Management Suite (OMS) workspace key.
         */
        primaryKey: string;
    }

    export interface StormClusterRoles {
        /**
         * A `headNode` block as defined above.
         */
        headNode: outputs.hdinsight.StormClusterRolesHeadNode;
        /**
         * A `workerNode` block as defined below.
         */
        workerNode: outputs.hdinsight.StormClusterRolesWorkerNode;
        /**
         * A `zookeeperNode` block as defined below.
         */
        zookeeperNode: outputs.hdinsight.StormClusterRolesZookeeperNode;
    }

    export interface StormClusterRolesHeadNode {
        /**
         * The Password associated with the local administrator for the Head Nodes. Changing this forces a new resource to be created.
         */
        password?: string;
        /**
         * A list of SSH Keys which should be used for the local administrator on the Head Nodes. Changing this forces a new resource to be created.
         */
        sshKeys?: string[];
        /**
         * The ID of the Subnet within the Virtual Network where the Head Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        subnetId?: string;
        /**
         * The Username of the local administrator for the Head Nodes. Changing this forces a new resource to be created.
         */
        username: string;
        /**
         * The ID of the Virtual Network where the Head Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        virtualNetworkId?: string;
        /**
         * The Size of the Virtual Machine which should be used as the Head Nodes. Changing this forces a new resource to be created.
         */
        vmSize: string;
    }

    export interface StormClusterRolesWorkerNode {
        /**
         * The minimum number of instances which should be run for the Worker Nodes. Changing this forces a new resource to be created.
         *
         * @deprecated this has been deprecated from the API and will be removed in version 3.0 of the provider
         */
        minInstanceCount: number;
        /**
         * The Password associated with the local administrator for the Worker Nodes. Changing this forces a new resource to be created.
         */
        password?: string;
        /**
         * A list of SSH Keys which should be used for the local administrator on the Worker Nodes. Changing this forces a new resource to be created.
         */
        sshKeys?: string[];
        /**
         * The ID of the Subnet within the Virtual Network where the Worker Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        subnetId?: string;
        /**
         * The number of instances which should be run for the Worker Nodes.
         */
        targetInstanceCount: number;
        /**
         * The Username of the local administrator for the Worker Nodes. Changing this forces a new resource to be created.
         */
        username: string;
        /**
         * The ID of the Virtual Network where the Worker Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        virtualNetworkId?: string;
        /**
         * The Size of the Virtual Machine which should be used as the Worker Nodes. Changing this forces a new resource to be created.
         */
        vmSize: string;
    }

    export interface StormClusterRolesZookeeperNode {
        /**
         * The Password associated with the local administrator for the Zookeeper Nodes. Changing this forces a new resource to be created.
         */
        password?: string;
        /**
         * A list of SSH Keys which should be used for the local administrator on the Zookeeper Nodes. Changing this forces a new resource to be created.
         */
        sshKeys?: string[];
        /**
         * The ID of the Subnet within the Virtual Network where the Zookeeper Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        subnetId?: string;
        /**
         * The Username of the local administrator for the Zookeeper Nodes. Changing this forces a new resource to be created.
         */
        username: string;
        /**
         * The ID of the Virtual Network where the Zookeeper Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        virtualNetworkId?: string;
        /**
         * The Size of the Virtual Machine which should be used as the Zookeeper Nodes. Changing this forces a new resource to be created.
         */
        vmSize: string;
    }

    export interface StormClusterStorageAccount {
        /**
         * Is this the Default Storage Account for the HDInsight Storm Cluster? Changing this forces a new resource to be created.
         */
        isDefault: boolean;
        /**
         * The Access Key which should be used to connect to the Storage Account. Changing this forces a new resource to be created.
         */
        storageAccountKey: string;
        /**
         * The ID of the Storage Container. Changing this forces a new resource to be created.
         */
        storageContainerId: string;
    }

}

export namespace healthcare {
    export interface GetServiceAuthenticationConfiguration {
        /**
         * The intended audience to receive authentication tokens for the service.
         */
        audience: string;
        /**
         * The Azure Active Directory (tenant) that serves as the authentication authority to access the service.
         */
        authority: string;
        /**
         * Is the 'SMART on FHIR' option for mobile and web implementations enabled?
         */
        smartProxyEnabled: boolean;
    }

    export interface GetServiceCorsConfiguration {
        /**
         * Are credentials are allowed via CORS?
         */
        allowCredentials: boolean;
        /**
         * The set of headers to be allowed via CORS.
         */
        allowedHeaders: string[];
        /**
         * The methods to be allowed via CORS.
         */
        allowedMethods: string[];
        /**
         * The set of origins to be allowed via CORS.
         */
        allowedOrigins: string[];
        /**
         * The max age to be allowed via CORS.
         */
        maxAgeInSeconds: number;
    }

    export interface ServiceAuthenticationConfiguration {
        /**
         * The intended audience to receive authentication tokens for the service. The default value is https://azurehealthcareapis.com
         */
        audience?: string;
        /**
         * The Azure Active Directory (tenant) that serves as the authentication authority to access the service. The default authority is the Directory defined in the authentication scheme in use when running this provider.
         * Authority must be registered to Azure AD and in the following format: https://{Azure-AD-endpoint}/{tenant-id}.
         */
        authority?: string;
        /**
         * Enables the 'SMART on FHIR' option for mobile and web implementations.
         */
        smartProxyEnabled?: boolean;
    }

    export interface ServiceCorsConfiguration {
        /**
         * If credentials are allowed via CORS.
         */
        allowCredentials?: boolean;
        /**
         * A set of headers to be allowed via CORS.
         */
        allowedHeaders?: string[];
        /**
         * The methods to be allowed via CORS.
         */
        allowedMethods?: string[];
        /**
         * A set of origins to be allowed via CORS.
         */
        allowedOrigins?: string[];
        /**
         * The max age to be allowed via CORS.
         */
        maxAgeInSeconds?: number;
    }

}

export namespace hpc {
    export interface CacheAccessPolicyAccessRule {
        /**
         * The access level for this rule. Possible values are: `rw`, `ro`, `no`.
         */
        access: string;
        /**
         * The anonymous GID used when `rootSquashEnabled` is `true`.
         */
        anonymousGid?: number;
        /**
         * The anonymous UID used when `rootSquashEnabled` is `true`.
         */
        anonymousUid?: number;
        /**
         * The filter applied to the `scope` for this rule. The filter's format depends on its scope: `default` scope matches all clients and has no filter value; `network` scope takes a CIDR format; `host` takes an IP address or fully qualified domain name. If a client does not match any filter rule and there is no default rule, access is denied.
         */
        filter?: string;
        /**
         * Whether to enable [root squash](https://docs.microsoft.com/en-us/azure/hpc-cache/access-policies#root-squash)? Defaults to `false`.
         */
        rootSquashEnabled?: boolean;
        /**
         * The scope of this rule. The `scope` and (potentially) the `filter` determine which clients match the rule. Possible values are: `default`, `network`, `host`.
         */
        scope: string;
        /**
         * Whether allow access to subdirectories under the root export? Defaults to `false`.
         */
        submountAccessEnabled?: boolean;
        /**
         * Whether [SUID](https://docs.microsoft.com/en-us/azure/hpc-cache/access-policies#suid) is allowed? Defaults to `false`.
         */
        suidEnabled?: boolean;
    }

    export interface CacheDefaultAccessPolicy {
        /**
         * One to three `accessRule` blocks as defined above.
         */
        accessRules: outputs.hpc.CacheDefaultAccessPolicyAccessRule[];
    }

    export interface CacheDefaultAccessPolicyAccessRule {
        /**
         * The access level for this rule. Possible values are: `rw`, `ro`, `no`.
         */
        access: string;
        /**
         * The anonymous GID used when `rootSquashEnabled` is `true`.
         */
        anonymousGid?: number;
        /**
         * The anonymous UID used when `rootSquashEnabled` is `true`.
         */
        anonymousUid?: number;
        /**
         * The filter applied to the `scope` for this rule. The filter's format depends on its scope: `default` scope matches all clients and has no filter value; `network` scope takes a CIDR format; `host` takes an IP address or fully qualified domain name. If a client does not match any filter rule and there is no default rule, access is denied.
         */
        filter?: string;
        /**
         * Whether to enable [root squash](https://docs.microsoft.com/en-us/azure/hpc-cache/access-policies#root-squash)? Defaults to `false`.
         */
        rootSquashEnabled?: boolean;
        /**
         * The scope of this rule. The `scope` and (potentially) the `filter` determine which clients match the rule. Possible values are: `default`, `network`, `host`.
         */
        scope: string;
        /**
         * Whether allow access to subdirectories under the root export? Defaults to `false`.
         */
        submountAccessEnabled?: boolean;
        /**
         * Whether [SUID](https://docs.microsoft.com/en-us/azure/hpc-cache/access-policies#suid) is allowed? Defaults to `false`.
         */
        suidEnabled?: boolean;
    }

    export interface CacheDirectoryActiveDirectory {
        /**
         * The NetBIOS name to assign to the HPC Cache when it joins the Active Directory domain as a server.
         */
        cacheNetbiosName: string;
        /**
         * The primary DNS IP address used to resolve the Active Directory domain controller's FQDN.
         */
        dnsPrimaryIp: string;
        /**
         * The secondary DNS IP address used to resolve the Active Directory domain controller's FQDN.
         */
        dnsSecondaryIp?: string;
        /**
         * The fully qualified domain name of the Active Directory domain controller.
         */
        domainName: string;
        /**
         * The Active Directory domain's NetBIOS name.
         */
        domainNetbiosName: string;
        /**
         * The password of the Active Directory domain administrator.
         */
        password: string;
        /**
         * The username of the Active Directory domain administrator.
         */
        username: string;
    }

    export interface CacheDirectoryFlatFile {
        /**
         * The URI of the file containing group information (`/etc/group` file format in Unix-like OS).
         */
        groupFileUri: string;
        /**
         * The URI of the file containing user information (`/etc/passwd` file format in Unix-like OS).
         */
        passwordFileUri: string;
    }

    export interface CacheDirectoryLdap {
        /**
         * The base distinguished name (DN) for the LDAP domain.
         */
        baseDn: string;
        /**
         * A `bind` block as defined above.
         */
        bind: outputs.hpc.CacheDirectoryLdapBind;
        /**
         * The URI of the CA certificate to validate the LDAP secure connection.
         */
        certificateValidationUri?: string;
        /**
         * Whether the certificate should be automatically downloaded. This can be set to `true` only when `certificateValidationUri` is provided. Defaults to `false`.
         */
        downloadCertificateAutomatically?: boolean;
        /**
         * Whether the LDAP connection should be encrypted? Defaults to `false`.
         */
        encrypted?: boolean;
        /**
         * The FQDN or IP address of the LDAP server.
         */
        server: string;
    }

    export interface CacheDirectoryLdapBind {
        /**
         * The Bind Distinguished Name (DN) identity to be used in the secure LDAP connection.
         */
        dn: string;
        /**
         * The Bind password to be used in the secure LDAP connection.
         */
        password: string;
    }

    export interface CacheDns {
        /**
         * The DNS search domain for the HPC Cache.
         */
        searchDomain?: string;
        /**
         * A list of DNS servers for the HPC Cache. At most three IP(s) are allowed to set.
         */
        servers: string[];
    }

    export interface CacheNfsTargetNamespaceJunction {
        /**
         * The name of the access policy applied to this target. Defaults to `default`.
         */
        accessPolicyName?: string;
        /**
         * The client-facing file path of this NFS target within the HPC Cache NFS Target.
         */
        namespacePath: string;
        /**
         * The NFS export of this NFS target within the HPC Cache NFS Target.
         */
        nfsExport: string;
        /**
         * The relative subdirectory path from the `nfsExport` to map to the `namespacePath`. Defaults to `""`, in which case the whole `nfsExport` is exported.
         */
        targetPath?: string;
    }

}

export namespace hsm {
    export interface ModuleNetworkProfile {
        /**
         * The private IPv4 address of the network interface. Changing this forces a new Dedicated Hardware Security Module to be created.
         */
        networkInterfacePrivateIpAddresses: string[];
        /**
         * The ID of the subnet. Changing this forces a new Dedicated Hardware Security Module to be created.
         */
        subnetId: string;
    }

}

export namespace iot {
    export interface IoTHubEndpoint {
        /**
         * Time interval at which blobs are written to storage. Value should be between 60 and 720 seconds. Default value is 300 seconds. This attribute is mandatory for endpoint type `AzureIotHub.StorageContainer`.
         */
        batchFrequencyInSeconds?: number;
        /**
         * The connection string for the endpoint.
         */
        connectionString: string;
        /**
         * The name of storage container in the storage account. This attribute is mandatory for endpoint type `AzureIotHub.StorageContainer`.
         */
        containerName?: string;
        /**
         * Encoding that is used to serialize messages to blobs. Supported values are 'avro' and 'avrodeflate'. Default value is 'avro'. This attribute is mandatory for endpoint type `AzureIotHub.StorageContainer`.
         */
        encoding?: string;
        /**
         * File name format for the blob. Default format is ``{iothub}/{partition}/{YYYY}/{MM}/{DD}/{HH}/{mm}``. All parameters are mandatory but can be reordered. This attribute is mandatory for endpoint type `AzureIotHub.StorageContainer`.
         */
        fileNameFormat?: string;
        /**
         * Maximum number of bytes for each blob written to storage. Value should be between 10485760(10MB) and 524288000(500MB). Default value is 314572800(300MB). This attribute is mandatory for endpoint type `AzureIotHub.StorageContainer`.
         */
        maxChunkSizeInBytes?: number;
        /**
         * The name of the endpoint. The name must be unique across endpoint types. The following names are reserved:  `events`, `operationsMonitoringEvents`, `fileNotifications` and `$default`.
         */
        name: string;
        /**
         * The resource group in which the endpoint will be created.
         */
        resourceGroupName?: string;
        /**
         * The type of the endpoint. Possible values are `AzureIotHub.StorageContainer`, `AzureIotHub.ServiceBusQueue`, `AzureIotHub.ServiceBusTopic` or `AzureIotHub.EventHub`.
         */
        type: string;
    }

    export interface IoTHubEnrichment {
        /**
         * The list of endpoints which will be enriched.
         */
        endpointNames: string[];
        /**
         * The key of the enrichment.
         */
        key: string;
        /**
         * The value of the enrichment. Value can be any static string, the name of the IoT hub sending the message (use `$iothubname`) or information from the device twin (ex: `$twin.tags.latitude`)
         */
        value: string;
    }

    export interface IoTHubFallbackRoute {
        /**
         * The condition that is evaluated to apply the routing rule. If no condition is provided, it evaluates to true by default. For grammar, see: https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-query-language.
         */
        condition?: string;
        /**
         * Used to specify whether the fallback route is enabled.
         */
        enabled: boolean;
        /**
         * The endpoints to which messages that satisfy the condition are routed. Currently only 1 endpoint is allowed.
         */
        endpointNames: string[];
        /**
         * The source that the routing rule is to be applied to, such as `DeviceMessages`. Possible values include: `RoutingSourceInvalid`, `RoutingSourceDeviceMessages`, `RoutingSourceTwinChangeEvents`, `RoutingSourceDeviceLifecycleEvents`, `RoutingSourceDeviceJobLifecycleEvents`.
         */
        source?: string;
    }

    export interface IoTHubFileUpload {
        /**
         * The connection string for the Azure Storage account to which files are uploaded.
         */
        connectionString: string;
        /**
         * The name of the root container where you upload files. The container need not exist but should be creatable using the connectionString specified.
         */
        containerName: string;
        /**
         * The period of time for which a file upload notification message is available to consume before it is expired by the IoT hub, specified as an [ISO 8601 timespan duration](https://en.wikipedia.org/wiki/ISO_8601#Durations). This value must be between 1 minute and 48 hours, and evaluates to 'PT1H' by default.
         */
        defaultTtl: string;
        /**
         * The lock duration for the file upload notifications queue, specified as an [ISO 8601 timespan duration](https://en.wikipedia.org/wiki/ISO_8601#Durations). This value must be between 5 and 300 seconds, and evaluates to 'PT1M' by default.
         */
        lockDuration: string;
        /**
         * The number of times the IoT hub attempts to deliver a file upload notification message. It evaluates to 10 by default.
         */
        maxDeliveryCount?: number;
        /**
         * Used to specify whether file notifications are sent to IoT Hub on upload. It evaluates to false by default.
         */
        notifications?: boolean;
        /**
         * The period of time for which the SAS URI generated by IoT Hub for file upload is valid, specified as an [ISO 8601 timespan duration](https://en.wikipedia.org/wiki/ISO_8601#Durations). This value must be between 1 minute and 24 hours, and evaluates to 'PT1H' by default.
         */
        sasTtl: string;
    }

    export interface IoTHubIpFilterRule {
        /**
         * The desired action for requests captured by this rule. Possible values are  `Accept`, `Reject`
         */
        action: string;
        /**
         * The IP address range in CIDR notation for the rule.
         */
        ipMask: string;
        /**
         * The name of the filter.
         */
        name: string;
    }

    export interface IoTHubRoute {
        /**
         * The condition that is evaluated to apply the routing rule. If no condition is provided, it evaluates to true by default. For grammar, see: https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-query-language.
         */
        condition?: string;
        /**
         * Used to specify whether a route is enabled.
         */
        enabled: boolean;
        /**
         * The list of endpoints to which messages that satisfy the condition are routed.
         */
        endpointNames: string[];
        /**
         * The name of the route.
         */
        name: string;
        /**
         * The source that the routing rule is to be applied to, such as `DeviceMessages`. Possible values include: `RoutingSourceInvalid`, `RoutingSourceDeviceMessages`, `RoutingSourceTwinChangeEvents`, `RoutingSourceDeviceLifecycleEvents`, `RoutingSourceDeviceJobLifecycleEvents`.
         */
        source: string;
    }

    export interface IoTHubSharedAccessPolicy {
        /**
         * The name of the shared access policy.
         */
        keyName: string;
        /**
         * The permissions assigned to the shared access policy.
         */
        permissions: string;
        /**
         * The primary key.
         */
        primaryKey: string;
        /**
         * The secondary key.
         */
        secondaryKey: string;
    }

    export interface IoTHubSku {
        /**
         * The number of provisioned IoT Hub units.
         */
        capacity: number;
        /**
         * The name of the sku. Possible values are `B1`, `B2`, `B3`, `F1`, `S1`, `S2`, and `S3`.
         */
        name: string;
    }

    export interface IotHubDpsLinkedHub {
        /**
         * The weight applied to the IoT Hub. Defaults to 0.
         */
        allocationWeight?: number;
        /**
         * Determines whether to apply allocation policies to the IoT Hub. Defaults to false.
         */
        applyAllocationPolicy?: boolean;
        /**
         * The connection string to connect to the IoT Hub. Changing this forces a new resource.
         */
        connectionString: string;
        /**
         * The IoT Hub hostname.
         */
        hostname: string;
        /**
         * The location of the IoT hub. Changing this forces a new resource.
         */
        location: string;
    }

    export interface IotHubDpsSku {
        /**
         * The number of provisioned IoT Device Provisioning Service units.
         */
        capacity: number;
        /**
         * The name of the sku. Currently can only be set to `S1`.
         */
        name: string;
    }

    export interface SecurityDeviceGroupAllowRule {
        /**
         * Specifies which Ip is not allowed to be connected to in current device group.
         */
        connectionToIpNotAlloweds?: string[];
        /**
         * Specifies which local user is not allowed to Login in current device group.
         */
        localUserNotAlloweds?: string[];
        /**
         * Specifies which process is not allowed to be executed in current device group.
         */
        processNotAlloweds?: string[];
    }

    export interface SecurityDeviceGroupRangeRule {
        /**
         * Specifies the time range. represented in ISO 8601 duration format.
         */
        duration: string;
        /**
         * The maximum threshold in the given time window.
         */
        max: number;
        /**
         * The minimum threshold in the given time window.
         */
        min: number;
        /**
         * The type of supported rule type. Possible Values are `ActiveConnectionsNotInAllowedRange`, `AmqpC2DMessagesNotInAllowedRange`, `MqttC2DMessagesNotInAllowedRange`, `HttpC2DMessagesNotInAllowedRange`, `AmqpC2DRejectedMessagesNotInAllowedRange`, `MqttC2DRejectedMessagesNotInAllowedRange`, `HttpC2DRejectedMessagesNotInAllowedRange`, `AmqpD2CMessagesNotInAllowedRange`, `MqttD2CMessagesNotInAllowedRange`, `HttpD2CMessagesNotInAllowedRange`, `DirectMethodInvokesNotInAllowedRange`, `FailedLocalLoginsNotInAllowedRange`, `FileUploadsNotInAllowedRange`, `QueuePurgesNotInAllowedRange`, `TwinUpdatesNotInAllowedRange` and `UnauthorizedOperationsNotInAllowedRange`.
         */
        type: string;
    }

    export interface SecuritySolutionRecommendationsEnabled {
        /**
         * Is Principal Authentication enabled for the ACR repository? Defaults to `true`.
         */
        acrAuthentication?: boolean;
        /**
         * Is Agent send underutilized messages enabled? Defaults to `true`.
         */
        agentSendUnutilizedMsg?: boolean;
        /**
         * Is Security related system configuration issues identified? Defaults to `true`.
         */
        baseline?: boolean;
        /**
         * Is IoT Edge Hub memory optimized? Defaults to `true`.
         */
        edgeHubMemOptimize?: boolean;
        /**
         * Is logging configured for IoT Edge module? Defaults to `true`.
         */
        edgeLoggingOption?: boolean;
        /**
         * Is inconsistent module settings enabled for SecurityGroup? Defaults to `true`.
         */
        inconsistentModuleSettings?: boolean;
        /**
         * is Azure IoT Security agent installed? Defaults to `true`.
         */
        installAgent?: boolean;
        /**
         * Is Default IP filter policy denied? Defaults to `true`.
         */
        ipFilterDenyAll?: boolean;
        /**
         * Is IP filter rule source allowable IP range too large? Defaults to `true`.
         */
        ipFilterPermissiveRule?: boolean;
        /**
         * Is any ports open on the device? Defaults to `true`.
         */
        openPorts?: boolean;
        /**
         * Does firewall policy exist which allow necessary communication to/from the device? Defaults to `true`.
         */
        permissiveFirewallPolicy?: boolean;
        /**
         * Is only necessary addresses or ports are permitted in? Defaults to `true`.
         */
        permissiveInputFirewallRules?: boolean;
        /**
         * Is only necessary addresses or ports are permitted out? Defaults to `true`.
         */
        permissiveOutputFirewallRules?: boolean;
        /**
         * Is high level permissions are needed for the module? Defaults to `true`.
         */
        privilegedDockerOptions?: boolean;
        /**
         * Is any credentials shared among devices? Defaults to `true`.
         */
        sharedCredentials?: boolean;
        /**
         * Does TLS cipher suite need to be updated? Defaults to `true`.
         */
        vulnerableTlsCipherSuite?: boolean;
    }

    export interface TimeSeriesInsightsGen2EnvironmentStorage {
        /**
         * Access key of storage account for Azure IoT Time Series Insights Gen2 Environment
         */
        key: string;
        /**
         * Name of storage account for Azure IoT Time Series Insights Gen2 Environment
         */
        name: string;
    }

    export interface TimeSeriesInsightsReferenceDataSetKeyProperty {
        /**
         * The name of the key property. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * The data type of the key property. Valid values include `Bool`, `DateTime`, `Double`, `String`. Changing this forces a new resource to be created.
         */
        type: string;
    }

}

export namespace keyvault {
    export interface CertifiateCertificate {
        /**
         * The base64-encoded certificate contents. Changing this forces a new resource to be created.
         */
        contents: string;
        /**
         * The password associated with the certificate. Changing this forces a new resource to be created.
         */
        password?: string;
    }

    export interface CertifiateCertificateAttribute {
        /**
         * The create time of the Key Vault Certificate.
         */
        created: string;
        /**
         * whether the Key Vault Certificate is enabled.
         */
        enabled: boolean;
        /**
         * The expires time of the Key Vault Certificate.
         */
        expires: string;
        /**
         * The not before valid time of the Key Vault Certificate.
         */
        notBefore: string;
        /**
         * The deletion recovery level of the Key Vault Certificate.
         */
        recoveryLevel: string;
        /**
         * The recent update time of the Key Vault Certificate.
         */
        updated: string;
    }

    export interface CertifiateCertificatePolicy {
        /**
         * A `issuerParameters` block as defined below.
         */
        issuerParameters: outputs.keyvault.CertifiateCertificatePolicyIssuerParameters;
        /**
         * A `keyProperties` block as defined below.
         */
        keyProperties: outputs.keyvault.CertifiateCertificatePolicyKeyProperties;
        /**
         * A `lifetimeAction` block as defined below.
         */
        lifetimeActions?: outputs.keyvault.CertifiateCertificatePolicyLifetimeAction[];
        /**
         * A `secretProperties` block as defined below.
         */
        secretProperties: outputs.keyvault.CertifiateCertificatePolicySecretProperties;
        /**
         * A `x509CertificateProperties` block as defined below. Required when `certificate` block is not specified.
         */
        x509CertificateProperties: outputs.keyvault.CertifiateCertificatePolicyX509CertificateProperties;
    }

    export interface CertifiateCertificatePolicyIssuerParameters {
        /**
         * The name of the Certificate Issuer. Possible values include `Self` (for self-signed certificate), or `Unknown` (for a certificate issuing authority like `Let's Encrypt` and Azure direct supported ones). Changing this forces a new resource to be created.
         */
        name: string;
    }

    export interface CertifiateCertificatePolicyKeyProperties {
        /**
         * Specifies the curve to use when creating an `EC` key. Possible values are `P-256`, `P-256K`, `P-384`, and `P-521`. This field will be required in a future release if `keyType` is `EC` or `EC-HSM`. Changing this forces a new resource to be created.
         */
        curve: string;
        /**
         * Is this certificate exportable? Changing this forces a new resource to be created.
         */
        exportable: boolean;
        /**
         * The size of the key used in the certificate. Possible values include `2048`, `3072`, and `4096` for `RSA` keys, or `256`, `384`, and `521` for `EC` keys. This property is required when using RSA keys. Changing this forces a new resource to be created.
         */
        keySize: number;
        /**
         * Specifies the type of key, such as `RSA` or `EC`. Changing this forces a new resource to be created.
         */
        keyType: string;
        /**
         * Is the key reusable? Changing this forces a new resource to be created.
         */
        reuseKey: boolean;
    }

    export interface CertifiateCertificatePolicyLifetimeAction {
        /**
         * A `action` block as defined below.
         */
        action: outputs.keyvault.CertifiateCertificatePolicyLifetimeActionAction;
        /**
         * A `trigger` block as defined below.
         */
        trigger: outputs.keyvault.CertifiateCertificatePolicyLifetimeActionTrigger;
    }

    export interface CertifiateCertificatePolicyLifetimeActionAction {
        /**
         * The Type of action to be performed when the lifetime trigger is triggerec. Possible values include `AutoRenew` and `EmailContacts`. Changing this forces a new resource to be created.
         */
        actionType: string;
    }

    export interface CertifiateCertificatePolicyLifetimeActionTrigger {
        /**
         * The number of days before the Certificate expires that the action associated with this Trigger should run. Changing this forces a new resource to be created. Conflicts with `lifetimePercentage`.
         */
        daysBeforeExpiry?: number;
        /**
         * The percentage at which during the Certificates Lifetime the action associated with this Trigger should run. Changing this forces a new resource to be created. Conflicts with `daysBeforeExpiry`.
         */
        lifetimePercentage?: number;
    }

    export interface CertifiateCertificatePolicySecretProperties {
        /**
         * The Content-Type of the Certificate, such as `application/x-pkcs12` for a PFX or `application/x-pem-file` for a PEM. Changing this forces a new resource to be created.
         */
        contentType: string;
    }

    export interface CertifiateCertificatePolicyX509CertificateProperties {
        /**
         * A list of Extended/Enhanced Key Usages. Changing this forces a new resource to be created.
         */
        extendedKeyUsages: string[];
        /**
         * A list of uses associated with this Key. Possible values include `cRLSign`, `dataEncipherment`, `decipherOnly`, `digitalSignature`, `encipherOnly`, `keyAgreement`, `keyCertSign`, `keyEncipherment` and `nonRepudiation` and are case-sensitive. Changing this forces a new resource to be created.
         */
        keyUsages: string[];
        /**
         * The Certificate's Subject. Changing this forces a new resource to be created.
         */
        subject: string;
        /**
         * A `subjectAlternativeNames` block as defined below.
         */
        subjectAlternativeNames: outputs.keyvault.CertifiateCertificatePolicyX509CertificatePropertiesSubjectAlternativeNames;
        /**
         * The Certificates Validity Period in Months. Changing this forces a new resource to be created.
         */
        validityInMonths: number;
    }

    export interface CertifiateCertificatePolicyX509CertificatePropertiesSubjectAlternativeNames {
        /**
         * A list of alternative DNS names (FQDNs) identified by the Certificate. Changing this forces a new resource to be created.
         */
        dnsNames?: string[];
        /**
         * A list of email addresses identified by this Certificate. Changing this forces a new resource to be created.
         */
        emails?: string[];
        /**
         * A list of User Principal Names identified by the Certificate. Changing this forces a new resource to be created.
         */
        upns?: string[];
    }

    export interface CertificateCertificate {
        /**
         * The base64-encoded certificate contents. Changing this forces a new resource to be created.
         */
        contents: string;
        /**
         * The password associated with the certificate. Changing this forces a new resource to be created.
         */
        password?: string;
    }

    export interface CertificateCertificateAttribute {
        /**
         * The create time of the Key Vault Certificate.
         */
        created: string;
        /**
         * whether the Key Vault Certificate is enabled.
         */
        enabled: boolean;
        /**
         * The expires time of the Key Vault Certificate.
         */
        expires: string;
        /**
         * The not before valid time of the Key Vault Certificate.
         */
        notBefore: string;
        /**
         * The deletion recovery level of the Key Vault Certificate.
         */
        recoveryLevel: string;
        /**
         * The recent update time of the Key Vault Certificate.
         */
        updated: string;
    }

    export interface CertificateCertificatePolicy {
        /**
         * A `issuerParameters` block as defined below.
         */
        issuerParameters: outputs.keyvault.CertificateCertificatePolicyIssuerParameters;
        /**
         * A `keyProperties` block as defined below.
         */
        keyProperties: outputs.keyvault.CertificateCertificatePolicyKeyProperties;
        /**
         * A `lifetimeAction` block as defined below.
         */
        lifetimeActions?: outputs.keyvault.CertificateCertificatePolicyLifetimeAction[];
        /**
         * A `secretProperties` block as defined below.
         */
        secretProperties: outputs.keyvault.CertificateCertificatePolicySecretProperties;
        /**
         * A `x509CertificateProperties` block as defined below. Required when `certificate` block is not specified.
         */
        x509CertificateProperties: outputs.keyvault.CertificateCertificatePolicyX509CertificateProperties;
    }

    export interface CertificateCertificatePolicyIssuerParameters {
        /**
         * The name of the Certificate Issuer. Possible values include `Self` (for self-signed certificate), or `Unknown` (for a certificate issuing authority like `Let's Encrypt` and Azure direct supported ones). Changing this forces a new resource to be created.
         */
        name: string;
    }

    export interface CertificateCertificatePolicyKeyProperties {
        /**
         * Specifies the curve to use when creating an `EC` key. Possible values are `P-256`, `P-256K`, `P-384`, and `P-521`. This field will be required in a future release if `keyType` is `EC` or `EC-HSM`. Changing this forces a new resource to be created.
         */
        curve: string;
        /**
         * Is this certificate exportable? Changing this forces a new resource to be created.
         */
        exportable: boolean;
        /**
         * The size of the key used in the certificate. Possible values include `2048`, `3072`, and `4096` for `RSA` keys, or `256`, `384`, and `521` for `EC` keys. This property is required when using RSA keys. Changing this forces a new resource to be created.
         */
        keySize: number;
        /**
         * Specifies the type of key, such as `RSA` or `EC`. Changing this forces a new resource to be created.
         */
        keyType: string;
        /**
         * Is the key reusable? Changing this forces a new resource to be created.
         */
        reuseKey: boolean;
    }

    export interface CertificateCertificatePolicyLifetimeAction {
        /**
         * A `action` block as defined below.
         */
        action: outputs.keyvault.CertificateCertificatePolicyLifetimeActionAction;
        /**
         * A `trigger` block as defined below.
         */
        trigger: outputs.keyvault.CertificateCertificatePolicyLifetimeActionTrigger;
    }

    export interface CertificateCertificatePolicyLifetimeActionAction {
        /**
         * The Type of action to be performed when the lifetime trigger is triggerec. Possible values include `AutoRenew` and `EmailContacts`. Changing this forces a new resource to be created.
         */
        actionType: string;
    }

    export interface CertificateCertificatePolicyLifetimeActionTrigger {
        /**
         * The number of days before the Certificate expires that the action associated with this Trigger should run. Changing this forces a new resource to be created. Conflicts with `lifetimePercentage`.
         */
        daysBeforeExpiry?: number;
        /**
         * The percentage at which during the Certificates Lifetime the action associated with this Trigger should run. Changing this forces a new resource to be created. Conflicts with `daysBeforeExpiry`.
         */
        lifetimePercentage?: number;
    }

    export interface CertificateCertificatePolicySecretProperties {
        /**
         * The Content-Type of the Certificate, such as `application/x-pkcs12` for a PFX or `application/x-pem-file` for a PEM. Changing this forces a new resource to be created.
         */
        contentType: string;
    }

    export interface CertificateCertificatePolicyX509CertificateProperties {
        /**
         * A list of Extended/Enhanced Key Usages. Changing this forces a new resource to be created.
         */
        extendedKeyUsages: string[];
        /**
         * A list of uses associated with this Key. Possible values include `cRLSign`, `dataEncipherment`, `decipherOnly`, `digitalSignature`, `encipherOnly`, `keyAgreement`, `keyCertSign`, `keyEncipherment` and `nonRepudiation` and are case-sensitive. Changing this forces a new resource to be created.
         */
        keyUsages: string[];
        /**
         * The Certificate's Subject. Changing this forces a new resource to be created.
         */
        subject: string;
        /**
         * A `subjectAlternativeNames` block as defined below.
         */
        subjectAlternativeNames: outputs.keyvault.CertificateCertificatePolicyX509CertificatePropertiesSubjectAlternativeNames;
        /**
         * The Certificates Validity Period in Months. Changing this forces a new resource to be created.
         */
        validityInMonths: number;
    }

    export interface CertificateCertificatePolicyX509CertificatePropertiesSubjectAlternativeNames {
        /**
         * A list of alternative DNS names (FQDNs) identified by the Certificate. Changing this forces a new resource to be created.
         */
        dnsNames?: string[];
        /**
         * A list of email addresses identified by this Certificate. Changing this forces a new resource to be created.
         */
        emails?: string[];
        /**
         * A list of User Principal Names identified by the Certificate. Changing this forces a new resource to be created.
         */
        upns?: string[];
    }

    export interface CertificateIssuerAdmin {
        /**
         * E-mail address of the admin.
         */
        emailAddress: string;
        /**
         * First name of the admin.
         */
        firstName?: string;
        /**
         * Last name of the admin.
         */
        lastName?: string;
        /**
         * Phone number of the admin.
         */
        phone?: string;
    }

    export interface GetCertificateCertificatePolicy {
        /**
         * A `issuerParameters` block as defined below.
         */
        issuerParameters: outputs.keyvault.GetCertificateCertificatePolicyIssuerParameter[];
        /**
         * A `keyProperties` block as defined below.
         */
        keyProperties: outputs.keyvault.GetCertificateCertificatePolicyKeyProperty[];
        /**
         * A `lifetimeAction` block as defined below.
         */
        lifetimeActions: outputs.keyvault.GetCertificateCertificatePolicyLifetimeAction[];
        /**
         * A `secretProperties` block as defined below.
         */
        secretProperties: outputs.keyvault.GetCertificateCertificatePolicySecretProperty[];
        /**
         * An `x509CertificateProperties` block as defined below.
         */
        x509CertificateProperties: outputs.keyvault.GetCertificateCertificatePolicyX509CertificateProperty[];
    }

    export interface GetCertificateCertificatePolicyIssuerParameter {
        /**
         * Specifies the name of the Key Vault Certificate.
         */
        name: string;
    }

    export interface GetCertificateCertificatePolicyKeyProperty {
        curve: string;
        /**
         * Is this Certificate Exportable?
         */
        exportable: boolean;
        /**
         * The size of the Key used in the Certificate.
         */
        keySize: number;
        /**
         * Specifies the Type of Key, for example `RSA`.
         */
        keyType: string;
        /**
         * Is the key reusable?
         */
        reuseKey: boolean;
    }

    export interface GetCertificateCertificatePolicyLifetimeAction {
        /**
         * A `action` block as defined below.
         */
        actions: outputs.keyvault.GetCertificateCertificatePolicyLifetimeActionAction[];
        /**
         * A `trigger` block as defined below.
         */
        triggers: outputs.keyvault.GetCertificateCertificatePolicyLifetimeActionTrigger[];
    }

    export interface GetCertificateCertificatePolicyLifetimeActionAction {
        /**
         * The Type of action to be performed when the lifetime trigger is triggerec.
         */
        actionType: string;
    }

    export interface GetCertificateCertificatePolicyLifetimeActionTrigger {
        /**
         * The number of days before the Certificate expires that the action associated with this Trigger should run.
         */
        daysBeforeExpiry: number;
        /**
         * The percentage at which during the Certificates Lifetime the action associated with this Trigger should run.
         */
        lifetimePercentage: number;
    }

    export interface GetCertificateCertificatePolicySecretProperty {
        /**
         * The Content-Type of the Certificate, for example `application/x-pkcs12` for a PFX or `application/x-pem-file` for a PEM.
         */
        contentType: string;
    }

    export interface GetCertificateCertificatePolicyX509CertificateProperty {
        /**
         * A list of Extended/Enhanced Key Usages.
         */
        extendedKeyUsages: string[];
        /**
         * A list of uses associated with this Key.
         */
        keyUsages: string[];
        /**
         * The Certificate's Subject.
         */
        subject: string;
        /**
         * A `subjectAlternativeNames` block as defined below.
         */
        subjectAlternativeNames: outputs.keyvault.GetCertificateCertificatePolicyX509CertificatePropertySubjectAlternativeName[];
        /**
         * The Certificates Validity Period in Months.
         */
        validityInMonths: number;
    }

    export interface GetCertificateCertificatePolicyX509CertificatePropertySubjectAlternativeName {
        /**
         * A list of alternative DNS names (FQDNs) identified by the Certificate.
         */
        dnsNames: string[];
        /**
         * A list of email addresses identified by this Certificate.
         */
        emails: string[];
        /**
         * A list of User Principal Names identified by the Certificate.
         */
        upns: string[];
    }

    export interface GetCertificateIssuerAdmin {
        /**
         * E-mail address of the admin.
         */
        emailAddress: string;
        /**
         * First name of the admin.
         */
        firstName: string;
        /**
         * Last name of the admin.
         */
        lastName: string;
        /**
         * Phone number of the admin.
         */
        phone: string;
    }

    export interface GetKeyVaultAccessPolicy {
        /**
         * The Object ID of a Azure Active Directory Application.
         */
        applicationId: string;
        /**
         * A list of certificate permissions applicable to this Access Policy.
         */
        certificatePermissions: string[];
        /**
         * A list of key permissions applicable to this Access Policy.
         */
        keyPermissions: string[];
        /**
         * An Object ID of a User, Service Principal or Security Group.
         */
        objectId: string;
        /**
         * A list of secret permissions applicable to this Access Policy.
         */
        secretPermissions: string[];
        /**
         * A list of storage permissions applicable to this Access Policy.
         */
        storagePermissions: string[];
        /**
         * The Azure Active Directory Tenant ID used to authenticate requests for this Key Vault.
         */
        tenantId: string;
    }

    export interface GetKeyVaultNetworkAcl {
        bypass: string;
        defaultAction: string;
        ipRules: string[];
        virtualNetworkSubnetIds: string[];
    }

    export interface KeyVaultAccessPolicy {
        /**
         * The object ID of an Application in Azure Active Directory.
         */
        applicationId?: string;
        /**
         * List of certificate permissions, must be one or more from the following: `Backup`, `Create`, `Delete`, `DeleteIssuers`, `Get`, `GetIssuers`, `Import`, `List`, `ListIssuers`, `ManageContacts`, `ManageIssuers`, `Purge`, `Recover`, `Restore`, `SetIssuers` and `Update`.
         */
        certificatePermissions?: string[];
        /**
         * List of key permissions, must be one or more from the following: `Backup`, `Create`, `Decrypt`, `Delete`, `Encrypt`, `Get`, `Import`, `List`, `Purge`, `Recover`, `Restore`, `Sign`, `UnwrapKey`, `Update`, `Verify` and `WrapKey`.
         */
        keyPermissions?: string[];
        /**
         * The object ID of a user, service principal or security group in the Azure Active Directory tenant for the vault. The object ID must be unique for the list of access policies.
         */
        objectId: string;
        /**
         * List of secret permissions, must be one or more from the following: `Backup`, `Delete`, `Get`, `List`, `Purge`, `Recover`, `Restore` and `Set`.
         */
        secretPermissions?: string[];
        /**
         * List of storage permissions, must be one or more from the following: `Backup`, `Delete`, `DeleteSAS`, `Get`, `GetSAS`, `List`, `ListSAS`, `Purge`, `Recover`, `RegenerateKey`, `Restore`, `Set`, `SetSAS` and `Update`.
         */
        storagePermissions?: string[];
        /**
         * The Azure Active Directory tenant ID that should be used for authenticating requests to the key vault. Must match the `tenantId` used above.
         */
        tenantId: string;
    }

    export interface KeyVaultContact {
        /**
         * E-mail address of the contact.
         */
        email: string;
        /**
         * Name of the contact.
         */
        name?: string;
        /**
         * Phone number of the contact.
         */
        phone?: string;
    }

    export interface KeyVaultNetworkAcls {
        /**
         * Specifies which traffic can bypass the network rules. Possible values are `AzureServices` and `None`.
         */
        bypass: string;
        /**
         * The Default Action to use when no rules match from `ipRules` / `virtualNetworkSubnetIds`. Possible values are `Allow` and `Deny`.
         */
        defaultAction: string;
        /**
         * One or more IP Addresses, or CIDR Blocks which should be able to access the Key Vault.
         */
        ipRules?: string[];
        /**
         * One or more Subnet ID's which should be able to access this Key Vault.
         */
        virtualNetworkSubnetIds?: string[];
    }
}

export namespace kusto {
    export interface ClusterIdentity {
        /**
         * A list of IDs for User Assigned Managed Identity resources to be assigned.
         */
        identityIds?: string[];
        /**
         * The Principal ID associated with this System Assigned Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this System Assigned Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that is configured on this Kusto Cluster. Possible values are: `SystemAssigned`, `UserAssigned` and `SystemAssigned, UserAssigned`.
         */
        type: string;
    }

    export interface ClusterOptimizedAutoScale {
        /**
         * The maximum number of allowed instances. Must between `0` and `1000`.
         */
        maximumInstances: number;
        /**
         * The minimum number of allowed instances. Must between `0` and `1000`.
         */
        minimumInstances: number;
    }

    export interface ClusterSku {
        /**
         * Specifies the node count for the cluster. Boundaries depend on the sku name.
         */
        capacity: number;
        /**
         * The name of the SKU. Valid values are: `Dev(No SLA)_Standard_D11_v2`, `Dev(No SLA)_Standard_E2a_v4`, `Standard_D11_v2`, `Standard_D12_v2`, `Standard_D13_v2`, `Standard_D14_v2`, `Standard_DS13_v2+1TB_PS`, `Standard_DS13_v2+2TB_PS`, `Standard_DS14_v2+3TB_PS`, `Standard_DS14_v2+4TB_PS`, `Standard_E16as_v4+3TB_PS`, `Standard_E16as_v4+4TB_PS`, `Standard_E16a_v4`, `Standard_E2a_v4`, `Standard_E4a_v4`, `Standard_E64i_v3`, `Standard_E8as_v4+1TB_PS`, `Standard_E8as_v4+2TB_PS`, `Standard_E8a_v4`, `Standard_L16s`, `Standard_L4s` and `Standard_L8s`.
         */
        name: string;
    }

    export interface ClusterVirtualNetworkConfiguration {
        /**
         * Data management's service public IP address resource id.
         */
        dataManagementPublicIpId: string;
        /**
         * Engine service's public IP address resource id.
         */
        enginePublicIpId: string;
        /**
         * The subnet resource id.
         */
        subnetId: string;
    }

}

export namespace lb {
    export interface BackendAddressPoolBackendAddress {
        ipAddress: string;
        /**
         * Specifies the name of the Backend Address Pool.
         */
        name: string;
        virtualNetworkId: string;
    }

    export interface GetBackendAddressPoolBackendAddress {
        /**
         * The Static IP address for this Load Balancer within the Virtual Network.
         */
        ipAddress: string;
        /**
         * Specifies the name of the Backend Address Pool.
         */
        name: string;
        /**
         * The ID of the Virtual Network where the Backend Address of the Load Balancer exists.
         */
        virtualNetworkId: string;
    }

    export interface GetBackendAddressPoolBackendIpConfiguration {
        /**
         * The ID of the Backend Address Pool.
         */
        id: string;
    }

    export interface GetLBFrontendIpConfiguration {
        /**
         * The id of the Frontend IP Configuration.
         */
        id: string;
        /**
         * Specifies the name of the Load Balancer.
         */
        name: string;
        /**
         * Private IP Address to assign to the Load Balancer.
         */
        privateIpAddress: string;
        /**
         * The allocation method for the Private IP Address used by this Load Balancer.
         */
        privateIpAddressAllocation: string;
        /**
         * The Private IP Address Version, either `IPv4` or `IPv6`.
         */
        privateIpAddressVersion: string;
        /**
         * The ID of a  Public IP Address which is associated with this Load Balancer.
         */
        publicIpAddressId: string;
        /**
         * The ID of the Subnet which is associated with the IP Configuration.
         */
        subnetId: string;
        /**
         * A list of Availability Zones which the Load Balancer's IP Addresses should be created in.
         */
        zones: string[];
    }

    export interface LoadBalancerFrontendIpConfiguration {
        /**
         * A list of Availability Zones which the Load Balancer's IP Addresses should be created in. Possible values are `Zone-Redundant`, `1`, `2`, `3`, and `No-Zone`. Defaults to `Zone-Redundant`.
         * `No-Zones` - A `non-zonal` resource will be created and the resource will not be replicated or distributed to any Availability Zones.
         */
        availabilityZone: string;
        /**
         * The id of the Frontend IP Configuration.
         */
        id: string;
        /**
         * The list of IDs of inbound rules that use this frontend IP.
         */
        inboundNatRules: string[];
        /**
         * The list of IDs of load balancing rules that use this frontend IP.
         */
        loadBalancerRules: string[];
        /**
         * Specifies the name of the frontend ip configuration.
         */
        name: string;
        /**
         * The list of IDs outbound rules that use this frontend IP.
         */
        outboundRules: string[];
        /**
         * Private IP Address to assign to the Load Balancer. The last one and first four IPs in any range are reserved and cannot be manually assigned.
         */
        privateIpAddress: string;
        /**
         * The allocation method for the Private IP Address used by this Load Balancer. Possible values as `Dynamic` and `Static`.
         */
        privateIpAddressAllocation: string;
        /**
         * The version of IP that the Private IP Address is. Possible values are `IPv4` or `IPv6`.
         */
        privateIpAddressVersion: string;
        /**
         * The ID of a Public IP Address which should be associated with the Load Balancer.
         */
        publicIpAddressId: string;
        /**
         * The ID of a Public IP Prefix which should be associated with the Load Balancer. Public IP Prefix can only be used with outbound rules.
         */
        publicIpPrefixId: string;
        /**
         * The ID of the Subnet which should be associated with the IP Configuration.
         */
        subnetId: string;
        /**
         * @deprecated This property has been deprecated in favour of `availability_zone` due to a breaking behavioural change in Azure: https://azure.microsoft.com/en-us/updates/zone-behavior-change/
         */
        zones: string;
    }

    export interface OutboundRuleFrontendIpConfiguration {
        /**
         * The ID of the Load Balancer Outbound Rule.
         */
        id: string;
        /**
         * The name of the Frontend IP Configuration.
         */
        name: string;
    }

}

export namespace lighthouse {
    export interface DefinitionAuthorization {
        /**
         * The set of role definition ids which define all the permissions that the principal id can assign.
         */
        delegatedRoleDefinitionIds?: string[];
        /**
         * The display name of the security group/service principal/user that would be assigned permissions to the projected subscription.
         */
        principalDisplayName?: string;
        /**
         * Principal ID of the security group/service principal/user that would be assigned permissions to the projected subscription.
         */
        principalId: string;
        /**
         * The role definition identifier. This role will define the permissions that are granted to the principal. This cannot be an `Owner` role.
         */
        roleDefinitionId: string;
    }

    export interface DefinitionPlan {
        /**
         * The plan name of the marketplace offer.
         */
        name: string;
        /**
         * The product code of the plan.
         */
        product: string;
        /**
         * The publisher ID of the plan.
         */
        publisher: string;
        /**
         * The version of the plan.
         */
        version: string;
    }

}

export namespace loganalytics {
    export interface ClusterIdentity {
        /**
         * The Principal ID for the Service Principal associated with the Identity of this Log Analytics Cluster.
         */
        principalId: string;
        /**
         * The Tenant ID for the Service Principal associated with the Identity of this Log Analytics Cluster.
         */
        tenantId: string;
        /**
         * Specifies the identity type of the Log Analytics Cluster. At this time the only allowed value is `SystemAssigned`.
         */
        type: string;
    }

}

export namespace logicapps {
    export interface ActionHttpRunAfter {
        /**
         * Specifies the name of the precedent HTTP Action.
         */
        actionName: string;
        /**
         * Specifies the expected result of the precedent HTTP Action, only after which the current HTTP Action will be triggered. Possible values include `Succeeded`, `Failed`, `Skipped` and `TimedOut`.
         */
        actionResult: string;
    }

    export interface TriggerRecurrenceSchedule {
        /**
         * Specifies a list of hours when the trigger should run. Valid values are between 0 and 23.
         */
        atTheseHours?: number[];
        /**
         * Specifies a list of minutes when the trigger should run. Valid values are between 0 and 59.
         */
        atTheseMinutes?: number[];
        /**
         * Specifies a list of days when the trigger should run. Valid values include `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday`, and `Sunday`.
         */
        onTheseDays?: string[];
    }

}

export namespace machinelearning {
    export interface ComputeClusterIdentity {
        principalId: string;
        tenantId: string;
        /**
         * The Type of Identity which should be used for this Disk Encryption Set. At this time the only possible value is SystemAssigned. Changing this forces a new Machine Learning Compute Cluster to be created.
         */
        type: string;
    }

    export interface ComputeClusterScaleSettings {
        /**
         * Maximum node count. Changing this forces a new Machine Learning Compute Cluster to be created.
         */
        maxNodeCount: number;
        /**
         * Minimal node count. Changing this forces a new Machine Learning Compute Cluster to be created.
         */
        minNodeCount: number;
        /**
         * Node Idle Time Before Scale Down: defines the time until the compute is shutdown when it has gone into Idle state. Is defined according to W3C XML schema standard for duration. Changing this forces a new Machine Learning Compute Cluster to be created.
         */
        scaleDownNodesAfterIdleDuration: string;
    }

    export interface GetWorkspaceIdentity {
        principalId: string;
        tenantId: string;
        type: string;
    }

    export interface InferenceClusterSsl {
        /**
         * The certificate for the ssl configuration.Conflicts with `ssl.0.leaf_domain_label`,`ssl.0.overwrite_existing_domain`. Changing this forces a new Machine Learning Inference Cluster to be created.
         */
        cert?: string;
        /**
         * The cname of the ssl configuration.Conflicts with `ssl.0.leaf_domain_label`,`ssl.0.overwrite_existing_domain`. Changing this forces a new Machine Learning Inference Cluster to be created.
         */
        cname?: string;
        /**
         * The key content for the ssl configuration.Conflicts with `ssl.0.leaf_domain_label`,`ssl.0.overwrite_existing_domain`. Changing this forces a new Machine Learning Inference Cluster to be created.
         */
        key?: string;
        /**
         * The leaf domain label for the ssl configuration. Conflicts with `ssl.0.cert`,`ssl.0.key`,`ssl.0.cname`. Changing this forces a new Machine Learning Inference Cluster to be created.
         */
        leafDomainLabel?: string;
        /**
         * Whether or not to overwrite existing leaf domain. Conflicts with `ssl.0.cert`,`ssl.0.key`,`ssl.0.cname` Changing this forces a new Machine Learning Inference Cluster to be created.
         */
        overwriteExistingDomain?: boolean;
    }

    export interface WorkspaceIdentity {
        /**
         * The (Client) ID of the Service Principal.
         */
        principalId: string;
        /**
         * The ID of the Tenant the Service Principal is assigned in.
         */
        tenantId: string;
        /**
         * The Type of Identity which should be used for this Disk Encryption Set. At this time the only possible value is `SystemAssigned`.
         */
        type: string;
    }

}

export namespace managedapplication {
    export interface ApplicationPlan {
        /**
         * Specifies the name of the plan from the marketplace.
         */
        name: string;
        /**
         * Specifies the product of the plan from the marketplace.
         */
        product: string;
        /**
         * Specifies the promotion code to use with the plan.
         */
        promotionCode?: string;
        /**
         * Specifies the publisher of the plan.
         */
        publisher: string;
        /**
         * Specifies the version of the plan from the marketplace.
         */
        version: string;
    }

    export interface DefinitionAuthorization {
        /**
         * Specifies a role definition identifier for the provider. This role will define all the permissions that the provider must have on the managed application's container resource group. This role definition cannot have permission to delete the resource group.
         */
        roleDefinitionId: string;
        /**
         * Specifies a service principal identifier for the provider. This is the identity that the provider will use to call ARM to manage the managed application resources.
         */
        servicePrincipalId: string;
    }

}

export namespace management {
    export interface GroupPolicyAssignmentIdentity {
        /**
         * The Principal ID of the Policy Assignment for this Management Group.
         */
        principalId: string;
        /**
         * The Tenant ID of the Policy Assignment for this Management Group.
         */
        tenantId: string;
        /**
         * The Type of Managed Identity which should be added to this Policy Definition. The only possible value is `SystemAssigned`.
         */
        type?: string;
    }

}

export namespace mariadb {
    export interface GetMariaDbServerStorageProfile {
        /**
         * Whether autogrow is enabled or disabled for the storage.
         */
        autoGrow: string;
        /**
         * Backup retention days for the server.
         */
        backupRetentionDays: number;
        /**
         * Whether Geo-redundant is enabled or not for server backup.
         */
        geoRedundantBackup: string;
        /**
         * The max storage allowed for a server.
         */
        storageMb: number;
    }

    export interface ServerStorageProfile {
        /**
         * @deprecated this has been moved to the top level boolean attribute `auto_grow_enabled` and will be removed in version 3.0 of the provider.
         */
        autoGrow: string;
        /**
         * Backup retention days for the server, supported values are between `7` and `35` days.
         *
         * @deprecated this has been moved to the top level and will be removed in version 3.0 of the provider.
         */
        backupRetentionDays: number;
        /**
         * @deprecated this has been moved to the top level boolean attribute `geo_redundant_backup_enabled` and will be removed in version 3.0 of the provider.
         */
        geoRedundantBackup: string;
        /**
         * Max storage allowed for a server. Possible values are between `5120` MB (5GB) and `1024000`MB (1TB) for the Basic SKU and between `5120` MB (5GB) and `4096000` MB (4TB) for General Purpose/Memory Optimized SKUs. For more information see the [product documentation](https://docs.microsoft.com/en-us/rest/api/mariadb/servers/create#storageprofile).
         *
         * @deprecated this has been moved to the top level and will be removed in version 3.0 of the provider.
         */
        storageMb?: number;
    }

}

export namespace media {
    export interface AssetFilterPresentationTimeRange {
        /**
         * The absolute end time boundary. Applies to Video on Demand (VoD).
         * For the Live Streaming presentation, it is silently ignored and applied when the presentation ends and the stream becomes VoD. This is a long value that represents an absolute end point of the presentation, rounded to the closest next GOP start. The unit is defined by `unitTimescaleInMiliseconds`, so an `endInUnits` of 180 would be for 3 minutes. Use `startInUnits` and `endInUnits` to trim the fragments that will be in the playlist (manifest). For example, `startInUnits` set to 20 and `endInUnits` set to 60 using `unitTimescaleInMiliseconds` in 1000 will generate a playlist that contains fragments from between 20 seconds and 60 seconds of the VoD presentation. If a fragment straddles the boundary, the entire fragment will be included in the manifest.
         */
        endInUnits?: number;
        /**
         * Indicates whether the `endInUnits` property must be present. If true, `endInUnits` must be specified or a bad request code is returned. Applies to Live Streaming only. Allowed values: false, true.
         */
        forceEnd?: boolean;
        /**
         * The relative to end right edge. Applies to Live Streaming only.
         * This value defines the latest live position that a client can seek to. Using this property, you can delay live playback position and create a server-side buffer for players. The unit is defined by `unitTimescaleInMiliseconds`. The maximum live back off duration is 300 seconds. For example, a value of 20 means that the latest available content is 20 seconds delayed from the real live edge.
         */
        liveBackoffInUnits?: number;
        /**
         * The relative to end sliding window. Applies to Live Streaming only. Use `presentationWindowInUnits` to apply a sliding window of fragments to include in a playlist. The unit is defined by `unitTimescaleInMiliseconds`. For example, set  `presentationWindowInUnits` to 120 to apply a two-minute sliding window. Media within 2 minutes of the live edge will be included in the playlist. If a fragment straddles the boundary, the entire fragment will be included in the playlist. The minimum presentation window duration is 60 seconds.
         */
        presentationWindowInUnits?: number;
        /**
         * The absolute start time boundary. Applies to Video on Demand (VoD) or Live Streaming. This is a long value that represents an absolute start point of the stream. The value gets rounded to the closest next GOP start. The unit is defined by `unitTimescaleInMiliseconds`, so a `startInUnits` of 15 would be for 15 seconds. Use `startInUnits` and `endInUnits` to trim the fragments that will be in the playlist (manifest). For example, `startInUnits` set to 20 and `endInUnits` set to 60 using `unitTimescaleInMiliseconds` in 1000 will generate a playlist that contains fragments from between 20 seconds and 60 seconds of the VoD presentation. If a fragment straddles the boundary, the entire fragment will be included in the manifest.
         */
        startInUnits?: number;
        /**
         * Specified as the number of miliseconds in one unit timescale. For example, if you want to set a `startInUnits` at 30 seconds, you would use a value of 30 when using the `unitTimescaleInMiliseconds` in 1000. Or if you want to set `startInUnits` in 30 miliseconds, you would use a value of 30 when using the `unitTimescaleInMiliseconds` in 1.  Applies timescale to `startInUnits`, `startTimescale` and `presentationWindowInTimescale` and `liveBackoffInTimescale`.
         */
        unitTimescaleInMiliseconds?: number;
    }

    export interface AssetFilterTrackSelection {
        /**
         * One or more `condition` blocks as defined above.
         */
        conditions: outputs.media.AssetFilterTrackSelectionCondition[];
    }

    export interface AssetFilterTrackSelectionCondition {
        /**
         * The condition operation to test a track property against. Supported values are `Equal` and `NotEqual`.
         */
        operation?: string;
        /**
         * The track property to compare. Supported values are `Bitrate`, `FourCC`, `Language`, `Name` and `Type`. Check [documentation](https://docs.microsoft.com/en-us/azure/media-services/latest/filters-concept) for more details.
         */
        property?: string;
        /**
         * The track property value to match or not match.
         */
        value?: string;
    }

    export interface ContentKeyPolicyPolicyOption {
        /**
         * Enable a configuration for non-DRM keys.
         */
        clearKeyConfigurationEnabled?: boolean;
        /**
         * A `fairplayConfiguration` block as defined above. Check license requirements here https://docs.microsoft.com/en-us/azure/media-services/latest/fairplay-license-overview.
         */
        fairplayConfiguration?: outputs.media.ContentKeyPolicyPolicyOptionFairplayConfiguration;
        /**
         * The name which should be used for this Policy Option.
         */
        name: string;
        /**
         * Enable an open restriction. License or key will be delivered on every request.
         */
        openRestrictionEnabled?: boolean;
        /**
         * One or more `playreadyConfigurationLicense` blocks as defined above.
         */
        playreadyConfigurationLicenses?: outputs.media.ContentKeyPolicyPolicyOptionPlayreadyConfigurationLicense[];
        /**
         * A `tokenRestriction` block as defined below.
         */
        tokenRestriction?: outputs.media.ContentKeyPolicyPolicyOptionTokenRestriction;
        /**
         * The Widevine template.
         */
        widevineConfigurationTemplate?: string;
    }

    export interface ContentKeyPolicyPolicyOptionFairplayConfiguration {
        /**
         * The key that must be used as FairPlay Application Secret key.
         */
        ask?: string;
        /**
         * A `offlineRentalConfiguration` block as defined below.
         */
        offlineRentalConfiguration?: outputs.media.ContentKeyPolicyPolicyOptionFairplayConfigurationOfflineRentalConfiguration;
        /**
         * The Base64 representation of FairPlay certificate in PKCS 12 (pfx) format (including private key).
         */
        pfx?: string;
        /**
         * The password encrypting FairPlay certificate in PKCS 12 (pfx) format.
         */
        pfxPassword?: string;
        /**
         * The rental and lease key type. Supported values are `DualExpiry`, `PersistentLimited`, `PersistentUnlimited` or `Undefined`.
         */
        rentalAndLeaseKeyType?: string;
        /**
         * The rental duration. Must be greater than 0.
         */
        rentalDurationSeconds?: number;
    }

    export interface ContentKeyPolicyPolicyOptionFairplayConfigurationOfflineRentalConfiguration {
        /**
         * Playback duration.
         */
        playbackDurationSeconds?: number;
        /**
         * Storage duration.
         */
        storageDurationSeconds?: number;
    }

    export interface ContentKeyPolicyPolicyOptionPlayreadyConfigurationLicense {
        /**
         * A flag indicating whether test devices can use the license.
         */
        allowTestDevices?: boolean;
        /**
         * The begin date of license.
         */
        beginDate?: string;
        /**
         * Specifies that the content key ID is in the PlayReady header.
         */
        contentKeyLocationFromHeaderEnabled?: boolean;
        /**
         * The content key ID. Specifies that the content key ID is specified in the PlayReady configuration.
         */
        contentKeyLocationFromKeyId?: string;
        /**
         * The PlayReady content type. Supported values are `UltraVioletDownload`, `UltraVioletStreaming` or `Unspecified`.
         */
        contentType?: string;
        /**
         * The expiration date of license.
         */
        expirationDate?: string;
        /**
         * The grace period of license.
         */
        gracePeriod?: string;
        /**
         * The license type. Supported values are `NonPersistent` or `Persistent`.
         */
        licenseType?: string;
        /**
         * A `playRight` block as defined above.
         */
        playRight?: outputs.media.ContentKeyPolicyPolicyOptionPlayreadyConfigurationLicensePlayRight;
        /**
         * The relative begin date of license.
         */
        relativeBeginDate?: string;
        /**
         * The relative expiration date of license.
         */
        relativeExpirationDate?: string;
    }

    export interface ContentKeyPolicyPolicyOptionPlayreadyConfigurationLicensePlayRight {
        /**
         * Configures Automatic Gain Control (AGC) and Color Stripe in the license. Must be between 0 and 3 inclusive.
         */
        agcAndColorStripeRestriction?: number;
        /**
         * Configures Unknown output handling settings of the license. Supported values are `Allowed`, `AllowedWithVideoConstriction` or `NotAllowed`.
         */
        allowPassingVideoContentToUnknownOutput?: string;
        /**
         * Specifies the output protection level for compressed digital audio. Supported values are 100, 150 or 200.
         */
        analogVideoOpl?: number;
        /**
         * Specifies the output protection level for compressed digital audio.Supported values are 100, 150 or 200.
         */
        compressedDigitalAudioOpl?: number;
        /**
         * Enables the Image Constraint For Analog Component Video Restriction in the license.
         */
        digitalVideoOnlyContentRestriction?: boolean;
        /**
         * The amount of time that the license is valid after the license is first used to play content.
         */
        firstPlayExpiration?: string;
        /**
         * Enables the Image Constraint For Analog Component Video Restriction in the license.
         */
        imageConstraintForAnalogComponentVideoRestriction?: boolean;
        /**
         * Enables the Image Constraint For Analog Component Video Restriction in the license.
         */
        imageConstraintForAnalogComputerMonitorRestriction?: boolean;
        /**
         * Configures the Serial Copy Management System (SCMS) in the license. Must be between 0 and 3 inclusive.
         */
        scmsRestriction?: number;
        /**
         * Specifies the output protection level for uncompressed digital audio. Supported values are 100, 150, 250 or 300.
         */
        uncompressedDigitalAudioOpl?: number;
        /**
         * Specifies the output protection level for uncompressed digital video. Supported values are 100, 150, 250 or 300.
         */
        uncompressedDigitalVideoOpl?: number;
    }

    export interface ContentKeyPolicyPolicyOptionTokenRestriction {
        /**
         * The audience for the token.
         */
        audience?: string;
        /**
         * The token issuer.
         */
        issuer?: string;
        /**
         * The OpenID connect discovery document.
         */
        openIdConnectDiscoveryDocument?: string;
        /**
         * The RSA Parameter exponent.
         */
        primaryRsaTokenKeyExponent?: string;
        /**
         * The RSA Parameter modulus.
         */
        primaryRsaTokenKeyModulus?: string;
        /**
         * The key value of the key. Specifies a symmetric key for token validation.
         */
        primarySymmetricTokenKey?: string;
        /**
         * The raw data field of a certificate in PKCS 12 format (X509Certificate2 in .NET). Specifies a certificate for token validation.
         */
        primaryX509TokenKeyRaw?: string;
        /**
         * One or more `requiredClaim` blocks as defined above.
         */
        requiredClaims?: outputs.media.ContentKeyPolicyPolicyOptionTokenRestrictionRequiredClaim[];
        /**
         * The type of token. Supported values are `Jwt` or `Swt`.
         */
        tokenType?: string;
    }

    export interface ContentKeyPolicyPolicyOptionTokenRestrictionRequiredClaim {
        /**
         * Token claim type.
         */
        type?: string;
        /**
         * Token claim value.
         */
        value?: string;
    }

    export interface JobInputAsset {
        /**
         * A label that is assigned to a JobInputClip, that is used to satisfy a reference used in the Transform. For example, a Transform can be authored so as to take an image file with the label 'xyz' and apply it as an overlay onto the input video before it is encoded. When submitting a Job, exactly one of the JobInputs should be the image file, and it should have the label 'xyz'.
         */
        label?: string;
        /**
         * The name of the input Asset. Changing this forces a new Media Job to be created.
         */
        name: string;
    }

    export interface JobOutputAsset {
        /**
         * A label that is assigned to a JobOutput in order to help uniquely identify it. This is useful when your Transform has more than one TransformOutput, whereby your Job has more than one JobOutput. In such cases, when you submit the Job, you will add two or more JobOutputs, in the same order as TransformOutputs in the Transform. Subsequently, when you retrieve the Job, either through events or on a GET request, you can use the label to easily identify the JobOutput. If a label is not provided, a default value of '{presetName}_{outputIndex}' will be used, where the preset name is the name of the preset in the corresponding TransformOutput and the output index is the relative index of the this JobOutput within the Job. Note that this index is the same as the relative index of the corresponding TransformOutput within its Transform.
         */
        label?: string;
        /**
         * The name of the output Asset. Changing this forces a new Media Job to be created.
         */
        name: string;
    }

    export interface LiveEventCrossSiteAccessPolicy {
        /**
         * The content of clientaccesspolicy.xml used by Silverlight.
         */
        clientAccessPolicy?: string;
        /**
         * The content of the Cross Domain Policy (`crossdomain.xml`).
         */
        crossDomainPolicy?: string;
    }

    export interface LiveEventEncoding {
        /**
         * Use an `ISO 8601` time value between 0.5 to 20 seconds to specify the output fragment length for the video and audio tracks of an encoding live event. For example, use `PT2S` to indicate 2 seconds. For the video track it also defines the key frame interval, or the length of a GoP (group of pictures). If this value is not set for an encoding live event, the fragment duration defaults to 2 seconds. The value cannot be set for pass-through live events.
         */
        keyFrameInterval?: string;
        /**
         * The optional encoding preset name, used when `type` is not `None`. If the `type` is set to `Standard`, then the default preset name is `Default720p`. Else if the `type` is set to `Premium1080p`, the default preset is `Default1080p`. Changing this forces a new resource to be created.
         */
        presetName?: string;
        /**
         * Specifies how the input video will be resized to fit the desired output resolution(s). Allowed values are `None`, `AutoFit` or `AutoSize`. Default is `None`.
         */
        stretchMode?: string;
        /**
         * Live event type. Allowed values are `None`, `Premium1080p` or `Standard`. When set to `None`, the service simply passes through the incoming video and audio layer(s) to the output. When `type` is set to `Standard` or `Premium1080p`, a live encoder transcodes the incoming stream into multiple bitrates or layers. Defaults to `None`. Changing this forces a new resource to be created.
         */
        type?: string;
    }

    export interface LiveEventInput {
        /**
         * A UUID in string form to uniquely identify the stream. If omitted, the service will generate a unique value. Changing this forces a new value to be created.
         */
        accessToken: string;
        endpoints: outputs.media.LiveEventInputEndpoint[];
        /**
         * One or more `ipAccessControlAllow` blocks as defined below.
         */
        ipAccessControlAllows?: outputs.media.LiveEventInputIpAccessControlAllow[];
        /**
         * ISO 8601 time duration of the key frame interval duration of the input. This value sets the `EXT-X-TARGETDURATION` property in the HLS output. For example, use PT2S to indicate 2 seconds. This field cannot be set when `type` is set to `Encoding`.
         */
        keyFrameIntervalDuration?: string;
        /**
         * The input protocol for the live event. Allowed values are `FragmentedMP4` and `RTMP`. Changing this forces a new resource to be created.
         */
        streamingProtocol?: string;
    }

    export interface LiveEventInputEndpoint {
        protocol: string;
        url: string;
    }

    export interface LiveEventInputIpAccessControlAllow {
        /**
         * The IP address or CIDR range.
         */
        address?: string;
        /**
         * The friendly name for the IP address range.
         */
        name?: string;
        /**
         * The subnet mask prefix length (see CIDR notation).
         */
        subnetPrefixLength?: number;
    }

    export interface LiveEventPreview {
        /**
         * An alternative media identifier associated with the streaming locator created for the preview. The identifier can be used in the `CustomLicenseAcquisitionUrlTemplate` or the `CustomKeyAcquisitionUrlTemplate` of the Streaming Policy specified in the `streamingPolicyName` field. Changing this forces a new resource to be created.
         */
        alternativeMediaId?: string;
        endpoints: outputs.media.LiveEventPreviewEndpoint[];
        /**
         * One or more `ipAccessControlAllow` blocks as defined above.
         */
        ipAccessControlAllows?: outputs.media.LiveEventPreviewIpAccessControlAllow[];
        /**
         * The identifier of the preview locator in Guid format. Specifying this at creation time allows the caller to know the preview locator url before the event is created. If omitted, the service will generate a random identifier. Changing this forces a new resource to be created.
         */
        previewLocator: string;
        /**
         * The name of streaming policy used for the live event preview. Changing this forces a new resource to be created.
         */
        streamingPolicyName: string;
    }

    export interface LiveEventPreviewEndpoint {
        protocol: string;
        url: string;
    }

    export interface LiveEventPreviewIpAccessControlAllow {
        /**
         * The IP address or CIDR range.
         */
        address?: string;
        /**
         * The friendly name for the IP address range.
         */
        name?: string;
        /**
         * The subnet mask prefix length (see CIDR notation).
         */
        subnetPrefixLength?: number;
    }

    export interface ServiceAccountIdentity {
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Media Services Account. Possible value is  `SystemAssigned`.
         */
        type?: string;
    }

    export interface ServiceAccountKeyDeliveryAccessControl {
        /**
         * The Default Action to use when no rules match from `ipAllowList`. Possible values are `Allow` and `Deny`.
         */
        defaultAction?: string;
        /**
         * One or more IP Addresses, or CIDR Blocks which should be able to access the Key Delivery.
         */
        ipAllowLists?: string[];
    }

    export interface ServiceAccountStorageAccount {
        /**
         * Specifies the ID of the Storage Account that will be associated with the Media Services instance.
         */
        id: string;
        /**
         * Specifies whether the storage account should be the primary account or not. Defaults to `false`.
         */
        isPrimary?: boolean;
    }

    export interface StreamingEndpointAccessControl {
        /**
         * One or more `akamaiSignatureHeaderAuthenticationKey` blocks as defined below.
         */
        akamaiSignatureHeaderAuthenticationKeys?: outputs.media.StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKey[];
        /**
         * A `ip` block as defined below.
         */
        ipAllows?: outputs.media.StreamingEndpointAccessControlIpAllow[];
    }

    export interface StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKey {
        /**
         * Authentication key.
         */
        base64Key?: string;
        /**
         * The expiration time of the authentication key.
         */
        expiration?: string;
        /**
         * Identifier of the key.
         */
        identifier?: string;
    }

    export interface StreamingEndpointAccessControlIpAllow {
        /**
         * The IP address to allow.
         */
        address?: string;
        /**
         * The friendly name for the IP address range.
         */
        name?: string;
        /**
         * The subnet mask prefix length (see CIDR notation).
         */
        subnetPrefixLength?: number;
    }

    export interface StreamingEndpointCrossSiteAccessPolicy {
        /**
         * The content of clientaccesspolicy.xml used by Silverlight.
         */
        clientAccessPolicy: string;
        /**
         * The content of crossdomain.xml used by Silverlight.
         */
        crossDomainPolicy: string;
    }

    export interface StreamingLocatorContentKey {
        /**
         * ID of Content Key. Changing this forces a new Streaming Locator to be created.
         */
        contentKeyId?: string;
        /**
         * Label of Content Key as specified in the Streaming Policy. Changing this forces a new Streaming Locator to be created.
         */
        labelReferenceInStreamingPolicy?: string;
        /**
         * Content Key Policy used by Content Key. Changing this forces a new Streaming Locator to be created.
         */
        policyName?: string;
        /**
         * Encryption type of Content Key. Supported values are `CommonEncryptionCbcs`, `CommonEncryptionCenc` or `EnvelopeEncryption`. Changing this forces a new Streaming Locator to be created.
         */
        type?: string;
        /**
         * Value of Content Key. Changing this forces a new Streaming Locator to be created.
         */
        value?: string;
    }

    export interface StreamingPolicyCommonEncryptionCbcs {
        /**
         * A `defaultContentKey` block as defined below. Changing this forces a new Streaming Policy to be created.
         */
        defaultContentKey?: outputs.media.StreamingPolicyCommonEncryptionCbcsDefaultContentKey;
        /**
         * A `drmFairplay` block as defined below. Changing this forces a new Streaming Policy to be created.
         */
        drmFairplay?: outputs.media.StreamingPolicyCommonEncryptionCbcsDrmFairplay;
        /**
         * A `enabledProtocols` block as defined below. Changing this forces a new Streaming Policy to be created.
         */
        enabledProtocols?: outputs.media.StreamingPolicyCommonEncryptionCbcsEnabledProtocols;
    }

    export interface StreamingPolicyCommonEncryptionCbcsDefaultContentKey {
        /**
         * Label can be used to specify Content Key when creating a Streaming Locator. Changing this forces a new Streaming Policy to be created.
         */
        label?: string;
        /**
         * Policy used by Default Key. Changing this forces a new Streaming Policy to be created.
         */
        policyName?: string;
    }

    export interface StreamingPolicyCommonEncryptionCbcsDrmFairplay {
        /**
         * All license to be persistent or not. Changing this forces a new Streaming Policy to be created.
         */
        allowPersistentLicense?: boolean;
        /**
         * Template for the URL of the custom service delivering licenses to end user players. Not required when using Azure Media Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the value specific to the request. The currently supported token values are `{AlternativeMediaId}`, which is replaced with the value of `StreamingLocatorId.AlternativeMediaId`, and `{ContentKeyId}`, which is replaced with the value of identifier of the key being requested. Changing this forces a new Streaming Policy to be created.
         */
        customLicenseAcquisitionUrlTemplate?: string;
    }

    export interface StreamingPolicyCommonEncryptionCbcsEnabledProtocols {
        /**
         * Enable DASH protocol or not. Changing this forces a new Streaming Policy to be created.
         */
        dash?: boolean;
        /**
         * Enable Download protocol or not. Changing this forces a new Streaming Policy to be created.
         */
        download?: boolean;
        /**
         * Enable HLS protocol or not. Changing this forces a new Streaming Policy to be created.
         */
        hls?: boolean;
        /**
         * Enable SmoothStreaming protocol or not. Changing this forces a new Streaming Policy to be created.
         */
        smoothStreaming?: boolean;
    }

    export interface StreamingPolicyCommonEncryptionCenc {
        /**
         * A `defaultContentKey` block as defined below. Changing this forces a new Streaming Policy to be created.
         */
        defaultContentKey?: outputs.media.StreamingPolicyCommonEncryptionCencDefaultContentKey;
        /**
         * A `drmPlayready` block as defined below. Changing this forces a new Streaming Policy to be created.
         */
        drmPlayready?: outputs.media.StreamingPolicyCommonEncryptionCencDrmPlayready;
        /**
         * Template for the URL of the custom service delivering licenses to end user players. Not required when using Azure Media Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the value specific to the request. The currently supported token values are `{AlternativeMediaId}`, which is replaced with the value of `StreamingLocatorId.AlternativeMediaId`, and `{ContentKeyId}`, which is replaced with the value of identifier of the key being requested. Changing this forces a new Streaming Policy to be created.
         */
        drmWidevineCustomLicenseAcquisitionUrlTemplate?: string;
        /**
         * A `enabledProtocols` block as defined below. Changing this forces a new Streaming Policy to be created.
         */
        enabledProtocols?: outputs.media.StreamingPolicyCommonEncryptionCencEnabledProtocols;
    }

    export interface StreamingPolicyCommonEncryptionCencDefaultContentKey {
        /**
         * Label can be used to specify Content Key when creating a Streaming Locator. Changing this forces a new Streaming Policy to be created.
         */
        label?: string;
        /**
         * Policy used by Default Key. Changing this forces a new Streaming Policy to be created.
         */
        policyName?: string;
    }

    export interface StreamingPolicyCommonEncryptionCencDrmPlayready {
        /**
         * Custom attributes for PlayReady. Changing this forces a new Streaming Policy to be created.
         */
        customAttributes?: string;
        /**
         * Template for the URL of the custom service delivering licenses to end user players. Not required when using Azure Media Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the value specific to the request. The currently supported token values are `{AlternativeMediaId}`, which is replaced with the value of `StreamingLocatorId.AlternativeMediaId`, and `{ContentKeyId}`, which is replaced with the value of identifier of the key being requested. Changing this forces a new Streaming Policy to be created.
         */
        customLicenseAcquisitionUrlTemplate?: string;
    }

    export interface StreamingPolicyCommonEncryptionCencEnabledProtocols {
        /**
         * Enable DASH protocol or not. Changing this forces a new Streaming Policy to be created.
         */
        dash?: boolean;
        /**
         * Enable Download protocol or not. Changing this forces a new Streaming Policy to be created.
         */
        download?: boolean;
        /**
         * Enable HLS protocol or not. Changing this forces a new Streaming Policy to be created.
         */
        hls?: boolean;
        /**
         * Enable SmoothStreaming protocol or not. Changing this forces a new Streaming Policy to be created.
         */
        smoothStreaming?: boolean;
    }

    export interface StreamingPolicyNoEncryptionEnabledProtocols {
        /**
         * Enable DASH protocol or not. Changing this forces a new Streaming Policy to be created.
         */
        dash?: boolean;
        /**
         * Enable Download protocol or not. Changing this forces a new Streaming Policy to be created.
         */
        download?: boolean;
        /**
         * Enable HLS protocol or not. Changing this forces a new Streaming Policy to be created.
         */
        hls?: boolean;
        /**
         * Enable SmoothStreaming protocol or not. Changing this forces a new Streaming Policy to be created.
         */
        smoothStreaming?: boolean;
    }

    export interface TransformOutput {
        /**
         * A `audioAnalyzerPreset` block as defined below.
         */
        audioAnalyzerPreset?: outputs.media.TransformOutputAudioAnalyzerPreset;
        /**
         * A `builtinPreset` block as defined below.
         */
        builtinPreset?: outputs.media.TransformOutputBuiltinPreset;
        /**
         * A `faceDetectorPreset` block as defined below.
         */
        faceDetectorPreset?: outputs.media.TransformOutputFaceDetectorPreset;
        /**
         * A Transform can define more than one outputs. This property defines what the service should do when one output fails - either continue to produce other outputs, or, stop the other outputs. The overall Job state will not reflect failures of outputs that are specified with `ContinueJob`. Possibles value are `StopProcessingJob` or `ContinueJob`.
         */
        onErrorAction?: string;
        /**
         * Sets the relative priority of the TransformOutputs within a Transform. This sets the priority that the service uses for processing Transform Outputs. Possibles value are `High`, `Normal` or `Low`.
         */
        relativePriority?: string;
        /**
         * A `videoAnalyzerPreset` block as defined below.
         */
        videoAnalyzerPreset?: outputs.media.TransformOutputVideoAnalyzerPreset;
    }

    export interface TransformOutputAudioAnalyzerPreset {
        /**
         * Possibles value are `Basic` or `Standard`. Determines the set of audio analysis operations to be performed.
         */
        audioAnalysisMode?: string;
        /**
         * The language for the audio payload in the input using the BCP-47 format of 'language tag-region' (e.g: 'en-US'). If you know the language of your content, it is recommended that you specify it. The language must be specified explicitly for AudioAnalysisMode:Basic, since automatic language detection is not included in basic mode. If the language isn't specified, automatic language detection will choose the first language detected and process with the selected language for the duration of the file. It does not currently support dynamically switching between languages after the first language is detected. The automatic detection works best with audio recordings with clearly discernable speech. If automatic detection fails to find the language, transcription would fallback to 'en-US'." The list of supported languages is available here: https://go.microsoft.com/fwlink/?linkid=2109463.
         */
        audioLanguage?: string;
    }

    export interface TransformOutputBuiltinPreset {
        /**
         * The built-in preset to be used for encoding videos. The allowed values are `AACGoodQualityAudio`, `AdaptiveStreaming`,`ContentAwareEncoding`, `ContentAwareEncodingExperimental`,`CopyAllBitrateNonInterleaved`, `H264MultipleBitrate1080p`,`H264MultipleBitrate720p`, `H264MultipleBitrateSD`,`H264SingleBitrate1080p`, `H264SingleBitrate720p` and `H264SingleBitrateSD`.
         */
        presetName?: string;
    }

    export interface TransformOutputFaceDetectorPreset {
        /**
         * Possibles value are `SourceResolution` or `StandardDefinition`. Specifies the maximum resolution at which your video is analyzed. The default behavior is `SourceResolution` which will keep the input video at its original resolution when analyzed. Using `StandardDefinition` will resize input videos to standard definition while preserving the appropriate aspect ratio. It will only resize if the video is of higher resolution. For example, a 1920x1080 input would be scaled to 640x360 before processing. Switching to `StandardDefinition` will reduce the time it takes to process high resolution video. It may also reduce the cost of using this component (see https://azure.microsoft.com/en-us/pricing/details/media-services/#analytics for details). However, faces that end up being too small in the resized video may not be detected.
         */
        analysisResolution?: string;
    }

    export interface TransformOutputVideoAnalyzerPreset {
        /**
         * Possibles value are `Basic` or `Standard`. Determines the set of audio analysis operations to be performed.
         */
        audioAnalysisMode?: string;
        /**
         * The language for the audio payload in the input using the BCP-47 format of 'language tag-region' (e.g: 'en-US'). If you know the language of your content, it is recommended that you specify it. The language must be specified explicitly for AudioAnalysisMode:Basic, since automatic language detection is not included in basic mode. If the language isn't specified, automatic language detection will choose the first language detected and process with the selected language for the duration of the file. It does not currently support dynamically switching between languages after the first language is detected. The automatic detection works best with audio recordings with clearly discernable speech. If automatic detection fails to find the language, transcription would fallback to 'en-US'." The list of supported languages is available here: https://go.microsoft.com/fwlink/?linkid=2109463.
         */
        audioLanguage?: string;
        /**
         * Defines the type of insights that you want the service to generate. The allowed values are `AudioInsightsOnly`, `VideoInsightsOnly`, and `AllInsights`. If you set this to `AllInsights` and the input is audio only, then only audio insights are generated. Similarly if the input is video only, then only video insights are generated. It is recommended that you not use `AudioInsightsOnly` if you expect some of your inputs to be video only; or use `VideoInsightsOnly` if you expect some of your inputs to be audio only. Your Jobs in such conditions would error out.
         */
        insightsType?: string;
    }

}

export namespace mediaservices {
    export interface AccountIdentity {
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Media Services Account. Possible value is  `SystemAssigned`.
         */
        type?: string;
    }

    export interface AccountKeyDeliveryAccessControl {
        /**
         * The Default Action to use when no rules match from `ipAllowList`. Possible values are `Allow` and `Deny`.
         */
        defaultAction?: string;
        /**
         * One or more IP Addresses, or CIDR Blocks which should be able to access the Key Delivery.
         */
        ipAllowLists?: string[];
    }

    export interface AccountStorageAccount {
        /**
         * Specifies the ID of the Storage Account that will be associated with the Media Services instance.
         */
        id: string;
        /**
         * Specifies whether the storage account should be the primary account or not. Defaults to `false`.
         */
        isPrimary?: boolean;
    }

}

export namespace monitoring {
    export interface AadDiagnosticSettingLog {
        /**
         * The log category for the Azure Active Directory Diagnostic. Possible values are `AuditLogs`, `SignInLogs`, `ADFSSignInLogs`, `ManagedIdentitySignInLogs`, `NonInteractiveUserSignInLogs`, `ProvisioningLogs`, `ServicePrincipalSignInLogs`.
         */
        category: string;
        /**
         * Is this Diagnostic Log enabled? Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * A `retentionPolicy` block as defined below.
         */
        retentionPolicy: outputs.monitoring.AadDiagnosticSettingLogRetentionPolicy;
    }

    export interface AadDiagnosticSettingLogRetentionPolicy {
        /**
         * The number of days for which this Retention Policy should apply. Defaults to `0`.
         */
        days?: number;
        /**
         * Is this Retention Policy enabled? Defaults to `false`.
         */
        enabled?: boolean;
    }

    export interface ActionGroupArmRoleReceiver {
        /**
         * The name of the ARM role receiver.
         */
        name: string;
        /**
         * The arm role id.
         */
        roleId: string;
        /**
         * Enables or disables the common alert schema.
         */
        useCommonAlertSchema?: boolean;
    }

    export interface ActionGroupAutomationRunbookReceiver {
        /**
         * The automation account ID which holds this runbook and authenticates to Azure resources.
         */
        automationAccountId: string;
        /**
         * Indicates whether this instance is global runbook.
         */
        isGlobalRunbook: boolean;
        /**
         * The name of the automation runbook receiver.
         */
        name: string;
        /**
         * The name for this runbook.
         */
        runbookName: string;
        /**
         * The URI where webhooks should be sent.
         */
        serviceUri: string;
        /**
         * Enables or disables the common alert schema.
         */
        useCommonAlertSchema?: boolean;
        /**
         * The resource id for webhook linked to this runbook.
         */
        webhookResourceId: string;
    }

    export interface ActionGroupAzureAppPushReceiver {
        /**
         * The email address of the user signed into the mobile app who will receive push notifications from this receiver.
         */
        emailAddress: string;
        /**
         * The name of the Azure app push receiver.
         */
        name: string;
    }

    export interface ActionGroupAzureFunctionReceiver {
        /**
         * The Azure resource ID of the function app.
         */
        functionAppResourceId: string;
        /**
         * The function name in the function app.
         */
        functionName: string;
        /**
         * The http trigger url where http request sent to.
         */
        httpTriggerUrl: string;
        /**
         * The name of the Azure Function receiver.
         */
        name: string;
        /**
         * Enables or disables the common alert schema.
         */
        useCommonAlertSchema?: boolean;
    }

    export interface ActionGroupEmailReceiver {
        /**
         * The email address of this receiver.
         */
        emailAddress: string;
        /**
         * The name of the email receiver. Names must be unique (case-insensitive) across all receivers within an action group.
         */
        name: string;
        /**
         * Enables or disables the common alert schema.
         */
        useCommonAlertSchema?: boolean;
    }

    export interface ActionGroupItsmReceiver {
        /**
         * The unique connection identifier of the ITSM connection.
         */
        connectionId: string;
        /**
         * The name of the ITSM receiver.
         */
        name: string;
        /**
         * The region of the workspace.
         */
        region: string;
        /**
         * A JSON blob for the configurations of the ITSM action. CreateMultipleWorkItems option will be part of this blob as well.
         */
        ticketConfiguration: string;
        /**
         * The Azure Log Analytics workspace ID where this connection is defined.
         */
        workspaceId: string;
    }

    export interface ActionGroupLogicAppReceiver {
        /**
         * The callback url where http request sent to.
         */
        callbackUrl: string;
        /**
         * The name of the logic app receiver.
         */
        name: string;
        /**
         * The Azure resource ID of the logic app.
         */
        resourceId: string;
        /**
         * Enables or disables the common alert schema.
         */
        useCommonAlertSchema?: boolean;
    }

    export interface ActionGroupSmsReceiver {
        /**
         * The country code of the SMS receiver.
         */
        countryCode: string;
        /**
         * The name of the SMS receiver. Names must be unique (case-insensitive) across all receivers within an action group.
         */
        name: string;
        /**
         * The phone number of the SMS receiver.
         */
        phoneNumber: string;
    }

    export interface ActionGroupVoiceReceiver {
        /**
         * The country code of the voice receiver.
         */
        countryCode: string;
        /**
         * The name of the voice receiver.
         */
        name: string;
        /**
         * The phone number of the voice receiver.
         */
        phoneNumber: string;
    }

    export interface ActionGroupWebhookReceiver {
        /**
         * The `aadAuth` block as defined below
         */
        aadAuth?: outputs.monitoring.ActionGroupWebhookReceiverAadAuth;
        /**
         * The name of the webhook receiver. Names must be unique (case-insensitive) across all receivers within an action group.
         */
        name: string;
        /**
         * The URI where webhooks should be sent.
         */
        serviceUri: string;
        /**
         * Enables or disables the common alert schema.
         */
        useCommonAlertSchema?: boolean;
    }

    export interface ActionGroupWebhookReceiverAadAuth {
        /**
         * The identifier uri for aad auth.
         */
        identifierUri: string;
        /**
         * The webhook application object Id for aad auth.
         */
        objectId: string;
        /**
         * The tenant id for aad auth.
         */
        tenantId: string;
    }

    export interface ActionRuleActionGroupCondition {
        /**
         * A `alertContext` block as defined below.
         */
        alertContext?: outputs.monitoring.ActionRuleActionGroupConditionAlertContext;
        /**
         * A `alertRuleId` block as defined below.
         */
        alertRuleId?: outputs.monitoring.ActionRuleActionGroupConditionAlertRuleId;
        /**
         * A `description` block as defined below.
         */
        description?: outputs.monitoring.ActionRuleActionGroupConditionDescription;
        /**
         * A `monitor` block as defined below.
         */
        monitor?: outputs.monitoring.ActionRuleActionGroupConditionMonitor;
        /**
         * A `monitorService` as block defined below.
         */
        monitorService?: outputs.monitoring.ActionRuleActionGroupConditionMonitorService;
        /**
         * A `severity` block as defined below.
         */
        severity?: outputs.monitoring.ActionRuleActionGroupConditionSeverity;
        /**
         * A `targetResourceType` block as defined below.
         */
        targetResourceType?: outputs.monitoring.ActionRuleActionGroupConditionTargetResourceType;
    }

    export interface ActionRuleActionGroupConditionAlertContext {
        /**
         * The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
         */
        operator: string;
        /**
         * A list of values to match for a given condition.
         */
        values: string[];
    }

    export interface ActionRuleActionGroupConditionAlertRuleId {
        /**
         * The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
         */
        operator: string;
        /**
         * A list of values to match for a given condition.
         */
        values: string[];
    }

    export interface ActionRuleActionGroupConditionDescription {
        /**
         * The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
         */
        operator: string;
        /**
         * A list of values to match for a given condition.
         */
        values: string[];
    }

    export interface ActionRuleActionGroupConditionMonitor {
        /**
         * The operator for a given condition. Possible values are `Equals` and `NotEquals`.
         */
        operator: string;
        /**
         * A list of values to match for a given condition. Possible values are `Fired` and `Resolved`.
         */
        values: string[];
    }

    export interface ActionRuleActionGroupConditionMonitorService {
        /**
         * The operator for a given condition. Possible values are `Equals` and `NotEquals`.
         */
        operator: string;
        /**
         * A list of values to match for a given condition. Possible values are `ActivityLog Administrative`, `ActivityLog Autoscale`, `ActivityLog Policy`, `ActivityLog Recommendation`, `ActivityLog Security`, `Application Insights`, `Azure Backup`, `Data Box Edge`, `Data Box Gateway`, `Health Platform`, `Log Analytics`, `Platform`, and `Resource Health`.
         */
        values: string[];
    }

    export interface ActionRuleActionGroupConditionSeverity {
        /**
         * The operator for a given condition. Possible values are `Equals`and `NotEquals`.
         */
        operator: string;
        /**
         * A list of values to match for a given condition. Possible values are `Sev0`, `Sev1`, `Sev2`, `Sev3`, and `Sev4`.
         */
        values: string[];
    }

    export interface ActionRuleActionGroupConditionTargetResourceType {
        /**
         * The operator for a given condition. Possible values are `Equals` and `NotEquals`.
         */
        operator: string;
        /**
         * A list of values to match for a given condition. The values should be valid resource types.
         */
        values: string[];
    }

    export interface ActionRuleActionGroupScope {
        /**
         * A list of resource IDs of the given scope type which will be the target of action rule.
         */
        resourceIds: string[];
        /**
         * Specifies the type of target scope. Possible values are `ResourceGroup` and `Resource`.
         */
        type: string;
    }

    export interface ActionRuleSuppressionCondition {
        /**
         * A `alertContext` block as defined below.
         */
        alertContext?: outputs.monitoring.ActionRuleSuppressionConditionAlertContext;
        /**
         * A `alertRuleId` block as defined below.
         */
        alertRuleId?: outputs.monitoring.ActionRuleSuppressionConditionAlertRuleId;
        /**
         * A `description` block as defined below.
         */
        description?: outputs.monitoring.ActionRuleSuppressionConditionDescription;
        /**
         * A `monitor` block as defined below.
         */
        monitor?: outputs.monitoring.ActionRuleSuppressionConditionMonitor;
        /**
         * A `monitorService` as block defined below.
         */
        monitorService?: outputs.monitoring.ActionRuleSuppressionConditionMonitorService;
        /**
         * A `severity` block as defined below.
         */
        severity?: outputs.monitoring.ActionRuleSuppressionConditionSeverity;
        /**
         * A `targetResourceType` block as defined below.
         */
        targetResourceType?: outputs.monitoring.ActionRuleSuppressionConditionTargetResourceType;
    }

    export interface ActionRuleSuppressionConditionAlertContext {
        /**
         * The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
         */
        operator: string;
        /**
         * A list of values to match for a given condition.
         */
        values: string[];
    }

    export interface ActionRuleSuppressionConditionAlertRuleId {
        /**
         * The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
         */
        operator: string;
        /**
         * A list of values to match for a given condition.
         */
        values: string[];
    }

    export interface ActionRuleSuppressionConditionDescription {
        /**
         * The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
         */
        operator: string;
        /**
         * A list of values to match for a given condition.
         */
        values: string[];
    }

    export interface ActionRuleSuppressionConditionMonitor {
        /**
         * The operator for a given condition. Possible values are `Equals` and `NotEquals`.
         */
        operator: string;
        /**
         * A list of values to match for a given condition. Possible values are `Fired` and `Resolved`.
         */
        values: string[];
    }

    export interface ActionRuleSuppressionConditionMonitorService {
        /**
         * The operator for a given condition. Possible values are `Equals` and `NotEquals`.
         */
        operator: string;
        /**
         * A list of values to match for a given condition. Possible values are `ActivityLog Administrative`, `ActivityLog Autoscale`, `ActivityLog Policy`, `ActivityLog Recommendation`, `ActivityLog Security`, `Application Insights`, `Azure Backup`, `Data Box Edge`, `Data Box Gateway`, `Health Platform`, `Log Analytics`, `Platform`, and `Resource Health`.
         */
        values: string[];
    }

    export interface ActionRuleSuppressionConditionSeverity {
        /**
         * The operator for a given condition. Possible values are `Equals`and `NotEquals`.
         */
        operator: string;
        /**
         * A list of values to match for a given condition. Possible values are `Sev0`, `Sev1`, `Sev2`, `Sev3`, and `Sev4`.
         */
        values: string[];
    }

    export interface ActionRuleSuppressionConditionTargetResourceType {
        /**
         * The operator for a given condition. Possible values are `Equals` and `NotEquals`.
         */
        operator: string;
        /**
         * A list of values to match for a given condition. The values should be valid resource types.
         */
        values: string[];
    }

    export interface ActionRuleSuppressionScope {
        /**
         * A list of resource IDs of the given scope type which will be the target of action rule.
         */
        resourceIds: string[];
        /**
         * Specifies the type of target scope. Possible values are `ResourceGroup` and `Resource`.
         */
        type: string;
    }

    export interface ActionRuleSuppressionSuppression {
        /**
         * Specifies the type of suppression. Possible values are `Always`, `Daily`, `Monthly`, `Once`, and `Weekly`.
         */
        recurrenceType: string;
        /**
         * A `schedule` block as defined below. Required if `recurrenceType` is `Daily`, `Monthly`, `Once` or `Weekly`.
         */
        schedule?: outputs.monitoring.ActionRuleSuppressionSuppressionSchedule;
    }

    export interface ActionRuleSuppressionSuppressionSchedule {
        /**
         * specifies the recurrence UTC end datetime (Y-m-d'T'H:M:S'Z').
         */
        endDateUtc: string;
        /**
         * specifies the list of dayOfMonth to recurrence. Possible values are between `1` - `31`. Required if `recurrenceType` is `Monthly`.
         */
        recurrenceMonthlies?: number[];
        /**
         * specifies the list of dayOfWeek to recurrence. Possible values are `Sunday`, `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday` and  `Saturday`.
         */
        recurrenceWeeklies?: string[];
        /**
         * specifies the recurrence UTC start datetime (Y-m-d'T'H:M:S'Z').
         */
        startDateUtc: string;
    }

    export interface ActivityLogAlertAction {
        /**
         * The ID of the Action Group can be sourced from the `azure.monitoring.ActionGroup` resource.
         */
        actionGroupId: string;
        /**
         * The map of custom string properties to include with the post operation. These data are appended to the webhook payload.
         */
        webhookProperties?: {[key: string]: string};
    }

    export interface ActivityLogAlertCriteria {
        /**
         * The email address or Azure Active Directory identifier of the user who performed the operation.
         */
        caller?: string;
        /**
         * The category of the operation. Possible values are `Administrative`, `Autoscale`, `Policy`, `Recommendation`, `ResourceHealth`, `Security` and `ServiceHealth`.
         */
        category: string;
        /**
         * The severity level of the event. Possible values are `Verbose`, `Informational`, `Warning`, `Error`, and `Critical`.
         */
        level?: string;
        /**
         * The Resource Manager Role-Based Access Control operation name. Supported operation should be of the form: `<resourceProvider>/<resourceType>/<operation>`.
         */
        operationName?: string;
        /**
         * The recommendation category of the event. Possible values are `Cost`, `Reliability`, `OperationalExcellence` and `Performance`. It is only allowed when `category` is `Recommendation`.
         */
        recommendationCategory?: string;
        /**
         * The recommendation impact of the event. Possible values are `High`, `Medium` and `Low`. It is only allowed when `category` is `Recommendation`.
         */
        recommendationImpact?: string;
        /**
         * The recommendation type of the event. It is only allowed when `category` is `Recommendation`.
         */
        recommendationType?: string;
        /**
         * The name of resource group monitored by the activity log alert.
         */
        resourceGroup?: string;
        /**
         * The specific resource monitored by the activity log alert. It should be within one of the `scopes`.
         */
        resourceId?: string;
        /**
         * The name of the resource provider monitored by the activity log alert.
         */
        resourceProvider?: string;
        /**
         * The resource type monitored by the activity log alert.
         */
        resourceType?: string;
        /**
         * A block to define fine grain service health settings.
         */
        serviceHealths: outputs.monitoring.ActivityLogAlertCriteriaServiceHealth[];
        /**
         * The status of the event. For example, `Started`, `Failed`, or `Succeeded`.
         */
        status?: string;
        /**
         * The sub status of the event.
         */
        subStatus?: string;
    }

    export interface ActivityLogAlertCriteriaServiceHealth {
        /**
         * Events this alert will monitor Possible values are `Incident`, `Maintenance`, `Informational`, `ActionRequired` and `Security`.
         */
        events?: string[];
        /**
         * Locations this alert will monitor. For example, `West Europe`. Defaults to `Global`.
         */
        locations?: string[];
        /**
         * Services this alert will monitor. For example, `Activity Logs & Alerts`, `Action Groups`. Defaults to all Services.
         */
        services?: string[];
    }

    export interface AutoscaleSettingNotification {
        /**
         * A `email` block as defined below.
         */
        email?: outputs.monitoring.AutoscaleSettingNotificationEmail;
        /**
         * One or more `webhook` blocks as defined below.
         */
        webhooks?: outputs.monitoring.AutoscaleSettingNotificationWebhook[];
    }

    export interface AutoscaleSettingNotificationEmail {
        /**
         * Specifies a list of custom email addresses to which the email notifications will be sent.
         */
        customEmails?: string[];
        /**
         * Should email notifications be sent to the subscription administrator? Defaults to `false`.
         */
        sendToSubscriptionAdministrator?: boolean;
        /**
         * Should email notifications be sent to the subscription co-administrator? Defaults to `false`.
         */
        sendToSubscriptionCoAdministrator?: boolean;
    }

    export interface AutoscaleSettingNotificationWebhook {
        /**
         * A map of settings.
         */
        properties?: {[key: string]: string};
        /**
         * The HTTPS URI which should receive scale notifications.
         */
        serviceUri: string;
    }

    export interface AutoscaleSettingProfile {
        /**
         * A `capacity` block as defined below.
         */
        capacity: outputs.monitoring.AutoscaleSettingProfileCapacity;
        /**
         * A `fixedDate` block as defined below. This cannot be specified if a `recurrence` block is specified.
         */
        fixedDate?: outputs.monitoring.AutoscaleSettingProfileFixedDate;
        /**
         * Specifies the name of the profile.
         */
        name: string;
        /**
         * A `recurrence` block as defined below. This cannot be specified if a `fixedDate` block is specified.
         */
        recurrence?: outputs.monitoring.AutoscaleSettingProfileRecurrence;
        /**
         * One or more (up to 10) `rule` blocks as defined below.
         */
        rules?: outputs.monitoring.AutoscaleSettingProfileRule[];
    }

    export interface AutoscaleSettingProfileCapacity {
        /**
         * The number of instances that are available for scaling if metrics are not available for evaluation. The default is only used if the current instance count is lower than the default. Valid values are between `0` and `1000`.
         */
        default: number;
        /**
         * The maximum number of instances for this resource. Valid values are between `0` and `1000`.
         */
        maximum: number;
        /**
         * The minimum number of instances for this resource. Valid values are between `0` and `1000`.
         */
        minimum: number;
    }

    export interface AutoscaleSettingProfileFixedDate {
        /**
         * Specifies the end date for the profile, formatted as an RFC3339 date string.
         */
        end: string;
        /**
         * Specifies the start date for the profile, formatted as an RFC3339 date string.
         */
        start: string;
        /**
         * The Time Zone of the `start` and `end` times. A list of [possible values can be found here](https://msdn.microsoft.com/en-us/library/azure/dn931928.aspx). Defaults to `UTC`.
         */
        timezone?: string;
    }

    export interface AutoscaleSettingProfileRecurrence {
        /**
         * A list of days that this profile takes effect on. Possible values include `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday` and `Sunday`.
         */
        days: string[];
        /**
         * A list containing a single item, which specifies the Hour interval at which this recurrence should be triggered (in 24-hour time). Possible values are from `0` to `23`.
         */
        hours: number;
        /**
         * A list containing a single item which specifies the Minute interval at which this recurrence should be triggered.
         */
        minutes: number;
        /**
         * The Time Zone used for the `hours` field. A list of [possible values can be found here](https://msdn.microsoft.com/en-us/library/azure/dn931928.aspx). Defaults to `UTC`.
         */
        timezone?: string;
    }

    export interface AutoscaleSettingProfileRule {
        /**
         * A `metricTrigger` block as defined below.
         */
        metricTrigger: outputs.monitoring.AutoscaleSettingProfileRuleMetricTrigger;
        /**
         * A `scaleAction` block as defined below.
         */
        scaleAction: outputs.monitoring.AutoscaleSettingProfileRuleScaleAction;
    }

    export interface AutoscaleSettingProfileRuleMetricTrigger {
        /**
         * One or more `dimensions` block as defined below.
         */
        dimensions?: outputs.monitoring.AutoscaleSettingProfileRuleMetricTriggerDimension[];
        /**
         * The name of the metric that defines what the rule monitors, such as `Percentage CPU` for `Virtual Machine Scale Sets` and `CpuPercentage` for `App Service Plan`.
         */
        metricName: string;
        /**
         * The namespace of the metric that defines what the rule monitors, such as `microsoft.compute/virtualmachinescalesets` for `Virtual Machine Scale Sets`.
         */
        metricNamespace?: string;
        /**
         * The ID of the Resource which the Rule monitors.
         */
        metricResourceId: string;
        /**
         * Specifies the operator used to compare the metric data and threshold. Possible values are: `Equals`, `NotEquals`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan`, `LessThanOrEqual`.
         */
        operator: string;
        /**
         * Specifies how the metrics from multiple instances are combined. Possible values are `Average`, `Min` and `Max`.
         */
        statistic: string;
        /**
         * Specifies the threshold of the metric that triggers the scale action.
         */
        threshold: number;
        /**
         * Specifies how the data that's collected should be combined over time. Possible values include `Average`, `Count`, `Maximum`, `Minimum`, `Last` and `Total`. Defaults to `Average`.
         */
        timeAggregation: string;
        /**
         * Specifies the granularity of metrics that the rule monitors, which must be one of the pre-defined values returned from the metric definitions for the metric. This value must be between 1 minute and 12 hours an be formatted as an ISO 8601 string.
         */
        timeGrain: string;
        /**
         * Specifies the time range for which data is collected, which must be greater than the delay in metric collection (which varies from resource to resource). This value must be between 5 minutes and 12 hours and be formatted as an ISO 8601 string.
         */
        timeWindow: string;
    }

    export interface AutoscaleSettingProfileRuleMetricTriggerDimension {
        /**
         * The name of the dimension.
         */
        name: string;
        /**
         * The dimension operator. Possible values are `Equals` and `NotEquals`. `Equals` means being equal to any of the values. `NotEquals` means being not equal to any of the values.
         */
        operator: string;
        /**
         * A list of dimension values.
         */
        values: string[];
    }

    export interface AutoscaleSettingProfileRuleScaleAction {
        /**
         * The amount of time to wait since the last scaling action before this action occurs. Must be between 1 minute and 1 week and formatted as a ISO 8601 string.
         */
        cooldown: string;
        /**
         * The scale direction. Possible values are `Increase` and `Decrease`.
         */
        direction: string;
        /**
         * The type of action that should occur. Possible values are `ChangeCount`, `ExactCount` and `PercentChangeCount`.
         */
        type: string;
        /**
         * The number of instances involved in the scaling action. Defaults to `1`.
         */
        value: number;
    }

    export interface DiagnosticSettingLog {
        /**
         * The name of a Diagnostic Log Category for this Resource.
         */
        category: string;
        /**
         * Is this Diagnostic Log enabled? Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * A `retentionPolicy` block as defined below.
         */
        retentionPolicy?: outputs.monitoring.DiagnosticSettingLogRetentionPolicy;
    }

    export interface DiagnosticSettingLogRetentionPolicy {
        /**
         * The number of days for which this Retention Policy should apply.
         */
        days?: number;
        /**
         * Is this Retention Policy enabled?
         */
        enabled: boolean;
    }

    export interface DiagnosticSettingMetric {
        /**
         * The name of a Diagnostic Metric Category for this Resource.
         */
        category: string;
        /**
         * Is this Diagnostic Metric enabled? Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * A `retentionPolicy` block as defined below.
         */
        retentionPolicy?: outputs.monitoring.DiagnosticSettingMetricRetentionPolicy;
    }

    export interface DiagnosticSettingMetricRetentionPolicy {
        /**
         * The number of days for which this Retention Policy should apply.
         */
        days?: number;
        /**
         * Is this Retention Policy enabled?
         */
        enabled: boolean;
    }

    export interface GetActionGroupArmRoleReceiver {
        /**
         * Specifies the name of the Action Group.
         */
        name: string;
        /**
         * The arm role id.
         */
        roleId: string;
        /**
         * Indicates whether to use common alert schema.
         */
        useCommonAlertSchema: boolean;
    }

    export interface GetActionGroupAutomationRunbookReceiver {
        /**
         * The automation account ID which holds this runbook and authenticates to Azure resources.
         */
        automationAccountId: string;
        /**
         * Indicates whether this instance is global runbook.
         */
        isGlobalRunbook: boolean;
        /**
         * Specifies the name of the Action Group.
         */
        name: string;
        /**
         * The name for this runbook.
         */
        runbookName: string;
        /**
         * The URI where webhooks should be sent.
         */
        serviceUri: string;
        /**
         * Indicates whether to use common alert schema.
         */
        useCommonAlertSchema: boolean;
        /**
         * The resource id for webhook linked to this runbook.
         */
        webhookResourceId: string;
    }

    export interface GetActionGroupAzureAppPushReceiver {
        /**
         * The email address of this receiver.
         */
        emailAddress: string;
        /**
         * Specifies the name of the Action Group.
         */
        name: string;
    }

    export interface GetActionGroupAzureFunctionReceiver {
        /**
         * The Azure resource ID of the function app.
         */
        functionAppResourceId: string;
        /**
         * The function name in the function app.
         */
        functionName: string;
        /**
         * The http trigger url where http request sent to.
         */
        httpTriggerUrl: string;
        /**
         * Specifies the name of the Action Group.
         */
        name: string;
        /**
         * Indicates whether to use common alert schema.
         */
        useCommonAlertSchema: boolean;
    }

    export interface GetActionGroupEmailReceiver {
        /**
         * The email address of this receiver.
         */
        emailAddress: string;
        /**
         * Specifies the name of the Action Group.
         */
        name: string;
        /**
         * Indicates whether to use common alert schema.
         */
        useCommonAlertSchema: boolean;
    }

    export interface GetActionGroupItsmReceiver {
        /**
         * The unique connection identifier of the ITSM connection.
         */
        connectionId: string;
        /**
         * Specifies the name of the Action Group.
         */
        name: string;
        /**
         * The region of the workspace.
         */
        region: string;
        /**
         * A JSON blob for the configurations of the ITSM action. CreateMultipleWorkItems option will be part of this blob as well.
         */
        ticketConfiguration: string;
        /**
         * The Azure Log Analytics workspace ID where this connection is defined.
         */
        workspaceId: string;
    }

    export interface GetActionGroupLogicAppReceiver {
        /**
         * The callback url where http request sent to.
         */
        callbackUrl: string;
        /**
         * Specifies the name of the Action Group.
         */
        name: string;
        /**
         * The Azure resource ID of the logic app.
         */
        resourceId: string;
        /**
         * Indicates whether to use common alert schema.
         */
        useCommonAlertSchema: boolean;
    }

    export interface GetActionGroupSmsReceiver {
        /**
         * The country code of the voice receiver.
         */
        countryCode: string;
        /**
         * Specifies the name of the Action Group.
         */
        name: string;
        /**
         * The phone number of the voice receiver.
         */
        phoneNumber: string;
    }

    export interface GetActionGroupVoiceReceiver {
        /**
         * The country code of the voice receiver.
         */
        countryCode: string;
        /**
         * Specifies the name of the Action Group.
         */
        name: string;
        /**
         * The phone number of the voice receiver.
         */
        phoneNumber: string;
    }

    export interface GetActionGroupWebhookReceiver {
        aadAuths: outputs.monitoring.GetActionGroupWebhookReceiverAadAuth[];
        /**
         * Specifies the name of the Action Group.
         */
        name: string;
        /**
         * The URI where webhooks should be sent.
         */
        serviceUri: string;
        /**
         * Indicates whether to use common alert schema.
         */
        useCommonAlertSchema: boolean;
    }

    export interface GetActionGroupWebhookReceiverAadAuth {
        identifierUri: string;
        objectId: string;
        tenantId: string;
    }

    export interface GetLogProfileRetentionPolicy {
        /**
         * The number of days for the retention policy.
         */
        days: number;
        /**
         * A boolean value indicating whether the retention policy is enabled.
         */
        enabled: boolean;
    }

    export interface GetScheduledQueryRulesAlertAction {
        /**
         * List of action group reference resource IDs.
         */
        actionGroups: string[];
        /**
         * Custom payload to be sent for all webhook URI in Azure action group.
         */
        customWebhookPayload: string;
        /**
         * Custom subject override for all email IDs in Azure action group.
         */
        emailSubject: string;
    }

    export interface GetScheduledQueryRulesAlertTrigger {
        metricTriggers: outputs.monitoring.GetScheduledQueryRulesAlertTriggerMetricTrigger[];
        /**
         * Evaluation operation for rule.
         */
        operator: string;
        /**
         * Result or count threshold based on which rule should be triggered.
         */
        threshold: number;
    }

    export interface GetScheduledQueryRulesAlertTriggerMetricTrigger {
        metricColumn: string;
        metricTriggerType: string;
        /**
         * Evaluation operation for rule.
         */
        operator: string;
        /**
         * Result or count threshold based on which rule should be triggered.
         */
        threshold: number;
    }

    export interface GetScheduledQueryRulesLogCriteria {
        /**
         * A `dimension` block as defined below.
         */
        dimensions: outputs.monitoring.GetScheduledQueryRulesLogCriteriaDimension[];
        /**
         * Name of the metric.
         */
        metricName: string;
    }

    export interface GetScheduledQueryRulesLogCriteriaDimension {
        /**
         * Specifies the name of the scheduled query rule.
         */
        name: string;
        /**
         * Operator for dimension values.
         */
        operator: string;
        /**
         * List of dimension values.
         */
        values: string[];
    }

    export interface LogProfileRetentionPolicy {
        /**
         * The number of days for the retention policy. Defaults to 0.
         */
        days?: number;
        /**
         * A boolean value to indicate whether the retention policy is enabled.
         */
        enabled: boolean;
    }

    export interface MetricAlertAction {
        /**
         * The ID of the Action Group can be sourced from the `azure.monitoring.ActionGroup` resource
         */
        actionGroupId: string;
        /**
         * The map of custom string properties to include with the post operation. These data are appended to the webhook payload.
         */
        webhookProperties?: {[key: string]: string};
    }

    export interface MetricAlertApplicationInsightsWebTestLocationAvailabilityCriteria {
        /**
         * The ID of the Application Insights Resource.
         */
        componentId: string;
        /**
         * The number of failed locations.
         */
        failedLocationCount: number;
        /**
         * The ID of the Application Insights Web Test.
         */
        webTestId: string;
    }

    export interface MetricAlertCriteria {
        /**
         * The statistic that runs over the metric values. Possible values are `Average`, `Count`, `Minimum`, `Maximum` and `Total`.
         */
        aggregation: string;
        /**
         * One or more `dimension` blocks as defined below.
         */
        dimensions?: outputs.monitoring.MetricAlertCriteriaDimension[];
        /**
         * One of the metric names to be monitored.
         */
        metricName: string;
        /**
         * One of the metric namespaces to be monitored.
         */
        metricNamespace: string;
        /**
         * The criteria operator. Possible values are `Equals`, `NotEquals`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
         */
        operator: string;
        /**
         * Skip the metric validation to allow creating an alert rule on a custom metric that isn't yet emitted? Defaults to `false`.
         */
        skipMetricValidation?: boolean;
        /**
         * The criteria threshold value that activates the alert.
         */
        threshold: number;
    }

    export interface MetricAlertCriteriaDimension {
        /**
         * One of the dimension names.
         */
        name: string;
        /**
         * The dimension operator. Possible values are `Include`, `Exclude` and `StartsWith`.
         */
        operator: string;
        /**
         * The list of dimension values.
         */
        values: string[];
    }

    export interface MetricAlertDynamicCriteria {
        /**
         * The statistic that runs over the metric values. Possible values are `Average`, `Count`, `Minimum`, `Maximum` and `Total`.
         */
        aggregation: string;
        /**
         * The extent of deviation required to trigger an alert. Possible values are `Low`, `Medium` and `High`.
         */
        alertSensitivity: string;
        /**
         * One or more `dimension` blocks as defined below.
         */
        dimensions?: outputs.monitoring.MetricAlertDynamicCriteriaDimension[];
        /**
         * The number of violations to trigger an alert. Should be smaller or equal to `evaluationTotalCount`.
         */
        evaluationFailureCount?: number;
        /**
         * The number of aggregated lookback points. The lookback time window is calculated based on the aggregation granularity (`windowSize`) and the selected number of aggregated points.
         */
        evaluationTotalCount?: number;
        /**
         * The [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) date from which to start learning the metric historical data and calculate the dynamic thresholds.
         */
        ignoreDataBefore?: string;
        /**
         * One of the metric names to be monitored.
         */
        metricName: string;
        /**
         * One of the metric namespaces to be monitored.
         */
        metricNamespace: string;
        /**
         * The criteria operator. Possible values are `LessThan`, `GreaterThan` and `GreaterOrLessThan`.
         */
        operator: string;
        /**
         * Skip the metric validation to allow creating an alert rule on a custom metric that isn't yet emitted? Defaults to `false`.
         */
        skipMetricValidation?: boolean;
    }

    export interface MetricAlertDynamicCriteriaDimension {
        /**
         * One of the dimension names.
         */
        name: string;
        /**
         * The dimension operator. Possible values are `Include`, `Exclude` and `StartsWith`.
         */
        operator: string;
        /**
         * The list of dimension values.
         */
        values: string[];
    }

    export interface ScheduledQueryRulesAlertAction {
        /**
         * List of action group reference resource IDs.
         */
        actionGroups: string[];
        /**
         * Custom payload to be sent for all webhook payloads in alerting action.
         */
        customWebhookPayload: string;
        /**
         * Custom subject override for all email ids in Azure action group.
         */
        emailSubject?: string;
    }

    export interface ScheduledQueryRulesAlertTrigger {
        /**
         * A `metricTrigger` block as defined above. Trigger condition for metric query rule.
         */
        metricTrigger?: outputs.monitoring.ScheduledQueryRulesAlertTriggerMetricTrigger;
        /**
         * Evaluation operation for rule - 'Equal', 'GreaterThan' or 'LessThan'.
         */
        operator: string;
        /**
         * Result or count threshold based on which rule should be triggered.  Values must be between 0 and 10000 inclusive.
         */
        threshold: number;
    }

    export interface ScheduledQueryRulesAlertTriggerMetricTrigger {
        /**
         * Evaluation of metric on a particular column.
         */
        metricColumn: string;
        /**
         * Metric Trigger Type - 'Consecutive' or 'Total'.
         */
        metricTriggerType: string;
        /**
         * Evaluation operation for rule - 'Equal', 'GreaterThan' or 'LessThan'.
         */
        operator: string;
        /**
         * The threshold of the metric trigger.    Values must be between 0 and 10000 inclusive.
         */
        threshold: number;
    }

    export interface ScheduledQueryRulesLogCriteria {
        /**
         * A `dimension` block as defined below.
         */
        dimensions: outputs.monitoring.ScheduledQueryRulesLogCriteriaDimension[];
        /**
         * Name of the metric.  Supported metrics are listed in the Azure Monitor [Microsoft.OperationalInsights/workspaces](https://docs.microsoft.com/en-us/azure/azure-monitor/platform/metrics-supported#microsoftoperationalinsightsworkspaces) metrics namespace.
         */
        metricName: string;
    }

    export interface ScheduledQueryRulesLogCriteriaDimension {
        /**
         * Name of the dimension.
         */
        name: string;
        /**
         * Operator for dimension values, - 'Include'.
         */
        operator?: string;
        /**
         * List of dimension values.
         */
        values: string[];
    }

    export interface SmartDetectorAlertRuleActionGroup {
        /**
         * Specifies a custom email subject if Email Receiver is specified in Monitor Action Group resource.
         */
        emailSubject?: string;
        /**
         * Specifies the action group ids.
         */
        ids: string[];
        /**
         * A JSON String which Specifies the custom webhook payload if Webhook Receiver is specified in Monitor Action Group resource.
         */
        webhookPayload?: string;
    }

}

export namespace mssql {
    export interface DatabaseExtendedAuditingPolicy {
        logMonitoringEnabled?: boolean;
        /**
         * Specifies the number of days to retain logs for in the storage account.
         */
        retentionInDays?: number;
        /**
         * Specifies the access key to use for the auditing storage account.
         */
        storageAccountAccessKey?: string;
        /**
         * Specifies whether `storageAccountAccessKey` value is the storage's secondary key.
         */
        storageAccountAccessKeyIsSecondary?: boolean;
        /**
         * Specifies the blob storage endpoint (e.g. https://MyAccount.blob.core.windows.net).
         */
        storageEndpoint?: string;
    }

    export interface DatabaseLongTermRetentionPolicy {
        /**
         * The monthly retention policy for an LTR backup in an ISO 8601 format. Valid value is between 1 to 120 months. e.g. `P1Y`, `P1M`, `P4W` or `P30D`.
         */
        monthlyRetention: string;
        /**
         * The week of year to take the yearly backup in an ISO 8601 format. Value has to be between `1` and `52`.
         */
        weekOfYear: number;
        /**
         * The weekly retention policy for an LTR backup in an ISO 8601 format. Valid value is between 1 to 520 weeks. e.g. `P1Y`, `P1M`, `P1W` or `P7D`.
         */
        weeklyRetention: string;
        /**
         * The yearly retention policy for an LTR backup in an ISO 8601 format. Valid value is between 1 to 10 years. e.g. `P1Y`, `P12M`, `P52W` or `P365D`.
         */
        yearlyRetention: string;
    }

    export interface DatabaseShortTermRetentionPolicy {
        /**
         * Point In Time Restore configuration. Value has to be between `7` and `35`.
         */
        retentionDays: number;
    }

    export interface DatabaseThreatDetectionPolicy {
        /**
         * Specifies a list of alerts which should be disabled. Possible values include `Access_Anomaly`, `Sql_Injection` and `Sql_Injection_Vulnerability`.
         */
        disabledAlerts?: string[];
        /**
         * Should the account administrators be emailed when this alert is triggered?
         */
        emailAccountAdmins?: string;
        /**
         * A list of email addresses which alerts should be sent to.
         */
        emailAddresses?: string[];
        /**
         * Specifies the number of days to keep in the Threat Detection audit logs.
         */
        retentionDays?: number;
        /**
         * The State of the Policy. Possible values are `Enabled`, `Disabled` or `New`.
         */
        state?: string;
        /**
         * Specifies the identifier key of the Threat Detection audit storage account. Required if `state` is `Enabled`.
         */
        storageAccountAccessKey?: string;
        /**
         * Specifies the blob storage endpoint (e.g. https://MyAccount.blob.core.windows.net). This blob storage will hold all Threat Detection audit logs. Required if `state` is `Enabled`.
         */
        storageEndpoint?: string;
        /**
         * Should the default server policy be used? Defaults to `Disabled`.
         */
        useServerDefault?: string;
    }

    export interface DatabaseVulnerabilityAssessmentRuleBaselineBaselineResult {
        /**
         * A list representing a result of the baseline.
         */
        results: string[];
    }

    export interface ElasticPoolPerDatabaseSettings {
        /**
         * The maximum capacity any one database can consume.
         */
        maxCapacity: number;
        /**
         * The minimum capacity all databases are guaranteed.
         */
        minCapacity: number;
    }

    export interface ElasticPoolSku {
        /**
         * The scale up/out capacity, representing server's compute units. For more information see the documentation for your Elasticpool configuration: [vCore-based](https://docs.microsoft.com/en-us/azure/sql-database/sql-database-vcore-resource-limits-elastic-pools) or [DTU-based](https://docs.microsoft.com/en-us/azure/sql-database/sql-database-dtu-resource-limits-elastic-pools).
         */
        capacity: number;
        /**
         * The `family` of hardware `Gen4` or `Gen5`.
         */
        family?: string;
        /**
         * Specifies the SKU Name for this Elasticpool. The name of the SKU, will be either `vCore` based `tier` + `family` pattern (e.g. GP_Gen4, BC_Gen5) or the `DTU` based `BasicPool`, `StandardPool`, or `PremiumPool` pattern.
         */
        name: string;
        /**
         * The tier of the particular SKU. Possible values are `GeneralPurpose`, `BusinessCritical`, `Basic`, `Standard`, or `Premium`. For more information see the documentation for your Elasticpool configuration: [vCore-based](https://docs.microsoft.com/en-us/azure/sql-database/sql-database-vcore-resource-limits-elastic-pools) or [DTU-based](https://docs.microsoft.com/en-us/azure/sql-database/sql-database-dtu-resource-limits-elastic-pools).
         */
        tier: string;
    }

    export interface GetServerIdentity {
        /**
         * The Principal ID for the Service Principal associated with the Identity of this SQL Server.
         */
        principalId: string;
        /**
         * The Tenant ID for the Service Principal associated with the Identity of this SQL Server.
         */
        tenantId: string;
        /**
         * The identity type of the Microsoft SQL Server.
         */
        type: string;
    }

    export interface ServerAzureadAdministrator {
        /**
         * (Required)  The login username of the Azure AD Administrator of this SQL Server.
         */
        loginUsername: string;
        /**
         * (Required) The object id of the Azure AD Administrator of this SQL Server.
         */
        objectId: string;
        /**
         * (Optional) The tenant id of the Azure AD Administrator of this SQL Server.
         */
        tenantId: string;
    }

    export interface ServerExtendedAuditingPolicy {
        /**
         * (Optional) Enable audit events to Azure Monitor? To enable server audit events to Azure Monitor, please enable its master database audit events to Azure Monitor.
         */
        logMonitoringEnabled?: boolean;
        /**
         * (Optional) Specifies the number of days to retain logs for in the storage account.
         */
        retentionInDays?: number;
        /**
         * (Optional)  Specifies the access key to use for the auditing storage account.
         */
        storageAccountAccessKey?: string;
        /**
         * (Optional) Specifies whether `storageAccountAccessKey` value is the storage's secondary key.
         */
        storageAccountAccessKeyIsSecondary?: boolean;
        /**
         * (Optional) Specifies the blob storage endpoint (e.g. https://MyAccount.blob.core.windows.net).
         */
        storageEndpoint?: string;
    }

    export interface ServerIdentity {
        /**
         * The Principal ID for the Service Principal associated with the Identity of this SQL Server.
         */
        principalId: string;
        /**
         * (Optional) The tenant id of the Azure AD Administrator of this SQL Server.
         */
        tenantId: string;
        /**
         * Specifies the identity type of the Microsoft SQL Server. At this time the only allowed value is `SystemAssigned`.
         */
        type: string;
    }

    export interface ServerVulnerabilityAssessmentRecurringScans {
        /**
         * Boolean flag which specifies if the schedule scan notification will be sent to the subscription administrators. Defaults to `false`.
         */
        emailSubscriptionAdmins?: boolean;
        /**
         * Specifies an array of e-mail addresses to which the scan notification is sent.
         */
        emails?: string[];
        /**
         * Boolean flag which specifies if recurring scans is enabled or disabled. Defaults to `false`.
         */
        enabled?: boolean;
    }

    export interface VirtualMachineAutoBackup {
        /**
         * Enable or disable encryption for backups. Defaults to `false`.
         */
        encryptionEnabled?: boolean;
        /**
         * Encryption password to use. Must be specified when encryption is enabled.
         */
        encryptionPassword?: string;
        /**
         * A `manualSchedule` block as documented below. When this block is present, the schedule type is set to `Manual`. Without this block, the schedule type is set to `Automated`.
         */
        manualSchedule?: outputs.mssql.VirtualMachineAutoBackupManualSchedule;
        /**
         * Retention period of backups, in days. Valid values are from `1` to `30`.
         */
        retentionPeriodInDays: number;
        /**
         * Access key for the storage account where backups will be kept.
         */
        storageAccountAccessKey: string;
        /**
         * Blob endpoint for the storage account where backups will be kept.
         */
        storageBlobEndpoint: string;
        /**
         * Include or exclude system databases from auto backup. Defaults to `false`.
         */
        systemDatabasesBackupEnabled?: boolean;
    }

    export interface VirtualMachineAutoBackupManualSchedule {
        /**
         * Frequency of full backups. Valid values include `Daily` or `Weekly`. Required when `backupScheduleAutomated` is false.
         */
        fullBackupFrequency: string;
        /**
         * Start hour of a given day during which full backups can take place. Valid values are from `0` to `23`. Required when `backupScheduleAutomated` is false.
         */
        fullBackupStartHour: number;
        /**
         * Duration of the time window of a given day during which full backups can take place, in hours. Valid values are between `1` and `23`. Required when `backupScheduleAutomated` is false.
         */
        fullBackupWindowInHours: number;
        /**
         * Frequency of log backups, in minutes. Valid values are from `5` to `60`. Required when `backupScheduleAutomated` is false.
         */
        logBackupFrequencyInMinutes: number;
    }

    export interface VirtualMachineAutoPatching {
        /**
         * The day of week to apply the patch on.
         */
        dayOfWeek: string;
        /**
         * The size of the Maintenance Window in minutes.
         */
        maintenanceWindowDurationInMinutes: number;
        /**
         * The Hour, in the Virtual Machine Time-Zone when the patching maintenance window should begin.
         */
        maintenanceWindowStartingHour: number;
    }

    export interface VirtualMachineKeyVaultCredential {
        /**
         * The azure Key Vault url. Changing this forces a new resource to be created.
         */
        keyVaultUrl: string;
        /**
         * The credential name.
         */
        name: string;
        /**
         * The service principal name to access key vault. Changing this forces a new resource to be created.
         */
        servicePrincipalName: string;
        /**
         * The service principal name secret to access key vault. Changing this forces a new resource to be created.
         */
        servicePrincipalSecret: string;
    }

    export interface VirtualMachineStorageConfiguration {
        /**
         * An `storageSettings` as defined below.
         */
        dataSettings?: outputs.mssql.VirtualMachineStorageConfigurationDataSettings;
        /**
         * The type of disk configuration to apply to the SQL Server. Valid values include `NEW`, `EXTEND`, or `ADD`.
         */
        diskType: string;
        /**
         * An `storageSettings` as defined below.
         */
        logSettings?: outputs.mssql.VirtualMachineStorageConfigurationLogSettings;
        /**
         * The type of storage workload. Valid values include `GENERAL`, `OLTP`, or `DW`.
         */
        storageWorkloadType: string;
        /**
         * An `storageSettings` as defined below.
         */
        tempDbSettings?: outputs.mssql.VirtualMachineStorageConfigurationTempDbSettings;
    }

    export interface VirtualMachineStorageConfigurationDataSettings {
        /**
         * The SQL Server default path
         */
        defaultFilePath: string;
        /**
         * A list of Logical Unit Numbers for the disks.
         */
        luns: number[];
    }

    export interface VirtualMachineStorageConfigurationLogSettings {
        /**
         * The SQL Server default path
         */
        defaultFilePath: string;
        /**
         * A list of Logical Unit Numbers for the disks.
         */
        luns: number[];
    }

    export interface VirtualMachineStorageConfigurationTempDbSettings {
        /**
         * The SQL Server default path
         */
        defaultFilePath: string;
        /**
         * A list of Logical Unit Numbers for the disks.
         */
        luns: number[];
    }

}

export namespace mysql {
    export interface GetServerIdentity {
        /**
         * The Client ID of the Service Principal assigned to this MySQL Server.
         */
        principalId: string;
        /**
         * The ID of the Tenant the Service Principal is assigned in.
         * ---
         */
        tenantId: string;
        /**
         * The Type of Identity used for this MySQL Server.
         */
        type: string;
    }

    export interface GetServerThreatDetectionPolicy {
        /**
         * Specifies a list of alerts which should be disabled. Possible values include `Access_Anomaly`, `Sql_Injection` and `Sql_Injection_Vulnerability`.
         */
        disabledAlerts: string[];
        /**
         * Should the account administrators be emailed when this alert is triggered?
         */
        emailAccountAdmins: boolean;
        /**
         * A list of email addresses which alerts should be sent to.
         */
        emailAddresses: string[];
        /**
         * Is the policy enabled?
         */
        enabled: boolean;
        /**
         * Specifies the number of days to keep in the Threat Detection audit logs.
         */
        retentionDays: number;
        /**
         * Specifies the identifier key of the Threat Detection audit storage account.
         */
        storageAccountAccessKey: string;
        /**
         * Specifies the blob storage endpoint (e.g. https://MyAccount.blob.core.windows.net). This blob storage will hold all Threat Detection audit logs.
         */
        storageEndpoint: string;
    }

    export interface ServerIdentity {
        /**
         * The Client ID of the Service Principal assigned to this MySQL Server.
         */
        principalId: string;
        /**
         * The ID of the Tenant the Service Principal is assigned in.
         */
        tenantId: string;
        /**
         * The Type of Identity which should be used for this MySQL Server. At this time the only possible value is `SystemAssigned`.
         */
        type: string;
    }

    export interface ServerStorageProfile {
        /**
         * @deprecated this has been moved to the top level boolean attribute `auto_grow_enabled` and will be removed in version 3.0 of the provider.
         */
        autoGrow: string;
        /**
         * Backup retention days for the server, supported values are between `7` and `35` days.
         *
         * @deprecated this has been moved to the top level and will be removed in version 3.0 of the provider.
         */
        backupRetentionDays: number;
        /**
         * @deprecated this has been moved to the top level boolean attribute `geo_redundant_backup_enabled` and will be removed in version 3.0 of the provider.
         */
        geoRedundantBackup: string;
        /**
         * Max storage allowed for a server. Possible values are between `5120` MB(5GB) and `1048576` MB(1TB) for the Basic SKU and between `5120` MB(5GB) and `4194304` MB(4TB) for General Purpose/Memory Optimized SKUs. For more information see the [product documentation](https://docs.microsoft.com/en-us/rest/api/mysql/servers/create#StorageProfile).
         *
         * @deprecated this has been moved to the top level and will be removed in version 3.0 of the provider.
         */
        storageMb?: number;
    }

    export interface ServerThreatDetectionPolicy {
        /**
         * Specifies a list of alerts which should be disabled. Possible values include `Access_Anomaly`, `Sql_Injection` and `Sql_Injection_Vulnerability`.
         */
        disabledAlerts?: string[];
        /**
         * Should the account administrators be emailed when this alert is triggered?
         */
        emailAccountAdmins?: boolean;
        /**
         * A list of email addresses which alerts should be sent to.
         */
        emailAddresses?: string[];
        /**
         * Is the policy enabled?
         */
        enabled?: boolean;
        /**
         * Specifies the number of days to keep in the Threat Detection audit logs.
         */
        retentionDays?: number;
        /**
         * Specifies the identifier key of the Threat Detection audit storage account.
         */
        storageAccountAccessKey?: string;
        /**
         * Specifies the blob storage endpoint (e.g. https://MyAccount.blob.core.windows.net). This blob storage will hold all Threat Detection audit logs.
         */
        storageEndpoint?: string;
    }

}

export namespace netapp {
    export interface AccountActiveDirectory {
        /**
         * A list of DNS server IP addresses for the Active Directory domain. Only allows `IPv4` address.
         */
        dnsServers: string[];
        /**
         * The name of the Active Directory domain.
         */
        domain: string;
        /**
         * The Organizational Unit (OU) within the Active Directory Domain.
         */
        organizationalUnit?: string;
        /**
         * The password associated with the `username`.
         */
        password: string;
        /**
         * The NetBIOS name which should be used for the NetApp SMB Server, which will be registered as a computer account in the AD and used to mount volumes.
         */
        smbServerName: string;
        /**
         * The Username of Active Directory Domain Administrator.
         */
        username: string;
    }

    export interface GetVolumeDataProtectionReplication {
        /**
         * The endpoint type.
         */
        endpointType: string;
        /**
         * Location of the primary volume.
         */
        remoteVolumeLocation: string;
        /**
         * Resource ID of the primary volume.
         */
        remoteVolumeResourceId: string;
        /**
         * Frequency of replication.
         */
        replicationFrequency: string;
        /**
         * @deprecated This property is not in use and will be removed in version 3.0 of the provider. Please use `replication_frequency` instead
         */
        replicationSchedule: string;
    }

    export interface VolumeDataProtectionReplication {
        /**
         * The endpoint type, default value is `dst` for destination.
         */
        endpointType?: string;
        /**
         * Location of the primary volume.
         */
        remoteVolumeLocation: string;
        /**
         * Resource ID of the primary volume.
         */
        remoteVolumeResourceId: string;
        /**
         * Replication frequency, supported values are '10minutes', 'hourly', 'daily', values are case sensitive.
         */
        replicationFrequency: string;
    }

    export interface VolumeExportPolicyRule {
        /**
         * A list of allowed clients IPv4 addresses.
         */
        allowedClients: string[];
        /**
         * Is the CIFS protocol allowed?
         *
         * @deprecated Deprecated in favour of `protocols_enabled`
         */
        cifsEnabled: boolean;
        /**
         * Is the NFSv3 protocol allowed?
         *
         * @deprecated Deprecated in favour of `protocols_enabled`
         */
        nfsv3Enabled: boolean;
        /**
         * Is the NFSv4 protocol allowed?
         *
         * @deprecated Deprecated in favour of `protocols_enabled`
         */
        nfsv4Enabled: boolean;
        /**
         * A list of allowed protocols. Valid values include `CIFS`, `NFSv3`, or `NFSv4.1`. Only one value is supported at this time. This replaces the previous arguments: `cifsEnabled`, `nfsv3Enabled` and `nfsv4Enabled`.
         */
        protocolsEnabled: string;
        /**
         * Is root access permitted to this volume?
         */
        rootAccessEnabled?: boolean;
        /**
         * The index number of the rule.
         */
        ruleIndex: number;
        /**
         * Is the file system on unix read only?
         */
        unixReadOnly?: boolean;
        /**
         * Is the file system on unix read and write?
         */
        unixReadWrite?: boolean;
    }

}

export namespace network {
    export interface ApplicationGatewayAuthenticationCertificate {
        /**
         * The contents of the Authentication Certificate which should be used.
         */
        data: string;
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * The name of the Authentication Certificate.
         */
        name: string;
    }

    export interface ApplicationGatewayAutoscaleConfiguration {
        /**
         * Maximum capacity for autoscaling. Accepted values are in the range `2` to `125`.
         */
        maxCapacity?: number;
        /**
         * Minimum capacity for autoscaling. Accepted values are in the range `0` to `100`.
         */
        minCapacity: number;
    }

    export interface ApplicationGatewayBackendAddressPool {
        /**
         * A list of FQDN's which should be part of the Backend Address Pool.
         */
        fqdns?: string[];
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * A list of IP Addresses which should be part of the Backend Address Pool.
         */
        ipAddresses?: string[];
        /**
         * The name of the Backend Address Pool.
         */
        name: string;
    }

    export interface ApplicationGatewayBackendHttpSetting {
        /**
         * The name of the affinity cookie.
         */
        affinityCookieName?: string;
        /**
         * One or more `authenticationCertificate` blocks.
         */
        authenticationCertificates?: outputs.network.ApplicationGatewayBackendHttpSettingAuthenticationCertificate[];
        /**
         * A `connectionDraining` block as defined below.
         */
        connectionDraining?: outputs.network.ApplicationGatewayBackendHttpSettingConnectionDraining;
        /**
         * Is Cookie-Based Affinity enabled? Possible values are `Enabled` and `Disabled`.
         */
        cookieBasedAffinity: string;
        /**
         * Host header to be sent to the backend servers. Cannot be set if `pickHostNameFromBackendAddress` is set to `true`.
         */
        hostName?: string;
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * The name of the Backend HTTP Settings Collection.
         */
        name: string;
        /**
         * The Path which should be used as a prefix for all HTTP requests.
         */
        path?: string;
        /**
         * Whether host header should be picked from the host name of the backend server. Defaults to `false`.
         */
        pickHostNameFromBackendAddress?: boolean;
        /**
         * The port which should be used for this Backend HTTP Settings Collection.
         */
        port: number;
        /**
         * The ID of the associated Probe.
         */
        probeId: string;
        /**
         * The name of an associated HTTP Probe.
         */
        probeName?: string;
        /**
         * The Protocol which should be used. Possible values are `Http` and `Https`.
         */
        protocol: string;
        /**
         * The request timeout in seconds, which must be between 1 and 86400 seconds.
         */
        requestTimeout?: number;
        /**
         * A list of `trustedRootCertificate` names.
         */
        trustedRootCertificateNames?: string[];
    }

    export interface ApplicationGatewayBackendHttpSettingAuthenticationCertificate {
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * The name of the Authentication Certificate.
         */
        name: string;
    }

    export interface ApplicationGatewayBackendHttpSettingConnectionDraining {
        /**
         * The number of seconds connection draining is active. Acceptable values are from `1` second to `3600` seconds.
         */
        drainTimeoutSec: number;
        /**
         * If connection draining is enabled or not.
         */
        enabled: boolean;
    }

    export interface ApplicationGatewayCustomErrorConfiguration {
        /**
         * Error page URL of the application gateway customer error.
         */
        customErrorPageUrl: string;
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * Status code of the application gateway customer error. Possible values are `HttpStatus403` and `HttpStatus502`
         */
        statusCode: string;
    }

    export interface ApplicationGatewayFrontendIpConfiguration {
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * The name of the Frontend IP Configuration.
         */
        name: string;
        /**
         * The Private IP Address to use for the Application Gateway.
         */
        privateIpAddress: string;
        /**
         * The Allocation Method for the Private IP Address. Possible values are `Dynamic` and `Static`.
         */
        privateIpAddressAllocation: string;
        /**
         * The ID of a Public IP Address which the Application Gateway should use. The allocation method for the Public IP Address depends on the `sku` of this Application Gateway. Please refer to the [Azure documentation for public IP addresses](https://docs.microsoft.com/en-us/azure/virtual-network/public-ip-addresses#application-gateways) for details.
         */
        publicIpAddressId: string;
        /**
         * The ID of the Subnet.
         */
        subnetId: string;
    }

    export interface ApplicationGatewayFrontendPort {
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * The name of the Frontend Port.
         */
        name: string;
        /**
         * The port used for this Frontend Port.
         */
        port: number;
    }

    export interface ApplicationGatewayGatewayIpConfiguration {
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * The Name of this Gateway IP Configuration.
         */
        name: string;
        /**
         * The ID of the Subnet which the Application Gateway should be connected to.
         */
        subnetId: string;
    }

    export interface ApplicationGatewayHttpListener {
        /**
         * One or more `customErrorConfiguration` blocks as defined below.
         */
        customErrorConfigurations?: outputs.network.ApplicationGatewayHttpListenerCustomErrorConfiguration[];
        /**
         * The ID of the Web Application Firewall Policy which should be used as a HTTP Listener.
         */
        firewallPolicyId?: string;
        /**
         * The ID of the associated Frontend Configuration.
         */
        frontendIpConfigurationId: string;
        /**
         * The Name of the Frontend IP Configuration used for this HTTP Listener.
         */
        frontendIpConfigurationName: string;
        /**
         * The ID of the associated Frontend Port.
         */
        frontendPortId: string;
        /**
         * The Name of the Frontend Port use for this HTTP Listener.
         */
        frontendPortName: string;
        /**
         * The Hostname which should be used for this HTTP Listener. Setting this value changes Listener Type to 'Multi site'.
         */
        hostName?: string;
        /**
         * A list of Hostname(s) should be used for this HTTP Listener. It allows special wildcard characters.
         */
        hostNames?: string[];
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * The Name of the HTTP Listener.
         */
        name: string;
        /**
         * The Protocol to use for this HTTP Listener. Possible values are `Http` and `Https`.
         */
        protocol: string;
        /**
         * Should Server Name Indication be Required? Defaults to `false`.
         */
        requireSni?: boolean;
        /**
         * The ID of the associated SSL Certificate.
         */
        sslCertificateId: string;
        /**
         * The name of the associated SSL Certificate which should be used for this HTTP Listener.
         */
        sslCertificateName?: string;
    }

    export interface ApplicationGatewayHttpListenerCustomErrorConfiguration {
        /**
         * Error page URL of the application gateway customer error.
         */
        customErrorPageUrl: string;
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * Status code of the application gateway customer error. Possible values are `HttpStatus403` and `HttpStatus502`
         */
        statusCode: string;
    }

    export interface ApplicationGatewayIdentity {
        /**
         * Specifies a list with a single user managed identity id to be assigned to the Application Gateway.
         */
        identityIds: string;
        /**
         * The Managed Service Identity Type of this Application Gateway. The only possible value is `UserAssigned`. Defaults to `UserAssigned`.
         */
        type?: string;
    }

    export interface ApplicationGatewayProbe {
        /**
         * The Hostname used for this Probe. If the Application Gateway is configured for a single site, by default the Host name should be specified as ‘127.0.0.1’, unless otherwise configured in custom probe. Cannot be set if `pickHostNameFromBackendHttpSettings` is set to `true`.
         */
        host?: string;
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * The Interval between two consecutive probes in seconds. Possible values range from 1 second to a maximum of 86,400 seconds.
         */
        interval: number;
        /**
         * A `match` block as defined above.
         */
        match: outputs.network.ApplicationGatewayProbeMatch;
        /**
         * The minimum number of servers that are always marked as healthy. Defaults to `0`.
         */
        minimumServers?: number;
        /**
         * The Name of the Probe.
         */
        name: string;
        /**
         * The Path used for this Probe.
         */
        path: string;
        /**
         * Whether the host header should be picked from the backend http settings. Defaults to `false`.
         */
        pickHostNameFromBackendHttpSettings?: boolean;
        /**
         * Custom port which will be used for probing the backend servers. The valid value ranges from 1 to 65535. In case not set, port from http settings will be used. This property is valid for Standard_v2 and WAF_v2 only.
         */
        port?: number;
        /**
         * The Protocol used for this Probe. Possible values are `Http` and `Https`.
         */
        protocol: string;
        /**
         * The Timeout used for this Probe, which indicates when a probe becomes unhealthy. Possible values range from 1 second to a maximum of 86,400 seconds.
         */
        timeout: number;
        /**
         * The Unhealthy Threshold for this Probe, which indicates the amount of retries which should be attempted before a node is deemed unhealthy. Possible values are from 1 - 20 seconds.
         */
        unhealthyThreshold: number;
    }

    export interface ApplicationGatewayProbeMatch {
        /**
         * A snippet from the Response Body which must be present in the Response..
         */
        body?: string;
        /**
         * A list of allowed status codes for this Health Probe.
         */
        statusCodes?: string[];
    }

    export interface ApplicationGatewayRedirectConfiguration {
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * Whether or not to include the path in the redirected Url. Defaults to `false`
         */
        includePath?: boolean;
        /**
         * Whether or not to include the query string in the redirected Url. Default to `false`
         */
        includeQueryString?: boolean;
        /**
         * Unique name of the redirect configuration block
         */
        name: string;
        /**
         * The type of redirect. Possible values are `Permanent`, `Temporary`, `Found` and `SeeOther`
         */
        redirectType: string;
        targetListenerId: string;
        /**
         * The name of the listener to redirect to. Cannot be set if `targetUrl` is set.
         */
        targetListenerName?: string;
        /**
         * The Url to redirect the request to. Cannot be set if `targetListenerName` is set.
         */
        targetUrl?: string;
    }

    export interface ApplicationGatewayRequestRoutingRule {
        /**
         * The ID of the associated Backend Address Pool.
         */
        backendAddressPoolId: string;
        /**
         * The Name of the Backend Address Pool which should be used for this Routing Rule. Cannot be set if `redirectConfigurationName` is set.
         */
        backendAddressPoolName?: string;
        /**
         * The ID of the associated Backend HTTP Settings Configuration.
         */
        backendHttpSettingsId: string;
        /**
         * The Name of the Backend HTTP Settings Collection which should be used for this Routing Rule. Cannot be set if `redirectConfigurationName` is set.
         */
        backendHttpSettingsName?: string;
        /**
         * The ID of the associated HTTP Listener.
         */
        httpListenerId: string;
        /**
         * The Name of the HTTP Listener which should be used for this Routing Rule.
         */
        httpListenerName: string;
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * The Name of this Request Routing Rule.
         */
        name: string;
        /**
         * The ID of the associated Redirect Configuration.
         */
        redirectConfigurationId: string;
        /**
         * The Name of the Redirect Configuration which should be used for this Routing Rule. Cannot be set if either `backendAddressPoolName` or `backendHttpSettingsName` is set.
         */
        redirectConfigurationName?: string;
        /**
         * The ID of the associated Rewrite Rule Set.
         */
        rewriteRuleSetId: string;
        /**
         * The Name of the Rewrite Rule Set which should be used for this Routing Rule. Only valid for v2 SKUs.
         */
        rewriteRuleSetName?: string;
        /**
         * The Type of Routing that should be used for this Rule. Possible values are `Basic` and `PathBasedRouting`.
         */
        ruleType: string;
        /**
         * The ID of the associated URL Path Map.
         */
        urlPathMapId: string;
        /**
         * The Name of the URL Path Map which should be associated with this Routing Rule.
         */
        urlPathMapName?: string;
    }

    export interface ApplicationGatewayRewriteRuleSet {
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * Unique name of the rewrite rule set block
         */
        name: string;
        /**
         * One or more `rewriteRule` blocks as defined above.
         */
        rewriteRules?: outputs.network.ApplicationGatewayRewriteRuleSetRewriteRule[];
    }

    export interface ApplicationGatewayRewriteRuleSetRewriteRule {
        /**
         * One or more `condition` blocks as defined above.
         */
        conditions?: outputs.network.ApplicationGatewayRewriteRuleSetRewriteRuleCondition[];
        /**
         * Unique name of the rewrite rule block
         */
        name: string;
        /**
         * One or more `requestHeaderConfiguration` blocks as defined above.
         */
        requestHeaderConfigurations?: outputs.network.ApplicationGatewayRewriteRuleSetRewriteRuleRequestHeaderConfiguration[];
        /**
         * One or more `responseHeaderConfiguration` blocks as defined above.
         */
        responseHeaderConfigurations?: outputs.network.ApplicationGatewayRewriteRuleSetRewriteRuleResponseHeaderConfiguration[];
        /**
         * Rule sequence of the rewrite rule that determines the order of execution in a set.
         */
        ruleSequence: number;
        /**
         * One `url` block as defined above
         */
        url?: outputs.network.ApplicationGatewayRewriteRuleSetRewriteRuleUrl;
    }

    export interface ApplicationGatewayRewriteRuleSetRewriteRuleCondition {
        /**
         * Perform a case in-sensitive comparison. Defaults to `false`
         */
        ignoreCase?: boolean;
        /**
         * Negate the result of the condition evaluation. Defaults to `false`
         */
        negate?: boolean;
        /**
         * The pattern, either fixed string or regular expression, that evaluates the truthfulness of the condition.
         */
        pattern: string;
        /**
         * The [variable](https://docs.microsoft.com/en-us/azure/application-gateway/rewrite-http-headers#server-variables) of the condition.
         */
        variable: string;
    }

    export interface ApplicationGatewayRewriteRuleSetRewriteRuleRequestHeaderConfiguration {
        /**
         * Header name of the header configuration.
         */
        headerName: string;
        /**
         * Header value of the header configuration. To delete a request header set this property to an empty string.
         */
        headerValue: string;
    }

    export interface ApplicationGatewayRewriteRuleSetRewriteRuleResponseHeaderConfiguration {
        /**
         * Header name of the header configuration.
         */
        headerName: string;
        /**
         * Header value of the header configuration. To delete a response header set this property to an empty string.
         */
        headerValue: string;
    }

    export interface ApplicationGatewayRewriteRuleSetRewriteRuleUrl {
        /**
         * The URL path to rewrite.
         */
        path?: string;
        /**
         * The query string to rewrite.
         */
        queryString?: string;
        /**
         * Whether the URL path map should be reevaluated after this rewrite has been applied. [More info on rewrite configutation](https://docs.microsoft.com/en-us/azure/application-gateway/rewrite-http-headers-url#rewrite-configuration)
         */
        reroute?: boolean;
    }

    export interface ApplicationGatewaySku {
        /**
         * The Capacity of the SKU to use for this Application Gateway. When using a V1 SKU this value must be between 1 and 32, and 1 to 125 for a V2 SKU. This property is optional if `autoscaleConfiguration` is set.
         */
        capacity?: number;
        /**
         * The Name of the SKU to use for this Application Gateway. Possible values are `Standard_Small`, `Standard_Medium`, `Standard_Large`, `Standard_v2`, `WAF_Medium`, `WAF_Large`, and `WAF_v2`.
         */
        name: string;
        /**
         * The Tier of the SKU to use for this Application Gateway. Possible values are `Standard`, `Standard_v2`, `WAF` and `WAF_v2`.
         */
        tier: string;
    }

    export interface ApplicationGatewaySslCertificate {
        /**
         * PFX certificate. Required if `keyVaultSecretId` is not set.
         */
        data?: string;
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * Secret Id of (base-64 encoded unencrypted pfx) `Secret` or `Certificate` object stored in Azure KeyVault. You need to enable soft delete for keyvault to use this feature. Required if `data` is not set.
         */
        keyVaultSecretId?: string;
        /**
         * The Name of the SSL certificate that is unique within this Application Gateway
         */
        name: string;
        /**
         * Password for the pfx file specified in data.  Required if `data` is set.
         */
        password?: string;
        /**
         * The Public Certificate Data associated with the SSL Certificate.
         */
        publicCertData: string;
    }

    export interface ApplicationGatewaySslPolicy {
        /**
         * A List of accepted cipher suites. Possible values are: `TLS_DHE_DSS_WITH_AES_128_CBC_SHA`, `TLS_DHE_DSS_WITH_AES_128_CBC_SHA256`, `TLS_DHE_DSS_WITH_AES_256_CBC_SHA`, `TLS_DHE_DSS_WITH_AES_256_CBC_SHA256`, `TLS_DHE_RSA_WITH_AES_128_CBC_SHA`, `TLS_DHE_RSA_WITH_AES_128_GCM_SHA256`, `TLS_DHE_RSA_WITH_AES_256_CBC_SHA`, `TLS_DHE_RSA_WITH_AES_256_GCM_SHA384`, `TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA`, `TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256`, `TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256`, `TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA`, `TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384`, `TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384`, `TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA`, `TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256`, `TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA`, `TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384`, `TLS_RSA_WITH_3DES_EDE_CBC_SHA`, `TLS_RSA_WITH_AES_128_CBC_SHA`, `TLS_RSA_WITH_AES_128_CBC_SHA256`, `TLS_RSA_WITH_AES_128_GCM_SHA256`, `TLS_RSA_WITH_AES_256_CBC_SHA`, `TLS_RSA_WITH_AES_256_CBC_SHA256` and `TLS_RSA_WITH_AES_256_GCM_SHA384`.
         */
        cipherSuites?: string[];
        /**
         * A list of SSL Protocols which should be disabled on this Application Gateway. Possible values are `TLSv1_0`, `TLSv1_1` and `TLSv1_2`.
         */
        disabledProtocols?: string[];
        /**
         * The minimal TLS version. Possible values are `TLSv1_0`, `TLSv1_1` and `TLSv1_2`.
         */
        minProtocolVersion?: string;
        /**
         * The Name of the Policy e.g AppGwSslPolicy20170401S. Required if `policyType` is set to `Predefined`. Possible values can change over time and
         * are published here https://docs.microsoft.com/en-us/azure/application-gateway/application-gateway-ssl-policy-overview. Not compatible with `disabledProtocols`.
         */
        policyName?: string;
        /**
         * The Type of the Policy. Possible values are `Predefined` and `Custom`.
         */
        policyType?: string;
    }

    export interface ApplicationGatewayTrustedRootCertificate {
        /**
         * The contents of the Trusted Root Certificate which should be used.
         */
        data: string;
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * The Name of the Trusted Root Certificate to use.
         */
        name: string;
    }

    export interface ApplicationGatewayUrlPathMap {
        /**
         * The ID of the Default Backend Address Pool.
         */
        defaultBackendAddressPoolId: string;
        /**
         * The Name of the Default Backend Address Pool which should be used for this URL Path Map. Cannot be set if `defaultRedirectConfigurationName` is set.
         */
        defaultBackendAddressPoolName?: string;
        /**
         * The ID of the Default Backend HTTP Settings Collection.
         */
        defaultBackendHttpSettingsId: string;
        /**
         * The Name of the Default Backend HTTP Settings Collection which should be used for this URL Path Map. Cannot be set if `defaultRedirectConfigurationName` is set.
         */
        defaultBackendHttpSettingsName?: string;
        /**
         * The ID of the Default Redirect Configuration.
         */
        defaultRedirectConfigurationId: string;
        /**
         * The Name of the Default Redirect Configuration which should be used for this URL Path Map. Cannot be set if either `defaultBackendAddressPoolName` or `defaultBackendHttpSettingsName` is set.
         */
        defaultRedirectConfigurationName?: string;
        defaultRewriteRuleSetId: string;
        /**
         * The Name of the Default Rewrite Rule Set which should be used for this URL Path Map. Only valid for v2 SKUs.
         */
        defaultRewriteRuleSetName?: string;
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * The Name of the URL Path Map.
         */
        name: string;
        /**
         * One or more `pathRule` blocks as defined above.
         */
        pathRules: outputs.network.ApplicationGatewayUrlPathMapPathRule[];
    }

    export interface ApplicationGatewayUrlPathMapPathRule {
        /**
         * The ID of the associated Backend Address Pool.
         */
        backendAddressPoolId: string;
        /**
         * The Name of the Backend Address Pool to use for this Path Rule. Cannot be set if `redirectConfigurationName` is set.
         */
        backendAddressPoolName?: string;
        /**
         * The ID of the associated Backend HTTP Settings Configuration.
         */
        backendHttpSettingsId: string;
        /**
         * The Name of the Backend HTTP Settings Collection to use for this Path Rule. Cannot be set if `redirectConfigurationName` is set.
         */
        backendHttpSettingsName?: string;
        /**
         * The ID of the Web Application Firewall Policy which should be used as a HTTP Listener.
         */
        firewallPolicyId?: string;
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * The Name of the Path Rule.
         */
        name: string;
        /**
         * A list of Paths used in this Path Rule.
         */
        paths: string[];
        /**
         * The ID of the associated Redirect Configuration.
         */
        redirectConfigurationId: string;
        /**
         * The Name of a Redirect Configuration to use for this Path Rule. Cannot be set if `backendAddressPoolName` or `backendHttpSettingsName` is set.
         */
        redirectConfigurationName?: string;
        /**
         * The ID of the associated Rewrite Rule Set.
         */
        rewriteRuleSetId: string;
        /**
         * The Name of the Rewrite Rule Set which should be used for this URL Path Map. Only valid for v2 SKUs.
         */
        rewriteRuleSetName?: string;
    }

    export interface ApplicationGatewayWafConfiguration {
        /**
         * one or more `disabledRuleGroup` blocks as defined below.
         */
        disabledRuleGroups?: outputs.network.ApplicationGatewayWafConfigurationDisabledRuleGroup[];
        /**
         * Is the Web Application Firewall be enabled?
         */
        enabled: boolean;
        /**
         * one or more `exclusion` blocks as defined below.
         */
        exclusions?: outputs.network.ApplicationGatewayWafConfigurationExclusion[];
        /**
         * The File Upload Limit in MB. Accepted values are in the range `1`MB to `750`MB for the `WAF_v2` SKU, and `1`MB to `500`MB for all other SKUs. Defaults to `100`MB.
         */
        fileUploadLimitMb?: number;
        /**
         * The Web Application Firewall Mode. Possible values are `Detection` and `Prevention`.
         */
        firewallMode: string;
        /**
         * The Maximum Request Body Size in KB.  Accepted values are in the range `1`KB to `128`KB.  Defaults to `128`KB.
         */
        maxRequestBodySizeKb?: number;
        /**
         * Is Request Body Inspection enabled?  Defaults to `true`.
         */
        requestBodyCheck?: boolean;
        /**
         * The Type of the Rule Set used for this Web Application Firewall. Currently, only `OWASP` is supported.
         */
        ruleSetType?: string;
        /**
         * The Version of the Rule Set used for this Web Application Firewall. Possible values are `2.2.9`, `3.0`, and `3.1`.
         */
        ruleSetVersion: string;
    }

    export interface ApplicationGatewayWafConfigurationDisabledRuleGroup {
        /**
         * The rule group where specific rules should be disabled. Accepted values are:  `crs20ProtocolViolations`, `crs21ProtocolAnomalies`, `crs23RequestLimits`, `crs30HttpPolicy`, `crs35BadRobots`, `crs40GenericAttacks`, `crs41SqlInjectionAttacks`, `crs41XssAttacks`, `crs42TightSecurity`, `crs45Trojans`, `General`, `REQUEST-911-METHOD-ENFORCEMENT`, `REQUEST-913-SCANNER-DETECTION`, `REQUEST-920-PROTOCOL-ENFORCEMENT`, `REQUEST-921-PROTOCOL-ATTACK`, `REQUEST-930-APPLICATION-ATTACK-LFI`, `REQUEST-931-APPLICATION-ATTACK-RFI`, `REQUEST-932-APPLICATION-ATTACK-RCE`, `REQUEST-933-APPLICATION-ATTACK-PHP`, `REQUEST-941-APPLICATION-ATTACK-XSS`, `REQUEST-942-APPLICATION-ATTACK-SQLI`, `REQUEST-943-APPLICATION-ATTACK-SESSION-FIXATION`
         */
        ruleGroupName: string;
        /**
         * A list of rules which should be disabled in that group. Disables all rules in the specified group if `rules` is not specified.
         */
        rules?: number[];
    }

    export interface ApplicationGatewayWafConfigurationExclusion {
        /**
         * Match variable of the exclusion rule to exclude header, cookie or GET arguments. Possible values are `RequestHeaderNames`, `RequestArgNames` and `RequestCookieNames`
         */
        matchVariable: string;
        /**
         * String value which will be used for the filter operation. If empty will exclude all traffic on this `matchVariable`
         */
        selector?: string;
        /**
         * Operator which will be used to search in the variable content. Possible values are `Equals`, `StartsWith`, `EndsWith`, `Contains`. If empty will exclude all traffic on this `matchVariable`
         */
        selectorMatchOperator?: string;
    }

    export interface ExpressRouteCircuitPeeringIpv6 {
        /**
         * A `microsoftPeering` block as defined below.
         */
        microsoftPeering: outputs.network.ExpressRouteCircuitPeeringIpv6MicrosoftPeering;
        /**
         * A subnet for the primary link.
         */
        primaryPeerAddressPrefix: string;
        /**
         * The ID of the Route Filter. Only available when `peeringType` is set to `MicrosoftPeering`.
         */
        routeFilterId?: string;
        /**
         * A subnet for the secondary link.
         */
        secondaryPeerAddressPrefix: string;
    }

    export interface ExpressRouteCircuitPeeringIpv6MicrosoftPeering {
        /**
         * A list of Advertised Public Prefixes.
         */
        advertisedPublicPrefixes?: string[];
        /**
         * The CustomerASN of the peering.
         */
        customerAsn?: number;
        /**
         * The Routing Registry against which the AS number and prefixes are registered. For example:  `ARIN`, `RIPE`, `AFRINIC` etc.
         */
        routingRegistryName?: string;
    }

    export interface ExpressRouteCircuitPeeringMicrosoftPeeringConfig {
        /**
         * A list of Advertised Public Prefixes.
         */
        advertisedPublicPrefixes: string[];
        /**
         * The CustomerASN of the peering.
         */
        customerAsn?: number;
        /**
         * The Routing Registry against which the AS number and prefixes are registered. For example:  `ARIN`, `RIPE`, `AFRINIC` etc.
         */
        routingRegistryName?: string;
    }

    export interface ExpressRouteCircuitSku {
        /**
         * The billing mode for bandwidth. Possible values are `MeteredData` or `UnlimitedData`.
         */
        family: string;
        /**
         * The service tier. Possible values are `Basic`, `Local`, `Standard` or `Premium`.
         */
        tier: string;
    }

    export interface ExpressRouteConnectionRouting {
        /**
         * The ID of the Virtual Hub Route Table associated with this Express Route Connection.
         */
        associatedRouteTableId: string;
        /**
         * A `propagatedRouteTable` block as defined below.
         */
        propagatedRouteTable: outputs.network.ExpressRouteConnectionRoutingPropagatedRouteTable;
    }

    export interface ExpressRouteConnectionRoutingPropagatedRouteTable {
        /**
         * The list of labels to logically group route tables.
         */
        labels: string[];
        /**
         * A list of IDs of the Virtual Hub Route Table to propagate routes from Express Route Connection to the route table.
         */
        routeTableIds: string[];
    }

    export interface ExpressRoutePortIdentity {
        /**
         * Specifies a list with a single user managed identity id to be assigned to the Express Route Port. Currently, exactly one id is allowed to specify.
         */
        identityIds?: string[];
        /**
         * The type of the identity used for the Express Route Port. Currently, the only possible values is `UserAssigned`.
         */
        type: string;
    }

    export interface ExpressRoutePortLink1 {
        /**
         * Whether enable administration state on the Express Route Port Link? Defaults to `false`.
         */
        adminEnabled?: boolean;
        /**
         * The connector type of the Express Route Port Link.
         */
        connectorType: string;
        /**
         * The ID of this Express Route Port Link.
         */
        id: string;
        /**
         * The interface name of the Azure router associated with the Express Route Port Link.
         */
        interfaceName: string;
        /**
         * The ID of the Key Vault Secret that contains the Mac security CAK key for this Express Route Port Link.
         */
        macsecCakKeyvaultSecretId?: string;
        /**
         * The MACSec cipher used for this Express Route Port Link. Possible values are `GcmAes128` and `GcmAes256`. Defaults to `GcmAes128`.
         */
        macsecCipher?: string;
        /**
         * The ID of the Key Vault Secret that contains the MACSec CKN key for this Express Route Port Link.
         */
        macsecCknKeyvaultSecretId?: string;
        /**
         * The ID that maps from the Express Route Port Link to the patch panel port.
         */
        patchPanelId: string;
        /**
         * The ID that maps from the patch panel port to the rack.
         */
        rackId: string;
        /**
         * The name of the Azure router associated with the Express Route Port Link.
         */
        routerName: string;
    }

    export interface ExpressRoutePortLink2 {
        /**
         * Whether enable administration state on the Express Route Port Link? Defaults to `false`.
         */
        adminEnabled?: boolean;
        /**
         * The connector type of the Express Route Port Link.
         */
        connectorType: string;
        /**
         * The ID of this Express Route Port Link.
         */
        id: string;
        /**
         * The interface name of the Azure router associated with the Express Route Port Link.
         */
        interfaceName: string;
        /**
         * The ID of the Key Vault Secret that contains the Mac security CAK key for this Express Route Port Link.
         */
        macsecCakKeyvaultSecretId?: string;
        /**
         * The MACSec cipher used for this Express Route Port Link. Possible values are `GcmAes128` and `GcmAes256`. Defaults to `GcmAes128`.
         */
        macsecCipher?: string;
        /**
         * The ID of the Key Vault Secret that contains the MACSec CKN key for this Express Route Port Link.
         */
        macsecCknKeyvaultSecretId?: string;
        /**
         * The ID that maps from the Express Route Port Link to the patch panel port.
         */
        patchPanelId: string;
        /**
         * The ID that maps from the patch panel port to the rack.
         */
        rackId: string;
        /**
         * The name of the Azure router associated with the Express Route Port Link.
         */
        routerName: string;
    }

    export interface FirewallApplicationRuleCollectionRule {
        /**
         * Specifies a description for the rule.
         */
        description?: string;
        /**
         * A list of FQDN tags. Possible values are `AppServiceEnvironment`, `AzureBackup`, `AzureKubernetesService`, `HDInsight`, `MicrosoftActiveProtectionService`, `WindowsDiagnostics`, `WindowsUpdate` and `WindowsVirtualDesktop`.
         */
        fqdnTags?: string[];
        /**
         * Specifies the name of the rule.
         */
        name: string;
        /**
         * One or more `protocol` blocks as defined below.
         */
        protocols?: outputs.network.FirewallApplicationRuleCollectionRuleProtocol[];
        /**
         * A list of source IP addresses and/or IP ranges.
         */
        sourceAddresses?: string[];
        /**
         * A list of source IP Group IDs for the rule.
         */
        sourceIpGroups?: string[];
        /**
         * A list of FQDNs.
         */
        targetFqdns?: string[];
    }

    export interface FirewallApplicationRuleCollectionRuleProtocol {
        /**
         * Specify a port for the connection.
         */
        port?: number;
        /**
         * Specifies the type of connection. Possible values are `Http`, `Https` and `Mssql`.
         */
        type: string;
    }

    export interface FirewallIpConfiguration {
        /**
         * Specifies the name of the IP Configuration.
         */
        name: string;
        /**
         * The private IP address associated with the Firewall.
         */
        privateIpAddress: string;
        /**
         * The ID of the Public IP Address associated with the firewall.
         */
        publicIpAddressId: string;
        /**
         * Reference to the subnet associated with the IP Configuration.
         */
        subnetId?: string;
    }

    export interface FirewallManagementIpConfiguration {
        /**
         * Specifies the name of the IP Configuration.
         */
        name: string;
        /**
         * The private IP address associated with the Firewall.
         */
        privateIpAddress: string;
        /**
         * The ID of the Public IP Address associated with the firewall.
         */
        publicIpAddressId: string;
        /**
         * Reference to the subnet associated with the IP Configuration. Changing this forces a new resource to be created.
         */
        subnetId: string;
    }

    export interface FirewallNatRuleCollectionRule {
        /**
         * Specifies a description for the rule.
         */
        description?: string;
        /**
         * A list of destination IP addresses and/or IP ranges.
         */
        destinationAddresses: string[];
        /**
         * A list of destination ports.
         */
        destinationPorts: string[];
        /**
         * Specifies the name of the rule.
         */
        name: string;
        /**
         * A list of protocols. Possible values are `Any`, `ICMP`, `TCP` and `UDP`.  If `action` is `Dnat`, protocols can only be `TCP` and `UDP`.
         */
        protocols: string[];
        /**
         * A list of source IP addresses and/or IP ranges.
         */
        sourceAddresses?: string[];
        /**
         * A list of source IP Group IDs for the rule.
         */
        sourceIpGroups?: string[];
        /**
         * The address of the service behind the Firewall.
         */
        translatedAddress: string;
        /**
         * The port of the service behind the Firewall.
         */
        translatedPort: string;
    }

    export interface FirewallNetworkRuleCollectionRule {
        /**
         * Specifies a description for the rule.
         */
        description?: string;
        /**
         * Either a list of destination IP addresses and/or IP ranges, or a list of destination [Service Tags](https://docs.microsoft.com/en-us/azure/virtual-network/service-tags-overview#available-service-tags).
         */
        destinationAddresses?: string[];
        /**
         * A list of destination FQDNS for the rule.
         */
        destinationFqdns?: string[];
        /**
         * A list of destination IP Group IDs for the rule.
         */
        destinationIpGroups?: string[];
        /**
         * A list of destination ports.
         */
        destinationPorts: string[];
        /**
         * Specifies the name of the rule.
         */
        name: string;
        /**
         * A list of protocols. Possible values are `Any`, `ICMP`, `TCP` and `UDP`.
         */
        protocols: string[];
        /**
         * A list of source IP addresses and/or IP ranges.
         */
        sourceAddresses?: string[];
        /**
         * A list of IP Group IDs for the rule.
         */
        sourceIpGroups?: string[];
    }

    export interface FirewallPolicyDns {
        /**
         * @deprecated This property has been deprecated as the service team has removed it from all API versions and is no longer supported by Azure. It will be removed in v3.0 of the provider.
         */
        networkRuleFqdnEnabled: boolean;
        /**
         * Whether to enable DNS proxy on Firewalls attached to this Firewall Policy? Defaults to `false`.
         */
        proxyEnabled?: boolean;
        /**
         * A list of custom DNS servers' IP addresses.
         */
        servers?: string[];
    }

    export interface FirewallPolicyRuleCollectionGroupApplicationRuleCollection {
        /**
         * The action to take for the application rules in this collection. Possible values are `Allow` and `Deny`.
         */
        action: string;
        /**
         * The name which should be used for this application rule collection.
         */
        name: string;
        /**
         * The priority of the application rule collection. The range is `100` - `65000`.
         */
        priority: number;
        /**
         * One or more `rule` (application rule) blocks as defined below.
         */
        rules: outputs.network.FirewallPolicyRuleCollectionGroupApplicationRuleCollectionRule[];
    }

    export interface FirewallPolicyRuleCollectionGroupApplicationRuleCollectionRule {
        /**
         * Specifies a list of destination FQDN tags.
         */
        destinationFqdnTags?: string[];
        /**
         * Specifies a list of destination FQDNs.
         */
        destinationFqdns?: string[];
        /**
         * The name which should be used for this rule.
         */
        name: string;
        /**
         * Specifies a list of network protocols this rule applies to. Possible values are `TCP`, `UDP`.
         */
        protocols: outputs.network.FirewallPolicyRuleCollectionGroupApplicationRuleCollectionRuleProtocol[];
        /**
         * Specifies a list of source IP addresses (including CIDR and `*`).
         */
        sourceAddresses?: string[];
        /**
         * Specifies a list of source IP groups.
         */
        sourceIpGroups?: string[];
    }

    export interface FirewallPolicyRuleCollectionGroupApplicationRuleCollectionRuleProtocol {
        /**
         * Port number of the protocol. Range is 0-64000.
         */
        port: number;
        /**
         * Protocol type. Possible values are `Http` and `Https`.
         */
        type: string;
    }

    export interface FirewallPolicyRuleCollectionGroupNatRuleCollection {
        /**
         * The action to take for the nat rules in this collection. Currently, the only possible value is `Dnat`.
         */
        action: string;
        /**
         * The name which should be used for this nat rule collection.
         */
        name: string;
        /**
         * The priority of the nat rule collection. The range is `100` - `65000`.
         */
        priority: number;
        /**
         * A `rule` (nat rule) block as defined above.
         */
        rules: outputs.network.FirewallPolicyRuleCollectionGroupNatRuleCollectionRule[];
    }

    export interface FirewallPolicyRuleCollectionGroupNatRuleCollectionRule {
        /**
         * The destination IP address (including CIDR).
         */
        destinationAddress?: string;
        /**
         * Specifies a list of destination ports.
         */
        destinationPorts?: string[];
        /**
         * The name which should be used for this rule.
         */
        name: string;
        /**
         * Specifies a list of network protocols this rule applies to. Possible values are `TCP`, `UDP`.
         */
        protocols: string[];
        /**
         * Specifies a list of source IP addresses (including CIDR and `*`).
         */
        sourceAddresses?: string[];
        /**
         * Specifies a list of source IP groups.
         */
        sourceIpGroups?: string[];
        /**
         * Specifies the translated address.
         */
        translatedAddress: string;
        /**
         * Specifies the translated port.
         */
        translatedPort: number;
    }

    export interface FirewallPolicyRuleCollectionGroupNetworkRuleCollection {
        /**
         * The action to take for the network rules in this collection. Possible values are `Allow` and `Deny`.
         */
        action: string;
        /**
         * The name which should be used for this network rule collection.
         */
        name: string;
        /**
         * The priority of the network rule collection. The range is `100` - `65000`.
         */
        priority: number;
        /**
         * One or more `rule` (network rule) blocks as defined above.
         */
        rules: outputs.network.FirewallPolicyRuleCollectionGroupNetworkRuleCollectionRule[];
    }

    export interface FirewallPolicyRuleCollectionGroupNetworkRuleCollectionRule {
        /**
         * Specifies a list of destination IP addresses (including CIDR and `*`) or Service Tags.
         */
        destinationAddresses?: string[];
        /**
         * Specifies a list of destination FQDNs.
         */
        destinationFqdns?: string[];
        /**
         * Specifies a list of destination IP groups.
         */
        destinationIpGroups?: string[];
        /**
         * Specifies a list of destination ports.
         */
        destinationPorts: string[];
        /**
         * The name which should be used for this rule.
         */
        name: string;
        /**
         * Specifies a list of network protocols this rule applies to. Possible values are `TCP`, `UDP`.
         */
        protocols: string[];
        /**
         * Specifies a list of source IP addresses (including CIDR and `*`).
         */
        sourceAddresses?: string[];
        /**
         * Specifies a list of source IP groups.
         */
        sourceIpGroups?: string[];
    }

    export interface FirewallPolicyThreatIntelligenceAllowlist {
        /**
         * A list of FQDNs that will be skipped for threat detection.
         */
        fqdns?: string[];
        /**
         * A list of IP addresses or IP address ranges that will be skipped for threat detection.
         */
        ipAddresses?: string[];
    }

    export interface FirewallVirtualHub {
        /**
         * The private IP address associated with the Firewall.
         */
        privateIpAddress: string;
        /**
         * The list of public IP addresses associated with the Firewall.
         */
        publicIpAddresses: string[];
        /**
         * Specifies the number of public IPs to assign to the Firewall. Defaults to `1`.
         */
        publicIpCount?: number;
        /**
         * Specifies the ID of the Virtual Hub where the Firewall resides in.
         */
        virtualHubId: string;
    }

    export interface GetApplicationGatewayIdentity {
        /**
         * A list of Managed Identity ID's assigned to this Application Gateway.
         */
        identityIds: string[];
        /**
         * The type of Managed Identity assigned to this Application Gateway.
         */
        type: string;
    }

    export interface GetExpressRouteCircuitPeering {
        /**
         * The Either a 16-bit or a 32-bit ASN for Azure.
         */
        azureAsn: number;
        /**
         * The Either a 16-bit or a 32-bit ASN. Can either be public or private.
         */
        peerAsn: number;
        /**
         * The type of the ExpressRoute Circuit Peering. Acceptable values include `AzurePrivatePeering`, `AzurePublicPeering` and `MicrosoftPeering`. Changing this forces a new resource to be created.
         */
        peeringType: string;
        /**
         * A `/30` subnet for the primary link.
         */
        primaryPeerAddressPrefix: string;
        /**
         * A `/30` subnet for the secondary link.
         */
        secondaryPeerAddressPrefix: string;
        /**
         * The shared key. Can be a maximum of 25 characters.
         */
        sharedKey: string;
        /**
         * A valid VLAN ID to establish this peering on.
         */
        vlanId: number;
    }

    export interface GetExpressRouteCircuitServiceProviderProperty {
        /**
         * The bandwidth in Mbps of the ExpressRoute circuit.
         */
        bandwidthInMbps: number;
        /**
         * The name of the peering location and **not** the Azure resource location.
         */
        peeringLocation: string;
        /**
         * The name of the ExpressRoute Service Provider.
         */
        serviceProviderName: string;
    }

    export interface GetExpressRouteCircuitSku {
        /**
         * The billing mode for bandwidth. Possible values are `MeteredData` or `UnlimitedData`.
         */
        family: string;
        /**
         * The service tier. Possible values are `Basic`, `Local`, `Standard` or `Premium`.
         */
        tier: string;
    }

    export interface GetFirewallIpConfiguration {
        /**
         * The name of the Azure Firewall.
         */
        name: string;
        /**
         * The private IP address associated with the Azure Firewall.
         */
        privateIpAddress: string;
        publicIpAddressId: string;
        /**
         * The ID of the Subnet where the Azure Firewall is deployed.
         */
        subnetId: string;
    }

    export interface GetFirewallManagementIpConfiguration {
        /**
         * The name of the Azure Firewall.
         */
        name: string;
        /**
         * The private IP address associated with the Azure Firewall.
         */
        privateIpAddress: string;
        publicIpAddressId: string;
        /**
         * The ID of the Subnet where the Azure Firewall is deployed.
         */
        subnetId: string;
    }

    export interface GetFirewallPolicyDn {
        networkRuleFqdnEnabled: boolean;
        proxyEnabled: boolean;
        servers: string[];
    }

    export interface GetFirewallPolicyThreatIntelligenceAllowlist {
        fqdns: string[];
        ipAddresses: string[];
    }

    export interface GetFirewallVirtualHub {
        /**
         * The private IP address associated with the Azure Firewall.
         */
        privateIpAddress: string;
        /**
         * The list of public IP addresses associated with the Azure Firewall.
         */
        publicIpAddresses: string[];
        /**
         * The number of public IPs assigned to the Azure Firewall.
         */
        publicIpCount: number;
        /**
         * The ID of the Virtual Hub where the Azure Firewall resides in.
         */
        virtualHubId: string;
    }

    export interface GetGatewayConnectionIpsecPolicy {
        /**
         * The DH group used in IKE phase 1 for initial SA. Valid
         * options are `DHGroup1`, `DHGroup14`, `DHGroup2`, `DHGroup2048`, `DHGroup24`,
         * `ECP256`, `ECP384`, or `None`.
         */
        dhGroup: string;
        /**
         * The IKE encryption algorithm. Valid
         * options are `AES128`, `AES192`, `AES256`, `DES`, or `DES3`.
         */
        ikeEncryption: string;
        /**
         * The IKE integrity algorithm. Valid
         * options are `MD5`, `SHA1`, `SHA256`, or `SHA384`.
         */
        ikeIntegrity: string;
        /**
         * The IPSec encryption algorithm. Valid
         * options are `AES128`, `AES192`, `AES256`, `DES`, `DES3`, `GCMAES128`, `GCMAES192`, `GCMAES256`, or `None`.
         */
        ipsecEncryption: string;
        /**
         * The IPSec integrity algorithm. Valid
         * options are `GCMAES128`, `GCMAES192`, `GCMAES256`, `MD5`, `SHA1`, or `SHA256`.
         */
        ipsecIntegrity: string;
        /**
         * The DH group used in IKE phase 2 for new child SA.
         * Valid options are `ECP256`, `ECP384`, `PFS1`, `PFS2`, `PFS2048`, `PFS24`,
         * or `None`.
         */
        pfsGroup: string;
        /**
         * The IPSec SA payload size in KB. Must be at least
         * `1024` KB.
         */
        saDatasize: number;
        /**
         * The IPSec SA lifetime in seconds. Must be at least
         * `300` seconds.
         */
        saLifetime: number;
    }

    export interface GetGatewayConnectionTrafficSelectorPolicy {
        /**
         * List of local CIDRs.
         */
        localAddressCidrs: string[];
        /**
         * List of remote CIDRs.
         */
        remoteAddressCidrs: string[];
    }

    export interface GetNetworkInterfaceIpConfiguration {
        /**
         * A list of Backend Address Pool ID's within a Application Gateway that this Network Interface is connected to.
         */
        applicationGatewayBackendAddressPoolsIds: string[];
        applicationSecurityGroupIds: string[];
        /**
         * A list of Backend Address Pool ID's within a Load Balancer that this Network Interface is connected to.
         */
        loadBalancerBackendAddressPoolsIds: string[];
        /**
         * A list of Inbound NAT Rule ID's within a Load Balancer that this Network Interface is connected to.
         */
        loadBalancerInboundNatRulesIds: string[];
        /**
         * Specifies the name of the Network Interface.
         */
        name: string;
        /**
         * is this the Primary IP Configuration for this Network Interface?
         */
        primary: boolean;
        /**
         * The Private IP Address assigned to this Network Interface.
         */
        privateIpAddress: string;
        /**
         * The IP Address allocation type for the Private address, such as `Dynamic` or `Static`.
         */
        privateIpAddressAllocation: string;
        privateIpAddressVersion: string;
        /**
         * The ID of the Public IP Address which is connected to this Network Interface.
         */
        publicIpAddressId: string;
        /**
         * The ID of the Subnet which the Network Interface is connected to.
         */
        subnetId: string;
    }

    export interface GetNetworkSecurityGroupSecurityRule {
        /**
         * Is network traffic is allowed or denied?
         */
        access: string;
        /**
         * The description for this rule.
         */
        description: string;
        /**
         * CIDR or destination IP range or * to match any IP.
         */
        destinationAddressPrefix: string;
        /**
         * A list of CIDRs or destination IP ranges.
         */
        destinationAddressPrefixes: string[];
        /**
         * A List of destination Application Security Group ID's
         */
        destinationApplicationSecurityGroupIds?: string[];
        /**
         * The Destination Port or Range.
         */
        destinationPortRange: string;
        destinationPortRanges: string[];
        /**
         * The direction specifies if rule will be evaluated on incoming or outgoing traffic.
         */
        direction: string;
        /**
         * Specifies the Name of the Network Security Group.
         */
        name: string;
        /**
         * The priority of the rule
         */
        priority: number;
        /**
         * The network protocol this rule applies to.
         */
        protocol: string;
        /**
         * CIDR or source IP range or * to match any IP.
         */
        sourceAddressPrefix: string;
        /**
         * A list of CIDRs or source IP ranges.
         */
        sourceAddressPrefixes: string[];
        /**
         * A List of source Application Security Group ID's
         */
        sourceApplicationSecurityGroupIds?: string[];
        /**
         * The Source Port or Range.
         */
        sourcePortRange: string;
        sourcePortRanges: string[];
    }

    export interface GetPublicIPsPublicIp {
        /**
         * The Domain Name Label of the Public IP Address
         */
        domainNameLabel: string;
        /**
         * The FQDN of the Public IP Address
         */
        fqdn: string;
        /**
         * The ID of the Public IP Address
         */
        id: string;
        /**
         * The IP address of the Public IP Address
         */
        ipAddress: string;
        /**
         * The Name of the Public IP Address
         */
        name: string;
    }

    export interface GetRouteFilterRule {
        /**
         * The access type of the rule
         */
        access: string;
        /**
         * The collection for bgp community values.
         */
        communities: string[];
        /**
         * The Name of this Route Filter.
         */
        name: string;
        /**
         * The Route Filter Rule Type.
         */
        ruleType: string;
    }

    export interface GetRouteTableRoute {
        /**
         * The destination CIDR to which the route applies.
         */
        addressPrefix: string;
        /**
         * The name of the Route Table.
         */
        name: string;
        /**
         * Contains the IP address packets should be forwarded to.
         */
        nextHopInIpAddress: string;
        /**
         * The type of Azure hop the packet should be sent to.
         */
        nextHopType: string;
    }

    export interface GetTrafficManagerProfileDnsConfig {
        /**
         * The relative domain name, this is combined with the domain name used by Traffic Manager to form the FQDN which is exported as documented below.
         */
        relativeName: string;
        /**
         * The TTL value of the Profile used by Local DNS resolvers and clients.
         */
        ttl: number;
    }

    export interface GetTrafficManagerProfileMonitorConfig {
        /**
         * One or more `customHeader` blocks as defined below.
         */
        customHeaders: outputs.network.GetTrafficManagerProfileMonitorConfigCustomHeader[];
        /**
         * A list of status code ranges.
         */
        expectedStatusCodeRanges: string[];
        /**
         * The interval used to check the endpoint health from a Traffic Manager probing agent.
         */
        intervalInSeconds: number;
        /**
         * The path used by the monitoring checks.
         */
        path: string;
        /**
         * The port number used by the monitoring checks.
         */
        port: number;
        /**
         * The protocol used by the monitoring checks.
         */
        protocol: string;
        /**
         * The amount of time the Traffic Manager probing agent should wait before considering that check a failure when a health check probe is sent to the endpoint.
         */
        timeoutInSeconds: number;
        /**
         * The number of failures a Traffic Manager probing agent tolerates before marking that endpoint as unhealthy.
         */
        toleratedNumberOfFailures: number;
    }

    export interface GetTrafficManagerProfileMonitorConfigCustomHeader {
        /**
         * Specifies the name of the Traffic Manager Profile.
         */
        name: string;
        /**
         * The value of custom header. Applicable for Http and Https protocol.
         */
        value: string;
    }

    export interface GetVirtualNetworkGatewayBgpSetting {
        /**
         * The Autonomous System Number (ASN) to use as part of the BGP.
         */
        asn: number;
        /**
         * The weight added to routes which have been learned
         * through BGP peering.
         */
        peerWeight: number;
        /**
         * The BGP peer IP address of the virtual network
         * gateway. This address is needed to configure the created gateway as a BGP Peer
         * on the on-premises VPN devices.
         */
        peeringAddress: string;
    }

    export interface GetVirtualNetworkGatewayCustomRoute {
        /**
         * A list of address blocks reserved for this virtual network in CIDR notation.
         */
        addressPrefixes: string[];
    }

    export interface GetVirtualNetworkGatewayIpConfiguration {
        /**
         * Specifies the name of the Virtual Network Gateway.
         */
        name: string;
        /**
         * Defines how the private IP address
         * of the gateways virtual interface is assigned.
         */
        privateIpAddressAllocation: string;
        /**
         * The ID of the Public IP Address associated
         * with the Virtual Network Gateway.
         */
        publicIpAddressId: string;
        /**
         * The ID of the gateway subnet of a virtual network in
         * which the virtual network gateway will be created. It is mandatory that
         * the associated subnet is named `GatewaySubnet`. Therefore, each virtual
         * network can contain at most a single Virtual Network Gateway.
         */
        subnetId: string;
    }

    export interface GetVirtualNetworkGatewayVpnClientConfiguration {
        /**
         * The client id of the Azure VPN application.
         * See [Create an Active Directory (AD) tenant for P2S OpenVPN protocol connections](https://docs.microsoft.com/en-gb/azure/vpn-gateway/openvpn-azure-ad-tenant-multi-app) for values
         * This setting is incompatible with the use of
         * `rootCertificate` and `revokedCertificate`, `radiusServerAddress`, and `radiusServerSecret`.
         */
        aadAudience: string;
        /**
         * The STS url for your tenant
         * This setting is incompatible with the use of
         * `rootCertificate` and `revokedCertificate`, `radiusServerAddress`, and `radiusServerSecret`.
         */
        aadIssuer: string;
        /**
         * AzureAD Tenant URL
         * This setting is incompatible with the use of
         * `rootCertificate` and `revokedCertificate`, `radiusServerAddress`, and `radiusServerSecret`.
         */
        aadTenant: string;
        /**
         * The address space out of which ip addresses for
         * vpn clients will be taken. You can provide more than one address space, e.g.
         * in CIDR notation.
         */
        addressSpaces: string[];
        /**
         * The address of the Radius server.
         * This setting is incompatible with the use of
         * `aadTenant`, `aadAudience`, `aadIssuer`, `rootCertificate` and `revokedCertificate`.
         */
        radiusServerAddress: string;
        /**
         * The secret used by the Radius server.
         * This setting is incompatible with the use of
         * `aadTenant`, `aadAudience`, `aadIssuer`, `rootCertificate` and `revokedCertificate`.
         */
        radiusServerSecret: string;
        /**
         * One or more `revokedCertificate` blocks which
         * are defined below.
         * This setting is incompatible with the use of
         * `aadTenant`, `aadAudience`, `aadIssuer`, `radiusServerAddress`, and `radiusServerSecret`.
         */
        revokedCertificates: outputs.network.GetVirtualNetworkGatewayVpnClientConfigurationRevokedCertificate[];
        /**
         * One or more `rootCertificate` blocks which are
         * defined below. These root certificates are used to sign the client certificate
         * used by the VPN clients to connect to the gateway.
         * This setting is incompatible with the use of
         * `aadTenant`, `aadAudience`, `aadIssuer`, `radiusServerAddress`, and `radiusServerSecret`.
         */
        rootCertificates: outputs.network.GetVirtualNetworkGatewayVpnClientConfigurationRootCertificate[];
        /**
         * List of the protocols supported by the vpn client.
         * The supported values are `SSTP`, `IkeV2` and `OpenVPN`.
         */
        vpnClientProtocols: string[];
    }

    export interface GetVirtualNetworkGatewayVpnClientConfigurationRevokedCertificate {
        /**
         * Specifies the name of the Virtual Network Gateway.
         */
        name: string;
        thumbprint: string;
    }

    export interface GetVirtualNetworkGatewayVpnClientConfigurationRootCertificate {
        /**
         * Specifies the name of the Virtual Network Gateway.
         */
        name: string;
        /**
         * The SHA1 thumbprint of the certificate to be revoked.
         */
        publicCertData: string;
    }

    export interface LocalNetworkGatewayBgpSettings {
        /**
         * The BGP speaker's ASN.
         */
        asn: number;
        /**
         * The BGP peering address and BGP identifier
         * of this BGP speaker.
         */
        bgpPeeringAddress: string;
        /**
         * The weight added to routes learned from this
         * BGP speaker.
         */
        peerWeight: number;
    }

    export interface NetworkConnectionMonitorDestination {
        /**
         * The IP address or domain name of the Network Connection Monitor endpoint.
         *
         * @deprecated The field belongs to the v1 network connection monitor, which is now deprecated in favour of v2 by Azure. Please check the document (https://www.terraform.io/docs/providers/azurerm/r/network_connection_monitor.html) for the v2 properties.
         */
        address: string;
        /**
         * The port for the HTTP connection.
         *
         * @deprecated The field belongs to the v1 network connection monitor, which is now deprecated in favour of v2 by Azure. Please check the document (https://www.terraform.io/docs/providers/azurerm/r/network_connection_monitor.html) for the v2 properties.
         */
        port: number;
        /**
         * The ID of the Virtual Machine which is used as the endpoint by the Network Connection Monitor. This property is deprecated in favour of `targetResourceId`.
         *
         * @deprecated The field belongs to the v1 network connection monitor, which is now deprecated in favour of v2 by Azure. Please check the document (https://www.terraform.io/docs/providers/azurerm/r/network_connection_monitor.html) for the v2 properties.
         */
        virtualMachineId: string;
    }

    export interface NetworkConnectionMonitorEndpoint {
        /**
         * The IP address or domain name of the Network Connection Monitor endpoint.
         */
        address?: string;
        /**
         * The test coverage for the Network Connection Monitor endpoint. Possible values are `AboveAverage`, `Average`, `BelowAverage`, `Default`, `Full` and `Low`.
         */
        coverageLevel?: string;
        /**
         * A list of IPv4/IPv6 subnet masks or IPv4/IPv6 IP addresses to be excluded to the Network Connection Monitor endpoint.
         */
        excludedIpAddresses?: string[];
        /**
         * A `filter` block as defined below.
         */
        filter?: outputs.network.NetworkConnectionMonitorEndpointFilter;
        /**
         * A list of IPv4/IPv6 subnet masks or IPv4/IPv6 IP addresses to be included to the Network Connection Monitor endpoint.
         */
        includedIpAddresses?: string[];
        /**
         * The name of the endpoint for the Network Connection Monitor .
         */
        name: string;
        /**
         * The resource ID which is used as the endpoint by the Network Connection Monitor.
         */
        targetResourceId: string;
        /**
         * The endpoint type of the Network Connection Monitor. Possible values are `AzureSubnet`, `AzureVM`, `AzureVNet`, `ExternalAddress`, `MMAWorkspaceMachine` and `MMAWorkspaceNetwork`.
         */
        targetResourceType?: string;
        /**
         * The ID of the Virtual Machine which is used as the endpoint by the Network Connection Monitor. This property is deprecated in favour of `targetResourceId`.
         *
         * @deprecated This property has been renamed to `target_resource_id` and will be removed in v3.0 of the provider.
         */
        virtualMachineId?: string;
    }

    export interface NetworkConnectionMonitorEndpointFilter {
        /**
         * A `item` block as defined below.
         */
        items?: outputs.network.NetworkConnectionMonitorEndpointFilterItem[];
        /**
         * The behaviour type of this endpoint filter. Currently the only allowed value is `Include`. Defaults to `Include`.
         */
        type?: string;
    }

    export interface NetworkConnectionMonitorEndpointFilterItem {
        /**
         * The address of the filter item.
         */
        address?: string;
        /**
         * The type of items included in the filter. Possible values are `AgentAddress`. Defaults to `AgentAddress`.
         */
        type?: string;
    }

    export interface NetworkConnectionMonitorSource {
        /**
         * The port for the HTTP connection.
         *
         * @deprecated The field belongs to the v1 network connection monitor, which is now deprecated in favour of v2 by Azure. Please check the document (https://www.terraform.io/docs/providers/azurerm/r/network_connection_monitor.html) for the v2 properties.
         */
        port: number;
        /**
         * The ID of the Virtual Machine which is used as the endpoint by the Network Connection Monitor. This property is deprecated in favour of `targetResourceId`.
         *
         * @deprecated The field belongs to the v1 network connection monitor, which is now deprecated in favour of v2 by Azure. Please check the document (https://www.terraform.io/docs/providers/azurerm/r/network_connection_monitor.html) for the v2 properties.
         */
        virtualMachineId: string;
    }

    export interface NetworkConnectionMonitorTestConfiguration {
        /**
         * A `httpConfiguration` block as defined below.
         */
        httpConfiguration?: outputs.network.NetworkConnectionMonitorTestConfigurationHttpConfiguration;
        /**
         * A `icmpConfiguration` block as defined below.
         */
        icmpConfiguration?: outputs.network.NetworkConnectionMonitorTestConfigurationIcmpConfiguration;
        /**
         * The name of test configuration for the Network Connection Monitor.
         */
        name: string;
        /**
         * The preferred IP version which is used in the test evaluation. Possible values are `IPv4` and `IPv6`.
         */
        preferredIpVersion?: string;
        /**
         * The protocol used to evaluate tests. Possible values are `Tcp`, `Http` and `Icmp`.
         */
        protocol: string;
        /**
         * A `successThreshold` block as defined below.
         */
        successThreshold?: outputs.network.NetworkConnectionMonitorTestConfigurationSuccessThreshold;
        /**
         * A `tcpConfiguration` block as defined below.
         */
        tcpConfiguration?: outputs.network.NetworkConnectionMonitorTestConfigurationTcpConfiguration;
        /**
         * The time interval in seconds at which the test evaluation will happen. Defaults to `60`.
         */
        testFrequencyInSeconds?: number;
    }

    export interface NetworkConnectionMonitorTestConfigurationHttpConfiguration {
        /**
         * The HTTP method for the HTTP request. Possible values are `Get` and `Post`. Defaults to `Get`.
         */
        method?: string;
        /**
         * The path component of the URI. It only accepts the absolute path.
         */
        path?: string;
        /**
         * The port for the HTTP connection.
         */
        port?: number;
        /**
         * Should HTTPS be preferred over HTTP in cases where the choice is not explicit? Defaults to `false`.
         */
        preferHttps?: boolean;
        /**
         * A `requestHeader` block as defined below.
         */
        requestHeaders?: outputs.network.NetworkConnectionMonitorTestConfigurationHttpConfigurationRequestHeader[];
        /**
         * The HTTP status codes to consider successful. For instance, `2xx`, `301-304` and `418`.
         */
        validStatusCodeRanges?: string[];
    }

    export interface NetworkConnectionMonitorTestConfigurationHttpConfigurationRequestHeader {
        /**
         * The name of the HTTP header.
         */
        name: string;
        /**
         * The value of the HTTP header.
         */
        value: string;
    }

    export interface NetworkConnectionMonitorTestConfigurationIcmpConfiguration {
        /**
         * Should path evaluation with trace route be enabled? Defaults to `true`.
         */
        traceRouteEnabled?: boolean;
    }

    export interface NetworkConnectionMonitorTestConfigurationSuccessThreshold {
        /**
         * The maximum percentage of failed checks permitted for a test to be successful.
         */
        checksFailedPercent?: number;
        /**
         * The maximum round-trip time in milliseconds permitted for a test to be successful.
         */
        roundTripTimeMs?: number;
    }

    export interface NetworkConnectionMonitorTestConfigurationTcpConfiguration {
        /**
         * The port for the Tcp connection.
         */
        port: number;
        /**
         * Should path evaluation with trace route be enabled? Defaults to `true`.
         */
        traceRouteEnabled?: boolean;
    }

    export interface NetworkConnectionMonitorTestGroup {
        /**
         * A list of destination endpoint names.
         */
        destinationEndpoints: string[];
        /**
         * Should the test group be enabled? Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * The name of the test group for the Network Connection Monitor.
         */
        name: string;
        /**
         * A list of source endpoint names.
         */
        sourceEndpoints: string[];
        /**
         * A list of test configuration names.
         */
        testConfigurationNames: string[];
    }

    export interface NetworkInterfaceIpConfiguration {
        /**
         * A name used for this IP Configuration.
         */
        name: string;
        /**
         * Is this the Primary IP Configuration? Must be `true` for the first `ipConfiguration` when multiple are specified. Defaults to `false`.
         */
        primary: boolean;
        /**
         * The Static IP Address which should be used.
         */
        privateIpAddress: string;
        /**
         * The allocation method used for the Private IP Address. Possible values are `Dynamic` and `Static`.
         */
        privateIpAddressAllocation: string;
        /**
         * The IP Version to use. Possible values are `IPv4` or `IPv6`. Defaults to `IPv4`.
         */
        privateIpAddressVersion?: string;
        /**
         * Reference to a Public IP Address to associate with this NIC
         */
        publicIpAddressId?: string;
        /**
         * The ID of the Subnet where this Network Interface should be located in.
         */
        subnetId?: string;
    }

    export interface NetworkPacketCaptureFilter {
        /**
         * The local IP Address to be filtered on. Notation: "127.0.0.1" for single address entry. "127.0.0.1-127.0.0.255" for range. "127.0.0.1;127.0.0.5" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported. Changing this forces a new resource to be created.
         */
        localIpAddress?: string;
        /**
         * The local port to be filtered on. Notation: "80" for single port entry."80-85" for range. "80;443;" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported. Changing this forces a new resource to be created.
         */
        localPort?: string;
        /**
         * The Protocol to be filtered on. Possible values include `Any`, `TCP` and `UDP`. Changing this forces a new resource to be created.
         */
        protocol: string;
        /**
         * The remote IP Address to be filtered on. Notation: "127.0.0.1" for single address entry. "127.0.0.1-127.0.0.255" for range. "127.0.0.1;127.0.0.5;" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported.. Changing this forces a new resource to be created.
         */
        remoteIpAddress?: string;
        /**
         * The remote port to be filtered on. Notation: "80" for single port entry."80-85" for range. "80;443;" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported. Changing this forces a new resource to be created.
         */
        remotePort?: string;
    }

    export interface NetworkPacketCaptureStorageLocation {
        /**
         * A valid local path on the targeting VM. Must include the name of the capture file (*.cap). For linux virtual machine it must start with `/var/captures`.
         */
        filePath?: string;
        /**
         * The ID of the storage account to save the packet capture session
         */
        storageAccountId?: string;
        /**
         * The URI of the storage path to save the packet capture.
         */
        storagePath: string;
    }

    export interface NetworkSecurityGroupSecurityRule {
        /**
         * Specifies whether network traffic is allowed or denied. Possible values are `Allow` and `Deny`.
         */
        access: string;
        /**
         * A description for this rule. Restricted to 140 characters.
         */
        description?: string;
        /**
         * CIDR or destination IP range or * to match any IP. Tags such as ‘VirtualNetwork’, ‘AzureLoadBalancer’ and ‘Internet’ can also be used. This is required if `destinationAddressPrefixes` is not specified.
         */
        destinationAddressPrefix?: string;
        /**
         * List of destination address prefixes. Tags may not be used. This is required if `destinationAddressPrefix` is not specified.
         */
        destinationAddressPrefixes?: string[];
        /**
         * A List of destination Application Security Group ID's
         */
        destinationApplicationSecurityGroupIds?: string[];
        /**
         * Destination Port or Range. Integer or range between `0` and `65535` or `*` to match any. This is required if `destinationPortRanges` is not specified.
         */
        destinationPortRange?: string;
        /**
         * List of destination ports or port ranges. This is required if `destinationPortRange` is not specified.
         */
        destinationPortRanges?: string[];
        /**
         * The direction specifies if rule will be evaluated on incoming or outgoing traffic. Possible values are `Inbound` and `Outbound`.
         */
        direction: string;
        /**
         * The name of the security rule.
         */
        name: string;
        /**
         * Specifies the priority of the rule. The value can be between 100 and 4096. The priority number must be unique for each rule in the collection. The lower the priority number, the higher the priority of the rule.
         */
        priority: number;
        /**
         * Network protocol this rule applies to. Can be `Tcp`, `Udp`, `Icmp`, or `*` to match all.
         */
        protocol: string;
        /**
         * CIDR or source IP range or * to match any IP. Tags such as ‘VirtualNetwork’, ‘AzureLoadBalancer’ and ‘Internet’ can also be used. This is required if `sourceAddressPrefixes` is not specified.
         */
        sourceAddressPrefix?: string;
        /**
         * List of source address prefixes. Tags may not be used. This is required if `sourceAddressPrefix` is not specified.
         */
        sourceAddressPrefixes?: string[];
        /**
         * A List of source Application Security Group ID's
         */
        sourceApplicationSecurityGroupIds?: string[];
        /**
         * Source Port or Range. Integer or range between `0` and `65535` or `*` to match any. This is required if `sourcePortRanges` is not specified.
         */
        sourcePortRange?: string;
        /**
         * List of source ports or port ranges. This is required if `sourcePortRange` is not specified.
         */
        sourcePortRanges?: string[];
    }

    export interface NetworkWatcherFlowLogRetentionPolicy {
        /**
         * The number of days to retain flow log records.
         */
        days: number;
        /**
         * Boolean flag to enable/disable traffic analytics.
         */
        enabled: boolean;
    }

    export interface NetworkWatcherFlowLogTrafficAnalytics {
        /**
         * Boolean flag to enable/disable traffic analytics.
         */
        enabled: boolean;
        /**
         * How frequently service should do flow analytics in minutes.
         */
        intervalInMinutes?: number;
        /**
         * The resource guid of the attached workspace.
         */
        workspaceId: string;
        /**
         * The location of the attached workspace.
         */
        workspaceRegion: string;
        /**
         * The resource ID of the attached workspace.
         */
        workspaceResourceId: string;
    }

    export interface PacketCaptureFilter {
        /**
         * The local IP Address to be filtered on. Notation: "127.0.0.1" for single address entry. "127.0.0.1-127.0.0.255" for range. "127.0.0.1;127.0.0.5" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported. Changing this forces a new resource to be created.
         */
        localIpAddress?: string;
        /**
         * The local port to be filtered on. Notation: "80" for single port entry."80-85" for range. "80;443;" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported. Changing this forces a new resource to be created.
         */
        localPort?: string;
        /**
         * The Protocol to be filtered on. Possible values include `Any`, `TCP` and `UDP`. Changing this forces a new resource to be created.
         */
        protocol: string;
        /**
         * The remote IP Address to be filtered on. Notation: "127.0.0.1" for single address entry. "127.0.0.1-127.0.0.255" for range. "127.0.0.1;127.0.0.5;" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported.. Changing this forces a new resource to be created.
         */
        remoteIpAddress?: string;
        /**
         * The remote port to be filtered on. Notation: "80" for single port entry."80-85" for range. "80;443;" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported. Changing this forces a new resource to be created.
         */
        remotePort?: string;
    }

    export interface PacketCaptureStorageLocation {
        /**
         * A valid local path on the targeting VM. Must include the name of the capture file (*.cap). For linux virtual machine it must start with `/var/captures`.
         */
        filePath?: string;
        /**
         * The ID of the storage account to save the packet capture session
         */
        storageAccountId?: string;
        /**
         * The URI of the storage path to save the packet capture.
         */
        storagePath: string;
    }

    export interface PointToPointVpnGatewayConnectionConfiguration {
        /**
         * The Name which should be used for this Connection Configuration.
         */
        name: string;
        /**
         * A `route` block as defined below.
         */
        route: outputs.network.PointToPointVpnGatewayConnectionConfigurationRoute;
        /**
         * A `vpnClientAddressPool` block as defined below.
         */
        vpnClientAddressPool: outputs.network.PointToPointVpnGatewayConnectionConfigurationVpnClientAddressPool;
    }

    export interface PointToPointVpnGatewayConnectionConfigurationRoute {
        /**
         * The Virtual Hub Route Table resource id associated with this Routing Configuration.
         */
        associatedRouteTableId: string;
        /**
         * A `propagatedRouteTable` block as defined below.
         */
        propagatedRouteTable?: outputs.network.PointToPointVpnGatewayConnectionConfigurationRoutePropagatedRouteTable;
    }

    export interface PointToPointVpnGatewayConnectionConfigurationRoutePropagatedRouteTable {
        /**
         * The list of Virtual Hub Route Table resource id which the routes will be propagated to.
         */
        ids: string[];
        /**
         * The list of labels to logically group Virtual Hub Route Tables which the routes will be propagated to.
         */
        labels?: string[];
    }

    export interface PointToPointVpnGatewayConnectionConfigurationVpnClientAddressPool {
        /**
         * A list of CIDR Ranges which should be used as Address Prefixes.
         */
        addressPrefixes: string[];
    }

    export interface ProfileContainerNetworkInterface {
        /**
         * One or more `ipConfiguration` blocks as documented below.
         */
        ipConfigurations: outputs.network.ProfileContainerNetworkInterfaceIpConfiguration[];
        /**
         * Specifies the name of the IP Configuration.
         */
        name: string;
    }

    export interface ProfileContainerNetworkInterfaceIpConfiguration {
        /**
         * Specifies the name of the IP Configuration.
         */
        name: string;
        /**
         * Reference to the subnet associated with the IP Configuration.
         */
        subnetId: string;
    }

    export interface RouteFilterRule {
        /**
         * The access type of the rule. The only possible value is `Allow`.
         */
        access: string;
        /**
         * The collection for bgp community values to filter on. e.g. ['12076:5010','12076:5020'].
         */
        communities: string[];
        /**
         * The name of the route filter rule.
         */
        name: string;
        /**
         * The rule type of the rule. The only possible value is `Community`.
         */
        ruleType: string;
    }

    export interface RouteTableRoute {
        /**
         * The destination CIDR to which the route applies, such as 10.1.0.0/16. Tags such as `VirtualNetwork`, `AzureLoadBalancer` or `Internet` can also be used.
         */
        addressPrefix: string;
        /**
         * The name of the route.
         */
        name: string;
        /**
         * Contains the IP address packets should be forwarded to. Next hop values are only allowed in routes where the next hop type is `VirtualAppliance`.
         */
        nextHopInIpAddress?: string;
        /**
         * The type of Azure hop the packet should be sent to. Possible values are `VirtualNetworkGateway`, `VnetLocal`, `Internet`, `VirtualAppliance` and `None`.
         */
        nextHopType: string;
    }

    export interface SubnetDelegation {
        /**
         * A name for this delegation.
         */
        name: string;
        /**
         * A `serviceDelegation` block as defined below.
         */
        serviceDelegation: outputs.network.SubnetDelegationServiceDelegation;
    }

    export interface SubnetDelegationServiceDelegation {
        /**
         * A list of Actions which should be delegated. This list is specific to the service to delegate to. Possible values include `Microsoft.Network/networkinterfaces/*`, `Microsoft.Network/virtualNetworks/subnets/action`, `Microsoft.Network/virtualNetworks/subnets/join/action`, `Microsoft.Network/virtualNetworks/subnets/prepareNetworkPolicies/action` and `Microsoft.Network/virtualNetworks/subnets/unprepareNetworkPolicies/action`.
         */
        actions?: string[];
        /**
         * The name of service to delegate to. Possible values include `Microsoft.ApiManagement/service`, `Microsoft.AzureCosmosDB/clusters`, `Microsoft.BareMetal/AzureVMware`, `Microsoft.BareMetal/CrayServers`, `Microsoft.Batch/batchAccounts`, `Microsoft.ContainerInstance/containerGroups`, `Microsoft.Databricks/workspaces`, `Microsoft.DBforMySQL/flexibleServers`, `Microsoft.DBforMySQL/serversv2`, `Microsoft.DBforPostgreSQL/flexibleServers`, `Microsoft.DBforPostgreSQL/serversv2`, `Microsoft.DBforPostgreSQL/singleServers`, `Microsoft.HardwareSecurityModules/dedicatedHSMs`, `Microsoft.Kusto/clusters`, `Microsoft.Logic/integrationServiceEnvironments`, `Microsoft.MachineLearningServices/workspaces`,  `Microsoft.Netapp/volumes`, `Microsoft.Network/managedResolvers`, `Microsoft.PowerPlatform/vnetaccesslinks`, `Microsoft.ServiceFabricMesh/networks`, `Microsoft.Sql/managedInstances`, `Microsoft.Sql/servers`, `Microsoft.StreamAnalytics/streamingJobs`, `Microsoft.Synapse/workspaces`, `Microsoft.Web/hostingEnvironments`, and `Microsoft.Web/serverFarms`.
         */
        name: string;
    }

    export interface SubnetServiceEndpointStoragePolicyDefinition {
        /**
         * The description of this Subnet Service Endpoint Storage Policy Definition.
         */
        description?: string;
        /**
         * The name which should be used for this Subnet Service Endpoint Storage Policy Definition.
         */
        name: string;
        /**
         * Specifies a list of resources that this Subnet Service Endpoint Storage Policy Definition applies to.
         */
        serviceResources: string[];
    }

    export interface TrafficManagerEndpointCustomHeader {
        /**
         * The name of the custom header.
         */
        name: string;
        /**
         * The value of custom header. Applicable for Http and Https protocol.
         */
        value: string;
    }

    export interface TrafficManagerEndpointSubnet {
        /**
         * The First IP....
         */
        first: string;
        /**
         * The Last IP...
         */
        last?: string;
        /**
         * The Scope...
         */
        scope?: number;
    }

    export interface TrafficManagerProfileDnsConfig {
        /**
         * The relative domain name, this is combined with the domain name used by Traffic Manager to form the FQDN which is exported as documented below. Changing this forces a new resource to be created.
         */
        relativeName: string;
        /**
         * The TTL value of the Profile used by Local DNS resolvers and clients.
         */
        ttl: number;
    }

    export interface TrafficManagerProfileMonitorConfig {
        /**
         * One or more `customHeader` blocks as defined below.
         */
        customHeaders?: outputs.network.TrafficManagerProfileMonitorConfigCustomHeader[];
        /**
         * A list of status code ranges in the format of `100-101`.
         */
        expectedStatusCodeRanges?: string[];
        /**
         * The interval used to check the endpoint health from a Traffic Manager probing agent. You can specify two values here: `30` (normal probing) and `10` (fast probing). The default value is `30`.
         */
        intervalInSeconds?: number;
        /**
         * The path used by the monitoring checks. Required when `protocol` is set to `HTTP` or `HTTPS` - cannot be set when `protocol` is set to `TCP`.
         */
        path?: string;
        /**
         * The port number used by the monitoring checks.
         */
        port: number;
        /**
         * The protocol used by the monitoring checks, supported values are `HTTP`, `HTTPS` and `TCP`.
         */
        protocol: string;
        /**
         * The amount of time the Traffic Manager probing agent should wait before considering that check a failure when a health check probe is sent to the endpoint. If `intervalInSeconds` is set to `30`, then `timeoutInSeconds` can be between `5` and `10`. The default value is `10`. If `intervalInSeconds` is set to `10`, then valid values are between `5` and `9` and `timeoutInSeconds` is required.
         */
        timeoutInSeconds?: number;
        /**
         * The number of failures a Traffic Manager probing agent tolerates before marking that endpoint as unhealthy. Valid values are between `0` and `9`. The default value is `3`
         */
        toleratedNumberOfFailures?: number;
    }

    export interface TrafficManagerProfileMonitorConfigCustomHeader {
        /**
         * The name of the custom header.
         */
        name: string;
        /**
         * The value of custom header. Applicable for Http and Https protocol.
         */
        value: string;
    }

    export interface VirtualHubConnectionRouting {
        /**
         * The ID of the route table associated with this Virtual Hub connection.
         */
        associatedRouteTableId: string;
        /**
         * A `propagatedRouteTable` block as defined below.
         */
        propagatedRouteTable: outputs.network.VirtualHubConnectionRoutingPropagatedRouteTable;
        /**
         * A `staticVnetRoute` block as defined below.
         */
        staticVnetRoutes?: outputs.network.VirtualHubConnectionRoutingStaticVnetRoute[];
    }

    export interface VirtualHubConnectionRoutingPropagatedRouteTable {
        /**
         * The list of labels to assign to this route table.
         */
        labels: string[];
        /**
         * A list of Route Table ID's to associated with this Virtual Hub Connection.
         */
        routeTableIds: string[];
    }

    export interface VirtualHubConnectionRoutingStaticVnetRoute {
        /**
         * A list of CIDR Ranges which should be used as Address Prefixes.
         */
        addressPrefixes?: string[];
        /**
         * The name which should be used for this Static Route.
         */
        name?: string;
        /**
         * The IP Address which should be used for the Next Hop.
         */
        nextHopIpAddress?: string;
    }

    export interface VirtualHubRoute {
        /**
         * A list of Address Prefixes.
         */
        addressPrefixes: string[];
        /**
         * The IP Address that Packets should be forwarded to as the Next Hop.
         */
        nextHopIpAddress: string;
    }

    export interface VirtualHubRouteTableRoute {
        /**
         * A list of destination addresses for this route.
         */
        destinations: string[];
        /**
         * The type of destinations. Possible values are `CIDR`, `ResourceId` and `Service`.
         */
        destinationsType: string;
        /**
         * The name which should be used for this route.
         */
        name: string;
        /**
         * The next hop's resource ID.
         */
        nextHop: string;
        /**
         * The type of next hop. Currently the only possible value is `ResourceId`. Defaults to `ResourceId`.
         */
        nextHopType?: string;
    }

    export interface VirtualNetworkDdosProtectionPlan {
        /**
         * Enable/disable DDoS Protection Plan on Virtual Network.
         */
        enable: boolean;
        /**
         * The ID of DDoS Protection Plan.
         */
        id: string;
    }

    export interface VirtualNetworkGatewayBgpSettings {
        /**
         * The Autonomous System Number (ASN) to use as part of the BGP.
         */
        asn?: number;
        /**
         * The weight added to routes which have been learned
         * through BGP peering. Valid values can be between `0` and `100`.
         */
        peerWeight?: number;
        /**
         * @deprecated Deprecated in favor of `bgp_settings.0.peering_addresses.0.default_addresses.0`
         */
        peeringAddress: string;
        /**
         * A list of `peeringAddresses` as defined below. Only one `peeringAddresses` block can be specified except when `activeActive` of this Virtual Network Gateway is `true`.
         */
        peeringAddresses: outputs.network.VirtualNetworkGatewayBgpSettingsPeeringAddress[];
    }

    export interface VirtualNetworkGatewayBgpSettingsPeeringAddress {
        /**
         * A list of Azure custom APIPA addresses assigned to the BGP peer of the Virtual Network Gateway.
         */
        apipaAddresses?: string[];
        /**
         * A list of peering address assigned to the BGP peer of the Virtual Network Gateway.
         */
        defaultAddresses: string[];
        /**
         * The name of the IP configuration of this Virtual Network Gateway. In case there are multiple `ipConfiguration` blocks defined, this property is **required** to specify.
         */
        ipConfigurationName: string;
        /**
         * A list of tunnel IP addresses assigned to the BGP peer of the Virtual Network Gateway.
         */
        tunnelIpAddresses: string[];
    }

    export interface VirtualNetworkGatewayConnectionIpsecPolicy {
        /**
         * The DH group used in IKE phase 1 for initial SA. Valid
         * options are `DHGroup1`, `DHGroup14`, `DHGroup2`, `DHGroup2048`, `DHGroup24`,
         * `ECP256`, `ECP384`, or `None`.
         */
        dhGroup: string;
        /**
         * The IKE encryption algorithm. Valid
         * options are `AES128`, `AES192`, `AES256`, `DES`, `DES3`, `GCMAES128`, or `GCMAES256`.
         */
        ikeEncryption: string;
        /**
         * The IKE integrity algorithm. Valid
         * options are `GCMAES128`, `GCMAES256`, `MD5`, `SHA1`, `SHA256`, or `SHA384`.
         */
        ikeIntegrity: string;
        /**
         * The IPSec encryption algorithm. Valid
         * options are `AES128`, `AES192`, `AES256`, `DES`, `DES3`, `GCMAES128`, `GCMAES192`, `GCMAES256`, or `None`.
         */
        ipsecEncryption: string;
        /**
         * The IPSec integrity algorithm. Valid
         * options are `GCMAES128`, `GCMAES192`, `GCMAES256`, `MD5`, `SHA1`, or `SHA256`.
         */
        ipsecIntegrity: string;
        /**
         * The DH group used in IKE phase 2 for new child SA.
         * Valid options are `ECP256`, `ECP384`, `PFS1`, `PFS14`, `PFS2`, `PFS2048`, `PFS24`, `PFSMM`,
         * or `None`.
         */
        pfsGroup: string;
        /**
         * The IPSec SA payload size in KB. Must be at least
         * `1024` KB. Defaults to `102400000` KB.
         */
        saDatasize: number;
        /**
         * The IPSec SA lifetime in seconds. Must be at least
         * `300` seconds. Defaults to `27000` seconds.
         */
        saLifetime: number;
    }

    export interface VirtualNetworkGatewayConnectionTrafficSelectorPolicy {
        localAddressCidrs: string[];
        remoteAddressCidrs: string[];
    }

    export interface VirtualNetworkGatewayCustomRoute {
        /**
         * A list of address blocks reserved for this virtual network in CIDR notation.
         */
        addressPrefixes?: string[];
    }

    export interface VirtualNetworkGatewayIpConfiguration {
        /**
         * A user-defined name of the IP configuration. Defaults to
         * `vnetGatewayConfig`.
         */
        name?: string;
        /**
         * Defines how the private IP address
         * of the gateways virtual interface is assigned. Valid options are `Static` or
         * `Dynamic`. Defaults to `Dynamic`.
         */
        privateIpAddressAllocation?: string;
        /**
         * The ID of the public ip address to associate
         * with the Virtual Network Gateway.
         */
        publicIpAddressId: string;
        /**
         * The ID of the gateway subnet of a virtual network in
         * which the virtual network gateway will be created. It is mandatory that
         * the associated subnet is named `GatewaySubnet`. Therefore, each virtual
         * network can contain at most a single Virtual Network Gateway.
         */
        subnetId: string;
    }

    export interface VirtualNetworkGatewayVpnClientConfiguration {
        /**
         * The client id of the Azure VPN application.
         * See [Create an Active Directory (AD) tenant for P2S OpenVPN protocol connections](https://docs.microsoft.com/en-gb/azure/vpn-gateway/openvpn-azure-ad-tenant-multi-app) for values
         * This setting is incompatible with the use of
         * `rootCertificate` and `revokedCertificate`, `radiusServerAddress`, and `radiusServerSecret`.
         */
        aadAudience?: string;
        /**
         * The STS url for your tenant
         * This setting is incompatible with the use of
         * `rootCertificate` and `revokedCertificate`, `radiusServerAddress`, and `radiusServerSecret`.
         */
        aadIssuer?: string;
        /**
         * AzureAD Tenant URL
         * This setting is incompatible with the use of
         * `rootCertificate` and `revokedCertificate`, `radiusServerAddress`, and `radiusServerSecret`.
         */
        aadTenant?: string;
        /**
         * The address space out of which ip addresses for
         * vpn clients will be taken. You can provide more than one address space, e.g.
         * in CIDR notation.
         */
        addressSpaces: string[];
        /**
         * The address of the Radius server.
         * This setting is incompatible with the use of
         * `aadTenant`, `aadAudience`, `aadIssuer`, `rootCertificate` and `revokedCertificate`.
         */
        radiusServerAddress?: string;
        /**
         * The secret used by the Radius server.
         * This setting is incompatible with the use of
         * `aadTenant`, `aadAudience`, `aadIssuer`, `rootCertificate` and `revokedCertificate`.
         */
        radiusServerSecret?: string;
        /**
         * One or more `revokedCertificate` blocks which
         * are defined below.
         * This setting is incompatible with the use of
         * `aadTenant`, `aadAudience`, `aadIssuer`, `radiusServerAddress`, and `radiusServerSecret`.
         */
        revokedCertificates?: outputs.network.VirtualNetworkGatewayVpnClientConfigurationRevokedCertificate[];
        /**
         * One or more `rootCertificate` blocks which are
         * defined below. These root certificates are used to sign the client certificate
         * used by the VPN clients to connect to the gateway.
         * This setting is incompatible with the use of
         * `aadTenant`, `aadAudience`, `aadIssuer`, `radiusServerAddress`, and `radiusServerSecret`.
         */
        rootCertificates?: outputs.network.VirtualNetworkGatewayVpnClientConfigurationRootCertificate[];
        /**
         * List of the protocols supported by the vpn client.
         * The supported values are `SSTP`, `IkeV2` and `OpenVPN`.
         * Values `SSTP` and `IkeV2` are incompatible with the use of
         * `aadTenant`, `aadAudience` and `aadIssuer`.
         */
        vpnClientProtocols: string[];
    }

    export interface VirtualNetworkGatewayVpnClientConfigurationRevokedCertificate {
        /**
         * A user-defined name of the IP configuration. Defaults to
         * `vnetGatewayConfig`.
         */
        name: string;
        thumbprint: string;
    }

    export interface VirtualNetworkGatewayVpnClientConfigurationRootCertificate {
        /**
         * A user-defined name of the IP configuration. Defaults to
         * `vnetGatewayConfig`.
         */
        name: string;
        /**
         * The public certificate of the root certificate
         * authority. The certificate must be provided in Base-64 encoded X.509 format
         * (PEM). In particular, this argument *must not* include the
         * `-----BEGIN CERTIFICATE-----` or `-----END CERTIFICATE-----` markers.
         * revoked.
         */
        publicCertData: string;
    }

    export interface VirtualNetworkSubnet {
        /**
         * The address prefix to use for the subnet.
         */
        addressPrefix: string;
        /**
         * The ID of DDoS Protection Plan.
         */
        id: string;
        /**
         * The name of the virtual network. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * The Network Security Group to associate with the subnet. (Referenced by `id`, ie. `azurerm_network_security_group.example.id`)
         */
        securityGroup?: string;
    }

    export interface VpnGatewayBgpSettings {
        /**
         * The ASN of the BGP Speaker. Changing this forces a new resource to be created.
         */
        asn: number;
        /**
         * The Address which should be used for the BGP Peering.
         */
        bgpPeeringAddress: string;
        /**
         * An `instanceBgpPeeringAddress` block as defined below.
         */
        instance0BgpPeeringAddress: outputs.network.VpnGatewayBgpSettingsInstance0BgpPeeringAddress;
        /**
         * An `instanceBgpPeeringAddress` block as defined below.
         */
        instance1BgpPeeringAddress: outputs.network.VpnGatewayBgpSettingsInstance1BgpPeeringAddress;
        /**
         * The weight added to Routes learned from this BGP Speaker. Changing this forces a new resource to be created.
         */
        peerWeight: number;
    }

    export interface VpnGatewayBgpSettingsInstance0BgpPeeringAddress {
        /**
         * A list of custom BGP peering addresses to assign to this instance.
         */
        customIps: string[];
        /**
         * The list of default BGP peering addresses which belong to the pre-defined VPN Gateway IP configuration.
         */
        defaultIps: string[];
        /**
         * The pre-defined id of VPN Gateway Ip Configuration.
         */
        ipConfigurationId: string;
        /**
         * The list of tunnel public IP addresses which belong to the pre-defined VPN Gateway IP configuration.
         */
        tunnelIps: string[];
    }

    export interface VpnGatewayBgpSettingsInstance1BgpPeeringAddress {
        /**
         * A list of custom BGP peering addresses to assign to this instance.
         */
        customIps: string[];
        /**
         * The list of default BGP peering addresses which belong to the pre-defined VPN Gateway IP configuration.
         */
        defaultIps: string[];
        /**
         * The pre-defined id of VPN Gateway Ip Configuration.
         */
        ipConfigurationId: string;
        /**
         * The list of tunnel public IP addresses which belong to the pre-defined VPN Gateway IP configuration.
         */
        tunnelIps: string[];
    }

    export interface VpnGatewayConnectionRouting {
        /**
         * The ID of the Route Table associated with this VPN Connection.
         */
        associatedRouteTable: string;
        /**
         * The list IDs of Route Tables to advertise the routes of this VPN Connection.
         */
        propagatedRouteTables: string[];
    }

    export interface VpnGatewayConnectionVpnLink {
        /**
         * The expected connection bandwidth in MBPS. Defaults to `10`.
         */
        bandwidthMbps?: number;
        /**
         * Should the BGP be enabled? Defaults to `false`. Changing this forces a new VPN Gateway Connection to be created.
         */
        bgpEnabled?: boolean;
        /**
         * One or more `ipsecPolicy` blocks as defined above.
         */
        ipsecPolicies?: outputs.network.VpnGatewayConnectionVpnLinkIpsecPolicy[];
        /**
         * Whether to use local azure ip to initiate connection? Defaults to `false`.
         */
        localAzureIpAddressEnabled?: boolean;
        /**
         * The name which should be used for this VPN Link Connection.
         */
        name: string;
        /**
         * Whether to enable policy-based traffic selectors? Defaults to `false`.
         */
        policyBasedTrafficSelectorEnabled?: boolean;
        /**
         * The protocol used for this VPN Link Connection. Possible values are `IKEv1` and `IKEv2`. Defaults to `IKEv2`.
         */
        protocol?: string;
        /**
         * Should the rate limit be enabled? Defaults to `false`.
         */
        ratelimitEnabled?: boolean;
        /**
         * Routing weight for this VPN Link Connection. Defaults to `0`.
         */
        routeWeight?: number;
        /**
         * SharedKey for this VPN Link Connection.
         */
        sharedKey?: string;
        /**
         * The ID of the connected VPN Site Link. Changing this forces a new VPN Gateway Connection to be created.
         */
        vpnSiteLinkId: string;
    }

    export interface VpnGatewayConnectionVpnLinkIpsecPolicy {
        /**
         * The DH Group used in IKE Phase 1 for initial SA. Possible values are `None`, `DHGroup1`, `DHGroup2`, `DHGroup14`, `DHGroup24`, `DHGroup2048`, `ECP256`, `ECP384`.
         */
        dhGroup: string;
        /**
         * The IPSec encryption algorithm (IKE phase 1). Possible values are `AES128`, `AES192`, `AES256`, `DES`, `DES3`, `GCMAES128`, `GCMAES192`, `GCMAES256`, `None`.
         */
        encryptionAlgorithm: string;
        /**
         * The IKE encryption algorithm (IKE phase 2). Possible values are `DES`, `DES3`, `AES128`, `AES192`, `AES256`, `GCMAES128`, `GCMAES256`.
         */
        ikeEncryptionAlgorithm: string;
        /**
         * The IKE integrity algorithm (IKE phase 2). Possible values are `MD5`, `SHA1`, `SHA256`, `SHA384`, `GCMAES128`, `GCMAES256`.
         */
        ikeIntegrityAlgorithm: string;
        /**
         * The IPSec integrity algorithm (IKE phase 1). Possible values are `MD5`, `SHA1`, `SHA256`, `GCMAES128`, `GCMAES192`, `GCMAES256`.
         */
        integrityAlgorithm: string;
        /**
         * The Pfs Group used in IKE Phase 2 for the new child SA. Possible values are `None`, `PFS1`, `PFS2`, `PFS14`, `PFS24`, `PFS2048`, `PFSMM`, `ECP256`, `ECP384`.
         */
        pfsGroup: string;
        /**
         * The IPSec Security Association (also called Quick Mode or Phase 2 SA) payload size in KB for the site to site VPN tunnel.
         */
        saDataSizeKb: number;
        /**
         * The IPSec Security Association (also called Quick Mode or Phase 2 SA) lifetime in seconds for the site to site VPN tunnel.
         */
        saLifetimeSec: number;
    }

    export interface VpnServerConfigurationAzureActiveDirectoryAuthentication {
        /**
         * The Audience which should be used for authentication.
         */
        audience: string;
        /**
         * The Issuer which should be used for authentication.
         */
        issuer: string;
        /**
         * The Tenant which should be used for authentication.
         */
        tenant: string;
    }

    export interface VpnServerConfigurationClientRevokedCertificate {
        /**
         * A name used to uniquely identify this certificate.
         */
        name: string;
        /**
         * The Thumbprint of the Certificate.
         */
        thumbprint: string;
    }

    export interface VpnServerConfigurationClientRootCertificate {
        /**
         * A name used to uniquely identify this certificate.
         */
        name: string;
        /**
         * The Public Key Data associated with the Certificate.
         */
        publicCertData: string;
    }

    export interface VpnServerConfigurationIpsecPolicy {
        /**
         * The DH Group, used in IKE Phase 1. Possible values include `DHGroup1`, `DHGroup2`, `DHGroup14`, `DHGroup24`, `DHGroup2048`, `ECP256`, `ECP384` and `None`.
         */
        dhGroup: string;
        /**
         * The IKE encryption algorithm, used for IKE Phase 2. Possible values include `AES128`, `AES192`, `AES256`, `DES`, `DES3`, `GCMAES128` and `GCMAES256`.
         */
        ikeEncryption: string;
        /**
         * The IKE encryption integrity algorithm, used for IKE Phase 2. Possible values include `GCMAES128`, `GCMAES256`, `MD5`, `SHA1`, `SHA256` and `SHA384`.
         */
        ikeIntegrity: string;
        /**
         * The IPSec encryption algorithm, used for IKE phase 1. Possible values include `AES128`, `AES192`, `AES256`, `DES`, `DES3`, `GCMAES128`, `GCMAES192`, `GCMAES256` and `None`.
         */
        ipsecEncryption: string;
        /**
         * The IPSec integrity algorithm, used for IKE phase 1. Possible values include `GCMAES128`, `GCMAES192`, `GCMAES256`, `MD5`, `SHA1` and `SHA256`.
         */
        ipsecIntegrity: string;
        /**
         * The Pfs Group, used in IKE Phase 2. Possible values include `ECP256`, `ECP384`, `PFS1`, `PFS2`, `PFS14`, `PFS24`, `PFS2048`, `PFSMM` and `None`.
         */
        pfsGroup: string;
        /**
         * The IPSec Security Association payload size in KB for a Site-to-Site VPN tunnel.
         */
        saDataSizeKilobytes: number;
        /**
         * The IPSec Security Association lifetime in seconds for a Site-to-Site VPN tunnel.
         */
        saLifetimeSeconds: number;
    }

    export interface VpnServerConfigurationRadius {
        /**
         * One or more `clientRootCertificate` blocks as defined above.
         */
        clientRootCertificates?: outputs.network.VpnServerConfigurationRadiusClientRootCertificate[];
        /**
         * One or more `serverRootCertificate` blocks as defined below.
         */
        serverRootCertificates: outputs.network.VpnServerConfigurationRadiusServerRootCertificate[];
        /**
         * One or more `server` blocks as defined below.
         */
        servers?: outputs.network.VpnServerConfigurationRadiusServer[];
    }

    export interface VpnServerConfigurationRadiusClientRootCertificate {
        /**
         * A name used to uniquely identify this certificate.
         */
        name: string;
        /**
         * The Thumbprint of the Certificate.
         */
        thumbprint: string;
    }

    export interface VpnServerConfigurationRadiusServer {
        /**
         * The Address of the Radius Server.
         */
        address: string;
        /**
         * One or more `clientRootCertificate` blocks as defined above.
         */
        clientRootCertificates?: outputs.network.VpnServerConfigurationRadiusServerClientRootCertificate[];
        /**
         * The Secret used to communicate with the Radius Server.
         */
        secret: string;
        /**
         * One or more `serverRootCertificate` blocks as defined below.
         */
        serverRootCertificates: outputs.network.VpnServerConfigurationRadiusServerServerRootCertificate[];
    }

    export interface VpnServerConfigurationRadiusServerClientRootCertificate {
        /**
         * A name used to uniquely identify this certificate.
         */
        name: string;
        /**
         * The Thumbprint of the Certificate.
         */
        thumbprint: string;
    }

    export interface VpnServerConfigurationRadiusServerRootCertificate {
        /**
         * A name used to uniquely identify this certificate.
         */
        name: string;
        /**
         * The Public Key Data associated with the Certificate.
         */
        publicCertData: string;
    }

    export interface VpnServerConfigurationRadiusServerServerRootCertificate {
        /**
         * A name used to uniquely identify this certificate.
         */
        name: string;
        /**
         * The Public Key Data associated with the Certificate.
         */
        publicCertData: string;
    }

    export interface VpnSiteLink {
        /**
         * A `bgp` block as defined above.
         */
        bgp?: outputs.network.VpnSiteLinkBgp;
        /**
         * The FQDN of this VPN Site Link.
         */
        fqdn?: string;
        /**
         * The ID of the VPN Site Link.
         */
        id: string;
        /**
         * The IP address of this VPN Site Link.
         */
        ipAddress?: string;
        /**
         * The name which should be used for this VPN Site Link.
         */
        name: string;
        /**
         * The name of the physical link at the VPN Site. Example: `ATT`, `Verizon`.
         */
        providerName?: string;
        /**
         * The speed of the VPN device at the branch location in unit of mbps.
         */
        speedInMbps?: number;
    }

    export interface VpnSiteLinkBgp {
        /**
         * The BGP speaker's ASN.
         */
        asn: number;
        /**
         * The BGP peering ip address.
         */
        peeringAddress: string;
    }
}

export namespace notificationhub {
    export interface GetHubApnsCredential {
        /**
         * The Application Mode which defines which server the APNS Messages should be sent to. Possible values are `Production` and `Sandbox`.
         */
        applicationMode: string;
        /**
         * The Bundle ID of the iOS/macOS application to send push notifications for, such as `com.org.example`.
         */
        bundleId: string;
        /**
         * The Apple Push Notifications Service (APNS) Key.
         */
        keyId: string;
        /**
         * The ID of the team the Token.
         */
        teamId: string;
        /**
         * The Push Token associated with the Apple Developer Account.
         */
        token: string;
    }

    export interface GetHubGcmCredential {
        /**
         * The API Key associated with the Google Cloud Messaging service.
         */
        apiKey: string;
    }

    export interface GetNamespaceSku {
        /**
         * Specifies the Name of the Notification Hub Namespace.
         */
        name: string;
    }

    export interface HubApnsCredential {
        /**
         * The Application Mode which defines which server the APNS Messages should be sent to. Possible values are `Production` and `Sandbox`.
         */
        applicationMode: string;
        /**
         * The Bundle ID of the iOS/macOS application to send push notifications for, such as `com.org.example`.
         */
        bundleId: string;
        /**
         * The Apple Push Notifications Service (APNS) Key.
         */
        keyId: string;
        /**
         * The ID of the team the Token.
         */
        teamId: string;
        /**
         * The Push Token associated with the Apple Developer Account. This is the contents of the `key` downloaded from [the Apple Developer Portal](https://developer.apple.com/account/ios/authkey/) between the `-----BEGIN PRIVATE KEY-----` and `-----END PRIVATE KEY-----` blocks.
         */
        token: string;
    }

    export interface HubGcmCredential {
        /**
         * The API Key associated with the Google Cloud Messaging service.
         */
        apiKey: string;
    }

}

export namespace operationalinsights {
    export interface AnalyticsSolutionPlan {
        name: string;
        /**
         * The product name of the solution. For example `OMSGallery/Containers`. Changing this forces a new resource to be created.
         */
        product: string;
        /**
         * A promotion code to be used with the solution.
         */
        promotionCode?: string;
        /**
         * The publisher of the solution. For example `Microsoft`. Changing this forces a new resource to be created.
         */
        publisher: string;
    }

}

export namespace policy {
    export interface AssignmentIdentity {
        /**
         * The Principal ID of this Policy Assignment if `type` is `SystemAssigned`.
         */
        principalId: string;
        /**
         * The Tenant ID of this Policy Assignment if `type` is `SystemAssigned`.
         */
        tenantId: string;
        /**
         * The type of Managed Identity for this Policy Assignment. Possible values are `SystemAssigned` (where Azure will generate a Service Principal for you).
         */
        type?: string;
    }

    export interface GetPolicySetDefinitionPolicyDefinitionGroup {
        /**
         * The ID of a resource that contains additional metadata about this policy definition group.
         */
        additionalMetadataResourceId: string;
        /**
         * The category of this policy definition group.
         */
        category: string;
        /**
         * The description of this policy definition group.
         */
        description: string;
        /**
         * Specifies the display name of the Policy Set Definition. Conflicts with `name`.
         */
        displayName: string;
        /**
         * Specifies the name of the Policy Set Definition. Conflicts with `displayName`.
         */
        name: string;
    }

    export interface GetPolicySetDefinitionPolicyDefinitionReference {
        /**
         * The parameter values for the referenced policy rule. This field is a json object.
         */
        parameterValues: string;
        /**
         * The mapping of the parameter values for the referenced policy rule. The keys are the parameter names.
         */
        parameters: {[key: string]: string};
        /**
         * The ID of the policy definition or policy set definition that is included in this policy set definition.
         */
        policyDefinitionId: string;
        /**
         * The list of names of the policy definition groups that this policy definition reference belongs to.
         */
        policyGroupNames: string[];
        /**
         * The unique ID within this policy set definition for this policy definition reference.
         */
        referenceId: string;
    }

    export interface PolicySetDefinitionPolicyDefinitionGroup {
        /**
         * The ID of a resource that contains additional metadata about this policy definition group.
         */
        additionalMetadataResourceId?: string;
        /**
         * The category of this policy definition group.
         */
        category?: string;
        /**
         * The description of this policy definition group.
         */
        description?: string;
        /**
         * The display name of this policy definition group.
         */
        displayName?: string;
        /**
         * The name of this policy definition group.
         */
        name: string;
    }

    export interface PolicySetDefinitionPolicyDefinitionReference {
        /**
         * Parameter values for the referenced policy rule. This field is a JSON string that allows you to assign parameters to this policy rule.
         */
        parameterValues: string;
        /**
         * Parameters for the policy set definition. This field is a json object that allows you to parameterize your policy definition.
         *
         * @deprecated Deprecated in favour of `parameter_values`
         */
        parameters: {[key: string]: string};
        /**
         * The ID of the policy definition or policy set definition that will be included in this policy set definition.
         */
        policyDefinitionId: string;
        /**
         * A list of names of the policy definition groups that this policy definition reference belongs to.
         */
        policyGroupNames?: string[];
        /**
         * A unique ID within this policy set definition for this policy definition reference.
         */
        referenceId: string;
    }

    export interface VirtualMachineConfigurationAssignmentConfiguration {
        /**
         * The name of the Guest Configuration that will be assigned in this Guest Configuration Assignment.
         */
        name: string;
        /**
         * One or more `parameter` blocks which define what configuration parameters and values against.
         */
        parameters?: outputs.policy.VirtualMachineConfigurationAssignmentConfigurationParameter[];
        /**
         * The version of the Guest Configuration that will be assigned in this Guest Configuration Assignment.
         */
        version?: string;
    }

    export interface VirtualMachineConfigurationAssignmentConfigurationParameter {
        /**
         * The name of the configuration parameter to check.
         */
        name: string;
        /**
         * The value to check the configuration parameter with.
         */
        value: string;
    }

}

export namespace postgresql {
    export interface FlexibleServerMaintenanceWindow {
        /**
         * The day of week for maintenance window. Defaults to `0`.
         */
        dayOfWeek?: number;
        /**
         * The day of week for maintenance window. Defaults to `0`.
         */
        startHour?: number;
        /**
         * The start minute for maintenance window. Defaults to `0`.
         */
        startMinute?: number;
    }

    export interface GetServerIdentity {
        /**
         * The ID of the System Managed Service Principal assigned to the PostgreSQL Server.
         */
        principalId: string;
        /**
         * The ID of the Tenant of the System Managed Service Principal assigned to the PostgreSQL Server.
         */
        tenantId: string;
        /**
         * The identity type of the Managed Identity assigned to the PostgreSQL Server.
         */
        type: string;
    }

    export interface ServerIdentity {
        /**
         * The Client ID of the Service Principal assigned to this PostgreSQL Server.
         */
        principalId: string;
        /**
         * The ID of the Tenant the Service Principal is assigned in.
         */
        tenantId: string;
        /**
         * The Type of Identity which should be used for this PostgreSQL Server. At this time the only possible value is `SystemAssigned`.
         */
        type: string;
    }

    export interface ServerStorageProfile {
        /**
         * @deprecated this has been moved to the top level and will be removed in version 3.0 of the provider.
         */
        autoGrow: string;
        /**
         * Backup retention days for the server, supported values are between `7` and `35` days.
         *
         * @deprecated this has been moved to the top level and will be removed in version 3.0 of the provider.
         */
        backupRetentionDays?: number;
        /**
         * @deprecated this has been moved to the top level and will be removed in version 3.0 of the provider.
         */
        geoRedundantBackup: string;
        /**
         * Max storage allowed for a server. Possible values are between `5120` MB(5GB) and `1048576` MB(1TB) for the Basic SKU and between `5120` MB(5GB) and `16777216` MB(16TB) for General Purpose/Memory Optimized SKUs. For more information see the [product documentation](https://docs.microsoft.com/en-us/rest/api/postgresql/servers/create#StorageProfile).
         *
         * @deprecated this has been moved to the top level and will be removed in version 3.0 of the provider.
         */
        storageMb?: number;
    }

    export interface ServerThreatDetectionPolicy {
        /**
         * Specifies a list of alerts which should be disabled. Possible values include `Access_Anomaly`, `Sql_Injection` and `Sql_Injection_Vulnerability`.
         */
        disabledAlerts?: string[];
        /**
         * Should the account administrators be emailed when this alert is triggered?
         */
        emailAccountAdmins?: boolean;
        /**
         * A list of email addresses which alerts should be sent to.
         */
        emailAddresses?: string[];
        /**
         * Is the policy enabled?
         */
        enabled?: boolean;
        /**
         * Specifies the number of days to keep in the Threat Detection audit logs.
         */
        retentionDays?: number;
        /**
         * Specifies the identifier key of the Threat Detection audit storage account.
         */
        storageAccountAccessKey?: string;
        /**
         * Specifies the blob storage endpoint (e.g. https://MyAccount.blob.core.windows.net). This blob storage will hold all Threat Detection audit logs.
         */
        storageEndpoint?: string;
    }

}

export namespace privatedns {
    export interface LinkServiceNatIpConfiguration {
        /**
         * Specifies the name which should be used for the NAT IP Configuration. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * Is this is the Primary IP Configuration? Changing this forces a new resource to be created.
         */
        primary: boolean;
        /**
         * Specifies a Private Static IP Address for this IP Configuration.
         */
        privateIpAddress?: string;
        /**
         * The version of the IP Protocol which should be used. At this time the only supported value is `IPv4`. Defaults to `IPv4`.
         */
        privateIpAddressVersion?: string;
        /**
         * Specifies the ID of the Subnet which should be used for the Private Link Service.
         */
        subnetId: string;
    }

    export interface MxRecordRecord {
        /**
         * The FQDN of the exchange to MX record points to.
         */
        exchange: string;
        /**
         * The preference of the MX record.
         */
        preference: number;
    }

    export interface SRVRecordRecord {
        /**
         * The Port the service is listening on.
         */
        port: number;
        /**
         * The priority of the SRV record.
         */
        priority: number;
        /**
         * The FQDN of the service.
         */
        target: string;
        /**
         * The Weight of the SRV record.
         */
        weight: number;
    }

    export interface TxtRecordRecord {
        /**
         * The value of the TXT record. Max length: 1024 characters
         */
        value: string;
    }

    export interface ZoneSoaRecord {
        /**
         * The email contact for the SOA record.
         */
        email: string;
        /**
         * The expire time for the SOA record. Defaults to `2419200`.
         */
        expireTime?: number;
        /**
         * The fully qualified domain name of the Record Set.
         */
        fqdn: string;
        /**
         * The domain name of the authoritative name server for the SOA record.
         */
        hostName: string;
        /**
         * The minimum Time To Live for the SOA record. By convention, it is used to determine the negative caching duration. Defaults to `10`.
         */
        minimumTtl?: number;
        /**
         * The refresh time for the SOA record. Defaults to `3600`.
         */
        refreshTime?: number;
        /**
         * The retry time for the SOA record. Defaults to `300`.
         */
        retryTime?: number;
        /**
         * The serial number for the SOA record.
         */
        serialNumber: number;
        /**
         * A mapping of tags to assign to the Record Set.
         */
        tags?: {[key: string]: string};
        /**
         * The Time To Live of the SOA Record in seconds. Defaults to `3600`.
         */
        ttl?: number;
    }

}

export namespace privatelink {
    export interface EndpointCustomDnsConfig {
        /**
         * The fully qualified domain name to the `privateDnsZone`.
         */
        fqdn: string;
        /**
         * A list of all IP Addresses that map to the `privateDnsZone` fqdn.
         */
        ipAddresses: string[];
    }

    export interface EndpointPrivateDnsZoneConfig {
        /**
         * The ID of the Private DNS Zone Config.
         */
        id: string;
        /**
         * Specifies the Name of the Private Endpoint. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * A list of IP Addresses
         */
        privateDnsZoneId: string;
        /**
         * A `recordSets` block as defined below.
         */
        recordSets: outputs.privatelink.EndpointPrivateDnsZoneConfigRecordSet[];
    }

    export interface EndpointPrivateDnsZoneConfigRecordSet {
        /**
         * The fully qualified domain name to the `privateDnsZone`.
         */
        fqdn: string;
        /**
         * A list of all IP Addresses that map to the `privateDnsZone` fqdn.
         */
        ipAddresses: string[];
        /**
         * Specifies the Name of the Private Endpoint. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * The time to live for each connection to the `privateDnsZone`.
         */
        ttl: number;
        /**
         * The type of DNS record.
         */
        type: string;
    }

    export interface EndpointPrivateDnsZoneGroup {
        /**
         * The ID of the Private DNS Zone Config.
         */
        id: string;
        /**
         * Specifies the Name of the Private DNS Zone Group. Changing this forces a new `privateDnsZoneGroup` resource to be created.
         */
        name: string;
        /**
         * Specifies the list of Private DNS Zones to include within the `privateDnsZoneGroup`.
         */
        privateDnsZoneIds: string[];
    }

    export interface EndpointPrivateServiceConnection {
        /**
         * Does the Private Endpoint require Manual Approval from the remote resource owner? Changing this forces a new resource to be created.
         */
        isManualConnection: boolean;
        /**
         * Specifies the Name of the Private Service Connection. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * The Service Alias of the Private Link Enabled Remote Resource which this Private Endpoint should be connected to. One of `privateConnectionResourceId` or `privateConnectionResourceAlias` must be specified. Changing this forces a new resource to be created.
         */
        privateConnectionResourceAlias?: string;
        /**
         * The ID of the Private Link Enabled Remote Resource which this Private Endpoint should be connected to. One of `privateConnectionResourceId` or `privateConnectionResourceAlias` must be specified. Changing this forces a new resource to be created.
         */
        privateConnectionResourceId?: string;
        /**
         * (Computed) The private IP address associated with the private endpoint, note that you will have a private IP address assigned to the private endpoint even if the connection request was `Rejected`.
         */
        privateIpAddress: string;
        /**
         * A message passed to the owner of the remote resource when the private endpoint attempts to establish the connection to the remote resource. The request message can be a maximum of `140` characters in length. Only valid if `isManualConnection` is set to `true`.
         */
        requestMessage?: string;
        /**
         * A list of subresource names which the Private Endpoint is able to connect to. `subresourceNames` corresponds to `groupId`. Changing this forces a new resource to be created.
         */
        subresourceNames?: string[];
    }

    export interface GetEndpointConnectionPrivateServiceConnection {
        /**
         * Specifies the Name of the private endpoint.
         */
        name: string;
        /**
         * The private IP address associated with the private endpoint, note that you will have a private IP address assigned to the private endpoint even if the connection request was `Rejected`.
         */
        privateIpAddress: string;
        /**
         * Possible values are as follows:
         * Value | Meaning
         * -- | --
         * `Auto-Approved` | The remote resource owner has added you to the `Auto-Approved` RBAC permission list for the remote resource, all private endpoint connection requests will be automatically `Approved`.
         * `Deleted state` | The resource owner has `Rejected` the private endpoint connection request and has removed your private endpoint request from the remote resource.
         * `request/response message` | If you submitted a manual private endpoint connection request, while in the `Pending` status the `requestResponse` will display the same text from your `requestMessage` in the `privateServiceConnection` block above. If the private endpoint connection request was `Rejected` by the owner of the remote resource, the text for the rejection will be displayed as the `requestResponse` text, if the private endpoint connection request was `Approved` by the owner of the remote resource, the text for the approval will be displayed as the `requestResponse` text
         */
        requestResponse: string;
        /**
         * The current status of the private endpoint request, possible values will be `Pending`, `Approved`, `Rejected`, or `Disconnected`.
         */
        status: string;
    }

    export interface GetServiceEndpointConnectionsPrivateEndpointConnection {
        /**
         * A message indicating if changes on the service provider require any updates or not.
         */
        actionRequired: string;
        /**
         * The resource id of the private link service connection between the private link service and the private link endpoint.
         */
        connectionId: string;
        /**
         * The name of the connection between the private link service and the private link endpoint.
         */
        connectionName: string;
        /**
         * The request for approval message or the reason for rejection message.
         */
        description: string;
        /**
         * The resource id of the private link endpoint.
         */
        privateEndpointId: string;
        /**
         * The name of the private link endpoint.
         */
        privateEndpointName: string;
        /**
         * Indicates the state of the connection between the private link service and the private link endpoint, possible values are `Pending`, `Approved` or `Rejected`.
         */
        status: string;
    }

    export interface GetServiceNatIpConfiguration {
        /**
         * The name of the private link service.
         */
        name: string;
        /**
         * Value that indicates if the IP configuration is the primary configuration or not.
         */
        primary: boolean;
        /**
         * The private IP address of the NAT IP configuration.
         */
        privateIpAddress: string;
        /**
         * The version of the IP Protocol.
         */
        privateIpAddressVersion: string;
        /**
         * The ID of the subnet to be used by the service.
         */
        subnetId: string;
    }

}

export namespace purview {
    export interface AccountIdentity {
        /**
         * The ID of the Principal (Client) in Azure Active Directory.
         */
        principalId: string;
        /**
         * The ID of the Azure Active Directory Tenant.
         */
        tenantId: string;
        /**
         * The type of Managed Identity assigned to this Purview Account.
         */
        type: string;
    }

}

export namespace recoveryservices {
    export interface VaultIdentity {
        principalId: string;
        tenantId: string;
        /**
         * The Type of Identity which should be used for this Recovery Services Vault. At this time the only possible value is `SystemAssigned`.
         */
        type: string;
    }

}

export namespace redis {
    export interface CachePatchSchedule {
        dayOfWeek: string;
        startHourUtc?: number;
    }

    export interface CacheRedisConfiguration {
        /**
         * Enable or disable AOF persistence for this Redis Cache.
         */
        aofBackupEnabled?: boolean;
        /**
         * First Storage Account connection string for AOF persistence.
         */
        aofStorageConnectionString0?: string;
        /**
         * Second Storage Account connection string for AOF persistence.
         */
        aofStorageConnectionString1?: string;
        /**
         * If set to `false`, the Redis instance will be accessible without authentication. Defaults to `true`.
         */
        enableAuthentication?: boolean;
        /**
         * Returns the max number of connected clients at the same time.
         */
        maxclients: number;
        /**
         * Value in megabytes reserved to accommodate for memory fragmentation. Defaults are shown below.
         */
        maxfragmentationmemoryReserved: number;
        /**
         * The max-memory delta for this Redis instance. Defaults are shown below.
         */
        maxmemoryDelta: number;
        /**
         * How Redis will select what to remove when `maxmemory` is reached. Defaults are shown below.
         */
        maxmemoryPolicy?: string;
        /**
         * Value in megabytes reserved for non-cache usage e.g. failover. Defaults are shown below.
         */
        maxmemoryReserved: number;
        /**
         * Keyspace notifications allows clients to subscribe to Pub/Sub channels in order to receive events affecting the Redis data set in some way. [Reference](https://redis.io/topics/notifications#configuration)
         */
        notifyKeyspaceEvents?: string;
        /**
         * Is Backup Enabled? Only supported on Premium SKU's.
         */
        rdbBackupEnabled?: boolean;
        /**
         * The Backup Frequency in Minutes. Only supported on Premium SKU's. Possible values are: `15`, `30`, `60`, `360`, `720` and `1440`.
         */
        rdbBackupFrequency?: number;
        /**
         * The maximum number of snapshots to create as a backup. Only supported for Premium SKU's.
         */
        rdbBackupMaxSnapshotCount?: number;
        /**
         * The Connection String to the Storage Account. Only supported for Premium SKU's. In the format: `DefaultEndpointsProtocol=https;BlobEndpoint=${azurerm_storage_account.example.primary_blob_endpoint};AccountName=${azurerm_storage_account.example.name};AccountKey=${azurerm_storage_account.example.primary_access_key}`.
         */
        rdbStorageConnectionString?: string;
    }

    export interface EnterpriseDatabaseModule {
        /**
         * Configuration options for the module (e.g. `ERROR_RATE 0.00 INITIAL_SIZE 400`).
         */
        args?: string;
        /**
         * The name which should be used for this module. Possible values are `RediSearch`, `RedisBloom` and `RedisTimeSeries`. Changing this forces a new Redis Enterprise Database to be created.
         */
        name: string;
        version: string;
    }

    export interface GetCachePatchSchedule {
        /**
         * the Weekday name for the patch item
         */
        dayOfWeek: string;
        /**
         * The Start Hour for maintenance in UTC
         */
        startHourUtc: number;
    }

    export interface GetCacheRedisConfiguration {
        aofBackupEnabled: boolean;
        aofStorageConnectionString0: string;
        aofStorageConnectionString1: string;
        /**
         * Specifies if authentication is enabled
         */
        enableAuthentication: boolean;
        maxclients: number;
        /**
         * Value in megabytes reserved to accommodate for memory fragmentation.
         */
        maxfragmentationmemoryReserved: number;
        /**
         * The max-memory delta for this Redis instance.
         */
        maxmemoryDelta: number;
        /**
         * How Redis will select what to remove when `maxmemory` is reached.
         */
        maxmemoryPolicy: string;
        /**
         * The value in megabytes reserved for non-cache usage e.g. failover
         */
        maxmemoryReserved: number;
        notifyKeyspaceEvents: string;
        /**
         * Is Backup Enabled? Only supported on Premium SKU's.
         */
        rdbBackupEnabled: boolean;
        /**
         * The Backup Frequency in Minutes. Only supported on Premium SKU's.
         */
        rdbBackupFrequency: number;
        /**
         * The maximum number of snapshots that can be created as a backup.
         */
        rdbBackupMaxSnapshotCount: number;
        /**
         * The Connection String to the Storage Account. Only supported for Premium SKU's.
         */
        rdbStorageConnectionString: string;
    }

}

export namespace role {
    export interface DefinitionPermission {
        /**
         * One or more Allowed Actions, such as `*`, `Microsoft.Resources/subscriptions/resourceGroups/read`. See ['Azure Resource Manager resource provider operations'](https://docs.microsoft.com/en-us/azure/role-based-access-control/resource-provider-operations) for details.
         */
        actions?: string[];
        /**
         * One or more Allowed Data Actions, such as `*`, `Microsoft.Storage/storageAccounts/blobServices/containers/blobs/read`. See ['Azure Resource Manager resource provider operations'](https://docs.microsoft.com/en-us/azure/role-based-access-control/resource-provider-operations) for details.
         */
        dataActions?: string[];
        /**
         * One or more Disallowed Actions, such as `*`, `Microsoft.Resources/subscriptions/resourceGroups/read`. See ['Azure Resource Manager resource provider operations'](https://docs.microsoft.com/en-us/azure/role-based-access-control/resource-provider-operations) for details.
         */
        notActions?: string[];
        /**
         * One or more Disallowed Data Actions, such as `*`, `Microsoft.Resources/subscriptions/resourceGroups/read`. See ['Azure Resource Manager resource provider operations'](https://docs.microsoft.com/en-us/azure/role-based-access-control/resource-provider-operations) for details.
         */
        notDataActions?: string[];
    }

    export interface GetRoleDefinitionPermission {
        actions: string[];
        dataActions?: string[];
        notActions: string[];
        notDataActions?: string[];
    }

}

export namespace search {
    export interface GetServiceIdentity {
        /**
         * The (Client) ID of the Service Principal.
         */
        principalId: string;
        /**
         * The ID of the Tenant the Service Principal is assigned in.
         */
        tenantId: string;
        /**
         * The Type of Managed Identity which is used for the Search Service.
         */
        type: string;
    }

    export interface GetServiceQueryKey {
        /**
         * The value of this Query Key.
         */
        key: string;
        /**
         * The Name of the Search Service.
         */
        name: string;
    }

    export interface ServiceIdentity {
        /**
         * The (Client) ID of the Service Principal.
         */
        principalId: string;
        /**
         * The ID of the Tenant the Service Principal is assigned in.
         */
        tenantId: string;
        /**
         * The Type of Identity which should be used for the Search Service. At this time the only possible value is `SystemAssigned`.
         */
        type: string;
    }

    export interface ServiceQueryKey {
        /**
         * The value of this Query Key.
         */
        key: string;
        /**
         * The Name which should be used for this Search Service. Changing this forces a new Search Service to be created.
         */
        name: string;
    }

}

export namespace securitycenter {
    export interface AssessmentStatus {
        /**
         * Specifies the cause of the assessment status.
         */
        cause?: string;
        /**
         * Specifies the programmatic code of the assessment status. Possible values are `Healthy`, `Unhealthy` and `NotApplicable`.
         */
        code: string;
        /**
         * Specifies the human readable description of the assessment status.
         */
        description?: string;
    }

    export interface AutomationAction {
        /**
         * A connection string to send data to the target Event Hub namespace, this should include a key with send permissions.
         */
        connectionString?: string;
        /**
         * The resource id of the target Logic App, Event Hub namespace or Log Analytics workspace.
         */
        resourceId: string;
        /**
         * The callback URL to trigger the Logic App that will receive and process data sent by this automation. This can be found in the Azure Portal under "See trigger history"
         */
        triggerUrl?: string;
        /**
         * Type of Azure resource to send data to. Must be set to one of: `LogicApp`, `EventHub` or `LogAnalytics`.
         */
        type: string;
    }

    export interface AutomationSource {
        /**
         * Type of data that will trigger this automation. Must be one of `Alerts`, `Assessments`, `SecureScoreControls`, `SecureScores` or `SubAssessments`. Note. assessments are also referred to as recommendations
         */
        eventSource: string;
        /**
         * A set of rules which evaluate upon event and data interception. This is defined in one or more `ruleSet` blocks as defined below.
         */
        ruleSets?: outputs.securitycenter.AutomationSourceRuleSet[];
    }

    export interface AutomationSourceRuleSet {
        /**
         * One or more `rule` blocks as defined below.
         */
        rules: outputs.securitycenter.AutomationSourceRuleSetRule[];
    }

    export interface AutomationSourceRuleSetRule {
        /**
         * A value that will be compared with the value in `propertyPath`.
         */
        expectedValue: string;
        /**
         * The comparison operator to use, must be one of: `Contains`, `EndsWith`, `Equals`, `GreaterThan`, `GreaterThanOrEqualTo`, `LesserThan`, `LesserThanOrEqualTo`, `NotEquals`, `StartsWith`
         */
        operator: string;
        /**
         * The JPath of the entity model property that should be checked.
         */
        propertyPath: string;
        /**
         * The data type of the compared operands, must be one of: `Integer`, `String`, `Boolean` or `Number`.
         */
        propertyType: string;
    }

}

export namespace sentinel {
    export interface AlertRuleScheduledEventGrouping {
        /**
         * The aggregation type of grouping the events.
         */
        aggregationMethod: string;
    }

    export interface AlertRuleScheduledIncidentConfiguration {
        /**
         * Whether to create an incident from alerts triggered by this Sentinel Scheduled Alert Rule?
         */
        createIncident: boolean;
        /**
         * A `grouping` block as defined below.
         */
        grouping: outputs.sentinel.AlertRuleScheduledIncidentConfigurationGrouping;
    }

    export interface AlertRuleScheduledIncidentConfigurationGrouping {
        /**
         * Enable grouping incidents created from alerts triggered by this Sentinel Scheduled Alert Rule. Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * The method used to group incidents. Possible values are `All`, `Custom` and `None`. Defaults to `None`.
         */
        entityMatchingMethod?: string;
        /**
         * A list of entity types to group by, only when the `entityMatchingMethod` is `Custom`. Possible values are `Account`, `Host`, `Url`, `Ip`.
         */
        groupBies?: string[];
        /**
         * Limit the group to alerts created within the lookback duration (in ISO 8601 duration format). Defaults to `PT5M`.
         */
        lookbackDuration?: string;
        /**
         * Whether to re-open closed matching incidents? Defaults to `false`.
         */
        reopenClosedIncidents?: boolean;
    }

    export interface GetAlertRuleTemplateScheduledTemplate {
        /**
         * The description of this Sentinel Scheduled Alert Rule Template.
         */
        description: string;
        /**
         * The query of this Sentinel Scheduled Alert Rule Template.
         */
        query: string;
        /**
         * The ISO 8601 timespan duration between two consecutive queries.
         */
        queryFrequency: string;
        /**
         * The ISO 8601 timespan duration, which determine the time period of the data covered by the query.
         */
        queryPeriod: string;
        /**
         * The alert severity of this Sentinel Scheduled Alert Rule Template.
         */
        severity: string;
        /**
         * A list of categories of attacks by which to classify the rule.
         */
        tactics: string[];
        /**
         * The alert trigger operator, combined with `triggerThreshold`, setting alert threshold of this Sentinel Scheduled Alert Rule Template.
         */
        triggerOperator: string;
        /**
         * The baseline number of query results generated, combined with `triggerOperator`, setting alert threshold of this Sentinel Scheduled Alert Rule Template.
         */
        triggerThreshold: number;
    }

    export interface GetAlertRuleTemplateSecurityIncidentTemplate {
        /**
         * The description of this Sentinel Scheduled Alert Rule Template.
         */
        description: string;
        /**
         * The Microsoft Security Service from where the alert will be generated.
         */
        productFilter: string;
    }

}

export namespace servicebus {
    export interface NamespaceNetworkRuleSetNetworkRule {
        /**
         * Should the ServiceBus Namespace Network Rule Set ignore missing Virtual Network Service Endpoint option in the Subnet? Defaults to `false`.
         */
        ignoreMissingVnetServiceEndpoint?: boolean;
        /**
         * The Subnet ID which should be able to access this ServiceBus Namespace.
         */
        subnetId: string;
    }

    export interface SubscriptionRuleCorrelationFilter {
        /**
         * Content type of the message.
         */
        contentType?: string;
        /**
         * Identifier of the correlation.
         */
        correlationId?: string;
        /**
         * Application specific label.
         */
        label?: string;
        /**
         * Identifier of the message.
         */
        messageId?: string;
        /**
         * A list of user defined properties to be included in the filter. Specified as a map of name/value pairs.
         */
        properties?: {[key: string]: string};
        /**
         * Address of the queue to reply to.
         */
        replyTo?: string;
        /**
         * Session identifier to reply to.
         */
        replyToSessionId?: string;
        /**
         * Session identifier.
         */
        sessionId?: string;
        /**
         * Address to send to.
         */
        to?: string;
    }

}

export namespace servicefabric {
    export interface ClusterAzureActiveDirectory {
        /**
         * The Azure Active Directory Client ID which should be used for the Client Application.
         */
        clientApplicationId: string;
        /**
         * The Azure Active Directory Cluster Application ID.
         */
        clusterApplicationId: string;
        /**
         * The Azure Active Directory Tenant ID.
         */
        tenantId: string;
    }

    export interface ClusterCertificate {
        /**
         * The Thumbprint of the Certificate.
         */
        thumbprint: string;
        /**
         * The Secondary Thumbprint of the Certificate.
         */
        thumbprintSecondary?: string;
        /**
         * The X509 Store where the Certificate Exists, such as `My`.
         */
        x509StoreName: string;
    }

    export interface ClusterCertificateCommonNames {
        /**
         * A `commonNames` block as defined below.
         */
        commonNames: outputs.servicefabric.ClusterCertificateCommonNamesCommonName[];
        /**
         * The X509 Store where the Certificate Exists, such as `My`.
         */
        x509StoreName: string;
    }

    export interface ClusterCertificateCommonNamesCommonName {
        /**
         * The common or subject name of the certificate.
         */
        certificateCommonName: string;
        /**
         * The Issuer Thumbprint of the Certificate.
         */
        certificateIssuerThumbprint?: string;
    }

    export interface ClusterClientCertificateCommonName {
        /**
         * The common or subject name of the certificate.
         */
        commonName: string;
        /**
         * Does the Client Certificate have Admin Access to the cluster? Non-admin clients can only perform read only operations on the cluster.
         */
        isAdmin: boolean;
        issuerThumbprint?: string;
    }

    export interface ClusterClientCertificateThumbprint {
        /**
         * Does the Client Certificate have Admin Access to the cluster? Non-admin clients can only perform read only operations on the cluster.
         */
        isAdmin: boolean;
        /**
         * The Thumbprint associated with the Client Certificate.
         */
        thumbprint: string;
    }

    export interface ClusterDiagnosticsConfig {
        /**
         * The Blob Endpoint of the Storage Account.
         */
        blobEndpoint: string;
        /**
         * The protected diagnostics storage key name, such as `StorageAccountKey1`.
         */
        protectedAccountKeyName: string;
        /**
         * The Queue Endpoint of the Storage Account.
         */
        queueEndpoint: string;
        /**
         * The name of the Storage Account where the Diagnostics should be sent to.
         */
        storageAccountName: string;
        /**
         * The Table Endpoint of the Storage Account.
         */
        tableEndpoint: string;
    }

    export interface ClusterFabricSetting {
        /**
         * The name of the Fabric Setting, such as `Security` or `Federation`.
         */
        name: string;
        /**
         * A map containing settings for the specified Fabric Setting.
         */
        parameters?: {[key: string]: string};
    }

    export interface ClusterNodeType {
        /**
         * A `applicationPorts` block as defined below.
         */
        applicationPorts: outputs.servicefabric.ClusterNodeTypeApplicationPorts;
        /**
         * The capacity tags applied to the nodes in the node type, the cluster resource manager uses these tags to understand how much resource a node has.
         */
        capacities?: {[key: string]: string};
        /**
         * The Port used for the Client Endpoint for this Node Type. Changing this forces a new resource to be created.
         */
        clientEndpointPort: number;
        /**
         * The Durability Level for this Node Type. Possible values include `Bronze`, `Gold` and `Silver`. Defaults to `Bronze`. Changing this forces a new resource to be created.
         */
        durabilityLevel?: string;
        /**
         * A `ephemeralPorts` block as defined below.
         */
        ephemeralPorts: outputs.servicefabric.ClusterNodeTypeEphemeralPorts;
        /**
         * The Port used for the HTTP Endpoint for this Node Type. Changing this forces a new resource to be created.
         */
        httpEndpointPort: number;
        /**
         * The number of nodes for this Node Type.
         */
        instanceCount: number;
        /**
         * Is this the Primary Node Type? Changing this forces a new resource to be created.
         */
        isPrimary: boolean;
        /**
         * The name of the Node Type. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * The placement tags applied to nodes in the node type, which can be used to indicate where certain services (workload) should run.
         */
        placementProperties?: {[key: string]: string};
        /**
         * The Port used for the Reverse Proxy Endpoint  for this Node Type. Changing this will upgrade the cluster.
         */
        reverseProxyEndpointPort?: number;
    }

    export interface ClusterNodeTypeApplicationPorts {
        /**
         * The end of the Application Port Range on this Node Type.
         */
        endPort: number;
        /**
         * The start of the Application Port Range on this Node Type.
         */
        startPort: number;
    }

    export interface ClusterNodeTypeEphemeralPorts {
        /**
         * The end of the Ephemeral Port Range on this Node Type.
         */
        endPort: number;
        /**
         * The start of the Ephemeral Port Range on this Node Type.
         */
        startPort: number;
    }

    export interface ClusterReverseProxyCertificate {
        /**
         * The Thumbprint of the Certificate.
         */
        thumbprint: string;
        /**
         * The Secondary Thumbprint of the Certificate.
         */
        thumbprintSecondary?: string;
        /**
         * The X509 Store where the Certificate Exists, such as `My`.
         */
        x509StoreName: string;
    }

    export interface ClusterReverseProxyCertificateCommonNames {
        /**
         * A `commonNames` block as defined below.
         */
        commonNames: outputs.servicefabric.ClusterReverseProxyCertificateCommonNamesCommonName[];
        /**
         * The X509 Store where the Certificate Exists, such as `My`.
         */
        x509StoreName: string;
    }

    export interface ClusterReverseProxyCertificateCommonNamesCommonName {
        /**
         * The common or subject name of the certificate.
         */
        certificateCommonName: string;
        /**
         * The Issuer Thumbprint of the Certificate.
         */
        certificateIssuerThumbprint?: string;
    }

    export interface ClusterUpgradePolicy {
        /**
         * A `deltaHealthPolicy` block as defined below
         */
        deltaHealthPolicy?: outputs.servicefabric.ClusterUpgradePolicyDeltaHealthPolicy;
        forceRestartEnabled?: boolean;
        /**
         * Specifies the duration, in "hh:mm:ss" string format, after which Service Fabric retries the health check if the previous health check fails. Defaults to `00:45:00`.
         */
        healthCheckRetryTimeout?: string;
        /**
         * Specifies the duration, in "hh:mm:ss" string format, that Service Fabric waits in order to verify that the cluster is stable before it continues to the next upgrade domain or completes the upgrade. This wait duration prevents undetected changes of health right after the health check is performed. Defaults to `00:01:00`.
         */
        healthCheckStableDuration?: string;
        /**
         * Specifies the duration, in "hh:mm:ss" string format, that Service Fabric waits before it performs the initial health check after it finishes the upgrade on the upgrade domain. Defaults to `00:00:30`.
         */
        healthCheckWaitDuration?: string;
        /**
         * A `healthPolicy` block as defined below
         */
        healthPolicy?: outputs.servicefabric.ClusterUpgradePolicyHealthPolicy;
        /**
         * Specifies the duration, in "hh:mm:ss" string format, that Service Fabric takes to upgrade a single upgrade domain. After this period, the upgrade fails. Defaults to `02:00:00`.
         */
        upgradeDomainTimeout?: string;
        /**
         * Specifies the duration, in "hh:mm:ss" string format, that Service Fabric waits for a replica set to reconfigure into a safe state, if it is not already in a safe state, before Service Fabric proceeds with the upgrade. Defaults to `10675199.02:48:05.4775807`.
         */
        upgradeReplicaSetCheckTimeout?: string;
        /**
         * Specifies the duration, in "hh:mm:ss" string format, that Service Fabric takes for the entire upgrade. After this period, the upgrade fails. Defaults to `12:00:00`.
         */
        upgradeTimeout?: string;
    }

    export interface ClusterUpgradePolicyDeltaHealthPolicy {
        maxDeltaUnhealthyApplicationsPercent?: number;
        maxDeltaUnhealthyNodesPercent?: number;
        maxUpgradeDomainDeltaUnhealthyNodesPercent?: number;
    }

    export interface ClusterUpgradePolicyHealthPolicy {
        maxUnhealthyApplicationsPercent?: number;
        maxUnhealthyNodesPercent?: number;
    }

    export interface MeshApplicationService {
        /**
         * Any number `codePackage` block as described below.
         */
        codePackages: outputs.servicefabric.MeshApplicationServiceCodePackage[];
        /**
         * The name of the service resource.
         */
        name: string;
        /**
         * The operating system required by the code in service. Valid values are `Linux` or `Windows`.
         */
        osType: string;
    }

    export interface MeshApplicationServiceCodePackage {
        /**
         * The Container image the code package will use.
         */
        imageName: string;
        /**
         * The name of the code package.
         */
        name: string;
        /**
         * A `resources` block as defined below.
         */
        resources: outputs.servicefabric.MeshApplicationServiceCodePackageResources;
    }

    export interface MeshApplicationServiceCodePackageResources {
        /**
         * A `limits` block as defined below.
         */
        limits?: outputs.servicefabric.MeshApplicationServiceCodePackageResourcesLimits;
        /**
         * A `requests` block as defined below.
         */
        requests: outputs.servicefabric.MeshApplicationServiceCodePackageResourcesRequests;
    }

    export interface MeshApplicationServiceCodePackageResourcesLimits {
        /**
         * The maximum number of CPU cores the container can use.
         */
        cpu: number;
        /**
         * The maximum memory request in GB the container can use.
         */
        memory: number;
    }

    export interface MeshApplicationServiceCodePackageResourcesRequests {
        /**
         * The minimum number of CPU cores the container requires.
         */
        cpu: number;
        /**
         * The minimum memory request in GB the container requires.
         */
        memory: number;
    }

}

export namespace signalr {
    export interface ServiceCor {
        /**
         * A list of origins which should be able to make cross-origin calls. `*` can be used to allow all calls.
         */
        allowedOrigins: string[];
    }

    export interface ServiceFeature {
        /**
         * The kind of Feature. Possible values are `EnableConnectivityLogs`, `EnableMessagingLogs`, and `ServiceMode`.
         */
        flag: string;
        /**
         * A value of a feature flag. Possible values are `Classic`, `Default` and `Serverless`.
         */
        value: string;
    }

    export interface ServiceSku {
        /**
         * Specifies the number of units associated with this SignalR service. Valid values are `1`, `2`, `5`, `10`, `20`, `50` and `100`.
         */
        capacity: number;
        /**
         * Specifies which tier to use. Valid values are `Free_F1` and `Standard_S1`.
         */
        name: string;
    }

    export interface ServiceUpstreamEndpoint {
        /**
         * The categories to match on, or `*` for all.
         */
        categoryPatterns: string[];
        /**
         * The events to match on, or `*` for all.
         */
        eventPatterns: string[];
        /**
         * The hubs to match on, or `*` for all.
         */
        hubPatterns: string[];
        /**
         * The upstream URL Template. This can be a url or a template such as `http://host.com/{hub}/api/{category}/{event}`.
         */
        urlTemplate: string;
    }

}

export namespace siterecovery {
    export interface ReplicatedVMManagedDisk {
        /**
         * Id of disk that should be replicated.
         */
        diskId: string;
        /**
         * Storage account that should be used for caching.
         */
        stagingStorageAccountId: string;
        /**
         * The Disk Encryption Set that the Managed Disk will be associated with.
         */
        targetDiskEncryptionSetId?: string;
        /**
         * What type should the disk be when a failover is done.
         */
        targetDiskType: string;
        /**
         * What type should the disk be that holds the replication data.
         */
        targetReplicaDiskType: string;
        /**
         * Resource group disk should belong to when a failover is done.
         */
        targetResourceGroupId: string;
    }

    export interface ReplicatedVMNetworkInterface {
        /**
         * Id of the public IP object to use when a failover is done.
         */
        recoveryPublicIpAddressId?: string;
        /**
         * Id source network interface.
         */
        sourceNetworkInterfaceId: string;
        /**
         * Static IP to assign when a failover is done.
         */
        targetStaticIp?: string;
        /**
         * Name of the subnet to to use when a failover is done.
         */
        targetSubnetName?: string;
    }

}

export namespace sql {
    export interface DatabaseExtendedAuditingPolicy {
        logMonitoringEnabled?: boolean;
        /**
         * Specifies the number of days to retain logs for in the storage account.
         */
        retentionInDays?: number;
        /**
         * Specifies the access key to use for the auditing storage account.
         */
        storageAccountAccessKey?: string;
        /**
         * Specifies whether `storageAccountAccessKey` value is the storage's secondary key.
         */
        storageAccountAccessKeyIsSecondary?: boolean;
        /**
         * Specifies the blob storage endpoint (e.g. https://MyAccount.blob.core.windows.net).
         */
        storageEndpoint?: string;
    }

    export interface DatabaseImport {
        /**
         * Specifies the name of the SQL administrator.
         */
        administratorLogin: string;
        /**
         * Specifies the password of the SQL administrator.
         */
        administratorLoginPassword: string;
        /**
         * Specifies the type of authentication used to access the server. Valid values are `SQL` or `ADPassword`.
         */
        authenticationType: string;
        /**
         * Specifies the type of import operation being performed. The only allowable value is `Import`.
         */
        operationMode?: string;
        /**
         * Specifies the access key for the storage account.
         */
        storageKey: string;
        /**
         * Specifies the type of access key for the storage account. Valid values are `StorageAccessKey` or `SharedAccessKey`.
         */
        storageKeyType: string;
        /**
         * Specifies the blob URI of the .bacpac file.
         */
        storageUri: string;
    }

    export interface DatabaseThreatDetectionPolicy {
        /**
         * Specifies a list of alerts which should be disabled. Possible values include `Access_Anomaly`, `Sql_Injection` and `Sql_Injection_Vulnerability`.
         */
        disabledAlerts?: string[];
        /**
         * Should the account administrators be emailed when this alert is triggered?
         */
        emailAccountAdmins?: string;
        /**
         * A list of email addresses which alerts should be sent to.
         */
        emailAddresses?: string[];
        /**
         * Specifies the number of days to keep in the Threat Detection audit logs.
         */
        retentionDays?: number;
        /**
         * The State of the Policy. Possible values are `Enabled`, `Disabled` or `New`.
         */
        state?: string;
        /**
         * Specifies the identifier key of the Threat Detection audit storage account. Required if `state` is `Enabled`.
         */
        storageAccountAccessKey?: string;
        /**
         * Specifies the blob storage endpoint (e.g. https://MyAccount.blob.core.windows.net). This blob storage will hold all Threat Detection audit logs. Required if `state` is `Enabled`.
         */
        storageEndpoint?: string;
        /**
         * @deprecated This field is now non-functional and thus will be removed in version 3.0 of the Azure Provider
         */
        useServerDefault?: string;
    }

    export interface FailoverGroupPartnerServer {
        /**
         * the SQL server ID
         */
        id: string;
        /**
         * the location of the failover group.
         */
        location: string;
        /**
         * local replication role of the failover group instance.
         */
        role: string;
    }

    export interface FailoverGroupReadWriteEndpointFailoverPolicy {
        /**
         * Applies only if `mode` is `Automatic`. The grace period in minutes before failover with data loss is attempted
         */
        graceMinutes?: number;
        /**
         * the failover mode. Possible values are `Manual`, `Automatic`
         */
        mode: string;
    }

    export interface FailoverGroupReadonlyEndpointFailoverPolicy {
        /**
         * Failover policy for the read-only endpoint. Possible values are `Enabled`, and `Disabled`
         */
        mode: string;
    }

    export interface GetServerIdentity {
        /**
         * The ID of the Principal (Client) in Azure Active Directory.
         */
        principalId: string;
        /**
         * The ID of the Azure Active Directory Tenant.
         */
        tenantId: string;
        /**
         * The identity type of the SQL Server.
         */
        type: string;
    }

    export interface SqlServerExtendedAuditingPolicy {
        /**
         * (Optional) Enable audit events to Azure Monitor? To enable server audit events to Azure Monitor, please enable its master database audit events to Azure Monitor.
         */
        logMonitoringEnabled?: boolean;
        /**
         * (Optional) Specifies the number of days to retain logs for in the storage account.
         */
        retentionInDays?: number;
        /**
         * (Optional)  Specifies the access key to use for the auditing storage account.
         */
        storageAccountAccessKey?: string;
        /**
         * (Optional) Specifies whether `storageAccountAccessKey` value is the storage's secondary key.
         */
        storageAccountAccessKeyIsSecondary?: boolean;
        /**
         * (Optional) Specifies the blob storage endpoint (e.g. https://MyAccount.blob.core.windows.net).
         */
        storageEndpoint?: string;
    }

    export interface SqlServerIdentity {
        /**
         * The Principal ID for the Service Principal associated with the Identity of this SQL Server.
         */
        principalId: string;
        /**
         * The Tenant ID for the Service Principal associated with the Identity of this SQL Server.
         */
        tenantId: string;
        /**
         * Specifies the identity type of the Microsoft SQL Server. At this time the only allowed value is `SystemAssigned`.
         */
        type: string;
    }

}

export namespace storage {
    export interface AccountAzureFilesAuthentication {
        /**
         * A `activeDirectory` block as defined below. Required when `directoryType` is `AD`.
         */
        activeDirectory: outputs.storage.AccountAzureFilesAuthenticationActiveDirectory;
        /**
         * Specifies the directory service used. Possible values are `AADDS` and `AD`.
         */
        directoryType: string;
    }

    export interface AccountAzureFilesAuthenticationActiveDirectory {
        /**
         * Specifies the domain GUID.
         */
        domainGuid: string;
        /**
         * Specifies the primary domain that the AD DNS server is authoritative for.
         */
        domainName: string;
        /**
         * Specifies the security identifier (SID).
         */
        domainSid: string;
        /**
         * Specifies the Active Directory forest.
         */
        forestName: string;
        /**
         * Specifies the NetBIOS domain name.
         */
        netbiosDomainName: string;
        /**
         * Specifies the security identifier (SID) for Azure Storage.
         */
        storageSid: string;
    }

    export interface AccountBlobProperties {
        /**
         * Is the blob service properties for change feed events enabled? Default to `false`.
         */
        changeFeedEnabled?: boolean;
        /**
         * A `containerDeleteRetentionPolicy` block as defined below.
         */
        containerDeleteRetentionPolicy?: outputs.storage.AccountBlobPropertiesContainerDeleteRetentionPolicy;
        /**
         * A `corsRule` block as defined below.
         */
        corsRules?: outputs.storage.AccountBlobPropertiesCorsRule[];
        /**
         * The API Version which should be used by default for requests to the Data Plane API if an incoming request doesn't specify an API Version. Defaults to `2020-06-12`.
         */
        defaultServiceVersion: string;
        /**
         * A `deleteRetentionPolicy` block as defined below.
         */
        deleteRetentionPolicy?: outputs.storage.AccountBlobPropertiesDeleteRetentionPolicy;
        /**
         * Is the last access time based tracking enabled? Default to `false`.
         */
        lastAccessTimeEnabled?: boolean;
        /**
         * Is versioning enabled? Default to `false`.
         */
        versioningEnabled?: boolean;
    }

    export interface AccountBlobPropertiesContainerDeleteRetentionPolicy {
        /**
         * Specifies the number of days that the container should be retained, between `1` and `365` days. Defaults to `7`.
         */
        days?: number;
    }

    export interface AccountBlobPropertiesCorsRule {
        /**
         * A list of headers that are allowed to be a part of the cross-origin request.
         */
        allowedHeaders: string[];
        /**
         * A list of http headers that are allowed to be executed by the origin. Valid options are
         * `DELETE`, `GET`, `HEAD`, `MERGE`, `POST`, `OPTIONS`, `PUT` or `PATCH`.
         */
        allowedMethods: string[];
        /**
         * A list of origin domains that will be allowed by CORS.
         */
        allowedOrigins: string[];
        /**
         * A list of response headers that are exposed to CORS clients.
         */
        exposedHeaders: string[];
        /**
         * The number of seconds the client should cache a preflight response.
         */
        maxAgeInSeconds: number;
    }

    export interface AccountBlobPropertiesDeleteRetentionPolicy {
        /**
         * Specifies the number of days that the blob should be retained, between `1` and `365` days. Defaults to `7`.
         */
        days?: number;
    }

    export interface AccountCustomDomain {
        /**
         * The Custom Domain Name to use for the Storage Account, which will be validated by Azure.
         */
        name: string;
        /**
         * Should the Custom Domain Name be validated by using indirect CNAME validation?
         */
        useSubdomain?: boolean;
    }

    export interface AccountIdentity {
        /**
         * A list of IDs for User Assigned Managed Identity resources to be assigned.
         */
        identityIds?: string[];
        /**
         * The Principal ID for the Service Principal associated with the Identity of this Storage Account.
         */
        principalId: string;
        /**
         * The Tenant ID for the Service Principal associated with the Identity of this Storage Account.
         */
        tenantId: string;
        /**
         * Specifies the identity type of the Storage Account. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned,UserAssigned` (to enable both).
         */
        type: string;
    }

    export interface AccountNetworkRules {
        /**
         * Specifies whether traffic is bypassed for Logging/Metrics/AzureServices. Valid options are
         * any combination of `Logging`, `Metrics`, `AzureServices`, or `None`.
         */
        bypasses: string[];
        /**
         * Specifies the default action of allow or deny when no other rules match. Valid options are `Deny` or `Allow`.
         */
        defaultAction: string;
        /**
         * List of public IP or IP ranges in CIDR Format. Only IPV4 addresses are allowed. Private IP address ranges (as defined in [RFC 1918](https://tools.ietf.org/html/rfc1918#section-3)) are not allowed.
         */
        ipRules: string[];
        /**
         * One or More `privateLinkAccess` block as defined below.
         */
        privateLinkAccesses?: outputs.storage.AccountNetworkRulesPrivateLinkAccess[];
        /**
         * A list of resource ids for subnets.
         */
        virtualNetworkSubnetIds: string[];
    }

    export interface AccountNetworkRulesPrivateLinkAccess {
        /**
         * The resource id of the resource access rule to be granted access.
         */
        endpointResourceId: string;
        /**
         * The tenant id of the resource of the resource access rule to be granted access. Defaults to the current tenant id.
         */
        endpointTenantId: string;
    }

    export interface AccountNetworkRulesPrivateLinkAccessRule {
        /**
         * The resource id of the resource access rule to be granted access.
         */
        endpointResourceId: string;
        /**
         * The tenant id of the resource of the resource access rule to be granted access. Defaults to the current tenant id.
         */
        endpointTenantId: string;
    }

    export interface AccountQueueProperties {
        /**
         * A `corsRule` block as defined above.
         */
        corsRules?: outputs.storage.AccountQueuePropertiesCorsRule[];
        /**
         * A `hourMetrics` block as defined below.
         */
        hourMetrics?: outputs.storage.AccountQueuePropertiesHourMetrics;
        /**
         * A `logging` block as defined below.
         */
        logging?: outputs.storage.AccountQueuePropertiesLogging;
        /**
         * A `minuteMetrics` block as defined below.
         */
        minuteMetrics?: outputs.storage.AccountQueuePropertiesMinuteMetrics;
    }

    export interface AccountQueuePropertiesCorsRule {
        /**
         * A list of headers that are allowed to be a part of the cross-origin request.
         */
        allowedHeaders: string[];
        /**
         * A list of http headers that are allowed to be executed by the origin. Valid options are
         * `DELETE`, `GET`, `HEAD`, `MERGE`, `POST`, `OPTIONS`, `PUT` or `PATCH`.
         */
        allowedMethods: string[];
        /**
         * A list of origin domains that will be allowed by CORS.
         */
        allowedOrigins: string[];
        /**
         * A list of response headers that are exposed to CORS clients.
         */
        exposedHeaders: string[];
        /**
         * The number of seconds the client should cache a preflight response.
         */
        maxAgeInSeconds: number;
    }

    export interface AccountQueuePropertiesHourMetrics {
        /**
         * Indicates whether hour metrics are enabled for the Queue service. Changing this forces a new resource.
         */
        enabled: boolean;
        /**
         * Indicates whether metrics should generate summary statistics for called API operations.
         */
        includeApis?: boolean;
        /**
         * Specifies the number of days that logs will be retained. Changing this forces a new resource.
         */
        retentionPolicyDays?: number;
        /**
         * The version of storage analytics to configure. Changing this forces a new resource.
         */
        version: string;
    }

    export interface AccountQueuePropertiesLogging {
        /**
         * Indicates whether all delete requests should be logged. Changing this forces a new resource.
         */
        delete: boolean;
        /**
         * Indicates whether all read requests should be logged. Changing this forces a new resource.
         */
        read: boolean;
        /**
         * Specifies the number of days that logs will be retained. Changing this forces a new resource.
         */
        retentionPolicyDays?: number;
        /**
         * The version of storage analytics to configure. Changing this forces a new resource.
         */
        version: string;
        /**
         * Indicates whether all write requests should be logged. Changing this forces a new resource.
         */
        write: boolean;
    }

    export interface AccountQueuePropertiesMinuteMetrics {
        /**
         * Indicates whether minute metrics are enabled for the Queue service. Changing this forces a new resource.
         */
        enabled: boolean;
        /**
         * Indicates whether metrics should generate summary statistics for called API operations.
         */
        includeApis?: boolean;
        /**
         * Specifies the number of days that logs will be retained. Changing this forces a new resource.
         */
        retentionPolicyDays?: number;
        /**
         * The version of storage analytics to configure. Changing this forces a new resource.
         */
        version: string;
    }

    export interface AccountRouting {
        /**
         * Specifies the kind of network routing opted by the user. Possible values are `InternetRouting` and `MicrosoftRouting`. Defaults to `MicrosoftRouting`.
         */
        choice?: string;
        /**
         * Should internet routing storage endpoints be published? Defaults to `false`.
         */
        publishInternetEndpoints?: boolean;
        /**
         * Should microsoft routing storage endpoints be published? Defaults to `false`.
         */
        publishMicrosoftEndpoints?: boolean;
    }

    export interface AccountShareProperties {
        /**
         * A `corsRule` block as defined below.
         */
        corsRules?: outputs.storage.AccountSharePropertiesCorsRule[];
        /**
         * A `retentionPolicy` block as defined below.
         */
        retentionPolicy?: outputs.storage.AccountSharePropertiesRetentionPolicy;
        /**
         * A `smb` block as defined below.
         */
        smb?: outputs.storage.AccountSharePropertiesSmb;
    }

    export interface AccountSharePropertiesCorsRule {
        /**
         * A list of headers that are allowed to be a part of the cross-origin request.
         */
        allowedHeaders: string[];
        /**
         * A list of http headers that are allowed to be executed by the origin. Valid options are
         * `DELETE`, `GET`, `HEAD`, `MERGE`, `POST`, `OPTIONS`, `PUT` or `PATCH`.
         */
        allowedMethods: string[];
        /**
         * A list of origin domains that will be allowed by CORS.
         */
        allowedOrigins: string[];
        /**
         * A list of response headers that are exposed to CORS clients.
         */
        exposedHeaders: string[];
        /**
         * The number of seconds the client should cache a preflight response.
         */
        maxAgeInSeconds: number;
    }

    export interface AccountSharePropertiesRetentionPolicy {
        /**
         * Specifies the number of days that the `azure.storage.Share` should be retained, between `1` and `365` days. Defaults to `7`.
         */
        days?: number;
    }

    export interface AccountSharePropertiesSmb {
        /**
         * A set of SMB authentication methods. Possible values are `NTLMv2`, and `Kerberos`.
         */
        authenticationTypes?: string[];
        /**
         * A set of SMB channel encryption. Possible values are `AES-128-CCM`, `AES-128-GCM`, and `AES-256-GCM`.
         */
        channelEncryptionTypes?: string[];
        /**
         * A set of Kerberos ticket encryption. Possible values are `RC4-HMAC`, and `AES-256`.
         */
        kerberosTicketEncryptionTypes?: string[];
        /**
         * A set of SMB protocol versions. Possible values are `SMB2.1`, `SMB3.0`, and `SMB3.1.1`.
         */
        versions?: string[];
    }

    export interface AccountStaticWebsite {
        /**
         * The absolute path to a custom webpage that should be used when a request is made which does not correspond to an existing file.
         */
        error404Document?: string;
        /**
         * The webpage that Azure Storage serves for requests to the root of a website or any subfolder. For example, index.html. The value is case-sensitive.
         */
        indexDocument?: string;
    }

    export interface BlobInventoryPolicyRule {
        /**
         * A `filter` block as defined above.
         */
        filter: outputs.storage.BlobInventoryPolicyRuleFilter;
        /**
         * The name which should be used for this Blob Inventory Policy Rule.
         */
        name: string;
    }

    export interface BlobInventoryPolicyRuleFilter {
        /**
         * A set of blob types. Possible values are `blockBlob`, `appendBlob`, and `pageBlob`. The storage account with `isHnsEnabled` is `true` doesn't support `pageBlob`.
         */
        blobTypes: string[];
        /**
         * Includes blob versions in blob inventory or not? Defaults to `false`.
         */
        includeBlobVersions?: boolean;
        /**
         * Includes blob snapshots in blob inventory or not? Defaults to `false`.
         */
        includeSnapshots?: boolean;
        /**
         * A set of strings for blob prefixes to be matched.
         */
        prefixMatches?: string[];
    }

    export interface DataLakeGen2FilesystemAce {
        /**
         * Specifies the Object ID of the Azure Active Directory User or Group that the entry relates to. Only valid for `user` or `group` entries.
         */
        id?: string;
        /**
         * Specifies the permissions for the entry in `rwx` form. For example, `rwx` gives full permissions but `r--` only gives read permissions.
         */
        permissions: string;
        /**
         * Specifies whether the ACE represents an `access` entry or a `default` entry. Default value is `access`.
         */
        scope?: string;
        /**
         * Specifies the type of entry. Can be `user`, `group`, `mask` or `other`.
         */
        type: string;
    }

    export interface DataLakeGen2PathAce {
        /**
         * Specifies the Object ID of the Azure Active Directory User or Group that the entry relates to. Only valid for `user` or `group` entries.
         */
        id?: string;
        /**
         * Specifies the permissions for the entry in `rwx` form. For example, `rwx` gives full permissions but `r--` only gives read permissions.
         */
        permissions: string;
        /**
         * Specifies whether the ACE represents an `access` entry or a `default` entry. Default value is `access`.
         */
        scope?: string;
        /**
         * Specifies the type of entry. Can be `user`, `group`, `mask` or `other`.
         */
        type: string;
    }

    export interface GetAccountBlobContainerSASPermissions {
        /**
         * Should Add permissions be enabled for this SAS?
         */
        add: boolean;
        /**
         * Should Create permissions be enabled for this SAS?
         */
        create: boolean;
        /**
         * Should Delete permissions be enabled for this SAS?
         */
        delete: boolean;
        /**
         * Should List permissions be enabled for this SAS?
         */
        list: boolean;
        /**
         * Should Read permissions be enabled for this SAS?
         */
        read: boolean;
        /**
         * Should Write permissions be enabled for this SAS?
         */
        write: boolean;
    }

    export interface GetAccountCustomDomain {
        /**
         * Specifies the name of the Storage Account
         */
        name: string;
    }

    export interface GetAccountSASPermissions {
        /**
         * Should Add permissions be enabled for this SAS?
         */
        add: boolean;
        /**
         * Should Create permissions be enabled for this SAS?
         */
        create: boolean;
        /**
         * Should Delete permissions be enabled for this SAS?
         */
        delete: boolean;
        /**
         * Should List permissions be enabled for this SAS?
         */
        list: boolean;
        /**
         * Should Process permissions be enabled for this SAS?
         */
        process: boolean;
        /**
         * Should Read permissions be enabled for this SAS?
         */
        read: boolean;
        /**
         * Should Update permissions be enabled for this SAS?
         */
        update: boolean;
        /**
         * Should Write permissions be enabled for this SAS?
         */
        write: boolean;
    }

    export interface GetAccountSASResourceTypes {
        /**
         * Should permission be granted to the container?
         */
        container: boolean;
        /**
         * Should permission be granted only to a specific object?
         */
        object: boolean;
        /**
         * Should permission be granted to the entire service?
         */
        service: boolean;
    }

    export interface GetAccountSASServices {
        /**
         * Should permission be granted to `blob` services within this storage account?
         */
        blob: boolean;
        /**
         * Should permission be granted to `file` services within this storage account?
         */
        file: boolean;
        /**
         * Should permission be granted to `queue` services within this storage account?
         */
        queue: boolean;
        /**
         * Should permission be granted to `table` services within this storage account?
         */
        table: boolean;
    }

    export interface GetPolicyRule {
        /**
         * An `actions` block as documented below.
         */
        actions: outputs.storage.GetPolicyRuleAction[];
        /**
         * Boolean to specify whether the rule is enabled.
         */
        enabled: boolean;
        /**
         * A `filter` block as documented below.
         */
        filters: outputs.storage.GetPolicyRuleFilter[];
        /**
         * The filter tag name used for tag based filtering for blob objects.
         */
        name: string;
    }

    export interface GetPolicyRuleAction {
        /**
         * A `baseBlob` block as documented below.
         */
        baseBlobs: outputs.storage.GetPolicyRuleActionBaseBlob[];
        /**
         * A `snapshot` block as documented below.
         */
        snapshots: outputs.storage.GetPolicyRuleActionSnapshot[];
        /**
         * A `version` block as documented below.
         */
        versions: outputs.storage.GetPolicyRuleActionVersion[];
    }

    export interface GetPolicyRuleActionBaseBlob {
        /**
         * The age in days after last modification to delete the blob.
         */
        deleteAfterDaysSinceModificationGreaterThan: number;
        /**
         * The age in days after last modification to tier blobs to archive storage. Supports blob currently at Hot or Cool tier.
         */
        tierToArchiveAfterDaysSinceModificationGreaterThan: number;
        /**
         * The age in days after last modification to tier blobs to cool storage. Supports blob currently at Hot tier.
         */
        tierToCoolAfterDaysSinceModificationGreaterThan: number;
    }

    export interface GetPolicyRuleActionSnapshot {
        /**
         * The age in days after creation to tier blob version to archive storage.
         */
        changeTierToArchiveAfterDaysSinceCreation: number;
        /**
         * The age in days after creation to tier blob version to cool storage.
         */
        changeTierToCoolAfterDaysSinceCreation: number;
        /**
         * The age in days after creation to delete the blob snapshot.
         */
        deleteAfterDaysSinceCreationGreaterThan: number;
    }

    export interface GetPolicyRuleActionVersion {
        /**
         * The age in days after creation to tier blob version to archive storage.
         */
        changeTierToArchiveAfterDaysSinceCreation: number;
        /**
         * The age in days after creation to tier blob version to cool storage.
         */
        changeTierToCoolAfterDaysSinceCreation: number;
        /**
         * The age in days after creation to delete the blob version.
         */
        deleteAfterDaysSinceCreation: number;
    }

    export interface GetPolicyRuleFilter {
        /**
         * An array of predefined values. Valid options are `blockBlob` and `appendBlob`.
         */
        blobTypes: string[];
        /**
         * A `matchBlobIndexTag` block as defined below. The block defines the blob index tag based filtering for blob objects.
         * ---
         */
        matchBlobIndexTags: outputs.storage.GetPolicyRuleFilterMatchBlobIndexTag[];
        /**
         * An array of strings for prefixes to be matched.
         */
        prefixMatches: string[];
    }

    export interface GetPolicyRuleFilterMatchBlobIndexTag {
        /**
         * The filter tag name used for tag based filtering for blob objects.
         */
        name: string;
        /**
         * The comparison operator which is used for object comparison and filtering. Possible value is `==`. Defaults to `==`.
         */
        operation: string;
        /**
         * The filter tag value used for tag based filtering for blob objects.
         */
        value: string;
    }

    export interface ManagementPolicyRule {
        /**
         * An `actions` block as documented below.
         */
        actions: outputs.storage.ManagementPolicyRuleActions;
        /**
         * Boolean to specify whether the rule is enabled.
         */
        enabled: boolean;
        /**
         * A `filter` block as documented below.
         */
        filters?: outputs.storage.ManagementPolicyRuleFilters;
        /**
         * A rule name can contain any combination of alpha numeric characters. Rule name is case-sensitive. It must be unique within a policy.
         */
        name: string;
    }

    export interface ManagementPolicyRuleActions {
        /**
         * A `baseBlob` block as documented below.
         */
        baseBlob?: outputs.storage.ManagementPolicyRuleActionsBaseBlob;
        /**
         * A `snapshot` block as documented below.
         */
        snapshot?: outputs.storage.ManagementPolicyRuleActionsSnapshot;
        /**
         * A `version` block as documented below.
         */
        version?: outputs.storage.ManagementPolicyRuleActionsVersion;
    }

    export interface ManagementPolicyRuleActionsBaseBlob {
        /**
         * The age in days after last modification to delete the blob. Must be between 0 and 99999.
         */
        deleteAfterDaysSinceModificationGreaterThan?: number;
        /**
         * The age in days after last modification to tier blobs to archive storage. Supports blob currently at Hot or Cool tier. Must be between 0 and 99999.
         */
        tierToArchiveAfterDaysSinceModificationGreaterThan?: number;
        /**
         * The age in days after last modification to tier blobs to cool storage. Supports blob currently at Hot tier. Must be between 0 and 99999.
         */
        tierToCoolAfterDaysSinceModificationGreaterThan?: number;
    }

    export interface ManagementPolicyRuleActionsSnapshot {
        /**
         * The age in days after creation to tier blob snapshot to archive storage. Must be between 0 and 99999.
         */
        changeTierToArchiveAfterDaysSinceCreation?: number;
        /**
         * The age in days after creation to tier blob snapshot to cool storage. Must be between 0 and 99999.
         */
        changeTierToCoolAfterDaysSinceCreation?: number;
        /**
         * The age in days after creation to delete the blob snapshot. Must be between 0 and 99999.
         */
        deleteAfterDaysSinceCreationGreaterThan?: number;
    }

    export interface ManagementPolicyRuleActionsVersion {
        /**
         * The age in days after creation to tier blob version to archive storage. Must be between 0 and 99999.
         */
        changeTierToArchiveAfterDaysSinceCreation?: number;
        /**
         * The age in days creation create to  tier blob version to cool storage. Must be between 0 and 99999.
         */
        changeTierToCoolAfterDaysSinceCreation?: number;
        /**
         * The age in days after creation to delete the blob version. Must be between 0 and 99999.
         */
        deleteAfterDaysSinceCreation?: number;
    }

    export interface ManagementPolicyRuleFilters {
        /**
         * An array of predefined values. Valid options are `blockBlob` and `appendBlob`.
         */
        blobTypes?: string[];
        /**
         * A `matchBlobIndexTag` block as defined below. The block defines the blob index tag based filtering for blob objects.
         */
        matchBlobIndexTags?: outputs.storage.ManagementPolicyRuleFiltersMatchBlobIndexTag[];
        /**
         * An array of strings for prefixes to be matched.
         */
        prefixMatches?: string[];
    }

    export interface ManagementPolicyRuleFiltersMatchBlobIndexTag {
        /**
         * The filter tag name used for tag based filtering for blob objects.
         */
        name: string;
        /**
         * The comparison operator which is used for object comparison and filtering. Possible value is `==`. Defaults to `==`.
         */
        operation?: string;
        /**
         * The filter tag value used for tag based filtering for blob objects.
         */
        value: string;
    }

    export interface ObjectReplicationRule {
        /**
         * The time after which the Block Blobs created will be copies to the destination. Possible values are `OnlyNewObjects`, `Everything` and time in RFC3339 format: `2006-01-02T15:04:00Z`.
         */
        copyBlobsCreatedAfter?: string;
        /**
         * The destination storage container name. Changing this forces a new Storage Object Replication to be created.
         */
        destinationContainerName: string;
        /**
         * Specifies a list of filters prefixes, the blobs whose names begin with which will be replicated.
         */
        filterOutBlobsWithPrefixes?: string[];
        name: string;
        /**
         * The source storage container name. Changing this forces a new Storage Object Replication to be created.
         */
        sourceContainerName: string;
    }

    export interface ShareAcl {
        /**
         * An `accessPolicy` block as defined below.
         */
        accessPolicies?: outputs.storage.ShareAclAccessPolicy[];
        /**
         * The ID which should be used for this Shared Identifier.
         */
        id: string;
    }

    export interface ShareAclAccessPolicy {
        /**
         * The time at which this Access Policy should be valid until, in [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) format.
         */
        expiry?: string;
        /**
         * The permissions which should be associated with this Shared Identifier. Possible value is combination of `r` (read), `w` (write), `d` (delete), and `l` (list).
         */
        permissions: string;
        /**
         * The time at which this Access Policy should be valid from, in [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) format.
         */
        start?: string;
    }

    export interface TableAcl {
        /**
         * An `accessPolicy` block as defined below.
         */
        accessPolicies?: outputs.storage.TableAclAccessPolicy[];
        /**
         * The ID which should be used for this Shared Identifier.
         */
        id: string;
    }

    export interface TableAclAccessPolicy {
        /**
         * The ISO8061 UTC time at which this Access Policy should be valid until.
         */
        expiry: string;
        /**
         * The permissions which should associated with this Shared Identifier.
         */
        permissions: string;
        /**
         * The ISO8061 UTC time at which this Access Policy should be valid from.
         */
        start: string;
    }
}

export namespace streamanalytics {
    export interface FunctionJavaScriptUDFInput {
        /**
         * The Data Type for the Input Argument of this JavaScript Function. Possible values include `array`, `any`, `bigint`, `datetime`, `float`, `nvarchar(max)` and `record`.
         */
        type: string;
    }

    export interface FunctionJavaScriptUDFOutput {
        /**
         * The Data Type output from this JavaScript Function. Possible values include `array`, `any`, `bigint`, `datetime`, `float`, `nvarchar(max)` and `record`.
         */
        type: string;
    }

    export interface GetJobIdentity {
        /**
         * The ID of the Principal (Client) in Azure Active Directory.
         */
        principalId: string;
        /**
         * The ID of the Azure Active Directory Tenant.
         */
        tenantId: string;
        /**
         * The type of identity used for the Stream Analytics Job.
         */
        type: string;
    }

    export interface JobIdentity {
        /**
         * The ID of the Principal (Client) in Azure Active Directory.
         */
        principalId: string;
        /**
         * The ID of the Azure Active Directory Tenant.
         */
        tenantId: string;
        /**
         * The type of identity used for the Stream Analytics Job. Possible values are `SystemAssigned`.
         */
        type: string;
    }

    export interface OutputBlobSerialization {
        /**
         * The encoding of the incoming data in the case of input and the encoding of outgoing data in the case of output. It currently can only be set to `UTF8`.
         */
        encoding?: string;
        /**
         * The delimiter that will be used to separate comma-separated value (CSV) records. Possible values are ` ` (space), `,` (comma), `   ` (tab), `|` (pipe) and `;`.
         */
        fieldDelimiter?: string;
        /**
         * Specifies the format of the JSON the output will be written in. Possible values are `Array` and `LineSeparated`.
         */
        format?: string;
        /**
         * The serialization format used for outgoing data streams. Possible values are `Avro`, `Csv` and `Json`.
         */
        type: string;
    }

    export interface OutputEventHubSerialization {
        /**
         * The encoding of the incoming data in the case of input and the encoding of outgoing data in the case of output. It currently can only be set to `UTF8`.
         */
        encoding?: string;
        /**
         * The delimiter that will be used to separate comma-separated value (CSV) records. Possible values are ` ` (space), `,` (comma), `   ` (tab), `|` (pipe) and `;`.
         */
        fieldDelimiter?: string;
        /**
         * Specifies the format of the JSON the output will be written in. Possible values are `Array` and `LineSeparated`.
         */
        format?: string;
        /**
         * The serialization format used for outgoing data streams. Possible values are `Avro`, `Csv` and `Json`.
         */
        type: string;
    }

    export interface OutputServiceBusQueueSerialization {
        /**
         * The encoding of the incoming data in the case of input and the encoding of outgoing data in the case of output. It currently can only be set to `UTF8`.
         */
        encoding?: string;
        /**
         * The delimiter that will be used to separate comma-separated value (CSV) records. Possible values are ` ` (space), `,` (comma), `   ` (tab), `|` (pipe) and `;`.
         */
        fieldDelimiter?: string;
        /**
         * Specifies the format of the JSON the output will be written in. Possible values are `Array` and `LineSeparated`.
         */
        format?: string;
        /**
         * The serialization format used for outgoing data streams. Possible values are `Avro`, `Csv` and `Json`.
         */
        type: string;
    }

    export interface OutputServicebusTopicSerialization {
        /**
         * The encoding of the incoming data in the case of input and the encoding of outgoing data in the case of output. It currently can only be set to `UTF8`.
         */
        encoding?: string;
        /**
         * The delimiter that will be used to separate comma-separated value (CSV) records. Possible values are ` ` (space), `,` (comma), `   ` (tab), `|` (pipe) and `;`.
         */
        fieldDelimiter?: string;
        /**
         * Specifies the format of the JSON the output will be written in. Possible values are `Array` and `LineSeparated`.
         */
        format?: string;
        /**
         * The serialization format used for outgoing data streams. Possible values are `Avro`, `Csv` and `Json`.
         */
        type: string;
    }

    export interface ReferenceInputBlobSerialization {
        /**
         * The encoding of the incoming data in the case of input and the encoding of outgoing data in the case of output. It currently can only be set to `UTF8`.
         */
        encoding?: string;
        /**
         * The delimiter that will be used to separate comma-separated value (CSV) records. Possible values are ` ` (space), `,` (comma), `	` (tab), `|` (pipe) and `;`.
         */
        fieldDelimiter?: string;
        /**
         * The serialization format used for the reference data. Possible values are `Avro`, `Csv` and `Json`.
         */
        type: string;
    }

    export interface StreamInputBlobSerialization {
        /**
         * The encoding of the incoming data in the case of input and the encoding of outgoing data in the case of output. It currently can only be set to `UTF8`.
         */
        encoding?: string;
        /**
         * The delimiter that will be used to separate comma-separated value (CSV) records. Possible values are ` ` (space), `,` (comma), `   ` (tab), `|` (pipe) and `;`.
         */
        fieldDelimiter?: string;
        /**
         * The serialization format used for incoming data streams. Possible values are `Avro`, `Csv` and `Json`.
         */
        type: string;
    }

    export interface StreamInputEventHubSerialization {
        /**
         * The encoding of the incoming data in the case of input and the encoding of outgoing data in the case of output. It currently can only be set to `UTF8`.
         */
        encoding?: string;
        /**
         * The delimiter that will be used to separate comma-separated value (CSV) records. Possible values are ` ` (space), `,` (comma), `   ` (tab), `|` (pipe) and `;`.
         */
        fieldDelimiter?: string;
        /**
         * The serialization format used for incoming data streams. Possible values are `Avro`, `Csv` and `Json`.
         */
        type: string;
    }

    export interface StreamInputIotHubSerialization {
        /**
         * The encoding of the incoming data in the case of input and the encoding of outgoing data in the case of output. It currently can only be set to `UTF8`.
         */
        encoding?: string;
        /**
         * The delimiter that will be used to separate comma-separated value (CSV) records. Possible values are ` ` (space), `,` (comma), `   ` (tab), `|` (pipe) and `;`.
         */
        fieldDelimiter?: string;
        /**
         * The serialization format used for incoming data streams. Possible values are `Avro`, `Csv` and `Json`.
         */
        type: string;
    }

}

export namespace synapse {
    export interface GetWorkspaceIdentity {
        /**
         * The Principal ID for the Service Principal associated with the Managed Service Identity of this Synapse Workspace.
         */
        principalId: string;
        /**
         * The Tenant ID for the Service Principal associated with the Managed Service Identity of this Synapse Workspace.
         */
        tenantId: string;
        /**
         * The Identity Type for the Service Principal associated with the Managed Service Identity of this Synapse Workspace.
         */
        type: string;
    }

    export interface SparkPoolAutoPause {
        /**
         * Number of minutes of idle time before the Spark Pool is automatically paused. Must be between `5` and `10080`.
         */
        delayInMinutes: number;
    }

    export interface SparkPoolAutoScale {
        /**
         * The maximum number of nodes the Spark Pool can support. Must be between `3` and `200`.
         */
        maxNodeCount: number;
        /**
         * The minimum number of nodes the Spark Pool can support. Must be between `3` and `200`.
         */
        minNodeCount: number;
    }

    export interface SparkPoolLibraryRequirement {
        /**
         * The content of library requirements.
         */
        content: string;
        /**
         * The name of the library requirements file.
         */
        filename: string;
    }

    export interface SqlPoolRestore {
        /**
         * Specifies the Snapshot time to restore. Changing this forces a new Synapse Sql Pool to be created.
         */
        pointInTime: string;
        /**
         * The ID of the Synapse Sql Pool or Sql Database which is to restore. Changing this forces a new Synapse Sql Pool to be created.
         */
        sourceDatabaseId: string;
    }

    export interface WorkspaceAadAdmin {
        /**
         * The login name of the Azure AD Administrator of this Synapse Workspace.
         */
        login: string;
        /**
         * The object id of the Azure AD Administrator of this Synapse Workspace.
         */
        objectId: string;
        /**
         * The tenant id of the Azure AD Administrator of this Synapse Workspace.
         */
        tenantId: string;
    }

    export interface WorkspaceAzureDevopsRepo {
        /**
         * Specifies the Azure DevOps account name.
         */
        accountName: string;
        /**
         * Specifies the collaboration branch of the repository to get code from.
         */
        branchName: string;
        /**
         * Specifies the name of the Azure DevOps project.
         */
        projectName: string;
        /**
         * Specifies the name of the git repository.
         */
        repositoryName: string;
        /**
         * Specifies the root folder within the repository. Set to `/` for the top level.
         */
        rootFolder: string;
    }

    export interface WorkspaceGithubRepo {
        /**
         * Specifies the GitHub account name.
         */
        accountName: string;
        /**
         * Specifies the collaboration branch of the repository to get code from.
         */
        branchName: string;
        /**
         * Specifies the GitHub Enterprise host name. For example: https://github.mydomain.com.
         */
        gitUrl?: string;
        /**
         * Specifies the name of the git repository.
         */
        repositoryName: string;
        /**
         * Specifies the root folder within the repository. Set to `/` for the top level.
         */
        rootFolder: string;
    }

    export interface WorkspaceIdentity {
        /**
         * The Principal ID for the Service Principal associated with the Managed Service Identity of this Synapse Workspace.
         */
        principalId: string;
        /**
         * The tenant id of the Azure AD Administrator of this Synapse Workspace.
         */
        tenantId: string;
        /**
         * The Identity Type for the Service Principal associated with the Managed Service Identity of this Synapse Workspace.
         */
        type: string;
    }

}

export namespace trafficmanager {
    export interface EndpointCustomHeader {
        /**
         * The name of the custom header.
         */
        name: string;
        /**
         * The value of custom header. Applicable for Http and Https protocol.
         */
        value: string;
    }

    export interface EndpointSubnet {
        /**
         * The First IP....
         */
        first: string;
        /**
         * The Last IP...
         */
        last?: string;
        /**
         * The Scope...
         */
        scope?: number;
    }

    export interface ProfileDnsConfig {
        /**
         * The relative domain name, this is combined with the domain name used by Traffic Manager to form the FQDN which is exported as documented below. Changing this forces a new resource to be created.
         */
        relativeName: string;
        /**
         * The TTL value of the Profile used by Local DNS resolvers and clients.
         */
        ttl: number;
    }

    export interface ProfileMonitorConfig {
        /**
         * One or more `customHeader` blocks as defined below.
         */
        customHeaders?: outputs.trafficmanager.ProfileMonitorConfigCustomHeader[];
        /**
         * A list of status code ranges in the format of `100-101`.
         */
        expectedStatusCodeRanges?: string[];
        /**
         * The interval used to check the endpoint health from a Traffic Manager probing agent. You can specify two values here: `30` (normal probing) and `10` (fast probing). The default value is `30`.
         */
        intervalInSeconds?: number;
        /**
         * The path used by the monitoring checks. Required when `protocol` is set to `HTTP` or `HTTPS` - cannot be set when `protocol` is set to `TCP`.
         */
        path?: string;
        /**
         * The port number used by the monitoring checks.
         */
        port: number;
        /**
         * The protocol used by the monitoring checks, supported values are `HTTP`, `HTTPS` and `TCP`.
         */
        protocol: string;
        /**
         * The amount of time the Traffic Manager probing agent should wait before considering that check a failure when a health check probe is sent to the endpoint. If `intervalInSeconds` is set to `30`, then `timeoutInSeconds` can be between `5` and `10`. The default value is `10`. If `intervalInSeconds` is set to `10`, then valid values are between `5` and `9` and `timeoutInSeconds` is required.
         */
        timeoutInSeconds?: number;
        /**
         * The number of failures a Traffic Manager probing agent tolerates before marking that endpoint as unhealthy. Valid values are between `0` and `9`. The default value is `3`
         */
        toleratedNumberOfFailures?: number;
    }

    export interface ProfileMonitorConfigCustomHeader {
        /**
         * The name of the custom header.
         */
        name: string;
        /**
         * The value of custom header. Applicable for Http and Https protocol.
         */
        value: string;
    }

}

export namespace waf {
    export interface PolicyCustomRule {
        /**
         * Type of action.
         */
        action: string;
        /**
         * One or more `matchConditions` blocks as defined below.
         */
        matchConditions: outputs.waf.PolicyCustomRuleMatchCondition[];
        /**
         * Gets name of the resource that is unique within a policy. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Describes priority of the rule. Rules with a lower value will be evaluated before rules with a higher value.
         */
        priority: number;
        /**
         * Describes the type of rule.
         */
        ruleType: string;
    }

    export interface PolicyCustomRuleMatchCondition {
        /**
         * A list of match values.
         */
        matchValues: string[];
        /**
         * One or more `matchVariables` blocks as defined below.
         */
        matchVariables: outputs.waf.PolicyCustomRuleMatchConditionMatchVariable[];
        /**
         * Describes if this is negate condition or not
         */
        negationCondition?: boolean;
        /**
         * Describes operator to be matched.
         */
        operator: string;
        /**
         * A list of transformations to do before the match is attempted.
         */
        transforms?: string[];
    }

    export interface PolicyCustomRuleMatchConditionMatchVariable {
        /**
         * Describes field of the matchVariable collection
         */
        selector?: string;
        /**
         * The name of the Match Variable
         */
        variableName: string;
    }

    export interface PolicyManagedRules {
        /**
         * One or more `exclusion` block defined below.
         */
        exclusions?: outputs.waf.PolicyManagedRulesExclusion[];
        /**
         * One or more `managedRuleSet` block defined below.
         */
        managedRuleSets: outputs.waf.PolicyManagedRulesManagedRuleSet[];
    }

    export interface PolicyManagedRulesExclusion {
        /**
         * The name of the Match Variable. Possible values: `RequestArgNames`, `RequestCookieNames`, `RequestHeaderNames`.
         */
        matchVariable: string;
        /**
         * Describes field of the matchVariable collection.
         */
        selector: string;
        /**
         * Describes operator to be matched. Possible values: `Contains`, `EndsWith`, `Equals`, `EqualsAny`, `StartsWith`.
         */
        selectorMatchOperator: string;
    }

    export interface PolicyManagedRulesManagedRuleSet {
        /**
         * One or more `ruleGroupOverride` block defined below.
         */
        ruleGroupOverrides?: outputs.waf.PolicyManagedRulesManagedRuleSetRuleGroupOverride[];
        /**
         * The rule set type. Possible values: `Microsoft_BotManagerRuleSet` and `OWASP`.
         */
        type?: string;
        /**
         * The rule set version. Possible values: `0.1`, `1.0`, `2.2.9`, `3.0`, `3.1` and `3.2`.
         */
        version: string;
    }

    export interface PolicyManagedRulesManagedRuleSetRuleGroupOverride {
        /**
         * One or more Rule ID's
         */
        disabledRules: string[];
        /**
         * The name of the Rule Group
         */
        ruleGroupName: string;
    }

    export interface PolicyPolicySettings {
        /**
         * Describes if the policy is in enabled state or disabled state. Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * The File Upload Limit in MB. Accepted values are in the range `1` to `750`. Defaults to `100`.
         */
        fileUploadLimitInMb?: number;
        /**
         * The Maximum Request Body Size in KB.  Accepted values are in the range `8` to `128`. Defaults to `128`.
         */
        maxRequestBodySizeInKb?: number;
        /**
         * Describes if it is in detection mode or prevention mode at the policy level. Defaults to `Prevention`.
         */
        mode?: string;
        /**
         * Is Request Body Inspection enabled? Defaults to `true`.
         */
        requestBodyCheck?: boolean;
    }

}
